new_code_raw	old_code_raw	new_comment_raw	old_comment_raw	label	pre_label	AST_level	line_counts	new_code_token_num
private static EmbeddedElasticsearchNode create(Settings settings) { // ensure PainlessPlugin is installed or otherwise scripted fields would not work Node node = new LocalNode(settings, Arrays.asList(Netty4Plugin.class, PainlessPlugin.class)); return new EmbeddedElasticsearchNode(node); }	"  public static EmbeddedElasticsearchNode create() {
    File data = Files.createTempDir();
    data.deleteOnExit();
    File home = Files.createTempDir();
    home.deleteOnExit();

    Settings settings = Settings.builder()
        .put(""node.name"", ""fake-elastic"")
        .put(""path.home"", home.getAbsolutePath())
        .put(""path.data"", data.getAbsolutePath())
        .put(""http.type"", ""netty4"")
        .put(""network.host"", ""localhost"")
        .build();

    return create(settings);
  }
"	Creates an instance with existing settings	Creates elastic node as single member of a cluster.	1	0	8	6	48
"private byte[] marshalAggregatorValues(long superstep) { if (superstep == INPUT_SUPERSTEP) { return new byte[0]; } ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); DataOutputStream output = new DataOutputStream(outputStream); for (Entry<String, AggregatorWrapper<Writable>> entry : getAggregatorMap().entrySet()) { if (entry.getValue().isChanged()) { try { output.writeUTF(entry.getKey()); entry.getValue().getCurrentAggregatedValue().write(output); } catch (IOException e) { throw new IllegalStateException(""Failed to marshall aggregator "" + ""with IOException "" + entry.getKey(), e); } } } if (LOG.isInfoEnabled()) { LOG.info( ""marshalAggregatorValues: Finished assembling aggregator values""); } return outputStream.toByteArray(); }"	"  private JSONArray marshalAggregatorValues(long superstep) {
    JSONArray aggregatorArray = new JSONArray();
    if ((superstep == INPUT_SUPERSTEP) || (aggregatorInUse.size() == 0)) {
      return aggregatorArray;
    }

    for (String name : aggregatorInUse) {
      try {
        Aggregator<Writable> aggregator = getAggregatorMap().get(name);
        ByteArrayOutputStream outputStream =
            new ByteArrayOutputStream();
        DataOutput output = new DataOutputStream(outputStream);
        aggregator.getAggregatedValue().write(output);

        JSONObject aggregatorObj = new JSONObject();
        aggregatorObj.put(AGGREGATOR_NAME_KEY, name);
        aggregatorObj.put(AGGREGATOR_CLASS_NAME_KEY,
            aggregator.getClass().getName());
        aggregatorObj.put(
            AGGREGATOR_VALUE_KEY,
            Base64.encodeBytes(outputStream.toByteArray()));
        aggregatorArray.put(aggregatorObj);
        if (LOG.isInfoEnabled()) {
          LOG.info(""marshalAggregatorValues: "" +
              ""Found aggregatorObj "" +
              aggregatorObj + "", value ("" +
              aggregator.getAggregatedValue() + "")"");
        }
      } catch (JSONException e) {
        throw new IllegalStateException(""Failed to marshall aggregator "" +
            ""with JSONException "" + name, e);
      } catch (IOException e) {
        throw new IllegalStateException(""Failed to marshall aggregator "" +
            ""with IOException "" + name, e);
      }
    }

    if (LOG.isInfoEnabled()) {
      LOG.info(""marshalAggregatorValues: Finished assembling "" +
          ""aggregator values in JSONArray - "" + aggregatorArray);
    }
    aggregatorInUse.clear();
    return aggregatorArray;
  }
"	Marshal the aggregator values of the worker to a byte array that will later be aggregated by master.	Marshal the aggregator values of to a JSONArray that will later be aggregated by master.	1	0	13	28	153
public static List<RelDataType> getFieldTypeList(final RelDataType type) { return Lists.transform(type.getFieldList(), GET_TYPE); }	"  public static List<RelDataType> getFieldTypeList(final RelDataType type) {
    return new AbstractList<RelDataType>() {
      public RelDataType get(int index) {
        return type.getFieldList().get(index).getType();
      }

      public int size() {
        return type.getFieldCount();
      }
    };
  }
"	Returns a list of the types of the fields in a given struct type.	Returns a list of the types of the fields in a given struct type.	0	1	5	4	24
"static MongoDatabasePolicy create() { final MongoClient client; if (MongoAssertions.useMongo()) { // use to real client (connects to mongo) client = new MongoClient(); } else if (MongoAssertions.useFongo()) { // in-memory DB (fake Mongo) client = new Fongo(MongoDatabasePolicy.class.getSimpleName()).getMongo(); } else { throw new UnsupportedOperationException(""I can only connect to Mongo or Fongo instances""); } return new MongoDatabasePolicy(client); }"	"  static MongoDatabaseRule create() {
    final MongoClient client;
    if (MongoAssertions.useMongo()) {
      // use to real client (connects to mongo)
      client = new MongoClient();
    } else if (MongoAssertions.useFongo()) {
      // in-memory DB (fake Mongo)
      client = new Fongo(MongoDatabaseRule.class.getSimpleName()).getMongo();
    } else {
      throw new UnsupportedOperationException(""I can only connect to Mongo or Fongo instances"");
    }

    return new MongoDatabaseRule(client);
  }
"	Creates an instance based on current maven profile (as defined by  -Pit).	Create an instance based on current maven profile (as defined by -Pit).	1	0	10	16	98
public Struct ceDataAttribute() { return recordParser.data(); }	"    public Struct ceDataAttribute() {
        Struct data = new Struct(ceDataAttributeSchema());
        if (recordParser.before() != null) {
            data.put(Envelope.FieldName.BEFORE, recordParser.before());
        }
        if (recordParser.after() != null) {
            data.put(Envelope.FieldName.AFTER, recordParser.after());
        }
        return data;
    }
"	Construct the value of the data attribute of CloudEvents.	Construct the value of the data attribute of CloudEvents.	0	1	4	4	13
public File getSinkFile() { return queue.file(); }	"	public File getSinkFile() {
		return sinkFile;
	}
"	Returns the queue directory	Returns	1	0	4	5	13
public boolean isMirrored() { if (!fMirroringEnabled) return false; Object property = getProperty(MIRRORED); return property instanceof Boolean && (Boolean) property; }	"	public boolean isMirrored() {
		Object property = getProperty(MIRRORED);
		return property instanceof Boolean && (Boolean) property;
	}
"	Returns true if the compare viewer is mirrored, i.e.	Only the views are mirrored.	1	0	6	8	33
"public float getKylinHBaseRegionCut() { return Float.valueOf(getOptional(""kylin.hbase.region.cut"", ""5.0"")); }"	"    public float getKylinHBaseRegionCut() {
        return Float.valueOf(getOptional(""kylin.hbase.region.cut"", ""1.0""));
    }
"	HBase region cut size, in GB	HBase region cut size, in GB	0	1	6	4	27
public Lob build() { return new Lob(this); }	"        public Ravioli build() {
            return new Ravioli(this);
        }
"	Build a Lob client	Build a Ravioli client	1	0	5	5	14
public static Builder copy(Configuration config) { return new Builder() { private Configuration.Builder builder = Configuration.copy(config); @Override public Builder with(String key, String value) { builder.with(key, value); return this; } @Override public Builder withDefault(String key, String value) { builder.withDefault(key, value); return this; } @Override public Builder apply(Consumer<Builder> function) { function.accept(this); return this; } @Override public Builder changeString(Field field, Function<String, String> function) { changeString(field,function); return this; } @Override public Builder changeString(String key, Function<String, String> function) { changeString(key,function); return this; } @Override public JdbcConfiguration build() { return JdbcConfiguration.adapt(builder.build()); } @Override public String toString() { return builder.toString(); } }; }	"    public static Builder copy(Configuration config) {
        return new Builder() {
            private Properties props = config.asProperties();

            @Override
            public Builder with(String key, String value) {
                props.setProperty(key, value);
                return this;
            }

            @Override
            public Builder withDefault(String key, String value) {
                if (!props.containsKey(key)) {
                    props.setProperty(key, value);
                }
                return this;
            }

            @Override
            public Builder apply(Consumer<Builder> function) {
                function.accept(this);
                return this;
            }

            @Override
            public JdbcConfiguration build() {
                return JdbcConfiguration.adapt(Configuration.from(props));
            }

            @Override
            public String toString() {
                return props.toString();
            }
        };
    }
"	Create a new  Builder configuration builder that starts with a copy of the supplied configuration.	Create a new Builder configuration builder that starts with a copy of the supplied configuration.	0	1	9	46	187
private BufferedImage loadImage(int itemId, int quantity, boolean stackable) { SpritePixels sprite = client.get().createItemSprite(itemId, quantity, 1, SpritePixels.DEFAULT_SHADOW_COLOR, stackable ? 1 : 0, false, CLIENT_DEFAULT_ZOOM); return sprite.toBufferedImage(); }	"	private AsyncBufferedImage loadImage(int itemId, int quantity, boolean stackable)
	{
		AsyncBufferedImage img = new AsyncBufferedImage(36, 32, BufferedImage.TYPE_INT_ARGB);
		clientThread.invokeLater(() ->
		{
			if (client.getGameState().ordinal() < GameState.LOGIN_SCREEN.ordinal())
			{
				return false;
			}
			SpritePixels sprite = client.createItemSprite(itemId, quantity, 1, SpritePixels.DEFAULT_SHADOW_COLOR,
				stackable ? 1 : 0, false, CLIENT_DEFAULT_ZOOM);
			if (sprite == null)
			{
				return false;
			}
			sprite.toBufferedImage(img);
			img.changed();
			return true;
		});
		return img;
	}
"	Loads item sprite from game, makes transparent, and generates image	Loads item sprite from game, makes transparent, and generates image	0	1	8	7	49
public Options includeDirectives(boolean flag) { return new Options(this.includeIntrospectionTypes, this.includeScalars, this.includeExtendedScalars, this.includeSchemaDefinition, this.useAstDefinitions, this.descriptionsAsHashComments, directive -> flag, this.comparatorRegistry); }	"        public Options includeDirectives(boolean flag) {
            return new Options(this.includeIntrospectionTypes, this.includeScalars, this.includeExtendedScalars, this.includeSchemaDefinition, flag, this.useAstDefinitions, this.descriptionsAsHashComments, this.comparatorRegistry);
        }
"	Allow to print directives.	Allow to print directives.	0	1	6	4	39
private ObjectWriter buildColumn(ParentShim parent, ColumnMetadata colSchema) { if (colSchema.isMultiList()) { return buildRepeatedList(parent, colSchema); } else if (colSchema.isMap()) { return buildMap(parent, colSchema); } else if (isSingleList(colSchema)) { return buildSingleList(parent, colSchema); } else if (colSchema.isVariant()) { return buildVariant(parent, colSchema); } else if (colSchema.isDict()) { return buildDict(parent, colSchema); } else { return buildPrimitive(parent, colSchema); } }	"  private ObjectWriter buildColumn(ParentShim parent, ColumnMetadata colSchema) {
    if (colSchema.isMultiList()) {
      return buildRepeatedList(parent, colSchema);
    } else if (colSchema.isMap()) {
      return buildMap(parent, colSchema);
    } else if (isSingleList(colSchema)) {
      return buildSingleList(parent, colSchema);
    } else if (colSchema.isVariant()) {
      return buildVariant(parent, colSchema);
    } else {
      return buildPrimitive(parent, colSchema);
    }
  }
"	Build the column writer, and any nested content, returning the built column writer as a generic object writer.	Build the column writer, and any nested content, returning the built column writer as a generic object writer.	0	1	11	16	112
"public boolean isConnectedAndHealthy() { Map<String, DiscoveryNode> nodeMap = nodes.get(); if (nodeMap == null || nodeMap.isEmpty()) { return false; } if (!deflector.isUp()) { return false; } try { return getHealth() != ClusterHealthStatus.RED; } catch (ElasticsearchException e) { LOG.trace(""Couldn't determine Elasticsearch health properly"", e); return false; } }"	"    public boolean isConnectedAndHealthy() {
        try {
            return getHealth() != ClusterHealthStatus.RED;
        } catch (ElasticsearchException e) {
            LOG.trace(""Couldn't determine Elasticsearch health properly"", e);
            return false;
        }
    }
"	Check if the Elasticsearch  Node is connected and that the cluster health status is not  ClusterHealthStatus#RED and that the  org.graylog2.indexer.Deflector#isUp() deflector is up.	Check if the Elasticsearch Node is connected and that the cluster health status is not ClusterHealthStatus#RED.	1	0	7	17	83
"protected static ASTNode findDeclaration2(Name findMe, ASTNode alternateParent) { ASTNode declaringClass = null; ASTNode parent = findMe.getParent(); ASTNode ret = null; ArrayList<Integer> constrains = new ArrayList<Integer>(); if (parent.getNodeType() == ASTNode.METHOD_INVOCATION) { Expression exp = (Expression) ((MethodInvocation) parent) .getStructuralProperty(MethodInvocation.EXPRESSION_PROPERTY); //TODO: Note the imbalance of constrains.add(ASTNode.METHOD_DECLARATION); // Possibly a bug here. Investigate later. if (((MethodInvocation) parent).getName().toString() .equals(findMe.toString())) { constrains.add(ASTNode.METHOD_DECLARATION); if (exp != null) { constrains.add(ASTNode.TYPE_DECLARATION); // log(""MI EXP: "" + exp.toString() + "" of type "" // + exp.getClass().getName() + "" parent: "" + exp.getParent()); if (exp instanceof MethodInvocation) { SimpleType stp = extracTypeInfo(findDeclaration2(((MethodInvocation) exp) .getName(), alternateParent)); if (stp == null) return null; declaringClass = findDeclaration2(stp.getName(), alternateParent); return definedIn(declaringClass, ((MethodInvocation) parent) .getName().toString(), constrains, declaringClass); } else if (exp instanceof FieldAccess) { SimpleType stp = extracTypeInfo(findDeclaration2(((FieldAccess) exp) .getName(), alternateParent)); if (stp == null) return null; declaringClass = findDeclaration2((stp.getName()), alternateParent); return definedIn(declaringClass, ((MethodInvocation) parent) .getName().toString(), constrains, declaringClass); } if (exp instanceof SimpleName) { SimpleType stp = extracTypeInfo(findDeclaration2(((SimpleName) exp), alternateParent)); if (stp == null) return null; declaringClass = findDeclaration2(stp.getName(), alternateParent); // log(""MI.SN "" + getNodeAsString(declaringClass)); constrains.add(ASTNode.METHOD_DECLARATION); return definedIn(declaringClass, ((MethodInvocation) parent) .getName().toString(), constrains, declaringClass); } } } else { parent = parent.getParent(); // Move one up the ast. V V IMP!! alternateParent = alternateParent.getParent(); } } else if (parent.getNodeType() == ASTNode.FIELD_ACCESS) { FieldAccess fa = (FieldAccess) parent; Expression exp = fa.getExpression(); if (fa.getName().toString().equals(findMe.toString())) { constrains.add(ASTNode.FIELD_DECLARATION); if (exp != null) { constrains.add(ASTNode.TYPE_DECLARATION); // log(""FA EXP: "" + exp.toString() + "" of type "" // + exp.getClass().getName() + "" parent: "" + exp.getParent()); if (exp instanceof MethodInvocation) { SimpleType stp = extracTypeInfo(findDeclaration2(((MethodInvocation) exp) .getName(), alternateParent)); if (stp == null) return null; declaringClass = findDeclaration2(stp.getName(), alternateParent); return definedIn(declaringClass, fa.getName().toString(), constrains, declaringClass); } else if (exp instanceof FieldAccess) { SimpleType stp = extracTypeInfo(findDeclaration2(((FieldAccess) exp) .getName(), alternateParent)); if (stp == null) return null; declaringClass = findDeclaration2((stp.getName()), alternateParent); constrains.add(ASTNode.TYPE_DECLARATION); return definedIn(declaringClass, fa.getName().toString(), constrains, declaringClass); } if (exp instanceof SimpleName) { SimpleType stp = extracTypeInfo(findDeclaration2(((SimpleName) exp), alternateParent)); if (stp == null) return null; declaringClass = findDeclaration2(stp.getName(), alternateParent); // log(""FA.SN "" + getNodeAsString(declaringClass)); constrains.add(ASTNode.METHOD_DECLARATION); return definedIn(declaringClass, fa.getName().toString(), constrains, declaringClass); } } } else { parent = parent.getParent(); // Move one up the ast. V V IMP!! alternateParent = alternateParent.getParent(); } } else if (parent.getNodeType() == ASTNode.QUALIFIED_NAME) { QualifiedName qn = (QualifiedName) parent; if (!findMe.toString().equals(qn.getQualifier().toString())) { SimpleType stp = extracTypeInfo(findDeclaration2((qn.getQualifier()), alternateParent)); if(stp == null) return null; declaringClass = findDeclaration2(stp.getName(), alternateParent); // log(qn.getQualifier() + ""->"" + qn.getName()); // log(""QN decl class: "" + getNodeAsString(declaringClass)); constrains.clear(); constrains.add(ASTNode.TYPE_DECLARATION); constrains.add(ASTNode.FIELD_DECLARATION); return definedIn(declaringClass, qn.getName().toString(), constrains, null); } else{ if(findMe instanceof QualifiedName){ QualifiedName qnn = (QualifiedName) findMe; // log(""findMe is a QN, "" // + (qnn.getQualifier().toString() + "" other "" + qnn.getName() // .toString())); SimpleType stp = extracTypeInfo(findDeclaration2((qnn.getQualifier()), alternateParent)); if (stp == null) { return null; } // log(qnn.getQualifier() + ""->"" + qnn.getName()); declaringClass = findDeclaration2(stp.getName(), alternateParent); // log(""QN decl class: "" // + getNodeAsString(declaringClass)); constrains.clear(); constrains.add(ASTNode.TYPE_DECLARATION); constrains.add(ASTNode.FIELD_DECLARATION); return definedIn(declaringClass, qnn.getName().toString(), constrains, null); } } } else if (parent.getNodeType() == ASTNode.SIMPLE_TYPE) { constrains.add(ASTNode.TYPE_DECLARATION); if (parent.getParent().getNodeType() == ASTNode.CLASS_INSTANCE_CREATION) constrains.add(ASTNode.CLASS_INSTANCE_CREATION); } else if (parent instanceof Expression) { // constrains.add(ASTNode.TYPE_DECLARATION); // constrains.add(ASTNode.METHOD_DECLARATION); // constrains.add(ASTNode.FIELD_DECLARATION); } // TODO: in findDec, we also have a case where parent of type TD is handled. // Figure out if needed here as well. // log(""Alternate parent: "" + getNodeAsString(alternateParent)); while (alternateParent != null) { // log(""findDeclaration2 -> "" // + getNodeAsString(alternateParent)); for (Object oprop : alternateParent.structuralPropertiesForType()) { StructuralPropertyDescriptor prop = (StructuralPropertyDescriptor) oprop; if (prop.isChildProperty() || prop.isSimpleProperty()) { if (alternateParent.getStructuralProperty(prop) instanceof ASTNode) { // log(prop + "" C/S Prop of -> "" // + getNodeAsString(alternateParent)); ret = definedIn((ASTNode) alternateParent .getStructuralProperty(prop), findMe.toString(), constrains, declaringClass); if (ret != null) return ret; } } else if (prop.isChildListProperty()) { // log((prop) + "" ChildList props of "" // + getNodeAsString(alternateParent)); List<ASTNode> nodelist = (List<ASTNode>) alternateParent .getStructuralProperty(prop); for (ASTNode retNode : nodelist) { ret = definedIn(retNode, findMe.toString(), constrains, declaringClass); if (ret != null) return ret; } } } alternateParent = alternateParent.getParent(); } return null; }"	"  protected static ASTNode findDeclaration2(Name findMe, ASTNode alternateParent) {
    ASTNode declaringClass = null;
    ASTNode parent = findMe.getParent();
    ASTNode ret = null;
    ArrayList<Integer> constrains = new ArrayList<Integer>();
    if (parent.getNodeType() == ASTNode.METHOD_INVOCATION) {
      Expression exp = (Expression) ((MethodInvocation) parent)
          .getStructuralProperty(MethodInvocation.EXPRESSION_PROPERTY);
      //TODO: Note the imbalance of constrains.add(ASTNode.METHOD_DECLARATION);
      // Possibly a bug here. Investigate later.
      if (((MethodInvocation) parent).getName().toString()
          .equals(findMe.toString())) {
        constrains.add(ASTNode.METHOD_DECLARATION);

        if (exp != null) {
          constrains.add(ASTNode.TYPE_DECLARATION);
//          log(""MI EXP: "" + exp.toString() + "" of type ""
//              + exp.getClass().getName() + "" parent: "" + exp.getParent());
          if (exp instanceof MethodInvocation) {
            SimpleType stp = extracTypeInfo(findDeclaration2(((MethodInvocation) exp)
                                                                 .getName(),
                                                             alternateParent));
            if (stp == null)
              return null;
            declaringClass = findDeclaration2(stp.getName(), alternateParent);
            return definedIn(declaringClass, ((MethodInvocation) parent)
                .getName().toString(), constrains, declaringClass);
          } else if (exp instanceof FieldAccess) {
            SimpleType stp = extracTypeInfo(findDeclaration2(((FieldAccess) exp)
                                                                 .getName(),
                                                             alternateParent));
            if (stp == null)
              return null;
            declaringClass = findDeclaration2((stp.getName()), alternateParent);
            return definedIn(declaringClass, ((MethodInvocation) parent)
                .getName().toString(), constrains, declaringClass);
          }
          if (exp instanceof SimpleName) {
            SimpleType stp = extracTypeInfo(findDeclaration2(((SimpleName) exp),
                                                             alternateParent));
            if (stp == null)
              return null;
            declaringClass = findDeclaration2(stp.getName(), alternateParent);
//            log(""MI.SN "" + getNodeAsString(declaringClass));
            constrains.add(ASTNode.METHOD_DECLARATION);
            return definedIn(declaringClass, ((MethodInvocation) parent)
                .getName().toString(), constrains, declaringClass);
          }

        }
      } else {
        parent = parent.getParent(); // Move one up the ast. V V IMP!!
        alternateParent = alternateParent.getParent();
      }
    } else if (parent.getNodeType() == ASTNode.FIELD_ACCESS) {
      FieldAccess fa = (FieldAccess) parent;
      Expression exp = fa.getExpression();
      if (fa.getName().toString().equals(findMe.toString())) {
        constrains.add(ASTNode.FIELD_DECLARATION);

        if (exp != null) {
          constrains.add(ASTNode.TYPE_DECLARATION);
//          log(""FA EXP: "" + exp.toString() + "" of type ""
//              + exp.getClass().getName() + "" parent: "" + exp.getParent());
          if (exp instanceof MethodInvocation) {
            SimpleType stp = extracTypeInfo(findDeclaration2(((MethodInvocation) exp)
                                                                 .getName(),
                                                             alternateParent));
            if (stp == null)
              return null;
            declaringClass = findDeclaration2(stp.getName(), alternateParent);
            return definedIn(declaringClass, fa.getName().toString(),
                             constrains, declaringClass);
          } else if (exp instanceof FieldAccess) {
            SimpleType stp = extracTypeInfo(findDeclaration2(((FieldAccess) exp)
                                                                 .getName(),
                                                             alternateParent));
            if (stp == null)
              return null;
            declaringClass = findDeclaration2((stp.getName()), alternateParent);
            constrains.add(ASTNode.TYPE_DECLARATION);
            return definedIn(declaringClass, fa.getName().toString(),
                             constrains, declaringClass);
          }
          if (exp instanceof SimpleName) {
            SimpleType stp = extracTypeInfo(findDeclaration2(((SimpleName) exp),
                                                             alternateParent));
            if (stp == null)
              return null;
            declaringClass = findDeclaration2(stp.getName(), alternateParent);
//            log(""FA.SN "" + getNodeAsString(declaringClass));
            constrains.add(ASTNode.METHOD_DECLARATION);
            return definedIn(declaringClass, fa.getName().toString(),
                             constrains, declaringClass);
          }
        }

      } else {
        parent = parent.getParent(); // Move one up the ast. V V IMP!!
        alternateParent = alternateParent.getParent();
      }
    } else if (parent.getNodeType() == ASTNode.QUALIFIED_NAME) {

      QualifiedName qn = (QualifiedName) parent;
      if (!findMe.toString().equals(qn.getQualifier().toString())) {

        SimpleType stp = extracTypeInfo(findDeclaration2((qn.getQualifier()),
                                                         alternateParent));
        if(stp == null)
          return null;
        declaringClass = findDeclaration2(stp.getName(), alternateParent);
//        log(qn.getQualifier() + ""->"" + qn.getName());
//        log(""QN decl class: "" + getNodeAsString(declaringClass));
        constrains.clear();
        constrains.add(ASTNode.TYPE_DECLARATION);
        constrains.add(ASTNode.FIELD_DECLARATION);
        return definedIn(declaringClass, qn.getName().toString(), constrains,
                         null);
      }
      else{
        if(findMe instanceof QualifiedName){
          QualifiedName qnn = (QualifiedName) findMe;
//          log(""findMe is a QN, ""
//              + (qnn.getQualifier().toString() + "" other "" + qnn.getName()
//                  .toString()));

          SimpleType stp = extracTypeInfo(findDeclaration2((qnn.getQualifier()), alternateParent));
//          log(qnn.getQualifier() + ""->"" + qnn.getName());
          declaringClass = findDeclaration2(stp.getName(), alternateParent);

//          log(""QN decl class: ""
//              + getNodeAsString(declaringClass));
          constrains.clear();
          constrains.add(ASTNode.TYPE_DECLARATION);
          constrains.add(ASTNode.FIELD_DECLARATION);
          return definedIn(declaringClass, qnn.getName().toString(), constrains,
                           null);
        }
      }
    } else if (parent.getNodeType() == ASTNode.SIMPLE_TYPE) {
      constrains.add(ASTNode.TYPE_DECLARATION);
      if (parent.getParent().getNodeType() == ASTNode.CLASS_INSTANCE_CREATION)
        constrains.add(ASTNode.CLASS_INSTANCE_CREATION);
    } else if (parent instanceof Expression) {
//      constrains.add(ASTNode.TYPE_DECLARATION);
//      constrains.add(ASTNode.METHOD_DECLARATION);
//      constrains.add(ASTNode.FIELD_DECLARATION);
    } // TODO: in findDec, we also have a case where parent of type TD is handled.
      // Figure out if needed here as well.
//    log(""Alternate parent: "" + getNodeAsString(alternateParent));
    while (alternateParent != null) {
//      log(""findDeclaration2 -> ""
//          + getNodeAsString(alternateParent));
      for (Object oprop : alternateParent.structuralPropertiesForType()) {
        StructuralPropertyDescriptor prop = (StructuralPropertyDescriptor) oprop;
        if (prop.isChildProperty() || prop.isSimpleProperty()) {
          if (alternateParent.getStructuralProperty(prop) instanceof ASTNode) {
//            log(prop + "" C/S Prop of -> ""
//                + getNodeAsString(alternateParent));
            ret = definedIn((ASTNode) alternateParent
                                .getStructuralProperty(prop),
                            findMe.toString(), constrains, declaringClass);
            if (ret != null)
              return ret;
          }
        } else if (prop.isChildListProperty()) {
//          log((prop) + "" ChildList props of ""
//              + getNodeAsString(alternateParent));
          List<ASTNode> nodelist = (List<ASTNode>) alternateParent
              .getStructuralProperty(prop);
          for (ASTNode retNode : nodelist) {
            ret = definedIn(retNode, findMe.toString(), constrains,
                            declaringClass);
            if (ret != null)
              return ret;
          }
        }
      }
      alternateParent = alternateParent.getParent();
    }
    return null;
  }
"	A variation of findDeclaration() but accepts an alternate parent ASTNode	A variation of findDeclaration() but accepts an alternate parent ASTNode	0	1	18	188	1441
public ResourceRepo removeResource(Resource resource) { if ((this.resourceRepos == null) || (resource == null)) { return null; } ResourceRepo doomed = null; for (ResourceRepo rc : this.resourceRepos) { if (resource.equals(rc.getResourceRepoPK().getResource())) { doomed = rc; break; } } if (doomed != null) { this.resourceRepos.remove(doomed); } return doomed; }	"    public ResourceChannel removeResource(Resource resource) {
        if ((this.resourceChannels == null) || (resource == null)) {
            return null;
        }

        ResourceChannel doomed = null;

        for (ResourceChannel rc : this.resourceChannels) {
            if (resource.equals(rc.getResourceChannelPK().getResource())) {
                doomed = rc;
                break;
            }
        }

        if (doomed != null) {
            this.resourceChannels.remove(doomed);
        }

        return doomed;
    }
"	Unsubscribes the resource from this repo, if it exists.	Unsubscribes the resource from this channel, if it exists.	1	0	9	22	81
public boolean isFlagSet(int flagsToCheck) { return (flags & flagsToCheck) != 0; }	"    public boolean isFlagSet(int flag) {
        return (flags & flag) != 0;
    }
"	Returns  true if any of the flags supplied in the argument are set.	Checks if a flag is set.	1	0	6	5	18
"public Client build() { if ((environment == null) && (executorService == null) && (objectMapper == null)) { throw new IllegalStateException(""Must have either an environment or both "" + ""an executor service and an object mapper""); } if (environment == null) { return build(executorService, objectMapper); } return build(environment.getLifecycleEnvironment() .managedExecutorService(""jersey-client-%d"", configuration.getMinThreads(), configuration.getMaxThreads(), 60, TimeUnit.SECONDS), environment.getJsonEnvironment().build()); }"	"    public Client build() {
        if ((environment == null) && (executorService == null) && (objectMapper == null)) {
            throw new IllegalStateException(""Must have either an environment or both "" +
                                                    ""an executor service and an object mapper"");
        }

        if (environment == null) {
            return build(executorService, objectMapper);
        }

        return build(environment.getLifecycleEnvironment()
                                .managedExecutorService(""jersey-client-%d"",
                                                        configuration.getMinThreads(),
                                                        configuration.getMaxThreads(),
                                                        60,
                                                        TimeUnit.SECONDS),
                     environment.getJsonEnvironment().buildObjectMapper());
    }
"	Builds the  Client instance.	Builds the Client instance.	0	1	8	19	111
"private ZapTextArea getTxtSkipURL() { if (txtSkipURL == null) { txtSkipURL = new ZapTextArea(); txtSkipURL.setFont(new java.awt.Font(""Default"", java.awt.Font.PLAIN, 11)); if (Model.getSingleton().getOptionsParam().getViewParam().getWmUiHandlingOption() == 0) { txtSkipURL.setSize(new java.awt.Dimension(290,52)); } } return txtSkipURL; }"	"    private JTextArea getTxtSkipURL() {
        if (txtSkipURL == null) {
            txtSkipURL = new JTextArea();
            txtSkipURL.setFont(new java.awt.Font(""Default"", java.awt.Font.PLAIN, 11));
    	    if (Model.getSingleton().getOptionsParam().getViewParam().getWmUiHandlingOption() == 0) {
    	    	txtSkipURL.setSize(new java.awt.Dimension(290,52));
    	    }
        }
        return txtSkipURL;
    }
"	This method initializes ZapTextArea	This method initializes jTextArea	1	0	12	11	77
protected Object convertTimestamp(Field fieldDefn, Object data) { java.util.Date date = null; if (data instanceof java.sql.Timestamp) { // JDBC specification indicates that this will be the canonical object for this JDBC type. date = (java.util.Date) data; } else if (data instanceof java.sql.Date) { // This should still work, even though it should have just date info date = (java.util.Date) data; } else if (data instanceof java.util.Date) { // Possible that some implementations might use this. date = (java.util.Date) data; } else if (data instanceof java.time.LocalDate) { // If we get a local date (no TZ info), we need to just convert to a util.Date (no TZ info) ... java.time.LocalDate local = (java.time.LocalDate) data; date = java.util.Date.from(local.atStartOfDay().toInstant(ZoneOffset.UTC)); } else if (data instanceof java.time.LocalDateTime) { // Get the instant in time by changing any date info to the epoch day so we only have time ... java.time.LocalDateTime local = (java.time.LocalDateTime) data; date = java.util.Date.from(local.toInstant(ZoneOffset.UTC)); } else { // An unexpected date = unexpectedTimestamp(data, fieldDefn); } return date; }	"    protected Object convertTimestamp(Field fieldDefn, Object data) {
        java.util.Date date = null;
        if (data instanceof java.sql.Timestamp) {
            // JDBC specification indicates that this will be the canonical object for this JDBC type.
            date = (java.util.Date) data;
        } else if (data instanceof java.sql.Date) {
            // This should still work, even though it should have just date info
            date = (java.util.Date) data;
        } else if (data instanceof java.util.Date) {
            // Possible that some implementations might use this.
            date = (java.util.Date) data;
        } else if (data instanceof java.time.LocalDate) {
            // If we get a local date (no TZ info), we need to just convert to a util.Date (no TZ info) ...
            java.time.LocalDate local = (java.time.LocalDate) data;
            date = java.util.Date.from(local.atStartOfDay().toInstant(ZoneOffset.UTC));
        } else if (data instanceof java.time.LocalDateTime) {
            // Get the instant in time by changing any date info to the epoch day so we only have time ...
            java.time.LocalDateTime local = (java.time.LocalDateTime) data;
            date = java.util.Date.from(local.toInstant(ZoneOffset.UTC));
        } else {
            // An unexpected
            date = unexpectedTimestamp(data, fieldDefn);
        }
        return date == null ? null : Timestamp.fromLogical(fieldDefn.schema(), date);
    }
"	Converts a value object for an expected JDBC type of  Types#TIMESTAMP.	Converts a value object for an expected JDBC type of Types#TIMESTAMP.	0	1	14	26	256
public static Boolean areColumnsUnique(RelNode rel, BitSet columns) { final BuiltInMetadata.ColumnUniqueness metadata = rel.metadata(BuiltInMetadata.ColumnUniqueness.class); return metadata.areColumnsUnique(columns, false); }	"  public static Boolean areColumnsUnique(RelNode rel, BitSet columns) {
    return (Boolean) rel.getCluster().getMetadataProvider().getRelMetadata(
        rel,
        ""areColumnsUnique"",
        new Object[]{columns, false});
  }
"	Returns the  BuiltInMetadata.ColumnUniqueness#areColumnsUnique(BitSet, boolean) statistic.	Determines if a specified set of columns from a specified relational expression are unique.	1	0	7	6	34
public static EBoolean endsWith(Expr<String> left, String right) { return operationFactory.createBoolean(Ops.ENDSWITH, left, exprFactory .createConstant(right)); }	"    public static EBoolean endsWith(Expr<String> left, String right, boolean caseSensitive) {
        if (caseSensitive){
            return endsWith(left, right);            
        }else{
            return operationFactory.createBoolean(Ops.ENDSWITH_IC, left, exprFactory.createConstant(right));
        }                
    }
"	Expr : left.endsWith(right)	Expr : left.endsWith(right) (ignore case)	1	0	6	5	30
public SubselectFetch getSubselect(EntityKey key) { return subselectsByEntityKey.get( key ); }	"	public SubselectFetch getSubselect(EntityKey key) {
		return (SubselectFetch) subselectsByEntityKey.get(key);
	}
"	Retrieve the fetch descriptor associated with the given entity key.	Retrieve the fetch descriptor associated with the given entity key.	0	1	5	4	16
public MenuItem addItem(String text, boolean asHTML, Command cmd) { return addItem(new MenuItem(text, asHTML, cmd)); }	"  public MenuItem addItem(SafeHtml html, ScheduledCommand cmd) {
    return addItem(new MenuItem(html, Roles.getMenuitemRole(), false, cmd));
  }
"	Adds a menu item to the bar, that will fire the given command when it is selected.	Adds a menu item to the bar containing SafeHtml, that will fire the given command when it is selected.	1	0	6	4	29
public String appendIdentitySelectToInsert(String insertString) { return getIdentityColumnSupport().appendIdentitySelectToInsert( insertString ); }	"	public String appendIdentitySelectToInsert(String insertString) {
		return insertString;
	}
"	"Provided we  #supportsInsertSelectIdentity, then attach the ""select identity"" clause to the insert statement."	"Provided we #supportsInsertSelectIdentity, then attach the ""select identity"" clause to the insert statement."	0	1	6	4	18
public boolean waitForView(View view, int timeout){ return waitForView(view, timeout, true, false); }	"	public boolean waitForView(View view, int timeout){
		return waitForView(view, timeout, true);
	}
"	Waits for a given view.	Waits for a given view.	0	1	5	4	24
public ENumber<Integer> length() { if (length == null) { length = ONumber.create(Integer.class, Ops.STRING_LENGTH, this); } return length; }	"    public ENumber<Long> length() {
        if (length == null) {
            length = ONumber.create(Long.class, Ops.STRING_LENGTH, this);
        }
        return length;
    }
"	Return the length of this String	Return the length of this String	0	1	9	7	31
public static Query parse(String queryString, BulletConfig config) { Query query = GSON.fromJson(queryString, Query.class); query.configure(config); return query; }	"    public static Specification parse(String queryString, BulletConfig config) {
        Specification specification = GSON.fromJson(queryString, Specification.class);
        specification.configure(config);
        return specification;
    }
"	Parses a Query out of the query string.	Parses a Specification out of the query string.	1	0	7	7	33
public static EBoolean startsWith(Expr<String> left, Expr<String> right) { return factory.createBoolean(Ops.STARTSWITH, left, right); }	"    public static EBoolean startsWith(Expr<String> left, Expr<String> right) {
        return createBoolean(Ops.STARTSWITH, left, right);
    }
"	Expr : left.startsWith(right)	Expr : left.startsWith(right)	0	1	6	4	27
public final DBCompareColExpr in(Collection<?> values) { if (values==null || values.isEmpty()) return cmp(DBCmpType.EQUAL, null); // create expression return cmp(DBCmpType.IN, values); }	"    public DBCompareColExpr in(Object value)
    {
        return cmp(DBCmpType.IN, listToArray(value));
    }
"	"Creates and returns an expression for the SQL ""in"" operator."	"Creates and returns a new comparison object for the SQL ""in"" operator."	1	0	6	9	44
public boolean equals(Object obj) { if (obj == null) { return false; } if (obj == this) { return true; } if (obj.getClass() != getClass()) { return false; } FiltersAggregation rhs = (FiltersAggregation) obj; return super.equals(obj) && Objects.equals(bucketMap, rhs.bucketMap); }	"    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }
        if (obj == this) {
            return true;
        }
        if (obj.getClass() != getClass()) {
            return false;
        }

        FiltersAggregation rhs = (FiltersAggregation) obj;
        return new EqualsBuilder()
                .appendSuper(super.equals(obj))
                .append(bucketMap, rhs.bucketMap)
                .isEquals();
    }
"	Method for getting counts using named filters	Method for getting counts using named filters	0	1	6	15	69
"public String getMatchedSentences() { StringBuilder sb = new StringBuilder(); for (int i = 0, sz = list.getModel().getSize(); i < sz; i++) { String t = list.getModel().getElementAt(i).getLabel().getText(); sb.append(t); sb.append(""\n""); } return sb.toString(); }"	"  public StringBuffer getMatchedSentences() {
    StringBuffer sb = new StringBuffer();
    for(int i = 0; i < list.getModel().getSize(); i++) {
      String t = ((TreeFromFile) list.getModel().getElementAt(i)).getLabel().getText();
      sb.append(t);
      sb.append(""\n"");
    }
    return sb;
  }
"	Returns all currently displayed sentences in plain text form.	Returns all currently displayed sentences in string buffer, plain text form	1	0	9	11	76
private TableExportButton getExportButton() { if (exportButton == null) { exportButton = new TableExportButton(getParamsTable()); } return exportButton; }	"	private JButton getExportButton() {
		JButton csvExportButton = new JButton(Constant.messages.getString(""params.toolbar.button.export""));
		csvExportButton.setIcon(new ImageIcon(ParamsPanel.class.getResource(""/resource/icon/16/115.png"")));
		csvExportButton.addActionListener((new AbstractAction() {
			private static final long serialVersionUID = 1L;

			@Override
			public void actionPerformed(ActionEvent e) {
				WritableFileChooser chooser = new WritableFileChooser();
				chooser.setSelectedFile(new File(Constant.messages.getString(""params.button.export.default.name"")));
				if (chooser
						.showSaveDialog(View.getSingleton().getMainFrame()) == WritableFileChooser.APPROVE_OPTION) {
					String file = chooser.getSelectedFile().toString();
					if (!file.endsWith("".csv"")) {
						file += "".csv"";
					}
					try (CSVPrinter pw = new CSVPrinter(
							Files.newBufferedWriter(chooser.getSelectedFile().toPath(), StandardCharsets.UTF_8),
							CSVFormat.DEFAULT)) {
						pw.printRecord(((ParamsTableModel) paramsTable.getModel()).getColumnNames());
						int rowCount = paramsTable.getRowCount();
						int colCount = paramsTable.getColumnCount();
						for (int row = 0; row < rowCount; row++) {
							List<Object> valueOfRow = new ArrayList<Object>();
							for (int col = 0; col < colCount; col++) {
								valueOfRow.add(paramsTable.getValueAt(row, col));
							}
							pw.printRecord(valueOfRow);
						}
						JOptionPane.showMessageDialog(View.getSingleton().getMainFrame(),
								Constant.messages.getString(""params.button.export.success""));
					} catch (Exception ex) {
						JOptionPane.showMessageDialog(View.getSingleton().getMainFrame(),
								Constant.messages.getString(""params.button.export.error"") + ""\n""
										+ ex.getLocalizedMessage());
						LOGGER.error(""Export Failed: "" + ex);
					}
				}
			}
		}));
		return csvExportButton;
	}
"	This method initializes panelCommand	This method initializes panelCommand	0	1	8	7	26
public Node getSecondNode() { return m_node2; } //	"	public NodeItem getSecondNode() {
		return m_node2;
	} //
"	Return the VisualItem representing the second (target) node in the edge.	Return the GraphItem representing the second (target) node in the edge.	1	0	4	5	12
"private String getConfigurationTable(Connection con) { try { if (StorageManager.getStorageImpl(con.getMetaData().getDatabaseProductName()).requiresConfigSchema()) { if (DatabaseConst.getConfigSchema().endsWith(""."")) return DatabaseConst.getConfigSchema() + TBL_GLOBAL_CONFIG; else return DatabaseConst.getConfigSchema() + ""."" + TBL_GLOBAL_CONFIG; } } catch (SQLException e) { LOG.warn(e); } return TBL_GLOBAL_CONFIG; }"	"    private String getConfigurationTable(Connection con) {
        try {
            if (StorageManager.getStorageImpl(con.getMetaData().getDatabaseProductName()).escapeSchema())
                return ""\"""" + DatabaseConst.getConfigSchema() + ""\""."" + TBL_GLOBAL_CONFIG;
        } catch (SQLException e) {
            LOG.warn(e);
        }
        return DatabaseConst.getConfigSchema() + ""."" + TBL_GLOBAL_CONFIG;
    }
"	Get the global configuration table name including the correct schema	Get the global configuration table name including the correct escaped schema	1	0	10	15	79
@Deprecated public long getNumBytesUploaded() { return totalBytesServerReceived; }	"  public long getNumBytesUploaded() {
    return bytesUploaded;
  }
"	Gets the total number of bytes the server received so far or  0 for direct uploads when the content length is not known.	Gets the total number of bytes uploaded by this uploader or 0 for direct uploads when the content length is not known.	1	0	4	6	12
public String print(ReadablePartial partial) { StringBuilder builder = new StringBuilder(requirePrinter().estimatePrintedLength()); try { printTo(builder, partial); } catch (IOException e) { // StringBuilder does not throw IOException } return builder.toString(); }	"    public String print(ReadablePartial partial) {
        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());
        printTo(buf, partial);
        return buf.toString();
    }
"	Prints a ReadablePartial to a new String.	Prints a ReadablePartial to a new String.	0	1	7	10	52
public User executeAs(Function<Response, Response> handler) { Type type = new TypeToken<User>(){}.getType(); return execute(handler).as(type); }	"        public User executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<User>(){}.getType();
            return getJSON().deserialize(execute(handler).asString(), type);
        }
"	GET /user/username	GET /user/username	0	1	8	5	35
public long findBestMatchCuboid(long cuboid) { return findBestMatchCuboid1(cuboid); }	"    public long findBestMatchCuboid(long child) {
        long parent = getOnTreeParent(child);
        while (parent > 0) {
            if (cubeDesc.getAllCuboids().contains(parent)) {
                break;
            }
            parent = getOnTreeParent(parent);
        }

        if (parent <= 0) {
            throw new IllegalStateException(""Can't find valid parent for Cuboid "" + child);
        }
        return parent;
    }
"	Get the parent cuboid rely on the spanning tree.	Get the parent cuboid really on the spanning tree.	1	0	5	4	15
@GET public Set<CassandraInstance> findAll() { return service.findAll(); }	"  @GET
  public List<CassandraInstance> findAll() {
    return service.findAll();
  }
"	Return the set of Cassandra instances.	Return the list of Cassandra instances ordered by position on ring, indicated by token.	1	0	5	6	16
public String getBackupDirectory() { return this.backupDirectory; }	"    public String getBackupDirectory() {
        return backupDirectory;
    }
"	Get the backup directory	DOCUMENT ME!	1	0	5	5	11
"static public Allocation createFromBitmap(RenderScript rs, Bitmap b, MipmapControl mips, int usage) { if (rs.isNative) { RenderScriptThunker rst = (RenderScriptThunker)rs; return AllocationThunker.createFromBitmap(rst, b, mips, usage); } rs.validate(); // WAR undocumented color formats if (b.getConfig() == null) { if ((usage & USAGE_SHARED) != 0) { throw new RSIllegalArgumentException(""USAGE_SHARED cannot be used with a Bitmap that has a null config.""); } Bitmap newBitmap = Bitmap.createBitmap(b.getWidth(), b.getHeight(), Bitmap.Config.ARGB_8888); Canvas c = new Canvas(newBitmap); c.drawBitmap(b, 0, 0, null); return createFromBitmap(rs, newBitmap, mips, usage); } Type t = typeFromBitmap(rs, b, mips); // enable optimized bitmap path only with no mipmap and script-only usage if (mips == MipmapControl.MIPMAP_NONE && t.getElement().isCompatible(Element.RGBA_8888(rs)) && usage == (USAGE_SHARED | USAGE_SCRIPT)) { int id = rs.nAllocationCreateBitmapBackedAllocation(t.getID(rs), mips.mID, b, usage); if (id == 0) { throw new RSRuntimeException(""Load failed.""); } // keep a reference to the Bitmap around to prevent GC Allocation alloc = new Allocation(id, rs, t, usage); alloc.setBitmap(b); return alloc; } int id = rs.nAllocationCreateFromBitmap(t.getID(rs), mips.mID, b, usage); if (id == 0) { throw new RSRuntimeException(""Load failed.""); } return new Allocation(id, rs, t, usage); }"	"    static public Allocation createFromBitmap(RenderScript rs, Bitmap b,
                                              MipmapControl mips,
                                              int usage) {
        rs.validate();
        Type t = typeFromBitmap(rs, b, mips);

        int id = rs.nAllocationCreateFromBitmap(t.getID(rs), mips.mID, b, usage);
        if (id == 0) {
            throw new RSRuntimeException(""Load failed."");
        }
        return new Allocation(id, rs, t, usage);
    }
"	Creates an Allocation from a  android.graphics.Bitmap.	Creates a renderscript allocation from a bitmap	1	0	9	46	327
"public boolean isValid(Litmus litmus) { return super.isValid(litmus) && litmus.check(Util.isDistinct(getRowType().getFieldNames()), ""distinct field names: {}"", getRowType()); }"	"  public boolean isValid(Litmus litmus) {
    return super.isValid(litmus)
        && litmus.check(Util.isDistinct(getRowType().getFieldNames()), getRowType());
  }
"	Computes the row type of an  Aggregate before it exists.	Computes the row type of an Aggregate before it exists.	0	1	8	6	45
public static int[] getViewToHeaderPosition(JTextArea view, int start, int end) { validateView(view); validateStartEnd(start, end); if (!isValidStartEndForLength(start, end, view.getDocument().getLength())) { return INVALID_POSITION; } return getViewToHeaderPositionImpl(view, start, end); }	"    public static int[] getViewToHeaderPosition(JTextArea view, int start, int end) {
        validateView(view);
        validateStartEnd(start, end, view.getDocument().getLength());
        return getViewToHeaderPositionImpl(view, start, end);
    }
"	Gets the given  start and  end view positions offset to a header.	Gets the given start and end view positions offset to a header.	0	1	6	11	63
public static String getPluginQuality(PluginPassiveScanner scanner) { // String scannerPackage = scanner.getClass().getCanonicalName(); String scannerName = scanner.getName(); return (getSpecificQuality(scannerName, scanner)); }	"	public static String getPluginQuality(PluginPassiveScanner scanner) {
        String scannerPackage = scanner.getClass().getCanonicalName();
        String scannerName = scanner.getName();
        
        return (getSpecificQuality(scannerName, scannerPackage));
        
        }
"	Gets the quality or status of the given passive  scanner.	Gets the quality or status of the given passive scanner.	0	1	5	8	39
public static RelDataTypeField lookupField( final RelDataType rowType, String columnName) { final RelDataTypeField [] fields = rowType.getFields(); for (int i = 0; i < fields.length; i++) { RelDataTypeField field = fields[i]; if (field.getName().equals(columnName)) { return field; } } return null; }	"    public static int lookupField(
        final RelDataType rowType,
        String columnName)
    {
        final RelDataTypeField [] fields = rowType.getFields();
        for (int i = 0; i < fields.length; i++) {
            RelDataTypeField field = fields[i];
            if (field.getName().equals(columnName)) {
                return i;
            }
        }
        return -1;
    }
"	Looks up a field with a given name, returning null if not found.	Looks up a field with a given name and if found returns its ordinal.	1	0	9	15	66
public static String asJson(Object object) throws IOException { return JSON.writeValueAsString(object); }	"    public static JsonNode asJson(Object object) throws IOException {
        return JSON.writeValueAsTree(object);
    }
"	Converts the given object into a canonical JSON string.	Converts the given object into a JSON AST.	1	0	5	5	19
"public Collection<TableGrant> getTableGrants(TableIdentifier table) { Collection<TableGrant> result = new HashSet<TableGrant>(); ResultSet rs = null; try { TableIdentifier tbl = table.createCopy(); tbl.adjustCase(this.dbConnection); rs = this.metaData.getTablePrivileges(tbl.getCatalog(), tbl.getSchema(), tbl.getTableName()); while (rs.next()) { String from = rs.getString(4); String to = rs.getString(5); String what = rs.getString(6); boolean grantable = StringUtil.stringToBool(rs.getString(7)); TableGrant grant = new TableGrant(to, what, grantable); result.add(grant); } } catch (Exception e) { LogMgr.logError(""DbMetadata.getTableGrants()"", ""Error when retrieving table privileges"",e); } finally { try { rs.close(); } catch (Throwable th) {} } return result; }"	"	public DataStore getTableGrants(TableIdentifier table)
	{
		String[] columns = new String[] { ""TABLENAME"", ""GRANTOR"", ""GRANTEE"", ""PRIVILEGE"", ""GRANTABLE"" };
		int[] colTypes = new int[] { Types.VARCHAR, Types.VARCHAR, Types.VARCHAR, Types.VARCHAR, Types.VARCHAR };
		DataStore result = new DataStore(columns, colTypes);
		ResultSet rs = null;
		try
		{
			TableIdentifier tbl = table.createCopy();
			tbl.adjustCase(this.dbConnection);
			rs = this.metaData.getTablePrivileges(tbl.getCatalog(), tbl.getSchema(), tbl.getTableName());
			while (rs.next())
			{
				int row = result.addRow();
				result.setValue(row, COLUMN_IDX_TABLE_GRANTS_OBJECT_NAME, rs.getString(3));
				result.setValue(row, COLUMN_IDX_TABLE_GRANTS_GRANTOR, rs.getString(4));
				result.setValue(row, COLUMN_IDX_TABLE_GRANTS_GRANTEE, rs.getString(5));
				result.setValue(row, COLUMN_IDX_TABLE_GRANTS_PRIV, rs.getString(6));
				result.setValue(row, COLUMN_IDX_TABLE_GRANTS_GRANTABLE, rs.getString(7));
			}
		}
		catch (Exception e)
		{
			LogMgr.logError(""DbMetadata.getTableGrants()"", ""Error when retrieving table privileges"",e);
			result.reset();
		}
		finally
		{
			try { rs.close(); } catch (Throwable th) {}
		}
		return result;
	}
"	Return the GRANTs for the given table	Return a String to recreate the GRANTs given for the passed table.	1	0	10	31	173
public ImageSource tilingDisabled() { return setTiling(false); }	"    public ImageSource tilingDisabled() {
        return tiling(false);
    }
"	Disable tiling of the image.	Disable tiling of the image.	0	1	5	4	13
public Subject login(AuthenticationToken token) throws AuthenticationException { Account account; try { account = authenticate(token); rememberMeSuccessfulLogin(token, account); } catch (AuthenticationException ae) { rememberMeFailedLogin(token, ae); throw ae; //propagate } Subject secCtx = createSubject(token, account); assertCreation(secCtx); bind(secCtx); return secCtx; }	"    public SecurityContext login(AuthenticationToken token) throws AuthenticationException {
        Account account;
        try {
            account = authenticate(token);
            rememberMeSuccessfulLogin(token, account);
        } catch (AuthenticationException ae) {
            rememberMeFailedLogin(token, ae);
            throw ae; //propagate
        }
        SecurityContext secCtx = createSecurityContext(token, account);
        assertCreation(secCtx);
        bind(secCtx);
        return secCtx;
    }
"	First authenticates the AuthenticationToken argument, and if successful, constructs a Subject instance representing the authenticated account's identity.	First authenticates the AuthenticationToken argument, and if successful, constructs a SecurityContext instance representing the authenticated account's identity.	1	0	7	16	72
public RollCycle getRollCycle() { return queue.rollCycle(); }	"	public RollCycle getRollCycle() {
		return rollCycle;
	}
"	Returns the queue file roll cycle	Returns	1	0	4	5	13
protected DimensionValueLoadTask buildDruidDimensionsLoader( DruidWebService webService, PhysicalTableDictionary physicalTableDictionary, DimensionDictionary dimensionDictionary ) { DruidDimensionValueLoader druidDimensionRowProvider = new DruidDimensionValueLoader( physicalTableDictionary, dimensionDictionary, webService ); return new DimensionValueLoadTask(Collections.singletonList(druidDimensionRowProvider)); }	"    protected DruidDimensionsLoader buildDruidDimensionsLoader(
            DruidWebService webService,
            PhysicalTableDictionary physicalTableDictionary,
            DimensionDictionary dimensionDictionary
    ) {
        return new DruidDimensionsLoader(
                physicalTableDictionary,
                dimensionDictionary,
                webService
        );
    }
"	Build a DimensionValueLoadTask.	Build a DruidDimensionsLoader.	1	0	6	14	38
public boolean overlaps(ReadableInterval interval) { if (interval == null) { return containsNow(); } long otherStart = interval.getStartMillis(); long otherEnd = interval.getEndMillis(); long thisStart = getStartMillis(); long thisEnd = getEndMillis(); return (thisStart < otherEnd && otherStart < thisEnd); }	"    public boolean overlaps(ReadableInterval interval) {
        if (interval == null) {
            throw new IllegalArgumentException(""The time interval must not be null"");
        }
        long otherStart = interval.getStartMillis();
        long otherEnd = interval.getEndMillis();
        long thisStart = getStartMillis();
        long thisEnd = getEndMillis();
        return (thisStart < otherEnd && otherStart < thisEnd);
    }
"	Does this time interval overlap the specified time interval.	Does this time interval overlap the specified time interval.	0	1	6	11	57
public String getTreeAuthoringPath() { return this.treeAuthoringPath; }	"    public String getTreeAuthoringPath() {
        return treeAuthoringPath;
    }
"	Returns the path to the authoring tree	DOCUMENT ME!	1	0	5	5	11
"protected String getChromeFile() throws IOException { if (!isChromeBinaryLocationKnown()) { chromeBinaryLocation = System.getProperty(""webdriver.chrome.bin""); if (chromeBinaryLocation == null) { if (Platform.getCurrent().is(Platform.WINDOWS)) { chromeBinaryLocation = getWindowsBinaryLocation(); } else if (Platform.getCurrent().is(Platform.UNIX)) { chromeBinaryLocation = ""/usr/bin/google-chrome""; } else if (Platform.getCurrent().is(Platform.MAC)) { String[] paths = new String[] { ""/Applications/Google Chrome.app/Contents/MacOS/Google Chrome"", ""/Users/"" + System.getProperty(""user.name"") + ""/Applications/Google Chrome.app/Contents/MacOS/Google Chrome""}; for (String path : paths) { File binary = new File(path); if (binary.exists()) { chromeBinaryLocation = binary.getCanonicalFile().getAbsoluteFile().toString(); break; } } } else { throw new WebDriverException(""Unsupported operating system. "" + ""Could not locate Chrome. Set webdriver.chrome.bin""); } } if (!isChromeBinaryLocationKnown()) { throw new WebDriverException(""Couldn't locate Chrome. "" + ""Set webdriver.chrome.bin""); } } return chromeBinaryLocation; }"	"  protected String getChromeFile() throws IOException {
    String chromeFileString = System.getProperty(""webdriver.chrome.bin"");
    if (chromeFileString == null) {
      if (Platform.getCurrent().is(Platform.WINDOWS)) {
        chromeFileString = getWindowsBinaryLocation();
      } else if (Platform.getCurrent().is(Platform.UNIX)) {
        chromeFileString = ""/usr/bin/google-chrome"";
      } else if (Platform.getCurrent().is(Platform.MAC)) {
        String[] paths = new String[] {
          ""/Applications/Google Chrome.app/Contents/MacOS/Google Chrome"",
          ""/Users/"" + System.getProperty(""user.name"") +
              ""/Applications/Google Chrome.app/Contents/MacOS/Google Chrome""};
        for (String path : paths) {
          File binary = new File(path);
          if (binary.exists()) {
            chromeFileString = binary.getCanonicalFile().getAbsoluteFile().toString();
            break;
          }
        }
      } else {
        throw new WebDriverException(""Unsupported operating system.  "" +
            ""Could not locate Chrome.  Set webdriver.chrome.bin"");
      }
      if (chromeFileString == null ||
          !new File(chromeFileString.toString()).exists()) {
        throw new WebDriverException(""Couldn't locate Chrome.  "" +
            ""Set webdriver.chrome.bin"");
      }
    }
    return chromeFileString;
  }
"	Locates the Chrome executable on the current platform.	Locates the Chrome executable on the current platform.	0	1	18	33	251
final public ParseException generateParseException() { this.jj_expentries.removeAllElements(); boolean[] la1tokens = new boolean[27]; for (int i = 0; i < 27; i++) { la1tokens[i] = false; } if (this.jj_kind >= 0) { la1tokens[this.jj_kind] = true; this.jj_kind = -1; } for (int i = 0; i < 13; i++) { if (this.jj_la1[i] == this.jj_gen) { for (int j = 0; j < 32; j++) { if ((this.jj_la1_0[i] & (1 << j)) != 0) { la1tokens[j] = true; } } } } for (int i = 0; i < 27; i++) { if (la1tokens[i]) { this.jj_expentry = new int[1]; this.jj_expentry[0] = i; this.jj_expentries.addElement(this.jj_expentry); } } this.jj_endpos = 0; jj_rescan_token(); jj_add_error_token(0, 0); int[][] exptokseq = new int[this.jj_expentries.size()][]; for (int i = 0; i < this.jj_expentries.size(); i++) { exptokseq[i] = (int[]) this.jj_expentries.elementAt(i); } return new ParseException(this.token, exptokseq, tokenImage); }	"    final public ParseException generateParseException() {
        jj_expentries.removeAllElements();

        boolean[] la1tokens = new boolean[27];

        for (int i = 0; i < 27; i++) {
            la1tokens[i] = false;
        }

        if (jj_kind >= 0) {
            la1tokens[jj_kind] = true;
            jj_kind = -1;
        }

        for (int i = 0; i < 13; i++) {
            if (jj_la1[i] == jj_gen) {
                for (int j = 0; j < 32; j++) {
                    if ((jj_la1_0[i] & (1 << j)) != 0) {
                        la1tokens[j] = true;
                    }
                }
            }
        }

        for (int i = 0; i < 27; i++) {
            if (la1tokens[i]) {
                jj_expentry = new int[1];
                jj_expentry[0] = i;
                jj_expentries.addElement(jj_expentry);
            }
        }

        jj_endpos = 0;
        jj_rescan_token();
        jj_add_error_token(0, 0);

        int[][] exptokseq = new int[jj_expentries.size()][];

        for (int i = 0; i < jj_expentries.size(); i++) {
            exptokseq[i] = (int[]) jj_expentries.elementAt(i);
        }

        return new ParseException(token, exptokseq, tokenImage);
    }
"	Generate a parse exception	DOCUMENT ME!	1	0	15	46	259
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; // set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { // prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); // System.err.println(""At end of text making after: |"" + str + ""|""); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); // System.err.println(""prevWord is |"" + prevWord.get(CoreAnnotations.TextAnnotation.class) + ""|, its after is |"" + // prevWord.get(CoreAnnotations.AfterAnnotation.class) + ""|""); prevWordAfter.setLength(0); } return null; } } else { switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { String str = yytext(); int first = str.codePointAt(0); String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } logger.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: logger.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 77: break; case 2: { return getNext(""<"", yytext()); } case 78: break; case 3: { return getNext(); } case 79: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 80: break; case 5: { if (tokenizeNLs) { return getNext(AbstractTokenizer.NEWLINE_TOKEN, yytext()); // for tokenizing newliens } else if (invertible) { // System.err.println(""Appending newline: |"" + yytext() + ""|""); prevWordAfter.append(yytext()); } } case 81: break; case 6: { final String origTxt = yytext(); String tok = LexerUtils.removeSoftHyphens(origTxt); if (americanize) { tok = Americanize.americanize(tok); } if (DEBUG) { logger.info(""Used {WORD} (2) to recognize "" + origTxt + "" as "" + tok); } return getNext(tok, origTxt); } case 82: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 83: break; case 8: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {QUOTES} (3) to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 84: break; case 9: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {SREDAUX} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 85: break; case 10: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 86: break; case 11: { return getNext("">"", yytext()); } case 87: break; case 12: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 88: break; case 13: { handleHyphenatedNumber(yytext()); if (DEBUG) { logger.info(""Used {NUMBER} to recognize "" + yytext() + "" as "" + removeFromNumber(yytext())); } return getNext(removeFromNumber(yytext()), yytext()); } case 89: break; case 14: { return handleEllipsis(yytext()); } case 90: break; case 15: { // breakByHyphens(yytext()); // this is causing fail of attempted to pushback too much! String tok = yytext(); /* A THING can contain quote like O'Malley */ String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {THING} (2) to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 91: break; case 16: { String txt = yytext(); String norm = normalizeFractions(yytext()); if (DEBUG) { logger.info(""Used {FRAC2} to recognize "" + txt + "" as "" + norm + ""; normalizeFractions="" + normalizeFractions + "", escapeForwardSlashAsterisk="" + escapeForwardSlashAsterisk); } return getNext(norm, txt); } case 92: break; case 17: { if (normalizeCurrency) { return getNext(LexerUtils.normalizeCurrency(yytext()), yytext()); } else { return getNext(LexerUtils.minimallyNormalizeCurrency(yytext()), yytext()); } } case 93: break; case 18: { if (normalizeOtherBrackets) { return getNext(""-RSB-"", yytext()); } else { return getNext(); } } case 94: break; case 19: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 95: break; case 20: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 96: break; case 21: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 97: break; case 22: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 98: break; case 23: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 99: break; case 24: { if (normalizeOtherBrackets) { return getNext(""-LSB-"", yytext()); } else { return getNext(); } } case 100: break; case 25: { String tok = yytext(); String norm = LexerUtils.processCp1252misc(tok); if (DEBUG) { logger.info(""Used {CP1252_MISC_SYMBOL} to recognize "" + tok + "" as "" + norm); } return getNext(norm, tok); } case 101: break; case 26: { if (invertible) { prevWordAfter.append(yytext()); } } case 102: break; case 27: // general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 103: break; case 28: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(); } case 104: break; case 29: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {REDAUX} (2) to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 105: break; case 30: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {APOWORD} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 106: break; case 31: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); String norm = handleQuotes(tok, true); if (DEBUG) { logger.info(""Used {DBLQUOT} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + true); } return getNext(norm, tok); } case 107: break; case 32: { String tok = yytext(); if (DEBUG) { logger.info(""Used {PROG_LANGS} to recognize "" + tok + "" as "" + tok); } return getNext(tok, tok); } case 108: break; case 33: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 109: break; case 34: { breakByHyphens(yytext()); if (DEBUG) { logger.info(""Used {HTHING} to recognize "" + yytext() + "" as "" + LexerUtils.removeSoftHyphens(yytext())); } return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext()); } case 110: break; case 35: // general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tok = LexerUtils.removeSoftHyphens(origTxt); if (americanize) { tok = Americanize.americanize(tok); } if (DEBUG) { logger.info(""Used {WORD} to recognize "" + origTxt + "" as "" + tok); } return getNext(tok, origTxt); } case 111: break; case 36: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 112: break; case 37: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String origTok = yytext(); String norm = LexerUtils.removeSoftHyphens(origTok); if (DEBUG) { logger.info(""Used {WORD} (3) to recognize "" + origTok + "" as "" + norm); } return getNext(norm, origTok); } case 113: break; case 38: { // this one should only match if we're basically at the end of file // since the last one matches two things, even newlines (if not tokenize per line) String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 114: break; case 39: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 115: break; case 40: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { // Extra context is to not match on ones like 'd but you do want words like ""a"" // can't have digit here because of cases like '90s String tok = yytext(); /* invert single quote - often but not always right */ String norm = handleQuotes(tok, true); if (DEBUG) { logger.info(""Used {QUOTES} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + true); } return getNext(norm, tok); } case 116: break; case 41: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {REDAUX} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 117: break; case 42: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { // Extra context is to not match on ones like 'd but you do want words like ""a"" // can't have digit here because of cases like '90s String tok = yytext(); /* invert single quote - often but not always right */ String norm = handleQuotes(tok, true); if (DEBUG) { logger.info(""Used {QUOTES} (2) to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + true); } return getNext(norm, tok); } case 118: break; case 43: { return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext()); } case 119: break; case 44: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {SREDAUX} (2) to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 120: break; case 45: { if (splitAssimilations) { yypushback(2); } String tok = yytext(); if (DEBUG) { logger.info(""Used {ASSIMILATIONS3} to recognize "" + tok + "" as "" + tok + ""; splitAssimilations="" + splitAssimilations); } return getNext(tok, tok); } case 121: break; case 46: { String txt = yytext(); // if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space... if (strictTreebank3) { int spaceIndex = indexOfSpace(txt); if (spaceIndex >= 0) { yypushback(txt.length() - spaceIndex); return getNext(); } } if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, yytext()); } case 122: break; case 47: { final String origTxt = yytext(); String tok; if (normalizeAmpersandEntity) { tok = LexerUtils.normalizeAmp(origTxt); } else { tok = origTxt; } if (DEBUG) { logger.info(""Used {THINGA} (2) to recognize "" + origTxt + "" as "" + tok); } return getNext(tok, origTxt); } case 123: break; case 48: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, origTxt); } case 124: break; case 49: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space } return getNext(txt, origTxt); } case 125: break; case 50: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tok = LexerUtils.removeSoftHyphens(origTxt); if (DEBUG) { logger.info(""Used {SWORD} to recognize "" + origTxt + "" as "" + tok); } return getNext(tok, origTxt); } case 126: break; case 51: // general lookahead, find correct zzMarkedPos { int zzFState = 17; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 127: break; case 52: { String txt = yytext(); String normTok = txt; if (escapeForwardSlashAsterisk) { normTok = delimit(normTok, '*'); } if (DEBUG) { logger.info(""Used {SWEARING} to recognize "" + txt + "" as "" + normTok); } return getNext(normTok, txt); } case 128: break; case 53: { final String origTxt = yytext(); String tok; if (normalizeAmpersandEntity) { tok = LexerUtils.normalizeAmp(origTxt); } else { tok = origTxt; } if (DEBUG) { logger.info(""Used {TBSPEC} to recognize "" + origTxt + "" as "" + tok); } return getNext(tok, origTxt); } case 129: break; case 54: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {SREDAUX} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 130: break; case 55: // general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 131: break; case 56: // general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 22; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 132: break; case 57: // general lookahead, find correct zzMarkedPos { int zzFState = 18; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 19; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 133: break; case 58: // general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 134: break; case 59: // general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 21; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 135: break; case 60: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 136: break; case 61: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); breakByHyphens(tok); tok = yytext(); String norm = LexerUtils.removeSoftHyphens(tok); if (DEBUG) { logger.info(""Used {HTHING} (2) to recognize "" + tok + "" as "" + norm); } return getNext(norm, tok); } case 137: break; case 62: { if (splitAssimilations) { yypushback(3); } String tok = yytext(); if (DEBUG) { logger.info(""Used {ASSIMILATIONS3} to recognize "" + tok + "" as "" + tok + ""; splitAssimilations="" + splitAssimilations); } return getNext(tok, tok); } case 138: break; case 63: { final String origTxt = yytext(); String tok; if (normalizeAmpersandEntity) { tok = LexerUtils.normalizeAmp(origTxt); } else { tok = origTxt; } if (DEBUG) { logger.info(""Used {SPAMP} to recognize "" + origTxt + "" as "" + tok); } return getNext(tok, origTxt); } case 139: break; case 64: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext()); } case 140: break; case 65: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { final String origTxt = yytext(); String tok; if (normalizeAmpersandEntity) { tok = LexerUtils.normalizeAmp(origTxt); } else { tok = origTxt; } if (DEBUG) { logger.info(""Used {THINGA} to recognize "" + origTxt + "" as "" + tok); } return getNext(tok, origTxt); } case 141: break; case 66: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 9; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 142: break; case 67: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { return getNext(); } case 143: break; case 68: // general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 144: break; case 69: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 145: break; case 70: // general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 13; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 146: break; case 71: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } return getNext(txt, yytext()); } case 147: break; case 72: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4); { return getNext(); } case 148: break; case 73: // lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { return getNext(); } case 149: break; case 74: { String txt = yytext(); if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } if (DEBUG) { logger.info(""Used {PHONE} to recognize "" + yytext() + "" as "" + txt); } return getNext(txt, yytext()); } case 150: break; case 75: // general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 25; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 151: break; case 76: // general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 24; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 152: break; default: zzScanError(ZZ_NO_MATCH); } } } }"	"  public Object next() throws java.io.IOException {
    int zzInput;
    int zzAction;

    // cached fields:
    int zzCurrentPosL;
    int zzMarkedPosL;
    int zzEndReadL = zzEndRead;
    char [] zzBufferL = zzBuffer;
    char [] zzCMapL = ZZ_CMAP;

    int [] zzTransL = ZZ_TRANS;
    int [] zzRowMapL = ZZ_ROWMAP;
    int [] zzAttrL = ZZ_ATTRIBUTE;

    while (true) {
      zzMarkedPosL = zzMarkedPos;

      yychar+= zzMarkedPosL-zzStartRead;

      zzAction = -1;

      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
  
      zzState = ZZ_LEXSTATE[zzLexicalState];

      // set up zzAction for empty match case:
      int zzAttributes = zzAttrL[zzState];
      if ( (zzAttributes & 1) == 1 ) {
        zzAction = zzState;
      }


      zzForAction: {
        while (true) {
    
          if (zzCurrentPosL < zzEndReadL) {
            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);
            zzCurrentPosL += Character.charCount(zzInput);
          }
          else if (zzAtEOF) {
            zzInput = YYEOF;
            break zzForAction;
          }
          else {
            // store back cached positions
            zzCurrentPos  = zzCurrentPosL;
            zzMarkedPos   = zzMarkedPosL;
            boolean eof = zzRefill();
            // get translated positions and possibly new buffer
            zzCurrentPosL  = zzCurrentPos;
            zzMarkedPosL   = zzMarkedPos;
            zzBufferL      = zzBuffer;
            zzEndReadL     = zzEndRead;
            if (eof) {
              zzInput = YYEOF;
              break zzForAction;
            }
            else {
              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);
              zzCurrentPosL += Character.charCount(zzInput);
            }
          }
          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
          if (zzNext == -1) break zzForAction;
          zzState = zzNext;

          zzAttributes = zzAttrL[zzState];
          if ( (zzAttributes & 1) == 1 ) {
            zzAction = zzState;
            zzMarkedPosL = zzCurrentPosL;
            if ( (zzAttributes & 8) == 8 ) break zzForAction;
          }

        }
      }

      // store back cached position
      zzMarkedPos = zzMarkedPosL;

      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
        zzAtEOF = true;
              {
                if (invertible) {
            // prevWordAfter.append(yytext());
            String str = prevWordAfter.toString();
            // System.err.println(""At end of text making after: |"" + str + ""|"");
            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);
            // System.err.println(""prevWord is |"" + prevWord.get(CoreAnnotations.TextAnnotation.class) + ""|, its after is |"" +
            //         prevWord.get(CoreAnnotations.AfterAnnotation.class) + ""|"");
            prevWordAfter.setLength(0);
          }
          return null;
              }
      }
      else {
        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
          case 1: 
            { String str = yytext();
          int first = str.codePointAt(0);
          String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"",
                          yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));
          switch (untokenizable) {
            case NONE_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              break;
            case FIRST_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              if ( ! this.seenUntokenizableCharacter) {
                logger.warning(msg);
                this.seenUntokenizableCharacter = true;
              }
              break;
            case ALL_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              logger.warning(msg);
              this.seenUntokenizableCharacter = true;
              break;
            case NONE_KEEP:
              return getNext();
            case FIRST_KEEP:
              if ( ! this.seenUntokenizableCharacter) {
                logger.warning(msg);
                this.seenUntokenizableCharacter = true;
              }
              return getNext();
            case ALL_KEEP:
              logger.warning(msg);
              this.seenUntokenizableCharacter = true;
              return getNext();
          }
            }
          case 74: break;
          case 2: 
            { return getNext(""<"", yytext());
            }
          case 75: break;
          case 3: 
            { return getNext();
            }
          case 76: break;
          case 4: 
            { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {
                    return getNext(ptbmdash, yytext());
                  } else {
                    return getNext();
                  }
            }
          case 77: break;
          case 5: 
            { if (tokenizeNLs) {
                      return getNext(AbstractTokenizer.NEWLINE_TOKEN, yytext()); // for tokenizing newliens
                  } else if (invertible) {
                    // System.err.println(""Appending newline: |"" + yytext() + ""|"");
                    prevWordAfter.append(yytext());
                  }
            }
          case 78: break;
          case 6: 
            { final String origTxt = yytext();
                          String tok = removeSoftHyphens(origTxt);
                          if (americanize) {
                            tok = Americanize.americanize(tok);
                          }
                          if (DEBUG) { logger.info(""Used {WORD} (2) to recognize "" + origTxt + "" as "" + tok +
                                                   ""; probablyLeft="" + false); }
                          return getNext(tok, origTxt);
            }
          case 79: break;
          case 7: 
            { if (invertible) {
                     prevWordAfter.append(yytext());
                  }
            }
          case 80: break;
          case 8: 
            { String tok = yytext();
                  String norm = handleQuotes(tok, false);
                  if (DEBUG) { logger.info(""Used {QUOTES} (3) to recognize "" + tok + "" as "" + norm +
                                           ""; probablyLeft="" + false); }
                  return getNext(norm, tok);
            }
          case 81: break;
          case 9: 
            { String tok = yytext();
                          String norm = handleQuotes(tok, false);
                          if (DEBUG) { logger.info(""Used {SREDAUX} to recognize "" + tok + "" as "" + norm +
                                                   ""; probablyLeft="" + false); }
                          return getNext(norm, tok);
            }
          case 82: break;
          case 10: 
            { if (escapeForwardSlashAsterisk) {
                    return getNext(delimit(yytext(), '/'), yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 83: break;
          case 11: 
            { return getNext("">"", yytext());
            }
          case 84: break;
          case 12: 
            { if (ptb3Dashes) {
                            return getNext(ptbmdash, yytext()); }
                          else {
                            return getNext();
                          }
            }
          case 85: break;
          case 13: 
            { handleHyphenatedNumber(yytext());
                          if (DEBUG) { logger.info(""Used {NUMBER} to recognize "" + yytext() + "" as "" + removeFromNumber(yytext())); }
                          return getNext(removeFromNumber(yytext()), yytext());
            }
          case 86: break;
          case 14: 
            { return handleEllipsis(yytext());
            }
          case 87: break;
          case 15: 
            { // breakByHyphens(yytext()); // this is causing fail of attempted to pushback too much!
                  String tok = yytext();
                  /* A THING can contain quote like O'Malley */
                  String norm = handleQuotes(tok, false);
                  if (DEBUG) { logger.info(""Used {THING} (2) to recognize "" + tok + "" as "" + norm +
                                           ""; probablyLeft="" + false); }
                  return getNext(norm, tok);
            }
          case 88: break;
          case 16: 
            { String txt = yytext();
                  String norm = normalizeFractions(yytext());
                  if (DEBUG) { logger.info(""Used {FRAC2} to recognize "" + txt + "" as "" + norm +
                                       ""; normalizeFractions="" + normalizeFractions +
                                       "", escapeForwardSlashAsterisk="" + escapeForwardSlashAsterisk); }
                  return getNext(norm, txt);
            }
          case 89: break;
          case 17: 
            { if (normalizeCurrency) {
                            return getNext(normalizeCurrency(yytext()), yytext());
                        } else {
                            return getNext(minimallyNormalizeCurrency(yytext()), yytext());
                          }
            }
          case 90: break;
          case 18: 
            { if (normalizeOtherBrackets) {
                    return getNext(""-RSB-"", yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 91: break;
          case 19: 
            { if (normalizeOtherBrackets) {
                    return getNext(closebrace, yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 92: break;
          case 20: 
            { if (normalizeParentheses) {
                    return getNext(openparen, yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 93: break;
          case 21: 
            { if (normalizeParentheses) {
                    return getNext(closeparen, yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 94: break;
          case 22: 
            { if (escapeForwardSlashAsterisk) {
                    return getNext(delimit(yytext(), '*'), yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 95: break;
          case 23: 
            { if (normalizeOtherBrackets) {
                    return getNext(openbrace, yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 96: break;
          case 24: 
            { if (normalizeOtherBrackets) {
                    return getNext(""-LSB-"", yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 97: break;
          case 25: 
            { String tok = yytext();
                        String norm = processCp1252misc(tok);
                        if (DEBUG) { logger.info(""Used {CP1252_MISC_SYMBOL} to recognize "" + tok + "" as "" + norm); }
                        return getNext(norm, tok);
            }
          case 98: break;
          case 26: 
            { if (invertible) {
                            prevWordAfter.append(yytext());
                        }
            }
          case 99: break;
          case 27: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 15;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 16;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return getNext();
            }
          case 100: break;
          case 28: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { return getNext();
            }
          case 101: break;
          case 29: 
            { String tok = yytext();
                  String norm = handleQuotes(tok, false);
                  if (DEBUG) { logger.info(""Used {REDAUX} (2) to recognize "" + tok + "" as "" + norm +
                                           ""; probablyLeft="" + false); }
                  return getNext(norm, tok);
            }
          case 102: break;
          case 30: 
            { String tok = yytext();
                          String norm = handleQuotes(tok, false);
                          if (DEBUG) { logger.info(""Used {APOWORD} to recognize "" + tok + "" as "" + norm +
                                                   ""; probablyLeft="" + false); }
                          return getNext(norm, tok);
            }
          case 103: break;
          case 31: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { String tok = yytext();
                                   String norm = handleQuotes(tok, true);
                                   if (DEBUG) { logger.info(""Used {DBLQUOT} to recognize "" + tok + "" as "" + norm +
                                                            ""; probablyLeft="" + true); }
                                   return getNext(norm, tok);
            }
          case 104: break;
          case 32: 
            { String tok = yytext();
                    if (DEBUG) { logger.info(""Used {PROG_LANGS} to recognize "" + tok + "" as "" + tok); }
                    return getNext(tok, tok);
            }
          case 105: break;
          case 33: 
            { String txt = yytext();
                  String origText = txt;
                  if (normalizeParentheses) {
                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                  }
                  return getNext(txt, origText);
            }
          case 106: break;
          case 34: 
            { breakByHyphens(yytext());
                  if (DEBUG) { logger.info(""Used {HTHING} to recognize "" + yytext() + "" as "" + removeSoftHyphens(yytext())); }
                  return getNext(removeSoftHyphens(yytext()), yytext());
            }
          case 107: break;
          case 35: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 3;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 4;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { final String origTxt = yytext();
                          String tok = removeSoftHyphens(origTxt);
                          if (americanize) {
                            tok = Americanize.americanize(tok);
                          }
                          if (DEBUG) { logger.info(""Used {WORD} to recognize "" + origTxt + "" as "" + tok +
                                                   ""; probablyLeft="" + false); }
                          return getNext(tok, origTxt);
            }
          case 108: break;
          case 36: 
            { if (escapeForwardSlashAsterisk) {
                            return getNext(delimit(yytext(), '/'), yytext());
                          } else {
                            return getNext();
                          }
            }
          case 109: break;
          case 37: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { return getNext(removeSoftHyphens(yytext()), yytext());
            }
          case 110: break;
          case 38: 
            { // this one should only match if we're basically at the end of file
                          // since the last one matches two things, even newlines (if not tokenize per line)
                          String s;
                          if (strictTreebank3 && ! ""U.S."".equals(yytext())) {
                            yypushback(1); // return a period for next time
                            s = yytext();
                          } else {
                            s = yytext();
                            yypushback(1); // return a period for next time
                          }
                          return getNext(s, yytext());
            }
          case 111: break;
          case 39: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { String txt = yytext();
                  String origText = txt;
                  if (normalizeParentheses) {
                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                  }
                  return getNext(txt, origText);
            }
          case 112: break;
          case 40: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);
            { // Extra context is to not match on ones like 'd but you do want words like ""a""
                  // can't have digit here because of cases like '90s
                  String tok = yytext();
                  /* invert single quote - often but not always right */
                  String norm = handleQuotes(tok, true);
                  if (DEBUG) { logger.info(""Used {QUOTES} to recognize "" + tok + "" as "" + norm +
                                           ""; probablyLeft="" + true); }
                  return getNext(norm, tok);
            }
          case 113: break;
          case 41: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { String tok = yytext();
                          String norm = handleQuotes(tok, false);
                          if (DEBUG) { logger.info(""Used {REDAUX} to recognize "" + tok + "" as "" + norm +
                                                   ""; probablyLeft="" + false); }
                          return getNext(norm, tok);
            }
          case 114: break;
          case 42: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);
            { // Extra context is to not match on ones like 'd but you do want words like ""a""
                  // can't have digit here because of cases like '90s
                  String tok = yytext();
                  /* invert single quote - often but not always right */
                  String norm = handleQuotes(tok, true);
                  if (DEBUG) { logger.info(""Used {QUOTES} (2) to recognize "" + tok + "" as "" + norm +
                                           ""; probablyLeft="" + true); }
                  return getNext(norm, tok);
            }
          case 115: break;
          case 43: 
            { return getNext(removeSoftHyphens(yytext()), yytext());
            }
          case 116: break;
          case 44: 
            { String tok = yytext();
                  String norm = handleQuotes(tok, false);
                  if (DEBUG) { logger.info(""Used {SREDAUX} (2) to recognize "" + tok + "" as "" + norm +
                                           ""; probablyLeft="" + false); }
                  return getNext(norm, tok);
            }
          case 117: break;
          case 45: 
            { if (splitAssimilations) {
                      yypushback(2);
                    }
                    String tok = yytext();
                    if (DEBUG) { logger.info(""Used {ASSIMILATIONS3} to recognize "" + tok + "" as "" + tok +
                            ""; splitAssimilations="" + splitAssimilations); }
                    return getNext(tok, tok);
            }
          case 118: break;
          case 46: 
            { String txt = yytext();
                  // if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space...
                  if (strictTreebank3) {
                    int spaceIndex = indexOfSpace(txt);
                    if (spaceIndex >= 0) {
                      yypushback(txt.length() - spaceIndex);
                      return getNext();
                    }
                  }
                  if (escapeForwardSlashAsterisk) {
                    txt = delimit(txt, '/');
                  }
                  if (normalizeSpace) {
                    txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                  }
                  return getNext(txt, yytext());
            }
          case 119: break;
          case 47: 
            { return getNormalizedAmpNext();
            }
          case 120: break;
          case 48: 
            { final String origTxt = yytext();
                          String txt = origTxt;
                          if (normalizeSpace) {
                            txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                          }
                          return getNext(txt, origTxt);
            }
          case 121: break;
          case 49: 
            { final String origTxt = yytext();
                          String txt = origTxt;
                          if (normalizeSpace) {
                            txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                          }
                          return getNext(txt, origTxt);
            }
          case 122: break;
          case 50: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 5;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 6;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { final String txt = yytext();
                          return getNext(removeSoftHyphens(txt),
                                         txt);
            }
          case 123: break;
          case 51: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 17;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 16;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return getNext();
            }
          case 124: break;
          case 52: 
            { String txt = yytext();
                  String normTok = txt;
                  if (escapeForwardSlashAsterisk) {
                    normTok = delimit(normTok, '*');
                  }
                  if (DEBUG) { logger.info(""Used {SWEARING} to recognize "" + txt + "" as "" + normTok); }
                  return getNext(normTok, txt);
            }
          case 125: break;
          case 53: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { String tok = yytext();
                          String norm = handleQuotes(tok, false);
                          if (DEBUG) { logger.info(""Used {SREDAUX} to recognize "" + tok + "" as "" + norm +
                                                   ""; probablyLeft="" + false); }
                          return getNext(norm, tok);
            }
          case 126: break;
          case 54: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 10;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 11;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return processAbbrev3();
            }
          case 127: break;
          case 55: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 20;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 22;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */
                                    return handleEllipsis(yytext());
            }
          case 128: break;
          case 56: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 18;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 19;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return getNext();
            }
          case 129: break;
          case 57: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 10;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 11;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return processAbbrev3();
            }
          case 130: break;
          case 58: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 20;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 21;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */
                                    return handleEllipsis(yytext());
            }
          case 131: break;
          case 59: 
            { String txt = yytext();
                          if (escapeForwardSlashAsterisk) {
                            txt = delimit(txt, '/');
                            txt = delimit(txt, '*');
                          }
                          return getNext(txt, yytext());
            }
          case 132: break;
          case 60: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { String tok = yytext();
                  breakByHyphens(tok);
                  tok = yytext();
                  String norm = removeSoftHyphens(tok);
                  if (DEBUG) { logger.info(""Used {HTHING} (2) to recognize "" + tok + "" as "" + norm); }
                  return getNext(norm, tok);
            }
          case 133: break;
          case 61: 
            { if (splitAssimilations) {
                      yypushback(3);
                    }
                    String tok = yytext();
                    if (DEBUG) { logger.info(""Used {ASSIMILATIONS3} to recognize "" + tok + "" as "" + tok +
                            ""; splitAssimilations="" + splitAssimilations); }
                    return getNext(tok, tok);
            }
          case 134: break;
          case 62: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { return getNormalizedAmpNext();
            }
          case 135: break;
          case 63: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 7;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 9;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return processAcronym();
            }
          case 136: break;
          case 64: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);
            { return getNext();
            }
          case 137: break;
          case 65: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 12;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 14;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return processAbbrev1();
            }
          case 138: break;
          case 66: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 7;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 8;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return processAcronym();
            }
          case 139: break;
          case 67: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 12;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 13;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return processAbbrev1();
            }
          case 140: break;
          case 68: 
            { String txt = yytext();
                          if (escapeForwardSlashAsterisk) {
                            txt = delimit(txt, '/');
                          }
                          return getNext(txt, yytext());
            }
          case 141: break;
          case 69: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4);
            { return getNext();
            }
          case 142: break;
          case 70: 
            // lookahead expression with fixed base length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);
            { return getNext();
            }
          case 143: break;
          case 71: 
            { String txt = yytext();
                          if (normalizeSpace) {
                            txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                          }
                          if (normalizeParentheses) {
                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                          }
                          if (DEBUG) { logger.info(""Used {PHONE} to recognize "" + yytext() + "" as "" + txt); }
                          return getNext(txt, yytext());
            }
          case 144: break;
          case 72: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 23;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 25;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */
                                    return handleEllipsis(yytext());
            }
          case 145: break;
          case 73: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 23;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 24;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */
                                    return handleEllipsis(yytext());
            }
          case 146: break;
          default:
            zzScanError(ZZ_NO_MATCH);
        }
      }
    }
  }
"	Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.	Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.	0	1	21	1128	7996
public ArrayList getAllLinkHRefs() { return this.link_href_all; }	"    public ArrayList getAllLinkHRefs() {
        return link_href_all;
    }
"	Get a list of all links	DOCUMENT ME!	1	0	5	5	11
View createShortcut(ShortcutInfo info) { return createShortcut(R.layout.application, (ViewGroup) mWorkspace.getChildAt(mWorkspace.getCurrentScreen()), info); }	"    View createShortcut(ShortcutInfo info) {
        return createShortcut(R.layout.application,
                (ViewGroup) mWorkspace.getChildAt(mWorkspace.getCurrentPage()), info);
    }
"	Creates a view representing a shortcut.	Creates a view representing a shortcut.	0	1	7	5	30
@Override protected Bitmap alloc(int size) { return Bitmap.createBitmap( 1, (int) Math.ceil(size / (double) BitmapUtil.RGB_565_BYTES_PER_PIXEL), Bitmap.Config.RGB_565); }	"  @Override
  protected Bitmap alloc(int size) {
    return Bitmap.createBitmap(1, size, Bitmaps.BITMAP_CONFIG);
  }
"	Allocate a bitmap that has a backing memory allocacation of 'size' bytes.	Allocate a bitmap with the specified width and height.	1	0	9	9	37
"public Mono<Client> testClientModel(Client body) throws RestClientException { Object postBody = body; // verify the required parameter 'body' is set if (body == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'body' when calling testClientModel""); } String path = UriComponentsBuilder.fromPath(""/fake"").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { ""application/json"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { ""application/json"" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {}; return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType); }"	"    public Mono<Client> testClientModel(Client body) throws RestClientException {
        Object postBody = body;
        
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'body' when calling testClientModel"");
        }
        
        String path = UriComponentsBuilder.fromPath(""/fake"").build().toUriString();
        
        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();
        final HttpHeaders headerParams = new HttpHeaders();
        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();

        final String[] accepts = { 
            ""application/json""
        };
        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);
        final String[] contentTypes = { 
            ""application/json""
        };
        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);

        String[] authNames = new String[] {  };

        ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {};
        return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);
    }
"	To test \&quot;client\&quot; model	To test \&quot;client\&quot; model	0	1	8	30	217
private String getTag() { if (lineage.isEmpty()) { return name; } else { return lineage.get(0).getName(); } }	"        private String getTag() {
            return dictionary.getJsonAliasFor(type);
        }
"	All Paths are 'tagged' in swagger with the root entity name in the path.	All Paths are 'tagged' in swagger with the final entity type name in the path.	1	0	7	9	32
public boolean isFull() { return getPrefetchSize() == 0 ? prefetchExtension.get() == 0 : dispatched.size() - prefetchExtension.get() >= info.getPrefetchSize(); }	"    public boolean isFull() {
        return dispatched.size() - prefetchExtension.get() >= info.getPrefetchSize();
    }
"	Used to determine if the broker can dispatch to the consumer.	Used to determine if the broker can dispatch to the consumer.	0	1	7	4	33
public static final Element elementFromUse(ExpressionTree node) { return InternalUtils.symbol(node); }	"    public static final ExecutableElement elementFromUse(MethodInvocationTree node) {
        return (ExecutableElement)TreeInfo.symbol((JCTree)node.getMethodSelect());
    }
"	Gets the element for the declaration corresponding to this use of an element.	Gets the element for the method corresponding to this invocation.	1	0	5	5	18
public static DurationFieldType days() { return DAYS_TYPE; }	"    public static DurationFieldType days() {
        return DAYS;
    }
"	Get the days field type.	Get the days field type.	0	1	4	4	11
static String boxClassName(Type type) { if (!(type instanceof Class)) { return type.toString(); } Primitive primitive = Primitive.of(type); if (primitive != null) { return primitive.boxClass.getSimpleName(); } else { return className(type); } }	"    static String boxClassName(Type type) {
        if (!(type instanceof Class)) {
            return type.toString();
        }
        Class clazz = (Class) type;
        if (clazz.isPrimitive()) {
            return PRIMITIVES.get(clazz).getSimpleName();
        } else {
            return className(clazz);
        }
    }
"	Boxes a type, if it is primitive, and returns the type name.	Boxes a type, if it is primitive, and returns the type name.	0	1	7	12	58
public static DrillFileSystem createFileSystem(String proxyUserName, Configuration fsConf) { return createFileSystem(createProxyUgi(proxyUserName), fsConf, null); }	"  public static DrillFileSystem createFileSystem(String proxyUserName, Configuration fsConf, OperatorStats stats) {
    return createFileSystem(createProxyUgi(proxyUserName), fsConf, stats);
  }
"	Create DrillFileSystem for given proxyUserName and configuration.	Create DrillFileSystem for given proxyUserName, configuration and stats.	1	0	6	4	26
public static Collection<Simon> getSimons(SimonFilter simonFilter) { return manager.getSimons(simonFilter); }	"	public static Collection<Simon> getSimons(SimonPattern pattern) {
		return manager.getSimons(pattern);
	}
"	Returns collection containing all existing Simons accepted by specified  SimonFilter.	Returns collection containing all existing Simons matching the pattern (can be null).	1	0	5	5	18
@CheckForNull public final SCMRevision fetch(@NonNull String thingName, @CheckForNull TaskListener listener) throws IOException, InterruptedException { return retrieve(thingName, defaultListener(listener)); }	"    @CheckForNull
    public final SCMRevision fetch(@NonNull String revision, @CheckForNull TaskListener listener)
            throws IOException, InterruptedException {
        return retrieve(revision, defaultListener(listener));
    }
"	Looks up a specific thingName based on some SCM-specific set of permissible syntaxes.	Looks up a specific revision based on some SCM-specific set of permissible syntaxes.	1	0	6	7	34
"public static Builder create() { return new Builder() { private Configuration config; private Consumer<SourceRecord> consumer; private ClassLoader classLoader; private Clock clock; @Override public Builder using(Configuration config) { this.config = config; return this; } @Override public Builder using(ClassLoader classLoader) { this.classLoader = classLoader; return this; } @Override public Builder using(Clock clock) { this.clock = clock; return this; } @Override public Builder notifying(Consumer<SourceRecord> consumer) { this.consumer = consumer; return this; } @Override public EmbeddedConnector build() { if (classLoader == null) classLoader = getClass().getClassLoader(); if (clock == null) clock = Clock.system(); Objects.requireNonNull(config, ""A connector configuration must be specified.""); Objects.requireNonNull(consumer, ""A connector consumer must be specified.""); return new EmbeddedConnector(config, classLoader, clock, consumer); } }; }"	"    public static Builder create() {
        return new Builder() {
            private Configuration config;
            private OffsetBackingStore offsetStore;
            private OffsetCommitPolicy offsetCommitPolicy;
            private Consumer<SourceRecord> consumer;
            private ClassLoader classLoader;
            private Clock clock;

            @Override
            public Builder using(Configuration config) {
                this.config = config;
                return this;
            }

            @Override
            public Builder using(OffsetBackingStore offsetStore) {
                this.offsetStore = offsetStore;
                return this;
            }

            @Override
            public Builder using(OffsetCommitPolicy policy) {
                this.offsetCommitPolicy = policy;
                return this;
            }

            @Override
            public Builder using(ClassLoader classLoader) {
                this.classLoader = classLoader;
                return this;
            }

            @Override
            public Builder using(Clock clock) {
                this.clock = clock;
                return this;
            }

            @Override
            public Builder notifying(Consumer<SourceRecord> consumer) {
                this.consumer = consumer;
                return this;
            }

            @Override
            public EmbeddedConnector build() {
                if (offsetStore == null) offsetStore = new MemoryOffsetBackingStore();
                if (offsetCommitPolicy == null) offsetCommitPolicy = OffsetCommitPolicy.always();
                if (classLoader == null) classLoader = getClass().getClassLoader();
                if (clock == null) clock = Clock.system();
                Objects.requireNonNull(config, ""A connector configuration must be specified."");
                Objects.requireNonNull(consumer, ""A connector consumer must be specified."");
                return new EmbeddedConnector(config, offsetStore, offsetCommitPolicy, classLoader, clock, consumer);
            }

        };
    }
"	Obtain a new  Builder instance that can be used to construct runnable  EmbeddedConnector instances.	Obtain a new Builder instance that can be used to construct runnable EmbeddedConnector instances.	0	1	10	43	182
public ScopeContainer getModuleScope() { return moduleScope; }	"    public ScopeContext getModuleScope() {
        return moduleScope;
    }
"	Returns the ScopeContainer for the MODULE scope that will be associated with this deployment unit.	Returns the ScopeContext for the MODULE scope that will be associated with this deployment unit.	1	0	4	5	10
public static DateTimeFieldType yearOfCentury() { return YEAR_OF_CENTURY_TYPE; }	"    public static DateTimeFieldType yearOfCentury() {
        return YEAR_OF_CENTURY;
    }
"	Get the year of century field type.	Get the year of century field type.	0	1	4	4	11
"public DurationField seconds() { return UnsupportedDurationField.getInstance(""seconds""); }"	"    public DurationField seconds() {
        return UnsupportedDurationField.INSTANCE;
    }
"	Returns a DurationField representing seconds.	Returns a DurationField representing seconds.	0	1	5	4	16
"public static String getHostFromUrl(String url) { String authority = getAuthorityFromUrl(url); // no port int idx = authority.indexOf("":""); if (idx == -1) return authority; // port, return only the portion preceding the port return authority.substring(0, idx); }"	"   public static String getHostFromUrl(String url)
   {
      // no work to do
      if (url.indexOf('/') == -1)
         return url;
      
      // presume no protocol; if present, skip those slashes
      int slashes = 0;
      if (url.contains(""://""))
         slashes += 2;
      
      // split on slashes and return first component
      String[] parts = url.split(""/"");
      if (parts.length < slashes)
         return url;
      return parts[slashes];
   }
"	Given a URL, attempt to return the host portion (not including the port).	Given a URL, attempt to infer and return the hostname from the URL.	1	0	6	13	60
public boolean contains(ReadableInterval interval) { if (interval == null) { return containsNow(); } long otherStart = interval.getStartMillis(); long otherEnd = interval.getEndMillis(); long thisStart = getStartMillis(); long thisEnd = getEndMillis(); return (thisStart <= otherStart && otherStart < thisEnd && otherEnd <= thisEnd); }	"    public boolean contains(ReadableInterval interval) {
        if (interval == null) {
            return containsNow();
        }
        long otherStart = interval.getStartMillis();
        long otherEnd = interval.getEndMillis();
        long thisStart = getStartMillis();
        long thisEnd = getEndMillis();
        return (thisStart <= otherStart && otherStart < thisEnd && otherEnd <= thisEnd) ||
            (thisStart == otherStart && thisEnd == otherEnd);
    }
"	Does this time interval contain the specified time interval.	Does this time interval contain or equal the specified time interval.	1	0	7	11	61
public String escapeReservedWord(String name) { // Can't start with an underscore, as our fields need to start with an // UppercaseLetter so that Go treats them as public/visible. // Options? // - MyName // - AName // - TheName // - XName // - X_Name // ... or maybe a suffix? // - Name_ ... think this will work. if (this.reservedWordsMappings().containsKey(name)) { return this.reservedWordsMappings().get(name); } return org.openapitools.codegen.utils.StringUtils.camelize(name) + '_'; }	"    public String escapeReservedWord(String name) {
        // Can't start with an underscore, as our fields need to start with an
        // UppercaseLetter so that Go treats them as public/visible.

        // Options?
        // - MyName
        // - AName
        // - TheName
        // - XName
        // - X_Name
        // ... or maybe a suffix?
        // - Name_ ... think this will work.
        if (this.reservedWordsMappings().containsKey(name)) {
            return this.reservedWordsMappings().get(name);
        }
        return camelize(name) + '_';
    }
"	Escapes a reserved word as defined in the `reservedWords` array.	Escapes a reserved word as defined in the `reservedWords` array.	0	1	8	18	116
public Method getMethod() { return method; }	"    public int getMethod() {
        return method;
    }
"	Gets the request method.	Gets an integer value of the request method.	1	0	4	5	10
private static int parseOffset(String str) { Chronology chrono; if (cDefault != null) { chrono = ISOChronology.getInstanceUTC(); } else { // Can't use a real chronology if called during class // initialization. Offset parser doesn't need it anyhow. chrono = new BaseChronology() { public DateTimeZone getZone() { return null; } public Chronology withUTC() { return this; } public Chronology withZone(DateTimeZone zone) { return this; } public String toString() { return getClass().getName(); } }; } return -(int) offsetFormatter().withChronology(chrono).parseMillis(str); }	"    private static int parseOffset(String str) {
        Chronology chrono;
        if (cDefault != null) {
            chrono = ISOChronology.getInstanceUTC();
        } else {
            // Can't use a real chronology if called during class
            // initialization. Offset parser doesn't need it anyhow.
            chrono = new BaseChronology() {
                public DateTimeZone getZone() {
                    return null;
                }
                public Chronology withUTC() {
                    return this;
                }
                public Chronology withZone(DateTimeZone zone) {
                    return this;
                }
                public String toString() {
                    return getClass().getName();
                }
            };
        }

        return -(int) offsetFormatter().parseMillis(str, chrono);
    }
"	Converts an old style id to a new style id.	Converts an old style id to a new style id.	0	1	11	26	126
public final int getEndColumn() { return this.bufcolumn[this.bufpos]; }	"    public final int getEndColumn() {
        return bufcolumn[bufpos];
    }
"	Get the column position	DOCUMENT ME!	1	0	7	5	16
public boolean isWordwrap() { return wordwrap; }	"    @Override
    public boolean isWordwrap() {
        // TODO implement here once the API from TextField is removed
        return super.isWordwrap();
    }
"	Tests if the text area is in word-wrap mode.	Tests if the editor is in word-wrap mode.	1	0	4	5	10
public static ApiResponse getReferencedApiResponse(OpenAPI openAPI, ApiResponse apiResponse) { if (apiResponse != null && StringUtils.isNotEmpty(apiResponse.get$ref())) { String name = getSimpleRef(apiResponse.get$ref()); ApiResponse referencedApiResponse = getApiResponse(openAPI, name); if(referencedApiResponse != null) { return referencedApiResponse; } } return apiResponse; }	"    public static ApiResponse getReferencedApiResponse(OpenAPI openAPI, ApiResponse apiResponse) {
        if (apiResponse != null && StringUtils.isNotEmpty(apiResponse.get$ref())) {
            String name = getSimpleRef(apiResponse.get$ref());
            return getApiResponse(openAPI, name);
        }
        return apiResponse;
    }
"	If a ApiResponse contains a reference to an other ApiResponse with '$ref', returns the referenced ApiResponse if it is found or the actual ApiResponse in the other cases.	If a ApiResponse contains a reference to an other ApiResponse with '$ref', returns the referenced ApiResponse or the actual ApiResponse in the other cases.	1	0	8	11	68
"public String loginUser(String username, String password) throws ApiException { Object postBody = null; // create path and map variables String path = ""/user/login"".replaceAll(""\\{format\\}"",""json""); // query params List<Pair> queryParams = new ArrayList<Pair>(); Map<String, String> headerParams = new HashMap<String, String>(); Map<String, Object> formParams = new HashMap<String, Object>(); queryParams.addAll(apiClient.parameterToPairs("""", ""username"", username)); queryParams.addAll(apiClient.parameterToPairs("""", ""password"", password)); final String[] accepts = { ""application/json"", ""application/xml"" }; final String accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final String contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; GenericType<String> returnType = new GenericType<String>() {}; return apiClient.invokeAPI(path, ""GET"", queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }"	"  public String loginUser(String username, String password) throws ApiException {
    Object localVarPostBody = null;
    
    // create path and map variables
    String localVarPath = ""/user/login"".replaceAll(""\\{format\\}"",""json"");

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarQueryParams.addAll(apiClient.parameterToPairs("""", ""username"", username));
    
    localVarQueryParams.addAll(apiClient.parameterToPairs("""", ""password"", password));
    

    

    

    final String[] localVarAccepts = {
      ""application/json"", ""application/xml""
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    
    GenericType<String> localVarReturnType = new GenericType<String>() {};
    return apiClient.invokeAPI(localVarPath, ""GET"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);
    
  }
"	Logs user into the system	Logs user into the system	0	1	8	39	217
"public String doCommand(String command, String field, String value) { resultExpected = true; doCommandWithoutWaitingForAResponse(command, field, value); try { return queueGetResult(""doCommand""); } finally { resultExpected = false; } }"	"    public String doCommand(String command, String field, String value) {
        resultExpected = true;
        doCommandWithoutWaitingForAResponse(command, field, value);
        try {
            return (String) queueGet(""commandResultHolder"", commandResultHolder);
        } catch (SeleniumCommandTimedOutException e) {
            return ""ERROR: Command timed out"";
        }
        finally {
            resultExpected = false;
        }
    }
"	Schedules the specified command to be retrieved by the next call to handle command result, and returns the result of that command.	Schedules the specified command to be retrieved by the next call to handle command result, and returns the result of that command.	0	1	6	11	44
public String getRCMLDirectory() { return this.rcmlDirectory; }	"    public String getRCMLDirectory() {
        return rcmlDirectory;
    }
"	Get the RCML directory	DOCUMENT ME!	1	0	5	5	11
public Collection<TypedDependency> typedDependenciesCollapsed() { return typedDependenciesCollapsed(Extras.NONE); }	"  public Collection<TypedDependency> typedDependenciesCollapsed() {
    return typedDependenciesCollapsed(false);
  }
"	Get the typed dependencies after collapsing them.	Get the typed dependencies after collapsing them.	0	1	5	4	15
"@Override public void createRecord(DBRecord rec, Connection conn) { throw new NotImplementedException(this, ""createRecord""); }"	"    @Override
    public boolean createRecord(DBRecord rec, Connection conn)
    {
        return error(Errors.NotImplemented, ""addRecord"");
    }
"	Returns an error, because it is not possible to add a record to a query.	Returns an error, because querys could't add new records to the database.	1	0	5	7	25
"public User getUserByName (String username) throws ApiException { Object postBody = null; byte[] postBinaryBody = null; // verify the required parameter 'username' is set if (username == null) { throw new ApiException(400, ""Missing the required parameter 'username' when calling getUserByName""); } // create path and map variables String path = ""/user/{username}"".replaceAll(""\\{format\\}"",""json"") .replaceAll(""\\{"" + ""username"" + ""\\}"", apiClient.escapeString(username.toString())); // query params List<Pair> queryParams = new ArrayList<Pair>(); Map<String, String> headerParams = new HashMap<String, String>(); Map<String, Object> formParams = new HashMap<String, Object>(); final String[] accepts = { ""application/json"", ""application/xml"" }; final String accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final String contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; TypeRef returnType = new TypeRef<User>() {}; return apiClient.invokeAPI(path, ""GET"", queryParams, postBody, postBinaryBody, headerParams, formParams, accept, contentType, authNames, returnType); }"	"  public User getUserByName (String username) throws ApiException {
    Object postBody = null;
    
    // verify the required parameter 'username' is set
    if (username == null) {
       throw new ApiException(400, ""Missing the required parameter 'username' when calling getUserByName"");
    }
    

    // create path and map variables
    String path = ""/user/{username}"".replaceAll(""\\{format\\}"",""json"")
      .replaceAll(""\\{"" + ""username"" + ""\\}"", apiClient.escapeString(username.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    Map<String, String> headerParams = new HashMap<String, String>();
    Map<String, Object> formParams = new HashMap<String, Object>();

    

    

    

    final String[] accepts = {
      ""application/json"", ""application/xml""
    };
    final String accept = apiClient.selectHeaderAccept(accepts);

    final String[] contentTypes = {
      
    };
    final String contentType = apiClient.selectHeaderContentType(contentTypes);

    String[] authNames = new String[] {  };
    
    TypeRef returnType = new TypeRef<User>() {};
    return apiClient.invokeAPI(path, ""GET"", queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);
    
  }
"	Get user by user name	Get user by user name	0	1	9	48	254
protected Object convertTimestampToEpochMillisAsDate(Column column, Field fieldDefn, Object data) { // epoch is the fallback value return convertValue(column, fieldDefn, data, 0L, (r) -> { try { r.deliver(new java.util.Date(Timestamp.toEpochMillis(data, adjuster))); } catch (IllegalArgumentException e) { } }); }	"    protected Object convertTimestampToEpochMillisAsDate(Column column, Field fieldDefn, Object data) {
        if (data == null && !fieldDefn.schema().isOptional()) {
            data = fieldDefn.schema().defaultValue();
        }
        if (data == null) {
            if (column.isOptional()) return null;
            return new java.util.Date(0L); // return epoch
        }
        try {
            return new java.util.Date(Timestamp.toEpochMillis(data, adjuster));
        } catch (IllegalArgumentException e) {
            return handleUnknownData(column, fieldDefn, data);
        }
    }
"	Converts a value object for an expected JDBC type of  Types#TIMESTAMP to  java.util.Date values representing milliseconds past epoch.	Converts a value object for an expected JDBC type of Types#TIMESTAMP to java.util.Date values representing milliseconds past epoch.	0	1	12	10	69
public static MemberID parse(String memberID) { return parse(memberID, false, AppInfo.getSingleton().getClassPath()); }	"    public static MemberID parse(String signature) {
        return parse(signature, false, AppInfo.getSingleton().getClassPath());
    }
"	Parse a member ID, with or without classname, with or without descriptor.	Parse a signature, with or without classname, with or without descriptor.	1	0	6	5	26
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; // set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { // prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); // System.err.println(""At end of text making after: |"" + str + ""|""); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); // System.err.println(""prevWord is |"" + prevWord.get(CoreAnnotations.TextAnnotation.class) + ""|, its after is |"" + // prevWord.get(CoreAnnotations.AfterAnnotation.class) + ""|""); prevWordAfter.setLength(0); } return null; } } else { switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { String str = yytext(); int first = str.codePointAt(0); String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } logger.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: logger.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 79: break; case 2: { return getNext(""<"", yytext()); } case 80: break; case 3: { return getNext(); } case 81: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 82: break; case 5: { if (tokenizeNLs) { return getNext(AbstractTokenizer.NEWLINE_TOKEN, yytext()); // for tokenizing newliens } else if (invertible) { // System.err.println(""Appending newline: |"" + yytext() + ""|""); prevWordAfter.append(yytext()); } } case 83: break; case 6: { final String origTxt = yytext(); String tok = LexerUtils.removeSoftHyphens(origTxt); if (americanize) { tok = Americanize.americanize(tok); } if (DEBUG) { logger.info(""Used {WORD} (2) to recognize "" + origTxt + "" as "" + tok); } return getNext(tok, origTxt); } case 84: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 85: break; case 8: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {QUOTES} (3) to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 86: break; case 9: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {SREDAUX} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 87: break; case 10: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 88: break; case 11: { return getNext("">"", yytext()); } case 89: break; case 12: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 90: break; case 13: { handleHyphenatedNumber(yytext()); if (DEBUG) { logger.info(""Used {NUMBER} to recognize "" + yytext() + "" as "" + removeFromNumber(yytext())); } return getNext(removeFromNumber(yytext()), yytext()); } case 91: break; case 14: { return handleEllipsis(yytext()); } case 92: break; case 15: { // breakByHyphens(yytext()); // this is causing fail of attempted to pushback too much! String tok = yytext(); /* A THING can contain quote like O'Malley */ String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {THING} (2) to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 93: break; case 16: { String txt = yytext(); String norm = normalizeFractions(yytext()); if (DEBUG) { logger.info(""Used {FRAC2} to recognize "" + txt + "" as "" + norm + ""; normalizeFractions="" + normalizeFractions + "", escapeForwardSlashAsterisk="" + escapeForwardSlashAsterisk); } return getNext(norm, txt); } case 94: break; case 17: { if (normalizeCurrency) { return getNext(LexerUtils.normalizeCurrency(yytext()), yytext()); } else { return getNext(LexerUtils.minimallyNormalizeCurrency(yytext()), yytext()); } } case 95: break; case 18: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 96: break; case 19: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 97: break; case 20: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 98: break; case 21: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 99: break; case 22: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 100: break; case 23: { if (normalizeOtherBrackets) { return getNext(""-LSB-"", yytext()); } else { return getNext(); } } case 101: break; case 24: { if (normalizeOtherBrackets) { return getNext(""-RSB-"", yytext()); } else { return getNext(); } } case 102: break; case 25: { String tok = yytext(); String norm = LexerUtils.processCp1252misc(tok); if (DEBUG) { logger.info(""Used {CP1252_MISC_SYMBOL} to recognize "" + tok + "" as "" + norm); } return getNext(norm, tok); } case 103: break; case 26: { if (invertible) { prevWordAfter.append(yytext()); } } case 104: break; case 27: // general lookahead, find correct zzMarkedPos { int zzFState = 17; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 18; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 105: break; case 28: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(); } case 106: break; case 29: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {REDAUX} (2) to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 107: break; case 30: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {APOWORD} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 108: break; case 31: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); String norm = handleQuotes(tok, true); if (DEBUG) { logger.info(""Used {DBLQUOT} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + true); } return getNext(norm, tok); } case 109: break; case 32: { String tok = yytext(); if (DEBUG) { logger.info(""Used {PROG_LANGS} to recognize "" + tok + "" as "" + tok); } return getNext(tok, tok); } case 110: break; case 33: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String txt = yytext(); if (DEBUG) { logger.info(""Used {DIGIT}/{SEP_SUFFIX} to recognize "" + txt); } return getNext(txt, txt); } case 111: break; case 34: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 112: break; case 35: { breakByHyphens(yytext()); if (DEBUG) { logger.info(""Used {HTHING} to recognize "" + yytext() + "" as "" + LexerUtils.removeSoftHyphens(yytext())); } return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext()); } case 113: break; case 36: // general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tok = LexerUtils.removeSoftHyphens(origTxt); if (americanize) { tok = Americanize.americanize(tok); } if (DEBUG) { logger.info(""Used {WORD} to recognize "" + origTxt + "" as "" + tok); } return getNext(tok, origTxt); } case 114: break; case 37: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 115: break; case 38: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String origTok = yytext(); String norm = LexerUtils.removeSoftHyphens(origTok); if (DEBUG) { logger.info(""Used {WORD} (3) to recognize "" + origTok + "" as "" + norm); } return getNext(norm, origTok); } case 116: break; case 39: { // this one should only match if we're basically at the end of file // since the last one matches two things, even newlines (if not tokenize per line) return processAbbrev1(); } case 117: break; case 40: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 118: break; case 41: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { // Extra context is to not match on ones like 'd but you do want words like ""a"" // can't have digit here because of cases like '90s String tok = yytext(); /* invert single quote - often but not always right */ String norm = handleQuotes(tok, true); if (DEBUG) { logger.info(""Used {QUOTES} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + true); } return getNext(norm, tok); } case 119: break; case 42: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {REDAUX} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 120: break; case 43: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { // Extra context is to not match on ones like 'd but you do want words like ""a"" // can't have digit here because of cases like '90s String tok = yytext(); /* invert single quote - often but not always right */ String norm = handleQuotes(tok, true); if (DEBUG) { logger.info(""Used {QUOTES} (2) to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + true); } return getNext(norm, tok); } case 121: break; case 44: { return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext()); } case 122: break; case 45: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {SREDAUX} (2) to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 123: break; case 46: { if (splitAssimilations) { yypushback(2); } String tok = yytext(); if (DEBUG) { logger.info(""Used {ASSIMILATIONS3} to recognize "" + tok + "" as "" + tok + ""; splitAssimilations="" + splitAssimilations); } return getNext(tok, tok); } case 124: break; case 47: { String txt = yytext(); // if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space... if (strictTreebank3) { int spaceIndex = indexOfSpace(txt); if (spaceIndex >= 0) { yypushback(txt.length() - spaceIndex); return getNext(); } } if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, yytext()); } case 125: break; case 48: { final String origTxt = yytext(); String tok; if (normalizeAmpersandEntity) { tok = LexerUtils.normalizeAmp(origTxt); } else { tok = origTxt; } if (DEBUG) { logger.info(""Used {THINGA} (2) to recognize "" + origTxt + "" as "" + tok); } return getNext(tok, origTxt); } case 126: break; case 49: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, origTxt); } case 127: break; case 50: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space } return getNext(txt, origTxt); } case 128: break; case 51: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tok = LexerUtils.removeSoftHyphens(origTxt); if (DEBUG) { logger.info(""Used {SWORD} to recognize "" + origTxt + "" as "" + tok); } return getNext(tok, origTxt); } case 129: break; case 52: // general lookahead, find correct zzMarkedPos { int zzFState = 19; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 18; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 130: break; case 53: { String txt = yytext(); String normTok = txt; if (escapeForwardSlashAsterisk) { normTok = delimit(normTok, '*'); } if (DEBUG) { logger.info(""Used {SWEARING} to recognize "" + txt + "" as "" + normTok); } return getNext(normTok, txt); } case 131: break; case 54: { final String origTxt = yytext(); String tok; if (normalizeAmpersandEntity) { tok = LexerUtils.normalizeAmp(origTxt); } else { tok = origTxt; } if (DEBUG) { logger.info(""Used {TBSPEC} to recognize "" + origTxt + "" as "" + tok); } return getNext(tok, origTxt); } case 132: break; case 55: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {SREDAUX} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 133: break; case 56: // general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 13; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 134: break; case 57: // general lookahead, find correct zzMarkedPos { int zzFState = 22; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 24; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 135: break; case 58: // general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 21; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 136: break; case 59: // general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 13; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 137: break; case 60: // general lookahead, find correct zzMarkedPos { int zzFState = 22; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 23; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 138: break; case 61: { String txt = yytext(); String norm = txt; if (escapeForwardSlashAsterisk) { norm = delimit(norm, '/'); norm = delimit(norm, '*'); } if (DEBUG) { logger.info(""Used {LIKELYURL} to recognize "" + txt + "" as "" + norm); } return getNext(norm, txt); } case 139: break; case 62: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); breakByHyphens(tok); tok = yytext(); String norm = LexerUtils.removeSoftHyphens(tok); if (DEBUG) { logger.info(""Used {HTHING} (2) to recognize "" + tok + "" as "" + norm); } return getNext(norm, tok); } case 140: break; case 63: { if (splitAssimilations) { yypushback(3); } String tok = yytext(); if (DEBUG) { logger.info(""Used {ASSIMILATIONS3} to recognize "" + tok + "" as "" + tok + ""; splitAssimilations="" + splitAssimilations); } return getNext(tok, tok); } case 141: break; case 64: { final String origTxt = yytext(); String tok; if (normalizeAmpersandEntity) { tok = LexerUtils.normalizeAmp(origTxt); } else { tok = origTxt; } if (DEBUG) { logger.info(""Used {SPAMP} to recognize "" + origTxt + "" as "" + tok); } return getNext(tok, origTxt); } case 142: break; case 65: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext()); } case 143: break; case 66: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { final String origTxt = yytext(); String tok; if (normalizeAmpersandEntity) { tok = LexerUtils.normalizeAmp(origTxt); } else { tok = origTxt; } if (DEBUG) { logger.info(""Used {THINGA} to recognize "" + origTxt + "" as "" + tok); } return getNext(tok, origTxt); } case 144: break; case 67: // general lookahead, find correct zzMarkedPos { int zzFState = 9; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 145: break; case 68: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { return getNext(); } case 146: break; case 69: // general lookahead, find correct zzMarkedPos { int zzFState = 14; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 147: break; case 70: // general lookahead, find correct zzMarkedPos { int zzFState = 9; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 10; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 148: break; case 71: // general lookahead, find correct zzMarkedPos { int zzFState = 14; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 15; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 149: break; case 72: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } return getNext(txt, yytext()); } case 150: break; case 73: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4); { return getNext(); } case 151: break; case 74: // lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { return getNext(); } case 152: break; case 75: { String txt = yytext(); String norm = txt; if (escapeForwardSlashAsterisk) { norm = delimit(norm, '/'); norm = delimit(norm, '*'); } if (DEBUG) { logger.info(""Used {FULLURL} to recognize "" + txt + "" as "" + norm); } return getNext(norm, txt); } case 153: break; case 76: { String txt = yytext(); if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } if (DEBUG) { logger.info(""Used {PHONE} to recognize "" + yytext() + "" as "" + txt); } return getNext(txt, yytext()); } case 154: break; case 77: // general lookahead, find correct zzMarkedPos { int zzFState = 25; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 27; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 155: break; case 78: // general lookahead, find correct zzMarkedPos { int zzFState = 25; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 26; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 156: break; default: zzScanError(ZZ_NO_MATCH); } } } }"	"  public Object next() throws java.io.IOException {
    int zzInput;
    int zzAction;

    // cached fields:
    int zzCurrentPosL;
    int zzMarkedPosL;
    int zzEndReadL = zzEndRead;
    char [] zzBufferL = zzBuffer;
    char [] zzCMapL = ZZ_CMAP;

    int [] zzTransL = ZZ_TRANS;
    int [] zzRowMapL = ZZ_ROWMAP;
    int [] zzAttrL = ZZ_ATTRIBUTE;

    while (true) {
      zzMarkedPosL = zzMarkedPos;

      yychar+= zzMarkedPosL-zzStartRead;

      zzAction = -1;

      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
  
      zzState = ZZ_LEXSTATE[zzLexicalState];

      // set up zzAction for empty match case:
      int zzAttributes = zzAttrL[zzState];
      if ( (zzAttributes & 1) == 1 ) {
        zzAction = zzState;
      }


      zzForAction: {
        while (true) {
    
          if (zzCurrentPosL < zzEndReadL) {
            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);
            zzCurrentPosL += Character.charCount(zzInput);
          }
          else if (zzAtEOF) {
            zzInput = YYEOF;
            break zzForAction;
          }
          else {
            // store back cached positions
            zzCurrentPos  = zzCurrentPosL;
            zzMarkedPos   = zzMarkedPosL;
            boolean eof = zzRefill();
            // get translated positions and possibly new buffer
            zzCurrentPosL  = zzCurrentPos;
            zzMarkedPosL   = zzMarkedPos;
            zzBufferL      = zzBuffer;
            zzEndReadL     = zzEndRead;
            if (eof) {
              zzInput = YYEOF;
              break zzForAction;
            }
            else {
              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);
              zzCurrentPosL += Character.charCount(zzInput);
            }
          }
          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
          if (zzNext == -1) break zzForAction;
          zzState = zzNext;

          zzAttributes = zzAttrL[zzState];
          if ( (zzAttributes & 1) == 1 ) {
            zzAction = zzState;
            zzMarkedPosL = zzCurrentPosL;
            if ( (zzAttributes & 8) == 8 ) break zzForAction;
          }

        }
      }

      // store back cached position
      zzMarkedPos = zzMarkedPosL;

      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
        zzAtEOF = true;
              {
                if (invertible) {
            // prevWordAfter.append(yytext());
            String str = prevWordAfter.toString();
            // System.err.println(""At end of text making after: |"" + str + ""|"");
            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);
            // System.err.println(""prevWord is |"" + prevWord.get(CoreAnnotations.TextAnnotation.class) + ""|, its after is |"" +
            //         prevWord.get(CoreAnnotations.AfterAnnotation.class) + ""|"");
            prevWordAfter.setLength(0);
          }
          return null;
              }
      }
      else {
        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
          case 1: 
            { String str = yytext();
          int first = str.codePointAt(0);
          String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"",
                          yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));
          switch (untokenizable) {
            case NONE_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              break;
            case FIRST_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              if ( ! this.seenUntokenizableCharacter) {
                logger.warning(msg);
                this.seenUntokenizableCharacter = true;
              }
              break;
            case ALL_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              logger.warning(msg);
              this.seenUntokenizableCharacter = true;
              break;
            case NONE_KEEP:
              return getNext();
            case FIRST_KEEP:
              if ( ! this.seenUntokenizableCharacter) {
                logger.warning(msg);
                this.seenUntokenizableCharacter = true;
              }
              return getNext();
            case ALL_KEEP:
              logger.warning(msg);
              this.seenUntokenizableCharacter = true;
              return getNext();
          }
            }
          case 77: break;
          case 2: 
            { return getNext(""<"", yytext());
            }
          case 78: break;
          case 3: 
            { return getNext();
            }
          case 79: break;
          case 4: 
            { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {
                    return getNext(ptbmdash, yytext());
                  } else {
                    return getNext();
                  }
            }
          case 80: break;
          case 5: 
            { if (tokenizeNLs) {
                      return getNext(AbstractTokenizer.NEWLINE_TOKEN, yytext()); // for tokenizing newliens
                  } else if (invertible) {
                    // System.err.println(""Appending newline: |"" + yytext() + ""|"");
                    prevWordAfter.append(yytext());
                  }
            }
          case 81: break;
          case 6: 
            { final String origTxt = yytext();
                          String tok = LexerUtils.removeSoftHyphens(origTxt);
                          if (americanize) {
                            tok = Americanize.americanize(tok);
                          }
                          if (DEBUG) { logger.info(""Used {WORD} (2) to recognize "" + origTxt + "" as "" + tok); }
                          return getNext(tok, origTxt);
            }
          case 82: break;
          case 7: 
            { if (invertible) {
                     prevWordAfter.append(yytext());
                  }
            }
          case 83: break;
          case 8: 
            { String tok = yytext();
                  String norm = handleQuotes(tok, false);
                  if (DEBUG) { logger.info(""Used {QUOTES} (3) to recognize "" + tok + "" as "" + norm +
                                           ""; probablyLeft="" + false); }
                  return getNext(norm, tok);
            }
          case 84: break;
          case 9: 
            { String tok = yytext();
                          String norm = handleQuotes(tok, false);
                          if (DEBUG) { logger.info(""Used {SREDAUX} to recognize "" + tok + "" as "" + norm +
                                                   ""; probablyLeft="" + false); }
                          return getNext(norm, tok);
            }
          case 85: break;
          case 10: 
            { if (escapeForwardSlashAsterisk) {
                    return getNext(delimit(yytext(), '/'), yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 86: break;
          case 11: 
            { return getNext("">"", yytext());
            }
          case 87: break;
          case 12: 
            { if (ptb3Dashes) {
                            return getNext(ptbmdash, yytext()); }
                          else {
                            return getNext();
                          }
            }
          case 88: break;
          case 13: 
            { handleHyphenatedNumber(yytext());
                          if (DEBUG) { logger.info(""Used {NUMBER} to recognize "" + yytext() + "" as "" + removeFromNumber(yytext())); }
                          return getNext(removeFromNumber(yytext()), yytext());
            }
          case 89: break;
          case 14: 
            { return handleEllipsis(yytext());
            }
          case 90: break;
          case 15: 
            { // breakByHyphens(yytext()); // this is causing fail of attempted to pushback too much!
                  String tok = yytext();
                  /* A THING can contain quote like O'Malley */
                  String norm = handleQuotes(tok, false);
                  if (DEBUG) { logger.info(""Used {THING} (2) to recognize "" + tok + "" as "" + norm +
                                           ""; probablyLeft="" + false); }
                  return getNext(norm, tok);
            }
          case 91: break;
          case 16: 
            { String txt = yytext();
                  String norm = normalizeFractions(yytext());
                  if (DEBUG) { logger.info(""Used {FRAC2} to recognize "" + txt + "" as "" + norm +
                                       ""; normalizeFractions="" + normalizeFractions +
                                       "", escapeForwardSlashAsterisk="" + escapeForwardSlashAsterisk); }
                  return getNext(norm, txt);
            }
          case 92: break;
          case 17: 
            { if (normalizeCurrency) {
                            return getNext(LexerUtils.normalizeCurrency(yytext()), yytext());
                        } else {
                            return getNext(LexerUtils.minimallyNormalizeCurrency(yytext()), yytext());
                          }
            }
          case 93: break;
          case 18: 
            { if (normalizeOtherBrackets) {
                    return getNext(""-RSB-"", yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 94: break;
          case 19: 
            { if (normalizeOtherBrackets) {
                    return getNext(closebrace, yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 95: break;
          case 20: 
            { if (normalizeParentheses) {
                    return getNext(openparen, yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 96: break;
          case 21: 
            { if (normalizeParentheses) {
                    return getNext(closeparen, yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 97: break;
          case 22: 
            { if (escapeForwardSlashAsterisk) {
                    return getNext(delimit(yytext(), '*'), yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 98: break;
          case 23: 
            { if (normalizeOtherBrackets) {
                    return getNext(openbrace, yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 99: break;
          case 24: 
            { if (normalizeOtherBrackets) {
                    return getNext(""-LSB-"", yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 100: break;
          case 25: 
            { String tok = yytext();
                        String norm = LexerUtils.processCp1252misc(tok);
                        if (DEBUG) { logger.info(""Used {CP1252_MISC_SYMBOL} to recognize "" + tok + "" as "" + norm); }
                        return getNext(norm, tok);
            }
          case 101: break;
          case 26: 
            { if (invertible) {
                            prevWordAfter.append(yytext());
                        }
            }
          case 102: break;
          case 27: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 15;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 16;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return getNext();
            }
          case 103: break;
          case 28: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { return getNext();
            }
          case 104: break;
          case 29: 
            { String tok = yytext();
                  String norm = handleQuotes(tok, false);
                  if (DEBUG) { logger.info(""Used {REDAUX} (2) to recognize "" + tok + "" as "" + norm +
                                           ""; probablyLeft="" + false); }
                  return getNext(norm, tok);
            }
          case 105: break;
          case 30: 
            { String tok = yytext();
                          String norm = handleQuotes(tok, false);
                          if (DEBUG) { logger.info(""Used {APOWORD} to recognize "" + tok + "" as "" + norm +
                                                   ""; probablyLeft="" + false); }
                          return getNext(norm, tok);
            }
          case 106: break;
          case 31: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { String tok = yytext();
                                   String norm = handleQuotes(tok, true);
                                   if (DEBUG) { logger.info(""Used {DBLQUOT} to recognize "" + tok + "" as "" + norm +
                                                            ""; probablyLeft="" + true); }
                                   return getNext(norm, tok);
            }
          case 107: break;
          case 32: 
            { String tok = yytext();
                    if (DEBUG) { logger.info(""Used {PROG_LANGS} to recognize "" + tok + "" as "" + tok); }
                    return getNext(tok, tok);
            }
          case 108: break;
          case 33: 
            { String txt = yytext();
                  String origText = txt;
                  if (normalizeParentheses) {
                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                  }
                  return getNext(txt, origText);
            }
          case 109: break;
          case 34: 
            { breakByHyphens(yytext());
                  if (DEBUG) { logger.info(""Used {HTHING} to recognize "" + yytext() + "" as "" + LexerUtils.removeSoftHyphens(yytext())); }
                  return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext());
            }
          case 110: break;
          case 35: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 3;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 4;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { final String origTxt = yytext();
                          String tok = LexerUtils.removeSoftHyphens(origTxt);
                          if (americanize) {
                            tok = Americanize.americanize(tok);
                          }
                          if (DEBUG) { logger.info(""Used {WORD} to recognize "" + origTxt + "" as "" + tok); }
                          return getNext(tok, origTxt);
            }
          case 111: break;
          case 36: 
            { if (escapeForwardSlashAsterisk) {
                            return getNext(delimit(yytext(), '/'), yytext());
                          } else {
                            return getNext();
                          }
            }
          case 112: break;
          case 37: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { String origTok = yytext();
                          String norm = LexerUtils.removeSoftHyphens(origTok);
                          if (DEBUG) { logger.info(""Used {WORD} (3) to recognize "" + origTok + "" as "" + norm); }
                          return getNext(norm, origTok);
            }
          case 113: break;
          case 38: 
            { // this one should only match if we're basically at the end of file
                          // since the last one matches two things, even newlines (if not tokenize per line)
                          return processAbbrev1();
            }
          case 114: break;
          case 39: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { String txt = yytext();
                  String origText = txt;
                  if (normalizeParentheses) {
                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                  }
                  return getNext(txt, origText);
            }
          case 115: break;
          case 40: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);
            { // Extra context is to not match on ones like 'd but you do want words like ""a""
                  // can't have digit here because of cases like '90s
                  String tok = yytext();
                  /* invert single quote - often but not always right */
                  String norm = handleQuotes(tok, true);
                  if (DEBUG) { logger.info(""Used {QUOTES} to recognize "" + tok + "" as "" + norm +
                                           ""; probablyLeft="" + true); }
                  return getNext(norm, tok);
            }
          case 116: break;
          case 41: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { String tok = yytext();
                          String norm = handleQuotes(tok, false);
                          if (DEBUG) { logger.info(""Used {REDAUX} to recognize "" + tok + "" as "" + norm +
                                                   ""; probablyLeft="" + false); }
                          return getNext(norm, tok);
            }
          case 117: break;
          case 42: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);
            { // Extra context is to not match on ones like 'd but you do want words like ""a""
                  // can't have digit here because of cases like '90s
                  String tok = yytext();
                  /* invert single quote - often but not always right */
                  String norm = handleQuotes(tok, true);
                  if (DEBUG) { logger.info(""Used {QUOTES} (2) to recognize "" + tok + "" as "" + norm +
                                           ""; probablyLeft="" + true); }
                  return getNext(norm, tok);
            }
          case 118: break;
          case 43: 
            { return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext());
            }
          case 119: break;
          case 44: 
            { String tok = yytext();
                  String norm = handleQuotes(tok, false);
                  if (DEBUG) { logger.info(""Used {SREDAUX} (2) to recognize "" + tok + "" as "" + norm +
                                           ""; probablyLeft="" + false); }
                  return getNext(norm, tok);
            }
          case 120: break;
          case 45: 
            { if (splitAssimilations) {
                      yypushback(2);
                    }
                    String tok = yytext();
                    if (DEBUG) { logger.info(""Used {ASSIMILATIONS3} to recognize "" + tok + "" as "" + tok +
                            ""; splitAssimilations="" + splitAssimilations); }
                    return getNext(tok, tok);
            }
          case 121: break;
          case 46: 
            { String txt = yytext();
                  // if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space...
                  if (strictTreebank3) {
                    int spaceIndex = indexOfSpace(txt);
                    if (spaceIndex >= 0) {
                      yypushback(txt.length() - spaceIndex);
                      return getNext();
                    }
                  }
                  if (escapeForwardSlashAsterisk) {
                    txt = delimit(txt, '/');
                  }
                  if (normalizeSpace) {
                    txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                  }
                  return getNext(txt, yytext());
            }
          case 122: break;
          case 47: 
            { final String origTxt = yytext();
                          String tok;
                          if (normalizeAmpersandEntity) {
                            tok = LexerUtils.normalizeAmp(origTxt);
                          } else {
                            tok = origTxt;
                          }
                          if (DEBUG) { logger.info(""Used {THINGA} (2) to recognize "" + origTxt + "" as "" + tok); }
                          return getNext(tok, origTxt);
            }
          case 123: break;
          case 48: 
            { final String origTxt = yytext();
                          String txt = origTxt;
                          if (normalizeSpace) {
                            txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                          }
                          return getNext(txt, origTxt);
            }
          case 124: break;
          case 49: 
            { final String origTxt = yytext();
                          String txt = origTxt;
                          if (normalizeSpace) {
                            txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                          }
                          return getNext(txt, origTxt);
            }
          case 125: break;
          case 50: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 5;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 6;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { final String origTxt = yytext();
                          String tok = LexerUtils.removeSoftHyphens(origTxt);
                          if (DEBUG) { logger.info(""Used {SWORD} to recognize "" + origTxt + "" as "" + tok); }
                          return getNext(tok, origTxt);
            }
          case 126: break;
          case 51: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 17;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 16;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return getNext();
            }
          case 127: break;
          case 52: 
            { String txt = yytext();
                  String normTok = txt;
                  if (escapeForwardSlashAsterisk) {
                    normTok = delimit(normTok, '*');
                  }
                  if (DEBUG) { logger.info(""Used {SWEARING} to recognize "" + txt + "" as "" + normTok); }
                  return getNext(normTok, txt);
            }
          case 128: break;
          case 53: 
            { final String origTxt = yytext();
                  String tok;
                  if (normalizeAmpersandEntity) {
                    tok = LexerUtils.normalizeAmp(origTxt);
                  } else {
                    tok = origTxt;
                  }
                  if (DEBUG) { logger.info(""Used {TBSPEC} to recognize "" + origTxt + "" as "" + tok); }
                  return getNext(tok, origTxt);
            }
          case 129: break;
          case 54: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { String tok = yytext();
                          String norm = handleQuotes(tok, false);
                          if (DEBUG) { logger.info(""Used {SREDAUX} to recognize "" + tok + "" as "" + norm +
                                                   ""; probablyLeft="" + false); }
                          return getNext(norm, tok);
            }
          case 130: break;
          case 55: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 10;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 11;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return processAbbrev3();
            }
          case 131: break;
          case 56: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 20;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 22;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */
                                    return handleEllipsis(yytext());
            }
          case 132: break;
          case 57: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 18;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 19;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return getNext();
            }
          case 133: break;
          case 58: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 10;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 11;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return processAbbrev3();
            }
          case 134: break;
          case 59: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 20;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 21;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */
                                    return handleEllipsis(yytext());
            }
          case 135: break;
          case 60: 
            { String txt = yytext();
                          if (escapeForwardSlashAsterisk) {
                            txt = delimit(txt, '/');
                            txt = delimit(txt, '*');
                          }
                          return getNext(txt, yytext());
            }
          case 136: break;
          case 61: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { String tok = yytext();
                  breakByHyphens(tok);
                  tok = yytext();
                  String norm = LexerUtils.removeSoftHyphens(tok);
                  if (DEBUG) { logger.info(""Used {HTHING} (2) to recognize "" + tok + "" as "" + norm); }
                  return getNext(norm, tok);
            }
          case 137: break;
          case 62: 
            { if (splitAssimilations) {
                      yypushback(3);
                    }
                    String tok = yytext();
                    if (DEBUG) { logger.info(""Used {ASSIMILATIONS3} to recognize "" + tok + "" as "" + tok +
                            ""; splitAssimilations="" + splitAssimilations); }
                    return getNext(tok, tok);
            }
          case 138: break;
          case 63: 
            { final String origTxt = yytext();
                          String tok;
                          if (normalizeAmpersandEntity) {
                            tok = LexerUtils.normalizeAmp(origTxt);
                          } else {
                            tok = origTxt;
                          }
                          if (DEBUG) { logger.info(""Used {SPAMP} to recognize "" + origTxt + "" as "" + tok); }
                          return getNext(tok, origTxt);
            }
          case 139: break;
          case 64: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext());
            }
          case 140: break;
          case 65: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { final String origTxt = yytext();
                          String tok;
                          if (normalizeAmpersandEntity) {
                            tok = LexerUtils.normalizeAmp(origTxt);
                          } else {
                            tok = origTxt;
                          }
                          if (DEBUG) { logger.info(""Used {THINGA} to recognize "" + origTxt + "" as "" + tok); }
                          return getNext(tok, origTxt);
            }
          case 141: break;
          case 66: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 7;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 9;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return processAcronym();
            }
          case 142: break;
          case 67: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);
            { return getNext();
            }
          case 143: break;
          case 68: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 12;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 14;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return processAbbrev1();
            }
          case 144: break;
          case 69: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 7;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 8;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return processAcronym();
            }
          case 145: break;
          case 70: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 12;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 13;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return processAbbrev1();
            }
          case 146: break;
          case 71: 
            { String txt = yytext();
                          if (escapeForwardSlashAsterisk) {
                            txt = delimit(txt, '/');
                          }
                          return getNext(txt, yytext());
            }
          case 147: break;
          case 72: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4);
            { return getNext();
            }
          case 148: break;
          case 73: 
            // lookahead expression with fixed base length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);
            { return getNext();
            }
          case 149: break;
          case 74: 
            { String txt = yytext();
                          if (normalizeSpace) {
                            txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                          }
                          if (normalizeParentheses) {
                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                          }
                          if (DEBUG) { logger.info(""Used {PHONE} to recognize "" + yytext() + "" as "" + txt); }
                          return getNext(txt, yytext());
            }
          case 150: break;
          case 75: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 23;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 25;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */
                                    return handleEllipsis(yytext());
            }
          case 151: break;
          case 76: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 23;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 24;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */
                                    return handleEllipsis(yytext());
            }
          case 152: break;
          default:
            zzScanError(ZZ_NO_MATCH);
        }
      }
    }
  }
"	Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.	Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.	0	1	21	1164	8301
public Charset getEncoding() { return _charset; }	"	public String getEncoding() {
		return _charset;
	}
"	Returns the encoding used to send and receive lines from the IRC server.	Returns the encoding used to send and receive lines from the IRC server, or null if not set.	1	0	4	5	10
@NonNull protected List<Action> retrieveActions(@NonNull SCMHead head, @NonNull SCMHeadEvent event, @NonNull TaskListener listener) throws IOException, InterruptedException { return Collections.emptyList(); }	"    @NonNull
    protected Map<Class<? extends Action>, Action> retrieveActions(@NonNull SCMHead head,
                                                                   @NonNull TaskListener listener)
            throws IOException, InterruptedException {
        return Collections.emptyMap();
    }
"	SPI for  #fetchActions(SCMHead, SCMHeadEvent, TaskListener).	SPI for #fetchActions(SCMHead, TaskListener).	1	0	5	9	34
public DateTimeFormatterBuilder appendMinuteOfDay(final int minDigits) { return appendDecimal(iChronoUTC.minuteOfDay(), minDigits, 4); }	"    public DateTimeFormatterBuilder appendMinuteOfDay(final int minDigits) {
        return appendNumeric(iChronoUTC.minuteOfDay(), minDigits, 4);
    }
"	Instructs the printer to emit a numeric minuteOfDay field.	Instructs the printer to emit a numeric minuteOfDay field.	0	1	5	4	23
public boolean matches( Method method, Class targetClass) { return ( (method.getAnnotation( RequiresPermissions.class ) != null ) || (method.getAnnotation( RequiresRoles.class ) != null ) ); }	"    public boolean matches( Method method, Class targetClass) {
        return ( (method.getAnnotation( PermissionsRequired.class ) != null ) ||
                 (method.getAnnotation( RolesRequired.class ) != null ) );
    }
"	Returns true if the method has a JSecurity RequiresRoles or RequiresPermissions annotation, false otherwise.	Returns true if the method has a JSecurity RolesRequired or PermissionsRequired annotation, false otherwise.	1	0	8	6	38
public int getLeapAmount() { return getField().getLeapAmount(getMillis()); }	"    public int getLeapAmount() {
        return getField().getLeapAmount(getReadableInstant().getMillis());
    }
"	Gets the amount by which this field is leap.	Gets the amount by which this field is leap.	0	1	6	4	18
protected IsolationLevel getTransactionIsolation() { return this.transactionIsolationLevel; }	"	protected TransactionIsolation getTransactionIsolation() {
		return this.transactionIsolationLevel;
	}
"	Retrieve the currently specified  IsolationLevel level.	Retrieve the currently specified TransactionIsolation level.	1	0	5	5	11
public static EBoolean contains(Expr<String> left, String right) { return factory.createBoolean(Ops.CONTAINS, left, factory.createConstant(right)); }	"    public static EBoolean contains(Expr<String> left, String right) {
        return createBoolean(Ops.CONTAINS, left, createConstant(right));
    }
"	Expr : left || right	Expr : left || right	0	1	6	4	30
public static Set<String> getAllSupportedComponentTypes() { return SUPPORTED_COMPONENT_TYPES; }	"    public static int[] getAllSupportedComponentTypes() {
        return SUPPORTED_COMPONENT_TYPES;
    }
"	Returns an array of all supported component types	Returns an array of codes representing all supported component types (see specific type constants).	1	0	5	5	12
"public static Map<String, String> getProperties(Object object) throws Exception { if (object == null) { return Collections.emptyMap(); } Map<String, String> props = new LinkedHashMap<String, String>(); BeanInfo beanInfo = Introspector.getBeanInfo(object.getClass()); Object[] NULL_ARG = {}; PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors(); if (propertyDescriptors != null) { for (int i = 0; i < propertyDescriptors.length; i++) { PropertyDescriptor pd = propertyDescriptors[i]; if (pd.getReadMethod() != null && !pd.getName().equals(""class"") && !pd.getName().equals(""properties"") && !pd.getName().equals(""reference"")) { Object value = pd.getReadMethod().invoke(object, NULL_ARG); if (value != null) { if (value instanceof Boolean || value instanceof Number || value instanceof String || value instanceof URI || value instanceof URL) { props.put(pd.getName(), ("""" + value)); } else if (value instanceof SSLContext) { // ignore this one.. } else { Map<String, String> inner = getProperties(value); for (Map.Entry<String, String> entry : inner.entrySet()) { props.put(pd.getName() + ""."" + entry.getKey(), entry.getValue()); } } } } } } return props; }"	"    public static Map<String, String> getProperties(Object object) throws Exception {
        Map<String, String> props = new LinkedHashMap<String, String>();
        BeanInfo beanInfo = Introspector.getBeanInfo(object.getClass());
        Object[] NULL_ARG = {};
        PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors();
        if (propertyDescriptors != null) {
            for (int i = 0; i < propertyDescriptors.length; i++) {
                PropertyDescriptor pd = propertyDescriptors[i];
                if (pd.getReadMethod() != null && !pd.getName().equals(""class"") && !pd.getName().equals(""properties"") && !pd.getName().equals(""reference"")) {
                    Object value = pd.getReadMethod().invoke(object, NULL_ARG);
                    if (value != null) {
                        if (value instanceof Boolean || value instanceof Number || value instanceof String || value instanceof URI || value instanceof URL) {
                            props.put(pd.getName(), ("""" + value));
                        } else if (value instanceof SSLContext) {
                            // ignore this one..
                        } else {
                            Map<String, String> inner = getProperties(value);
                            for (Map.Entry<String, String> entry : inner.entrySet()) {
                                props.put(pd.getName() + ""."" + entry.getKey(), entry.getValue());
                            }
                        }
                    }
                }
            }
        }
        return props;
    }
"	Get properties from an object using reflection.	Get properties from an object	1	0	20	33	282
public int getIconUtfValue(String icon) { if (iconMap.containsKey(icon)) { return iconMap.get(icon); } else { return 0; } }	"    public int getIconUtfValue(String icon) {
        return iconMap.get(icon);
    }
"	Loads a  Typeface for the given icon font.	Loads a Typeface for the given icon font.	0	1	7	8	32
public Object getCache(PGraphics renderer) { return g.getCache(renderer); }	"  public PMetadata getCache(PGraphics renderer) {
    return g.getCache(renderer);
  }
"	Get cache storage data for the specified renderer.	Get cache storage data for the specified renderer.	0	1	5	4	16
protected ComponentTemplate getMetaData( final Object entry ) { return (ComponentTemplate)entry; }	"    protected ComponentMetaData getMetaData( final Object entry )
    {
        return (ComponentMetaData)entry;
    }
"	Return the ComponentTemplate for specified component entry.	Return the org.jcontainer.loom.components.util.metadata.ComponentMetaData for specified component entry.	1	0	5	6	16
"public List<GmailMessage> getPriorityMessages(boolean unreadOnly){ try { final List<GmailMessage> priorityMessages = new ArrayList<GmailMessage>(); final Store store = openGmailStore(); Folder folder = getFolder(ImapGmailLabel.IMPORTANT.getName(),store); folder.open(Folder.READ_ONLY); for (final Message msg : folder.search(new FlagTerm( new Flags(Flags.Flag.SEEN), !unreadOnly))) { priorityMessages.add(new JavaMailGmailMessage(msg)); } return priorityMessages; } catch (final Exception e) { throw new GmailException(""Failed getting priority messages"", e); } }"	"    public List<GmailMessage> getPriorityMessages(){
        try {
            final List<GmailMessage> unreadPriority = new ArrayList<GmailMessage>();
            final Store store = openGmailStore();
            Folder folder = getFolder(ImapGmailLabel.IMPORTANT.getName(),store);
            folder.open(Folder.READ_ONLY);
            for (final Message msg : folder.search(new FlagTerm(
                    new Flags(Flags.Flag.SEEN), false))) {
                unreadPriority.add(new JavaMailGmailMessage(msg));
            }
            
            return unreadPriority;
        } catch (final Exception e) {
            throw new GmailException(""Failed getting unread priority messages"", e);
        }
    }
"	Returns list of unread/read priority  GmailMessage objects based on the  unreadOnly value	Returns list of unread priority GmailMessage objects	1	0	9	18	112
public TokenStream duplicate() { DuplicatedTokenStream duplicate = new DuplicatedTokenStream(inputStream); duplicatedStreams.add(duplicate); return duplicate; }	"  public TwitterTokenStream duplicate() {
    DuplicatedTokenStream duplicate = new DuplicatedTokenStream(inputStream);
    duplicatedStreams.add(duplicate);

    return duplicate;
  }
"	Returns a new TokenStream which provides the same output as the original TokenStream.	Returns a new TwitterTokenStream which provides the same output as the original TwitterTokenStream.	1	0	6	8	24
public InstantConverter removeInstantConverter(InstantConverter converter) throws SecurityException { checkAlterInstantConverters(); if (converter == null) { return null; } InstantConverter[] removed = new InstantConverter[1]; iInstantConverters = iInstantConverters.remove(converter, removed); return removed[0]; }	"    public InstantConverter removeInstantConverter(int index) throws SecurityException {
        checkAlterInstantConverters();
        InstantConverter[] removed = new InstantConverter[1];
        iInstantConverters = iInstantConverters.remove(index, removed);
        return removed[0];
    }
"	Removes a converter from the set of converters.	Removes a converter from the set of converters, by index.	1	0	6	12	50
public Object get(long timeout, String key) throws TimeoutException { SynchronizationObject<CachedData[]> sync=setupGet(key); waitForNotNull(timeout, sync); CachedData[] rvContainer=sync.get(); assert rvContainer.length == 1; Object rv=null; if(rvContainer[0] != null) { rv=transcoder.decode(rvContainer[0]); } return rv; }	"	public Map<String, Object> get(String... keys) {
		final Map<String, Object> rv=new ConcurrentHashMap<String, Object>();
		final AtomicInteger requests=new AtomicInteger();
		final SynchronizationObject<AtomicInteger> sync
			=new SynchronizationObject<AtomicInteger>(requests);
		GetOperation.Callback cb=new GetOperation.Callback() {
				public void getComplete() {
					requests.decrementAndGet();
					sync.set(requests);
				}
				public void gotData(String k, int flags, byte[] data) {
					rv.put(k, transcoder.decode(new CachedData(flags, data)));
				}
		};
		// Break the gets down into groups by key
		Map<Integer, Collection<String>> chunks
			=new HashMap<Integer, Collection<String>>();
		for(String key : keys) {
			int which=getServerForKey(key);
			Collection<String> ks=chunks.get(which);
			if(ks == null) {
				ks=new ArrayList<String>();
				chunks.put(which, ks);
			}
			ks.add(key);
		}
		for(Map.Entry<Integer, Collection<String>> me : chunks.entrySet()) {
			requests.incrementAndGet();
			addOp(me.getKey(), new GetOperation(me.getValue(), cb));
		}
		try {
			sync.waitUntilTrue(
					new SynchronizationObject.Predicate<AtomicInteger>() {
						public boolean evaluate(AtomicInteger val) {
							return val.get() == 0;
						}},
					Long.MAX_VALUE, TimeUnit.SECONDS);
		} catch (InterruptedException e) {
			throw new RuntimeException(""Interrupted waiting for results"", e);
		} catch (TimeoutException e) {
			throw new RuntimeException(""Timed out waiting forever"", e);
		}
		return rv;
	}
"	Get with a single key.	Get the values for multiple keys from the cache.	1	0	10	13	73
public ProcessingPartitionScanner getProcessingPartitionScanner() { return (fPartitionScanner == null) ? new ProcessingPartitionScanner() : fPartitionScanner; }	"	 public ProcessingPartitionScanner getProcessingPartitionScanner() {
		if (fPartitionScanner == null)
			fPartitionScanner= new ProcessingPartitionScanner();
		return fPartitionScanner;
	}
"	Return a scanner for creating Processing partitions.	Return a scanner for creating Processing partitions.	0	1	6	4	20
"private Symbol generate(Resolver.Action action, Map<Object, Symbol> seen) throws IOException { if (action instanceof Resolver.DoNothing) { return simpleGen(action.writer, seen); } else if (action instanceof Resolver.ErrorAction) { return Symbol.error(action.toString()); } else if (action instanceof Resolver.Skip) { return Symbol.skipAction(simpleGen(action.writer, seen)); } else if (action instanceof Resolver.Promote) { return Symbol.resolve(simpleGen(action.writer, seen), simpleGen(action.reader, seen)); } else if (action instanceof Resolver.ReaderUnion) { Resolver.ReaderUnion ru = (Resolver.ReaderUnion) action; Symbol s = generate(ru.actualAction, seen); return Symbol.seq(Symbol.unionAdjustAction(ru.firstMatch, s), Symbol.UNION); } else if (action.writer.getType() == Schema.Type.ARRAY) { Symbol es = generate(((Resolver.Container) action).elementAction, seen); return Symbol.seq(Symbol.repeat(Symbol.ARRAY_END, es), Symbol.ARRAY_START); } else if (action.writer.getType() == Schema.Type.MAP) { Symbol es = generate(((Resolver.Container) action).elementAction, seen); return Symbol.seq(Symbol.repeat(Symbol.MAP_END, es, Symbol.STRING), Symbol.MAP_START); } else if (action.writer.getType() == Schema.Type.UNION) { if (((Resolver.WriterUnion) action).unionEquiv) return simpleGen(action.writer, seen); Resolver.Action[] branches = ((Resolver.WriterUnion) action).actions; Symbol[] symbols = new Symbol[branches.length]; String[] labels = new String[branches.length]; int i = 0; for (Resolver.Action branch : branches) { symbols[i] = generate(branch, seen); labels[i] = action.writer.getTypes().get(i).getFullName(); i++; } return Symbol.seq(Symbol.alt(symbols, labels), Symbol.WRITER_UNION_ACTION); } else if (action instanceof Resolver.EnumAdjust) { Resolver.EnumAdjust e = (Resolver.EnumAdjust) action; Object[] adjs = new Object[e.adjustments.length]; for (int i = 0; i < adjs.length; i++) adjs[i] = (0 <= e.adjustments[i] ? new Integer(e.adjustments[i]) : ""No match for "" + e.writer.getEnumSymbols().get(i)); return Symbol.seq(Symbol.enumAdjustAction(e.reader.getEnumSymbols().size(), adjs), Symbol.ENUM); } else if (action instanceof Resolver.RecordAdjust) { Symbol result = seen.get(action); if (result == null) { final Resolver.RecordAdjust ra = (Resolver.RecordAdjust) action; int defaultCount = ra.readerOrder.length - ra.firstDefault; int count = 1 + ra.fieldActions.length + 3 * defaultCount; Symbol[] production = new Symbol[count]; result = Symbol.seq(production); seen.put(action, result); production[--count] = Symbol.fieldOrderAction(ra.readerOrder); for (Resolver.Action wfa : ra.fieldActions) production[--count] = generate(wfa, seen); for (int i = ra.firstDefault; i < ra.readerOrder.length; i++) { Schema.Field rf = ra.readerOrder[i]; byte[] bb = getBinary(rf.schema(), Accessor.defaultValue(rf)); production[--count] = Symbol.defaultStartAction(bb); production[--count] = simpleGen(rf.schema(), seen); production[--count] = Symbol.DEFAULT_END_ACTION; } } return result; } throw new IllegalArgumentException(""Unrecognized Resolver.Action: "" + action); }"	"  private Symbol generate(Resolver.Action action, Map<Object, Symbol> seen) throws IOException {
    if (action instanceof Resolver.DoNothing) {
      return simpleGen(action.writer, seen);

    } else if (action instanceof Resolver.ErrorAction) {
      return Symbol.error(action.toString());

    } else if (action instanceof Resolver.Skip) {
      return Symbol.skipAction(simpleGen(action.writer, seen));

    } else if (action instanceof Resolver.Promote) {
      return Symbol.resolve(simpleGen(action.writer, seen), simpleGen(action.reader, seen));

    } else if (action.writer.getType() == Schema.Type.ARRAY) {
      Symbol es = generate(((Resolver.Container) action).elementAction, seen);
      return Symbol.seq(Symbol.repeat(Symbol.ARRAY_END, es), Symbol.ARRAY_START);

    } else if (action.writer.getType() == Schema.Type.MAP) {
      Symbol es = generate(((Resolver.Container) action).elementAction, seen);
      return Symbol.seq(Symbol.repeat(Symbol.MAP_END, es, Symbol.STRING), Symbol.MAP_START);

    } else if (action.writer.getType() == Schema.Type.UNION) {
      if (((Resolver.WriterUnion) action).unionEquiv)
        return simpleGen(action.writer, seen);
      Resolver.Action[] branches = ((Resolver.WriterUnion) action).actions;
      Symbol[] symbols = new Symbol[branches.length];
      String[] labels = new String[branches.length];
      int i = 0;
      for (Resolver.Action branch : branches) {
        symbols[i] = generate(branch, seen);
        labels[i] = action.writer.getTypes().get(i).getFullName();
        i++;
      }
      return Symbol.seq(Symbol.alt(symbols, labels), Symbol.WRITER_UNION_ACTION);

    } else if (action instanceof Resolver.ReaderUnion) {
      Resolver.ReaderUnion ru = (Resolver.ReaderUnion) action;
      Symbol s = generate(ru.actualAction, seen);
      return Symbol.seq(Symbol.unionAdjustAction(ru.firstMatch, s), Symbol.UNION);

    } else if (action instanceof Resolver.EnumAdjust) {
      Resolver.EnumAdjust e = (Resolver.EnumAdjust) action;
      Object[] adjs = new Object[e.adjustments.length];
      for (int i = 0; i < adjs.length; i++)
        adjs[i] = (0 <= e.adjustments[i] ? new Integer(e.adjustments[i])
            : ""No match for "" + e.writer.getEnumSymbols().get(i));
      return Symbol.seq(Symbol.enumAdjustAction(e.reader.getEnumSymbols().size(), adjs), Symbol.ENUM);

    } else if (action instanceof Resolver.RecordAdjust) {
      Symbol result = seen.get(action);
      if (result == null) {
        final Resolver.RecordAdjust ra = (Resolver.RecordAdjust) action;
        int defaultCount = ra.readerOrder.length - ra.firstDefault;
        int count = 1 + ra.fieldActions.length + 3 * defaultCount;
        Symbol[] production = new Symbol[count];
        result = Symbol.seq(production);
        seen.put(action, result);
        production[--count] = Symbol.fieldOrderAction(ra.readerOrder);
        for (Resolver.Action wfa : ra.fieldActions)
          production[--count] = generate(wfa, seen);
        for (int i = ra.firstDefault; i < ra.readerOrder.length; i++) {
          Schema.Field rf = ra.readerOrder[i];
          byte[] bb = getBinary(rf.schema(), Accessor.defaultValue(rf));
          production[--count] = Symbol.defaultStartAction(bb);
          production[--count] = simpleGen(rf.schema(), seen);
          production[--count] = Symbol.DEFAULT_END_ACTION;
        }
      }
      return result;
    }

    throw new IllegalArgumentException(""Unrecognized Resolver.Action: "" + action);
  }
"	Takes a  Resolver.Action for resolving two schemas and returns the start symbol for a grammar that implements that resolution.	Takes a Resolver.Action for resolving two schemas and returns the start symbol for a grammar that implements that resolution.	0	1	22	73	707
public Remote getPort(QName portName, Class proxyInterface) throws ServiceException { // First, try to find a generated stub. If that // returns null, then find a dynamic stub. Remote stub = getGeneratedStub(portName, proxyInterface); return stub != null ? stub : getPort(null, portName, proxyInterface); }	"    public Remote getPort(QName portName, Class proxyInterface)
                           throws ServiceException {
        return getPort(null, portName, proxyInterface);
    }
"	Return either an instance of a generated stub, if it can be found, or a dynamic proxy for the given proxy interface.	Not implemented yet	1	0	6	9	61
"public BaseSliderView getCurrentSlider(){ if(getRealAdapter() == null) throw new IllegalStateException(""You did not set a slider adapter""); int count = getRealAdapter().getCount(); int realCount = mViewPager.getCurrentItem() % count; return getRealAdapter().getSliderView(realCount); }"	"    public BaseSliderView getCurrentSlider(){

        if(getRealAdapter() == null)
            return null;

        int count = getRealAdapter().getCount();
        int realCount = mViewPager.getCurrentItem() % count;
        return  getRealAdapter().getSliderView(realCount);
    }
"	get current slider.	get current slider.	0	1	6	10	56
"private static File findBinary(String... binaryNames) { final String[] paths = System.getenv(""PATH"").split(File.pathSeparator); for (String binaryName : binaryNames) { for (String path : paths) { File file = new File(path, binaryName); if (file.exists()) { return file; } if (Platform.getCurrent().is(Platform.WINDOWS)) { File exe = new File(path, binaryName + "".exe""); if (exe.exists()) { return exe; } } } } return null; }"	"  private static File findBinary(String... binaryNames) {
    final String[] paths = System.getenv(""PATH"").split(File.pathSeparator);
    for (String binaryName : binaryNames) {
      for (String path : paths) {
        File file = new File(path, binaryName);
        if (file.exists()) {
          return file;
        }
      }
    }
    return null;
  }
"	Walk a PATH to locate binaries with a specified name.	UNIXy-only: walk a PATH to locate binaries with a specified name.	1	0	13	19	111
public long getInstantMillis(Object object, Chronology chrono) { Calendar calendar = (Calendar) object; long millisLocal = calendar.getTime().getTime() + calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET); DateTimeZone tz = DateTimeZone.forTimeZone(calendar.getTimeZone()); return millisLocal - tz.getOffsetFromLocal(millisLocal); }	"    public long getInstantMillis(Object object, Chronology chrono) {
        return ((Calendar) object).getTime().getTime();
    }
"	Gets the millis, which is the Calendar millis value.	Gets the millis, which is the Calendar millis value.	0	1	8	8	63
public float getX() { if(left == null) { calculateLeft(); } return left.floatValue(); }	"    public float getX() {
        return center[0];
    }
"	Get the x location of the left side of this shape.	Get the x location of the center of this circle	1	0	6	9	24
public static <T> Stream<T> from( T object ) { return new Stream<T>( new RepeatingObjectIterator<T>( object ), null ) ; }	"    @SuppressWarnings(""unchecked"")
    public static <T> Stream<T> from( T[] array ) {
        return new Stream<T>( primitiveArrayToList( array ).iterator(), null ) ;
    }
"	Construct a  Stream that for every element, returns  object.	Construct a Stream that iterates every Object in an array.	1	0	8	5	27
"public PhysicalPlan getPlan(SqlNode sqlNode) throws ValidationException, RelConversionException, IOException { SqlDropTable dropTableNode = ((SqlDropTable) sqlNode); SqlIdentifier tableIdentifier = dropTableNode.getTableIdentifier(); SchemaPlus defaultSchema = config.getConverter().getDefaultSchema(); AbstractSchema drillSchema = null; if (tableIdentifier != null) { drillSchema = SchemaUtilites.resolveToMutableDrillSchema(defaultSchema, dropTableNode.getSchema()); } String tableName = dropTableNode.getName(); if (drillSchema == null) { throw UserException.validationError() .message(""Invalid table_name [%s]"", tableName) .build(logger); } if (dropTableNode.checkTableExistence()) { final Table tableToDrop = SqlHandlerUtil.getTableFromSchema(drillSchema, tableName); if (tableToDrop == null || tableToDrop.getJdbcTableType() != Schema.TableType.TABLE) { return DirectPlan.createDirectPlan(context, true, String.format(""Table [%s] not found"", tableName)); } } drillSchema.dropTable(tableName); return DirectPlan.createDirectPlan(context, true, String.format(""Table [%s] %s"", tableName, ""dropped"")); }"	"  public PhysicalPlan getPlan(SqlNode sqlNode) throws ValidationException, RelConversionException, IOException {

    SqlDropTable dropTableNode = ((SqlDropTable) sqlNode);
    SqlIdentifier tableIdentifier = dropTableNode.getTableIdentifier();

    SchemaPlus defaultSchema = config.getConverter().getDefaultSchema();
    AbstractSchema drillSchema = null;

    if (tableIdentifier != null) {
      drillSchema = SchemaUtilites.resolveToMutableDrillSchema(defaultSchema, dropTableNode.getSchema());
    }

    String tableName = ((SqlDropTable) sqlNode).getName();
    if (drillSchema == null) {
      throw UserException.validationError()
          .message(""Invalid table_name [%s]"", tableName)
          .build(logger);
    }

    drillSchema.dropTable(tableName);

    return DirectPlan.createDirectPlan(context, true,
        String.format(""Table [%s] %s"", tableName, ""dropped""));
  }
"	Function resolves the schema and invokes the drop method (while IF EXISTS statement is used function invokes the drop method only if table exists).	Function resolves the schema and invokes the drop method.	1	0	10	33	199
public char get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }	"    public char get(WithAttributes attributes) {
        return attributes.getAttributes().get(this);
    }
"	Extracts the attribute map from the specified  WithAttributes and returns the value of this attribute from the map.	Analogous to #get(WithAttributes) except returning a primitive char.	1	0	6	5	19
"public static String launchProcess(final String command, final Map<String, String> environment, boolean backend) throws IOException { String[] cmds = command.split("" ""); ArrayList<String> cmdList = new ArrayList<String>(); for (String tok : cmds) { if (!StringUtils.isBlank(tok)) { cmdList.add(tok); } } return launchProcess(command, cmdList, environment, backend); }"	"    public static ByteArrayOutputStream launchProcess(String command, final Map environment, final String workDir, ExecuteResultHandler resultHandler)
            throws IOException {

        String[] cmdlist = command.split("" "");

        CommandLine cmd = new CommandLine(cmdlist[0]);
        for (String cmdItem : cmdlist) {
            if (StringUtils.isBlank(cmdItem) == false) {
                cmd.addArgument(cmdItem);
            }
        }

        DefaultExecutor executor = new DefaultExecutor();

        executor.setExitValue(0);
        if (StringUtils.isBlank(workDir) == false) {
            executor.setWorkingDirectory(new File(workDir));
        }

        ByteArrayOutputStream out = new ByteArrayOutputStream();

        PumpStreamHandler streamHandler = new PumpStreamHandler(out, out);
        if (streamHandler != null) {
            executor.setStreamHandler(streamHandler);
        }

        try {
            if (resultHandler == null) {
                executor.execute(cmd, environment);
            } else {
                executor.execute(cmd, environment, resultHandler);
            }
        } catch (ExecuteException e) {

            // @@@@
            // failed to run command
        }

        return out;

    }
"	Attention	If it is backend, please set resultHandler, such as DefaultExecuteResultHandler If it is frontend, ByteArrayOutputStream.toString get the result	1	0	9	13	81
private ServiceReference[] getInitialReferences(boolean trackAllServices, String className, String filterString) throws InvalidSyntaxException { if (trackAllServices) { return context.getAllServiceReferences(className, filterString); } return context.getServiceReferences(className, filterString); }	"	private ServiceReference[] getInitialReferences(boolean trackAllServices,
			String trackClass, String filterString)
			throws InvalidSyntaxException {
		if (trackAllServices) {
			return context.getAllServiceReferences(trackClass, filterString);
		}
		else {
			return context.getServiceReferences(trackClass, filterString);
		}
	}
"	Returns the list of initial ServiceReferences that will be tracked by this ServiceTracker.	Returns the list of initial ServiceReference objects that will be tracked by this ServiceTracker object.	1	0	7	10	43
public int toStatusCode(Throwable thrown) { if (thrown == null) { return SUCCESS; } else if (thrown instanceof InvalidCookieDomainException) { return INVALID_COOKIE_DOMAIN; } else if (thrown instanceof UnableToSetCookieException) { return UNABLE_TO_SET_COOKIE; } else if (thrown instanceof NoSuchWindowException) { return NO_SUCH_WINDOW; } else if (thrown instanceof InvalidSelectorException) { return INVALID_SELECTOR_ERROR; } else if (thrown instanceof NoSuchElementException) { return NO_SUCH_ELEMENT; } else if (thrown instanceof NoSuchFrameException) { return NO_SUCH_FRAME; } else if (thrown instanceof StaleElementReferenceException) { return STALE_ELEMENT_REFERENCE; } else if (thrown instanceof ElementNotVisibleException) { return ELEMENT_NOT_VISIBLE; } else if (thrown instanceof InvalidElementStateException) { return INVALID_ELEMENT_STATE; } else if (thrown instanceof XPathLookupException) { return XPATH_LOOKUP_ERROR; } else if (thrown instanceof TimeoutException) { return ASYNC_SCRIPT_TIMEOUT; } else if (thrown instanceof InvalidCoordinatesException) { return INVALID_ELEMENT_COORDINATES; } else if (thrown instanceof ImeNotAvailableException) { return IME_NOT_AVAILABLE; } else if (thrown instanceof ImeActivationFailedException) { return IME_ENGINE_ACTIVATION_FAILED; } else if (thrown instanceof NoAlertPresentException) { return NO_ALERT_PRESENT; } else if (thrown instanceof MoveTargetOutOfBoundsException) { return MOVE_TARGET_OUT_OF_BOUNDS; } else { return UNHANDLED_ERROR; } }	"  public int toStatusCode(Throwable thrown) {
    if (thrown == null) {
      return SUCCESS;
    } else if (thrown instanceof InvalidCookieDomainException) {
      return INVALID_COOKIE_DOMAIN;
    } else if (thrown instanceof UnableToSetCookieException) {
      return UNABLE_TO_SET_COOKIE;
    } else if (thrown instanceof NoSuchWindowException) {
      return NO_SUCH_WINDOW;
    } else if (thrown instanceof InvalidSelectorException) {
      return INVALID_SELECTOR_ERROR;
    } else if (thrown instanceof NoSuchElementException) {
      return NO_SUCH_ELEMENT;
    } else if (thrown instanceof NoSuchFrameException) {
      return NO_SUCH_FRAME;
    } else if (thrown instanceof StaleElementReferenceException) {
      return STALE_ELEMENT_REFERENCE;
    } else if (thrown instanceof ElementNotVisibleException) {
      return ELEMENT_NOT_VISIBLE;
    } else if (thrown instanceof InvalidElementStateException) {
      return INVALID_ELEMENT_STATE;
    } else if (thrown instanceof XPathLookupException) {
      return XPATH_LOOKUP_ERROR;
    } else if (thrown instanceof TimeoutException) {
      return ASYNC_SCRIPT_TIMEOUT;
    } else if (thrown instanceof InvalidCoordinatesException) {
      return INVALID_ELEMENT_COORDINATES;
    } else if (thrown instanceof ImeNotAvailableException) {
      return IME_NOT_AVAILABLE;
    } else if (thrown instanceof ImeActivationFailedException) {
      return IME_ENGINE_ACTIVATION_FAILED;
    } else if (thrown instanceof NoAlertPresentException) {
      return NO_ALERT_PRESENT;
    } else {
      return UNHANDLED_ERROR;
    }
  }
"	Converts a thrown error into the corresponding status code.	Converts a thrown error into the corresponding status code.	0	1	22	40	217
public EReference getComment_Replies() { return (EReference) commentEClass.getEStructuralFeatures().get(3); }	"	public EReference getComment_Replies() {
		return (EReference) commentEClass.getEStructuralFeatures().get(4);
	}
"	Returns the meta object for the reference list ' org.eclipse.mylyn.reviews.core.model.IComment#getReplies Replies'.	Returns the meta object for the containment reference list ' org.eclipse.mylyn.reviews.core.model.IComment#getReplies Replies'.	1	0	7	5	20
public Tuplizer getTuplizerOrNull(EntityMode entityMode) { return tuplizers.get( entityMode ); }	"	public Tuplizer getTuplizerOrNull(EntityMode entityMode) {
		return ( Tuplizer ) tuplizers.get( entityMode );
	}
"	Locate the contained tuplizer responsible for the given entity-mode.	Locate the contained tuplizer responsible for the given entity-mode.	0	1	5	4	16
"private String generateMessage(boolean includeErrorIdAndIdentity) { return errorType + "" ERROR: "" + super.getMessage() + ""\n\n"" + context.generateContextMessage(includeErrorIdAndIdentity); }"	"  private String generateMessage() {
    return errorType + "" ERROR: "" + super.getMessage() + ""\n\n"" +
      context.generateContextMessage();
  }
"	Generates a user error message that has the following structure:	Generates a user error message that has the following structure:	0	1	8	5	35
public Set<Warning> getWarnings() { return Collections.unmodifiableSet(project.getWarnings(packageName)); }	"    public Collection<Warning> getWarnings() {
        return project.getWarnings(packageName);
    }
"	Returns all warnings for this package details view.	Returns all the warnings in this package.	1	0	6	5	19
"@SuppressWarnings(""unchecked"") protected Class[] getClassContext() { return VMStack.getClasses(-1, false); }"	"    @SuppressWarnings(""unchecked"")
    protected Class[] getClassContext() {
        return Class.getStackClasses(-1, false);
    }
"	Returns an array containing one entry for each method in the current execution stack.	Returns an array containing one entry for each method in the stack.	1	0	5	6	26
"public boolean isTextPresent(String pattern) { return (Boolean) seleneseMethods.get(""isTextPresent"").apply(driver, pattern); }"	"  public boolean isTextPresent(String pattern) {
    String text = driver.findElement(By.xpath(""/html/body"")).getText();
    text = text.trim();

    String strategyName = ""implicit"";
    String use = pattern;
    Matcher matcher = TEXT_MATCHING_STRATEGY_AND_VALUE_PATTERN.matcher(pattern);
    if (matcher.matches()) {
      strategyName = matcher.group(1);
      use = matcher.group(2);
    }
    TextMatchingStrategy strategy = textMatchingStrategies.get(strategyName);

    return strategy.isAMatch(use, text);
  }
"	Verifies that the specified text pattern appears somewhere on the rendered page shown to the user.	Verifies that the specified text pattern appears somewhere on the rendered page shown to the user.	0	1	7	4	27
"public WebElement augment(RemoteWebElement element) { // TODO(simon): We should really add a ""SelfDescribing"" interface for this RemoteWebDriver parent = (RemoteWebDriver) element.getWrappedDriver(); if (parent == null) { return element; } Map<String, AugmenterProvider> augmentors = elementAugmentors; CompoundHandler handler = determineAugmentation(parent, augmentors); RemoteWebElement remote = create(handler, element); remote.setId(element.getId()); remote.setParent(parent); return remote; }"	"  public WebDriver augment(WebDriver driver) {
    // TODO(simon): We should really add a ""SelfDescribing"" interface for this
    if (!(driver instanceof RemoteWebDriver)) {
      return driver;
    }

    Map<String, ?> capabilities = ((RemoteWebDriver) driver).getCapabilities().asMap();

    CompoundHandler handler = new CompoundHandler((RemoteWebDriver) driver);

    for (Map.Entry<String, ?> capablityName : capabilities.entrySet()) {
      AugmenterProvider augmenter = augmentors.get(capablityName.getKey());
      if (augmenter == null) {
        continue;
      }

      Object value = capablityName.getValue();
      if (value instanceof Boolean && !((Boolean) value).booleanValue()) {
        continue;
      }

      handler.addCapabilityHander(augmenter.getDescribedInterface(),
          augmenter.getImplementation(value));
    }

    if (handler.isNeedingApplication()) {
      // Gather the existing interfaces
      Set<Class<?>> interfaces = new HashSet<Class<?>>();
      interfaces.addAll(handler.getInterfaces());
      interfaces.addAll(getInterfacesFrom(driver.getClass()));

      Enhancer enhancer = new Enhancer();
      enhancer.setInterfaces(interfaces.toArray(new Class<?>[interfaces.size()]));
      enhancer.setCallback(handler);
      enhancer.setSuperclass(driver.getClass());

      RemoteWebDriver remote = (RemoteWebDriver) enhancer.create();
      remote.setCommandExecutor(((RemoteWebDriver) driver).getCommandExecutor());
      remote.setElementConverter(((RemoteWebDriver) driver).getElementConverter());
      return remote;
    }

    return driver;
  }
"	Enhance the interfaces implemented by this instance of WebElement iff that instance is a  org.openqa.selenium.remote.RemoteWebElement.	Enhance the interfaces implemented by this instance of WebDriver iff that instance is a org.openqa.selenium.remote.RemoteWebDriver.	1	0	6	17	90
public Object getParams(PGraphics renderer) { if (paramMap == null) return null; return paramMap.get(renderer); }	"  public PParameters getParams(PGraphics renderer) {
    if (paramMap == null) return null;
    return paramMap.get(renderer);
  }
"	Get the parameters for the specified renderer.	Get the parameters for the specified renderer.	0	1	5	5	24
public static String encrypt(String plain) { return getMD5(plain); /* org.w3c.tools.crypt.Md5 md5 = new org.w3c.tools.crypt.Md5(plain); byte[] b = md5.processString(); return md5.getStringDigest(); */ }	"    public static String encrypt(String plain) {
        Md5 md5 = new Md5(plain);
        byte[] b = md5.processString();

        return md5.getStringDigest();
    }
"	Encrypt plain text password	DOCUMENT ME!	1	0	5	11	51
public ArrayList<ErrorMsg> getWarnings() { return _parser.getWarnings(); }	"    public Vector getWarnings() {
        return _parser.getWarnings();
    }
"	Get a list of all compile warning messages	Get a Vector containing all compile warning messages	1	0	5	5	14
"public RelOptTableImpl getTable(final List<String> names) { RelOptTableImpl temporaryTable = null; if (mightBeTemporaryTable(names, session.getDefaultSchemaPath(), drillConfig)) { String temporaryTableName = session.resolveTemporaryTableName(names.get(names.size() - 1)); if (temporaryTableName != null) { List<String> temporaryNames = Lists.newArrayList(temporarySchema, temporaryTableName); temporaryTable = super.getTable(temporaryNames); } } if (temporaryTable != null) { if (allowTemporaryTables) { return temporaryTable; } throw UserException .validationError() .message(""Temporary tables usage is disallowed. Used temporary table name: %s."", names) .build(logger); } RelOptTableImpl table = super.getTable(names); // Check the schema and throw a valid SchemaNotFound exception instead of TableNotFound exception. if (table == null) { isValidSchema(names); } return table; }"	"    public RelOptTableImpl getTable(final List<String> names) {
      RelOptTableImpl temporaryTable = null;

      if (mightBeTemporaryTable(names, session.getDefaultSchemaPath(), drillConfig)) {
        String temporaryTableName = session.resolveTemporaryTableName(names.get(names.size() - 1));
        if (temporaryTableName != null) {
          List<String> temporaryNames = Lists.newArrayList(temporarySchema, temporaryTableName);
          temporaryTable = super.getTable(temporaryNames);
        }
      }
      if (temporaryTable != null) {
        if (allowTemporaryTables) {
          return temporaryTable;
        }
        throw UserException
            .validationError()
            .message(""Temporary tables usage is disallowed. Used temporary table name: %s."", names)
            .build(logger);
      }
      return super.getTable(names);
    }
"	If schema is not indicated (only one element in the list) or schema is default temporary workspace, we need to check among session temporary tables in default temporary workspace first.	If schema is not indicated (only one element in the list) or schema is default temporary workspace, we need to check among session temporary tables in default temporary workspace first.	0	1	10	30	158
public Reader getReader() throws IOException { if (this.pipeIn == null) { this.pipeIn = new PipedReader(); this.pipeOut = new PipedWriter(this.pipeIn); Thread thread = new ParserThread(this); thread.start(); // start parsing } return this.pipeIn; }	"    public Reader getReader() throws IOException {
        if (pipeIn == null) {
            pipeIn = new PipedReader();
            pipeOut = new PipedWriter(pipeIn);

            Thread thread = new ParserThread(this);
            thread.start(); // start parsing
        }

        return pipeIn;
    }
"	Get a reader	DOCUMENT ME!	1	0	9	13	54
"public List<LogicalInputSplit> getInputSplits(final HiveReadEntry hiveReadEntry) { final Stopwatch timeGetSplits = Stopwatch.createStarted(); try { if (!isPartitionedTable) { return getTableInputSplits(); } final List<LogicalInputSplit> splits = Lists.newArrayList(); for (HivePartition p : hiveReadEntry.getPartitions()) { splits.addAll(getPartitionInputSplits(p)); } return splits; } catch (final Exception e) { logger.error(""Failed to get InputSplits"", e); throw new DrillRuntimeException(""Failed to get InputSplits"", e); } finally { logger.debug(""Took {} s to get InputSplits from {}.{}"", timeGetSplits.elapsed(TimeUnit.NANOSECONDS) / 1000, hiveReadEntry.getTable().getDbName(), hiveReadEntry.getTable().getTableName()); } }"	"  public List<InputSplitWrapper> getInputSplits(final HiveReadEntry hiveReadEntry) {
    final Stopwatch timeGetSplits = Stopwatch.createStarted();
    try {
      if (!isPartitionedTable) {
        return getTableInputSplits();
      }

      final List<InputSplitWrapper> splits = Lists.newArrayList();
      for (HivePartition p : hiveReadEntry.getPartitions()) {
        splits.addAll(getPartitionInputSplits(p));
      }
      return splits;
    } catch (final Exception e) {
      logger.error(""Failed to get InputSplits"", e);
      throw new DrillRuntimeException(""Failed to get InputSplits"", e);
    } finally {
      logger.debug(""Took {} s to get InputSplits from {}.{}"", timeGetSplits.elapsed(TimeUnit.NANOSECONDS) / 1000,
          hiveReadEntry.getTable().getDbName(), hiveReadEntry.getTable().getTableName());
    }
  }
"	Return  LogicalInputSplits for given  HiveReadEntry.	Return InputSplitWrappers for given HiveReadEntry.	1	0	9	21	149
"public String preprocess(String buildPath) throws RunnerException { try { return preprocess(buildPath, new PdePreprocessor(buildPath, name)); } catch (IOException e) { throw new RunnerException(""Error while preprocessing"", true); } }"	"  public String preprocess(String buildPath) throws RunnerException {
    return preprocess(buildPath, new PdePreprocessor());
  }
"	Build all the code for this sketch.	Build all the code for this sketch.	0	1	7	8	48
public boolean scrollUp(){ waiter.waitForViews(ListView.class, ScrollView.class, false); return scroller.scroll(Scroller.UP); }	"	public boolean scrollUp(){
		waiter.waitForViews(ListView.class, ScrollView.class);
		return scroller.scroll(Scroller.Direction.UP);
	}
"	Scrolls up the screen.	Scrolls up the screen.	0	1	6	5	27
"private File[] getDirectoryHistory() { File[] dirhist = Settings.instance().getDirectoryHistory(); if (dirhist == null || dirhist.length == 0) return new File[] { new File(""."").getAbsoluteFile() }; else return dirhist; }"	"    private String[] getDirectoryHistory() {
        return new String[] { directory.getAbsolutePath(), ""resources"", ""mursukas"", ""heppa"", ""marsupapana"" };

        // TODO:
        //return Settings.instance().getDirectoryHistory();
    }
"	Reads current directory history from Settings.	Gets current directory history from TODO.	1	0	8	8	52
public ArrayList<View> getViews() { try { return viewFetcher.getViews(null, false); } catch (Exception e) { e.printStackTrace(); return null; } }	"	
	public ArrayList<View> getViews() {
		try {
			return viewFetcher.getViews(null);
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
	}
"	Returns an  ArrayList of all the  View objects located in the focused window e.g.	Returns an ArrayList of the View objects located in the current Activity.	1	0	6	11	35
public static Log named(String name) { // a thread-safe SLF4J initialization routine is apparently hard, so I get to do dumb // shit like this while (true) { final org.slf4j.Logger logger = LoggerFactory.getLogger(name); if (logger instanceof Logger) { return forSlf4jLogger(logger); } } }	"    public static Log named(String name) {
        return forSlf4jLogger(LoggerFactory.getLogger(name));
    }
"	Returns a  Log instance with the given name.	Returns a Log instance with the given name.	0	1	9	11	65
"public static MatchFinder anyOf(final MatchFinder... finders) { return new MatchFinder() { @Override public boolean matches(UiElement element) { for (MatchFinder finder : finders) { if (finder.matches(element)) { return true; } } return false; } @Override public String toString() { return ""anyOf("" + Joiner.on("","").join(finders) + "")""; } }; }"	"  public static ElementMatcher anyOf(final ElementMatcher... matchers) {
    return new ElementMatcher() {
      @Override
      public boolean matches(UiElement element) {
        for (ElementMatcher matcher : matchers) {
          if (matcher.matches(element)) {
            return true;
          }
        }
        return false;
      }

      @Override
      public String toString() {
        return ""anyOf("" + Joiner.on("","").join(matchers) + "")"";
      }
    };
  }
"	Evaluates given @finders in short-circuit fashion in the order they are passed.	Evaluates given @matchers in short-circuit fashion in the order they are passed.	1	0	11	20	86
private List<CardViewWrapper> getVisibleViewsForCards(List<Card> cardsCopy) { List<CardViewWrapper> originalViews = new ArrayList<CardViewWrapper>(); for (Card card:cardsCopy){ originalViews.add(card.getCardView()); } /*List<CardView> views = new ArrayList<CardView>(); for (int i = 0; i < mCardListView.getChildCount(); i++) { View child = mCardListView.getChildAt(i); if (cardsCopy.contains(views)){ views.add((CardView) child); } }*/ return originalViews; }	"    private List<CommonCardView> getVisibleViewsForCards(List<Card> cardsCopy) {
        List<CommonCardView> originalViews = new ArrayList<CommonCardView>();
        for (Card card:cardsCopy){
            originalViews.add(card.getCardView());
        }

        /*List<CardView> views = new ArrayList<CardView>();
        for (int i = 0; i < mCardListView.getChildCount(); i++) {
            View child = mCardListView.getChildAt(i);
            if (cardsCopy.contains(views)){
                views.add((CardView) child);
            }
        }*/
        return originalViews;
    }
"	Returns the visible view for the cards	Returns the visible view for the cards	0	1	8	16	99
public boolean shouldBuffer() { Window window = runningQuery.getQuery().getWindow(); boolean noWindow = window == null; // If it's a RAW query without a window, it should be buffered if and only if it timed out. This means that the // query is not yet done. So this tells the driver to buffer the query to wait for more potential results. if (noWindow && isRaw()) { return runningQuery.isTimedOut(); } // No window (and not raw) is a duration based query => do buffer. Otherwise, buffer if the window is time based. return noWindow || window.isTimeBased(); }	"    public boolean shouldBuffer() {
        Window window = runningQuery.getQuery().getWindow();
        // No window means duration drives the query -> time based. Otherwise, if the window is time based.
        return window == null || window.isTimeBased();
    }
"	Returns if this query should buffer before emitting results.	Returns if this query should be buffered for a bit before getting results out.	1	0	6	13	123
public BootstrapServiceRegistry build() { final ClassLoaderServiceImpl classLoaderService = new ClassLoaderServiceImpl( applicationClassLoader, resourcesClassLoader, hibernateClassLoader, environmentClassLoader ); final IntegratorServiceImpl integratorService = new IntegratorServiceImpl( providedIntegrators, classLoaderService ); return new BootstrapServiceRegistryImpl( classLoaderService, integratorService ); }	"	public ServiceRegistry build() {
		final ClassLoaderServiceImpl classLoaderService = new ClassLoaderServiceImpl(
				applicationClassLoader,
				resourcesClassLoader,
				hibernateClassLoader,
				environmentClassLoader
		);

		final IntegratorServiceImpl integratorService = new IntegratorServiceImpl(
				providedIntegrators,
				classLoaderService
		);

		return new BootstrapServiceRegistryImpl( classLoaderService, integratorService );
	}
"	Build the bootstrap registry.	Build the bootstrap registry.	0	1	6	16	42
public static ModuleConfig getModuleConfig(PageContext pageContext) { ModuleConfig moduleConfig = (ModuleConfig) pageContext.getRequest().getAttribute(Globals.MODULE_KEY); if (moduleConfig == null) { // Backwards compatibility hack moduleConfig = (ModuleConfig) pageContext.getServletContext().getAttribute(Globals.MODULE_KEY); } return moduleConfig; }	"    public static ApplicationConfig getModuleConfig(PageContext pageContext) {
       ApplicationConfig appConfig = (ApplicationConfig)
           pageContext.getRequest().getAttribute(Globals.MODULE_KEY);
       if (appConfig == null) { // Backwards compatibility hack
           appConfig = (ApplicationConfig)
               pageContext.getServletContext().getAttribute(Globals.MODULE_KEY);
       }
       return appConfig;
    }
"	Return the ModuleConfig object is it exists, null otherwise.	Return the ApplicationConfig object is it exists, null otherwise.	1	0	10	11	54
public static boolean isSameType(MajorType type1, MajorType type2) { return isSameTypeAndMode(type1, type2) && type1.getScale() == type2.getScale() && type1.getPrecision() == type2.getPrecision(); }	"  public static boolean isSameType(MajorType type1, MajorType type2) {
    return type1.getMinorType() == type2.getMinorType() &&
           type1.getMode() == type2.getMode() &&
           type1.getScale() == type2.getScale() &&
           type1.getPrecision() == type2.getPrecision();
  }
"	"Check if two ""core"" types are the same, ignoring subtypes and children."	"Check if two ""core"" types are the same, ignoring subtypes and children."	0	1	7	6	41
public byte toOrdinal() { return this.opCode; }	"    public int toOrdinal() {
	      return this.opCode;
	    }
"	Returns the byte representing this operation code.	Returns the int representing this operation code.	1	0	5	5	11
private Timestamp[] getTimeframe() { Timestamp oldest = Timestamp.ZERO.plus(1000000); Timestamp newest = Timestamp.ZERO; for (Habit h : selectedHabits) { if(h.getRepetitions().getOldest() == null || h.getRepetitions().getNewest() == null) continue; Timestamp currOld = h.getRepetitions().getOldest().getTimestamp(); Timestamp currNew = h.getRepetitions().getNewest().getTimestamp(); oldest = currOld.isOlderThan(oldest) ? oldest : currOld; newest = currNew.isNewerThan(newest) ? newest : currNew; } return new Timestamp[]{oldest, newest}; }	"    private long[] getTimeframe()
    {
        long oldest = Long.MAX_VALUE;
        long newest = -1;
        for (Habit h : selectedHabits)
        {
            if(h.getRepetitions().getOldest() == null || h.getRepetitions().getNewest() == null)
                continue;
            long currOld = h.getRepetitions().getOldest().getTimestamp();
            long currNew = h.getRepetitions().getNewest().getTimestamp();
            oldest = currOld > oldest ? oldest : currOld;
            newest = currNew < newest ? newest : currNew;
        }
        return new long[]{oldest, newest};
    }
"	Gets the overall timeframe of the selected habits.	Gets the overall timeframe of the selected habits.	0	1	9	16	114
static int calcLevels(double start, int end, double multiple) { return (int) Math.ceil(calcMultipliedLevels(start, end, multiple)); }	"	static int calcLevels(double start, int end, double multiple)
	{
		return (int) Math.ceil((end - start) / multiple);
	}
"	Calculate skill levels required for increasing combat level, meant for all combat skills besides prayer, ranged, and magic.	Calculate skill levels required for increasing combat level, meant for all combat skills besides ranged and magic.	1	0	7	5	32
public DurationField millis() { return UnsupportedDurationField.getInstance(DurationFieldType.millis()); }	"    public DurationField millis() {
        return UnsupportedDurationField.getInstance(""millis"");
    }
"	Get the millis duration field for this chronology.	Get the millis duration field for this chronology.	0	1	5	4	17
public boolean waitForText(String text, int matches, long timeout, boolean scroll) { long now = System.currentTimeMillis(); final long endTime = now + timeout; while (!searcher.searchFor(TextView.class, text, matches, scroll) && !searcher.searchForEditText(text, scroll) && now < endTime) { now = System.currentTimeMillis(); } final boolean timedOut = now > endTime; return !timedOut; }	"	public boolean waitForText(String text, int matches, long timeout, boolean scroll)
    {
		long now = System.currentTimeMillis();
        final long endTime = now + timeout;

		while (!searcher.searchFor(TextView.class, text, matches, scroll) && !searcher.searchForEditText(text, scroll) && now < endTime) {
        	now = System.currentTimeMillis();	
        }    
        if (now > endTime)
        	return false;
        
       return true;
    }
"	Waits for a text to be shown.	Waits for a text to be shown.	0	1	8	14	80
public double getMatchRatio(String strA, String strB) { if (strA == null && strB == null) { return MAX_RATIO; } else if (strA == null || strB == null) { return MIN_RATIO; } if (strA.isEmpty() && strB.isEmpty()) { return MAX_RATIO; } else if (strA.isEmpty() || strB.isEmpty()) { return MIN_RATIO; } //get the percentage match against the longer of the 2 strings return (double)getLCS(strA, strB).length() / Math.max(strA.length(), strB.length()); }	"    public double getMatchRatio(String strA, String strB) {
        if (strA == null && strB == null) {
            return MAX_RATIO;
            
        } else if (strA == null || strB == null) {
            return MIN_RATIO;
        }
        
        if (strA.isEmpty() && strB.isEmpty()) {
            return MAX_RATIO;
            
        } else if (strA.isEmpty() || strB.isEmpty()) {
            return MIN_RATIO;
        }
                
        //get the percentage match against the longer of the 2 strings
        return (double)getLCS(strA, strB).length() / max(strA.length(), strB.length());
    }    
"	Calculate the ratio of similarity between 2 strings using LCS	Calculate the ratio of similarity between 2 strings using LCS	0	1	7	19	119
public LockableMGraph getUnsecuredMGraph() { try { checkWrite(); return wrapped; } catch (AccessControlException ex) { checkRead(); return new WriteBlockedMGraph(wrapped); } }	"	public LockableMGraph getUnsecuredMGraph() {
		checkWrite();
		return wrapped;
	}
"	Returns the wrapped LockableMGraph if the caller has all access rights.	Returns the wrapped LockableMGraph if the caller has all access rights, otherwise an AccessControlException is thrown.	1	0	7	12	35
public boolean isVisible(String locator) { return ((RenderedWebElement) elementFinder.findElement(driver, locator)).isDisplayed(); }	"  public boolean isVisible(String locator) {
    return ((RenderedWebElement) findElement(locator)).isDisplayed();
  }
"	Determines if the specified element is visible.	Determines if the specified element is visible.	0	1	6	4	26
"public static YourKitContext startProfile(boolean enableStackTelemetry, boolean enableCPUProfilling, boolean enableAllocationRecording) { Controller controller; try { controller = new Controller(); // CHECKSTYLE: stop IllegalCatch } catch (Exception e) { // CHECKSTYLE: resume IllegalCatch LOG.info(""Failed to set up YourKit controller"", e); return null; } try { if (enableStackTelemetry) { controller.enableStackTelemetry(); LOG.info(""Enabled Yourkit stack telemetry""); } // CHECKSTYLE: stop IllegalCatch } catch (Exception e) { // CHECKSTYLE: resume IllegalCatch LOG.info(""Failed to enable YourKit stack telemetry"", e); } try { if (enableCPUProfilling) { controller.startCPUProfiling(ProfilingModes.CPU_SAMPLING, Controller.DEFAULT_FILTERS, Controller.DEFAULT_WALLTIME_SPEC); LOG.info(""Started YourKit CPU profiling""); } // CHECKSTYLE: stop IllegalCatch } catch (Exception e) { // CHECKSTYLE: resume IllegalCatch LOG.info(""Failed to start YourKit CPU profiling"", e); } try { if (enableAllocationRecording) { controller.startAllocationRecording(true, ALLOCATION_RECORDING_INTERVAL, false, -1, true, false); LOG.info(""Started YourKit allocation recording""); } // CHECKSTYLE: stop IllegalCatch } catch (Exception e) { // CHECKSTYLE: resume IllegalCatch LOG.info(""Failed to start YourKit allocation recording"", e); } return new YourKitContext(controller); }"	"  public static YourKitContext startProfile(GiraphConfiguration conf) {
    Controller controller = null;
    try {
      controller = new Controller();
      controller.enableStackTelemetry();
      controller.startCPUProfiling(ProfilingModes.CPU_SAMPLING,
          Controller.DEFAULT_FILTERS);
      LOG.debug(""Started YourKit profiling CPU"");
      // CHECKSTYLE: stop IllegalCatch
    } catch (Exception e) {
      // CHECKSTYLE: resume IllegalCatch
      LOG.debug(""Failed to start YourKit CPU profiling"", e);
    }
    return new YourKitContext(controller);
  }
"	Create a YourKit controller and do some or all of  Controller#enableExceptionTelemetry()  Controller#startCPUProfiling(long, String, String)  Controller#startAllocationRecording(boolean, int, boolean, int, boolean, boolean) based on boolean config options passed as method parameters	Convenient replacement of #startProfilingCPU(long) with ProfilingModes#CPU_TRACING for the mode.	1	0	8	52	269
public static Schema getOutputKeySchema(Configuration conf) { String schemaString = conf.get(CONF_OUTPUT_KEY_SCHEMA); return schemaString != null ? new Schema.Parser().parse(schemaString) : null; }	"  public static Schema getOutputKeySchema(Configuration conf) {
    String schemaString = conf.get(CONF_OUTPUT_KEY_SCHEMA);
    return schemaString != null ? Schema.parse(schemaString) : null;
  }
"	Gets the job output key schema.	Gets the job output key schema.	0	1	7	5	35
public ChuckInterceptor maxContentLength(long max) { this.maxContentLength = max; return this; }	"    public ChuckInterceptor maxContentLength(long max) {
        this.maxContentLength = max;
    }
"	Control the max length for request and response content that will be retained.	Control the max length for request and response content that will be retained.	0	1	6	5	16
"public static Treepath getPreviousSibling( Treepath treepath ) throws IllegalArgumentException { if( treepath.getHeight() < 2 ) { throw new IllegalArgumentException( ""Treepath must have minimum height of 2"" ) ; } final Tree treeToMove = treepath.getBottom() ; final Tree parent = treepath.getTreeAtHeight( 1 ) ; for( int i = parent.getChildCount() - 1 ; i > 0 ; i-- ) { final Tree child = parent.getChildAt( i ) ; if( child == treeToMove ) { return Treepath.create( treepath.getParent(), parent.getChildAt( i - 1 ) ) ; } } throw new IllegalArgumentException( ""No previous sibling"" ) ; }"	"  public static Treepath getPreviousSibling( Treepath treepath ) {
    if( treepath.getHeight() < 2 ) {
      throw new IllegalArgumentException( ""Treepath must have minimum height of 2"" ) ;
    }
    final Tree treeToMove = treepath.getBottom() ;
    final Tree parent = treepath.getTreeAtHeight( 1 ) ;
    for( int i = parent.getChildCount() - 1 ; i > 0 ; i-- ) {
      final Tree child = parent.getChildAt( i ) ;
      if( child == treeToMove ) {
        return Treepath.create( treepath.getParent(), parent.getChildAt( i - 1 ) ) ;
      }
    }
    return null ;
  }
"	Returns the sibling on the left of the bottom of given  Treepath.	Returns the sibling on the left of the end of given Treepath.	1	0	11	16	119
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 38: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, yytext()); } case 55: break; case 43: // general lookahead, find correct zzMarkedPos { int zzFState = 9; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 10; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { // try to work around an apparent jflex bug where it // gets a space at the token end by getting // wrong the length of the trailing context. while (yylength() > 0) { char last = yycharat(yylength()-1); if (last == ' ' || last == '\t' || (last >= '\n' && last <= '\r' || last == '\u0085')) { yypushback(1); } else { break; } } return getNext(); } case 56: break; case 11: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 57: break; case 19: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 58: break; case 8: { return handleQuotes(yytext(), false); } case 59: break; case 35: // lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), false); } case 60: break; case 27: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 61: break; case 33: // lookahead expression with fixed lookahead length yypushback(1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 62: break; case 49: // lookahead expression with fixed lookahead length yypushback(1); { return getNormalizedAmpNext(); } case 63: break; case 36: { return getNormalizedAmpNext(); } case 64: break; case 23: { if (invertible) { prevWordAfter.append(yytext()); } } case 65: break; case 37: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, yytext()); } case 66: break; case 53: // lookahead expression with fixed lookahead length yypushback(4); { return getNext(); } case 67: break; case 46: // lookahead expression with fixed lookahead length yypushback(2); { return getNext(); } case 68: break; case 42: // general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 69: break; case 41: // general lookahead, find correct zzMarkedPos { int zzFState = 16; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 17; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 70: break; case 40: // general lookahead, find correct zzMarkedPos { int zzFState = 13; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 71: break; case 3: { return getNext(); } case 72: break; case 24: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(); } case 73: break; case 51: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } return getNext(txt, yytext()); } case 74: break; case 26: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, origTxt); } case 75: break; case 6: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 76: break; case 29: // general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 77: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 78: break; case 2: { return getNext(""<"", yytext()); } case 79: break; case 30: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 80: break; case 18: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 81: break; case 54: { String txt = yytext(); if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 82: break; case 50: { yypushback(3) ; return getNext(); } case 83: break; case 25: // lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), true); } case 84: break; case 39: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 85: break; case 21: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 86: break; case 17: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 87: break; case 13: { return handleEllipsis(yytext()); } case 88: break; case 34: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 1; { /* invert quote - often but not always right */ return handleQuotes(yytext(), true); } case 89: break; case 14: { return normalizeFractions(yytext()); } case 90: break; case 15: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(); } } case 91: break; case 47: // general lookahead, find correct zzMarkedPos { int zzFState = 11; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 12; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 92: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 93: break; case 9: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 94: break; case 45: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 95: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 96: break; case 28: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 97: break; case 48: { if (keepAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 98: break; case 20: { if (normalizeOtherBrackets) { return getNext(""-RSB-"", yytext()); } else { return getNext(); } } case 99: break; case 12: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 100: break; case 31: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 101: break; case 10: { return getNext("">"", yytext()); } case 102: break; case 32: { // this one should only match if we're basically at the end of file // since the last one matches two things, even newlines String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 103: break; case 22: { if (normalizeOtherBrackets) { return getNext(""-LSB-"", yytext()); } else { return getNext(); } } case 104: break; case 52: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { // try to work around an apparent jflex bug where it // gets a space at the token end by getting // wrong the length of the trailing context. while (yylength() > 0) { char last = yycharat(yylength()-1); if (last == ' ' || last == '\t' || (last >= '\n' && last <= '\r' || last == '\u0085')) { yypushback(1); } else { break; } } String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 105: break; case 1: { String str = yytext(); int first = str.charAt(0); String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } LOGGER.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: LOGGER.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 106: break; case 44: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 107: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 108: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }"	"  public Object next() throws java.io.IOException {
    int zzInput;
    int zzAction;

    // cached fields:
    int zzCurrentPosL;
    int zzMarkedPosL;
    int zzEndReadL = zzEndRead;
    char [] zzBufferL = zzBuffer;
    char [] zzCMapL = ZZ_CMAP;

    int [] zzTransL = ZZ_TRANS;
    int [] zzRowMapL = ZZ_ROWMAP;
    int [] zzAttrL = ZZ_ATTRIBUTE;

    while (true) {
      zzMarkedPosL = zzMarkedPos;

      yychar+= zzMarkedPosL-zzStartRead;

      zzAction = -1;

      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
  
      zzState = ZZ_LEXSTATE[zzLexicalState];


      zzForAction: {
        while (true) {
    
          if (zzCurrentPosL < zzEndReadL)
            zzInput = zzBufferL[zzCurrentPosL++];
          else if (zzAtEOF) {
            zzInput = YYEOF;
            break zzForAction;
          }
          else {
            // store back cached positions
            zzCurrentPos  = zzCurrentPosL;
            zzMarkedPos   = zzMarkedPosL;
            boolean eof = zzRefill();
            // get translated positions and possibly new buffer
            zzCurrentPosL  = zzCurrentPos;
            zzMarkedPosL   = zzMarkedPos;
            zzBufferL      = zzBuffer;
            zzEndReadL     = zzEndRead;
            if (eof) {
              zzInput = YYEOF;
              break zzForAction;
            }
            else {
              zzInput = zzBufferL[zzCurrentPosL++];
            }
          }
          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
          if (zzNext == -1) break zzForAction;
          zzState = zzNext;

          int zzAttributes = zzAttrL[zzState];
          if ( (zzAttributes & 1) == 1 ) {
            zzAction = zzState;
            zzMarkedPosL = zzCurrentPosL;
            if ( (zzAttributes & 8) == 8 ) break zzForAction;
          }

        }
      }

      // store back cached position
      zzMarkedPos = zzMarkedPosL;

      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
        case 38: 
          { String txt = yytext();
                  if (escapeForwardSlashAsterisk) {
                    txt = delimit(txt, '/');
                  }
                  if (normalizeSpace) {
                    // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                    txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space

                  }
                  return getNext(txt, yytext());
          }
        case 55: break;
        case 43: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 9;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 10;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { // try to work around an apparent jflex bug where it
                          // gets a space at the token end by getting
                          // wrong the length of the trailing context.
                          while (yylength() > 0) {
                            char last = yycharat(yylength()-1);
                            if (last == ' ' || last == '\t' || (last >= '\n' && last <= '\r' || last == '\u0085')) {
                              yypushback(1);
                            } else {
                              break;
                            }
                          }
			  return getNext();
          }
        case 56: break;
        case 11: 
          { if (ptb3Dashes) {
                            return getNext(ptbmdash, yytext()); }
                          else {
                            return getNext();
                          }
          }
        case 57: break;
        case 19: 
          { if (escapeForwardSlashAsterisk) {
                    return getNext(delimit(yytext(), '*'), yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 58: break;
        case 8: 
          { return handleQuotes(yytext(), false);
          }
        case 59: break;
        case 35: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return handleQuotes(yytext(), false);
          }
        case 60: break;
        case 27: 
          { String txt = yytext();
                  String origText = txt;
                  if (normalizeParentheses) {
                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                  }
                  return getNext(txt, origText);
          }
        case 61: break;
        case 33: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { String txt = yytext();
                  String origText = txt;
                  if (normalizeParentheses) {
                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                  }
                  return getNext(txt, origText);
          }
        case 62: break;
        case 48: 
          { if (splitAssimilations) {
                            yypushback(2) ; return getNext();
                          } else {
                            return getNext();
                          }
          }
        case 63: break;
        case 49: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return getNormalizedAmpNext();
          }
        case 64: break;
        case 36: 
          { return getNormalizedAmpNext();
          }
        case 65: break;
        case 23: 
          { if (invertible) {
                            prevWordAfter.append(yytext());
                        }
          }
        case 66: break;
        case 37: 
          { String txt = yytext();
                  if (escapeForwardSlashAsterisk) {
                    txt = delimit(txt, '/');
                  }
                  if (normalizeSpace) {
                    // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                    txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                  }
                  return getNext(txt, yytext());
          }
        case 67: break;
        case 53: 
          // lookahead expression with fixed lookahead length
          yypushback(4);
          { return getNext();
          }
        case 68: break;
        case 46: 
          // lookahead expression with fixed lookahead length
          yypushback(2);
          { return getNext();
          }
        case 69: break;
        case 42: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 15;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 14;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { return getNext();
          }
        case 70: break;
        case 41: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 16;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 17;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { return getNext();
          }
        case 71: break;
        case 40: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 13;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 14;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { return getNext();
          }
        case 72: break;
        case 3: 
          { return getNext();
          }
        case 73: break;
        case 24: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return getNext();
          }
        case 74: break;
        case 51: 
          { String txt = yytext();
                          if (escapeForwardSlashAsterisk) {
                            txt = delimit(txt, '/');
                          }
                          return getNext(txt, yytext());
          }
        case 75: break;
        case 26: 
          { final String origTxt = yytext();
                          String txt = origTxt;
                          if (normalizeSpace) {
                            // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                            txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                          }
                          return getNext(txt, origTxt);
          }
        case 76: break;
        case 6: 
          { final String origTxt = yytext();
                          String tmp = removeSoftHyphens(origTxt);
                          if (americanize) {
                            tmp = Americanize.americanize(tmp);
                          }
                          return getNext(tmp, origTxt);
          }
        case 77: break;
        case 29: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 3;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 4;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { final String origTxt = yytext();
                          String tmp = removeSoftHyphens(origTxt);
                          if (americanize) {
                            tmp = Americanize.americanize(tmp);
                          }
                          return getNext(tmp, origTxt);
          }
        case 78: break;
        case 16: 
          { if (normalizeOtherBrackets) {
                    return getNext(closebrace, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 79: break;
        case 2: 
          { return getNext(""<"", yytext());
          }
        case 80: break;
        case 30: 
          { if (escapeForwardSlashAsterisk) {
                            return getNext(delimit(yytext(), '/'), yytext());
                          } else {
                            return getNext();
                          }
          }
        case 81: break;
        case 18: 
          { if (normalizeParentheses) {
                    return getNext(closeparen, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 82: break;
        case 54: 
          { String txt = yytext();
                          if (normalizeSpace) {
                            // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                            txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                          }
                          if (normalizeParentheses) {
                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                          }
                          return getNext(txt, yytext());
          }
        case 83: break;
        case 25: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return handleQuotes(yytext(), true);
          }
        case 84: break;
        case 39: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 5;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 6;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { final String txt = yytext();
                          return getNext(removeSoftHyphens(txt),
                                         txt);
          }
        case 85: break;
        case 21: 
          { if (normalizeOtherBrackets) {
                    return getNext(openbrace, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 86: break;
        case 50: 
          { if (splitAssimilations) {
                            yypushback(3) ; return getNext();
                          } else {
                            return getNext();
                          }
          }
        case 87: break;
        case 17: 
          { if (normalizeParentheses) {
                    return getNext(openparen, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 88: break;
        case 13: 
          { return handleEllipsis(yytext());
          }
        case 89: break;
        case 34: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 1;
          { /* invert quote - often but not always right */
                  return handleQuotes(yytext(), true);
          }
        case 90: break;
        case 14: 
          { return normalizeFractions(yytext());
          }
        case 91: break;
        case 15: 
          { if (normalizeCurrency) {
                            return getNext(normalizeCurrency(yytext()), yytext()); }
                          else {
                            return getNext();
                          }
          }
        case 92: break;
        case 47: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 11;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 12;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { String s;
                          if (strictTreebank3 && ! ""U.S."".equals(yytext())) {
                            yypushback(1); // return a period for next time
                            s = yytext();
                          } else {
                            s = yytext();
                            yypushback(1); // return a period for next time
                          }
                          return getNext(s, yytext());
          }
        case 93: break;
        case 7: 
          { if (invertible) {
                     prevWordAfter.append(yytext());
                  }
          }
        case 94: break;
        case 9: 
          { if (escapeForwardSlashAsterisk) {
                    return getNext(delimit(yytext(), '/'), yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 95: break;
        case 45: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return getNext(removeSoftHyphens(yytext()),
                                               yytext());
          }
        case 96: break;
        case 4: 
          { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {
                    return getNext(ptbmdash, yytext());
                  } else {
                    return getNext();
                  }
          }
        case 97: break;
        case 28: 
          { return getNext(removeSoftHyphens(yytext()), yytext());
          }
        case 98: break;
        case 20: 
          { if (normalizeOtherBrackets) {
                    return getNext(""-RSB-"", yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 99: break;
        case 12: 
          { return getNext(removeSoftHyphens(yytext()),
                                         yytext());
          }
        case 100: break;
        case 31: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return getNext(removeSoftHyphens(yytext()),
                                         yytext());
          }
        case 101: break;
        case 10: 
          { return getNext("">"", yytext());
          }
        case 102: break;
        case 32: 
          { // this one should only match if we're basically at the end of file
                          // since the last one matches two things, even newlines
                          String s;
                          if (strictTreebank3 && ! ""U.S."".equals(yytext())) {
                            yypushback(1); // return a period for next time
                            s = yytext();
                          } else {
                            s = yytext();
                            yypushback(1); // return a period for next time
                          }
                          return getNext(s, yytext());
          }
        case 103: break;
        case 22: 
          { if (normalizeOtherBrackets) {
                    return getNext(""-LSB-"", yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 104: break;
        case 52: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 7;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 8;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { // try to work around an apparent jflex bug where it
                          // gets a space at the token end by getting
                          // wrong the length of the trailing context.
                          while (yylength() > 0) {
                            char last = yycharat(yylength()-1);
                            if (last == ' ' || last == '\t' || (last >= '\n' && last <= '\r' || last == '\u0085')) {
                              yypushback(1);
                            } else {
                              break;
                            }
                          }
                          String s;
                          if (strictTreebank3 && ! ""U.S."".equals(yytext())) {
                            yypushback(1); // return a period for next time
                            s = yytext();
                          } else {
                            s = yytext();
                            yypushback(1); // return a period for next time
                          }
                          return getNext(s, yytext());
          }
        case 105: break;
        case 1: 
          { String str = yytext();
          int first = str.charAt(0);
          String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));
          switch (untokenizable) {
            case NONE_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              break;
            case FIRST_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              if ( ! this.seenUntokenizableCharacter) {
                LOGGER.warning(msg);
                this.seenUntokenizableCharacter = true;
              }
              break;
            case ALL_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              LOGGER.warning(msg);
              this.seenUntokenizableCharacter = true;
              break;
            case NONE_KEEP:
              return getNext();
            case FIRST_KEEP:
              if ( ! this.seenUntokenizableCharacter) {
                LOGGER.warning(msg);
                this.seenUntokenizableCharacter = true;
              }
              return getNext();
            case ALL_KEEP:
              LOGGER.warning(msg);
              this.seenUntokenizableCharacter = true;
              return getNext();
          }
          }
        case 106: break;
        case 44: 
          { String txt = yytext();
                          if (escapeForwardSlashAsterisk) {
                            txt = delimit(txt, '/');
                            txt = delimit(txt, '*');
                          }
                          return getNext(txt, yytext());
          }
        case 107: break;
        case 5: 
          { if (tokenizeNLs) {
                      return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns
                  } else if (invertible) {
                      prevWordAfter.append(yytext());
                  }
          }
        case 108: break;
        default: 
          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
            zzAtEOF = true;
              {
                if (invertible) {
            prevWordAfter.append(yytext());
            String str = prevWordAfter.toString();
            prevWordAfter.setLength(0);
            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);
          }
          return null;
              }
          } 
          else {
            zzScanError(ZZ_NO_MATCH);
          }
      }
    }
  }
"	Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.	Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.	0	1	17	702	4305
@Override public boolean isClosed() { return mode == Mode.PARTITION ? window.isClosedForPartition() : window.isClosed(); }	"    @Override
    public boolean isClosed() {
        return window.isClosed();
    }
"	Depending on the  Mode#ALL mode this is operating in, returns true if and only if the query window is closed and you should emit the result at this time.	Returns true if the query window is closed and you should emit the result at this time.	1	0	6	6	24
public static Object deserialize(InputStream inputStream) throws SerializationException { return deserialize( inputStream, Thread.currentThread().getContextClassLoader() ); }	"    public static Object deserialize(InputStream inputStream) throws SerializationException {
        if (inputStream == null) {
            throw new IllegalArgumentException(""The InputStream must not be null"");
        }

		log.trace(""Starting deserialization of object"");

        CustomObjectInputStream in = null;
        try {
            // stream closed in the finally
            in = new CustomObjectInputStream(inputStream);
            return in.readObject();

        }
        catch (ClassNotFoundException ex) {
            throw new SerializationException(""could not deserialize"", ex);
        }
        catch (IOException ex) {
            throw new SerializationException(""could not deserialize"", ex);
        }
        finally {
            try {
                if (in != null) in.close();
            }
            catch (IOException ex) {}
        }
    }
"	Deserializes an object from the specified stream using the Thread Context	Deserializes an Object from the specified stream. The stream will be closed once the object is written.	1	0	6	4	26
"public static Socket socket(URI uri, Options opts) { if (opts == null) { opts = new Options(); } URL parsed = Url.parse(uri); URI source; try { source = parsed.toURI(); } catch (URISyntaxException e) { throw new RuntimeException(e); } String id = Url.extractId(parsed); String path = parsed.getPath(); boolean sameNamespace = managers.containsKey(id) && managers.get(id).nsps.containsKey(path); boolean newConnection = opts.forceNew || !opts.multiplex || sameNamespace; Manager io; if (newConnection) { logger.fine(String.format(""ignoring socket cache for %s"", source)); io = new Manager(source, opts); } else { if (!managers.containsKey(id)) { logger.fine(String.format(""new io instance for %s"", source)); managers.putIfAbsent(id, new Manager(source, opts)); } io = managers.get(id); } String query = parsed.getQuery(); if (query != null && (opts.query == null || opts.query.isEmpty())) { opts.query = query; } return io.socket(parsed.getPath(), opts); }"	"    public static Socket socket(URI uri, Options opts) {
        if (opts == null) {
            opts = new Options();
        }

        URL parsed = Url.parse(uri);
        URI source;
        try {
            source = parsed.toURI();
        } catch (URISyntaxException e) {
            throw new RuntimeException(e);
        }
        String id = Url.extractId(parsed);
        String path = parsed.getPath();
        boolean sameNamespace = managers.containsKey(id)
                && managers.get(id).nsps.containsKey(path);
        boolean newConnection = opts.forceNew || !opts.multiplex || sameNamespace;
        Manager io;

        if (newConnection) {
            logger.fine(String.format(""ignoring socket cache for %s"", source));
            io = new Manager(source, opts);
        } else {
            if (!managers.containsKey(id)) {
                logger.fine(String.format(""new io instance for %s"", source));
                managers.putIfAbsent(id, new Manager(source, opts));
            }
            io = managers.get(id);
        }

        return io.socket(parsed.getPath());
    }
"	Initializes a  Socket from an existing  Manager for multiplexing.	Initializes a Socket from an existing Manager for multiplexing.	0	1	10	38	244
public User getUserByName(String username) throws ApiException { ApiResponse<User> localVarResp = getUserByNameWithHttpInfo(username); return localVarResp.getData(); }	"    public User getUserByName(String username) throws ApiException {
        ApiResponse<User> resp = getUserByNameWithHttpInfo(username);
        return resp.getData();
    }
"	Get user by user name	Get user by user name	0	1	6	5	25
public static byte[] readByteCode(ZipInputStream zip) throws IOException { ByteArrayOutputStream bout = new ByteArrayOutputStream(); InputStream in = new BufferedInputStream( zip ); int b; while ( ( b = in.read() ) != -1 ) { bout.write( b ); } return bout.toByteArray(); }	"	public static byte[] readByteCode(InputStream inputStream) throws IOException {
		if ( inputStream == null ) {
			throw new IOException( ""null input stream"" );
		}

		byte[] buffer = new byte[409600];
		byte[] classBytes = new byte[0];
		int r = 0;

		try {
			r = inputStream.read( buffer );
			while ( r >= buffer.length ) {
				byte[] temp = new byte[ classBytes.length + buffer.length ];
				System.arraycopy( classBytes, 0, temp, 0, classBytes.length );
				System.arraycopy( buffer, 0, temp, classBytes.length, buffer.length );
				classBytes = temp;
			}
			if ( r != -1 ) {
				byte[] temp = new byte[ classBytes.length + r ];
				System.arraycopy( classBytes, 0, temp, 0, classBytes.length );
				System.arraycopy( buffer, 0, temp, classBytes.length, r );
				classBytes = temp;
			}
		}
		finally {
			try {
				inputStream.close();
			}
			catch (IOException ignore) {
				// intentionally empty
			}
		}

		return classBytes;
	}
"	Read class definition a zip (jar) file entry.	Reads class byte array info from the given input stream.	1	0	7	10	59
public boolean contains(long millisInstant) { long thisStart = getStartMillis(); long thisEnd = getEndMillis(); return (millisInstant >= thisStart && millisInstant < thisEnd) || (thisStart == millisInstant && thisEnd == millisInstant); }	"    public boolean contains(long millisInstant) {
        long thisStart = getStartMillis();
        long thisEnd = getEndMillis();
        return (millisInstant >= thisStart && millisInstant < thisEnd);
    }
"	Does this time interval contain or equal the specified millisecond instant.	Does this time interval contain the specified millisecond instant.	1	0	7	7	41
public static DateTimeFormatter dateHourMinute() { return Constants.dhm; }	"    public static DateTimeFormatter dateHourMinute() {
        if (dhm == null) {
            dhm = new DateTimeFormatterBuilder()
                .append(date())
                .append(literalTElement())
                .append(hourMinute())
                .toFormatter();
        }
        return dhm;
    }
"	Returns a formatter that combines a full date, two digit hour of day, and two digit minute of hour.	Returns a formatter that combines a full date, two digit hour of day, and two digit minute of hour.	0	1	4	4	12
public List<TableDesc> listTables() { return allTables; }	"    public List<TableDesc> listTables() {
        return Lists.newArrayList(this.tableDesc);
    }
"	at first stage the only table in II is fact table, tables	at first stage the only table in II is fact table, TODO: to extend to all tables	1	0	5	4	11
public DateTimeField[] getFields() { DateTimeField[] result = new DateTimeField[getFieldSize()]; for (int i = 0; i < result.length; i++) { result[i] = getField(i); } return result; }	"    public DateTimeField[] getFields() {
        return (DateTimeField[]) iFields.clone();
    }
"	Gets an array of the fields that this partial supports.	Gets an array of the fields that this partial supports.	0	1	9	8	49
public Optional<GraphQLError> add(SDLDefinition definition) { // extensions if (definition instanceof ObjectTypeExtensionDefinition) { ObjectTypeExtensionDefinition newEntry = (ObjectTypeExtensionDefinition) definition; return defineExt(objectTypeExtensions, newEntry, ObjectTypeExtensionDefinition::getName); } else if (definition instanceof InterfaceTypeExtensionDefinition) { InterfaceTypeExtensionDefinition newEntry = (InterfaceTypeExtensionDefinition) definition; return defineExt(interfaceTypeExtensions, newEntry, InterfaceTypeExtensionDefinition::getName); } else if (definition instanceof UnionTypeExtensionDefinition) { UnionTypeExtensionDefinition newEntry = (UnionTypeExtensionDefinition) definition; return defineExt(unionTypeExtensions, newEntry, UnionTypeExtensionDefinition::getName); } else if (definition instanceof EnumTypeExtensionDefinition) { EnumTypeExtensionDefinition newEntry = (EnumTypeExtensionDefinition) definition; return defineExt(enumTypeExtensions, newEntry, EnumTypeExtensionDefinition::getName); } else if (definition instanceof ScalarTypeExtensionDefinition) { ScalarTypeExtensionDefinition newEntry = (ScalarTypeExtensionDefinition) definition; return defineExt(scalarTypeExtensions, newEntry, ScalarTypeExtensionDefinition::getName); } else if (definition instanceof InputObjectTypeExtensionDefinition) { InputObjectTypeExtensionDefinition newEntry = (InputObjectTypeExtensionDefinition) definition; return defineExt(inputObjectTypeExtensions, newEntry, InputObjectTypeExtensionDefinition::getName); // // normal } else if (definition instanceof ScalarTypeDefinition) { ScalarTypeDefinition newEntry = (ScalarTypeDefinition) definition; return define(scalarTypes, scalarTypes, newEntry); } else if (definition instanceof TypeDefinition) { TypeDefinition newEntry = (TypeDefinition) definition; return define(types, types, newEntry); } else if (definition instanceof DirectiveDefinition) { DirectiveDefinition newEntry = (DirectiveDefinition) definition; return define(directiveDefinitions, directiveDefinitions, newEntry); } else if (definition instanceof SchemaDefinition) { SchemaDefinition newSchema = (SchemaDefinition) definition; if (schema != null) { return Optional.of(new SchemaRedefinitionError(this.schema, newSchema)); } else { schema = newSchema; } } else { return Assert.assertShouldNeverHappen(); } return Optional.empty(); }	"    public Optional<GraphQLError> add(Definition definition) {
        // extensions
        if (definition instanceof ObjectTypeExtensionDefinition) {
            ObjectTypeExtensionDefinition newEntry = (ObjectTypeExtensionDefinition) definition;
            return defineExt(objectTypeExtensions, newEntry, ObjectTypeExtensionDefinition::getName);
        } else if (definition instanceof InterfaceTypeExtensionDefinition) {
            InterfaceTypeExtensionDefinition newEntry = (InterfaceTypeExtensionDefinition) definition;
            return defineExt(interfaceTypeExtensions, newEntry, InterfaceTypeExtensionDefinition::getName);
        } else if (definition instanceof UnionTypeExtensionDefinition) {
            UnionTypeExtensionDefinition newEntry = (UnionTypeExtensionDefinition) definition;
            return defineExt(unionTypeExtensions, newEntry, UnionTypeExtensionDefinition::getName);
        } else if (definition instanceof EnumTypeExtensionDefinition) {
            EnumTypeExtensionDefinition newEntry = (EnumTypeExtensionDefinition) definition;
            return defineExt(enumTypeExtensions, newEntry, EnumTypeExtensionDefinition::getName);
        } else if (definition instanceof ScalarTypeExtensionDefinition) {
            ScalarTypeExtensionDefinition newEntry = (ScalarTypeExtensionDefinition) definition;
            return defineExt(scalarTypeExtensions, newEntry, ScalarTypeExtensionDefinition::getName);
        } else if (definition instanceof InputObjectTypeExtensionDefinition) {
            InputObjectTypeExtensionDefinition newEntry = (InputObjectTypeExtensionDefinition) definition;
            return defineExt(inputObjectTypeExtensions, newEntry, InputObjectTypeExtensionDefinition::getName);
            //
            // normal
        } else if (definition instanceof ScalarTypeDefinition) {
            ScalarTypeDefinition newEntry = (ScalarTypeDefinition) definition;
            return define(scalarTypes, scalarTypes, newEntry);
        } else if (definition instanceof TypeDefinition) {
            TypeDefinition newEntry = (TypeDefinition) definition;
            return define(types, types, newEntry);
        } else if (definition instanceof DirectiveDefinition) {
            DirectiveDefinition newEntry = (DirectiveDefinition) definition;
            return define(directiveDefinitions, directiveDefinitions, newEntry);
        } else if (definition instanceof SchemaDefinition) {
            SchemaDefinition newSchema = (SchemaDefinition) definition;
            if (schema != null) {
                return Optional.of(new SchemaRedefinitionError(this.schema, newSchema));
            } else {
                schema = newSchema;
            }
        }
        return Optional.empty();
    }
"	Adds a definition to the registry	Adds a definition to the registry	0	1	20	44	328
public List getLinkHRefs(boolean duplicate) { if (duplicate) { return this.htmlHandler.getAllLinkHRefs(); } return this.htmlHandler.getLinkHRefs(); }	"    public List getLinkHRefs(boolean duplicate) {
        if (duplicate) {
            return htmlHandler.getAllLinkHRefs();
        } else {
            return htmlHandler.getLinkHRefs();
        }
    }
"	Get Link hrefs	DOCUMENT ME!	1	0	7	8	29
"boolean storeRelations(KeyRegistry keyRegistry) { if (relationStoreInfos.isEmpty()) { // No relations waiting to be persisted return false; } ObjectProvider op = getObjectProvider(); ExecutionContext ec = op.getExecutionContext(); DatastoreTable table = getDatastoreTable(); if (datastoreEntity.getKey() != null) { // Register parent key for all owned related objects Key key = datastoreEntity.getKey(); AbstractClassMetaData acmd = op.getClassMetaData(); int[] relationFieldNums = acmd.getRelationMemberPositions(ec.getClassLoaderResolver(), ec.getMetaDataManager()); if (relationFieldNums != null) { for (int i=0;i<relationFieldNums.length;i++) { AbstractMemberMetaData mmd = acmd.getMetaDataForManagedMemberAtAbsolutePosition(relationFieldNums[i]); boolean owned = MetaDataUtils.isOwnedRelation(mmd); if (owned) { Object childValue = op.provideField(mmd.getAbsoluteFieldNumber()); if (childValue != null) { if (childValue instanceof Object[]) { childValue = Arrays.asList((Object[]) childValue); } String expectedType = getExpectedChildType(mmd); if (childValue instanceof Iterable) { // TODO(maxr): Make sure we're not pulling back unnecessary data when we iterate over the values. for (Object element : (Iterable) childValue) { addToParentKeyMap(keyRegistry, element, key, op.getExecutionContext(), expectedType, true); } } else { addToParentKeyMap(keyRegistry, childValue, key, op.getExecutionContext(), expectedType, !table.isParentKeyProvider(mmd)); } } } } } } boolean modifiedEntity = false; // Stage 1 : process FKs for (RelationStoreInformation relInfo : relationStoreInfos) { AbstractMemberMetaData mmd = relInfo.mmd; try { JavaTypeMapping mapping = table.getMemberMappingInDatastoreClass(relInfo.mmd); if (mapping instanceof EmbeddedPCMapping || mapping instanceof SerialisedPCMapping || mapping instanceof SerialisedReferenceMapping || mapping instanceof PersistableMapping || mapping instanceof InterfaceMapping) { if (!table.isParentKeyProvider(mmd)) { EntityUtils.checkParentage(relInfo.value, op); mapping.setObject(getExecutionContext(), datastoreEntity, IS_FK_VALUE_ARR, relInfo.value, op, mmd.getAbsoluteFieldNumber()); } } } catch (NotYetFlushedException e) { // Ignore this. We always have the object in the datastore, at least partially to get the key } } // Stage 2 : postInsert/postUpdate for (RelationStoreInformation relInfo : relationStoreInfos) { try { JavaTypeMapping mapping = table.getMemberMappingInDatastoreClass(relInfo.mmd); if (mapping instanceof MappingCallbacks) { if (operation == StoreFieldManager.Operation.INSERT) { ((MappingCallbacks)mapping).postInsert(op); } else { ((MappingCallbacks)mapping).postUpdate(op); } } } catch (NotYetFlushedException e) { // Ignore this. We always have the object in the datastore, at least partially to get the key } } // Stage 3 : set child keys in parent for (RelationStoreInformation relInfo : relationStoreInfos) { AbstractMemberMetaData mmd = relInfo.mmd; int relationType = mmd.getRelationType(ec.getClassLoaderResolver()); boolean owned = MetaDataUtils.isOwnedRelation(mmd); if (owned) { // Owned relations only store child keys if storageVersion high enough, and at ""owner"" side. if (!getStoreManager().storageVersionAtLeast(StorageVersion.WRITE_OWNED_CHILD_KEYS_TO_PARENTS)) { // don't write child keys to the parent if the storage version isn't high enough continue; } if (relationType == Relation.MANY_TO_ONE_BI) { // We don't store any ""FK"" of the parent at the child side (use parent key instead) continue; } else if (relationType == Relation.ONE_TO_ONE_BI && mmd.getMappedBy() != null) { // We don't store any ""FK"" at the non-owner side (use parent key instead) continue; } } Object value = relInfo.value; String propName = EntityUtils.getPropertyName(getStoreManager().getIdentifierFactory(), mmd); if (value == null) { // Nothing to extract checkSettingToNullValue(mmd, value); if (!datastoreEntity.hasProperty(propName)) { modifiedEntity = true; EntityUtils.setEntityProperty(datastoreEntity, mmd, propName, value); } } else if (Relation.isRelationSingleValued(relationType)) { if (ec.getApiAdapter().isDeleted(value)) { value = null; } else { Key key = EntityUtils.extractChildKey(value, ec, datastoreEntity); if (key == null) { Object childPC = processPersistable(mmd, value); if (childPC != value) { // Child object has been persisted/attached, so update it in the owner op.replaceField(mmd.getAbsoluteFieldNumber(), childPC); } key = EntityUtils.extractChildKey(childPC, ec, datastoreEntity); } value = key; if (!datastoreEntity.hasProperty(propName) || !value.equals(datastoreEntity.getProperty(propName))) { modifiedEntity = true; EntityUtils.setEntityProperty(datastoreEntity, mmd, propName, value); } } } else if (Relation.isRelationMultiValued(relationType)) { if (mmd.hasCollection()) { Collection coll = (Collection) value; List<Key> keys = Utils.newArrayList(); for (Object obj : coll) { // TODO Should process SCO before we get here so we have no deleted objects if (!ec.getApiAdapter().isDeleted(obj)) { Key key = EntityUtils.extractChildKey(obj, ec, datastoreEntity); if (key != null) { keys.add(key); } else { Object childPC = processPersistable(mmd, obj); key = EntityUtils.extractChildKey(childPC, ec, datastoreEntity); keys.add(key); } } } value = keys; if (!datastoreEntity.hasProperty(propName) || !value.equals(datastoreEntity.getProperty(propName))) { modifiedEntity = true; EntityUtils.setEntityProperty(datastoreEntity, mmd, propName, value); } } // TODO Cater for PC array, maps } } relationStoreInfos.clear(); return modifiedEntity; }"	"  boolean storeRelations(KeyRegistry keyRegistry) {
    NucleusLogger.GENERAL.debug("">> StoreFM.storeRelations "" + getObjectProvider() + "" numRelations="" + relationStoreInfos.size());
    if (relationStoreInfos.isEmpty()) {
      // No relations waiting to be persisted
      return false;
    }

    ObjectProvider op = getObjectProvider();
    ExecutionContext ec = op.getExecutionContext();
    DatastoreTable table = getDatastoreTable();
    if (datastoreEntity.getKey() != null) {
      // Register parent key for all owned related objects
      Key key = datastoreEntity.getKey();
      AbstractClassMetaData acmd = op.getClassMetaData();
      int[] relationFieldNums = acmd.getRelationMemberPositions(ec.getClassLoaderResolver(), ec.getMetaDataManager());
      if (relationFieldNums != null) {
        for (int i=0;i<relationFieldNums.length;i++) {
          AbstractMemberMetaData mmd = acmd.getMetaDataForManagedMemberAtAbsolutePosition(relationFieldNums[i]);
          boolean owned = MetaDataUtils.isOwnedRelation(mmd);
          if (owned) {
            Object childValue = op.provideField(mmd.getAbsoluteFieldNumber());
            if (childValue != null) {
              if (childValue instanceof Object[]) {
                childValue = Arrays.asList((Object[]) childValue);
              }

              String expectedType = getExpectedChildType(mmd);
              if (childValue instanceof Iterable) {
                // TODO(maxr): Make sure we're not pulling back unnecessary data when we iterate over the values.
                for (Object element : (Iterable) childValue) {
                  addToParentKeyMap(keyRegistry, element, key, op.getExecutionContext(), expectedType, true);
                }
              } else {
                addToParentKeyMap(keyRegistry, childValue, key, op.getExecutionContext(), expectedType, 
                    !table.isParentKeyProvider(mmd));
              }
            }
          }
        }
      }
    }

    boolean modifiedEntity = false;

    // Stage 1 : process FKs
    for (RelationStoreInformation relInfo : relationStoreInfos) {
      AbstractMemberMetaData mmd = relInfo.mmd;
      try {
        JavaTypeMapping mapping = table.getMemberMappingInDatastoreClass(relInfo.mmd);
        if (mapping instanceof EmbeddedPCMapping ||
            mapping instanceof SerialisedPCMapping ||
            mapping instanceof SerialisedReferenceMapping ||
            mapping instanceof PersistableMapping ||
            mapping instanceof InterfaceMapping) {
          if (!table.isParentKeyProvider(mmd)) {
            EntityUtils.checkParentage(relInfo.value, op);
            mapping.setObject(getExecutionContext(), datastoreEntity, IS_FK_VALUE_ARR, relInfo.value, op, mmd.getAbsoluteFieldNumber());
          }
        }
      } catch (NotYetFlushedException e) {
        // Ignore this. We always have the object in the datastore, at least partially to get the key
      }
    }

    // Stage 2 : postInsert/postUpdate
    for (RelationStoreInformation relInfo : relationStoreInfos) {
      try {
        JavaTypeMapping mapping = table.getMemberMappingInDatastoreClass(relInfo.mmd);
        if (mapping instanceof MappingCallbacks) {
          if (operation == StoreFieldManager.Operation.INSERT) {
            ((MappingCallbacks)mapping).postInsert(op);
          } else {
            ((MappingCallbacks)mapping).postUpdate(op);
          }
        }
      } catch (NotYetFlushedException e) {
        // Ignore this. We always have the object in the datastore, at least partially to get the key
      }
    }

    // Stage 3 : set child keys in parent
    for (RelationStoreInformation relInfo : relationStoreInfos) {
      AbstractMemberMetaData mmd = relInfo.mmd;
      int relationType = mmd.getRelationType(ec.getClassLoaderResolver());
      NucleusLogger.GENERAL.debug("">> StoreFM.storeRelations "" + getObjectProvider() + "" field="" + mmd.getFullFieldName());

      boolean owned = MetaDataUtils.isOwnedRelation(mmd);
      if (owned) {
        // Owned relations only store child keys if storageVersion high enough, and at ""owner"" side.
        if (!getStoreManager().storageVersionAtLeast(StorageVersion.WRITE_OWNED_CHILD_KEYS_TO_PARENTS)) {
          // don't write child keys to the parent if the storage version isn't high enough
          continue;
        }
        if (relationType == Relation.MANY_TO_ONE_BI) {
          // We don't store any ""FK"" of the parent at the child side (use parent key instead)
          continue;
        } else if (relationType == Relation.ONE_TO_ONE_BI && mmd.getMappedBy() != null) {
          // We don't store any ""FK"" at the non-owner side (use parent key instead)
          continue;
        }
      }

      Object value = relInfo.value;
      if (value == null) {
        // Nothing to extract
        checkSettingToNullValue(mmd, value);
      } else if (Relation.isRelationSingleValued(relationType)) {
        if (ec.getApiAdapter().isDeleted(value)) {
          value = null;
        } else {
          Key key = EntityUtils.extractChildKey(value, ec, datastoreEntity);
          if (key == null) {
            Object childPC = processPersistable(mmd, value);
            if (childPC != value) {
              // Child object has been persisted/attached, so update it in the owner
              op.replaceField(mmd.getAbsoluteFieldNumber(), childPC);
            }
            key = EntityUtils.extractChildKey(childPC, ec, datastoreEntity);
          }
          value = key;
        }
      } else if (Relation.isRelationMultiValued(relationType)) {
        if (mmd.hasCollection()) {
          Collection coll = (Collection) value;
          List<Key> keys = Utils.newArrayList();
          for (Object obj : coll) {
            // TODO Should process SCO before we get here so we have no deleted objects
            if (!ec.getApiAdapter().isDeleted(obj)) {
              Key key = EntityUtils.extractChildKey(obj, ec, datastoreEntity);
              if (key != null) {
                keys.add(key);
              } else {
                Object childPC = processPersistable(mmd, obj);
                key = EntityUtils.extractChildKey(childPC, ec, datastoreEntity);
                keys.add(key);
              }
            }
          }
          value = keys;
        }
        // TODO Cater for PC array, maps

        if (value instanceof SCO) {
          // Use the unwrapped value so the datastore doesn't fail on unknown types
          value = ((SCO)value).getValue();
        }
      }

      modifiedEntity = true;
      EntityUtils.setEntityProperty(datastoreEntity, mmd, 
          EntityUtils.getPropertyName(getStoreManager().getIdentifierFactory(), mmd), value);
    }

    relationStoreInfos.clear();

    NucleusLogger.GENERAL.debug("">> StoreFM.storeRelations "" + getObjectProvider() + "" entityModified="" + modifiedEntity);
    // TODO Return if we have modified the entity in this call

    try {
      return keyRegistry.parentNeedsUpdate(datastoreEntity.getKey());
    } finally {
      keyRegistry.clearModifiedParent(datastoreEntity.getKey());
    }
  }
"	Method to process all relations that have been identified by earlier call(s) of op.provideField(...).	Applies all the relation events that have been built up.	1	0	20	161	1093
static boolean hasNoNulls(Statistics stat) { return stat.getNumNulls() <= 0; }	"  static boolean hasNoNulls(Statistics stat) {
    return !stat.isNumNullsSet() || stat.getNumNulls() == 0;
  }
"	Checks that column chunk's statistics does not have nulls	Checks that column chunk's statistics has at least one null	1	0	5	5	16
public static boolean startsWithPattern(final byte[] byteArray, final byte[] pattern) { return hasPatternAt(byteArray, pattern, 0); }	"  public static boolean startsWithPattern(final byte[] byteArray, final byte[] pattern) {
    Preconditions.checkNotNull(byteArray);
    Preconditions.checkNotNull(pattern);
    if (pattern.length > byteArray.length) {
      return false;
    }

    for (int i = 0; i < pattern.length; ++i) {
      if (byteArray[i] != pattern[i]) {
        return false;
      }
    }

    return true;
  }
"	Checks if byteArray interpreted as sequence of bytes starts with pattern starting at position equal to offset.	Checks if byteArray interpreted as sequence of bytes starts with pattern starting at position equal to offset.	0	1	5	4	29
public Definition emit(Class cls, String allowedMethods) throws Exception { this.cls = cls; this.allowedMethods = allowedMethods; /** @todo ravi: getting the serviceName from cls name or explicitly ask the user? */ String name = cls.getName(); name = name.substring(name.lastIndexOf('.') + 1); setServiceName(name); return emit(); }	"    public Document emit(Class cls, String allowedMethods) throws Exception {
        this.cls = cls;
        this.allowedMethods = allowedMethods;

        /** @todo ravi: getting the serviceName from cls name or explicitly ask the user? */
        String name = cls.getName();
        name = name.substring(name.lastIndexOf('.') + 1);
        setServiceName(name);
        return emit();
    }
"	Generates a WSDL Definition for a given Class and a space seperated list of methods at design time	Generates a WSDL Document for a given Class and a space seperated list of methods at design time	1	0	8	12	74
public String toBooleanGetter(String name) { return getterAndSetterCapitalize(name); }	"    public String toBooleanGetter(String name) {
        return ""is"" + getterAndSetterCapitalize(name);
    }
"	Output the partial Getter name for boolean property, e.g.	Output the Getter name for boolean property, e.g.	1	0	5	4	15
public DateOnly roundHalfFloorCopy() { DateOnly instant = iInstant; return (DateOnly)instant.withMillis(iField.roundHalfFloor(instant.getMillis())); }	"    public DateOnly roundHalfFloorCopy() {
        DateOnly instant = iInstant;
        return (DateOnly)instant.toCopy(iField.roundHalfFloor(instant.getMillis()));
    }
"	Rounds to the nearest whole unit of this field on a copy of this DateOnly, favoring the floor if halfway.	Rounds to the nearest whole unit of this field on a copy of this DateOnly, favoring the floor if halfway.	0	1	7	5	28
public Observable<Connectivity> observeNetworkConnectivity(final Context context) { final IntentFilter filter = new IntentFilter(); filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION); return Observable.create(new Observable.OnSubscribe<Connectivity>() { @Override public void call(final Subscriber<? super Connectivity> subscriber) { final BroadcastReceiver receiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { subscriber.onNext(Connectivity.create(context)); } }; context.registerReceiver(receiver, filter); subscriber.add(unsubscribeInUiThread(new Action0() { @Override public void call() { context.unregisterReceiver(receiver); } })); } }).defaultIfEmpty(Connectivity.create()); }	"  public Observable<ConnectivityStatus> observeNetworkConnectivity(final Context context) {
    final IntentFilter filter = new IntentFilter();
    filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);

    return Observable.create(new Observable.OnSubscribe<ConnectivityStatus>() {
      @Override public void call(final Subscriber<? super ConnectivityStatus> subscriber) {
        final BroadcastReceiver receiver = new BroadcastReceiver() {
          @Override public void onReceive(Context context, Intent intent) {
            final ConnectivityStatus newStatus = getConnectivityStatus(context);

            // we need to perform check below,
            // because after going off-line, onReceive() is called twice
            if (newStatus != status) {
              status = newStatus;
              subscriber.onNext(newStatus);
            }
          }
        };

        context.registerReceiver(receiver, filter);

        subscriber.add(unsubscribeInUiThread(new Action0() {
          @Override public void call() {
            context.unregisterReceiver(receiver);
          }
        }));
      }
    }).defaultIfEmpty(ConnectivityStatus.OFFLINE);
  }
"	Observes network connectivity.	Observes ConnectivityStatus, which can be WIFI_CONNECTED, MOBILE_CONNECTED or OFFLINE	1	0	14	24	133
public Float getTopValue() { return topValue; }	"        public float getTopValue() {
            return topValue == null ? 0 : topValue.floatValue();
        }
"	Gets the 'top' attributes value in current units.	Gets the 'top' CSS-attributes value in specified units.	1	0	4	5	10
public Chat dccSendChatRequest(User sender, int timeout) throws IOException, SocketTimeoutException { return dccHandler.sendChatRequest(sender); }	"	public DccChat dccSendChatRequest(User sender, int timeout) throws IOException, SocketTimeoutException {
		if (sender == null)
			throw new IllegalArgumentException(""Can't send chat request to null user"");
		ServerSocket ss = null;//dccManager.createServerSocket();
		ss.setSoTimeout(timeout);
		int serverPort = ss.getLocalPort();

		InetAddress ourAddress = getDccInetAddress();
		if (ourAddress == null)
			ourAddress = getInetAddress();
		String ipNum = DccManager.addressToInteger(ourAddress);

		sendCTCPCommand(sender, ""DCC CHAT chat "" + ipNum + "" "" + serverPort);

		// The client may now connect to us to chat.
		Socket userSocket = ss.accept();

		// Close the server socket now that we've finished with it.
		ss.close();

		return new DccChat(this, sender, userSocket);
	}
"	Utility method to send a chat request to a user.	Attempts to establish a DCC CHAT session with a client.	1	0	5	5	23
public static Schema parse(File file) throws IOException { return new Parser().parse(file); }	"  public static Schema parse(File file) throws IOException {
    JsonParser parser = FACTORY.createJsonParser(file);
    try {
      return Schema.parse(MAPPER.readTree(parser), new Names());
    } catch (JsonParseException e) {
      throw new SchemaParseException(e);
    }
  }
"	Constructs a Schema object from JSON schema file file.	Constructs a Schema object from JSON schema file file.	0	1	6	4	22
public Throwable initCause(Throwable cause) { return super.initCause(cause); }	"	public Throwable initCause(Throwable cause) {
		throw new IllegalStateException();
	}
"	Initializes the cause of this exception to the specified value.	The cause of this exception can only be set when constructed.	1	0	5	5	16
protected TreePath[] getPathBetweenRows(int index0, int index1) { TreeUI tree = getUI(); if (tree != null) { int rowCount = getRowCount(); if (rowCount > 0 && !((index0 < 0 && index1 < 0) || (index0 >= rowCount && index1 >= rowCount))){ index0 = Math.min(rowCount - 1, Math.max(index0, 0)); index1 = Math.min(rowCount - 1, Math.max(index1, 0)); int minIndex = Math.min(index0, index1); int maxIndex = Math.max(index0, index1); TreePath[] selection = new TreePath[ maxIndex - minIndex + 1]; for(int counter = minIndex; counter <= maxIndex; counter++) { selection[counter - minIndex] = tree.getPathForRow(this, counter); } return selection; } } return new TreePath[0]; }	"    protected TreePath[] getPathBetweenRows(int index0, int index1) {
        int              newMinIndex, newMaxIndex;
        TreeUI           tree = getUI();

        newMinIndex = Math.min(index0, index1);
        newMaxIndex = Math.max(index0, index1);

        if(tree != null) {
            TreePath[] selection = new TreePath[newMaxIndex - newMinIndex + 1];
            for(int counter = newMinIndex; counter <= newMaxIndex; counter++) {
                selection[counter - newMinIndex] = tree.getPathForRow(this, counter);
            }
            return selection;
        }
        return null;
    }
"	Returns the paths (inclusive) between the specified rows.	Returns JTreePath instances representing the path between index0 and index1 (including index1).	1	0	14	23	171
public boolean isConstrained(String observation) { return observationIndex.indexOf(observation) >= 0; }	"  public boolean isConstrained(String observation) {
    return labelDictionary.containsKey(observation);
  }
"	True if this observation is constrained, and false otherwise.	True if this observation is constrained, and false otherwise.	0	1	6	4	17
"public static HashMap getXmlRpcWorkflowInstancePage( WorkflowInstancePage page) { HashMap pageHash = new HashMap(); pageHash.put(""totalPages"", String.valueOf(page.getTotalPages())); pageHash.put(""pageNum"", String.valueOf(page.getPageNum())); pageHash.put(""pageSize"", String.valueOf(page.getPageSize())); pageHash.put(""pageWorkflows"", getXmlRpcWorkflowInstances(page.getPageWorkflows())); return pageHash; }"	"  public static Hashtable getXmlRpcWorkflowInstancePage(
      WorkflowInstancePage page) {
    Hashtable pageHash = new Hashtable();
    pageHash.put(""totalPages"", String.valueOf(page.getTotalPages()));
    pageHash.put(""pageNum"", String.valueOf(page.getPageNum()));
    pageHash.put(""pageSize"", String.valueOf(page.getPageSize()));
    pageHash.put(""pageWorkflows"",
        getXmlRpcWorkflowInstances(page.getPageWorkflows()));

    return pageHash;

  }
"	Gets a  HashMap representation of a  WorkflowInstancePage that is serializable over the XML-RPC wire.	Gets a Hashtable representation of a WorkflowInstancePage that is serializable over the XML-RPC wire.	1	0	6	14	87
"public synchronized static String hashPassword(long accountId, String password) { try { return sha1Hash(getBytes(""FX-SALT"" + accountId + password)); } catch (NoSuchAlgorithmException e) { throw new FxCreateException(""Failed to load the SHA1 algorithm."").asRuntimeException(); } }"	"    public synchronized static final String hashPassword(String password) {
        if (digest == null) {
            try {
                digest = MessageDigest.getInstance(""MD5"");
            } catch (NoSuchAlgorithmException nsae) {
                System.err.println(""Failed to load the MD5 MessageDigest. "" + ""CMS will be unable to function normally."");
                nsae.printStackTrace();
            }
        }
        //Now, compute hash.
        digest.update(getBytes(password));
        String result = FxFormatUtils.encodeHex(digest.digest());
        // Avoid SQL problems
        return result.replaceAll(""'"", ""_"");
    }
"	Compute the hash of the given flexive password.	Hashes a password, making it almost impossible to read it.	1	0	9	9	58
public WebDriver frame(final String nameOrIdOrIndex) { try { // 1.) try to find frame in current window ... currentWindow = findFrame(currentWindow, nameOrIdOrIndex); } catch (NoSuchFrameException ignored) { // 2.) try to find frame in top window ... final WebWindow topWindow = currentWindow.getTopWindow(); currentWindow = findFrame(topWindow, nameOrIdOrIndex); } return HtmlUnitDriver.this; }	"    public WebDriver frame(final String name) {
      WebWindow window = currentWindow.getTopWindow();

      // Walk over all parts of the frame identifier, each time looking for a frame
      // with a name or ID matching this part of the identifier (separated by '.').
      String[] frames = name.split(""\\."");
      for (int i = 0; i < frames.length; ++i) {
        final String currentFrameId = frames[i];
        final HtmlPage page = (HtmlPage) window.getEnclosedPage();
        
        if (isNumericFrameIdValid(currentFrameId, page)) {
          window = getWindowByNumericFrameId(currentFrameId, page);
        } else {
          // Numeric frame ID is not valid - could be either because the identifier
          // was numeric and not valid OR the number that was given is actually a frame
          // name, not an index.
          
          boolean nextFrameFound = false;
          for (final FrameWindow frameWindow : page.getFrames()) {
            final String frameName = frameWindow.getName();
            final String frameId = frameWindow.getFrameElement().getId();
            final String remainingFrameId = joinFrom(frames, i, '.');
            if (frameName.equals(remainingFrameId) || frameId.equals(remainingFrameId)) {
              currentWindow = frameWindow;
              return HtmlUnitDriver.this;
            }
            if (frameName.equals(currentFrameId) || frameId.equals(currentFrameId)) {
              window = frameWindow;
              nextFrameFound = true;
            }
          } // End for.
          
          if (!nextFrameFound) {
            throw new NoSuchFrameException(""Cannot find frame: "" + name);
          }
        } // End else

      } // End for
      
      currentWindow = window;
      return HtmlUnitDriver.this;
    }
"	Switches to a given frame according to name or numeric ID.	Switches to a given frame according to name or numeric ID.	0	1	8	12	70
"private long insertData(ContentValues values, boolean callerIsSyncAdapter) { long id = 0; mValues.clear(); mValues.putAll(values); Long rawContactId = mValues.getAsLong(Data.RAW_CONTACT_ID); if (rawContactId == null) { throw new IllegalArgumentException(Data.RAW_CONTACT_ID + "" is required""); } // Replace package with internal mapping final String packageName = mValues.getAsString(Data.RES_PACKAGE); if (packageName != null) { mValues.put(DataColumns.PACKAGE_ID, mDbHelper.get().getPackageId(packageName)); } mValues.remove(Data.RES_PACKAGE); // Replace mimetype with internal mapping final String mimeType = mValues.getAsString(Data.MIMETYPE); if (TextUtils.isEmpty(mimeType)) { throw new IllegalArgumentException(Data.MIMETYPE + "" is required""); } mValues.put(DataColumns.MIMETYPE_ID, mDbHelper.get().getMimeTypeId(mimeType)); mValues.remove(Data.MIMETYPE); DataRowHandler rowHandler = getDataRowHandler(mimeType); final SQLiteDatabase db = mDbHelper.get().getWritableDatabase(); id = rowHandler.insert(db, mTransactionContext.get(), rawContactId, mValues); mTransactionContext.get().markRawContactDirtyAndChanged(rawContactId, callerIsSyncAdapter); mTransactionContext.get().rawContactUpdated(rawContactId); return id; }"	"    private long insertData(ContentValues inputValues, boolean callerIsSyncAdapter) {
        final Long rawContactId = inputValues.getAsLong(Data.RAW_CONTACT_ID);
        if (rawContactId == null) {
            throw new IllegalArgumentException(Data.RAW_CONTACT_ID + "" is required"");
        }

        final String mimeType = inputValues.getAsString(Data.MIMETYPE);
        if (TextUtils.isEmpty(mimeType)) {
            throw new IllegalArgumentException(Data.MIMETYPE + "" is required"");
        }

        // The input seem valid, create a shallow copy.
        final ContentValues values = new ContentValues(inputValues);

        // Populate the relevant values before inserting the new entry into the database.
        replacePackageNameByPackageId(values);

        // Replace the mimetype by the corresponding mimetype ID.
        values.put(DataColumns.MIMETYPE_ID, mDbHelper.get().getMimeTypeId(mimeType));
        values.remove(Data.MIMETYPE);

        // Insert the new entry.
        final SQLiteDatabase db = mDbHelper.get().getWritableDatabase();
        final TransactionContext context = mTransactionContext.get();
        final long dataId = getDataRowHandler(mimeType).insert(db, context, rawContactId, values);
        context.markRawContactDirtyAndChanged(rawContactId, callerIsSyncAdapter);
        context.rawContactUpdated(rawContactId);

        return dataId;
    }
"	Inserts an item in the data table	Inserts a new entry into the (contact) data table.	1	0	9	35	224
public DateTimeField minuteOfHour() { return UnsupportedDateTimeField.getInstance(DateTimeFieldType.minuteOfHour(), minutes()); }	"    public DateTimeField minuteOfHour() {
        return UnsupportedDateTimeField.getInstance(""minuteOfHour"", minutes());
    }
"	Get the minute of hour field for this chronology.	Get the minute of hour field for this chronology.	0	1	5	4	21
public ArrayList getLinkHRefs() { return this.link_href; }	"    public ArrayList getLinkHRefs() {
        return link_href;
    }
"	Get a list of links	DOCUMENT ME!	1	0	5	5	11
"@Override public Object clone() { try { DBTable clone = (DBTable) super.clone(); // clone all columns Class<?> colClass = columns.get(0).getClass(); Class<?> colBase = colClass.getSuperclass(); clone.columns = new ArrayList<DBColumn>(); Field[] fields = getClass().getFields(); for (int i = 0; i < columns.size(); i++) { DBTableColumn srcCol = (DBTableColumn) columns.get(i); DBTableColumn newCol = new DBTableColumn(clone, srcCol); // Replace all references for oldCol to newCol for (int j = 0; j < fields.length; j++) { // Find a class of Type DBColumn or DBTableColumn Class<?> type = fields[j].getType(); if (type == colClass || type == colBase) { try { // Check if the field points to the old Value if (fields[j].get(clone) == srcCol) fields[j].set(clone, newCol); } catch (Exception e) { // IllegalAccessException or IllegalArgumentException String fieldName = fields[j].getName(); log.error(""Cannot adjust declared table field: "" + fieldName + "". Reason is: "" + e.getMessage()); // throw CloneNotSupportedException CloneNotSupportedException cnse = new CloneNotSupportedException(""Unable to replace field reference for field "" + fieldName); cnse.initCause(e); throw cnse; } } } } // set new alias clone.alias = ""t"" + String.valueOf(tableCount.incrementAndGet()); // done log.info(""clone: Table "" + name + "" cloned! Alias old="" + alias + "" new="" + clone.alias); return clone; } catch (CloneNotSupportedException e) { // unable to clone table log.error(""Unable to clone table "" + getName()); throw new RuntimeException(e); } }"	"    @Override
    public Object clone()
    {
        try
        {
            DBTable clone = (DBTable) super.clone();
            // clone all columns
            Class<?> colClass = columns.get(0).getClass();
            Class<?> colBase = colClass.getSuperclass();
            clone.columns = new ArrayList<DBColumn>();
            Field[] fields = getClass().getDeclaredFields();
            for (int i = 0; i < columns.size(); i++)
            {
                DBTableColumn srcCol = (DBTableColumn) columns.get(i);
                DBTableColumn newCol = new DBTableColumn(clone, srcCol);
                // Replace all references for oldCol to newCol
                for (int j = 0; j < fields.length; j++)
                { // Find a class of Type DBColumn or DBTableColumn
                    Class<?> type = fields[j].getType();
                    if (type == colClass || type == colBase)
                    {
                        try
                        {
                            // Check if the field points to the old Value
                            if (fields[j].get(clone) == srcCol)
                                fields[j].set(clone, newCol);
                        } catch (Exception e)
                        {
                            // IllegalAccessException or IllegalArgumentException
                            log.error(""clone: Cannot clone table-member: "" + fields[j].getName() + ""-->"" + e.getMessage());
                        }
                    }
                }
            }
            // set new alias
            clone.alias = ""t"" + String.valueOf(tableCount.incrementAndGet());
            // done
            log.info(""clone: Table "" + name + "" cloned! Alias old="" + alias + "" new="" + clone.alias);
            return clone;
        } catch (CloneNotSupportedException e)
        {
            return null;
        }
    }
"	Clones this table and assigns a new table alias.	Clones this object.	1	0	17	50	367
private static CoreMap fromProto(CoreNLPProtos.Sentence proto) { CoreMap sentence = new ArrayCoreMap(); // Required fields sentence.set(TokenBeginAnnotation.class, proto.getTokenOffsetBegin()); sentence.set(TokenEndAnnotation.class, proto.getTokenOffsetEnd()); // Optional fields if (proto.hasSentenceIndex()) { sentence.set(SentenceIndexAnnotation.class, proto.getSentenceIndex()); } if (proto.hasCharacterOffsetBegin()) { sentence.set(CharacterOffsetBeginAnnotation.class, proto.getCharacterOffsetBegin()); } if (proto.hasCharacterOffsetEnd()) { sentence.set(CharacterOffsetEndAnnotation.class, proto.getCharacterOffsetEnd()); } if (proto.hasParseTree()) { sentence.set(TreeAnnotation.class, fromProto(proto.getParseTree())); } // Non-default fields if (proto.hasHasRelationAnnotations() && proto.getHasRelationAnnotations()) { // set entities List<EntityMention> entities = new ArrayList<EntityMention>(); for (CoreNLPProtos.Entity entity : proto.getEntityList()) { entities.add(fromProto(entity, sentence)); } sentence.set(EntityMentionsAnnotation.class, entities); // set relations List<RelationMention> relations = new ArrayList<RelationMention>(); for (CoreNLPProtos.Relation relation : proto.getRelationList()) { relations.add(fromProto(relation, sentence)); } sentence.set(RelationMentionsAnnotation.class, relations); } // Return return sentence; }	"  protected CoreLabel fromProto(CoreNLPProtos.Token proto) {
    CoreLabel word = new CoreLabel();
    // Required fields
    word.setWord(proto.getWord());
    // Optional fields
    if (proto.hasPos()) { word.setTag(proto.getPos()); }
    if (proto.hasValue()) { word.setValue(proto.getValue()); }
    if (proto.hasCategory()) { word.setCategory(proto.getCategory()); }
    if (proto.hasBefore()) { word.setBefore(proto.getBefore()); }
    if (proto.hasAfter()) { word.setAfter(proto.getAfter()); }
    if (proto.hasOriginalText()) { word.setOriginalText(proto.getOriginalText()); }
    if (proto.hasNer()) { word.setNER(proto.getNer()); }
    if (proto.hasLemma()) { word.setLemma(proto.getLemma()); }
    if (proto.hasBeginChar()) { word.setBeginPosition(proto.getBeginChar()); }
    if (proto.hasEndChar()) { word.setEndPosition(proto.getEndChar()); }
    if (proto.hasSpeaker()) { word.set(SpeakerAnnotation.class, proto.getSpeaker()); }
    if (proto.hasUtterance()) { word.set(UtteranceAnnotation.class, proto.getUtterance()); }
    if (proto.hasBeginIndex()) { word.set(BeginIndexAnnotation.class, proto.getBeginIndex()); }
    if (proto.hasEndIndex()) { word.set(EndIndexAnnotation.class, proto.getEndIndex()); }
    if (proto.hasTokenBeginIndex()) { word.set(TokenBeginAnnotation.class, proto.getTokenBeginIndex()); }
    if (proto.hasTokenEndIndex()) { word.set(TokenEndAnnotation.class, proto.getTokenEndIndex()); }
    if (proto.hasNormalizedNER()) { word.set(NormalizedNamedEntityTagAnnotation.class, proto.getNormalizedNER()); }
    if (proto.hasTimexValue()) { word.set(TimexAnnotation.class, fromProto(proto.getTimexValue())); }
    if (proto.hasHasXmlContext() && proto.getHasXmlContext()) { word.set(XmlContextAnnotation.class, proto.getXmlContextList()); }
    if (proto.hasCorefClusterID()) { word.set(CorefClusterIdAnnotation.class, proto.getCorefClusterID()); }
    if (proto.hasAnswer()) { word.set(AnswerAnnotation.class, proto.getAnswer()); }
    // Non-default annotators
    if (proto.hasGender()) { word.set(GenderAnnotation.class, proto.getGender()); }
    if (proto.hasTrueCase()) { word.set(TrueCaseAnnotation.class, proto.getTrueCase()); }
    if (proto.hasTrueCaseText()) { word.set(TrueCaseTextAnnotation.class, proto.getTrueCaseText()); }
    // Return
    return word;
  }
"	Create a CoreMap representing a sentence from this protocol buffer.	Create a CoreLabel from its serialized counterpart.	1	0	10	25	256
public String getOperator() { return name().toLowerCase(Locale.ROOT); }	"		public String getOperator() {
			return name().toLowerCase();
		}
"	The corresponding SQL operator	The corresponding SQL operator	0	1	6	4	17
"public boolean executeJavaScript(final By by, boolean click){ if(by instanceof By.Id){ return executeJavaScriptFunction(""id(\""""+by.getValue()+""\"", \"""" + String.valueOf(click) + ""\"");""); } else if(by instanceof By.Xpath){ return executeJavaScriptFunction(""xpath(\""""+by.getValue()+""\"", \"""" + String.valueOf(click) + ""\"");""); } else if(by instanceof By.CssSelector){ return executeJavaScriptFunction(""cssSelector(\""""+by.getValue()+""\"", \"""" + String.valueOf(click) + ""\"");""); } else if(by instanceof By.Name){ return executeJavaScriptFunction(""name(\""""+by.getValue()+""\"", \"""" + String.valueOf(click) + ""\"");""); } else if(by instanceof By.ClassName){ return executeJavaScriptFunction(""className(\""""+by.getValue()+""\"", \"""" + String.valueOf(click) + ""\"");""); } else if(by instanceof By.Text){ return executeJavaScriptFunction(""textContent(\""""+by.getValue()+""\"", \"""" + String.valueOf(click) + ""\"");""); } else if(by instanceof By.TagName){ return executeJavaScriptFunction(""tagName(\""""+by.getValue()+""\"", \"""" + String.valueOf(click) + ""\"");""); } return false; }"	"	private boolean executeJavaScript(final By by){
		if(by instanceof By.Id){
			return executeJavaScriptFunction(""id(\""""+by.getValue()+""\"");"");
		}
		else if(by instanceof By.Xpath){
			return executeJavaScriptFunction(""xpath(\""""+by.getValue()+""\"");"");
		}
		else if(by instanceof By.CssSelector){
			return executeJavaScriptFunction(""cssSelector(\""""+by.getValue()+""\"");"");
		}
		else if(by instanceof By.Name){
			return executeJavaScriptFunction(""name(\""""+by.getValue()+""\"");"");
		}
		else if(by instanceof By.ClassName){
			return executeJavaScriptFunction(""className(\""""+by.getValue()+""\"");"");
		}
		else if(by instanceof By.Text){
			return executeJavaScriptFunction(""textContent(\""""+by.getValue()+""\"");"");
		}
		else if(by instanceof By.TagName){
			return executeJavaScriptFunction(""tagName(\""""+by.getValue()+""\"");"");
		}
		return false;
	}
"	Executes JavaScript determined by the given By object	Executes JavaScript determined by the given By object	0	1	17	25	344
"private GridHubConfiguration getHubConfiguration() throws Exception { String hubApi = ""http://"" + registrationRequest.getConfiguration().getHubHost() + "":"" + registrationRequest.getConfiguration().getHubPort() + ""/grid/api/hub""; URL api = new URL(hubApi); HttpClient client = httpClientFactory.createClient(api); String url = api.toExternalForm(); HttpRequest request = new HttpRequest(GET, url); HttpResponse response = client.execute(request); try (Reader reader = new StringReader(response.getContentString()); JsonInput jsonInput = new Json().newInput(reader)) { return StandaloneConfiguration.loadFromJson(jsonInput, GridHubConfiguration.class); } }"	"  private GridHubConfiguration getHubConfiguration() throws Exception {
    String hubApi =
      ""http://"" + registrationRequest.getConfiguration().getHubHost() + "":""
      + registrationRequest.getConfiguration().getHubPort() + ""/grid/api/hub"";

    URL api = new URL(hubApi);
    HttpClient client = httpClientFactory.createClient(api);
    String url = api.toExternalForm();
    HttpRequest request = new HttpRequest(GET, url);

    HttpResponse response = client.execute(request);
    return GridHubConfiguration.loadFromJSON(extractObject(response));
  }
"	uses the hub API to get some of its configuration.	uses the hub API to get some of its configuration.	0	1	10	17	124
public byte get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }	"    public byte get(WithAttributes attributes) {
        return attributes.getAttributes().get(this);
    }
"	Extracts the attribute map from the specified  WithAttributes and returns the value of this attribute from the map.	Analogous to #get(WithAttributes) except returning a primitive byte.	1	0	6	5	19
@Override public Object put(Object value) { return put(value, false); }	"	@Override
	public Object put(Object value) {
		return put(null, value);
	}
"	encode = false	encode = true	1	0	5	6	19
public static Configuration from(Map<String, String> properties) { Map<String, String> props = new HashMap<>(); if (properties != null) props.putAll(properties); return new Configuration() { @Override public String getString(String key) { return properties.get(key); } @Override public Set<String> keys() { return properties.keySet(); } @Override public String toString() { return props.toString(); } }; }	"    public static Configuration from(Properties properties) {
        Properties props = new Properties();
        if (properties != null) props.putAll(properties);
        return new Configuration() {
            @Override
            public String getString(String key) {
                return properties.getProperty(key);
            }

            @Override
            public Set<String> keys() {
                return properties.stringPropertyNames();
            }
            
            @Override
            public String toString() {
                return props.toString();
            }
        };
    }
"	Obtain a configuration instance by copying the supplied map of string keys and string values.	Obtain a configuration instance by copying the supplied Properties object.	1	0	8	21	92
public int getRowStatus(int aRow) throws IndexOutOfBoundsException { RowData row = this.getRow(aRow); if (row.isNew()) { return RowData.NEW; } else if (row.isModified()) { return RowData.MODIFIED; } else { return RowData.NOT_MODIFIED; } }	"	public Integer getRowStatus(int aRow)
		throws IndexOutOfBoundsException
	{
		RowData row = this.getRow(aRow);
		if (row.isOriginal())
		{
			return ROW_ORIGINAL;
		}
		else if (row.isNew())
		{
			return ROW_NEW;
		}
		else if (row.isModified())
		{
			return ROW_MODIFIED;
		}
		else
		{
			return ROW_ORIGINAL;
		}
	}
"	Return the status value for the given row.	Return the status object for the given row.	1	0	7	19	53
public File getGeneratedOutput() throws CurnException { return null; }	"    public InputStream getGeneratedOutput()
        throws CurnException
    {
        return null;
    }
"	Get the File that represents the output produced by the handler, if applicable.	Get an InputStream that can be used to read the output data produced by the handler, if applicable.	1	0	4	7	12
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 8: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 48: break; case 19: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 49: break; case 45: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; // try to work around an apparent jflex bug where it // gets a space at the token end by getting // wrong the length of the trailing context. while (yylength() > 0) { char last = yycharat(yylength()-1); if (last == ' ' || last == '\t' || (last >= '\n' && last <= '\r' || last == '\u0085')) { yypushback(1); } else { break; } } if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 50: break; case 15: { return handleQuotes(yytext(), false); } case 51: break; case 30: // lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), false); } case 52: break; case 42: // lookahead expression with fixed lookahead length yypushback(1); { return getNormalizedAmpNext(); } case 53: break; case 29: { return getNormalizedAmpNext(); } case 54: break; case 46: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 4; { return getNext(); } case 55: break; case 40: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 3; { return getNext(); } case 56: break; case 37: // lookahead expression with fixed lookahead length yypushback(2); { return getNext(); } case 57: break; case 4: { return getNext(); } case 58: break; case 21: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(); } case 59: break; case 34: // general lookahead, find correct zzMarkedPos { int zzFState = 11; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 12; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 60: break; case 35: // general lookahead, find correct zzMarkedPos { int zzFState = 13; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 12; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 61: break; case 44: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } return getNext(txt, yytext()); } case 62: break; case 47: { String txt = yytext(); if (normalizeSpace) { txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 63: break; case 6: { if (normalizeOtherBrackets) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 64: break; case 7: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 65: break; case 27: // general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 66: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 67: break; case 41: { yypushback(2) ; return getNext(); } case 68: break; case 32: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space } return getNext(txt, yytext()); } case 69: break; case 24: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 70: break; case 18: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 71: break; case 43: { yypushback(3) ; return getNext(); } case 72: break; case 22: // lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), true); } case 73: break; case 2: { if (normalizeOtherBrackets) { return getNext(openparen, yytext()); } else { return getNext(); } } case 74: break; case 23: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space } return getNext(txt, origTxt); } case 75: break; case 33: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 76: break; case 20: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 77: break; case 17: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 78: break; case 11: { return handleEllipsis(yytext()); } case 79: break; case 31: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 1; { /* invert quote - often but not always right */ return handleQuotes(yytext(), true); } case 80: break; case 13: { return normalizeFractions(yytext()); } case 81: break; case 14: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(); } } case 82: break; case 38: // general lookahead, find correct zzMarkedPos { int zzFState = 9; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 10; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 83: break; case 10: { if (invertible) { prevWordAfter.append(yytext()); } } case 84: break; case 3: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 85: break; case 39: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 86: break; case 12: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 87: break; case 26: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 88: break; case 9: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 89: break; case 28: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 90: break; case 25: { // this one should only match if we're basically at the end of file // since the last one matches two things, even newlines String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 91: break; case 1: { String str = yytext(); int first = str.charAt(0); String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } LOGGER.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: LOGGER.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 92: break; case 36: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 93: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 94: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(AfterAnnotation.class, str); } return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }"	"  public Object next() throws java.io.IOException {
    int zzInput;
    int zzAction;

    // cached fields:
    int zzCurrentPosL;
    int zzMarkedPosL;
    int zzEndReadL = zzEndRead;
    char [] zzBufferL = zzBuffer;
    char [] zzCMapL = ZZ_CMAP;

    int [] zzTransL = ZZ_TRANS;
    int [] zzRowMapL = ZZ_ROWMAP;
    int [] zzAttrL = ZZ_ATTRIBUTE;

    while (true) {
      zzMarkedPosL = zzMarkedPos;

      yychar+= zzMarkedPosL-zzStartRead;

      zzAction = -1;

      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
  
      zzState = ZZ_LEXSTATE[zzLexicalState];


      zzForAction: {
        while (true) {
    
          if (zzCurrentPosL < zzEndReadL)
            zzInput = zzBufferL[zzCurrentPosL++];
          else if (zzAtEOF) {
            zzInput = YYEOF;
            break zzForAction;
          }
          else {
            // store back cached positions
            zzCurrentPos  = zzCurrentPosL;
            zzMarkedPos   = zzMarkedPosL;
            boolean eof = zzRefill();
            // get translated positions and possibly new buffer
            zzCurrentPosL  = zzCurrentPos;
            zzMarkedPosL   = zzMarkedPos;
            zzBufferL      = zzBuffer;
            zzEndReadL     = zzEndRead;
            if (eof) {
              zzInput = YYEOF;
              break zzForAction;
            }
            else {
              zzInput = zzBufferL[zzCurrentPosL++];
            }
          }
          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
          if (zzNext == -1) break zzForAction;
          zzState = zzNext;

          int zzAttributes = zzAttrL[zzState];
          if ( (zzAttributes & 1) == 1 ) {
            zzAction = zzState;
            zzMarkedPosL = zzCurrentPosL;
            if ( (zzAttributes & 8) == 8 ) break zzForAction;
          }

        }
      }

      // store back cached position
      zzMarkedPos = zzMarkedPosL;

      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
        case 23: 
          { final String origTxt = yytext();
			  String txt = origTxt;
       			  if (normalizeSpace) {
			    txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
			  }
                          return getNext(txt, origTxt);
          }
        case 45: break;
        case 31: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 1;
          { /* invert quote - often but not always right */
		  return handleQuotes(yytext(), true);
          }
        case 46: break;
        case 8: 
          { if (ptb3Dashes) {
                            return getNext(ptbmdash, yytext()); }
                          else {
                            return getNext();
                          }
          }
        case 47: break;
        case 19: 
          { if (escapeForwardSlashAsterisk) {
                    return getNext(delimit(yytext(), '*'), yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 48: break;
        case 38: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 9;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 10;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { String s;
                          if (strictTreebank3 && ! ""U.S."".equals(yytext())) {
                            yypushback(1); // return a period for next time
                            s = yytext();
                          } else {
                            s = yytext();
                            yypushback(1); // return a period for next time
                          }
	                  return getNext(s, yytext());
          }
        case 49: break;
        case 15: 
          { return handleQuotes(yytext(), false);
          }
        case 50: break;
        case 30: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return handleQuotes(yytext(), false);
          }
        case 51: break;
        case 12: 
          { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {
	            return getNext(ptbmdash, yytext());
                  } else {
                    return getNext();
		  }
          }
        case 52: break;
        case 40: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return getNormalizedAmpNext();
          }
        case 53: break;
        case 29: 
          { return getNormalizedAmpNext();
          }
        case 54: break;
        case 37: 
          // lookahead expression with fixed lookahead length
          yypushback(2);
          { return getNext();
          }
        case 55: break;
        case 4: 
          { return getNext();
          }
        case 56: break;
        case 21: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return getNext();
          }
        case 57: break;
        case 34: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 11;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 12;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { return getNext();
          }
        case 58: break;
        case 35: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 13;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 12;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { return getNext();
          }
        case 59: break;
        case 42: 
          { String txt = yytext();
                          if (escapeForwardSlashAsterisk) {
                            txt = delimit(txt, '/');
                          }
                          return getNext(txt, yytext());
          }
        case 60: break;
        case 6: 
          { if (normalizeOtherBrackets) {
                    return getNext(closeparen, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 61: break;
        case 27: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 3;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 4;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { final String origTxt = yytext();
                          String tmp = removeSoftHyphens(origTxt);
                          if (americanize) {
                            tmp = Americanize.americanize(tmp);
                          }
                          return getNext(tmp, origTxt);
          }
        case 62: break;
        case 16: 
          { if (normalizeOtherBrackets) {
                    return getNext(closebrace, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 63: break;
        case 32: 
          { String txt = yytext();
                  if (escapeForwardSlashAsterisk) {
                    txt = delimit(txt, '/');
                  }
                  if (normalizeSpace) {
                    txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                  }
                  return getNext(txt, yytext());
          }
        case 64: break;
        case 24: 
          { if (escapeForwardSlashAsterisk) {
                            return getNext(delimit(yytext(), '/'), yytext());
                          } else {
                            return getNext();
                          }
          }
        case 65: break;
        case 44: 
          { String txt = yytext();
			  if (normalizeSpace) {
			    txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
			  }
			  if (normalizeParentheses) {
			    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
			    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
			  }
			  return getNext(txt, yytext());
          }
        case 66: break;
        case 18: 
          { if (normalizeParentheses) {
                    return getNext(closeparen, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 67: break;
        case 41: 
          { yypushback(3) ; return getNext();
          }
        case 68: break;
        case 22: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return handleQuotes(yytext(), true);
          }
        case 69: break;
        case 2: 
          { if (normalizeOtherBrackets) {
                    return getNext(openparen, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 70: break;
        case 33: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 5;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 6;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { final String txt = yytext();
                          return getNext(removeSoftHyphens(txt),
                                         txt);
          }
        case 71: break;
        case 20: 
          { if (normalizeOtherBrackets) {
                    return getNext(openbrace, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 72: break;
        case 25: 
          { // this one should only match if we're basically at the end of file
			  // since the last one matches two things, even newlines
                          String s;
                          if (strictTreebank3 && ! ""U.S."".equals(yytext())) {
                            yypushback(1); // return a period for next time
                            s = yytext();
                          } else {
                            s = yytext();
                            yypushback(1); // return a period for next time
                          }
	                  return getNext(s, yytext());
          }
        case 73: break;
        case 43: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 7;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 8;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { String s;
                          // try to work around an apparent jflex bug where it
                          // gets a space at the token end by getting
                          // wrong the length of the trailing context.
                          while (yylength() > 0) {
			    char last = yycharat(yylength()-1);
			    if (last == ' ' || last == '\t') {
                              yypushback(1);
                            } else {
                              break;
                            }
                          }
                          if (strictTreebank3 && ! ""U.S."".equals(yytext())) {
                            yypushback(1); // return a period for next time
                            s = yytext();
                          } else {
                            s = yytext();
                            yypushback(1); // return a period for next time
                          }
                          return getNext(s, yytext());
          }
        case 74: break;
        case 17: 
          { if (normalizeParentheses) {
                    return getNext(openparen, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 75: break;
        case 11: 
          { return handleEllipsis(yytext());
          }
        case 76: break;
        case 13: 
          { return normalizeFractions(yytext());
          }
        case 77: break;
        case 14: 
          { if (normalizeCurrency) {
                            return getNext(normalizeCurrency(yytext()), yytext()); }
                          else {
                            return getNext();
                          }
          }
        case 78: break;
        case 10: 
          { if (invertible) {
                     prevWordAfter.append(yytext());
                  }
          }
        case 79: break;
        case 3: 
          { if (escapeForwardSlashAsterisk) {
                    return getNext(delimit(yytext(), '/'), yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 80: break;
        case 39: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return getNext(removeSoftHyphens(yytext()),
                                               yytext());
          }
        case 81: break;
        case 26: 
          { return getNext(removeSoftHyphens(yytext()), yytext());
          }
        case 82: break;
        case 7: 
          { final String origTxt = yytext();
			  String tmp = removeSoftHyphens(origTxt);
                          if (americanize) {
                            tmp = Americanize.americanize(tmp);
                          }
                          return getNext(tmp, origTxt);
          }
        case 83: break;
        case 9: 
          { return getNext(removeSoftHyphens(yytext()),
                                         yytext());
          }
        case 84: break;
        case 28: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return getNext(removeSoftHyphens(yytext()),
                                         yytext());
          }
        case 85: break;
        case 1: 
          { String str = yytext();
          int first = str.charAt(0);
          String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));
          switch (untokenizable) {
            case NONE_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              break;
            case FIRST_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              if ( ! this.seenUntokenizableCharacter) {
                LOGGER.warning(msg);
                this.seenUntokenizableCharacter = true;
              }
              break;
            case ALL_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              LOGGER.warning(msg);
              this.seenUntokenizableCharacter = true;
              break;
            case NONE_KEEP:
              return getNext();
            case FIRST_KEEP:
              if ( ! this.seenUntokenizableCharacter) {
                LOGGER.warning(msg);
                this.seenUntokenizableCharacter = true;
              }
              return getNext();
            case ALL_KEEP:
              LOGGER.warning(msg);
              this.seenUntokenizableCharacter = true;
              return getNext();
          }
          }
        case 86: break;
        case 36: 
          { String txt = yytext();
                          if (escapeForwardSlashAsterisk) {
                            txt = delimit(txt, '/');
                            txt = delimit(txt, '*');
                          }
                          return getNext(txt, yytext());
          }
        case 87: break;
        case 5: 
          { if (tokenizeNLs) {
                      return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns
                  } else if (invertible) {
                      prevWordAfter.append(yytext());
                  }
          }
        case 88: break;
        default: 
          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
            zzAtEOF = true;
              {
                if (invertible) { 
            prevWordAfter.append(yytext()); 
            String str = prevWordAfter.toString();
            prevWordAfter.setLength(0);
            prevWord.set(AfterAnnotation.class, str);
          }
          return null;
              }
          } 
          else {
            zzScanError(ZZ_NO_MATCH);
          }
      }
    }
  }
"	Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.	Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.	0	1	17	593	3467
public boolean isBatchFull() { return processedRecordCount >= HiveDefaultRecordReader.TARGET_RECORD_COUNT; }	"  public boolean isBatchFull() {
    return processedRecordCount >= HiveAbstractReader.TARGET_RECORD_COUNT;
  }
"	Checks if current number of processed records does not exceed max batch size.	Checks if current number of processed records does not exceed max batch size.	0	1	5	4	12
public Map<String, String> populateImplicitColumns(String filePath, List<String> partitionValues, boolean includeFileImplicitColumns) { Map<String, String> implicitValues = new LinkedHashMap<>(); for (int i = 0; i < partitionValues.size(); i++) { if (isStarQuery || selectedPartitionColumns.contains(i)) { implicitValues.put(partitionDesignator + i, partitionValues.get(i)); } } if (includeFileImplicitColumns) { Path path = Path.getPathWithoutSchemeAndAuthority(new Path(filePath)); for (Map.Entry<String, ImplicitFileColumns> entry : selectedImplicitColumns.entrySet()) { implicitValues.put(entry.getKey(), entry.getValue().getValue(path)); } } return implicitValues; }	"  public Map<String, String> populateImplicitColumns(FileWork work, String selectionRoot) {
    return populateImplicitColumns(work.getPath(), selectionRoot);
  }
"	Creates map with implicit columns where key is column name, value is columns actual value.	Compares selection root and actual file path to determine partition columns values.	1	0	11	22	129
"private StreamEvent findIfActualMax(AttributeDetails latestEvent) { int indexCurrentMax = valueStack.indexOf(currentMax); int postBound = valueStack.indexOf(latestEvent) - indexCurrentMax; // If latest event is at a distance greater than maxPostBound from max, max is not eligible to be sent as output if (postBound > maxPostBound) { currentMax.notEligibleForRealMax(); return null; } // If maxPreBound is 0, no need to check preBoundChange. Send output with postBound value if (maxPreBound == 0) { StreamEvent outputEvent = eventStack.get(indexCurrentMax); complexEventPopulater.populateComplexEvent(outputEvent, new Object[] { ""max"", 0, postBound }); currentMax.sentOutputAsRealMax(); return outputEvent; } int preBound = 1; double dThreshold = currentMax.getValue() - currentMax.getValue() * preBoundChange / 100; while (preBound <= maxPreBound && indexCurrentMax - preBound >= 0) { if (valueStack.get(indexCurrentMax - preBound).getValue() <= dThreshold) { StreamEvent outputEvent = eventStack.get(indexCurrentMax); complexEventPopulater.populateComplexEvent(outputEvent, new Object[] { ""max"", preBound, postBound }); currentMax.sentOutputAsRealMax(); return outputEvent; } ++preBound; } // Completed iterating through maxPreBound older events. No events which satisfy preBoundChange condition found. // Therefore max is not eligible to be sent as output. currentMax.notEligibleForRealMax(); return null; }"	"    private StreamEvent findIfActualMax(attributeDetails latestEvent) {
        int indexCurrentMax = valueStack.indexOf(currentMax);
        int actual_L = valueStack.indexOf(latestEvent) - indexCurrentMax;
        // If latest event is at a distance greater than L from max, max is not eligible to be sent as output
        if (actual_L > L) {
            currentMax.notEligibleForRealMax();
            return null;
        }
        int actual_l = 1;
        double dThreshold = currentMax.getValue() - currentMax.getValue() * d / 100;
        while (actual_l <= l && indexCurrentMax - actual_l >= 0) {
            if (valueStack.get(indexCurrentMax - actual_l).getValue() <= dThreshold) {
                StreamEvent outputEvent = eventStack.get(indexCurrentMax);
                complexEventPopulater.populateComplexEvent(outputEvent, new Object[] { ""max"", actual_l, actual_L });
                currentMax.sentOutputAsRealMax();
                return outputEvent;
            }
            ++actual_l;
        }
        // Completed iterating through l older events. No events which satisfy d condition found.
        // Therefore max is not eligible to be sent as output.
        currentMax.notEligibleForRealMax();
        return null;
    }
"	Method to find whether a value preBoundChange% less than or equal to max exists within maxPreBound length window, by looping through older events.	Method to find whether a value d% less than or equal to max exists within l length window, by looping through older events.	1	0	11	33	250
"public PayloadBuilder resizeAlertBody(int payloadLength) { return resizeAlertBody(payloadLength, """"); }"	"    public PayloadBuilder resizeAlertBody(int payloadLength) {
        int currLength = length();
        if (currLength < payloadLength)
            return this;

        int d = currLength - payloadLength;
        String body = (String)aps.get(""alert"");

        if (body.length() < d)
            aps.remove(""alert"");
        else
            aps.put(""alert"", body.subSequence(0, body.length() - d));

        return this;
    }
"	Shrinks the alert message body so that the resulting payload message fits within the passed expected payload length.	Shrinks the alert message body so that the resulting payload message fits within the passed expected payload length.	0	1	5	4	18
private ZapTextField getTxtReverseProxyHttpsPort() { if (txtReverseProxyHttpsPort == null) { txtReverseProxyHttpsPort = new ZapTextField(); } return txtReverseProxyHttpsPort; }	"	private JTextField getTxtReverseProxyHttpsPort() {
		if (txtReverseProxyHttpsPort == null) {
			txtReverseProxyHttpsPort = new JTextField();
		}
		return txtReverseProxyHttpsPort;
	}
"	This method initializes ZapTextField	This method initializes jTextField	1	0	8	7	23
public Single<ModelApiResponse> rxUploadFileWithRequiredFile(Long petId, AsyncFile requiredFile, String additionalMetadata) { return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> { delegate.uploadFileWithRequiredFile(petId, requiredFile, additionalMetadata, fut); })); }	"    public Single<ModelApiResponse> rxUploadFileWithRequiredFile(Long petId, AsyncFile file, String additionalMetadata) {
        return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> {
            delegate.uploadFileWithRequiredFile(petId, file, additionalMetadata, fut);
        }));
    }
"	uploads an image (required)	uploads an image (required)	0	1	10	6	46
public YearMonth addWrapFieldToCopy(int valueToAdd) { int[] newValues = iBase.getValues(); newValues = getField().addWrapField(iBase, iFieldIndex, newValues, valueToAdd); return new YearMonth(iBase, newValues); }	"        public YearMonth addWrapFieldToCopy(int valueToAdd) {
            int[] newValues = iYearMonth.getValues();
            newValues = getField().addWrapField(iYearMonth, iFieldIndex, newValues, valueToAdd);
            return new YearMonth(iYearMonth, newValues);
        }
"	Adds to the value of this field in a copy of this YearMonth wrapping within this field if the maximum value is reached.	Adds to the value of this field in a copy of this YearMonth wrapping within this field if the maximum value is reached.	0	1	7	6	42
private PendingIntent getGeofencePendingIntent() { // Reuse the PendingIntent if we already have it. if (mGeofencePendingIntent != null) { return mGeofencePendingIntent; } Intent intent = new Intent(this, GeofenceBroadcastReceiver.class); // We use FLAG_UPDATE_CURRENT so that we get the same pending intent back when calling // addGeofences() and removeGeofences(). mGeofencePendingIntent = PendingIntent.getBroadcast(this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT); return mGeofencePendingIntent; }	"    private PendingIntent getGeofencePendingIntent() {
        // Reuse the PendingIntent if we already have it.
        if (mGeofencePendingIntent != null) {
            return mGeofencePendingIntent;
        }
        Intent intent = new Intent(this, GeofenceTransitionsIntentService.class);
        // We use FLAG_UPDATE_CURRENT so that we get the same pending intent back when calling
        // addGeofences() and removeGeofences().
        return PendingIntent.getService(this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);
    }
"	Gets a PendingIntent to send with the request to add or remove Geofences.	Gets a PendingIntent to send with the request to add or remove Geofences.	0	1	7	12	81
public MutableDirectBuffer buffer() { return mutableDirectBuffer; }	"    public ClientProtocolBuffer buffer() {
        return protocolBuffer;
    }
"	The  MutableDirectBuffer that encapsulates the internal buffer.	The ClientProtocolBuffer that encapsulates the internal buffer.	1	0	4	5	10
public IntervalConverter removeIntervalConverter(IntervalConverter converter) throws SecurityException { checkAlterIntervalConverters(); if (converter == null) { return null; } IntervalConverter[] removed = new IntervalConverter[1]; iIntervalConverters = iIntervalConverters.remove(converter, removed); return removed[0]; }	"    public IntervalConverter removeIntervalConverter(int index) throws SecurityException {
        checkAlterIntervalConverters();
        IntervalConverter[] removed = new IntervalConverter[1];
        iIntervalConverters = iIntervalConverters.remove(index, removed);
        return removed[0];
    }
"	Removes a converter from the set of converters.	Removes a converter from the set of converters, by index.	1	0	6	12	50
public int getReadTimeout() { return httpClient.readTimeoutMillis(); }	"    public int getReadTimeout() {
        return httpClient.getReadTimeout();
    }
"	Get read timeout (in milliseconds).	Get read timeout (in milliseconds).	0	1	4	4	13
public ArrayList<View> getViews() { try { return ensureArrayListOrNull(viewFetcher.getViews()); } catch (Exception e) { e.printStackTrace(); return null; } }	"	public ArrayList<View> getViews() {
		return ensureArrayListOrNull(viewFetcher.getViews());
	}
"	Returns a  List of the  Views located in the current  Activity.	Returns a List of the Views located in the current Activity.	0	1	6	9	35
public Table removeTable(TableId tableId) { return lock.write(() -> { changes.add(tableId); return tablesByTableId.remove(tableId); }); }	"    public Table removeTable(TableId tableId) {
        return lock.write(() -> tablesByTableId.remove(tableId));
    }
"	Remove the definition of the identified table.	Remove the definition of the identified table.	0	1	8	7	33
"public static MatchFinder allOf(final MatchFinder... finders) { return new MatchFinder() { @Override public boolean matches(UiElement element) { for (MatchFinder finder : finders) { if (!finder.matches(element)) { return false; } } return true; } @Override public String toString() { return ""allOf("" + Joiner.on("","").join(finders) + "")""; } }; }"	"  public static ElementMatcher allOf(final ElementMatcher... matchers) {
    return new ElementMatcher() {
      @Override
      public boolean matches(UiElement element) {
        for (ElementMatcher matcher : matchers) {
          if (!matcher.matches(element)) {
            return false;
          }
        }
        return true;
      }

      @Override
      public String toString() {
        return ""allOf("" + Joiner.on("","").join(matchers) + "")"";
      }
    };
  }
"	Evaluates given @finders in short-circuit fashion in the order they are passed.	Evaluates given @matchers in short-circuit fashion in the order they are passed.	1	0	11	20	87
private void ensureSameType(SqlRexContext cx, final RexNode[] exprs) { RelDataType type = cx.getTypeFactory().leastRestrictive( new AbstractList<RelDataType>() { public RelDataType get(int index) { return exprs[index].getType(); } public int size() { return exprs.length; } }); for (int i = 0; i < exprs.length; i++) { exprs[i] = cx.getRexBuilder().ensureType(type, exprs[i], false); } }	"    private void ensureSameType(SqlRexContext cx, RexNode[] exprs) {
        // TODO: make leastRestrictive take a list
        List<RelDataType> types = new ArrayList<RelDataType>();
        for (RexNode expr : exprs) {
            types.add(expr.getType());
        }
        RelDataType type =
            cx.getTypeFactory().leastRestrictive(
                types.toArray(new RelDataType[types.size()]));
        for (int i = 0; i < exprs.length; i++) {
            exprs[i] = cx.getRexBuilder().ensureType(type, exprs[i], false);
        }
    }
"	Converts a call to an operator into a  RexCall to the same operator.	Converts a call to an operator into a RexCall to the same operator.	0	1	12	16	97
public ArrayList<EditText> getCurrentEditTexts() { return getCurrentViews(EditText.class); }	"	public ArrayList<EditText> getCurrentEditTexts() {
		ArrayList<EditText>editTextList = new ArrayList<EditText>();
		ArrayList<View> viewList = getViews();
		for(View view : viewList){
			if (view instanceof android.widget.EditText)
				editTextList.add((EditText) view);
		}
		return editTextList;	
	}
"	Returns a  List of the  EditTexts contained in the current  Activity.	Returns a List of the EditTexts contained in the current Activity.	0	1	6	4	15
public float get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }	"    public float get(WithAttributes attributes) {
        return attributes.getAttributes().get(this);
    }
"	Extracts the attribute map from the specified  WithAttributes and returns the value of this attribute from the map.	Analogous to #get(WithAttributes) except returning a primitive float.	1	0	6	5	19
public static BinaryResourceFile fromInputStream(InputStream is) throws IOException { byte[] buf = ByteStreams.toByteArray(is); return new BinaryResourceFile(buf); }	"  public static ResourceFile fromInputStream(InputStream is) throws IOException {
    byte[] buf = ByteStreams.toByteArray(is);
    return new ResourceFile(buf);
  }
"	Given an input stream, reads the stream until the end and returns a  BinaryResourceFile representing the contents of the stream.	Given an input stream, reads the stream until the end and returns a ResourceFile representing the contents of the stream.	1	0	6	6	29
public static Tree UCPtransform(Tree t) { if (t == null) { return null; } Tree firstChild = t.firstChild(); if (firstChild != null) { List<Pair<TregexPattern,TsurgeonPattern>> ops = Generics.newArrayList(); for (int i = 0; i < operations.length; i++) { for (TregexPattern pattern : matchPatterns[i]) { ops.add(Generics.newPair(pattern, operations[i])); } } return Tsurgeon.processPatternsOnTree(ops, t); } else { return t; } }	"  public static Tree UCPtransform(Tree t) {
    if (t == null) {
      return null;
    }
    return Tsurgeon.processPattern(ucpRenameTregex, ucpRenameTsurgeon, t);
  }
"	Transforms t if it contains an UCP, it will change the UCP tag into the phrasal tag of the first word of the UCP (UCP (JJ electronic) (, ,) (NN computer) (CC and) (NN building)) will become (ADJP (JJ electronic) (, ,) (NN computer) (CC and) (NN building))	Transforms t if it contains an UCP, it will change the UCP tag into the phrasal tag of the first word of the UCP (UCP (JJ electronic) (, ,) (NN computer) (CC and) (NN building)) will become (ADJP (JJ electronic) (, ,) (NN computer) (CC and) (NN building))	0	1	14	20	104
List<ExtensionState> getExtensions() { return extensions; }	"    List<ExtensionState> getExtensions() {
        return Collections.unmodifiableList(extensions);
    }
"	Gets the extensions' state (as saved in the configuration file).	Gets the extensions' state (as saved in the configuration file).	0	1	5	4	10
public Dictionary getProperties() { return m_properties; }	"    public Properties getProperties() {
        return m_properties;
    }
"	Returns the properties.	Returns the property descriptors	1	0	4	5	10
public String getAuthoringPath() { return this.authoringPath; }	"    public String getAuthoringPath() {
        return authoringPath;
    }
"	Returns the authoring path	DOCUMENT ME!	1	0	5	5	11
protected Object convertDurationToMicroseconds(Column column, Field fieldDefn, Object data) { return convertValue(column, fieldDefn, data, 0L, (r) -> { try { if (data instanceof Duration) { r.deliver(((Duration)data).toNanos() / 1_000); } } catch (IllegalArgumentException e) { } }); }	"    protected Object convertDurationToMicroseconds(Column column, Field fieldDefn, Object data) {
        if (data == null && !fieldDefn.schema().isOptional()) {
            data = fieldDefn.schema().defaultValue();
        }
        if (data == null) {
            if (column.isOptional()) return null;
            return 0L;
        }
        try {
            if (data instanceof Duration) return ((Duration) data).toNanos() / 1_000;
        } catch (IllegalArgumentException e) {
            return handleUnknownData(column, fieldDefn, data);
        }
        return handleUnknownData(column, fieldDefn, data);
    }
"	Converts a value object for an expected type of  java.time.Duration to  Long values that represents the time in microseconds.	Converts a value object for an expected type of java.time.Duration to Long values that represents the time in microseconds.	0	1	13	11	68
"public static Platform extractFromSysProperty(String osName, String osVersion) { osName = osName.toLowerCase(); // os.name for android is linux if (""dalvik"".equalsIgnoreCase(System.getProperty(""java.vm.name""))) { return Platform.ANDROID; } // Windows 8 can't be detected by osName alone if (osVersion.equals(""6.2"") && osName.startsWith(""windows nt"")) { return WIN8; } Platform mostLikely = UNIX; String previousMatch = null; for (Platform os : Platform.values()) { for (String matcher : os.partOfOsName) { if ("""".equals(matcher)) { continue; } matcher = matcher.toLowerCase(); if (os.isExactMatch(osName, matcher)) { return os; } if (os.isCurrentPlatform(osName, matcher) && isBetterMatch(previousMatch, matcher)) { previousMatch = matcher; mostLikely = os; } } } // Default to assuming we're on a UNIX variant (including LINUX) return mostLikely; }"	"  public static Platform extractFromSysProperty(String osName) {
    osName = osName.toLowerCase();
    // os.name for android is linux
    if (""dalvik"".equalsIgnoreCase(System.getProperty(""java.vm.name""))) {
      return Platform.ANDROID;
    }
    Platform mostLikely = UNIX;
    String previousMatch = null;
    for (Platform os : Platform.values()) {
      for (String matcher : os.partOfOsName) {
        if ("""".equals(matcher)) {
          continue;
        }
        matcher = matcher.toLowerCase();
        if (os.isExactMatch(osName, matcher)) {
          return os;
        }
        if (os.isCurrentPlatform(osName, matcher) && isBetterMatch(previousMatch, matcher)) {
          previousMatch = matcher;
          mostLikely = os;
        }
      }
    }

    // Default to assuming we're on a UNIX variant (including LINUX)
    return mostLikely;
  }
"	Extracts platforms based on system properties in Java and uses a heuristic to determine the most likely operating system.	Extracts platforms based on system properties in Java and a heuristic to determine the most likely operating system.	1	0	11	32	198
"public Order placeOrder(Order body) throws ApiException { Object localVarPostBody = body; // verify the required parameter 'body' is set if (body == null) { throw new ApiException(400, ""Missing the required parameter 'body' when calling placeOrder""); } // create path and map variables String localVarPath = ""/store/order""; // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { ""application/xml"", ""application/json"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Order> localVarReturnType = new GenericType<Order>() {}; return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	"  public Order placeOrder(Order body) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, ""Missing the required parameter 'body' when calling placeOrder"");
    }
    
    // create path and map variables
    String localVarPath = ""/store/order"";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    final String[] localVarAccepts = {
      ""application/xml"", ""application/json""
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    GenericType<Order> localVarReturnType = new GenericType<Order>() {};
    return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);
      }
"	Place an order for a pet	Place an order for a pet	0	1	8	36	213
public VisualItem findItem(Point p) { Point2D p2 = (m_itransform==null ? p : m_itransform.transform(p, m_tmpPoint)); synchronized (m_registry) { Iterator items = m_registry.getItemsReversed(); while (items.hasNext()) { VisualItem vi = (VisualItem) items.next(); Renderer r = vi.getRenderer(); if (r != null && r.locatePoint(p2, vi)) { return vi; } } } return null; } //	"	public GraphItem findItem(Point p) {
        Point2D p2 = (m_itransform==null ? p : 
                        m_itransform.transform(p, m_tmpPoint));
		synchronized (m_registry) {
			Iterator items = m_registry.getItemsReversed();
			while (items.hasNext()) {
				GraphItem gi = (GraphItem) items.next();
				Renderer r = gi.getRenderer();
				if (r != null && r.locatePoint(p2, gi)) {
					return gi;
				}
			}
		}
		return null;
	} //
"	Returns the VisualItem located at the given point.	Returns the GraphItem located at the given point.	1	0	9	17	90
public static long nextPowerOfTwo(long value) { if (!isPowerOfTwo(value)) { value--; value |= value >> 1; value |= value >> 2; value |= value >> 4; value |= value >> 8; value |= value >> 16; value |= value >> 32; value++; } return value; }	"    public static long nextPowerOfTwo(final long value) {
        return 1L << (64 - Long.numberOfLeadingZeros(value - 1));
    }
"	Returns the next power of two that is larger than the specified long value.	Fast method of finding the next power of 2 greater than or equal to the supplied value.	1	0	8	15	61
public org.apache.poi.ss.usermodel.Workbook transformXLS(InputStream is, Map beanParams) throws ParsePropertyException, InvalidFormatException { org.apache.poi.ss.usermodel.Workbook hssfWorkbook = null; try { hssfWorkbook = WorkbookFactory.create(is); transformWorkbook(hssfWorkbook, beanParams); } catch (IOException e) { e.printStackTrace(); } return hssfWorkbook; }	"    public HSSFWorkbook transformXLS(InputStream is, Map beanParams) throws ParsePropertyException {
        HSSFWorkbook hssfWorkbook = null;
        try {
            POIFSFileSystem fs = new POIFSFileSystem(is);
            hssfWorkbook = new HSSFWorkbook(fs);
            transformWorkbook(hssfWorkbook, beanParams);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return hssfWorkbook;
    }
"	Creates Workbook instance based on .xls template from a given InputStream and a number of beans	Creates HSSFWorkbook instance based on .xls template from a given InputStream and a number of beans	1	0	9	12	62
"public static PathMetadata<String> forVariable(String variable) { return new PathMetadata<String>(null, Assert.hasLength(variable,""variable""), PathType.VARIABLE); }"	"    public static PathMetadata<String> forVariable(String variable) {
        return new PathMetadata<String>(null, ConstantImpl.create(Assert.hasLength(variable,""variable""), true), PathType.VARIABLE);
    }
"	Create a new PathMetadata for a variable	Create a new PathMetadata for a variable	0	1	7	4	32
public short get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }	"    public short get(WithAttributes attributes) {
        return attributes.getAttributes().get(this);
    }
"	Extracts the attribute map from the specified  WithAttributes and returns the value of this attribute from the map.	Analogous to #get(WithAttributes) except returning a primitive short.	1	0	6	5	19
public boolean isConnected(Integer channelId) { synchronized (wsProxies) { if (wsProxies.containsKey(channelId)) { return wsProxies.get(channelId).isConnected(); } } return false; }	"	public boolean isConnected(HttpMessage handshakeMessage) {
		int historyId = handshakeMessage.getHistoryRef().getHistoryId();
		for (Entry<Integer, WebSocketProxy> entry : wsProxies.entrySet()) {
			WebSocketProxy proxy = entry.getValue();
			if (historyId == proxy.getHandshakeReference().getHistoryId()) {
				return proxy.isConnected();
			}
		}
		return false;
	}
"	Returns true if given channel id is connected.	Returns true if the WebSocket connection that followed the given	1	0	8	9	38
protected Iterable<Object> toIterable(Object result) { return FpKit.toCollection(result); }	"    protected Iterable<Object> toIterable(Object result) {
        if (result.getClass().isArray()) {
            return IntStream.range(0, Array.getLength(result))
                    .mapToObj(i -> Array.get(result, i))
                    .collect(toList());
        }
        return (Iterable<Object>) result;
    }
"	Converts an object that is known to should be an Iterable into one	Converts an object that is known to should be an Iterable into one	0	1	5	4	17
public ChromeDriverService build() { return (ChromeDriverService) super.build(); }	"    public ChromeDriverService build() {
      if (port == 0) {
        port = PortProber.findFreePort();
      }

      checkState(exe != null, ""Path to the chromedriver executable not specified"");

      try {
        return new ChromeDriverService(exe, port, environment, logFile);
      } catch (IOException e) {
        throw new WebDriverException(e);
      }
    }
"	Creates a new binary to manage the chromedriver server.	Creates a new binary to manage the chromedriver server.	0	1	5	4	16
public static boolean isVisibleInExplain(RelNode rel, SqlExplainLevel explainLevel) { final BuiltInMetadata.ExplainVisibility metadata = rel.metadata(BuiltInMetadata.ExplainVisibility.class); Boolean b = metadata.isVisibleInExplain(explainLevel); return b == null || b; }	"  public static boolean isVisibleInExplain(
      RelNode rel,
      SqlExplainLevel explainLevel) {
    Boolean b =
        (Boolean) rel.getCluster().getMetadataProvider().getRelMetadata(
            rel,
            ""isVisibleInExplain"",
            new Object[]{explainLevel});
    if (b == null) {
      return true;
    } else {
      return b;
    }
  }
"	Returns the  BuiltInMetadata.ExplainVisibility#isVisibleInExplain(SqlExplainLevel) statistic.	Determines whether a relational expression should be visible in EXPLAIN	1	0	7	9	40
boolean findCellForSpan(int[] cellXY, int spanX, int spanY) { // return the span represented by the CellInfo only there is no view there // (this.cell == null) and there is enough space if (this.cell == null && this.spanX >= spanX && this.spanY >= spanY) { if (cellXY != null) { cellXY[0] = cellX; cellXY[1] = cellY; } return true; } int startX = 0; if (intersectX >= 0) { startX = Math.max(startX, intersectX - (spanX - 1)); } int endX = mCountX - (spanX - 1); if (intersectX >= 0) { endX = Math.min(endX, intersectX + (spanX - 1)); } int startY = 0; if (intersectY >= 0) { startY = Math.max(startY, intersectY - (spanY - 1)); } int endY = mCountY - (spanY - 1); if (intersectY >= 0) { endY = Math.min(endY, intersectY + (spanY - 1)); } for (int x = startX; x < endX + 1; x++) { inner: for (int y = startY; y < endY; y++) { for (int i = 0; i < spanX; i++) { for (int j = 0; j < spanY; j++) { if (mOccupied[x + i][y + j]) { // small optimization: we can skip to below the row we just found // an occupied cell y += j; continue inner; } } } if (cellXY != null) { cellXY[0] = x; cellXY[1] = y; } return true; } } return false; }	"        boolean findCellForSpan(int[] cellXY, int spanX, int spanY) {
            return findCellForSpan(cellXY, spanX, spanY, true);
        }
"	Finds the upper-left coordinate of the first rectangle in the grid that can hold a cell of the specified dimensions.	This method can be called only once! Calling #findVacantCellsFromOccupied will restore the ability to call this method.	1	0	15	52	333
public DurationType getDurationType(Object object, boolean precise) { ReadableTimePeriod period = (ReadableTimePeriod) object; if (precise) { if (period.getDurationType().isPrecise()) { return period.getDurationType(); } else { return DurationType.getPreciseAllType(); } } return period.getDurationType(); }	"    public DurationType getDurationType(Object object, boolean precise) {
        return DurationType.getPreciseAllType();
    }
"	Selects a suitable duration type for the given object.	Selects a suitable duration type for the given object.	0	1	8	12	58
public final File getGeneratedOutput() throws CurnException { return hasGeneratedOutput() ? outputFile : null; }	"    public final InputStream getGeneratedOutput()
        throws CurnException
    {
        InputStream result = null;

        if (hasGeneratedOutput())
        {
            try
            {
                result = new FileInputStream (outputFile);
            }

            catch (FileNotFoundException ex)
            {
                throw new CurnException (Curn.BUNDLE_NAME,
                                         ""FileOutputHandler.cantReopenFile"",
                                         ""Cannot reopen file \""{0}\""."",
                                         new Object[] {outputFile},
                                         ex);
            }
        }

        return result;
    }
"	Get the File that represents the output produced by the handler, if applicable.	Get an InputStream that can be used to read the output data produced by the handler, if applicable.	1	0	5	7	19
public boolean available() { return 0 < glTextureID; }	"  public boolean available()  {
    return 0 < glTextureID[0];
  }
"	Returns true if the texture has been initialized.	Returns true if the texture has been initialized.	0	1	5	4	11
private int updateRedundancy() { int desiredRedundancy = this.pRegion.getRedundantCopies(); int numBucketHosts = getNumInitializedBuckets(); if (isClosed()) { return numBucketHosts; } int actualRedundancy = numBucketHosts - 1; this.redundancy = actualRedundancy; if (this.redundancySatisfied && numBucketHosts > 0 && actualRedundancy < desiredRedundancy) { incLowRedundancyBucketCount(1); this.redundancySatisfied = false; } else if (!this.redundancySatisfied && numBucketHosts > 0 && actualRedundancy >= desiredRedundancy) { incLowRedundancyBucketCount(-1); this.redundancySatisfied = true; this.redundancyEverSatisfied = true; } return numBucketHosts; }	"  private int updateRedundancy() {
    int numBucketHosts = getNumInitializedBuckets();
    if (!isClosed()) {
      redundancyTracker.updateStatistics(numBucketHosts);
    }
    return numBucketHosts;
  }
"	Determine if there has been a change in redundancy and alter the lowRedundancyBucketCount stat as needed.	Get the current number of bucket hosts and update the redundancy statistics for the region	1	0	9	21	100
private static String literalValue(RexLiteral literal) { Object value = literal.getValue2(); return String.valueOf(value); }	"    private static String literalValue(RexLiteral literal) {
      Object value = literal.getValue2();
      StringBuilder buf = new StringBuilder();
      buf.append(value);
      return buf.toString();
    }
"	Convert the value of a literal to a string.	Convert the value of a literal to a string.	0	1	5	5	24
public static SlantType getSlant(World world, Vector3 position) { TileEntity t = position.getTileEntity(world); if (t != null) { if (t instanceof TileEntityConveyorBelt) { TileEntityConveyorBelt tileEntity = (TileEntityConveyorBelt) t; Vector3 frontCheck = position.clone(); frontCheck.modifyPositionFromSide(tileEntity.getDirection()); Vector3 backCheck = position.clone(); backCheck.modifyPositionFromSide(tileEntity.getDirection().getOpposite()); if (Vector3.add(frontCheck, new Vector3(0, 1, 0)).getBlockID(world) == AssemblyLine.blockConveyorBelt.blockID && Vector3.add(backCheck, new Vector3(0, -1, 0)).getBlockID(world) == AssemblyLine.blockConveyorBelt.blockID) { return SlantType.UP; } else if (Vector3.add(frontCheck, new Vector3(0, -1, 0)).getBlockID(world) == AssemblyLine.blockConveyorBelt.blockID && Vector3.add(backCheck, new Vector3(0, 1, 0)).getBlockID(world) == AssemblyLine.blockConveyorBelt.blockID) { return SlantType.DOWN; } } } return null; }	"	public ForgeDirection getSlant(World world, Vector3 position)
	{
		TileEntity t = position.getTileEntity(world);

		if (t != null)
		{
			if (t instanceof TileEntityConveyorBelt)
			{
				TileEntityConveyorBelt tileEntity = (TileEntityConveyorBelt) t;
				Vector3 highCheck = position.clone();
				highCheck.modifyPositionFromSide(tileEntity.getDirection());
			}
		}

		return ForgeDirection.UNKNOWN;
	}
"	Checks the front and the back position to find any conveyor blocks either higher or lower than this block to determine if it this conveyor block needs to slant.	Is this conveyor belt slanted towards a direction?	1	0	13	26	195
public final ProviderDescriptor getDescriptor() { return mDescriptor; }	"    public final RouteProviderDescriptor getDescriptor() {
        return mDescriptor;
    }
"	Gets the provider's descriptor.	Gets the current route provider descriptor.	1	0	4	5	11
"public static Criterion ilike(String propertyName, Object value) { if ( value == null ) { throw new IllegalArgumentException( ""Comparison value passed to ilike cannot be null"" ); } return ilike( propertyName, value.toString(), MatchMode.EXACT ); }"	"	public static Criterion ilike(String propertyName, Object value) {
		if ( value == null ) {
			throw new IllegalArgumentException( ""Comparison value passed to ilike cannot be null"" );
		}
		return ilike( propertyName, value.toString(), MatchMode.ANYWHERE );
	}
"	"A case-insensitive ""like"", similar to Postgres ilike operator"	"A case-insensitive ""like"", similar to Postgres ilike operator"	0	1	7	7	50
"public String applyClassNamingPolicy(String input) { if (input != null && input.length() > 0) { if (""string"".equalsIgnoreCase(input)) { return ""string""; } String output = input.substring(0, 1).toUpperCase() + input.substring(1); // class name can't have . so if dot exists remove the same output = output.replace(""."", """"); return output; } else { throw new CodeGenerationException(""Error converting input to first letter caps becuase of null or empty input""); } }"	"  public String applyClassNamingPolicy(String input) {
    if (input != null && input.length() > 0) {
      String output = input.substring(0, 1).toUpperCase() + input.substring(1);
      // class name can't have . so if dot exists remove the same
      output = output.replace(""."", """");
      
      return output;
    }
    else {
      throw new CodeGenerationException(""Error converting input to first letter caps becuase of null or empty input"");
    }
  }
"	Converts the first character of the input into upper case .	Converts the first character of the input into upper case .	0	1	9	17	113
private boolean isShareable() { return getRequestScope().getDictionary().isShareable(obj.getClass()); }	"    private boolean isShareable() {
        return getRequestScope().getDictionary().isSharable(obj.getClass());
    }
"	Checks if this persistent resource's underlying entity is shareable.	Checks if this persistent resource's underlying entity is sharable.	1	0	6	5	22
public CometSupport defaultCometSupport(final boolean preferBlocking) { if (!preferBlocking && testClassExists(SERVLET_30)) { if (detectWebSocketPresent().size() > 0) { return new Servlet30CometSupportWithWebSocket(config); } return new Servlet30CometSupport(config); } else { return new BlockingIOCometSupport(config); } }	"    public CometSupport defaultCometSupport(final boolean preferBlocking) {
        if (!preferBlocking && testClassExists(SERVLET_30)) {
            return new Servlet30CometSupport(config);
        } else {
            return new BlockingIOCometSupport(config);
        }
    }
"	This method is used to determine the default CometSupport if all else fails	This method is used to determine the default CometSupport if all else fails	0	1	9	11	59
public int compareTo(IndexedWord w) { if (this.equals(IndexedWord.NO_WORD)) { if (w.equals(IndexedWord.NO_WORD)) { return 0; } else { return -1; } } if (w.equals(IndexedWord.NO_WORD)) { return 1; } // Override the default comparator if pseudo-positions are set. // This is needed for splicing trees together awkwardly in OpenIE. if (!Double.isNaN(w.pseudoPosition) || !Double.isNaN(this.pseudoPosition)) { double val = this.pseudoPosition() - w.pseudoPosition(); if (val < 0) { return -1; } if (val > 0) { return 1; } else { return 0; } } // Otherwise, compare using the normal doc/sentence/token index hierarchy String docID = this.getString(CoreAnnotations.DocIDAnnotation.class); int docComp = docID.compareTo(w.getString(CoreAnnotations.DocIDAnnotation.class)); if (docComp != 0) return docComp; int sentComp = Integer.compare(sentIndex(), w.sentIndex()); if (sentComp != 0) return sentComp; int indexComp = Integer.compare(index(), w.index()); if (indexComp != 0) return indexComp; return Integer.compare(copyCount(), w.copyCount()); }	"  public int compareTo(IndexedWord w) {
    if (this.equals(IndexedWord.NO_WORD)) {
      if (w.equals(IndexedWord.NO_WORD)) {
        return 0;
      } else {
        return -1;
      }
    }
    if (w.equals(IndexedWord.NO_WORD)) {
      return 1;
    }

    // Override the default comparator if pseudo-positions are set.
    // This is needed for splicing trees together awkwardly in OpenIE.
    if (!Double.isNaN(w.pseudoPosition) || !Double.isNaN(this.pseudoPosition)) {
      double val = this.pseudoPosition() - w.pseudoPosition();
      if (val < 0) { return -1; }
      if (val > 0) { return 1; }
      else { return 0; }
    }

    // Otherwise, compare using the normal doc/sentence/token index hierarchy
    String docID = this.getString(CoreAnnotations.DocIDAnnotation.class);
    int docComp = docID.compareTo(w.getString(CoreAnnotations.DocIDAnnotation.class));
    if (docComp != 0) return docComp;

    int sentComp = sentIndex() - w.sentIndex();
    if (sentComp != 0) return sentComp;

    int indexComp = index() - w.index();
    if (indexComp != 0) return indexComp;

    return copyCount() - w.copyCount();
  }
"	NOTE: For this compareTo, you must have a DocIDAnnotation,	NOTE: This compareTo is based on and made to be compatible with the one from IndexedFeatureLabel.	1	0	9	35	249
public boolean hasCorrelation() { return !mapCorToCorRel.isEmpty(); }	"    public boolean hasCorrelation() {
      return !mapCorVarToCorRel.isEmpty();
    }
"	Returns whether there are any correlating variables in this statement.	Returns whether there are any correlating variables in this statement.	0	1	4	4	14
public boolean isEmergencyAlertMessage() { return mSmsCbMessage.isEmergencyMessage(); }	"    public boolean isEmergencyAlertMessage() {
        if (!mSmsCbMessage.isEmergencyMessage()) {
            return false;
        }
        SmsCbCmasInfo cmasInfo = mSmsCbMessage.getCmasWarningInfo();
        if (cmasInfo != null &&
                cmasInfo.getMessageClass() == SmsCbCmasInfo.CMAS_CLASS_CHILD_ABDUCTION_EMERGENCY) {
            return false;
        }
        return true;
    }
"	Returns whether the broadcast is an emergency (PWS) message type, including test messages and AMBER alerts.	Returns whether the broadcast is an emergency (PWS) message type, including test messages, but excluding lower priority Amber alert broadcasts.	1	0	4	5	13
"public static Optional<Add> create(String statement) { Matcher argumentMatcher = ARGUMENT_TOKENIZER.matcher(statement.trim()); if (!argumentMatcher.find()) { return Optional.absent(); } String commandName = argumentMatcher.group(); if (!(StringUtils.equals(commandName, ""ADD"") || StringUtils.equals(commandName, ""COPY""))) { return Optional.absent(); } String lastToken = null; Collection<String> sources = new ArrayList<>(); while (argumentMatcher.find()) { if (lastToken != null) { sources.add(lastToken); } lastToken = argumentMatcher.group().replaceAll(""(^\"")|(\""$)"", """"); } if (sources.isEmpty()) { throw new DockerClientException(""Wrong ADD or COPY format""); } return Optional.of(new Add(sources, lastToken)); }"	"        public static Optional<Add> create(String statement) {
            Matcher matcher = ADD_OR_COPY_PATTERN.matcher(statement.trim());
            if (!matcher.find()) {
                return Optional.absent();
            }

            if (matcher.groupCount() != 3) {
                throw new DockerClientException(""Wrong ADD or COPY format"");
            }

            return Optional.of(new Add(matcher));
        }
"	Createa an Add if it matches, or missing if not.	Createa an Add if it matches, or missing if not.	0	1	9	29	174
protected int getNewForOldInput(int oldOrdinal) { return getNewFieldForOldInput(oldOrdinal).i; }	"  protected int getNewForOldInput(int oldOrdinal) {
    assert currentRel != null;
    int newOrdinal = 0;

    // determine which input rel oldOrdinal references, and adjust
    // oldOrdinal to be relative to that input rel
    RelNode oldInput = null;
    for (RelNode oldInput1 : currentRel.getInputs()) {
      RelDataType oldInputType = oldInput1.getRowType();
      int n = oldInputType.getFieldCount();
      if (oldOrdinal < n) {
        oldInput = oldInput1;
        break;
      }
      RelNode newInput = getNewForOldRel(oldInput1);
      newOrdinal += newInput.getRowType().getFieldCount();
      oldOrdinal -= n;
    }
    assert oldInput != null;

    RelDataType oldInputType = oldInput.getRowType();
    newOrdinal += calculateFlattenedOffset(oldInputType, oldOrdinal);
    return newOrdinal;
  }
"	Maps the ordinal of a field pre-flattening to the ordinal of the corresponding field post-flattening.	Maps the ordinal of a field pre-flattening to the ordinal of the corresponding field post-flattening, and optionally returns its type.	1	0	5	4	16
public static IPath toPath(URI uri) { Assert.isNotNull(uri); if (EFS.SCHEME_FILE.equals(uri.getScheme())) return new Path(uri.getSchemeSpecificPart()); return null; }	"	public static IPath toPath(URI uri) {
		if (uri == null)
			return null;
		if (EFS.SCHEME_FILE.equals(uri.getScheme()))
			return new Path(uri.getSchemeSpecificPart());
		return new Path(uri.getPath());
	}
"	Returns an  IPath representing this  URI in the local file system, or null if this URI does not represent a file in the local file system.	Converts a URI to an IPath.	1	0	6	8	41
public Collection<OsmPrimitive> getSelected() { return Collections.unmodifiableSet(selectedPrimitives); }	"    public Collection<OsmPrimitive> getSelected() {
        // It would be nice to have this be a copy-on-write list
        // or an Collections.unmodifiableList().  It would be
        // much faster for large selections.  May users just
        // call this, and only check the .size().
        return new ArrayList<OsmPrimitive>(selectedPrimitives);
    }
"	Replies an unmodifiable collection of primitives currently selected in this dataset	Return a list of all selected objects.	1	0	5	5	15
public ArrayList<CheckBox> getCurrentCheckBoxes() { return ensureArrayListOrNull(viewFetcher.getCurrentViews(CheckBox.class)); }	"	public ArrayList<CheckBox> getCurrentCheckBoxes()
	{
		return viewFetcher.getCurrentViews(CheckBox.class);
	}
"	Returns a  List of the  CheckBoxes contained in the current  Activity.	Returns a List of the CheckBoxes contained in the current Activity.	0	1	7	4	19
public String[] createText(MilStd2525TacticalGraphic graphic) { String[] result; String functionId = graphic.getFunctionId(); if (CircularFireSupportArea.FUNCTION_ID_TARGET.equals(functionId)) { result = new String[] { graphic.getText() }; } else { boolean useSeparateTimeLabel = this.isShowSeparateTimeLabel(functionId); String mainText = this.createMainText(graphic, functionId, !useSeparateTimeLabel); if (useSeparateTimeLabel) { String timeText = this.createTimeRangeText(graphic); result = new String[] { mainText, timeText }; } else { result = new String[] { mainText }; } } return result; }	"    public String createText(MilStd2525TacticalGraphic graphic)
    {
        String functionId = graphic.getFunctionId();
        if (CircularFireSupportArea.FUNCTION_ID_TARGET.equals(functionId))
            return graphic.getText();
        else
            return createDateRangeText(graphic, functionId);
    }
"	Construct the text for labels in a Fire Support area graphic.	Construct the text for the main label of a graphic.	1	0	11	28	110
public InstrumentationFieldCompleteParameters withNewState(InstrumentationState instrumentationState) { return new InstrumentationFieldCompleteParameters( this.executionContext, executionStrategyParameters, this.fieldDef, this.typeInfo, this.fetchedValue, instrumentationState); }	"    public InstrumentationFieldCompleteParameters withNewState(InstrumentationState instrumentationState) {
        return new InstrumentationFieldCompleteParameters(
                this.executionContext, executionStrategyParameters, this.fieldDef, this.typeInfo, instrumentationState);
    }
"	Returns a cloned parameters object with the new state	Returns a cloned parameters object with the new state	0	1	6	5	30
public int compareTo(ByteArrayWritable that) { return WritableComparator.compareBytes(this.data, this.offset, this.length, that.data, that.offset, that.length); }	"    public int compareTo(final byte[] that) {
        return WritableComparator.compareBytes(this.data, this.offset, this.length, that, 0, that.length);
    }
"	Define the sort order of the BytesWritable.	Compares the bytes in this object to the specified byte array	1	0	6	5	32
public static boolean shouldDisplay(Context context) { WelcomeActivityContent fragment = getCurrentFragment(context); return fragment != null; }	"    public static boolean shouldDisplay(Context context) {
        WelcomeActivityContent fragment = getCurrentFragment(context);
        if (fragment == null) {
            return false;
        }
        return true;
    }
"	Tracks whether to display this activity.	Whether to display the WelcomeActivity.	1	0	6	6	22
public final int getEndLine() { return this.bufline[this.bufpos]; }	"    public final int getEndLine() {
        return bufline[bufpos];
    }
"	Get the line number	DOCUMENT ME!	1	0	7	5	16
"public NonLiteral convertNonLiteral(Node node) { if (node == null) { throw new IllegalArgumentException(""null argument not allowed""); } if (node.isBlank()) { return convertJenaNode2TriaBlankNode(node); } if (node.isURI()) { return convertJenaUri2UriRef(node); } throw new RuntimeException(""cannot convert "" + node + "" to NonLiteral""); }"	"    public BlankNodeOrIri convertNonLiteral(Node node) {
        if (node == null) {
            throw new IllegalArgumentException(""null argument not allowed"");
        }
        if (node.isBlank()) {
            return convertJenaNode2TriaBlankNode(node);
        }
        if (node.isURI()) {
            return convertJenaUri2UriRef(node);
        }
        throw new RuntimeException(""cannot convert "" + node + "" to BlankNodeOrIri"");
    }
"	Converts a node to a BNode if it is a Blank Node otherwise to a UriRef.	Converts a node to a BlankNode if it is a Blank Node otherwise to a Iri.	1	0	7	14	75
public String fakeOuterStringSerialize(String body) throws ApiException { ApiResponse<String> localVarResp = fakeOuterStringSerializeWithHttpInfo(body); return localVarResp.getData(); }	"    public String fakeOuterStringSerialize(String body) throws ApiException {
        ApiResponse<String> resp = fakeOuterStringSerializeWithHttpInfo(body);
        return resp.getData();
    }
"	Test serialization of outer string types	Test serialization of outer string types	0	1	6	5	25
"public boolean isConnected() { final Health request = new Health.Builder() .local() .timeout(Ints.saturatedCast(requestTimeout.toSeconds())) .build(); final JestResult result = JestUtils.execute(jestClient, request, () -> ""Couldn't check connection status of Elasticsearch""); final int numberOfDataNodes = Optional.of(result.getJsonObject()) .map(json -> asInteger(json.get(""number_of_data_nodes""))) .orElse(0); return numberOfDataNodes > 0; }"	"    public boolean isConnected() {
        Map<String, DiscoveryNode> nodeMap = nodes.get();
        return nodeMap != null && !nodeMap.isEmpty();
    }
"	Check if Elasticsearch is available and that there are data nodes in the cluster.	Check if the Elasticsearch org.elasticsearch.node.Node is connected and that there are other nodes in the cluster.	1	0	10	14	93
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 38: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, yytext()); } case 55: break; case 43: // general lookahead, find correct zzMarkedPos { int zzFState = 9; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 10; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { // try to work around an apparent jflex bug where it // gets a space at the token end by getting // wrong the length of the trailing context. while (yylength() > 0) { char last = yycharat(yylength()-1); if (last == ' ' || last == '\t' || (last >= '\n' && last <= '\r' || last == '\u0085')) { yypushback(1); } else { break; } } return getNext(); } case 56: break; case 11: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 57: break; case 19: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 58: break; case 8: { return handleQuotes(yytext(), false); } case 59: break; case 35: // lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), false); } case 60: break; case 27: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 61: break; case 33: // lookahead expression with fixed lookahead length yypushback(1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 62: break; case 49: // lookahead expression with fixed lookahead length yypushback(1); { return getNormalizedAmpNext(); } case 63: break; case 36: { return getNormalizedAmpNext(); } case 64: break; case 23: { if (invertible) { prevWordAfter.append(yytext()); } } case 65: break; case 37: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, yytext()); } case 66: break; case 53: // lookahead expression with fixed lookahead length yypushback(4); { return getNext(); } case 67: break; case 46: // lookahead expression with fixed lookahead length yypushback(2); { return getNext(); } case 68: break; case 42: // general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 69: break; case 41: // general lookahead, find correct zzMarkedPos { int zzFState = 16; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 17; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 70: break; case 40: // general lookahead, find correct zzMarkedPos { int zzFState = 13; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 71: break; case 3: { return getNext(); } case 72: break; case 24: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(); } case 73: break; case 51: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } return getNext(txt, yytext()); } case 74: break; case 26: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, origTxt); } case 75: break; case 6: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 76: break; case 29: // general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 77: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 78: break; case 2: { return getNext(""<"", yytext()); } case 79: break; case 30: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 80: break; case 18: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 81: break; case 54: { String txt = yytext(); if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 82: break; case 50: { yypushback(3) ; return getNext(); } case 83: break; case 25: // lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), true); } case 84: break; case 39: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 85: break; case 21: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 86: break; case 17: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 87: break; case 13: { return handleEllipsis(yytext()); } case 88: break; case 34: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 1; { /* invert quote - often but not always right */ return handleQuotes(yytext(), true); } case 89: break; case 14: { return normalizeFractions(yytext()); } case 90: break; case 15: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(); } } case 91: break; case 47: // general lookahead, find correct zzMarkedPos { int zzFState = 11; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 12; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 92: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 93: break; case 9: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 94: break; case 45: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 95: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 96: break; case 28: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 97: break; case 48: { if (keepAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 98: break; case 20: { if (normalizeOtherBrackets) { return getNext(""-RSB-"", yytext()); } else { return getNext(); } } case 99: break; case 12: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 100: break; case 31: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 101: break; case 10: { return getNext("">"", yytext()); } case 102: break; case 32: { // this one should only match if we're basically at the end of file // since the last one matches two things, even newlines String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 103: break; case 22: { if (normalizeOtherBrackets) { return getNext(""-LSB-"", yytext()); } else { return getNext(); } } case 104: break; case 52: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { // try to work around an apparent jflex bug where it // gets a space at the token end by getting // wrong the length of the trailing context. while (yylength() > 0) { char last = yycharat(yylength()-1); if (last == ' ' || last == '\t' || (last >= '\n' && last <= '\r' || last == '\u0085')) { yypushback(1); } else { break; } } String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 105: break; case 1: { String str = yytext(); int first = str.charAt(0); String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } LOGGER.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: LOGGER.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 106: break; case 44: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 107: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 108: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }"	"  public Object next() throws java.io.IOException {
    int zzInput;
    int zzAction;

    // cached fields:
    int zzCurrentPosL;
    int zzMarkedPosL;
    int zzEndReadL = zzEndRead;
    char [] zzBufferL = zzBuffer;
    char [] zzCMapL = ZZ_CMAP;

    int [] zzTransL = ZZ_TRANS;
    int [] zzRowMapL = ZZ_ROWMAP;
    int [] zzAttrL = ZZ_ATTRIBUTE;

    while (true) {
      zzMarkedPosL = zzMarkedPos;

      yychar+= zzMarkedPosL-zzStartRead;

      zzAction = -1;

      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
  
      zzState = ZZ_LEXSTATE[zzLexicalState];


      zzForAction: {
        while (true) {
    
          if (zzCurrentPosL < zzEndReadL)
            zzInput = zzBufferL[zzCurrentPosL++];
          else if (zzAtEOF) {
            zzInput = YYEOF;
            break zzForAction;
          }
          else {
            // store back cached positions
            zzCurrentPos  = zzCurrentPosL;
            zzMarkedPos   = zzMarkedPosL;
            boolean eof = zzRefill();
            // get translated positions and possibly new buffer
            zzCurrentPosL  = zzCurrentPos;
            zzMarkedPosL   = zzMarkedPos;
            zzBufferL      = zzBuffer;
            zzEndReadL     = zzEndRead;
            if (eof) {
              zzInput = YYEOF;
              break zzForAction;
            }
            else {
              zzInput = zzBufferL[zzCurrentPosL++];
            }
          }
          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
          if (zzNext == -1) break zzForAction;
          zzState = zzNext;

          int zzAttributes = zzAttrL[zzState];
          if ( (zzAttributes & 1) == 1 ) {
            zzAction = zzState;
            zzMarkedPosL = zzCurrentPosL;
            if ( (zzAttributes & 8) == 8 ) break zzForAction;
          }

        }
      }

      // store back cached position
      zzMarkedPos = zzMarkedPosL;

      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
        case 38: 
          { String txt = yytext();
                  if (escapeForwardSlashAsterisk) {
                    txt = delimit(txt, '/');
                  }
                  if (normalizeSpace) {
                    // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                    txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space

                  }
                  return getNext(txt, yytext());
          }
        case 55: break;
        case 43: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 9;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 10;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { // try to work around an apparent jflex bug where it
                          // gets a space at the token end by getting
                          // wrong the length of the trailing context.
                          while (yylength() > 0) {
                            char last = yycharat(yylength()-1);
                            if (last == ' ' || last == '\t' || (last >= '\n' && last <= '\r' || last == '\u0085')) {
                              yypushback(1);
                            } else {
                              break;
                            }
                          }
			  return getNext();
          }
        case 56: break;
        case 11: 
          { if (ptb3Dashes) {
                            return getNext(ptbmdash, yytext()); }
                          else {
                            return getNext();
                          }
          }
        case 57: break;
        case 19: 
          { if (escapeForwardSlashAsterisk) {
                    return getNext(delimit(yytext(), '*'), yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 58: break;
        case 8: 
          { return handleQuotes(yytext(), false);
          }
        case 59: break;
        case 35: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return handleQuotes(yytext(), false);
          }
        case 60: break;
        case 27: 
          { String txt = yytext();
                  String origText = txt;
                  if (normalizeParentheses) {
                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                  }
                  return getNext(txt, origText);
          }
        case 61: break;
        case 33: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { String txt = yytext();
                  String origText = txt;
                  if (normalizeParentheses) {
                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                  }
                  return getNext(txt, origText);
          }
        case 62: break;
        case 49: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return getNormalizedAmpNext();
          }
        case 63: break;
        case 36: 
          { return getNormalizedAmpNext();
          }
        case 64: break;
        case 23: 
          { if (invertible) {
                            prevWordAfter.append(yytext());
                        }
          }
        case 65: break;
        case 37: 
          { String txt = yytext();
                  if (escapeForwardSlashAsterisk) {
                    txt = delimit(txt, '/');
                  }
                  if (normalizeSpace) {
                    // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                    txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                  }
                  return getNext(txt, yytext());
          }
        case 66: break;
        case 53: 
          // lookahead expression with fixed lookahead length
          yypushback(4);
          { return getNext();
          }
        case 67: break;
        case 46: 
          // lookahead expression with fixed lookahead length
          yypushback(2);
          { return getNext();
          }
        case 68: break;
        case 42: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 15;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 14;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { return getNext();
          }
        case 69: break;
        case 41: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 16;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 17;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { return getNext();
          }
        case 70: break;
        case 40: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 13;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 14;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { return getNext();
          }
        case 71: break;
        case 3: 
          { return getNext();
          }
        case 72: break;
        case 24: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return getNext();
          }
        case 73: break;
        case 51: 
          { String txt = yytext();
                          if (escapeForwardSlashAsterisk) {
                            txt = delimit(txt, '/');
                          }
                          return getNext(txt, yytext());
          }
        case 74: break;
        case 26: 
          { final String origTxt = yytext();
                          String txt = origTxt;
                          if (normalizeSpace) {
                            // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                            txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                          }
                          return getNext(txt, origTxt);
          }
        case 75: break;
        case 6: 
          { final String origTxt = yytext();
                          String tmp = removeSoftHyphens(origTxt);
                          if (americanize) {
                            tmp = Americanize.americanize(tmp);
                          }
                          return getNext(tmp, origTxt);
          }
        case 76: break;
        case 29: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 3;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 4;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { final String origTxt = yytext();
                          String tmp = removeSoftHyphens(origTxt);
                          if (americanize) {
                            tmp = Americanize.americanize(tmp);
                          }
                          return getNext(tmp, origTxt);
          }
        case 77: break;
        case 16: 
          { if (normalizeOtherBrackets) {
                    return getNext(closebrace, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 78: break;
        case 2: 
          { return getNext(""<"", yytext());
          }
        case 79: break;
        case 48: 
          { yypushback(2) ; return getNext();
          }
        case 80: break;
        case 30: 
          { if (escapeForwardSlashAsterisk) {
                            return getNext(delimit(yytext(), '/'), yytext());
                          } else {
                            return getNext();
                          }
          }
        case 81: break;
        case 18: 
          { if (normalizeParentheses) {
                    return getNext(closeparen, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 82: break;
        case 54: 
          { String txt = yytext();
                          if (normalizeSpace) {
                            // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                            txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                          }
                          if (normalizeParentheses) {
                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                          }
                          return getNext(txt, yytext());
          }
        case 83: break;
        case 50: 
          { yypushback(3) ; return getNext();
          }
        case 84: break;
        case 25: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return handleQuotes(yytext(), true);
          }
        case 85: break;
        case 39: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 5;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 6;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { final String txt = yytext();
                          return getNext(removeSoftHyphens(txt),
                                         txt);
          }
        case 86: break;
        case 21: 
          { if (normalizeOtherBrackets) {
                    return getNext(openbrace, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 87: break;
        case 17: 
          { if (normalizeParentheses) {
                    return getNext(openparen, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 88: break;
        case 13: 
          { return handleEllipsis(yytext());
          }
        case 89: break;
        case 34: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 1;
          { /* invert quote - often but not always right */
                  return handleQuotes(yytext(), true);
          }
        case 90: break;
        case 14: 
          { return normalizeFractions(yytext());
          }
        case 91: break;
        case 15: 
          { if (normalizeCurrency) {
                            return getNext(normalizeCurrency(yytext()), yytext()); }
                          else {
                            return getNext();
                          }
          }
        case 92: break;
        case 47: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 11;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 12;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { String s;
                          if (strictTreebank3 && ! ""U.S."".equals(yytext())) {
                            yypushback(1); // return a period for next time
                            s = yytext();
                          } else {
                            s = yytext();
                            yypushback(1); // return a period for next time
                          }
                          return getNext(s, yytext());
          }
        case 93: break;
        case 7: 
          { if (invertible) {
                     prevWordAfter.append(yytext());
                  }
          }
        case 94: break;
        case 9: 
          { if (escapeForwardSlashAsterisk) {
                    return getNext(delimit(yytext(), '/'), yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 95: break;
        case 45: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return getNext(removeSoftHyphens(yytext()),
                                               yytext());
          }
        case 96: break;
        case 4: 
          { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {
                    return getNext(ptbmdash, yytext());
                  } else {
                    return getNext();
                  }
          }
        case 97: break;
        case 28: 
          { return getNext(removeSoftHyphens(yytext()), yytext());
          }
        case 98: break;
        case 20: 
          { if (normalizeOtherBrackets) {
                    return getNext(""-RSB-"", yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 99: break;
        case 12: 
          { return getNext(removeSoftHyphens(yytext()),
                                         yytext());
          }
        case 100: break;
        case 31: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return getNext(removeSoftHyphens(yytext()),
                                         yytext());
          }
        case 101: break;
        case 10: 
          { return getNext("">"", yytext());
          }
        case 102: break;
        case 32: 
          { // this one should only match if we're basically at the end of file
                          // since the last one matches two things, even newlines
                          String s;
                          if (strictTreebank3 && ! ""U.S."".equals(yytext())) {
                            yypushback(1); // return a period for next time
                            s = yytext();
                          } else {
                            s = yytext();
                            yypushback(1); // return a period for next time
                          }
                          return getNext(s, yytext());
          }
        case 103: break;
        case 22: 
          { if (normalizeOtherBrackets) {
                    return getNext(""-LSB-"", yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 104: break;
        case 52: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 7;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 8;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { // try to work around an apparent jflex bug where it
                          // gets a space at the token end by getting
                          // wrong the length of the trailing context.
                          while (yylength() > 0) {
                            char last = yycharat(yylength()-1);
                            if (last == ' ' || last == '\t' || (last >= '\n' && last <= '\r' || last == '\u0085')) {
                              yypushback(1);
                            } else {
                              break;
                            }
                          }
                          String s;
                          if (strictTreebank3 && ! ""U.S."".equals(yytext())) {
                            yypushback(1); // return a period for next time
                            s = yytext();
                          } else {
                            s = yytext();
                            yypushback(1); // return a period for next time
                          }
                          return getNext(s, yytext());
          }
        case 105: break;
        case 1: 
          { String str = yytext();
          int first = str.charAt(0);
          String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));
          switch (untokenizable) {
            case NONE_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              break;
            case FIRST_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              if ( ! this.seenUntokenizableCharacter) {
                LOGGER.warning(msg);
                this.seenUntokenizableCharacter = true;
              }
              break;
            case ALL_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              LOGGER.warning(msg);
              this.seenUntokenizableCharacter = true;
              break;
            case NONE_KEEP:
              return getNext();
            case FIRST_KEEP:
              if ( ! this.seenUntokenizableCharacter) {
                LOGGER.warning(msg);
                this.seenUntokenizableCharacter = true;
              }
              return getNext();
            case ALL_KEEP:
              LOGGER.warning(msg);
              this.seenUntokenizableCharacter = true;
              return getNext();
          }
          }
        case 106: break;
        case 44: 
          { String txt = yytext();
                          if (escapeForwardSlashAsterisk) {
                            txt = delimit(txt, '/');
                            txt = delimit(txt, '*');
                          }
                          return getNext(txt, yytext());
          }
        case 107: break;
        case 5: 
          { if (tokenizeNLs) {
                      return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns
                  } else if (invertible) {
                      prevWordAfter.append(yytext());
                  }
          }
        case 108: break;
        default: 
          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
            zzAtEOF = true;
              {
                if (invertible) {
            prevWordAfter.append(yytext());
            String str = prevWordAfter.toString();
            prevWordAfter.setLength(0);
            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);
          }
          return null;
              }
          } 
          else {
            zzScanError(ZZ_NO_MATCH);
          }
      }
    }
  }
"	Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.	Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.	0	1	17	702	4305
public CharSequence getQueryHint() { final CharSequence hint; if (mQueryHint != null) { hint = mQueryHint; } else if (IS_AT_LEAST_FROYO && mSearchable != null && mSearchable.getHintId() != 0) { hint = getContext().getText(mSearchable.getHintId()); } else { hint = mDefaultQueryHint; } return hint; }	"    public CharSequence getQueryHint() {
        if (mQueryHint != null) {
            return mQueryHint;
        } else if (IS_AT_LEAST_FROYO && mSearchable != null) {
            CharSequence hint = null;
            int hintId = mSearchable.getHintId();
            if (hintId != 0) {
                hint = getContext().getString(hintId);
            }
            return hint;
        }
        return null;
    }
"	Returns the hint text that will be displayed in the query text field.	Gets the hint text to display in the query text field.	1	0	10	13	63
public static XpiDriverService createDefaultService() { try { return new Builder().build(); } catch (WebDriverException e) { throw new IllegalStateException(e.getMessage(), e.getCause()); } }	"  public static XpiDriverService createDefaultService() {
    try {
      return new XpiDriverService.Builder().usingAnyFreePort().build();
    } catch (WebDriverException e) {
      throw new IllegalStateException(e.getMessage(), e.getCause());
    }
  }
"	Configures and returns a new  XpiDriverService using the default configuration.	Configures and returns a new XpiDriverService using the default configuration.	0	1	7	8	42
@NonNull protected List<Action> retrieveActions(@NonNull SCMSourceEvent event, @NonNull TaskListener listener) throws IOException, InterruptedException { return Collections.emptyList(); }	"    @NonNull
    protected Map<Class<? extends Action>, Action> retrieveActions(@NonNull TaskListener listener)
            throws IOException, InterruptedException {
        return Collections.emptyMap();
    }
"	SPI for  #fetchActions(SCMSourceEvent,TaskListener).	SPI for #fetchActions(TaskListener).	1	0	5	8	29
public static LobCreator getLobCreator(SessionImplementor session) { return session.getFactory() .getServiceRegistry() .getService( JdbcServices.class ) .getLobCreator( session ); }	"	public static LobCreator getLobCreator(SessionImplementor session) {
		return session.getFactory()
				.getJdbcServices()
				.getLobCreator( session );
	}
"	Obtain a lob creator for the given session.	Obtain a lob creator for the given session.	0	1	7	7	28
public static final TwitterTokenStream of(TwitterTokenStream... streams) { return new TokenStreamAggregator(streams); }	"  public static final TokenStream of(TokenStream... streams) {
    return new TokenStreamAggregator(streams);
  }
"	Creates a  TwitterTokenStream that aggregates the outputs of a given set of  TokenStreams.	Creates a TokenStream that aggregates the outputs of a given set of TokenStreams.	1	0	5	5	18
public User getUserByName(String username) throws ApiException { return getUserByNameWithHttpInfo(username).getData(); }	"  public User getUserByName(String username) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'username' is set
    if (username == null) {
      throw new ApiException(400, ""Missing the required parameter 'username' when calling getUserByName"");
    }
    
    // create path and map variables
    String localVarPath = ""/user/{username}""
      .replaceAll(""\\{"" + ""username"" + ""\\}"", apiClient.escapeString(username.toString()));

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    final String[] localVarAccepts = {
      ""application/xml"", ""application/json""
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    GenericType<User> localVarReturnType = new GenericType<User>() {};
    return apiClient.invokeAPI(localVarPath, ""GET"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);
      }
"	Get user by user name	Get user by user name	0	1	5	4	20
public final Map<String, String> validateSubDocuments() { final OOXML ooxml = this.getFormatVersion().getXML(); if (!ooxml.canValidate()) return null; final Map<String, String> res = new HashMap<String, String>(); for (final String s : subdocNames) { if (this.getEntries().contains(s)) { final String valid = ooxml.getValidator(this.getDocument(s)).isValid(); if (valid != null) res.put(s, valid); } } return res; }	"    public final Map<String, String> validateSubDocuments() {
        final OOXML ooxml = OOXML.get(getVersion());
        final Map<String, String> res = new HashMap<String, String>();
        for (final String s : subdocNames) {
            if (this.getEntries().contains(s)) {
                final String valid = ooxml.getValidator(this.getDocument(s)).isValid();
                if (valid != null)
                    res.put(s, valid);
            }
        }
        return res;
    }
"	Call  Validator#isValid() on each XML subdocuments.	Call OOXML#isValid(Document) on each XML subdocuments.	1	0	12	16	103
public Schema getDefaultSchema() { return this; }	"  public AbstractSchema getDefaultSchema() {
    return this;
  }
"	The schema can be a top level schema which doesn't have its own tables, but refers to one of the default sub schemas for table look up.	The schema can be a top level schema which doesn't have its own tables, but refers to one of the default sub schemas for table look up.	0	1	4	4	10
"public ApiResponse uploadFile (Long petId, String additionalMetadata, File file) throws ApiException { Object postBody = null; // verify the required parameter 'petId' is set if (petId == null) { throw new ApiException(400, ""Missing the required parameter 'petId' when calling uploadFile""); } // create path and map variables String path = ""/pet/{petId}/uploadImage"".replaceAll(""\\{format\\}"",""json"").replaceAll(""\\{"" + ""petId"" + ""\\}"", apiInvoker.escapeString(petId.toString())); // query params List<Pair> queryParams = new ArrayList<Pair>(); // header params Map<String, String> headerParams = new HashMap<String, String>(); // form params Map<String, String> formParams = new HashMap<String, String>(); String[] contentTypes = { ""multipart/form-data"" }; String contentType = contentTypes.length > 0 ? contentTypes[0] : ""application/json""; if (contentType.startsWith(""multipart/form-data"")) { // file uploading MultipartEntityBuilder builder = MultipartEntityBuilder.create(); if (additionalMetadata != null) { builder.addTextBody(""additionalMetadata"", ApiInvoker.parameterToString(additionalMetadata), ApiInvoker.TEXT_PLAIN_UTF8); } if (file != null) { builder.addBinaryBody(""file"", file); } HttpEntity httpEntity = builder.build(); postBody = httpEntity; } else { // normal form params formParams.put(""additionalMetadata"", ApiInvoker.parameterToString(additionalMetadata)); } try { String response = apiInvoker.invokeAPI(basePath, path, ""POST"", queryParams, postBody, headerParams, formParams, contentType); if(response != null){ return (ApiResponse) ApiInvoker.deserialize(response, """", ApiResponse.class); } else { return null; } } catch (ApiException ex) { throw ex; } }"	"  public void  uploadFile (Long petId, String additionalMetadata, File file) throws ApiException {
    Object postBody = null;
    
    // verify the required parameter 'petId' is set
    if (petId == null) {
       throw new ApiException(400, ""Missing the required parameter 'petId' when calling uploadFile"");
    }
    

    // create path and map variables
    String path = ""/pet/{petId}/uploadImage"".replaceAll(""\\{format\\}"",""json"").replaceAll(""\\{"" + ""petId"" + ""\\}"", apiInvoker.escapeString(petId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    

    

    String[] contentTypes = {
      ""multipart/form-data""
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : ""application/json"";

    if (contentType.startsWith(""multipart/form-data"")) {
      // file uploading
      MultipartEntityBuilder builder = MultipartEntityBuilder.create();
      
      if (additionalMetadata != null) {
        builder.addTextBody(""additionalMetadata"", ApiInvoker.parameterToString(additionalMetadata), ApiInvoker.TEXT_PLAIN_UTF8);
      }
      
      if (file != null) {
        builder.addBinaryBody(""file"", file);
      }
      

      HttpEntity httpEntity = builder.build();
      postBody = httpEntity;
    } else {
      // normal form params
      formParams.put(""additionalMetadata"", ApiInvoker.parameterToString(additionalMetadata));
      
      
    }

    try {
      String response = apiInvoker.invokeAPI(basePath, path, ""POST"", queryParams, postBody, headerParams, formParams, contentType);
      if(response != null){
        return ;
      }
      else {
        return ;
      }
    } catch (ApiException ex) {
      throw ex;
    }
  }
"	uploads an image	uploads an image	0	1	10	63	369
@Override public boolean equals(Object other) { if (this == other) { return true; } if (other instanceof PwPair) { PwPair otherPwPair = (PwPair) other; return getRank() == otherPwPair.getRank() && mUrlDevice.equals(otherPwPair.mUrlDevice) && mPwsResult.equals(otherPwPair.mPwsResult); } return false; }	"  public boolean equals(Object other) {
    if (other instanceof PwPair) {
      PwPair otherPwPair = (PwPair) other;
      return getRank() == otherPwPair.getRank();
    }
    return false;
  }
"	Check if two PwPairs are equal.	Check if two PwPairs are equal based on rank.	1	0	9	16	64
"public static String asString(final InputStream is, Charset charset) throws IOException { final BufferedReader reader = new BufferedReader(new InputStreamReader(is, charset)); try { final String firstLine = reader.readLine(); if (firstLine == null) { return """"; } final StringBuilder builder = new StringBuilder(firstLine); for (String line = reader.readLine(); line != null; line = reader.readLine()) { builder.append(EOL); builder.append(line); } return builder.toString(); } finally { reader.close(); } }"	"    public static String asString(final InputStream is) throws IOException {
        final BufferedReader reader = new BufferedReader(new InputStreamReader(is, ""UTF-8""));
        try {
            return reader.readLine();
        } finally {
            reader.close();
        }
    }
"	Reads the provided input stream as a string and then closes the stream.	Reads the provided input stream as a UTF-8 string and then closes the stream.	1	0	8	19	109
"public String getSchemaType(Schema schema) { if (schema instanceof ComposedSchema) { // composed schema ComposedSchema cs = (ComposedSchema) schema; List<Schema> schemas = ModelUtils.getInterfaces(cs); if (cs.getAllOf() != null) { for (Schema s : cs.getAllOf()) { if (s != null) { //schema = s; } //LOGGER.info(""ALL OF SCHEMA: {}"", s); } LOGGER.info(""Composed schema not yet supported: {}"", cs); // get the model (allOf) return getAlias(""UNKNOWN_COMPOSED_SCHMEA""); } else if (cs.getAnyOf() != null) { // anyOf List<String> names = new ArrayList<String>(); for (Schema s : schemas) { if (StringUtils.isNotBlank(s.get$ref())) { // reference to another definition/schema String schemaName = ModelUtils.getSimpleRef(s.get$ref()); if (StringUtils.isNotEmpty(schemaName)) { names.add(getAlias(schemaName)); } else { LOGGER.warn(""Error obtaining the datatype from ref:"" + schema.get$ref() + "". Default to 'object'""); return ""object""; } } else { // primitive type or model names.add(getAlias(getPrimitiveType(s))); } return ""anyOf<"" + String.join("","", names) + "">""; } } else if (cs.getOneOf() != null) { // oneOf List<String> names = new ArrayList<String>(); for (Schema s : schemas) { if (StringUtils.isNotBlank(s.get$ref())) { // reference to another definition/schema String schemaName = ModelUtils.getSimpleRef(s.get$ref()); if (StringUtils.isNotEmpty(schemaName)) { names.add(getAlias(schemaName)); } else { LOGGER.warn(""Error obtaining the datatype from ref:"" + schema.get$ref() + "". Default to 'object'""); return ""object""; } } else { // primitive type or model names.add(getAlias(getPrimitiveType(s))); } return ""oneOf<"" + String.join("","", names) + "">""; } } } if (StringUtils.isNotBlank(schema.get$ref())) { // reference to another definition/schema // get the schema/model name from $ref String schemaName = ModelUtils.getSimpleRef(schema.get$ref()); if (StringUtils.isNotEmpty(schemaName)) { return getAlias(schemaName); } else { LOGGER.warn(""Error obtaining the datatype from ref:"" + schema.get$ref() + "". Default to 'object'""); return ""object""; } } else { // primitive type or model return getAlias(getPrimitiveType(schema)); } }"	"    public String getSchemaType(Schema schema) {
        // TODO better logic to handle compose schema
        if (schema instanceof ComposedSchema) { // composed schema
            ComposedSchema cs = (ComposedSchema) schema;
            if (cs.getAllOf() != null) {
                for (Schema s : cs.getAllOf()) {
                    if (s != null) {
                        // using the first schema defined in allOf
                        schema = s;
                        break;
                    }
                }
            }
        }

        if (StringUtils.isNotBlank(schema.get$ref())) { // reference to another definition/schema
            // get the schema/model name from $ref
            String schemaName = ModelUtils.getSimpleRef(schema.get$ref());
            if (StringUtils.isNotEmpty(schemaName)) {
                return getAlias(schemaName);
            } else {
                LOGGER.warn(""Error obtaining the datatype from ref:"" + schema.get$ref() + "". Default to 'object'"");
                return ""object"";
            }
        } else { // primitive type or model
            return getAlias(getPrimitiveType(schema));
        }
    }
"	returns the OpenAPI type for the property.	returns the OpenAPI type for the property.	0	1	19	66	569
"public TaskShutdownDameon execute() throws Exception { // create heartbeat TaskHeartbeatRunable hb = new TaskHeartbeatRunable(zkCluster, topologyid, taskid, uptime, taskStats, taskStatus, stormConf); AsyncLoopThread heartbeat_thread = new AsyncLoopThread(hb, false, Thread.MIN_PRIORITY, true); IConnection puller = context.bind(topologyid, taskid, false); TaskSendTargets sendTargets = echoToSystemBolt(); // create thread to get tuple from zeroMQ, // and pass the tuple to bolt/spout RunnableCallback baseExecutor = mkExecutor(puller, sendTargets); AsyncLoopThread executor_threads = new AsyncLoopThread(baseExecutor, false, Thread.MAX_PRIORITY, true); List<AsyncLoopThread> allThreads = new ArrayList<AsyncLoopThread>(); allThreads.add(heartbeat_thread); allThreads.add(executor_threads); LOG.info(""Finished loading task "" + componentid + "":"" + taskid); return getShutdown(allThreads, heartbeat_thread, puller, baseExecutor); }"	"	public TaskShutdownDameon execute() throws Exception {

		// create heartbeat
		TaskHeartbeatRunable hb = new TaskHeartbeatRunable(zkCluster,
				topologyid, taskid, uptime, taskStats, taskStatus, stormConf);

		AsyncLoopThread heartbeat_thread = new AsyncLoopThread(hb, false,
				Thread.MIN_PRIORITY, true);

		IConnection puller = context.bind(topologyid, taskid, false);

		TaskSendTargets sendTargets = echoToSystemBolt();

		// create thread to get tuple from zeroMQ,
		// and pass the tuple to bolt/spout
		RunnableCallback baseExecutor = mkExecutor(puller, sendTargets);
		AsyncLoopThread executor_threads = new AsyncLoopThread(baseExecutor,
				false, Thread.MAX_PRIORITY, true);

		AsyncLoopThread[] all_threads = { executor_threads, heartbeat_thread };

		LOG.info(""Finished loading task "" + componentid + "":"" + taskid);

		return getShutdown(all_threads, heartbeat_thread, puller);
	}
"	create executor to receive tuples and run bolt/spout execute function	create executor to receive tuples and run bolt/spout execute function	0	1	8	28	161
public static ENumber<Integer> indexOf(Expr<String> left, String right) { return operationFactory.createNumber(Integer.class, Ops.INDEXOF, left, exprFactory.createConstant(right)); }	"    public static ENumber<Integer> indexOf(Expr<String> left, String right, int i) {
        return operationFactory.createNumber(Integer.class,Ops.INDEXOF_2ARGS, left, exprFactory.createConstant(right), exprFactory.createConstant(i));
    }
"	Expr : left.indexOf(right)	Expr : left.indexOf(right, i)	1	0	6	5	34
public CubeInstance disableCube(CubeInstance cube) throws IOException { aclEvaluate.hasProjectWritePermission(cube.getProjectInstance()); Message msg = MsgPicker.getMsg(); String cubeName = cube.getName(); RealizationStatusEnum ostatus = cube.getStatus(); if (null != ostatus && !RealizationStatusEnum.READY.equals(ostatus)) { throw new BadRequestException(String.format(msg.getDISABLE_NOT_READY_CUBE(), cubeName, ostatus)); } return getCubeManager().updateCubeStatus(cube, RealizationStatusEnum.DISABLED); }	"    public CubeInstance disableCube(CubeInstance cube) throws IOException {
        aclEvaluate.hasProjectWritePermission(cube.getProjectInstance());
        Message msg = MsgPicker.getMsg();

        String cubeName = cube.getName();

        RealizationStatusEnum ostatus = cube.getStatus();
        if (null != ostatus && !RealizationStatusEnum.READY.equals(ostatus)) {
            throw new BadRequestException(String.format(msg.getDISABLE_NOT_READY_CUBE(), cubeName, ostatus));
        }

        cube.setStatus(RealizationStatusEnum.DISABLED);

        try {
            CubeUpdate cubeBuilder = new CubeUpdate(cube);
            cubeBuilder.setStatus(RealizationStatusEnum.DISABLED);
            return getCubeManager().updateCube(cubeBuilder);
        } catch (IOException e) {
            cube.setStatus(ostatus);
            throw e;
        }
    }
"	Update a cube status from ready to disabled.	Update a cube status from ready to disabled.	0	1	8	14	88
public SortedMap<String, String> getOriginTabContentsAsStrings(final Origin selectedColumn) { openTab(Tab.ORIGIN); return mapTableCellsKeyValue(String.class, getVisibleTableRows(true, false), selectedColumn.column); }	"    public SortedMap<String, String> getOriginTabContentsAsStrings() {
        openTab(Tab.ORIGIN);
        return mapTableCellsKeyValue(String.class, getVisibleTableRows(true, true), 3);
    }
"	"Returns the first and the specified columns of the ""Origin""-tab as key => value pairs, skipping the header row."	"Returns the first two columns of the ""Warnings""-tab as key => value pairs, skipping the header row."	1	0	6	7	36
"public ByteBuffer getImageBytes() { if (!isReady()) { return null; } assert driver != null; assert device != null; // some devices can support direct image buffers, and for those call // processor task, and for those which does not support direct image // buffers, just convert image to RGB byte array if (device instanceof BufferAccess) { return new WebcamGetBufferTask(driver, device).getBuffer(); } else { throw new IllegalStateException(String.format(""Driver %s does not support buffer access"", driver.getClass().getName())); } }"	"	public ByteBuffer getImageBytes() {

		if (!isReady()) {
			return null;
		}

		assert driver != null;
		assert device != null;

		// some devices can support direct image buffers, and for those call
		// processor task, and for those which does not support direct image
		// buffers, just convert image to RGB byte array

		if (device instanceof BufferAccess) {
			return new WebcamReadBufferTask(driver, device).getBuffer();
		} else {
			BufferedImage image = getImage();
			if (image != null) {
				return ByteBuffer.wrap(ImageUtils.toRawByteArray(image));
			} else {
				return null;
			}
		}
	}
"	Get RAW image ByteBuffer.	Get RAW image ByteBuffer.	0	1	9	20	119
public boolean isPullSuccessIndicated() { if (isErrorIndicated() || getStatus() == null) { return false; } return (getStatus().contains(DOWNLOAD_COMPLETE) || getStatus().contains(IMAGE_UP_TO_DATE) || getStatus().contains(DOWNLOADED_NEWER_IMAGE) || getStatus().contains(LEGACY_REGISTRY) || getStatus().contains(DOWNLOADED_SWARM) ); }	"    public boolean isPullSuccessIndicated() {
        if (isErrorIndicated() || getStatus() == null) {
            return false;
        }

        return (getStatus().contains(DOWNLOAD_COMPLETE) || getStatus().contains(IMAGE_UP_TO_DATE)
                || getStatus().contains(DOWNLOADED_NEWER_IMAGE) || getStatus().contains(LEGACY_REGISTRY));
    }
"	Returns whether the status indicates a successful pull operation	Returns whether the status indicates a successful pull operation	0	1	10	13	71
"protected AuthenticationInfo doMultiRealmAuthentication(Collection<? extends Realm> realms, AuthenticationToken token) { ModularAuthenticationStrategy strategy = getModularAuthenticationStrategy(); AuthenticationInfo aggregate = strategy.beforeAllAttempts(realms, token); if (log.isDebugEnabled()) { log.debug(""Iterating through ["" + realms.size() + ""] realms for PAM authentication""); } for (Realm realm : realms) { if (realm.supports(token)) { if (log.isDebugEnabled()) { log.debug(""Attempting to authenticate token ["" + token + ""] "" + ""using realm of type ["" + realm + ""]""); } AuthenticationInfo info = null; Throwable t = null; try { info = realm.getAuthenticationInfo(token); } catch (Throwable throwable) { t = throwable; if (log.isTraceEnabled()) { String msg = ""Realm ["" + realm + ""] threw an exception during a multi-realm authentication attempt:""; log.trace(msg, t); } } aggregate = strategy.afterAttempt(realm, token, info, aggregate, t); } else { if (log.isDebugEnabled()) { log.debug(""Realm of type ["" + realm + ""] does not support token "" + ""["" + token + ""]. Skipping realm.""); } } } aggregate = strategy.afterAllAttempts(token, aggregate); return aggregate; }"	"    protected Account doMultiRealmAuthentication(Collection<? extends Realm> realms, AuthenticationToken token) {

        ModularAuthenticationStrategy strategy = getModularAuthenticationStrategy();

        Account aggregate = strategy.beforeAllAttempts(realms, token);

        if (log.isDebugEnabled()) {
            log.debug(""Iterating through ["" + realms.size() + ""] realms for PAM authentication"");
        }

        for (Realm realm : realms) {

            if (realm.supports(token)) {

                if (log.isDebugEnabled()) {
                    log.debug(""Attempting to authenticate token ["" + token + ""] "" +
                            ""using realm of type ["" + realm + ""]"");
                }

                aggregate = strategy.beforeAttempt(realm, token, aggregate);

                Account account = null;
                Throwable t = null;
                try {
                    account = realm.getAccount(token);
                } catch (Throwable throwable) {
                    t = throwable;
                    if (log.isTraceEnabled()) {
                        String msg = ""Realm ["" + realm + ""] threw an exception during a multi-realm authentication attempt:"";
                        log.trace(msg, t);
                    }
                }

                aggregate = strategy.afterAttempt(realm, token, account, aggregate, t);

            } else {
                if (log.isDebugEnabled()) {
                    log.debug(""Realm of type ["" + realm + ""] does not support token "" +
                            ""["" + token + ""].  Skipping realm."");
                }
            }
        }

        aggregate = strategy.afterAllAttempts(token, aggregate);

        return aggregate;
    }
"	Performs the multi-realm authentication attempt by calling back to a  ModularAuthenticationStrategy object as each realm is consulted for AuthenticationInfo for the specified token.	Performs the multi-realm authentication attempt by calling back to a ModularAuthenticationStrategy object as each realm is consulted for Account for the specified token.	1	0	16	47	264
"protected Object convertDateToEpochDaysAsDate(Column column, Field fieldDefn, Object data) { // epoch is the fallback value return convertValue(column, fieldDefn, data, new java.util.Date(0L), (r) -> { try { int epochDay = Date.toEpochDay(data, adjuster); long epochMillis = TimeUnit.DAYS.toMillis(epochDay); r.deliver(new java.util.Date(epochMillis)); } catch (IllegalArgumentException e) { logger.warn(""Unexpected JDBC DATE value for field {} with schema {}: class={}, value={}"", fieldDefn.name(), fieldDefn.schema(), data.getClass(), data); } }); }"	"    protected Object convertDateToEpochDaysAsDate(Column column, Field fieldDefn, Object data) {
        if (data == null && !fieldDefn.schema().isOptional()) {
            data = fieldDefn.schema().defaultValue();
        }
        if (data == null) {
            if (column.isOptional()) return null;
            return new java.util.Date(0L); // return epoch
        }
        try {
            int epochDay = Date.toEpochDay(data, adjuster);
            long epochMillis = TimeUnit.DAYS.toMillis(epochDay);
            return new java.util.Date(epochMillis);
        } catch (IllegalArgumentException e) {
            logger.warn(""Unexpected JDBC DATE value for field {} with schema {}: class={}, value={}"", fieldDefn.name(),
                        fieldDefn.schema(), data.getClass(), data);
            return null;
        }
    }
"	Converts a value object for an expected JDBC type of  Types#DATE to the number of days past epoch, but represented as a  java.util.Date value at midnight on the date.	Converts a value object for an expected JDBC type of Types#DATE to the number of days past epoch, but represented as a java.util.Date value at midnight on the date.	0	1	12	14	132
public boolean areTablesToBeUpdated(Set tables) { return areTablesToUpdated( updates, tables ) || areTablesToUpdated( insertions, tables ) || areTablesToUpdated( unresolvedInsertions.getDependentEntityInsertActions(), tables ) || areTablesToUpdated( deletions, tables ) || areTablesToUpdated( collectionUpdates, tables ) || areTablesToUpdated( collectionCreations, tables ) || areTablesToUpdated( collectionQueuedOps, tables ) || areTablesToUpdated( collectionRemovals, tables ); }	"	public boolean areTablesToBeUpdated(Set tables) {
		return areTablesToUpdated( updates, tables ) ||
				areTablesToUpdated( insertions, tables ) ||
				areTablesToUpdated( unresolvedInsertions.getDependentEntityInsertActions(), tables ) ||
				areTablesToUpdated( deletions, tables ) ||
				areTablesToUpdated( collectionUpdates, tables ) ||
				areTablesToUpdated( collectionCreations, tables ) ||
				areTablesToUpdated( collectionRemovals, tables );
	}
"	Check whether the given tables/query-spaces are to be executed against given the currently queued actions.	Check whether the given tables/query-spaces are to be executed against given the currently queued actions.	0	1	12	11	76
public double get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }	"    public double get(WithAttributes attributes) {
        return attributes.getAttributes().get(this);
    }
"	Extracts the attribute map from the specified  WithAttributes and returns the value of this attribute from the map.	Analogous to #get(WithAttributes) except returning a primitive double.	1	0	6	5	19
"static HintStrategyTable createHintStrategies(HintStrategyTable.Builder builder) { return builder .addHintStrategy(""no_hash_join"", HintStrategies.JOIN) .addHintStrategy(""time_zone"", HintStrategies.SET_VAR) .addHintStrategy(""REPARTITION"", HintStrategies.SET_VAR) .addHintStrategy(""index"", HintStrategies.TABLE_SCAN) .addHintStrategy(""properties"", HintStrategies.TABLE_SCAN) .addHintStrategy( ""resource"", HintStrategies.or( HintStrategies.PROJECT, HintStrategies.AGGREGATE, HintStrategies.CALC)) .addHintStrategy(""AGG_STRATEGY"", HintStrategies.AGGREGATE, (hint, errorHandler) -> errorHandler.check( hint.listOptions.size() == 1 && (hint.listOptions.get(0).equalsIgnoreCase(""ONE_PHASE"") || hint.listOptions.get(0).equalsIgnoreCase(""TWO_PHASE"")), ""Hint {} only allows single option, "" + ""allowed options: [ONE_PHASE, TWO_PHASE]"", hint.hintName )) .addHintStrategy(""use_hash_join"", HintStrategies.and(HintStrategies.JOIN, HintStrategies.explicit((hint, rel) -> { if (!(rel instanceof LogicalJoin)) { return false; } LogicalJoin join = (LogicalJoin) rel; final List<String> tableNames = hint.listOptions; final List<String> inputTables = join.getInputs().stream() .filter(input -> input instanceof TableScan) .map(scan -> Util.last(scan.getTable().getQualifiedName())) .collect(Collectors.toList()); return equalsStringList(tableNames, inputTables); }))) .build(); }"	"    private static HintStrategyTable createHintStrategies() {
      return HintStrategyTable.builder()
        .addHintStrategy(""no_hash_join"", HintStrategies.JOIN)
        .addHintStrategy(""time_zone"", HintStrategies.SET_VAR)
        .addHintStrategy(""REPARTITION"", HintStrategies.SET_VAR)
        .addHintStrategy(""index"", HintStrategies.TABLE_SCAN)
        .addHintStrategy(""properties"", HintStrategies.TABLE_SCAN)
        .addHintStrategy(
            ""resource"", HintStrategies.or(
            HintStrategies.PROJECT, HintStrategies.AGGREGATE, HintStrategies.CALC))
        .addHintStrategy(""AGG_STRATEGY"", HintStrategies.AGGREGATE)
        .addHintStrategy(""use_hash_join"",
          HintStrategies.and(HintStrategies.JOIN,
            HintStrategies.explicit((hint, rel) -> {
              if (!(rel instanceof LogicalJoin)) {
                return false;
              }
              LogicalJoin join = (LogicalJoin) rel;
              final List<String> tableNames = hint.listOptions;
              final List<String> inputTables = join.getInputs().stream()
                  .filter(input -> input instanceof TableScan)
                  .map(scan -> Util.last(scan.getTable().getQualifiedName()))
                  .collect(Collectors.toList());
              return equalsStringList(tableNames, inputTables);
            })))
        .build();
    }
"	Creates mock hint strategies with given builder.	Creates mock hint strategies.	1	0	16	37	266
public static Set<ImmutableBitSet> getUniqueKeys(RelNode rel) { final BuiltInMetadata.UniqueKeys metadata = rel.metadata(BuiltInMetadata.UniqueKeys.class); return metadata.getUniqueKeys(false); }	"  public static Set<BitSet> getUniqueKeys(RelNode rel) {
    final BuiltInMetadata.UniqueKeys metadata =
        rel.metadata(BuiltInMetadata.UniqueKeys.class);
    return metadata.getUniqueKeys(false);
  }
"	Returns the  BuiltInMetadata.UniqueKeys#getUniqueKeys(boolean) statistic.	Returns the BuiltInMetadata.UniqueKeys#getUniqueKeys(boolean) statistic.	0	1	7	6	30
@Override public boolean equals(Object obj) { if (obj != null && obj.getClass().equals(this.getClass())) { NoteObject that = (NoteObject) obj; if (content == null && that.getContent() != null) return false; if (content != null && !content.equals(that.getContent())) return false; } return true; }	"	@Override
	public boolean equals(Object obj) {
		if (obj != null && obj.getClass().equals(this.getClass())) {
			NoteObject that = (NoteObject) obj;
			return (this.content.equals(that.getContent()));
		}
		return false;
	}
"	Tests if two notes are equal.	Tests if two contents are equal.	1	0	8	12	78
public boolean hasPath(final String path, final boolean consistent) { return hasPath(path, consistent, null); }	"  public boolean hasPath(final String path, final boolean consistent) {
    Preconditions.checkNotNull(path, ""path is required"");

    final String target = PathUtils.join(root, path);
    try {
      if (consistent) {
        return curator.checkExists().forPath(target) != null;
      } else {
        return getCache().getCurrentData(target) != null;
      }
    } catch (final Exception e) {
      throw new DrillRuntimeException(""error while checking path on zookeeper"", e);
    }
  }
"	Returns true if path exists, false otherwise.	Checks if the given path exists.	1	0	5	4	24
"public BuildResult getPreviousResult() { ResultAction<? extends BuildResult> action = getPreviousAction(); if (action != null) { return action.getResult(); } throw new NoSuchElementException(""No previous result available""); }"	"    public BuildResult getPreviousResult() {
        return getPreviousAction().getResult();
    }
"	Returns the previous build result.	Returns the action of the previous build.	1	0	6	9	42
public static Path createTestingPath(String relativePath) { return Paths.get(dataDir(), relativePath).toAbsolutePath(); }	"        public static Path createTestingPath(String relativePath) {
            return Paths.get(""target/data"", relativePath).toAbsolutePath();
        }
"	Create the path to a file within the test data directory at the given relative path.	Create the path to a file within the test data directory at the given relative path.	0	1	5	4	24
public EReference getTopic_Comments() { return (EReference) topicEClass.getEStructuralFeatures().get(1); }	"	public EReference getTopic_Comments() {
		return (EReference) topicEClass.getEStructuralFeatures().get(2);
	}
"	Returns the meta object for the containment reference list '  org.eclipse.mylyn.reviews.core.model.ITopic#getComments Comments'.	Returns the meta object for the reference list ' org.eclipse.mylyn.reviews.core.model.ITopic#getComments Comments'.	1	0	7	5	20
public boolean searchText(String text, int minimumNumberOfMatches, boolean scroll) { return searcher.searchWithTimeoutFor(TextView.class, text, minimumNumberOfMatches, scroll, false); }	"	public boolean searchText(String text, int minimumNumberOfMatches, boolean scroll) {
		return searcher.searchWithTimeoutFor(TextView.class, text, minimumNumberOfMatches, scroll);
	}
"	Searches for a text string and returns  true if the searched text is found a given number of times.	Searches for a text string and returns true if the searched text is found a given number of times.	0	1	6	4	31
private boolean isSameText() { ArrayList<TextView> textViewList = soloView.getCurrentTextViews(null); int size = textViewList.size(); int constant = 0; if (size > 2) constant = 2; else constant = size; if (checkTextView != null && !checkTextView.getText().equals( textViewList.get(size - constant).getText())) { checkTextView = textViewList.get(size - constant); return false; } else if (checkTextView == null) { checkTextView = textViewList.get(size - constant); return false; } else return true; }	"	private boolean isSameText() {
		ArrayList<TextView> textViewList = soloView.getCurrentTextViews(null);
		int size = textViewList.size();
		int constant = 0;
		if (size > 2)
			constant = 2;
		else
			constant = size;
		
		if (checkTextView != null
				&& !checkTextView.getText().equals(
						soloView.getCurrentTextViews(null).get(
								soloView.getCurrentTextViews(null).size()
										- constant).getText())) {
			checkTextView = textViewList.get(size - constant);
			return true;
		} else if (checkTextView == null) {
			checkTextView = textViewList.get(size - constant);
			return true;
		}
		else
			return false;
	}
"	Determines if a previous text is the same as the current.	Determines if no more scrolling can be done.	1	0	10	22	103
public DateTimeFormatterBuilder appendDayOfWeekShortText() { return appendShortText(DateTimeFieldType.dayOfWeek()); }	"    public DateTimeFormatterBuilder appendDayOfWeekShortText() {
        return appendShortText(iChronoUTC.dayOfWeek());
    }
"	Instructs the printer to emit a short locale-specific dayOfWeek text.	Instructs the printer to emit a short locale-specific dayOfWeek text.	0	1	5	4	16
"public WebSocket doWebSocketConnect(final HttpServletRequest request, final String protocol) { logger.info(""WebSocket upgrade requested""); return new JettyWebSocketListener(request,this); }"	"    protected WebSocket doWebSocketConnect(final HttpServletRequest request, final String protocol) {
        logger.info(""WebSocket upgrade requested"");

        return new WebSocket() {
            private WebSocketProcessor webSocketProcessor;

            @Override
            public void onConnect(WebSocket.Outbound outbound) {
                webSocketProcessor = new WebSocketProcessor(AtmosphereServlet.this, new JettyWebSocketSupport(outbound));
                try {
                    webSocketProcessor.connect(new JettyRequestFix(request));
                } catch (IOException e) {
                    logger.warn(""failed to connect to web socket"", e);
                }
            }

            @Override
            public void onMessage(byte frame, String data) {
                webSocketProcessor.broadcast(frame, data);
            }

            @Override
            public void onMessage(byte frame, byte[] data, int offset, int length) {
                webSocketProcessor.broadcast(frame, new String(data, offset, length));
            }

            @Override
            public void onFragment(boolean more, byte opcode, byte[] data, int offset, int length) {
                webSocketProcessor.broadcast(opcode, new String(data, offset, length));
            }

            @Override
            public void onDisconnect() {
                webSocketProcessor.close();
            }
        };
    }
"	Jetty 7.2 & 8.0.0-M1/M2and up WebSocket support.	Jetty 7 and up WebSocket support.	1	0	5	6	33
public long getExecutionRowCount() { return executionRowCount.sum(); }	"	public long getExecutionRowCount() {
		return executionRowCount.get();
	}
"	Number of lines returned by all the executions of this query (from DB)	Number of lines returned by all the executions of this query (from DB)	0	1	4	4	13
protected Object convertDouble(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0.0d; } if (data instanceof Double) return data; if (data instanceof Number) { // Includes BigDecimal and other numeric values ... Number value = (Number) data; return new Double(value.doubleValue()); } if (data instanceof Boolean) { return NumberConversions.getDouble((Boolean) data); } return handleUnknownData(column, fieldDefn, data); }	"    protected Object convertDouble(Column column, Field fieldDefn, Object data) {
        if (data == null) {
            data = fieldDefn.schema().defaultValue();
        }
        if (data == null) {
            if (column.isOptional()) return null;
            return 0.0d;
        }
        if (data instanceof Double) return data;
        if (data instanceof Number) {
            // Includes BigDecimal and other numeric values ...
            Number value = (Number) data;
            return new Double(value.doubleValue());
        }
        if (data instanceof Boolean) {
            return ((Boolean) data).booleanValue() ? DOUBLE_TRUE : DOUBLE_FALSE;
        }
        return handleUnknownData(column, fieldDefn, data);
    }
"	Converts a value object for an expected JDBC type of  Types#DOUBLE.	Converts a value object for an expected JDBC type of Types#DOUBLE.	0	1	8	20	122
protected String getNewIdFor(EObject element_p) { return copyXmlIds()? null: EcoreUtil.generateUUID(); }	"  protected String getNewIdFor(EObject element_p) {
    return copyPhysicalIds()? null: EcoreUtil.generateUUID();
  }
"	Return a new unique intrinsic ID for the given element, if relevant.	Return a new unique Ecore identifier for the given element, if relevant.	1	0	5	5	21
private int waitForSocket(Launcher launcher, int port, int timeout) { try { LocalPortReceiveAdbPortTask task = new LocalPortReceiveAdbPortTask(port, timeout); return launcher.getChannel().call(task); } catch (InterruptedException ex) { // Ignore } catch (IOException e) { // Ignore } return -1; }	"    private boolean waitForSocket(Launcher launcher, int port, int timeout) {
        try {
            LocalPortOpenTask task = new LocalPortOpenTask(port, timeout);
            return launcher.getChannel().call(task);
        } catch (InterruptedException ex) {
            // Ignore
        } catch (IOException e) {
            // Ignore
        }

        return false;
    }
"	Waits for an emulator to say what socket its using, or times out.	Waits for a socket on the remote machine's localhost to become available, or times out.	1	0	7	13	62
public static StringExpression type(EntityPath<?> path) { return StringOperation.create(JPQLOps.TYPE, path); }	"    public static StringExpression type(EntityPath<?> path) {
        return StringOperation.create(JPQLTemplates.TYPE, path);
    }
"	Get the type(path) expression	Get the type(path) expression	0	1	5	4	21
public float getY() { if(top == null) { calculateTop(); } return top.floatValue(); }	"    public float getY() {
        return center[1];
    }
"	Get the y position of the top of this shape.	Get the y location of the center of this circle	1	0	6	9	24
"public String toString() { if ( connString == null ) { String wrappedString; try { wrappedString = getRealConnection().toString(); } catch ( SQLException e ) { wrappedString = ""<none>""; } connString = this.getClass().getName() + ""@"" + this.hashCode() + "", Wrapped Connection = "" + wrappedString; } return connString; }"	"    public String toString() 
    {
        try
        {
            return getRealConnection().toString();
        }
        catch ( SQLException e )
        {
            return ""<no connection>"";
        }
    }
"	Get the string representation for this connection.	Get the string representation for the underlying physical connection.	1	0	12	22	69
"public boolean supports(AuthenticationToken token) { if ( log.isInfoEnabled() ) { log.info( ""Received null AuthenticationToken. Returning false for supports(token) implementation (can't "" + ""process null tokens)."" ); } return token != null && getAuthenticationTokenClass().isAssignableFrom(token.getClass()); }"	"    public boolean supports(Class tokenClass) {
        return getAuthenticationTokenClass().isAssignableFrom( tokenClass );
    }
"	Convenience implementation that returns getAuthenticationTokenClass().isAssignableFrom( token.getClass() );.	Convenience implementation that returns getAuthenticationTokenClass().isAssignableFrom( tokenClass );.	1	0	8	9	64
"private SortResults mergeSpilledRuns() { logger.debug(""Starting consolidate phase. Batches = {}, Records = {}, Memory = {}, In-memory batches {}, spilled runs {}"", metrics.getInputBatchCount(), metrics.getInputRowCount(), allocator.getAllocatedMemory(), bufferedBatches.size(), spilledRuns.size()); // Consolidate batches to a number that can be merged in // a single last pass. loop: for (;;) { MergeTask task = memManager.consolidateBatches( allocator.getAllocatedMemory(), bufferedBatches.size(), spilledRuns.size()); switch (task.action) { case SPILL: spillFromMemory(); break; case MERGE: mergeRuns(task.count); break; case NONE: break loop; default: throw new IllegalStateException(""Unexpected action: "" + task.action); } } int mergeRowCount = memManager.getMergeBatchRowCount(); return spilledRuns.finalMerge(bufferedBatches.removeAll(), outputBatch, mergeRowCount, allocHelper); }"	"  private SortResults mergeSpilledRuns() {
    logger.debug(""Starting consolidate phase. Batches = {}, Records = {}, Memory = {}, In-memory batches {}, spilled runs {}"",
                 metrics.getInputBatchCount(), metrics.getInputRowCount(),
                 allocator.getAllocatedMemory(),
                 bufferedBatches.size(), spilledRuns.size());

    // Consolidate batches to a number that can be merged in
    // a single last pass.

    loop:
    for (;;) {
      MergeTask task = memManager.consolidateBatches(
          allocator.getAllocatedMemory(),
          bufferedBatches.size(),
          spilledRuns.size());
      switch (task.action) {
      case SPILL:
        spillFromMemory();
        break;
      case MERGE:
        mergeRuns(task.count);
        break;
      case NONE:
        break loop;
      default:
        throw new IllegalStateException(""Unexpected action: "" + task.action);
      }
    }

    int mergeRowCount = memManager.getMergeBatchRowCount();
    return spilledRuns.finalMerge(bufferedBatches.removeAll(), outputBatch, mergeRowCount);
  }
"	Perform merging of (typically spilled) batches.	Perform merging of (typically spilled) batches.	0	1	10	33	185
protected MedicationMedicalRecordBodyType mapBody(final EHREXTRACT ehrExtract, final int compositionIndex) { final COMPOSITION composition = ehrExtract.getAllCompositions().get(compositionIndex); // parse this composition into values stored in a Map Map<String,String> ehr13606values = retrieveValues(composition, compositionIndex); // use the ehr values to build a medication medical history record body return buildBody(ehr13606values); }	"    protected MedicationMedicalRecordBodyType mapBody(final EHREXTRACT ehrExtract, final int compositionIndex) {
        final COMPOSITION composition = ehrExtract.getAllCompositions().get(compositionIndex);

        final MedicationMedicalRecordBodyType bodyType = new MedicationMedicalRecordBodyType();
        
        
        AdditionalPatientInformationType apit = new AdditionalPatientInformationType();
        apit.setDateOfBirth(""2010-01-31"");
        
        CVType gender = new CVType();
        gender.setCode(""abc"");
        gender.setCodeSystem(""def"");
        gender.setDisplayName(""ghi"");
        gender.setOriginalText(""jkl"");
        apit.setGender(gender);
        
        bodyType.setAdditionalPatientInformation(apit);
        
        MedicationPrescriptionType mpt = new MedicationPrescriptionType();
        
        mpt.setDispensationAuthorization(new DispensationAuthorizationType());
        mpt.setEndOfTreatment(""2014-12-31"");
        mpt.setEndOfTreatmentReason(new CVType());
        mpt.setEvaluator(new HealthcareProfessionalType());
        mpt.setPrecedingPrescriptionId(new IIType());
        mpt.setPrescriber(new HealthcareProfessionalType());
        mpt.setPrescriptionChainId(new IIType());
        mpt.setPrescriptionId(new IIType());
        mpt.setPrescriptionStatus(new CVType());
        mpt.setSelfMedication(false);
        mpt.setStartOfFirstTreatment(""2014-01-31"");
        mpt.setSucceedingPrescriptionId(new IIType());
        mpt.setTypeOfPrescription(TypeOfPrescriptionEnum.INSTTNING);
        
        bodyType.setMedicationPrescription(mpt);

        for (final CONTENT content : composition.getContent()) {
            for (final ITEM item : ((ENTRY) content).getItems()) {
            	
            	
            	log.debug(item.getMeaning().getCode() + "" "" + item.getMeaning().getDisplayName().getValue() + "" "" + (item instanceof ELEMENT ? ""ELEMENT"" : ""CLUSTER""));

                switch (item.getMeaning().getCode()) {
                    case ""lkm-ord-tid"":   // Ordinationstidpunkt
                        mpt.setStartOfTreatment(""2014-02-28"");
                        log.debug(item.getMeaning().getCode() + "" "" + item.getMeaning().getDisplayName().getValue() + "" "" + EHRUtil.getElementTextValue((ELEMENT)item));
                        break;
                    case ""lkm-ord-not"":   // Notat
                        mpt.setPrescriptionNote(""Here is a note"");
                        log.debug(item.getMeaning().getCode() + "" "" + item.getMeaning().getDisplayName().getValue() + "" "" + EHRUtil.getElementTextValue((ELEMENT)item));
                        break;
                    case ""lkm-ord-utv"":   // Utvrderingstidpunkt
                        mpt.setEvaluationTime(""123"");
                        log.debug(item.getMeaning().getCode() + "" "" + item.getMeaning().getDisplayName().getValue() + "" "" + EHRUtil.getElementTextValue((ELEMENT)item));
                        break;
                    case ""lkm-ord-and"":   // ndaml
                        mpt.setTreatmentPurpose(""There is a purpose to this treatment"");
                        log.debug(item.getMeaning().getCode() + "" "" + item.getMeaning().getDisplayName().getValue() + "" "" + EHRUtil.getElementTextValue((ELEMENT)item));
                        break;
                        

                    case ""lkm-dos""    :   // Dosering
                        log.debug(item.getMeaning().getCode() + "" "" + item.getMeaning().getDisplayName().getValue());
                    	CLUSTER c = (CLUSTER)item;
                    	List<ITEM> parts = c.getParts();
                    	for (ITEM part : parts) {
                        	log.debug(part.getMeaning().getCode());
                            if (""lkm-dst"".equals(part.getMeaning().getCode())) {
                                c = (CLUSTER)part;
                                
                                List<ITEM> dosparts = c.getParts();
                                for (ITEM dospart : dosparts) {
                                    log.debug(dospart.getMeaning().getCode() + "" "" + dospart.getMeaning().getDisplayName().getValue() + "" "" + EHRUtil.getElementTextValue((ELEMENT)dospart));
                                }
                            }
                        }
                        break;
                        
                    case ""lkm-lva""    :   // Lkemedelsval
                        log.debug(item.getMeaning().getCode() + "" "" + item.getMeaning().getDisplayName().getValue());
                        c = (CLUSTER)item;
                        parts = c.getParts();
                        for (ITEM part : parts) {
                            log.debug(part.getMeaning().getCode());
                            
                            switch (item.getMeaning().getCode()) {
                            case ""lkm-lva-kom"" :
                                log.debug(part.getMeaning().getCode() + "" "" + part.getMeaning().getDisplayName().getValue() + "" "" + EHRUtil.getElementTextValue((ELEMENT)part));
                                break;
                            case ""lkm-lva-typ"" :
                                log.debug(part.getMeaning().getCode() + "" "" + part.getMeaning().getDisplayName().getValue() + "" "" + EHRUtil.getElementTextValue((ELEMENT)part));
                                break;
                            case ""lkm-lva-ext"" :
                                log.debug(part.getMeaning().getCode() + "" "" + part.getMeaning().getDisplayName().getValue() + "" "" + EHRUtil.getElementTextValue((ELEMENT)part));
                                break;
                            case ""lkm-lkm-lva"":
                                log.debug(part.getMeaning().getCode() + "" "" + part.getMeaning().getDisplayName().getValue() + "" "" + EHRUtil.getElementTextValue((ELEMENT)part));
                                break;
                            }
                        }
                        // mpt.setDrug(new DrugChoiceType());
                        // EHRUtil.getElementTextValue((ELEMENT)item);
                        break;
                        
                        
                    case ""lkm-for-tid"":   // Frskrivningstidpunkt
                        mpt.setStartOfTreatment(""2014-02-28"");
                        break;
                    case ""lkm-for-uiv"":   // Utlmningsintervall
                        log.debug(item.getMeaning().getCode() + "" "" + item.getMeaning().getDisplayName().getValue() + "" "" + EHRUtil.getElementTextValue((ELEMENT)item));
                        break;
                    case ""lkm-for-mpt"":   // Mngd per tillflle
                        log.debug(item.getMeaning().getCode() + "" "" + item.getMeaning().getDisplayName().getValue() + "" "" + EHRUtil.getElementTextValue((ELEMENT)item));
                        break;
                    case ""lkm-for-tot"":   // Totalmngd
                        log.debug(item.getMeaning().getCode() + "" "" + item.getMeaning().getDisplayName().getValue() + "" "" + EHRUtil.getElementTextValue((ELEMENT)item));
                        break;
                    case ""lkm-for-fpe"":   // Frpackningsenhet
                        log.debug(item.getMeaning().getCode() + "" "" + item.getMeaning().getDisplayName().getValue() + "" "" + EHRUtil.getElementTextValue((ELEMENT)item));
                        break;
                    case ""lkm-for-dbs"":   // Distributionsstt
                        log.debug(item.getMeaning().getCode() + "" "" + item.getMeaning().getDisplayName().getValue() + "" "" + EHRUtil.getElementTextValue((ELEMENT)item));
                        break;
                }
            }
        }
        return bodyType;
    }
"	Create a MedicationMedicalRecord using the information in the current ehr13606 composition.	Maps contact body information.	1	0	7	12	69
public Integer getSocksVersion() { return socksVersion; }	"  public String getSocksVersion() {
    return socksVersion;
  }
"	Gets the SOCKS version (4 or 5).	Gets the SOCKS version (4 or 5).	0	1	4	4	10
public Set<ClassInfo> getInterfaces() { String[] names = classGen.getInterfaceNames(); Set<ClassInfo> interfaces = new HashSet<ClassInfo>(names.length); for (String name : names) { ClassInfo cls = getAppInfo().getClassInfo(name); if (cls != null) { interfaces.add(cls); } } return interfaces; }	"    public Collection<ClassInfo> getInterfaces() {
        return interfaces;
    }
"	Get a set of all (loaded) interfaces this class directly implements.	Get a collection of all (loaded) interfaces this class directly implements.	1	0	9	13	64
public CreateTableEntry createNewTable(String tableName, List<String> partitionColumns) { return createNewTable(tableName, partitionColumns, StorageStrategy.DEFAULT); }	"  public CreateTableEntry createNewTable(String tableName, List<String> partitionColumns) {
    return createNewTable(tableName, partitionColumns, StorageStrategy.PERSISTENT);
  }
"	Creates table entry using table name and list of partition columns if any.	Creates table entry using table name and list of partition columns if any.	0	1	6	4	24
public static ScannableTable generate(int width, int height, int seed) { return new MazeTable(width, height, seed, false); }	"  public static ScannableTable generate(int width, int height, int seed) {
    return new MazeTable(width, height, seed);
  }
"	Table function that generates a maze.	Called by reflection based on the definition of the user-defined function in the schema.	1	0	5	4	29
public boolean onStartJob(final JobParameters jobParameters) { mFetchWeatherTask = new AsyncTask<Void, Void, Void>(){ @Override protected Void doInBackground(Void... voids) { Context context = getApplicationContext(); SunshineSyncTask.syncWeather(context); return null; } @Override protected void onPostExecute(Void aVoid) { // COMPLETED (6) Once the weather data is sync'd, call jobFinished with the appropriate arguements jobFinished(jobParameters, false); } }; mFetchWeatherTask.execute(); return true; }	"    public boolean onStartJob(final JobParameters jobParameters) {

        mFetchWeatherThread = new Thread(new Runnable() {
            @Override
            public void run() {

                Context context = getApplicationContext();
                SunshineSyncTask.syncWeather(context);
//              COMPLETED (6) Once the weather data is sync'd, call jobFinished with the appropriate arguements
                jobFinished(jobParameters, false);
            }
        });

        mFetchWeatherThread.start();

        return true;
    }
"	The entry point to your Job.	The entry point to your Job.	0	1	9	21	96
private byte[] read(InputStream in, int length) throws IOException { byte[] buffer = new byte[length]; int bytesRead = 0; do { bytesRead += in.read(buffer); } while (length != bytesRead); int freeSpace = currentFrame.capacity() - currentFrame.position(); if (freeSpace < bytesRead) { currentFrame = reallocate(currentFrame, currentFrame.position() + bytesRead); } // add bytes to current frame and reset to be able to read again currentFrame.put(buffer); return buffer; }	"		private ByteBuffer read(SocketChannel channel, int length) throws IOException {
			ByteBuffer buffer = ByteBuffer.allocate(length);
			
			int bytesRead = 0;
			do {
				bytesRead += channel.read(buffer);
			} while (length != bytesRead);
			
			buffer.flip();
			
			int freeSpace = currentFrame.capacity() - currentFrame.position();
			if (freeSpace < bytesRead) {
				currentFrame = reallocate(currentFrame, currentFrame.position() + bytesRead);
			}

			// add bytes to current frame and reset to be able to read again
			currentFrame.put(buffer);
			buffer.rewind();
			
			return buffer;
		}
"	Reads given length from the given stream.	Reads given length from the channel.	1	0	9	19	104
protected Object convertTimeToMicrosPastMidnight(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0L; // return epoch } try { return MicroTime.toMicroOfDay(data, adjuster); } catch (IllegalArgumentException e) { return handleUnknownData(column, fieldDefn, data); } }	"    protected Object convertTimeToMicrosPastMidnight(Column column, Field fieldDefn, Object data) {
        if (data == null) {
            data = fieldDefn.schema().defaultValue();
        }
        if (data == null) {
            if (column.isOptional()) return null;
            return 0L; // return epoch
        }
        try {
            return MicroTime.toMicroOfDay(data);
        } catch (IllegalArgumentException e) {
            return handleUnknownData(column, fieldDefn, data);
        }
    }
"	Converts a value object for an expected JDBC type of  Types#TIME to  MicroTime values, or microseconds past midnight.	Converts a value object for an expected JDBC type of Types#TIME to MicroTime values, or microseconds past midnight.	0	1	8	15	84
"protected String readAnnouncement( File file ) throws MojoExecutionException { InputStreamReader reader = null; FileInputStream inputStream = null; try { inputStream = new FileInputStream( file ); if ( StringUtils.isEmpty( templateEncoding ) ) { templateEncoding = ReaderFactory.FILE_ENCODING; getLog().warn( ""File encoding has not been set, using platform encoding '"" + templateEncoding + ""', i.e. build is platform dependent!"" ); } reader = new InputStreamReader( inputStream, templateEncoding ); return IOUtil.toString( reader ); } catch ( FileNotFoundException fnfe ) { throw new MojoExecutionException( ""File not found. "" + file ); } catch ( UnsupportedEncodingException uee ) { throw new MojoExecutionException( ""Unsupported encoding: '"" + templateEncoding + ""'"" ); } catch ( IOException ioe ) { throw new MojoExecutionException( ""Failed to read the announcement file."", ioe ); } finally { IOUtil.close( inputStream ); IOUtil.close( reader ); } }"	"    protected FileReader readAnnouncement( File file )
        throws MojoExecutionException
    {
        FileReader fileReader;
        try
        {
            fileReader = new FileReader( file );
        }
        catch ( FileNotFoundException fnfe )
        {
            throw new MojoExecutionException( ""File not found. "" + file );
        }
        return fileReader;
    }
"	Read the content of the generated announcement file.	Read the announcement generated file.	1	0	11	39	176
@NonNull protected List<Action> retrieveActions(@NonNull SCMRevision revision, @NonNull SCMHeadEvent event, @NonNull TaskListener listener) throws IOException, InterruptedException { return Collections.emptyList(); }	"    @NonNull
    protected Map<Class<? extends Action>, Action> retrieveActions(@NonNull SCMRevision revision,
                                                                   @NonNull TaskListener listener)
            throws IOException, InterruptedException {
        return Collections.emptyMap();
    }
"	SPI for  #fetchActions(SCMRevision, SCMHeadEvent, TaskListener).	SPI for #fetchActions(SCMRevision, TaskListener).	1	0	5	9	34
public long getBlockIfSessionPoolIsFullTimeout() { return this.sessionPool.getMaxWaitMillis(); }	"    public long getBlockIfSessionPoolIsFullTimeout() {
        return this.sessionPool.getMaxWait();
    }
"	Returns the timeout to use for blocking creating new sessions	Returns the timeout to use for blocking creating new sessions	0	1	5	4	14
protected int getInSubqueryThreshold() { return config.getInSubqueryThreshold(); }	"  protected int getInSubqueryThreshold() {
    return IN_SUBQUERY_THRESHOLD;
  }
"	Gets the list size threshold under which  #convertInToOr is used.	Gets the list size threshold under which #convertInToOr is used.	0	1	4	4	13
"public CompletableFuture<ExecutionResult> executeAsync(ExecutionInput executionInput) { try { log.debug(""Executing request. operation name: {}. query: {}. variables {} "", executionInput.getOperationName(), executionInput.getQuery(), executionInput.getVariables()); InstrumentationState instrumentationState = instrumentation.createState(); InstrumentationExecutionParameters instrumentationParameters = new InstrumentationExecutionParameters(executionInput, this.graphQLSchema, instrumentationState); InstrumentationContext<ExecutionResult> executionInstrumentation = instrumentation.beginExecution(instrumentationParameters); CompletableFuture<ExecutionResult> executionResult = parseValidateAndExecute(executionInput, instrumentationState); // // finish up instrumentation executionResult = executionResult.whenComplete(executionInstrumentation::onEnd); // // allow instrumentation to tweak the result executionResult = executionResult.thenCompose(result -> instrumentation.instrumentExecutionResult(result, instrumentationParameters)); return executionResult; } catch (AbortExecutionException abortException) { ExecutionResultImpl executionResult = new ExecutionResultImpl(abortException); return CompletableFuture.completedFuture(executionResult); } }"	"    public CompletableFuture<ExecutionResult> executeAsync(ExecutionInput executionInput) {
        log.debug(""Executing request. operation name: {}. query: {}. variables {} "", executionInput.getOperationName(), executionInput.getQuery(), executionInput.getVariables());

        InstrumentationState instrumentationState = instrumentation.createState();

        InstrumentationExecutionParameters instrumentationParameters = new InstrumentationExecutionParameters(executionInput, instrumentationState);
        InstrumentationContext<ExecutionResult> executionInstrumentation = instrumentation.beginExecution(instrumentationParameters);
        CompletableFuture<ExecutionResult> executionResult = parseValidateAndExecute(executionInput, instrumentationState);
        //
        // finish up instrumentation
        executionResult = executionResult.whenComplete(executionInstrumentation::onEnd);
        //
        // allow instrumentation to tweak the result
        executionResult = executionResult.thenCompose(result -> instrumentation.instrumentExecutionResult(result, instrumentationParameters));
        return executionResult;
    }
"	Executes the graphql query using the provided input object 	Executes the graphql query using the provided input object	0	1	9	22	155
"public static GitlabRepositoryName create(final String url) { LOGGER.log(Level.FINE, ""Constructing from URL {0}"", url); for (Pattern p : URL_PATTERNS) { Matcher m = p.matcher(url.trim()); if (m.matches()) { LOGGER.log(Level.FINE, ""URL matches {0}"", m); GitlabRepositoryName ret = new GitlabRepositoryName(m.group(1), m.group(2), m.group(3)); LOGGER.log(Level.FINE, ""Object is {0}"", ret); return ret; } } LOGGER.log(Level.WARNING, ""Could not match URL {0}"", url); return null; }"	"    public static GitHubRepositoryName create(final String url) {
        LOGGER.log(Level.FINE, ""Constructing from URL {0}"", url);
        for (Pattern p : URL_PATTERNS) {
            Matcher m = p.matcher(url.trim());
            if (m.matches()) {
                LOGGER.log(Level.FINE, ""URL matches {0}"", m);
                GitHubRepositoryName ret = new GitHubRepositoryName(m.group(1), m.group(2),
                        m.group(3));
                LOGGER.log(Level.FINE, ""Object is {0}"", ret);
                return ret;
            }
        }
        LOGGER.log(Level.WARNING, ""Could not match URL {0}"", url);
        return null;
    }
"	Create  GitlabRepositoryName from URL	Create GitHubRepositoryName from URL	1	0	11	17	141
public final FileChannel getChannel() { synchronized(this) { if(channel == null) { channel = FileChannelFactory.getFileChannel(this, fd.descriptor, options); } return channel; } }	"    public final synchronized FileChannel getChannel() {
        return channel;
    }
"	Gets this file's  FileChannel object.	Returns the FileChannel equivalent to this stream.	1	0	9	11	36
public List getImageSrcs(boolean duplicate) { if (duplicate) { return this.htmlHandler.getAllImageSrcs(); } return this.htmlHandler.getImageSrcs(); }	"    public List getImageSrcs(boolean duplicate) {
        if (duplicate) {
            return htmlHandler.getAllImageSrcs();
        } else {
            return htmlHandler.getImageSrcs();
        }
    }
"	Get Image src attributes	DOCUMENT ME!	1	0	7	8	29
"public static GridRole find(String[] args) { if (args == null) { return NOT_GRID; } for (int i = 0; i < args.length; i++) { if (""-role"".equals(args[i])) { if (i == args.length - 1) { return null; } else { String role = args[i + 1].toLowerCase(); if (nodeAliases.contains(role)) { return NODE; } else if (""hub"".equals(role)) { return HUB; } else if (""standalone"".equals(role)) { return NOT_GRID; } else { return null; } } } } return NOT_GRID; }"	"  public static GridRole find(String[] args) {
    if (args == null) {
      return NOT_GRID;
    }
    for (int i = 0; i < args.length; i++) {
      if (""-role"".equals(args[i])) {
        if (i == args.length - 1) {
          throw new GridConfigurationException(
              ""-role needs to be followed by the role of this component in the grid."");
        } else {
          String role = args[i + 1].toLowerCase();
          if (nodeAliases.contains(role)) {
            return NODE;
          } else if (""hub"".equals(role)) {
            return HUB;
          } else if (""standalone"".equals(role)) {
            return NOT_GRID;
          } else {
            return null;
          }
        }
      }
    }
    return NOT_GRID;
  }
"	finds the requested role from the parameters.	finds the requested role from the parameters.	0	1	14	25	136
"public Object getPathComponent(int index) { int pathLength = getPathCount(); if(index < 0 || index >= pathLength) throw new IllegalArgumentException(""Index "" + index + "" is out of the specified range""); TreePath path = this; for(int i = pathLength-1; i != index; i--) { path = path.getParentPath(); } return path.getLastPathComponent(); }"	"    public Object getPathComponent(int element) {
        int          pathLength = getPathCount();

        if(element < 0 || element >= pathLength)
            throw new IllegalArgumentException(""Index "" + element + "" is out of the specified range"");

        TreePath         path = this;

        for(int i = pathLength-1; i != element; i--) {
           path = path.parentPath;
        }
        return path.lastPathComponent;
    }
"	Returns the path element at the specified index.	Returns the path component at the specified index.	1	0	8	16	78
protected EngineParameterMetaData getParameterMetaData() throws SQLException { if (stmtPmeta != null) return stmtPmeta; stmtPmeta = ((EnginePreparedStatement)ps).getEmbedParameterSetMetaData(); return stmtPmeta; }	"	protected EmbedParameterSetMetaData getParameterMetaData() throws SQLException
	{
		if (stmtPmeta != null)
			return stmtPmeta;

		EmbedParameterSetMetaData pmeta = null;
		Class[] getParameterMetaDataParam = {};
		try {
			Method sh =
				getPreparedStatement().getClass().getMethod(""getEmbedParameterSetMetaData"", getParameterMetaDataParam);
			pmeta = (EmbedParameterSetMetaData)
				sh.invoke(getPreparedStatement(),null);
			stmtPmeta = pmeta;
		}
		catch (Exception e) {
			handleReflectionException(e);
		}
		return stmtPmeta;
	}
"	Retrieve the ParameterMetaData for the prepared statement.	Get parameter metadata from EmbedPreparedStatement or	1	0	6	11	32
public SqlTester getTester() { return new SqlTesterImpl(new AdvisorTesterFactory()); }	"  public Tester getTester(SqlConformance conformance) {
    return new AdvisorTestImpl(conformance);
  }
"	Converts a list to a string, one item per line.	Converts a list to a string, one item per line.	0	1	6	4	17
public boolean peek() { if (outputQueue.isEmpty()) { return false; } else { final int nextId = outputQueue.peek().id; return orderResults ? nextId == lastReturnedId + 1 : true; } }	"  public boolean peek() {
    if (outputQueue.isEmpty()) {
      return false;
    } else {
       return orderResults ? outputQueue.containsKey(returnedItemCounter + 1) : true;
    }
  }
"	Indicates whether a not a new result is available.	Indicates whether or not a new result is available.	1	0	9	9	41
"public ResponseEntity<ModelApiResponse> uploadFileWithRequiredFileWithHttpInfo(Long petId, File requiredFile, String additionalMetadata) throws RestClientException { Object postBody = null; // verify the required parameter 'petId' is set if (petId == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'petId' when calling uploadFileWithRequiredFile""); } // verify the required parameter 'requiredFile' is set if (requiredFile == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile""); } // create path and map variables final Map<String, Object> uriVariables = new HashMap<String, Object>(); uriVariables.put(""petId"", petId); String path = apiClient.expandPath(""/fake/{petId}/uploadImageWithRequiredFile"", uriVariables); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); if (additionalMetadata != null) formParams.add(""additionalMetadata"", additionalMetadata); if (requiredFile != null) formParams.add(""requiredFile"", new FileSystemResource(requiredFile)); final String[] accepts = { ""application/json"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { ""multipart/form-data"" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { ""petstore_auth"" }; ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {}; return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType); }"	"    public ResponseEntity<ModelApiResponse> uploadFileWithRequiredFileWithHttpInfo(Long petId, File requiredFile, String additionalMetadata) throws RestClientException {
        Object postBody = null;
        
        // verify the required parameter 'petId' is set
        if (petId == null) {
            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'petId' when calling uploadFileWithRequiredFile"");
        }
        
        // verify the required parameter 'requiredFile' is set
        if (requiredFile == null) {
            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile"");
        }
        
        // create path and map variables
        final Map<String, Object> uriVariables = new HashMap<String, Object>();
        uriVariables.put(""petId"", petId);
        String path = apiClient.expandPath(""/fake/{petId}/uploadImageWithRequiredFile"", uriVariables);

        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();
        final HttpHeaders headerParams = new HttpHeaders();
        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();

        if (additionalMetadata != null)
            formParams.add(""additionalMetadata"", additionalMetadata);
        if (requiredFile != null)
            formParams.add(""requiredFile"", new FileSystemResource(requiredFile));

        final String[] accepts = { 
            ""application/json""
        };
        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);
        final String[] contentTypes = { 
            ""multipart/form-data""
        };
        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);

        String[] authNames = new String[] { ""petstore_auth"" };

        ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {};
        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);
    }
"	uploads an image (required) 200 - successful operation	uploads an image (required) 200 - successful operation	0	1	8	43	336
public ParameterList getBodyParams() { return bodyParams; }	"  public Map<String, String> getBodyParams()
  {
    return bodyParams;
  }
"	Obtains a  ParameterList of the body parameters.	Obtains a Map of the body parameters.	1	0	4	6	10
protected Control initControl(boolean ignoreProxyError) { if (!Control.initSingletonWithoutView(getControlOverrides()) && ! ignoreProxyError) { return null; } return Control.getSingleton(); }	"    protected Control initControl() {
        Control.initSingletonWithoutViewAndProxy(getControlOverrides());
        return Control.getSingleton();
    }
"	Initialises the  Control singleton without view.	Initialises the Control singleton without view and proxy.	1	0	6	8	35
public boolean evaluate(S object) { return ev.<Boolean>evaluate(object); }	"            public boolean evaluate(S object) {
                return QueryIteratorUtils.<Boolean>evaluate(ev, object);
            }            
"	filter the given iterator using the given expressionevaluator that evaluates to true / false	filter the given iterator using the given expressionevaluator that evaluates to true / false	0	1	6	4	17
public double getContentPosition() { return mBundle.getDouble(KEY_CONTENT_POSITION, -1); }	"    public long getContentPosition() {
        return mBundle.getLong(KEY_CONTENT_POSITION, -1);
    }
"	Gets the content playback position as a floating point number of seconds from the beginning of the content.	Gets the content playback position as a long integer number of milliseconds from the beginning of the content.	1	0	5	5	17
public Vector getErrors() { return _parser.getErrors(); }	"    public ArrayList<ErrorMsg> getErrors() {
        return _parser.getErrors();
    }
"	Get a Vector containing all compile error messages	Get a list of all compile error messages	1	0	4	5	13
public int getMinimumValue() { return DateTimeConstants.MONDAY; }	"    public int getMinimumValue() {
        return MIN;
    }
"	Get the minimum value that this field can have.	Get the minimum value that this field can have.	0	1	4	4	11
public static InboundContext getActiveSessionAndProducer() { return threadLocal.get(); }	"    public static InboundContext getActiveSessionAndProducer() {
        return (InboundContext) threadLocal.get();
    }
"	Returns the current  InboundContext used by the current thread which is processing a message.	Returns the current InboundContext used by the current thread which is processing a message.	0	1	4	4	14
"public <T extends Server> Server getServer(Class<T> clazz, String name) { for (Server server : getServers()){ if (server.isValid() && server.getLabel().getName().equals(name)){ return server.getAdapter(clazz); } } log.info(""Requested server '"" + name + ""' was not found on Servers view""); log.info(""Available servers are: "" + LoggingUtils.format(getServersNames())); throw new EclipseLayerException(""There is no server with name "" + name); }"	"	public <T extends Server> T getServer(Class<T> clazz, String name) {
		for (Server server : getServers()){
			if (server.isValid() && server.getLabel().getName().equals(name)){
				return server.getAdapter(clazz);
			}
		}
		log.info(""Requested server '"" + name + ""' was not found on Servers view"");
		log.info(""Available servers are: "" + LoggingUtils.format(getServersNames()));
		throw new EclipseLayerException(""There is no server with name "" + name);
	}
"	Gets a server of specified type with a given name	Gets a server of specified type with the given name.	1	0	9	12	113
"public Object getValue(PgProto.DatumMessage datumMessage, PgConnectionSupplier connection, boolean includeUnknownDatatypes) { int columnType = (int) datumMessage.getColumnType(); switch (columnType) { case PgOid.BOOL: return datumMessage.hasDatumBool() ? datumMessage.getDatumBool() : null; case PgOid.INT2: case PgOid.INT4: return datumMessage.hasDatumInt32() ? datumMessage.getDatumInt32() : null; case PgOid.INT8: case PgOid.OID: case PgOid.MONEY: return datumMessage.hasDatumInt64() ? datumMessage.getDatumInt64() : null; case PgOid.FLOAT4: return datumMessage.hasDatumFloat()? datumMessage.getDatumFloat() : null; case PgOid.FLOAT8: return datumMessage.hasDatumDouble() ? datumMessage.getDatumDouble() : null; case PgOid.NUMERIC: if (datumMessage.hasDatumDouble()) { // For backwards compatibility only to enable independent upgrade of Postgres plug-in return datumMessage.getDatumDouble(); } else if (datumMessage.hasDatumString()) { final String s = datumMessage.getDatumString(); return PostgresValueConverter.toSpecialValue(s).orElseGet(() -> new SpecialValueDecimal(new BigDecimal(s))); } return null; case PgOid.CHAR: case PgOid.VARCHAR: case PgOid.BPCHAR: case PgOid.TEXT: case PgOid.JSON: case PgOid.JSONB_OID: case PgOid.XML: case PgOid.UUID: case PgOid.BIT: case PgOid.VARBIT: case PgOid.INET_OID: case PgOid.CIDR_OID: case PgOid.MACADDR_OID: case PgOid.MACADDR8_OID: return datumMessage.hasDatumString() ? datumMessage.getDatumString() : null; case PgOid.DATE: return datumMessage.hasDatumInt32() ? (long) datumMessage.getDatumInt32() : null; case PgOid.TIMESTAMP: if (!datumMessage.hasDatumInt64()) { return null; } // these types are sent by the plugin as LONG - microseconds since Unix Epoch return Conversions.toInstantFromMicros(datumMessage.getDatumInt64()); case PgOid.TIMESTAMPTZ: if (!datumMessage.hasDatumInt64()) { return null; } // these types are sent by the plugin as LONG - microseconds since Unix Epoch return Conversions.toInstantFromMicros(datumMessage.getDatumInt64()).atOffset(ZoneOffset.UTC); case PgOid.TIME: if (!datumMessage.hasDatumInt64()) { return null; } // these types are sent by the plugin as LONG - microseconds since Unix Epoch return Duration.of(datumMessage.getDatumInt64(), ChronoUnit.MICROS); case PgOid.TIMETZ: if (!datumMessage.hasDatumDouble()) { return null; } // the value is sent as a double microseconds return Conversions.toInstantFromMicros((long) datumMessage.getDatumDouble()) .atOffset(ZoneOffset.UTC) .toOffsetTime(); case PgOid.INTERVAL: // these are sent as doubles by the plugin since their storage is larger than 8 bytes return datumMessage.hasDatumDouble() ? datumMessage.getDatumDouble() : null; // the plugin will send back a TZ formatted string case PgOid.BYTEA: return datumMessage.hasDatumBytes() ? datumMessage.getDatumBytes().toByteArray() : null; case PgOid.POINT: { PgProto.Point datumPoint = datumMessage.getDatumPoint(); return new PGpoint(datumPoint.getX(), datumPoint.getY()); } case PgOid.TSRANGE_OID: case PgOid.TSTZRANGE_OID: case PgOid.DATERANGE_OID: case PgOid.INT4RANGE_OID: case PgOid.NUM_RANGE_OID: case PgOid.INT8RANGE_OID: return datumMessage.hasDatumBytes() ? new String(datumMessage.getDatumBytes().toByteArray(), Charset.forName(""UTF-8"")) : null; case PgOid.INT2_ARRAY: case PgOid.INT4_ARRAY: case PgOid.INT8_ARRAY: case PgOid.TEXT_ARRAY: case PgOid.NUMERIC_ARRAY: case PgOid.FLOAT4_ARRAY: case PgOid.FLOAT8_ARRAY: case PgOid.BOOL_ARRAY: case PgOid.DATE_ARRAY: case PgOid.TIME_ARRAY: case PgOid.TIMETZ_ARRAY: case PgOid.TIMESTAMP_ARRAY: case PgOid.TIMESTAMPTZ_ARRAY: case PgOid.BYTEA_ARRAY: case PgOid.VARCHAR_ARRAY: case PgOid.OID_ARRAY: case PgOid.BPCHAR_ARRAY: case PgOid.MONEY_ARRAY: case PgOid.NAME_ARRAY: case PgOid.INTERVAL_ARRAY: case PgOid.CHAR_ARRAY: case PgOid.VARBIT_ARRAY: case PgOid.UUID_ARRAY: case PgOid.XML_ARRAY: case PgOid.POINT_ARRAY: case PgOid.JSONB_ARRAY: case PgOid.JSON_ARRAY: case PgOid.REF_CURSOR_ARRAY: case PgOid.INET_ARRAY: case PgOid.CIDR_ARRAY: case PgOid.MACADDR_ARRAY: case PgOid.MACADDR8_ARRAY: case PgOid.TSRANGE_ARRAY: case PgOid.TSTZRANGE_ARRAY: case PgOid.DATERANGE_ARRAY: case PgOid.INT4RANGE_ARRAY: case PgOid.NUM_RANGE_ARRAY: case PgOid.INT8RANGE_ARRAY: return getArray(datumMessage, connection, columnType); case PgOid.UNSPECIFIED: return null; default: PostgresType type = typeRegistry.get(columnType); if (type.getOid() == typeRegistry.geometryOid() || type.getOid() == typeRegistry.geographyOid() || type.getOid() == typeRegistry.citextOid() ) { return datumMessage.getDatumBytes().toByteArray(); } if(type.getOid() == typeRegistry.hstoreOid()) { return datumMessage.getDatumBytes().toByteArray(); } if (type.getOid() == typeRegistry.geometryArrayOid() || type.getOid() == typeRegistry.geographyArrayOid() || type.getOid() == typeRegistry.citextArrayOid() || type.getOid() == typeRegistry.hstoreArrayOid()) { return getArray(datumMessage, connection, columnType); } // unknown data type is sent by decoder as binary value if (includeUnknownDatatypes && datumMessage.hasDatumBytes()) { return datumMessage.getDatumBytes().toByteArray(); } return null; } }"	"    public Object getValue(PgProto.DatumMessage datumMessage, PgConnectionSupplier connection, boolean includeUnknownDatatypes) {
        int columnType = (int) datumMessage.getColumnType();
        switch (columnType) {
            case PgOid.BOOL:
                return datumMessage.hasDatumBool() ? datumMessage.getDatumBool() : null;
            case PgOid.INT2:
            case PgOid.INT4:
                return datumMessage.hasDatumInt32() ? datumMessage.getDatumInt32() : null;
            case PgOid.INT8:
            case PgOid.OID:
            case PgOid.MONEY:
                return datumMessage.hasDatumInt64() ? datumMessage.getDatumInt64() : null;
            case PgOid.FLOAT4:
                return datumMessage.hasDatumFloat()? datumMessage.getDatumFloat() : null;
            case PgOid.FLOAT8:
                return datumMessage.hasDatumDouble() ? datumMessage.getDatumDouble() : null;
            case PgOid.NUMERIC:
                if (datumMessage.hasDatumDouble()) {
                    // For backwards compatibility only to enable independent upgrade of Postgres plug-in
                    return datumMessage.getDatumDouble();
                }
                else if (datumMessage.hasDatumString()) {
                    final String s = datumMessage.getDatumString();
                    return PostgresValueConverter.toSpecialValue(s).orElseGet(() -> new SpecialValueDecimal(new BigDecimal(s)));
                }
                return null;
            case PgOid.CHAR:
            case PgOid.VARCHAR:
            case PgOid.BPCHAR:
            case PgOid.TEXT:
            case PgOid.JSON:
            case PgOid.JSONB_OID:
            case PgOid.XML:
            case PgOid.UUID:
            case PgOid.BIT:
            case PgOid.VARBIT:
            case PgOid.INET_OID:
            case PgOid.CIDR_OID:
            case PgOid.MACADDR_OID:
            case PgOid.MACADDR8_OID:
                return datumMessage.hasDatumString() ? datumMessage.getDatumString() : null;
            case PgOid.DATE:
                return datumMessage.hasDatumInt32() ? (long) datumMessage.getDatumInt32() : null;
            case PgOid.TIMESTAMP:
                if (!datumMessage.hasDatumInt64()) {
                    return null;
                }
                // these types are sent by the plugin as LONG - microseconds since Unix Epoch
                // but we'll convert them to nanos which is the smallest unit
                final LocalDateTime serverLocal = Conversions.toLocalDateTimeUTC(datumMessage.getDatumInt64());
                return Conversions.toEpochNanos(serverLocal.toInstant(ZoneOffset.UTC));
            case PgOid.TIMESTAMPTZ:
            case PgOid.TIME:
                if (!datumMessage.hasDatumInt64()) {
                    return null;
                }
                // these types are sent by the plugin as LONG - microseconds since Unix Epoch
                // but we'll convert them to nanos which is the smallest unit
                return TimeUnit.NANOSECONDS.convert(datumMessage.getDatumInt64(), TimeUnit.MICROSECONDS);
            case PgOid.TIMETZ:
                if (!datumMessage.hasDatumDouble()) {
                    return null;
                }
                // the value is sent as a double microseconds, convert to nano
                return BigDecimal.valueOf(datumMessage.getDatumDouble() * 1000).longValue();
            case PgOid.INTERVAL:
                // these are sent as doubles by the plugin since their storage is larger than 8 bytes
                return datumMessage.hasDatumDouble() ? datumMessage.getDatumDouble() : null;
            // the plugin will send back a TZ formatted string
            case PgOid.BYTEA:
                return datumMessage.hasDatumBytes() ? datumMessage.getDatumBytes().toByteArray() : null;
            case PgOid.POINT: {
                PgProto.Point datumPoint = datumMessage.getDatumPoint();
                return new PGpoint(datumPoint.getX(), datumPoint.getY());
            }
            case PgOid.TSRANGE_OID:
            case PgOid.TSTZRANGE_OID:
            case PgOid.DATERANGE_OID:
            case PgOid.INT4RANGE_OID:
            case PgOid.NUM_RANGE_OID:
            case PgOid.INT8RANGE_OID:
                return datumMessage.hasDatumBytes() ? new String(datumMessage.getDatumBytes().toByteArray(), Charset.forName(""UTF-8"")) : null;
            case PgOid.INT2_ARRAY:
            case PgOid.INT4_ARRAY:
            case PgOid.INT8_ARRAY:
            case PgOid.TEXT_ARRAY:
            case PgOid.NUMERIC_ARRAY:
            case PgOid.FLOAT4_ARRAY:
            case PgOid.FLOAT8_ARRAY:
            case PgOid.BOOL_ARRAY:
            case PgOid.DATE_ARRAY:
            case PgOid.TIME_ARRAY:
            case PgOid.TIMETZ_ARRAY:
            case PgOid.TIMESTAMP_ARRAY:
            case PgOid.TIMESTAMPTZ_ARRAY:
            case PgOid.BYTEA_ARRAY:
            case PgOid.VARCHAR_ARRAY:
            case PgOid.OID_ARRAY:
            case PgOid.BPCHAR_ARRAY:
            case PgOid.MONEY_ARRAY:
            case PgOid.NAME_ARRAY:
            case PgOid.INTERVAL_ARRAY:
            case PgOid.CHAR_ARRAY:
            case PgOid.VARBIT_ARRAY:
            case PgOid.UUID_ARRAY:
            case PgOid.XML_ARRAY:
            case PgOid.POINT_ARRAY:
            case PgOid.JSONB_ARRAY:
            case PgOid.JSON_ARRAY:
            case PgOid.REF_CURSOR_ARRAY:
            case PgOid.INET_ARRAY:
            case PgOid.CIDR_ARRAY:
            case PgOid.MACADDR_ARRAY:
            case PgOid.MACADDR8_ARRAY:
            case PgOid.TSRANGE_ARRAY:
            case PgOid.TSTZRANGE_ARRAY:
            case PgOid.DATERANGE_ARRAY:
            case PgOid.INT4RANGE_ARRAY:
            case PgOid.NUM_RANGE_ARRAY:
            case PgOid.INT8RANGE_ARRAY:
            return getArray(datumMessage, connection, columnType);

            case PgOid.UNSPECIFIED:
                return null;

            default:
                PostgresType type = typeRegistry.get(columnType);
                if (type.getOid() == typeRegistry.geometryOid() || type.getOid() == typeRegistry.geographyOid() || type.getOid() == typeRegistry.citextOid() ) {
                    return datumMessage.getDatumBytes().toByteArray();
                }
                if(type.getOid() == typeRegistry.hstoreOid()) {
                    return datumMessage.getDatumBytes().toByteArray();
                }
                if (type.getOid() == typeRegistry.geometryArrayOid() ||
                        type.getOid() == typeRegistry.geographyArrayOid() ||
                        type.getOid() == typeRegistry.citextArrayOid() ||
                        type.getOid() == typeRegistry.hstoreArrayOid()) {
                    return getArray(datumMessage, connection, columnType);
                }
                // unknown data type is sent by decoder as binary value
                if (includeUnknownDatatypes && datumMessage.hasDatumBytes()) {
                    return datumMessage.getDatumBytes().toByteArray();
                }

                return null;
        }
    }
"	Converts the Protobuf value for a  io.debezium.connector.postgresql.proto.PgProto.DatumMessage plugin message to a Java value based on the type of the column from the message.	Converts the Protobuf value for a io.debezium.connector.postgresql.proto.PgProto.DatumMessage plugin message to a Java value based on the type of the column from the message.	0	1	14	153	961
"public String[] getDropSchemaCommand(String schemaName) { return new String[] {""drop schema "" + schemaName}; }"	"	public String getDropSchemaCommand(String schemaName) {
		return ""drop schema "" + schemaName;
	}
"	Get the SQL command used to drop the named schema	Get the SQL command used to drop the named schema	0	1	7	4	25
private Integer findColumn(String columnName) throws SQLException { return columnNameCache.getIndexForColumnName( columnName, rs ); }	"	private int findColumn(String columnName) throws SQLException {
		return columnNameCache.getIndexForColumnName( columnName, rs );
	}
"	Locate the column index corresponding to the given column name via the cache.	Locate the column index corresponding to the given column name via the cache.	0	1	5	4	20
protected final Enumeration elements() { return _contents.elements(); }	"    protected final Iterator<SyntaxTreeNode> elements() {
        return _contents.iterator();
    }
"	Returns an Enumeration of all child nodes of this node.	Returns an Iterator of all child nodes of this node.	1	0	4	5	14
public static Predicate<Connectivity> hasState(final NetworkInfo.State... states) { return new Predicate<Connectivity>() { @Override public boolean test(@NonNull Connectivity connectivity) throws Exception { for (NetworkInfo.State state : states) { if (connectivity.state() == state) { return true; } } return false; } }; }	"  public static Predicate<Connectivity> hasState(final NetworkInfo.State... states) {
    return new Predicate<Connectivity>() {
      @Override public boolean test(@NonNull Connectivity connectivity) throws Exception {
        for (NetworkInfo.State state : states) {
          if (connectivity.getState() == state) {
            return true;
          }
        }
        return false;
      }
    };
  }
"	Filter, which returns true if at least one given state occurred	Filter, which returns true if at least one given state occurred	0	1	11	13	63
public RexNode makeZeroLiteral(RelDataType type) { return makeLiteral(zeroValue(type), type, false); }	"  public RexNode makeZeroLiteral(RelDataType type, boolean allowCast) {
    if (type.isNullable()) {
      type = typeFactory.createTypeWithNullability(type, false);
    }
    RexLiteral literal;
    switch (type.getSqlTypeName()) {
    case CHAR:
      return makeCharLiteral(
          new NlsString(Util.spaces(type.getPrecision()), null, null));
    case VARCHAR:
      literal = makeCharLiteral(new NlsString("""", null, null));
      if (allowCast) {
        return makeCast(type, literal);
      } else {
        return literal;
      }
    case BINARY:
      return makeBinaryLiteral(
          new ByteString(new byte[type.getPrecision()]));
    case VARBINARY:
      literal = makeBinaryLiteral(ByteString.EMPTY);
      if (allowCast) {
        return makeCast(type, literal);
      } else {
        return literal;
      }
    case TINYINT:
    case SMALLINT:
    case INTEGER:
    case BIGINT:
    case DECIMAL:
      return makeExactLiteral(BigDecimal.ZERO, type);
    case FLOAT:
    case REAL:
    case DOUBLE:
      return makeApproxLiteral(BigDecimal.ZERO, type);
    case BOOLEAN:
      return booleanFalse;
    case TIME:
      return makeTimeLiteral(
          DateTimeUtil.zeroCalendar, type.getPrecision());
    case DATE:
      return makeDateLiteral(DateTimeUtil.zeroCalendar);
    case TIMESTAMP:
      return makeTimestampLiteral(
          DateTimeUtil.zeroCalendar, type.getPrecision());
    default:
      throw Util.unexpected(type.getSqlTypeName());
    }
  }
"	Creates a literal of the default value for the given type.	Creates an expression of the default value for the given type, casting if necessary to ensure that the expression is the exact type.	1	0	6	4	22
public static Iterable<Runnable> thread(final String title, Iterable<Runnable> runnables){ //--Preparation //(variables) final AtomicBoolean haveStarted = new AtomicBoolean(false); final ReentrantLock metaInfoLock = new ReentrantLock(); final AtomicInteger numPending = new AtomicInteger(0); final Iterator<Runnable> iter = runnables.iterator(); //--Create Runnables return new IterableIterator<>(new Iterator<Runnable>() { @Override public boolean hasNext() { synchronized (iter) { return iter.hasNext(); } } @Override public synchronized Runnable next() { final Runnable runnable; synchronized (iter) { runnable = iter.next(); } // (don't flood the queu) while (numPending.get() > 100) { try { Thread.sleep(100); } catch (InterruptedException e) { } } numPending.incrementAndGet(); // (add the job) Runnable toReturn = new Runnable(){ public void run(){ boolean threadFinished = false; try{ //(signal start of threads) metaInfoLock.lock(); if(!haveStarted.getAndSet(true)){ startThreads(title); //<--this must be a blocking operation } metaInfoLock.unlock(); //(run runnable) try{ runnable.run(); } catch (Exception e){ e.printStackTrace(); System.exit(1); } catch (AssertionError e) { e.printStackTrace(); System.exit(1); } //(signal end of thread) finishThread(); threadFinished = true; //(signal end of threads) int numStillPending = numPending.decrementAndGet(); synchronized (iter) { if (numStillPending <= 0 && !iter.hasNext()) { endThreads(title); } } } catch(Throwable t){ t.printStackTrace(); if (!threadFinished) { finishThread(); } } } }; return toReturn; } @Override public void remove() { synchronized (iter) { iter.remove(); } } }); }	"    public static Iterable<Runnable> thread(final String title, Iterable<Runnable> runnables){
      //--Preparation
      //(variables)
      final AtomicBoolean haveStarted = new AtomicBoolean(false);
      final ReentrantLock metaInfoLock = new ReentrantLock();
      final AtomicInteger numPending = new AtomicInteger(0);
      final Iterator<Runnable> iter = runnables.iterator();
      //--Create Runnables
      return new IterableIterator<>(new Iterator<Runnable>() {
        @Override
        public boolean hasNext() {
          return iter.hasNext();
        }
        @Override
        public synchronized Runnable next() {
          final Runnable runnable = iter.next();
          // (don't flood the queu)
          while (numPending.get() > 100) {
            try { Thread.sleep(100); }
            catch (InterruptedException e) { }
          }
          numPending.incrementAndGet();
          // (add the job)
          Runnable toReturn = new Runnable(){
            public void run(){
              boolean threadFinished = false;
              try{
                //(signal start of threads)
                metaInfoLock.lock();
                if(!haveStarted.getAndSet(true)){
                  startThreads(title); //<--this must be a blocking operation
                }
                metaInfoLock.unlock();
                //(run runnable)
                try{
                  runnable.run();
                } catch (Exception e){
                  e.printStackTrace();
                  System.exit(1);
                } catch (AssertionError e) {
                  e.printStackTrace();
                  System.exit(1);
                }
                //(signal end of thread)
                finishThread();
                threadFinished = true;
                //(signal end of threads)
                int numStillPending = numPending.decrementAndGet();
                if(numStillPending <= 0 && !iter.hasNext()){
                  endThreads(title);
                }
              } catch(Throwable t){
                t.printStackTrace();
                if (!threadFinished) { finishThread(); }
              }
            }
          };
          return toReturn;
        }

        @Override
        public void remove() {
          iter.remove();
        }
      });
    }
"	Wrap a collection of threads (Runnables) to be logged by Redwood.	Wrap a collection of threads (Runnables) to be logged by Redwood.	0	1	17	76	393
static Folder fromXml(Context context) { return (Folder) LayoutInflater.from(context).inflate(R.layout.user_folder, null); }	"    static Folder fromXml(Launcher launcher) {
        return (Folder) launcher.getLayoutInflater().inflate(R.layout.user_folder, null);
    }
"	Creates a new UserFolder, inflated from R.layout.user_folder.	Creates a new UserFolder, inflated from R.layout.user_folder.	0	1	7	4	27
public static Folder resolveFolder(Folder dir, String relativePath) { final String[] fragments = StringUtils.split(relativePath, '/'); if (ArrayUtils.isEmpty(fragments)) { return dir; } return resolveFolder(dir, Arrays.stream(fragments).iterator()); }	"	public static Folder resolveFolder(Folder dir, String relativePath) {
		final String[] fragments = StringUtils.split(relativePath, '/');
		if (ArrayUtils.isEmpty(fragments)) {
			throw new IllegalArgumentException(""Empty relativePath"");
		}
		return resolveFolder(dir, Arrays.stream(fragments).iterator());
	}
"	Resolves a relative path (separated by '/') to a folder, e.g.	Resolves a relative path (separated by '/') to a folder, e.g.	0	1	6	8	56
public final int getBeginLine() { return this.bufline[this.tokenBegin]; }	"    public final int getBeginLine() {
        return bufline[tokenBegin];
    }
"	Get the line begin	DOCUMENT ME!	1	0	7	5	16
public ApiResponse<Void> deleteOrderWithHttpInfo(String orderId) throws ApiException { okhttp3.Call localVarCall = deleteOrderValidateBeforeCall(orderId, null, null); return localVarApiClient.execute(localVarCall); }	"    public ApiResponse<Void> deleteOrderWithHttpInfo(String orderId) throws ApiException {
        okhttp3.Call call = deleteOrderValidateBeforeCall(orderId, null, null);
        return apiClient.execute(call);
    }
"	Delete purchase order by ID	Delete purchase order by ID	0	1	6	5	31
"public boolean applyAPSRequest(APSResult request, Callback callback) { PumpInterface pump = getActivePump(); request.rate = applyBasalConstraints(request.rate); if (!pump.isInitialized()) { log.debug(""applyAPSRequest: "" + MainApp.sResources.getString(R.string.pumpNotInitialized)); if (callback != null) { callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpNotInitialized)).enacted(false).success(false)).run(); } return false; } if (pump.isSuspended()) { log.debug(""applyAPSRequest: "" + MainApp.sResources.getString(R.string.pumpsuspended)); if (callback != null) { callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpsuspended)).enacted(false).success(false)).run(); } return false; } if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: "" + request.toString()); if ((request.rate == 0 && request.duration == 0) || Math.abs(request.rate - pump.getBaseBasalRate()) < pump.getPumpDescription().basalStep) { if (isTempBasalInProgress()) { if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: cancelTempBasal()""); getCommandQueue().cancelTempBasal(false, callback); if (request.smb == 0) return true; } else { if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: Basal set correctly""); if (callback != null) { callback.result(new PumpEnactResult().absolute(request.rate).duration(0).enacted(false).success(true).comment(""Basal set correctly"")).run(); } if (request.smb == 0) return false; } } else if (isTempBasalInProgress() && getTempBasalRemainingMinutesFromHistory() > 5 && Math.abs(request.rate - getTempBasalAbsoluteRateHistory()) < pump.getPumpDescription().basalStep) { if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: Temp basal set correctly""); if (callback != null) { callback.result(new PumpEnactResult().absolute(getTempBasalAbsoluteRateHistory()).duration(getTempBasalFromHistory(System.currentTimeMillis()).getPlannedRemainingMinutes()).enacted(false).success(true).comment(""Temp basal set correctly"")).run(); } if (request.smb == 0) return false; } else { if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: setTempBasalAbsolute()""); getCommandQueue().tempBasalAbsolute(request.rate, request.duration, false, callback); if (request.smb == 0) return true; } log.debug(""SMB requested in config is: "" + request.smb); if (request.smb != 0) { long lastBolusTime = getLastBolusTime(); if (lastBolusTime != 0 && lastBolusTime + 3 * 60 * 1000 > System.currentTimeMillis()) { log.debug(""SMB requsted but still in 3 min interval""); } else { DetailedBolusInfo detailedBolusInfo = new DetailedBolusInfo(); detailedBolusInfo.eventType = CareportalEvent.CORRECTIONBOLUS; detailedBolusInfo.insulin = request.smb; detailedBolusInfo.isSMB = true; detailedBolusInfo.source = Source.USER; boolean smbDelivered = getCommandQueue().bolus(detailedBolusInfo, callback); if (smbDelivered) return true; else return false; } } return true; }"	"    public boolean applyAPSRequest(APSResult request, Callback callback) {
        PumpInterface pump = getActivePump();
        request.rate = applyBasalConstraints(request.rate);
        PumpEnactResult result;

        if (!pump.isInitialized()) {
            log.debug(""applyAPSRequest: "" + MainApp.sResources.getString(R.string.pumpNotInitialized));
            if (callback != null) {
                callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpNotInitialized)).enacted(false).success(false)).run();
            }
            return false;
        }

        if (pump.isSuspended()) {
            log.debug(""applyAPSRequest: "" + MainApp.sResources.getString(R.string.pumpsuspended));
            if (callback != null) {
                callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpsuspended)).enacted(false).success(false)).run();
            }
            return false;
        }

        if (Config.logCongigBuilderActions)
            log.debug(""applyAPSRequest: "" + request.toString());
        if ((request.rate == 0 && request.duration == 0) || Math.abs(request.rate - pump.getBaseBasalRate()) < pump.getPumpDescription().basalStep) {
            if (isTempBasalInProgress()) {
                if (Config.logCongigBuilderActions)
                    log.debug(""applyAPSRequest: cancelTempBasal()"");
                getCommandQueue().cancelTempBasal(false, callback);
                return true;
            } else {
                if (Config.logCongigBuilderActions)
                    log.debug(""applyAPSRequest: Basal set correctly"");
                if (callback != null) {
                    callback.result(new PumpEnactResult().absolute(request.rate).duration(0).enacted(false).success(true).comment(""Basal set correctly"")).run();
                }
                return false;
            }
        } else if (isTempBasalInProgress()
                && getTempBasalRemainingMinutesFromHistory() > 5
                && Math.abs(request.rate - getTempBasalAbsoluteRateHistory()) < pump.getPumpDescription().basalStep) {
            if (Config.logCongigBuilderActions)
                log.debug(""applyAPSRequest: Temp basal set correctly"");
            if (callback != null) {
                callback.result(new PumpEnactResult().absolute(getTempBasalAbsoluteRateHistory()).duration(getTempBasalFromHistory(System.currentTimeMillis()).getPlannedRemainingMinutes()).enacted(false).success(true).comment(""Temp basal set correctly"")).run();
            }
            return false;
        } else {
            if (Config.logCongigBuilderActions)
                log.debug(""applyAPSRequest: setTempBasalAbsolute()"");
            getCommandQueue().tempBasalAbsolute(request.rate, request.duration, false, callback);
            return true;
        }
    }
"	expect absolute request and allow both absolute and percent response based on pump capabilities	expect absolute request and allow both absolute and percent response based on pump capabilities	0	1	13	76	617
"private boolean searchForButton(String regex, int matches) { sleeper.sleep(); inst.waitForIdleSync(); Pattern p = Pattern.compile(regex); Matcher matcher; ArrayList<Button> buttonList = viewFetcher.getCurrentViews(Button.class); if(matches == 0) matches = 1; for(Button button : buttonList){ matcher = p.matcher(button.getText().toString()); if(matcher.find()){ countMatches++; } if (countMatches == matches) { countMatches = 0; return true; } } if (scroller.scroll(Scroller.Direction.DOWN)) { return searchForButton(regex, matches); } else { if (countMatches > 0) Log.d(LOG_TAG, "" There are only "" + countMatches + "" matches of "" + regex); countMatches = 0; return false; } }"	"	private boolean searchForButton(String search, int matches) {
		sleeper.sleep();
		inst.waitForIdleSync();
		Pattern p = Pattern.compile(search);
		Matcher matcher;
		ArrayList<Button> buttonList = viewFetcher.getCurrentViews(Button.class);
		if(matches == 0)
			matches = 1;
		for(Button button : buttonList){
			matcher = p.matcher(button.getText().toString());
			if(matcher.find()){	
				countMatches++;
			}
			if (countMatches == matches) {
				countMatches = 0;
				return true;
			} 	
		}

		if (scroller.scroll(Scroller.Direction.DOWN))
		{
			return searchForButton(search, matches);
		} else {
			if (countMatches > 0)
				Log.d(LOG_TAG, "" There are only "" + countMatches + "" matches of "" + search);
			countMatches = 0;
			return false;
		}

	}
"	Searches for a button with the given regex string and returns true if the searched button is found a given number of times	Searches for a button with the given search string and returns true if the searched button is found a given number of times	1	0	11	31	154
"public Action doCometSupport(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException { req.setAttribute(BROADCASTER_FACTORY, broadcasterFactory); req.setAttribute(PROPERTY_USE_STREAM, useStreamForFlushingComments); req.setAttribute(BROADCASTER_CLASS, broadcasterClassName); req.setAttribute(ATMOSPHERE_CONFIG, config); AtmosphereRequest r = null; Action a = null; try { if (config.getInitParameter(ALLOW_QUERYSTRING_AS_REQUEST) != null && (isIECandidate(req) || req.getParameter(HeaderConfig.JSONP_CALLBACK_NAME) != null) && req.getAttribute(WebSocket.WEBSOCKET_SUSPEND) == null) { Map<String, String> headers = configureQueryStringAsRequest(req); String body = headers.remove(ATMOSPHERE_POST_BODY); if (body != null && body.isEmpty()) { body = null; } r = new AtmosphereRequest.Builder() .headers(headers) .method(body != null && req.getMethod().equalsIgnoreCase(""GET"") ? ""POST"" : req.getMethod()) .body(body) .request(req).build(); a = cometSupport.service(r, res); } else { if (AtmosphereRequest.class.isAssignableFrom(req.getClass())) { return cometSupport.service(req, res); } else { return cometSupport.service(AtmosphereRequest.wrap(req), res); } } } catch (IllegalStateException ex) { if (ex.getMessage() != null && ex.getMessage().startsWith(""Tomcat failed"")) { if (!isFilter) { logger.warn(""Failed using comet support: {}, error: {} Is the Nio or Apr Connector enabled?"", cometSupport.getClass().getName(), ex.getMessage()); logger.warn(""Using BlockingIOCometSupport.""); } logger.trace(ex.getMessage(), ex); cometSupport = new BlockingIOCometSupport(config); doCometSupport(req, res); } else { logger.error(""AtmosphereServlet exception"", ex); throw ex; } } finally { if (r != null && a != null && a.type != Action.TYPE.SUSPEND) { r.destroy(); } } return null; }"	"    public Action doCometSupport(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException {
        req.setAttribute(BROADCASTER_FACTORY, broadcasterFactory);
        req.setAttribute(PROPERTY_USE_STREAM, useStreamForFlushingComments);
        req.setAttribute(BROADCASTER_CLASS, broadcasterClassName);
        req.setAttribute(ATMOSPHERE_CONFIG, config);

        AtmosphereRequest r = null;
        Action a = null;
        try {
            if (config.getInitParameter(ALLOW_QUERYSTRING_AS_REQUEST) != null
                    && (isIECandidate(req) || req.getParameter(HeaderConfig.JSONP_CALLBACK_NAME) != null)
                    && req.getAttribute(WebSocket.WEBSOCKET_SUSPEND) == null) {

                Map<String, String> headers = configureQueryStringAsRequest(req);
                String body = headers.remove(ATMOSPHERE_POST_BODY);
                if (body != null && body.isEmpty()) {
                    body = null;
                }

                r = new AtmosphereRequest.Builder()
                        .headers(headers)
                        .method(body != null && req.getMethod().equalsIgnoreCase(""GET"") ? ""POST"" : req.getMethod())
                        .body(body)
                        .request(req).build();

                a = cometSupport.service(r, res);
            } else {
                return cometSupport.service(AtmosphereRequest.wrap(req), res);
            }
        } catch (IllegalStateException ex) {
            if (ex.getMessage() != null && ex.getMessage().startsWith(""Tomcat failed"")) {
                if (!isFilter) {
                    logger.warn(""Failed using comet support: {}, error: {} Is the Nio or Apr Connector enabled?"", cometSupport.getClass().getName(),
                            ex.getMessage());
                    logger.warn(""Using BlockingIOCometSupport."");
                }
                logger.trace(ex.getMessage(), ex);

                cometSupport = new BlockingIOCometSupport(config);
                doCometSupport(req, res);
            } else {
                logger.error(""AtmosphereServlet exception"", ex);
                throw ex;
            }
        } finally {
            if (r != null && a != null && a.type != Action.TYPE.SUSPEND) {
                r.destroy();
            }
        }
        return null;
    }
"	Invoke the proprietary  CometSupport	Invoke the proprietary CometSupport	0	1	14	56	394
"public static TimestampedEntry parseTimestampedEntry(InputStream in) { TimestampedEntry timestampedEntry = new TimestampedEntry(); timestampedEntry.timestamp = readNumber(in, CTConstants.TIMESTAMP_LENGTH); int entryType = (int) readNumber(in, CTConstants.LOG_ENTRY_TYPE_LENGTH); timestampedEntry.entryType = Ct.LogEntryType.valueOf(entryType); Ct.SignedEntry.Builder signedEntryBuilder = Ct.SignedEntry.newBuilder(); if (entryType == Ct.LogEntryType.X509_ENTRY_VALUE) { int length = (int) readNumber(in, 3); ByteString x509 = ByteString.copyFrom(readFixedLength(in, length)); signedEntryBuilder.setX509(x509); } else if (entryType == Ct.LogEntryType.PRECERT_ENTRY_VALUE) { Ct.PreCert.Builder preCertBuilder = Ct.PreCert.newBuilder(); byte[] arr = readFixedLength(in, 32); preCertBuilder.setIssuerKeyHash(ByteString.copyFrom(arr)); // set tbs certificate arr = readFixedLength(in, 2); int length = (int) readNumber(in, 2); preCertBuilder.setTbsCertificate(ByteString.copyFrom(readFixedLength(in, length))); preCertBuilder.build(); signedEntryBuilder.setPrecert(preCertBuilder); } else { throw new SerializationException(String.format(""Unknown entry type: %d"", entryType)); } timestampedEntry.signedEntry = signedEntryBuilder.build(); return timestampedEntry; }"	"  public static Ct.TimestampedEntry parseTimestampedEntry(InputStream in) {
    Ct.TimestampedEntry.Builder timestampedEntry = Ct.TimestampedEntry.newBuilder();

    long timestamp = readNumber(in, CTConstants.TIMESTAMP_LENGTH);
    timestampedEntry.setTimestamp(timestamp);

    int entryType = (int) readNumber(in, CTConstants.LOG_ENTRY_TYPE_LENGTH);
    timestampedEntry.setEntryType(Ct.LogEntryType.valueOf(entryType));

    Ct.SignedEntry.Builder signedEntryBuilder = Ct.SignedEntry.newBuilder();
    if (entryType == Ct.LogEntryType.X509_ENTRY_VALUE) {

      int length = (int) readNumber(in, 3);
      ByteString x509 = ByteString.copyFrom(readFixedLength(in, length));
      signedEntryBuilder.setX509(x509);

    } else if (entryType == Ct.LogEntryType.PRECERT_ENTRY_VALUE) {
      Ct.PreCert.Builder preCertBuilder = Ct.PreCert.newBuilder();

      byte[] arr = readFixedLength(in, 32);
      preCertBuilder.setIssuerKeyHash(ByteString.copyFrom(arr));

      // set tbs certificate
      arr = readFixedLength(in, 2);
      int length = (int) readNumber(in, 2);

      preCertBuilder.setTbsCertificate(ByteString.copyFrom(readFixedLength(in, length)));
      preCertBuilder.build();

      signedEntryBuilder.setPrecert(preCertBuilder);
    } else {
      throw new SerializationException(String.format(""Unknown entry type: %d"", entryType));
    }
    signedEntryBuilder.build();
    timestampedEntry.setSignedEntry(signedEntryBuilder);

    return timestampedEntry.build();
  }
"	Parses a  TimestampedEntry from binary encoding.	Parses a Ct.TimestampedEntry from binary encoding.	1	0	10	38	224
protected Function<?,?> getTypeFunction(Class<?> aType) { return (Function<?,?>) defaultFunctions.get(aType); }	"    protected Function getTypeFunction( Class aType ) {
        return (Function) typeFunctions.get( aType );
    }
"	Returns a transformer for the given primitive type.	Returns a applyer for the given primitive type.	1	0	6	5	26
public static int killProcess(Process process) { if (thisIsWindows()) { return killWinProcess(process); } else { return killUnixProcess(process); } }	"  public static int killProcess(Process process) {
    int exitValue;

    // first, wait a second to see if the process will die on it's own (we will likely have asked
    // the process to kill itself just before calling this method
    try {
      exitValue = waitForProcessDeath(process, 1000);
      closeAllStreamsAndDestroyProcess( process);
      if (exitValue == 0) {
        return exitValue;
      }
    } catch (Exception e) {
      // no? ok, no biggie, now let's force kill it...
    }

    process.destroy();
    try {
      exitValue = waitForProcessDeath(process, 10000);
      closeAllStreamsAndDestroyProcess( process);
    } catch (ProcessStillAliveException ex) {
      if (Platform.getCurrent().is(Platform.WINDOWS)) {
        throw ex;
      }
      try {
        log.info(""Process didn't die after 10 seconds"");
        kill9(process);
        exitValue = waitForProcessDeath(process, 10000);
        closeAllStreamsAndDestroyProcess( process);
      } catch (Exception e) {
        log.warning(""Process refused to die after 10 seconds, and couldn't kill9 it"");
        e.printStackTrace();
        throw new RuntimeException(
            ""Process refused to die after 10 seconds, and couldn't kill9 it: "" + e.getMessage(),
            ex);
      }
    }
    return exitValue;
  }
"	"Forcibly kills a process, using OS tools like ""kill"" as a last resort"	"Forcibly kills a process, using OS tools like ""kill"" as a last resort"	0	1	7	8	33
protected Object convertBoolean(Column column, Field fieldDefn, Object data) { return convertValue(column, fieldDefn, data, false, (r) -> { if (data instanceof Boolean) { r.deliver(data); } else if (data instanceof Short) { r.deliver(((Short) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE); } else if (data instanceof Integer) { r.deliver(((Integer) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE); } else if (data instanceof Long) { r.deliver(((Long) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE); } }); }	"    protected Object convertBoolean(Column column, Field fieldDefn, Object data) {
        if (data == null && !fieldDefn.schema().isOptional()) {
            data = fieldDefn.schema().defaultValue();
        }
        if (data == null) {
            if (column.isOptional()) return null;
            return false;
        }
        if (data instanceof Boolean) return data;
        if (data instanceof Short) return ((Short) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;
        if (data instanceof Integer) return ((Integer) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;
        if (data instanceof Long) return ((Long) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;
        return handleUnknownData(column, fieldDefn, data);
    }
"	Converts a value object for an expected JDBC type of  Types#BOOLEAN.	Converts a value object for an expected JDBC type of Types#BOOLEAN.	0	1	16	17	138
public ProcessingColorProvider getProcessingColorProvider() { return (fColorProvider == null) ? new ProcessingColorProvider() : fColorProvider; }	"	 public ProcessingColorProvider getProcessingColorProvider() {
	 	if (fColorProvider == null)
			fColorProvider= new ProcessingColorProvider();
		return fColorProvider;
	}
"	Returns the shared color provider.	Returns the shared color provider.	0	1	6	4	20
public boolean isSupported(DateTimeFieldType type) { if (type == null) { return false; } return isSupported(type.getDurationType()); }	"    public boolean isSupported(DateTimeFieldType type) {
        if (type == null) {
            return false;
        }
        DateTimeField field = type.getField(getChronology());
        if (DATE_DURATION_TYPES.contains(type.getDurationType()) ||
            field.getDurationField().getUnitMillis() >= getChronology().days().getUnitMillis()) {
            return field.isSupported();
        }
        return false;
    }
"	Checks if the field type specified is supported by this local date and chronology.	Checks if the field type specified is supported by this local datetime and chronology.	1	0	6	7	28
public boolean waitForText(String text, int minimumNumberOfMatches, long timeout, boolean scroll) { TextView textView = waiter.waitForText(text, minimumNumberOfMatches, timeout, scroll); return textView != null; }	"	public boolean waitForText(String text, int minimumNumberOfMatches, long timeout, boolean scroll) {
		return waiter.waitForText(text, minimumNumberOfMatches, timeout, scroll);
    }
"	Waits for a text to be shown.	Waits for a text to be shown.	0	1	6	6	37
"public boolean isRcsAssociated(final String phoneNumber) { boolean result = false; Cursor cur = ctx.getContentResolver().query(RichAddressBookData.CONTENT_URI, new String[]{RichAddressBookData.KEY_CONTACT_NUMBER}, RichAddressBookData.KEY_CONTACT_NUMBER + ""=?"", new String[]{phoneNumber}, null); if (cur!=null){ if (cur.moveToFirst()) { result = true; } cur.close(); }else{ result = false; } return result; }"	"    public boolean isRcsAssociated(final String phoneNumber) {
    	return !getRcsRawContactIdFromPhoneNumber(phoneNumber).isEmpty();
    }
"	Utility to check if a phone number is associated to an entry in the rich address book provider	Utility to check if a phone number is associated to a RCS account	1	0	9	19	86
public String executeAs(Function<Response, Response> handler) { Type type = new TypeToken<String>(){}.getType(); return execute(handler).as(type); }	"        public String executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<String>(){}.getType();
            return getJSON().deserialize(execute(handler).asString(), type);
        }
"	POST /fake/outer/string	POST /fake/outer/string	0	1	8	5	35
"public QName getPortTypeName() { return portTypeName == null ? new QName("""") : portTypeName; }"	"    public QName getPortTypeName() {
        return portName == null ? new QName("""") : portName;
    }
"	Returns the fully qualified name of the port type for this Call object (if there is one).	Returns the fully qualified name of the port for this Call object (if there is one).	1	0	6	5	20
"@Processor @OAuthProtected @OAuthInvalidateAccessTokenOn(exception=OAuthTokenExpiredException.class) @Paged public PagingDelegate<CommentReply> listCommentReplies( final String fileId, final String commentId, final @Optional @Default(""false"") boolean includeDeleted, final @Optional @Default(""100"") int maxResults, final PagingConfiguration pagingConfiguration ) throws IOException { return new TokenBasedPagingDelegate<CommentReply>() { @Override protected List<CommentReply> doGetPage() throws IOException { CommentReplyList response = client.replies().list(fileId, commentId) .setIncludeDeleted(includeDeleted) .setMaxResults(maxResults) .setPageToken(this.getPageToken()) .execute(); this.setPageToken(response.getNextPageToken()); return CommentReply.valueOf(response.getItems(), CommentReply.class); } }; }"	"	@Processor
    @OAuthProtected
	@OAuthInvalidateAccessTokenOn(exception=OAuthTokenExpiredException.class)
	@Inject
	public List<CommentReply> listCommentReplies(
			MuleMessage message,
			String fileId,
			String commentId, 
			@Optional @Default(""false"") boolean includeDeleted,
			@Optional @Default(""100"") int maxResults,
			@Optional @Default(""#[flowVars['GoogleDrive_NEXT_PAGE_TOKEN']]"") String pageToken
			) throws IOException {
		
		CommentReplyList response = this.client.replies().list(fileId, commentId)
										.setIncludeDeleted(includeDeleted)
										.setMaxResults(maxResults)
										.setPageToken(pageToken)
										.execute();
		

		PaginationUtils.savePageToken(NEXT_PAGE_TOKEN, response.getNextPageToken(), message);
		return CommentReply.valueOf(response.getItems(), CommentReply.class);
	}
"	Returns a paginated  Iterator with all the  org.mule.module.google.drive.model.CommentReply for a given comment @sample.xml ../../../doc/GoogleDriveConnector.xml.sample google-drive:list-comment-replies	Lists all replies for a given comment @sample.xml ../../../doc/GoogleDriveConnector.xml.sample google-drive:list-comment-replies	1	0	11	29	134
public static TimeExtractionFunction createDefault(String timeZone) { return new TimeExtractionFunction(ISO_TIME_FORMAT, null, timeZone, null); }	"  public static TimeExtractionFunction createDefault() {
    return new TimeExtractionFunction(ISO_TIME_FORMAT, null, ""UTC"", null);
  }
"	Creates the default time format extraction function.	Creates the default time format extraction function.	0	1	5	4	23
public URL getRoot() { return rootUrl; }	"	public IPath getRoot() {
		return root;
	}
"	Method getRoot.	Gets the root.	1	0	4	5	10
"public static ExpectedCondition<Boolean> and(final ExpectedCondition<?>... conditions) { return new ExpectedCondition<Boolean>() { @Override public Boolean apply(WebDriver driver) { for (ExpectedCondition<?> condition : conditions) { Object result = condition.apply(driver); if (result instanceof Boolean) { if (Boolean.FALSE.equals(result)) { return false; } } if (result == null) { return false; } } return true; } @Override public String toString() { StringBuilder message = new StringBuilder(""all conditions to be valid: ""); Joiner.on("" && "").appendTo(message, conditions); return message.toString(); } }; }"	"  public static ExpectedCondition<Boolean> and(final ExpectedCondition<?>... conditions) {
    return new ExpectedCondition<Boolean>() {
      @Override
      public Boolean apply(WebDriver driver) {
        for (ExpectedCondition<?> condition : conditions) {
          try {
            Object result = condition.apply(driver);
            if (result == null) {
              return Boolean.FALSE;
            } else if (result instanceof Boolean) {
              if (!(Boolean) result) {
                return Boolean.FALSE;
              }
            }
          } catch (Exception e) {
            return Boolean.FALSE;
          }
        }
        return Boolean.TRUE;
      }

      @Override
      public String toString() {
        String message = ""all conditions to be valid: "";
        for (ExpectedCondition<?> condition : conditions) {
          message += condition.toString();
        }
        return message;
      }
    };
  }
"	An expectation with the logical and condition of the given list of conditions.	An expectation with the logical and condition of the given list of conditions.	0	1	13	29	131
public static AccessType fromExternalName(String externalName) { if ( externalName == null ) { return null; } for ( AccessType accessType : AccessType.values() ) { if ( accessType.getExternalName().equals( externalName ) ) { return accessType; } } // Check to see if making upper-case matches an enum name. try { return AccessType.valueOf( externalName.toUpperCase( Locale.ROOT) ); } catch ( IllegalArgumentException e ) { throw new UnknownAccessTypeException( externalName ); } }	"	public static AccessType fromExternalName(String externalName) {
		if ( externalName == null ) {
			return null;
		}
		for ( AccessType accessType : AccessType.values() ) {
			if ( accessType.getExternalName().equals( externalName ) ) {
				return accessType;
			}
		}
		throw new UnknownAccessTypeException( externalName );
	}
"	Resolve an AccessType from its external name.	Resolve an AccessType from its external name.	0	1	8	18	91
private boolean validate(RexNode first, RexNode second) { return first instanceof RexCall && second instanceof RexCall; }	"  private boolean validate(RexNode first, RexNode second) {
    if (first == null || second == null) {
      return false;
    }
    if (!(first instanceof RexCall)
        || !(second instanceof RexCall)) {
      return false;
    }
    return true;
  }
"	Looks at the usage of variables in first and second conjunction to decide whether this kind of expression is currently supported for proving first implies second.	Looks at the usage of variables in first and second conjunction to decide if this kind of expression is currently supported for proving first => second.	1	0	6	4	22
"public static Bind parse(String serialized) { try { String[] parts = serialized.split("":""); switch (parts.length) { case 2: { return new Bind(parts[0], Volume.parse(parts[1])); } case 3: { AccessMode accessMode = AccessMode.valueOf(parts[2].toLowerCase()); return new Bind(parts[0], Volume.parse(parts[1]), accessMode); } default: { throw new IllegalArgumentException(); } } } catch (Exception e) { throw new IllegalArgumentException(""Error parsing Bind '"" + serialized + ""'""); } }"	"	public static Bind parse(String serialized) {
		try {
			String[] parts = serialized.split("":"");
			switch (parts.length) {
			case 2: {
				return new Bind(parts[0], Volume.parse(parts[1]));
			}
			case 3: {
				if (""rw"".equals(parts[2].toLowerCase()))
					return new Bind(parts[0], Volume.parse(parts[1]), false);
				else if (""ro"".equals(parts[2].toLowerCase()))
					return new Bind(parts[0], Volume.parse(parts[1]), true);
				else
					throw new IllegalArgumentException();
			}
			default: {
				throw new IllegalArgumentException();
			}
			}
		} catch (Exception e) {
			throw new IllegalArgumentException(""Error parsing Bind '"" + serialized
					+ ""'"");
		}
	}
"	Parses a bind mount specification to a  Bind.	Parses a bind mount specification to a Bind.	0	1	12	21	131
"protected boolean parse(String data) throws Exception { if(data == null || data.isEmpty()) { return true; } // ZAP: Replace all ""\n"" with ""\r\n"" to parse correctly String newData = data.replaceAll(""(?<!\r)\n"", CRLF); // ZAP: always use CRLF to comply with HTTP specification // even if the data it's not directly used. mLineDelimiter = CRLF; String[] split = patternCRLF.split(newData); mStartLine = split[0]; String token = null, name = null, value = null; int pos = 0; StringBuilder sb = new StringBuilder(2048); for (int i=1; i<split.length; i++) { token = split[i]; if (token.equals("""")) { continue; } if((pos = token.indexOf("":"")) < 0) { mMalformedHeader = true; return false; } name = token.substring(0, pos).trim(); value = token.substring(pos +1).trim(); if(name.equalsIgnoreCase(CONTENT_LENGTH)) { try { mContentLength = Integer.parseInt(value); } catch (NumberFormatException nfe){} } /* if (name.equalsIgnoreCase(PROXY_CONNECTION)) { sb.append(name + "": "" + _CLOSE + mLineDelimiter); } else if (name.equalsIgnoreCase(CONNECTION)) { sb.append(name + "": "" + _CLOSE + mLineDelimiter); } else { */ sb.append(name + "": "" + value + mLineDelimiter); //} addInternalHeaderFields(name, value); } mMsgHeader = sb.toString(); return true; }"	"    protected boolean parse(String data) throws Exception {

        String 	token = null,
				name = null,
				value = null;
        int pos = 0;
        Pattern pattern = null;

        if(data == null || data.equals("""")) {
            return true;
        }

        if ((pos = data.indexOf(CRLF)) < 0) {
        	if ((pos = data.indexOf(LF)) < 0) {
        		return false;
        	} else {
        		mLineDelimiter = LF;
        		pattern = patternLF;
        	}
        } else {
        	mLineDelimiter = CRLF;
        	pattern = patternCRLF;
        }
        
		String[] split = pattern.split(data);
		mStartLine = split[0];

		StringBuffer sb = new StringBuffer(2048);
		for (int i=1; i<split.length; i++)
		{
			token = split[i];
			if (token.equals("""")) {
				continue;
			}
			
            if((pos = token.indexOf("":"")) < 0) {
				mMalformedHeader = true;
                return false;
            }
            name  = token.substring(0, pos).trim();
            value = token.substring(pos +1).trim();

            if(name.equalsIgnoreCase(CONTENT_LENGTH)) {
            	try {
                	mContentLength = Integer.parseInt(value);
            	} catch (NumberFormatException nfe){}
            }
			
            /*
            if (name.equalsIgnoreCase(PROXY_CONNECTION)) {
            	sb.append(name + "": "" + _CLOSE + mLineDelimiter);
            } else if (name.equalsIgnoreCase(CONNECTION)) {
            	sb.append(name + "": "" + _CLOSE + mLineDelimiter);
            } else {
            */
			sb.append(name + "": "" + value + mLineDelimiter);
			//}
			
			addInternalHeaderFields(name, value);
		}

        mMsgHeader = sb.toString();
		return true;
	}
"	Parse this Http header using the String given.	Parse this Http header using the String given.	0	1	11	57	327
public MainWindowBase getSleakWindow() { //<DEBUG to find undisposed system resources> DeviceData data = new DeviceData(); data.tracking = true; Display display = new Display(data); Sleak sleak = new Sleak(); sleak.open(); Shell shell = new Shell(display); window = new MainWindowBase(shell); return window; //</DEBUG> }	"	public MainWindow getSleakWindow() {
		//<DEBUG to find undisposed system resources>
		DeviceData data = new DeviceData();
		data.tracking = true;
		Display display = new Display(data);
		Sleak sleak = new Sleak();
		sleak.open();
		
		Shell shell = new Shell(display);
		window = new MainWindow(shell);
		return window;
		//</DEBUG>
	}
"	Initiates an instance of  MainWindowBase that is monitored by Sleak.java, to monitor what handles (to OS device context) are in use.	Initiates an instance of MainWindow that is monitored by Sleak.java, to monitor what handles (to OS device context) are in use.	1	0	6	15	68
final public Map getGroups() { return this.groups; }	"    final public Map getGroups() {
        return groups;
    }
"	Get all Groups	DOCUMENT ME!	1	0	5	5	12
protected Object convertBoolean(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return false; } if (data instanceof Boolean) return data; if (data instanceof Short) return ((Short) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE; if (data instanceof Integer) return ((Integer) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE; if (data instanceof Long) return ((Long) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE; return handleUnknownData(column, fieldDefn, data); }	"    protected Object convertBoolean(Column column, Field fieldDefn, Object data) {
        if (data == null) return null;
        if (data instanceof Boolean) return data;
        if (data instanceof Short) return ((Short) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;
        if (data instanceof Integer) return ((Integer) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;
        if (data instanceof Long) return ((Long) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;
        return handleUnknownData(column, fieldDefn, data);
    }
"	Converts a value object for an expected JDBC type of  Types#BOOLEAN.	Converts a value object for an expected JDBC type of Types#BOOLEAN.	0	1	8	15	142
public boolean equals(Object readableInterval) { if (this == readableInterval) { return true; } if (readableInterval instanceof ReadableInterval == false) { return false; } ReadableInterval other = (ReadableInterval) readableInterval; return (getStartMillis() == other.getStartMillis() && getEndMillis() == other.getEndMillis() && getChronology() == other.getChronology()); }	"    public boolean equals(Object readableInterval) {
        if (this == readableInterval) {
            return true;
        }
        if (readableInterval instanceof ReadableInterval == false) {
            return false;
        }
        ReadableInterval other = (ReadableInterval) readableInterval;
        return (getStartMillis() == other.getStartMillis() &&
                getEndMillis() == other.getEndMillis());
    }
"	Compares this object with the specified object for equality based on start and end millis plus the chronology.	Compares this object with the specified object for equality based on start and end millis.	1	0	7	13	67
File getBaseDir(final File file1, final File file2) { if (file1 == null || file2 == null) { return null; } final Iterator file1Parents = getParents(file1).iterator(); final Iterator file2Parents = getParents(file2.getAbsoluteFile()).iterator(); File result = null; while (file1Parents.hasNext() && file2Parents.hasNext()) { File next = (File) file1Parents.next(); if (next.equals(file2Parents.next())) { result = next; } else { break; } } return result; }	"    File getBaseDir(File base, File file) {
        if (base == null) {
            return file.getParentFile().getAbsoluteFile();
        } else {
            Iterator bases = getParents(base).iterator();
            Iterator fileParents = getParents(file.getAbsoluteFile()).iterator();
            File result = null;
            while (bases.hasNext() && fileParents.hasNext()) {
                File next = (File) bases.next();
                if (next.equals(fileParents.next())) {
                    result = next;
                } else {
                    break;
                }
            }
            return result;
        }
    }
"	Returns the common base directory between the passed file1 and file2.	Returns the common base directory between a current base directory and a given file.	1	0	9	19	105
"public static boolean checkAlreadyExist(AccountDatabase.AccountName s) { Realm realm = Realm.getDefaultInstance(); // Query in the realm database RealmQuery<AccountDatabase> query = realm.where(AccountDatabase.class); // Checking if string equals to is exist or not query.equalTo(""name"", s.toString()); RealmResults<AccountDatabase> result1 = query.findAll(); // Here checking if count of that values is greater than zero return (result1.size() > 0); }"	"    public static boolean checkAlreadyExist(AccountDatabase.AccountName s) {
        Realm realm = Realm.getDefaultInstance();
        // Query in the realm database
        RealmQuery<AccountDatabase> query = realm.where(AccountDatabase.class);

        // Checking if string equals to is exist or not
        query.equalTo(""name"", s.toString());
        RealmResults<AccountDatabase> result1 = query.findAll();

        // Here checking if count of that values is greater than zero
        return (result1.size() > 0) ? true : false;
    }
"	This function check if the selected account is already existed.	This function check if the selected account is already existed.	0	1	7	13	89
public Float getBottomValue() { return bottomValue; }	"        public float getBottomValue() {
            return bottomValue == null ? 0 : bottomValue.floatValue();
        }
"	Gets the 'bottom' attributes value using current units.	Gets the 'bottom' CSS-attributes value in specified units.	1	0	4	5	10
public ArrayList getAllAHRefs() { return this.a_href_all; }	"    public ArrayList getAllAHRefs() {
        return a_href_all;
    }
"	Get a list of all a href=	DOCUMENT ME!	1	0	5	5	11
public String getAsText(long instant, Locale locale) { return getAsText(get(instant)); }	"    public String getAsText(long instant, Locale locale) {
        return Integer.toString(get(instant));
    }
"	Get the human-readable, text value of this field from the milliseconds.	Get the human-readable, text value of this field from the milliseconds.	0	1	6	4	21
"private String buildRemoveVideoSdpProposal() { if (logger.isActivated()) { logger.debug(""Build SDP proposal to remove video stream from the session""); } try { // Build SDP part String ntpTime = SipUtils.constructNTPtime(System.currentTimeMillis()); String ipAddress = getDialogPath().getSipStack().getLocalIpAddress(); getAudioPlayer().getLocalRtpPort(); String audioSdp = AudioSdpBuilder.buildSdpOffer(getAudioPlayer().getSupportedAudioCodecs(), getAudioPlayer().getLocalRtpPort()); return ""v=0"" + SipUtils.CRLF + ""o=- "" + ntpTime + "" "" + ntpTime + "" "" + SdpUtils.formatAddressType(ipAddress) + SipUtils.CRLF + ""s=-"" + SipUtils.CRLF + ""c="" + SdpUtils.formatAddressType(ipAddress) + SipUtils.CRLF + ""t=0 0"" + SipUtils.CRLF + audioSdp + ""a=sendrcv"" + SipUtils.CRLF; } catch (RemoteException e) { if (logger.isActivated()) { logger.error(""Remove video has failed"", e); } // Unexpected error handleError(new IPCallError(IPCallError.UNEXPECTED_EXCEPTION, e.getMessage())); return null; } }"	"	private String buildRemoveVideoSdpProposal() {
		if (logger.isActivated()) {
			logger.info(""buildRemoveVideoSdpProposal()"");
		}

		// Build SDP part
		String sdp = """";
		String ntpTime = SipUtils.constructNTPtime(System.currentTimeMillis());
		String ipAddress = getDialogPath().getSipStack().getLocalIpAddress();

		
		try {
			logger.warn(""Build audio sdp"");
			getAudioPlayer().getLocalRtpPort();			
			String audioSdp = AudioSdpBuilder.buildSdp(getAudioPlayer().getSupportedAudioCodecs(), getAudioPlayer().getLocalRtpPort());
			
			sdp = ""v=0"" + SipUtils.CRLF + ""o=- "" + ntpTime + "" "" + ntpTime
					+ "" "" + SdpUtils.formatAddressType(ipAddress)
					+ SipUtils.CRLF + ""s=-"" + SipUtils.CRLF + ""c=""
					+ SdpUtils.formatAddressType(ipAddress) + SipUtils.CRLF
					+ ""t=0 0"" + SipUtils.CRLF + audioSdp + ""a=sendrcv""
					+ SipUtils.CRLF;
		} catch (RemoteException e) {
			if (logger.isActivated()) {
				logger.error(""Remove Video has failed"", e);
			}

			// Unexpected error
			handleError(new IPCallError(IPCallError.UNEXPECTED_EXCEPTION,
					e.getMessage()));
		}
		return sdp;
	}
"	Build SDP proposal to remove video stream from the session	Build sdp proposal for removeVideo	1	0	23	31	215
"public Symbol generate(Schema sc, Map<LitS, Symbol> seen) { switch (sc.getType()) { case NULL: case BOOLEAN: case INT: case LONG: case FLOAT: case DOUBLE: case STRING: case BYTES: case FIXED: case UNION: return super.generate(sc, seen); case ENUM: return Symbol.seq(Symbol.enumLabelsAction(sc.getEnumSymbols()), Symbol.ENUM); case ARRAY: return Symbol.seq(Symbol.repeat(Symbol.ARRAY_END, Symbol.ITEM_END, generate(sc.getElementType(), seen)), Symbol.ARRAY_START); case MAP: return Symbol.seq(Symbol.repeat(Symbol.MAP_END, Symbol.ITEM_END, generate(sc.getValueType(), seen), Symbol.MAP_KEY_MARKER, Symbol.STRING), Symbol.MAP_START); case RECORD: { LitS wsc = new LitS(sc); Symbol rresult = seen.get(wsc); if (rresult == null) { Symbol[] production = new Symbol[sc.getFields().size() * 3 + 2]; rresult = Symbol.seq(production); seen.put(wsc, rresult); int i = production.length; int n = 0; production[--i] = Symbol.RECORD_START; for (Field f : sc.getFields()) { production[--i] = Symbol.fieldAdjustAction(n, f.name()); production[--i] = generate(f.schema(), seen); production[--i] = Symbol.FIELD_END; n++; } production[--i] = Symbol.RECORD_END; } return rresult; } default: throw new RuntimeException(""Unexpected schema type""); } }"	"  public Symbol generate(Schema sc, Map<LitS, Symbol> seen) {
    switch (sc.getType()) {
    case NULL:
    case BOOLEAN:
    case INT:
    case LONG:
    case FLOAT:
    case DOUBLE:
    case STRING:
    case BYTES:
    case FIXED:
    case UNION:
      return super.generate(sc, seen);
    case ENUM:
      return Symbol.seq(new Symbol.EnumLabelsAction(sc.getEnumSymbols()),
          Symbol.ENUM);
    case ARRAY:
      return Symbol.seq(Symbol.repeat(Symbol.ARRAY_END,
              Symbol.ITEM_END, generate(sc.getElementType(), seen)),
          Symbol.ARRAY_START);
    case MAP:
      return Symbol.seq(Symbol.repeat(Symbol.MAP_END,
              Symbol.ITEM_END, generate(sc.getValueType(), seen),
              Symbol.MAP_KEY_MARKER, Symbol.STRING),
          Symbol.MAP_START);
    case RECORD: {
      LitS wsc = new LitS(sc);
      Symbol rresult = seen.get(wsc);
      if (rresult == null) {
        Symbol[] production = new Symbol[sc.getFields().size() * 3 + 2];
        rresult = Symbol.seq(production);
        seen.put(wsc, rresult);

        int i = production.length;
        int n = 0;
        production[--i] = Symbol.RECORD_START;
        for (Field f : sc.getFields()) {
          production[--i] = new Symbol.FieldAdjustAction(n, f.name());
          production[--i] = generate(f.schema(), seen);
          production[--i] = Symbol.FIELD_END;
          n++;
        }
        production[--i] = Symbol.RECORD_END;
      }
      return rresult;
    }
    default:
      throw new RuntimeException(""Unexpected schema type"");
    }
  }
"	Returns the non-terminal that is the start symbol for grammar of the given schema sc.	Returns the non-terminal that is the start symbol for grammar of the given schema sc.	0	1	14	51	315
public String getName() { return this.fullName; }	"    public String getName() {
        return this.name;
    }
"	Returns the full name (i.e.	Returns the name of the element.	1	0	5	4	11
public ModelApiResponse uploadFile(Long petId, String additionalMetadata, File file) throws ApiException { return uploadFileWithHttpInfo(petId, additionalMetadata, file).getData(); }	"  public ModelApiResponse uploadFile(Long petId, String additionalMetadata, File file) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'petId' is set
    if (petId == null) {
      throw new ApiException(400, ""Missing the required parameter 'petId' when calling uploadFile"");
    }
    
    // create path and map variables
    String localVarPath = ""/pet/{petId}/uploadImage""
      .replaceAll(""\\{"" + ""petId"" + ""\\}"", apiClient.escapeString(petId.toString()));

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    if (additionalMetadata != null)
      localVarFormParams.put(""additionalMetadata"", additionalMetadata);
if (file != null)
      localVarFormParams.put(""file"", file);

    final String[] localVarAccepts = {
      ""application/json""
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      ""multipart/form-data""
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { ""petstore_auth"" };

    GenericType<ModelApiResponse> localVarReturnType = new GenericType<ModelApiResponse>() {};
    return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);
      }
"	uploads an image	uploads an image	0	1	5	4	30
public String getMergePolicy() { return mergePolicy; }	"    public String getMergePolicy() {
        return mergePolicyConfig.getPolicy();
    }
"	Gets the map merge policy  com.hazelcast.map.merge.MapMergePolicy	Gets the merge policy.	1	0	4	5	10
"protected static CodecFactory getCompressionCodec(TaskAttemptContext context) { if (FileOutputFormat.getCompressOutput(context)) { // Default to deflate compression. int compressionLevel = context.getConfiguration().getInt( org.apache.avro.mapred.AvroOutputFormat.DEFLATE_LEVEL_KEY, org.apache.avro.mapred.AvroOutputFormat.DEFAULT_DEFLATE_LEVEL); String outputCodec = context.getConfiguration() .get(AvroJob.CONF_OUTPUT_CODEC); if (outputCodec == null) { String compressionCodec = context.getConfiguration().get(""mapred.output.compression.codec""); String avroCodecName = HadoopCodecFactory.getAvroCodecName(compressionCodec); if ( avroCodecName != null){ context.getConfiguration().set(AvroJob.CONF_OUTPUT_CODEC, avroCodecName); return HadoopCodecFactory.fromHadoopString(compressionCodec); } else { return CodecFactory.deflateCodec(compressionLevel); } } else if (DataFileConstants.DEFLATE_CODEC.equals(outputCodec)) { return CodecFactory.deflateCodec(compressionLevel); } else { return CodecFactory.fromString(outputCodec); } } // No compression. return CodecFactory.nullCodec(); }"	"  protected static CodecFactory getCompressionCodec(TaskAttemptContext context) {
    if (FileOutputFormat.getCompressOutput(context)) {
      // Default to deflate compression.
      String outputCodec = context.getConfiguration()
        .get(AvroJob.CONF_OUTPUT_CODEC, DataFileConstants.DEFLATE_CODEC);
      if (DataFileConstants.DEFLATE_CODEC.equals(outputCodec)) {
        int compressionLevel = context.getConfiguration().getInt(
            org.apache.avro.mapred.AvroOutputFormat.DEFLATE_LEVEL_KEY,
            org.apache.avro.mapred.AvroOutputFormat.DEFAULT_DEFLATE_LEVEL);
        return CodecFactory.deflateCodec(compressionLevel);
      } else {
        return CodecFactory.fromString(outputCodec);
      }
    }

    // No compression.
    return CodecFactory.nullCodec();
  }
"	Gets the configured compression codec from the task context.	Gets the configured compression codec from the task context.	0	1	12	31	168
private JtdsConnection getConnection() throws SQLException { return (JtdsConnection) statement.getConnection(); }	"    private ConnectionJDBC getConnection() throws SQLException {
        return (ConnectionJDBC) statement.getConnection();
    }
"	Returns the  JtdsConnection object referenced by the  #statement instance variable.	Returns the ConnectionJDBC object referenced by the #statement instance variable.	1	0	5	5	18
public Path getEntirePartitionLocation() { return file; }	"  public String getEntirePartitionLocation() {
    return file;
  }
"	Return the full location of this partition	Return the full location of this partition	0	1	4	4	10
private static Gobbling gobble( Treepath< SyntacticTree > gobbleStart, int indentation ) { Preconditions.checkArgument( gobbleStart.getTreeAtEnd().isOneOf( _PLACEHOLDER_ ) ) ; Treepath< SyntacticTree > start = gobbleStart ; do { if( TreepathTools.hasNextSibling( start ) ) { final Treepath< SyntacticTree > next = TreepathTools.getNextSibling( start ) ; if( isRawItem( next ) ) { final Treepath< SyntacticTree > minusNext = TreepathTools.removeNextSibling( start ) ; return new Gobbling( minusNext, makeEmbeddedListItem( next ), indentation ) ; } else { final SyntacticTree nextTree = next.getTreeAtEnd() ; if( nextTree.isOneOf( WHITESPACE_, LINE_BREAK_ ) ) { start = TreepathTools.removeNextSibling( start ) ; if( nextTree.isOneOf( WHITESPACE_ ) ) { indentation = getWhitespaceLength( next ) ; } continue ; } } } // If no next sibling at all, or no useful next sibling, then return. return new Gobbling( start ) ; } while( true ) ; }	"  private static Gobbling gobble( Treepath< SyntacticTree > gobbleStart ) {
    if( null == gobbleStart ) {
      return null ;
    }
    Preconditions.checkArgument( gobbleStart.getTreeAtEnd().isOneOf( _PLACEHOLDER_ ) ) ;
    gobbleStart = TreepathTools.getNextSibling( gobbleStart ) ;
    
    do {
      if( isRawItem( gobbleStart ) ) {
        if( TreepathTools.hasNextSibling( gobbleStart ) ) {
          final Treepath< SyntacticTree > nextStart = TreepathTools.getNextSibling( gobbleStart ) ;
          final Treepath< SyntacticTree > nextStartMinusPrevious =
              TreepathTools.removePreviousSibling( nextStart ) ;
          return new Gobbling( nextStartMinusPrevious, makeEmbeddedListItem( gobbleStart ), true ) ;
        } else {
          final Treepath< SyntacticTree > minusPrevious = TreepathTools.removeEnd( gobbleStart ) ;
          return new Gobbling( minusPrevious, makeEmbeddedListItem( gobbleStart ), false ) ;
        }
      } else if( gobbleStart.getTreeAtEnd().isOneOf( WHITESPACE_, LINE_BREAK_ ) ) {
        if( TreepathTools.hasNextSibling( gobbleStart ) ) {
          gobbleStart = TreepathTools.getNextSibling( gobbleStart ) ;
        }
      } else {
        return null ;
      }
    } while( true ) ;
  }
"	Gobbles one item node if possible.	Gobble one item node if possible.	1	0	16	28	165
public final int getColumn() { return this.bufcolumn[this.bufpos]; }	"    public final int getColumn() {
        return bufcolumn[bufpos];
    }
"	Get the column position	DOCUMENT ME!	1	0	7	5	16
public TopicPublisher createPublisher(Topic topic) throws JMSException { checkClosed(); if (topic instanceof CustomDestination) { CustomDestination customDestination = (CustomDestination) topic; return customDestination.createPublisher(this); } return new ActiveMQTopicPublisher(this, ActiveMQMessageTransformation.transformDestination(topic)); }	"    public TopicPublisher createPublisher(Topic topic) throws JMSException {
        checkClosed();
        return new ActiveMQTopicPublisher(this, ActiveMQMessageTransformation.transformDestination(topic));
    }
"	Creates a publisher for the specified topic.	Creates a publisher for the specified topic.	0	1	8	10	50
"protected Account doMultiRealmAuthentication( Collection<? extends Realm> realms, AuthenticationToken token ) { ModularAuthenticationStrategy strategy = getModularAuthenticationStrategy(); strategy.beforeAllAttempts( realms, token ); Account aggregatedInfo = createAggregatedAccount( token ); if (log.isDebugEnabled()) { log.debug(""Iterating through ["" + realms.size() + ""] realms for PAM authentication""); } for( Realm realm : realms) { strategy.beforeAttempt( realm, token ); if( realm.supports( token.getClass() ) ) { if (log.isDebugEnabled()) { log.debug(""Attempting to authenticate token ["" + token + ""] "" + ""using realm of type ["" + realm.getClass() + ""]""); } Account realmInfo = null; Throwable t = null; try { realmInfo = realm.getAccount( token ); } catch ( Throwable throwable ) { t = throwable; if ( log.isTraceEnabled() ) { String msg = ""Realm ["" + realm + ""] threw an exception during a multi-realm authentication attempt:""; log.trace( msg, t ); } } strategy.afterAttempt( realm, token, realmInfo, t ); // If non-null account is returned, then the realm was able to authenticate the // user - so merge the account with any accumulated before: if( realmInfo != null ) { if (log.isDebugEnabled()) { log.debug(""Account successfully authenticated using realm of type ["" + realm.getClass().getName() + ""]""); } // Merge the module-returned data with the aggregate data merge( aggregatedInfo, realmInfo ); } } else { if (log.isDebugEnabled()) { log.debug(""Realm of type ["" + realm.getClass().getName() + ""] does not support token "" + ""of type ["" + token.getClass().getName() + ""]. Skipping realm."" ); } } } strategy.afterAllAttempts( token, aggregatedInfo ); return aggregatedInfo; }"	"    protected AuthenticationInfo doMultiRealmAuthentication( Collection<? extends Realm> realms, AuthenticationToken token ) {

        ModularAuthenticationStrategy strategy = getModularAuthenticationStrategy();

        strategy.beforeAllAttempts( realms, token );
        
        AuthenticationInfo aggregatedInfo = createAggregatedAuthenticationInfo( token );

        if (log.isDebugEnabled()) {
            log.debug(""Iterating through ["" + realms.size() + ""] realms for PAM authentication"");
        }

        for( Realm realm : realms) {

            strategy.beforeAttempt( realm, token );

            if( realm.supports( token.getClass() ) ) {

                if (log.isDebugEnabled()) {
                    log.debug(""Attempting to authenticate token ["" + token + ""] "" +
                        ""using realm of type ["" + realm.getClass() + ""]"");
                }

                AuthenticationInfo realmInfo = null;
                Throwable t = null;
                try {
                    realmInfo = realm.getAuthenticationInfo( token );
                } catch ( Throwable throwable ) {
                    t = throwable;
                    if ( log.isTraceEnabled() ) {
                        String msg = ""Realm ["" + realm + ""] threw an exception during a multi-realm authentication attempt:"";
                        log.trace( msg, t );
                    }
                }

                strategy.afterAttempt( realm, token, realmInfo, t );

                // If non-null info is returned, then the realm was able to authenticate the
                // user - so merge the info with any accumulated before:
                if( realmInfo != null ) {

                    if (log.isDebugEnabled()) {
                        log.debug(""Account successfully authenticated using realm of type ["" +
                            realm.getClass().getName() + ""]"");
                    }

                    // Merge the module-returned data with the aggregate data
                    merge( aggregatedInfo, realmInfo );

                }
            } else {
                if (log.isDebugEnabled()) {
                    log.debug(""Realm of type ["" + realm.getClass().getName() + ""] does not support token "" +
                            ""of type ["" + token.getClass().getName() + ""].  Skipping realm."" );
                }
            }
        }

        strategy.afterAllAttempts( token, aggregatedInfo );

        return aggregatedInfo;
    }
"	Performs the multi-realm authentication attempt by calling back to a  ModularAuthenticationStrategy object as each realm is consulted for Account for the specified token.	Performs the multi-realm authentication attempt by calling back to a ModularAuthenticationStrategy object as each realm is consulted for AuthenticationInfo for the specified token.	1	0	17	64	387
public int getBuffer(int k) { return (k >= 0 && k < getBufferSize()) ? buffer.get(k) : Config.NONEXIST; }	"  public int getBuffer(int k) {
    return (k >= 0 && k < getBufferSize()) ? buffer.get(k) : CONST.NONEXIST;
  }
"	Get the sentence index of the kth word on the buffer.	Get the sentence index of the kth word on the buffer.	0	1	7	4	30
"public boolean addFile(File sourceFile) { String filename = sourceFile.getName(); File destFile = null; String codeExtension = null; boolean replacement = false; // if the file appears to be code related, drop it // into the code folder, instead of the data folder if (filename.toLowerCase().endsWith("".class"") || filename.toLowerCase().endsWith("".jar"") || filename.toLowerCase().endsWith("".dll"") || filename.toLowerCase().endsWith("".jnilib"") || filename.toLowerCase().endsWith("".so"")) { //if (!codeFolder.exists()) codeFolder.mkdirs(); prepareCodeFolder(); destFile = new File(codeFolder, filename); } else { for (String extension : mode.getExtensions()) { String lower = filename.toLowerCase(); if (lower.endsWith(""."" + extension)) { destFile = new File(this.folder, filename); codeExtension = extension; } } if (codeExtension == null) { prepareDataFolder(); destFile = new File(dataFolder, filename); } } // check whether this file already exists if (destFile.exists()) { Object[] options = { Language.text(""prompt.ok""), Language.text(""prompt.cancel"") }; String prompt = Language.interpolate(""add_file.messages.confirm_replace"", filename); int result = JOptionPane.showOptionDialog(editor, prompt, ""Replace"", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options[0]); if (result == JOptionPane.YES_OPTION) { replacement = true; } else { return false; } } // If it's a replacement, delete the old file first, // otherwise case changes will not be preserved. // http://dev.processing.org/bugs/show_bug.cgi?id=969 if (replacement) { boolean muchSuccess = destFile.delete(); if (!muchSuccess) { Base.showWarning(Language.text(""add_file.messages.error_adding""), Language.interpolate(""add_file.messages.cannot_delete.description"", filename), null); return false; } } // make sure they aren't the same file if ((codeExtension == null) && sourceFile.equals(destFile)) { Base.showWarning(Language.text(""add_file.messages.same_file""), Language.text(""add_file.messages.same_file.description""), null); return false; } // Handles ""Add File"" when a .pde is used. For beta 1, this no longer runs // on a separate thread because it's totally unnecessary (a .pde file is // not going to be so large that it's ever required) and otherwise we have // to introduce a threading block here. // https://github.com/processing/processing/issues/3383 if (!sourceFile.equals(destFile)) { try { Base.copyFile(sourceFile, destFile); } catch (IOException e) { Base.showWarning(Language.text(""add_file.messages.error_adding""), Language.interpolate(""add_file.messages.cannot_add.description"", filename), e); return false; } } if (codeExtension != null) { SketchCode newCode = new SketchCode(destFile, codeExtension); if (replacement) { replaceCode(newCode); } else { insertCode(newCode); sortCode(); } setCurrentCode(filename); editor.header.repaint(); if (isUntitled()) { // TODO probably not necessary? problematic? // Mark the new code as modified so that the sketch is saved current.setModified(true); } } else { if (isUntitled()) { // TODO probably not necessary? problematic? // If a file has been added, mark the main code as modified so // that the sketch is properly saved. code[0].setModified(true); } } return true; }"	"  public boolean addFile(File sourceFile) {
    String filename = sourceFile.getName();
    File destFile = null;
    String codeExtension = null;
    boolean replacement = false;

    // if the file appears to be code related, drop it
    // into the code folder, instead of the data folder
    if (filename.toLowerCase().endsWith("".class"") ||
        filename.toLowerCase().endsWith("".jar"") ||
        filename.toLowerCase().endsWith("".dll"") ||
        filename.toLowerCase().endsWith("".jnilib"") ||
        filename.toLowerCase().endsWith("".so"")) {

      //if (!codeFolder.exists()) codeFolder.mkdirs();
      prepareCodeFolder();
      destFile = new File(codeFolder, filename);

    } else {
      for (String extension : mode.getExtensions()) {
        String lower = filename.toLowerCase();
        if (lower.endsWith(""."" + extension)) {
          destFile = new File(this.folder, filename);
          codeExtension = extension;
        }
      }
      if (codeExtension == null) {
        prepareDataFolder();
        destFile = new File(dataFolder, filename);
      }
    }

    // check whether this file already exists
    if (destFile.exists()) {
      Object[] options = { Language.text(""prompt.ok""), Language.text(""prompt.cancel"") };
      String prompt = ""Replace the existing version of "" + filename + ""?"";
      int result = JOptionPane.showOptionDialog(editor,
                                                prompt,
                                                ""Replace"",
                                                JOptionPane.YES_NO_OPTION,
                                                JOptionPane.QUESTION_MESSAGE,
                                                null,
                                                options,
                                                options[0]);
      if (result == JOptionPane.YES_OPTION) {
        replacement = true;
      } else {
        return false;
      }
    }

    // If it's a replacement, delete the old file first,
    // otherwise case changes will not be preserved.
    // http://dev.processing.org/bugs/show_bug.cgi?id=969
    if (replacement) {
      boolean muchSuccess = destFile.delete();
      if (!muchSuccess) {
        Base.showWarning(""Error adding file"",
                         ""Could not delete the existing '"" +
                         filename + ""' file."", null);
        return false;
      }
    }

    // make sure they aren't the same file
    if ((codeExtension == null) && sourceFile.equals(destFile)) {
      Base.showWarning(""You can't fool me"",
                       ""This file has already been copied to the\n"" +
                       ""location from which where you're trying to add it.\n"" +
                       ""I ain't not doin nuthin'."", null);
      return false;
    }

    // in case the user is ""adding"" the code in an attempt
    // to update the sketch's tabs
	if (!sourceFile.equals(destFile)) {
		final File sourceFile2 = sourceFile;
		final File destFile2 = destFile;
	    // Create a new event dispatch thread- to display ProgressBar
	    // while Saving As
    javax.swing.SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        new ProgressFrame(sourceFile2, destFile2, editor);
      }
    });
	}

    if (codeExtension != null) {
      SketchCode newCode = new SketchCode(destFile, codeExtension);

      if (replacement) {
        replaceCode(newCode);

      } else {
        insertCode(newCode);
        sortCode();
      }
      setCurrentCode(filename);
      editor.header.repaint();
      if (isUntitled()) {  // TODO probably not necessary? problematic?
        // Mark the new code as modified so that the sketch is saved
        current.setModified(true);
      }

    } else {
      if (isUntitled()) {  // TODO probably not necessary? problematic?
        // If a file has been added, mark the main code as modified so
        // that the sketch is properly saved.
        code[0].setModified(true);
      }
    }
    return true;
  }
"	Add a file to the sketch.	Add a file to the sketch.	0	1	13	119	749
public final boolean hasValidResults() { return getLastAction() != null; }	"    public final boolean hasValidResults() {
        AbstractBuild<?, ?> build = getLastFinishedBuild();
        if (build != null) {
            BuildHistory history = new BuildHistory(build, resultActionType);

            return history.hasPreviousResult();
        }
        return false;
    }
"	Returns whether this project has a valid result action attached.	Returns whether we have enough valid results in order to draw a meaningful graph.	1	0	5	5	15
public Button getButton(String text) { return getter.getView(Button.class, text, false); }	"	public Button getButton(String text)
	{
		return viewFetcher.getView(Button.class, text, false);
	}
"	Returns a Button which shows a given text.	Returns a Button which shows a given text.	0	1	6	5	21
public static <T> Method findMethod(Class<?> implClass, Operation<T> operation) throws NoSuchMethodException { String name = operation.getName(); Class<?>[] paramTypes = getPhysicalTypes(operation); return implClass.getMethod(name, paramTypes); }	"    public static Method findMethod(Operation<?> operation, Method[] methods) {
        for (Method method : methods) {
            if (match(operation, method)) {
                return method;
            }
        }
        return null;
    }
"	Return the method on the implementation class that matches the operation.	Searches an array of methods for a match against the given operation	1	0	6	7	44
public static ActiveMQConnectionFactory createConnectionFactoryWithoutHA(JMSFactoryType jmsFactoryType, final TransportConfiguration... transportConfigurations) { ActiveMQConnectionFactory factory = null; if (jmsFactoryType.equals(JMSFactoryType.CF)) { factory = new ActiveMQJMSConnectionFactory(false, transportConfigurations); } else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_CF)) { factory = new ActiveMQQueueConnectionFactory(false, transportConfigurations); } else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_CF)) { factory = new ActiveMQTopicConnectionFactory(false, transportConfigurations); } else if (jmsFactoryType.equals(JMSFactoryType.XA_CF)) { factory = new ActiveMQXAConnectionFactory(false, transportConfigurations); } else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_XA_CF)) { factory = new ActiveMQXAQueueConnectionFactory(false, transportConfigurations); } else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_XA_CF)) { factory = new ActiveMQXATopicConnectionFactory(false, transportConfigurations); } return factory; }	"   public static HornetQConnectionFactory createConnectionFactoryWithoutHA(JMSFactoryType jmsFactoryType, final TransportConfiguration... transportConfigurations)
   {
      HornetQConnectionFactory factory = null;
      if (jmsFactoryType.equals(JMSFactoryType.CF))
      {
         factory = new HornetQJMSConnectionFactory(false, transportConfigurations);
      }
      else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_CF))
      {
         factory = new HornetQQueueConnectionFactory(false, transportConfigurations);
      }
      else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_CF))
      {
         factory = new HornetQTopicConnectionFactory(false, transportConfigurations);
      }
      else if (jmsFactoryType.equals(JMSFactoryType.XA_CF))
      {
         factory = new HornetQXAConnectionFactory(false, transportConfigurations);
      }
      else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_XA_CF))
      {
         factory = new HornetQXAQueueConnectionFactory(false, transportConfigurations);
      }
      else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_XA_CF))
      {
         factory = new HornetQXATopicConnectionFactory(false, transportConfigurations);
      }

      return factory;
   }
"	Create a ActiveMQConnectionFactory which creates session factories using a static list of transportConfigurations.	Create a HornetQConnectionFactory which creates session factories using a static list of transportConfigurations.	1	0	13	32	146
public TableExtDesc getTableExt(String tableName, String prj) { TableDesc t = getTableDesc(tableName, prj); if (t == null) return null; TableExtDesc result = srcTableExtMap.get(mapKey(t.getIdentity(), t.getProject())); // avoid returning null, since the TableDesc exists if (null == result) { result = new TableExtDesc(); result.setName(t.getIdentity()); result.setUuid(UUID.randomUUID().toString()); result.setLastModified(0); result.init(t.getProject()); srcTableExtMap.put(mapKey(t.getIdentity(), t.getProject()), result); } return result; }	"    public TableExtDesc getTableExt(String tableName, String prj) {
        if (tableName.indexOf(""."") < 0)
            tableName = ""DEFAULT."" + tableName;

        TableExtDesc result = srcTableExdMap.get(tableName.toUpperCase());

        // create new
        if (null == result) {
            result = new TableExtDesc();
            result.setName(tableName);
            result.setUuid(UUID.randomUUID().toString());
            result.setLastModified(0);
            result.init();
            srcTableExdMap.put(result.getName(), result);
        }
        return result;
    }
"	Get table extended info.	Get table extended info.	0	1	8	19	129
"public static W3CWidget getWidget(String metadata, String shindig) throws Exception{ JSONObject gadget = null; JSONObject response = new JSONObject(metadata); JSONArray gadgets = response.getJSONArray(""gadgets""); if (gadgets.length()==0) return null; gadget = gadgets.getJSONObject(0); return new GadgetAdapter(gadget, shindig); }"	"	public static Widget getWidget(String metadata, String shindig) throws Exception{
		JSONObject gadget = null;
		Widget widget = null;
		JSONObject response = new JSONObject(metadata);
		JSONArray gadgets = response.getJSONArray(""gadgets"");
		if (gadgets.length() > 0){
			gadget = gadgets.getJSONObject(0);
			if (gadget.has(""errors"")) throw new Exception(""Invalid gadget - Shindig error"");
			
			widget = new Widget();
			// Defaults
			String title = ""Untitled Gadget"";
			int height = 200;
			int width = 320;
			String author = ""Unknown Author"";
			String description = ""Google Gadget"";
			String icon = DEFAULT_ICON;

			if (!gadget.has(""url"")) throw new Exception(""Invalid gadget - URL missing"");
			if (gadget.getString(""url"") == null || gadget.getString(""url"").equals("""")) throw new Exception(""Invalid gadget - Invalid URL"");
			try {
				@SuppressWarnings(""unused"")
				URL url = new URL(gadget.getString(""url""));
			} catch (Exception e) {
				throw new Exception(""Invalid gadget - invalid URL"");
			}

			// Use the URL as the GUID
			widget.setGuid(gadget.getString(""url""));

			// We should be able to use the ""iframeUrl"" property here, but
			// it isn't very reliable at generating a usable value, so we construct
			// a very basic URL instead
			StartFile sf = new StartFile();
			sf.setWidget(widget);
			// FIXME we need to use real locales in these URLs
			sf.setUrl(shindig+""/gadgets/ifr?url=""+gadget.getString(""url"")+""&amp;lang=en&amp;country=UK"");
			
			if (gadget.has(""height"")) if (gadget.getInt(""height"") != 0) height = gadget.getInt(""height"");
			if (gadget.has(""width"")) if (gadget.getInt(""width"") != 0) width = gadget.getInt(""width"");

			if (gadget.has(""author"")){
				if (gadget.getString(""author"")!=null){
					if (!(gadget.getString(""author"").trim()).equals("""")){
						author = gadget.getString(""author"");
					}
				}
			}

			if (gadget.has(""title"")){
				if (gadget.getString(""title"")!=null){
					if (!(gadget.getString(""title"").trim()).equals("""")){
						title = gadget.getString(""title"");
					}
				}
			}

			// Override the title with directory title if present (this is intended for gallery use)
			if (gadget.has(""directory_title"")){
				if (gadget.getString(""directory_title"")!=null){
					if (!(gadget.getString(""directory_title"").trim()).equals("""")){
						title = gadget.getString(""directory_title"");
					}    			
				}
			}

			if (gadget.has(""description"")){
				if (gadget.getString(""description"")!=null){
					if (!(gadget.getString(""description"").trim()).equals("""")){
						title = gadget.getString(""description"");
					}
				}
			}

			if (gadget.has(""thumbnail"")){
				if (gadget.getString(""thumbnail"")!=null){
					if (!(gadget.getString(""thumbnail"").trim()).equals("""")){
						icon = gadget.getString(""thumbnail"");
					}
				}
			}

			widget.setMaximize(false);
			widget.setHeight(height);
			widget.setWidth(width);
			Name name = new Name();
			name.setWidget(widget);
			name.setName(title);
			Description desc = new Description();
			desc.setWidget(widget);
			desc.setContent(description);
			WidgetIcon wicon = new WidgetIcon();
			wicon.setSrc(icon);
			wicon.setWidget(widget);
			widget.setWidgetAuthor(author);
			
			widget.save();
			sf.save();
			name.save();
			wicon.save();
			desc.save();
			
		}
		return widget;
	}
"	Marshall JSON metadata into a new W3CWidget instance	Marshall JSON metadata into a new Widget instance	1	0	6	10	64
public static boolean isSameScriptEngine(String name, String engineName, String engineLanguage) { if (name == null) { return false; } // In the configs we just use the engine name, in the UI we use the language name as well if (name.indexOf(LANG_ENGINE_SEP) > 0) { if (name.equals(engineLanguage + LANG_ENGINE_SEP + engineName)) { return true; } return false; } return name.equals(engineName); }	"	public static boolean isSameScriptEngine(String name, String engineName, String engineLanguage) {
		if (name == null) {
			return false;
		}

		// In the configs we just use the engine name, in the UI we use the language name as well
		if (name.indexOf(LANG_ENGINE_SEP) > 0) {
			if (name.equals(engineLanguage + LANG_ENGINE_SEP + engineName)) {
				return true;
			}
			return false;
		}

		if (name.equals(engineName)) {
			return true;
		}

		// Nasty, but sometime the engine names are reported differently, eg 'Mozilla Rhino' vs 'Rhino'
		if (name.endsWith(engineName)) {
			return true;
		}
		if (engineName.endsWith(name)) {
			return true;
		}
		return false;
	}
"	Tells whether or not the given  name matches the given  engineName and  engineLanguage.	Tells whether or not the given name matches the given engineName and engineLanguage.	0	1	9	16	86
public static int getPrecision(MajorType majorType) { if (majorType.hasPrecision()) { return majorType.getPrecision(); } return isScalarStringType(majorType) ? MAX_VARCHAR_LENGTH : UNDEFINED; }	"  public static int getPrecision(MajorType majorType) {
    MinorType type = majorType.getMinorType();

    if (type == MinorType.VARBINARY || type == MinorType.VARCHAR) {
      return 65536;
    }

    if (majorType.hasPrecision()) {
      return majorType.getPrecision();
    }

    return 0;
  }
"	Get the precision of given type.	Get the precision of given type.	0	1	6	8	35
private ObjectAnimator createNullAnimator(ImageView imageView) { return AnimatorUtils.ofObject(createMatrixProperty(imageView), new MatrixUtils.NullMatrixEvaluator(), MatrixUtils.IDENTITY_MATRIX, MatrixUtils.IDENTITY_MATRIX); }	"    private ObjectAnimator createNullAnimator(ImageView imageView) {
        return AnimatorUtils.ofObject(new ImageAnimator(imageView),
                new MatrixUtils.NullMatrixEvaluator(),
                MatrixUtils.IDENTITY_MATRIX, MatrixUtils.IDENTITY_MATRIX);
    }
"	Creates an Animator for ImageViews moving, changing dimensions, and/or changing  android.widget.ImageView.ScaleType.	Creates an Animator for ImageViews moving, changing dimensions, and/or changing android.widget.ImageView.ScaleType.	0	1	7	6	31
"public static String getId( final Widget widget ) { // TODO [rh] consider overriding the id when Widget#setData is called // - safer 1: in case someone tries to obtain id directly from addapter // - safer 2: changing the id after widget was initialized could be // detected and prevented // - less memory: new HashMap created per widget to hold the id // - illegal id's could be rejected immediately (close to error source) // - faster (?): only ""return getAdapter( widget ).getId();"" in here String result = ( String )widget.getData( CUSTOM_WIDGET_ID ); if( result == null ) { result = getAdapter( widget ).getId(); } return result; }"	"  public static String getId( final Widget widget ) {
    return getAdapter( widget ).getId();
  }
"	Returns the id of the given widget that is used to identify the widget on the client.	Returns the id of the widget that is used to identify the widget on the client.	1	0	8	16	147
public static DateTimeFormatter hourMinuteSecondMillis() { return Constants.hmsl; }	"    public static DateTimeFormatter hourMinuteSecondMillis() {
        if (hmsl == null) {
            hmsl = new DateTimeFormatterBuilder()
                .append(hourElement())
                .append(minuteElement())
                .append(secondElement())
                .appendLiteral('.')
                .appendFractionOfSecond(3, 3)
                .toFormatter();
        }
        return hmsl;
    }
"	Returns a formatter for a two digit hour of day, two digit minute of hour, two digit second of minute, and three digit fraction of second (HH:mm:ss.SSS).	Returns a formatter for a two digit hour of day, two digit minute of hour, two digit second of minute, and three digit fraction of second (HH:mm:ss.SSS).	0	1	4	4	12
public static PathMetadata<Integer> forListAccess(PList<?> parent, int index) { return new PathMetadata<Integer>(parent, EConstant.create(index), PathType.LISTVALUE_CONSTANT); }	"    public static PathMetadata<Integer> forListAccess(PList<?> parent, int index) {
        return new PathMetadata<Integer>(parent, factory.createConstant(index), PathType.LISTVALUE_CONSTANT);
    }
"	Create a new PathMetadata instance for indexed list access	Create a new PathMetadata instance for indexed list access	0	1	7	4	32
public DateTimeFormatterBuilder appendMillisOfDay(final int minDigits) { return appendDecimal(iChronoUTC.millisOfDay(), minDigits, 8); }	"    public DateTimeFormatterBuilder appendMillisOfDay(final int minDigits) {
        return appendNumeric(iChronoUTC.millisOfDay(), minDigits, 8);
    }
"	Instructs the printer to emit a numeric millisOfDay field.	Instructs the printer to emit a numeric millisOfDay field.	0	1	5	4	23
private boolean isShareable() { return getRequestScope().getDictionary().isSharable(obj.getClass()); }	"    private boolean isShareable() {
        return getRequestScope().getDictionary().getAnnotation(obj.getClass(), Shareable.class) != null;
    }
"	Checks if this persistent resource's underlying entity is sharable.	Checks if this persistent resource's underlying entity has the @Shareable annotation.	1	0	6	5	22
"private Bitmap getWidgetPreview(AppWidgetProviderInfo info) { final PackageManager packageManager = mPackageManager; String packageName = info.provider.getPackageName(); Drawable drawable = null; if (info.previewImage != 0) { drawable = packageManager.getDrawable(packageName, info.previewImage, null); if (drawable == null) { Log.w(TAG, ""Can't load icon drawable 0x"" + Integer.toHexString(info.icon) + "" for provider: "" + info.provider); } } // If we don't have a preview image, create a default one if (drawable == null) { Resources resources = mLauncher.getResources(); // Create a new bitmap to hold the widget preview int width = (int) (Math.max(mMinWidgetPreviewDim, Math.min(mMaxWidgetPreviewDim, info.minWidth)) * sScaleFactor); int height = (int) (Math.max(mMinWidgetPreviewDim, Math.min(mMaxWidgetPreviewDim, info.minHeight)) * sScaleFactor); final Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888); final Drawable background = resources.getDrawable(R.drawable.default_widget_preview); renderDrawableToBitmap(background, bitmap, 0, 0, width, height, 1.0f, 1.0f); // Draw the icon flush left try { Drawable icon = null; if (info.icon > 0) { icon = packageManager.getDrawable(packageName, info.icon, null); } if (icon == null) { icon = resources.getDrawable(R.drawable.ic_launcher_application); } final int iconSize = mMinWidgetPreviewDim / 2; final int offset = iconSize / 4; renderDrawableToBitmap(icon, null, offset, offset, iconSize, iconSize, 1.0f, 1.0f); } catch (Resources.NotFoundException e) { // if we can't find the icon, then just don't draw it } return bitmap; } else { // Scale down the preview if necessary final float imageWidth = drawable.getIntrinsicWidth(); final float imageHeight = drawable.getIntrinsicHeight(); final float aspect = (float) imageWidth / imageHeight; final int scaledWidth = (int) (Math.max(mMinWidgetPreviewDim, Math.min(mMaxWidgetPreviewDim, imageWidth)) * sScaleFactor); final int scaledHeight = (int) (Math.max(mMinWidgetPreviewDim, Math.min(mMaxWidgetPreviewDim, imageHeight)) * sScaleFactor); int width; int height; if (aspect >= 1.0f) { width = scaledWidth; height = (int) (((float) scaledWidth / imageWidth) * imageHeight); } else { height = scaledHeight; width = (int) (((float) scaledHeight / imageHeight) * imageWidth); } final Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888); renderDrawableToBitmap(drawable, bitmap, 0, 0, width, height, 1.0f, 1.0f); return bitmap; } }"	"    private FastBitmapDrawable getWidgetPreview(AppWidgetProviderInfo info) {
        final PackageManager packageManager = mPackageManager;
        String packageName = info.provider.getPackageName();
        Drawable drawable = null;
        FastBitmapDrawable newDrawable = null;
        if (info.previewImage != 0) {
            drawable = packageManager.getDrawable(packageName, info.previewImage, null);
            if (drawable == null) {
                Log.w(TAG, ""Can't load icon drawable 0x"" + Integer.toHexString(info.icon)
                        + "" for provider: "" + info.provider);
            }
        }

        // If we don't have a preview image, create a default one
        final int minDim = mWorkspaceWidgetLayout.estimateCellWidth(1);
        final int maxDim = mWorkspaceWidgetLayout.estimateCellWidth(3);
        if (drawable == null) {
            Resources resources = mLauncher.getResources();

            // Create a new bitmap to hold the widget preview
            int width = (int) (Math.max(minDim, Math.min(maxDim, info.minWidth)) * sScaleFactor);
            int height = (int) (Math.max(minDim, Math.min(maxDim, info.minHeight)) * sScaleFactor);
            final Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888);
            final Drawable background = resources.getDrawable(R.drawable.default_widget_preview);
            renderDrawableToBitmap(background, bitmap, 0, 0, width, height, 1.0f, 1.0f);

            // Draw the icon flush left
            try {
                Drawable icon = null;
                if (info.icon > 0) {
                    icon = packageManager.getDrawable(packageName, info.icon, null);
                }
                if (icon == null) {
                    icon = resources.getDrawable(R.drawable.ic_launcher_application);
                }

                final int iconSize = minDim / 2;
                final int offset = iconSize / 4;
                renderDrawableToBitmap(icon, null, offset, offset, iconSize, iconSize, 1.0f, 1.0f);
            } catch (Resources.NotFoundException e) {
                // if we can't find the icon, then just don't draw it
            }

            newDrawable = new FastBitmapDrawable(bitmap);
        } else {
            // Scale down the preview if necessary
            final float imageWidth = drawable.getIntrinsicWidth();
            final float imageHeight = drawable.getIntrinsicHeight();
            final float aspect = (float) imageWidth / imageHeight;
            final int scaledWidth =
                (int) (Math.max(minDim, Math.min(maxDim, imageWidth)) * sScaleFactor);
            final int scaledHeight =
                (int) (Math.max(minDim, Math.min(maxDim, imageHeight)) * sScaleFactor);
            int width;
            int height;
            if (aspect >= 1.0f) {
                width = scaledWidth;
                height = (int) (((float) scaledWidth / imageWidth) * imageHeight);
            } else {
                height = scaledHeight;
                width = (int) (((float) scaledHeight / imageHeight) * imageWidth);
            }

            final Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888);
            renderDrawableToBitmap(drawable, bitmap, 0, 0, width, height, 1.0f, 1.0f);

            newDrawable = new FastBitmapDrawable(bitmap);
        }
        newDrawable.setBounds(0, 0, newDrawable.getIntrinsicWidth(),
                newDrawable.getIntrinsicHeight());
        return newDrawable;
    }
"	This method will extract the preview image specified by the widget developer (if it exists), otherwise, it will try to generate a default image preview with the widget's package icon.	This method will extract the preview image specified by the widget developer (if it exists), otherwise, it will try to generate a default image preview with the widget's package icon.	0	1	13	69	515
private String checkSubElementsNullability(Type propertyType, Object value) throws HibernateException { if ( propertyType.isComponentType() ) { return checkComponentNullability( value, (CompositeType) propertyType ); } if ( propertyType.isCollectionType() ) { // persistent collections may have components final CollectionType collectionType = (CollectionType) propertyType; final Type collectionElementType = collectionType.getElementType( session.getFactory() ); if ( collectionElementType.isComponentType() ) { // check for all components values in the collection final CompositeType componentType = (CompositeType) collectionElementType; final Iterator itr = CascadingActions.getLoadedElementsIterator( session, collectionType, value ); while ( itr.hasNext() ) { final Object compositeElement = itr.next(); if ( compositeElement != null ) { return checkComponentNullability( compositeElement, componentType ); } } } } return null; }	"	private String checkSubElementsNullability(Type propertyType, Object value) throws HibernateException {
		// IMPL NOTE : we currently skip checking ""any"" and ""many to any"" mappings.  This is not the best solution.
		//
		// The problem I ran into with performing the checks on ""any"" and ""many to any"" mappings had to do  with
		// cascaded saves of transient associated entities not yet having assigned the identifier (this was
		// specifically in the ""many to any"" case).

		if ( propertyType.isAnyType() ) {
			return null;
		}

		if ( propertyType.isComponentType() ) {
			return checkComponentNullability( value, (CompositeType) propertyType );
		}

		if ( propertyType.isCollectionType() ) {
			//persistent collections may have components
			final CollectionType collectionType = (CollectionType) propertyType;
			final Type collectionElementType = collectionType.getElementType( session.getFactory() );

			if ( collectionElementType.isAnyType() ) {
				return null;
			}

			if ( collectionElementType.isComponentType() ) {
				//check for all components values in the collection
				final CompositeType componentType = (CompositeType) collectionElementType;
				final Iterator itr = CascadingActions.getLoadedElementsIterator( session, collectionType, value );
				while ( itr.hasNext() ) {
					final Object compValue = itr.next();
					if ( compValue != null ) {
						return checkComponentNullability( compValue, componentType );
					}
				}
			}
		}

		return null;
	}
"	check sub elements-nullability.	check sub elements-nullability.	0	1	13	26	146
public RepositoryMethodMetadata lookupMethod(RepositoryMetadata repositoryMetadata, Method method) { return repositoryMetadata.getMethodsMetadata().get(method); }	"    public RepositoryMethodMetadata lookupMethod(Class<?> repoClass, Method method)
    {
        return lookupComponent(repoClass).getMethodsMetadata().get(method);
    }
"	lookup the  RepositoryMethodMetadata for a specific repository and method.	Repository access - lookup method information for a specific Repository class.	1	0	6	6	22
public WireType getWireType() { return queue.wireType(); }	"	public WireType getWireType() {
		return wireType;
	}
"	Returns the queue wire type	Returns	1	0	4	5	13
public boolean searchEditText(String search) { Pattern p = Pattern.compile(search); Matcher matcher; ArrayList<EditText> editTextList = getCurrentEditTexts(); Iterator<EditText> iterator = editTextList.iterator(); while (iterator.hasNext()) { EditText editText = (EditText) iterator.next(); matcher = p.matcher(editText.getText().toString()); if (matcher.matches()) { return true; } } if (scrollDownList()) return searchEditText(search); else return false; }	"	
	public EditText searchEditText(String search) {
		ArrayList<EditText> editTextList = getCurrentEditTexts();
		Iterator<EditText> iterator = editTextList.iterator();
		while (iterator.hasNext()) {
			EditText editText = (EditText) iterator.next();
			if (editText.getText().toString().equals(search)) {
				return editText;
			}
		}
		return null;
		
	}
"	Searches for a text string in the edit texts located in the current activity.	Searches for a search string in the EditTexts located in the current activity.	1	0	9	20	95
public Job<?, ?> getOwner() { return job; }	"    public AbstractProject<?, ?> getOwner() {
        return project;
    }
"	Returns the job.	Returns the project.	1	0	4	5	13
"public String getTitle() { return (String) seleneseMethods.get(""getTitle"").apply(driver); }"	"  public String getTitle() {
    return driver.getTitle();
  }
"	Gets the title of the current page.	Gets the title of the current page.	0	1	7	4	23
"public String getConsoleText() { activate(); WidgetIsFound<org.eclipse.swt.custom.StyledText> widgetIsFound = new WidgetIsFound<org.eclipse.swt.custom.StyledText>( new ClassMatcher(org.eclipse.swt.custom.StyledText.class)); new WaitUntil(widgetIsFound, TimePeriod.NORMAL, false); // Checck whether there is a console to display or not if (widgetIsFound.getWidget() == null) { return null; } // wait for text to appear new WaitWhile(new ConsoleHasText(""""),TimePeriod.SHORT,false); return new DefaultStyledText().getText(); }"	"	public String getConsoleText() {
		activate();
		new WaitUntil(new WidgetIsFound<org.eclipse.swt.custom.StyledText>(
				new ClassMatcher(org.eclipse.swt.custom.StyledText.class)));
		// wait for text to appear
		new WaitWhile(new ConsoleHasText(""""),TimePeriod.SHORT,false);
		return new DefaultStyledText().getText();
	}
"	Gets text from console.	Returns console test.	1	0	12	16	106
private IDKey getIdentityKey(Object value) { return new IDKey(value); }	"    private String getIdentityKey(Object value) {
        return """" + System.identityHashCode(value);
    }
"	Get an IDKey that represents the unique identity of the object.	Get a String representation of the identity hashCode for a given	1	0	5	5	16
"public Symbol generate(Schema sc, Map<LitS, Symbol> seen) { switch (sc.getType()) { case NULL: case BOOLEAN: case INT: case LONG: case FLOAT: case DOUBLE: case STRING: case BYTES: case FIXED: case UNION: return super.generate(sc, seen); case ENUM: return Symbol.seq(new Symbol.EnumLabelsAction(sc.getEnumSymbols()), Symbol.ENUM); case ARRAY: return Symbol.seq(Symbol.repeat(Symbol.ARRAY_END, Symbol.ITEM_END, generate(sc.getElementType(), seen)), Symbol.ARRAY_START); case MAP: return Symbol.seq(Symbol.repeat(Symbol.MAP_END, Symbol.ITEM_END, generate(sc.getValueType(), seen), Symbol.MAP_KEY_MARKER, Symbol.STRING), Symbol.MAP_START); case RECORD: { LitS wsc = new LitS(sc); Symbol rresult = seen.get(wsc); if (rresult == null) { Symbol[] production = new Symbol[sc.getFields().size() * 2 + 2]; rresult = Symbol.seq(production); seen.put(wsc, rresult); int i = production.length; int n = 0; production[--i] = Symbol.RECORD_START; for (Map.Entry<String, Field> f : sc.getFields().entrySet()) { production[--i] = new Symbol.FieldAdjustAction(n, f.getKey()); production[--i] = generate(f.getValue().schema(), seen); n++; } production[--i] = Symbol.RECORD_END; } return rresult; } default: throw new RuntimeException(""Unexpected schema type""); } }"	"  public Symbol generate(Schema sc, Map<LitS, Symbol> seen) {
    switch (sc.getType()) {
    case NULL:
    case BOOLEAN:
    case INT:
    case LONG:
    case FLOAT:
    case DOUBLE:
    case STRING:
    case BYTES:
    case FIXED:
    case UNION:
      return super.generate(sc, seen);
    case ENUM:
      return Symbol.seq(new Symbol.EnumLabelsAction(sc.getEnumSymbols()),
          Symbol.ENUM);
    case ARRAY:
      return Symbol.seq(Symbol.ARRAY_END,
          Symbol.repeat(Symbol.ARRAY_END,
              Symbol.ITEM_END, generate(sc.getElementType(), seen)),
          Symbol.ARRAY_START);
    case MAP:
      return Symbol.seq(Symbol.MAP_END,
          Symbol.repeat(Symbol.MAP_END,
              Symbol.ITEM_END, generate(sc.getValueType(), seen),
              Symbol.MAP_KEY_MARKER, Symbol.STRING),
          Symbol.MAP_START);
    case RECORD: {
      LitS wsc = new LitS(sc);
      Symbol rresult = seen.get(wsc);
      if (rresult == null) {
        Symbol[] production = new Symbol[sc.getFields().size() * 2 + 2];
        rresult = Symbol.seq(production);
        seen.put(wsc, rresult);

        int i = production.length;
        int n = 0;
        production[--i] = Symbol.RECORD_START;
        for (Map.Entry<String, Field> f : sc.getFields().entrySet()) {
          production[--i] = new Symbol.FieldAdjustAction(n, f.getKey());
          production[--i] = generate(f.getValue().schema(), seen);
          n++;
        }
        production[--i] = Symbol.RECORD_END;
      }
      return rresult;
    }
    default:
      throw new RuntimeException(""Unexpected schema type"");
    }
  }
"	Returns the non-terminal that is the start symbol for grammar of the given schema sc.	Returns the non-terminal that is the start symbol for grammar of the given schema sc.	0	1	14	50	318
public static Log forSlf4jLogger(org.slf4j.Logger logger) { return new Log((Logger) logger); }	"    public static Log forSlf4jLogger(org.slf4j.Logger logger) {
        return named(logger.getName());
    }
"	Returns a  Log instance with the same name as the given slf4j  org.slf4j.Logger instance.	Returns a Log instance with the same name as the given slf4j org.slf4j.Logger instance.	0	1	6	4	22
public static MemberID parse(String memberID, boolean isClassMember) { return parse(memberID, isClassMember, null); }	"    public static MemberID parse(String signature, boolean isClassMember) {
        return parse(signature, isClassMember, null);
    }
"	Parse a member ID, with or without classname, with or without descriptor.	Parse a signature, with or without classname, with or without descriptor.	1	0	5	5	23
"protected String getUrlProtocol() { return ""derby://localhost:"" + (getPort() > 0 ? getPort() : DEFAULT_PORT) + ""/memory:""; }"	"    protected String getUrlProtocol() {
        return PROTOCOL;
    }
"	Get the database connection protocol used for JDBC connections	Get the database connection protocol.	1	0	8	5	36
public static SchemaBuilder builder() { return SchemaBuilder.int64() .name(SCHEMA_NAME) .version(1); }	"    public static SchemaBuilder builder() {
        return SchemaBuilder.float64()
                            .name(SCHEMA_NAME)
                            .version(1);
    }
"	Returns a  SchemaBuilder for a  MicroDuration.	Returns a SchemaBuilder for a MicroDuration.	0	1	6	6	22
"private boolean searchForToggleButton(String regex, int matches) { sleeper.sleep(); inst.waitForIdleSync(); Pattern p = Pattern.compile(regex); Matcher matcher; ArrayList<ToggleButton> toggleButtonList = viewFetcher.getCurrentViews(ToggleButton.class); if(matches == 0) matches = 1; for(ToggleButton toggleButton : toggleButtonList){ matcher = p.matcher(toggleButton.getText().toString()); if(matcher.find()){ countMatches++; } if (countMatches == matches) { countMatches=0; return true; } } if (scroller.scroll(Scroller.Direction.DOWN)) { return searchForToggleButton(regex, matches); } else { if(countMatches > 0) Log.d(LOG_TAG, "" There are only "" + countMatches + "" matches of "" + regex); countMatches = 0; return false; } }"	"	private boolean searchForToggleButton(String search, int matches) {
		sleeper.sleep();
		inst.waitForIdleSync();
		Pattern p = Pattern.compile(search);
		Matcher matcher;
		ArrayList<ToggleButton> toggleButtonList = viewFetcher.getCurrentViews(ToggleButton.class);
		if(matches == 0)
			matches = 1;
		for(ToggleButton toggleButton : toggleButtonList){
			matcher = p.matcher(toggleButton.getText().toString());
			if(matcher.find()){	
				countMatches++;
			}
			if (countMatches == matches) {
				countMatches=0;
				return true;
			} 
		}

		if (scroller.scroll(Scroller.Direction.DOWN))
		{
			return searchForToggleButton(search, matches);
		} else {
			if(countMatches > 0)
				Log.d(LOG_TAG, "" There are only "" + countMatches + "" matches of "" + search);
			countMatches = 0;
			return false;
		}
		
	}
"	Searches for a toggle button with the given regex string and returns true if the searched toggle button is found a given number of times	Searches for a toggle button with the given search string and returns true if the searched toggle button is found a given number of times	1	0	11	31	154
public Index parseAndUpdateIndex(List<JaxbRoot<XMLEntityMappings>> mappings, Index annotationIndex) { List<XMLEntityMappings> list = new ArrayList<XMLEntityMappings>( mappings.size() ); for ( JaxbRoot<XMLEntityMappings> jaxbRoot : mappings ) { list.add( jaxbRoot.getRoot() ); } return new EntityMappingsMocker( list, annotationIndex, metadata.getServiceRegistry() ).mockNewIndex(); }	"	public Index parseAndUpdateIndex(List<JaxbRoot<XMLEntityMappings>> mappings, Index annotationIndex) {
		List<XMLEntityMappings> list = new ArrayList<XMLEntityMappings>( mappings.size() );
		for ( JaxbRoot<XMLEntityMappings> jaxbRoot : mappings ) {
			list.add( jaxbRoot.getRoot() );
		}
		return new EntityMappingsMocker(
				list, annotationIndex, meta.getServiceRegistry()
		).mockNewIndex();
	}
"	Parses the given xml configuration files and returns a updated annotation index	Parses the given xml configuration files and returns a updated annotation index	0	1	8	8	63
"public Client call123testSpecialTags(Client body) throws ApiException { Object localVarPostBody = body; // verify the required parameter 'body' is set if (body == null) { throw new ApiException(400, ""Missing the required parameter 'body' when calling call123testSpecialTags""); } // create path and map variables String localVarPath = ""/another-fake/dummy""; // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, String> localVarCookieParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { ""application/json"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { ""application/json"" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Client> localVarReturnType = new GenericType<Client>() {}; return apiClient.invokeAPI(localVarPath, ""PATCH"", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	"  public Client call123testSpecialTags(Client body) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, ""Missing the required parameter 'body' when calling call123testSpecialTags"");
    }
    
    // create path and map variables
    String localVarPath = ""/another-fake/dummy"";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    final String[] localVarAccepts = {
      ""application/json""
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      ""application/json""
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    GenericType<Client> localVarReturnType = new GenericType<Client>() {};
    return apiClient.invokeAPI(localVarPath, ""PATCH"", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);
      }
"	To test special tags	To test special tags	0	1	8	38	229
"private int invoke_calculateBufferSize(int tdsVersion, int packetSize) { Class[] classes = new Class[]{int.class, int.class}; Object[] objects = new Object[]{new Integer(tdsVersion), new Integer(packetSize)}; return ((Integer) invokeStaticMethod(Support.class, ""calculateNamedPipeBufferSize"", classes, objects)).intValue(); }"	"    private int invoke_calculateBufferSize(int tdsVersion, int packetSize) {
        Class[] classes = new Class[]{int.class, int.class};
        Object[] objects = new Object[]{new Integer(tdsVersion), new Integer(packetSize)};

        return ((Integer) invokeStaticMethod(SharedNamedPipe.class,
                ""calculateBufferSize"", classes, objects)).intValue();
    }
"	Helper method to invoke  Support#calculateNamedPipeBufferSize(int, int) using reflection.	Helper method to invoke SharedNamedPipe#calculateBufferSize(int, int) using reflection.	1	0	8	9	73
private boolean shouldRegister(InstanceInfo myInfo) { if (!clientConfig.shouldRegisterWithEureka()) { return false; } else if ((myInfo != null) && (myInfo.getDataCenterInfo() .equals(DataCenterInfo.Name.Amazon))) { return true; } return true; }	"    private boolean shouldRegister(InstanceInfo myInfo) {
        if (!clientConfig.shouldRegisterWithEureka()) {
            return false;
        }

        return true;
    }
"	Checks to see if the eureka client registration is enabled.	Checks to see if the eureka client registration is enabled.	0	1	7	12	53
public String getTreeLivePath() { return this.treeLivePath; }	"    public String getTreeLivePath() {
        return treeLivePath;
    }
"	Returns the path to the live tree	DOCUMENT ME!	1	0	5	5	11
"public Builder setHostName(String hostName) { if (hostName == null || hostName.isEmpty()) { logger.warn(""Passed in hostname is blank, not setting it""); return this; } String existingHostName = result.hostName; result.hostName = hostName; if ((existingHostName != null) && !(hostName.equals(existingHostName))) { refreshStatusPageUrl().refreshHealthCheckUrl() .refreshVIPAddress().refreshSecureVIPAddress(); } return this; }"	"        public Builder setHostName(String hostName) {
            String existingHostName = result.hostName;
            result.hostName = hostName;
            if ((existingHostName != null)
                    && !(hostName.equals(existingHostName))) {
                refreshStatusPageUrl().refreshHealthCheckUrl()
                        .refreshVIPAddress().refreshSecureVIPAddress();
            }
            return this;
        }
"	Sets the fully qualified hostname of this running instance.This is mostly used in constructing the  java.net.URL for communicating with the instance.	Sets the fully qualified hostname of this running instance.This is mostly used in constructing the java.net.URL for communicating with the instance.	0	1	7	16	86
"public synchronized VisualItem getItem(String itemClass, Entity entity, boolean create) { ItemEntry entry = (ItemEntry)m_entryMap.get(itemClass); if ( entry != null ) { VisualItem item = (VisualItem)entry.itemMap.get(entity); if ( !create ) { return item; } else if ( item == null ) { item = m_ifactory.getItem(itemClass); item.init(this, itemClass, entity); addItem(entry, entity, item); } if ( item instanceof NodeItem ) ((NodeItem)item).removeAllNeighbors(); item.setDirty(0); item.setVisible(true); return item; } else { throw new IllegalArgumentException(""The input string must be a"" + "" recognized item class!""); } } //"	"	public synchronized GraphItem getItem(String itemClass, Entity entity, boolean create) {
		ItemEntry entry = (ItemEntry)m_entryMap.get(itemClass);
		if ( entry != null ) {
			GraphItem item = (GraphItem)entry.itemMap.get(entity);
			if ( !create ) {
				return item;
			} else if ( item == null ) {
				item = m_ifactory.getItem(itemClass);
				item.init(this, itemClass, entity);
				addItem(entry, entity, item);
			}
            if ( item instanceof NodeItem )
                ((NodeItem)item).removeAllNeighbors();
            item.setDirty(0);
            item.setVisible(true);
			return item;
		} else {
			throw new IllegalArgumentException(""The input string must be a""
						+ "" recognized item class!"");
		}		
	} //
"	Requests a VisualItem of the specified item class corresponding to a given Entity, optionally creating the VisualItem if it doesn't already exist.	Requests a GraphItem of the specified item class corresponding to a given Entity, optionally creating the GraphItem if it doesn't already exist.	1	0	11	23	148
public String getExportDirectory() { return this.exportDirectory; }	"    public String getExportDirectory() {
        return exportDirectory;
    }
"	Returns the path to the export directory	DOCUMENT ME!	1	0	5	5	11
"protected LdapDirectoryInfo performAuthentication(String username, char[] password) { if( searchBase == null ) { throw new IllegalStateException( ""A search base must be specified."" ); } if( url == null ) { throw new IllegalStateException( ""An LDAP URL must be specified of the form ldap://<hostname>:<port>"" ); } if( principalSuffix != null ) { username = username + principalSuffix; } Hashtable<String, String> env = new Hashtable<String, String>(6); env.put(Context.SECURITY_AUTHENTICATION, authentication); env.put(Context.SECURITY_PRINCIPAL, username); env.put(Context.SECURITY_CREDENTIALS, new String( password )); env.put(Context.INITIAL_CONTEXT_FACTORY, contextFactory); env.put(Context.PROVIDER_URL, url); env.put(Context.REFERRAL, refferal); if (log.isDebugEnabled()) { log.debug( ""Initializing LDAP context using environment properties ["" + env + ""]"" ); } LdapContext ctx = null; try { ctx = new InitialLdapContext(env, null); return getLdapDirectoryInfo(username, ctx); } catch (javax.naming.AuthenticationException e) { throw new IncorrectCredentialException( ""User could not be authenticated with LDAP server."", e ); } catch (NamingException e) { throw new AuthenticationException( ""LDAP naming error while attempting to authenticate user."", e ); } finally { // Always close the LDAP context try { if (ctx != null) { ctx.close(); } } catch (NamingException e) { if( log.isErrorEnabled() ) { log.error(""Problem closing Context: "", e); } } } }"	"    protected ActiveDirectoryInfo performAuthentication(String username, char[] password) {

        if( searchBase == null ) {
            throw new IllegalStateException( ""A search base must be specified."" );
        }
        if( url == null ) {
            throw new IllegalStateException( ""An LDAP URL must be specified of the form ldap://<hostname>:<port>"" );
        }


        if( principalSuffix != null ) {
            username = username + principalSuffix;
        }

        Hashtable<String, String> env = new Hashtable<String, String>(6);

        env.put(Context.SECURITY_AUTHENTICATION, authentication);
        env.put(Context.SECURITY_PRINCIPAL, username);
        env.put(Context.SECURITY_CREDENTIALS, new String( password ));
        env.put(Context.INITIAL_CONTEXT_FACTORY, contextFactory);
        env.put(Context.PROVIDER_URL, url);
        env.put(Context.REFERRAL, refferal);

        if (log.isDebugEnabled()) {
            log.debug( ""Initializing LDAP context using environment properties ["" + env + ""]"" );
        }

        LdapContext ctx = null;
        try {
            ctx = new InitialLdapContext(env, null);

            return getActiveDirectoryInfo(username, ctx);


        } catch (javax.naming.AuthenticationException e) {
            throw new IncorrectCredentialException( ""User could not be authenticated with LDAP server."", e );

        } catch (NamingException e) {
            throw new AuthenticationException( ""LDAP naming error while attempting to authenticate user."", e );

        } finally {
            // Always close the LDAP context
            try {
                if (ctx != null) {
                    ctx.close();
                }
            } catch (NamingException e) {
                if( log.isErrorEnabled() ) {
                    log.error(""Problem closing Context: "", e);
                }
            }
        }
    }
"	Performs the actual authentication of the user by connecting to the LDAP server, querying it for user information, and returning an  LdapDirectoryInfo instance containing the results.	Performs the actual authentication of the user by connecting to the LDAP server, querying it for user information, and returning an ActiveDirectoryInfo instance containing the results.	1	0	10	55	311
public EurekaClient getEurekaClient() { return eurekaClient; }	"    public EurekaClient getEurekaClient() {
        return discoveryClient;
    }
"	Get the  EurekaClient implementation.	Get the EurekaClient implementation.	0	1	4	4	10
public DateTime withFields(ReadablePartial partial) { if (partial == null) { return this; } return withMillis(getChronology().set(partial, getMillis())); }	"    public DateTime withFields(ReadablePartial partial) {
        if (partial == null) {
            return this;
        }
        return partial.resolveDateTime(this);
    }
"	Gets a copy of this datetime with the partial set of fields replacing those from this instance.	Gets a copy of this datetime with the partial set of fields replacing those from this instance.	0	1	7	7	35
"public static MRequisitionLine[] forC_OrderLine_ID(Properties ctx, int C_OrderLine_ID, String trxName) { final String whereClause = COLUMNNAME_C_OrderLine_ID+""=?""; List<MRequisitionLine> list = new Query(ctx, MRequisitionLine.Table_Name, whereClause, trxName) .setParameters(new Object[]{C_OrderLine_ID}) .list(); return list.toArray(new MRequisitionLine[list.size()]); }"	"	public static MRequisitionLine forC_OrderLine_ID(Properties ctx, int C_OrderLine_ID, String trxName)
	{
		final String whereClause = COLUMNNAME_C_OrderLine_ID+""=?"";
		return new Query(ctx, MRequisitionLine.Table_Name, whereClause, trxName)
			.setParameters(new Object[]{C_OrderLine_ID})
			.firstOnly();
	}
"	Get corresponding Requisition Line(s) for given Order Line	Get corresponding Requisition Line for given Order Line	1	0	9	10	70
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; // set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { String str = yytext(); int first = str.charAt(0); String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } LOGGER.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: LOGGER.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 55: break; case 2: { return getNext(""<"", yytext()); } case 56: break; case 3: { return getNext(); } case 57: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 58: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 59: break; case 6: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 60: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 61: break; case 8: { return handleQuotes(yytext(), false); } case 62: break; case 9: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 63: break; case 10: { return getNext("">"", yytext()); } case 64: break; case 11: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 65: break; case 12: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 66: break; case 13: { return handleEllipsis(yytext()); } case 67: break; case 14: { return normalizeFractions(yytext()); } case 68: break; case 15: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(); } } case 69: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 70: break; case 17: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 71: break; case 18: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 72: break; case 19: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 73: break; case 20: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 74: break; case 21: { if (normalizeOtherBrackets) { return getNext(""-RSB-"", yytext()); } else { return getNext(); } } case 75: break; case 22: { if (normalizeOtherBrackets) { return getNext(""-LSB-"", yytext()); } else { return getNext(); } } case 76: break; case 23: { if (invertible) { prevWordAfter.append(yytext()); } } case 77: break; case 24: // general lookahead, find correct zzMarkedPos { int zzFState = 13; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 78: break; case 25: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(); } case 79: break; case 26: // lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), true); } case 80: break; case 27: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, origTxt); } case 81: break; case 28: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 82: break; case 29: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 83: break; case 30: // general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 84: break; case 31: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 85: break; case 32: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 86: break; case 33: { // this one should only match if we're basically at the end of file // since the last one matches two things, even newlines String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 87: break; case 34: // lookahead expression with fixed lookahead length yypushback(1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 88: break; case 35: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 1; { /* invert quote - often but not always right */ return handleQuotes(yytext(), true); } case 89: break; case 36: // lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), false); } case 90: break; case 37: { return getNormalizedAmpNext(); } case 91: break; case 38: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, yytext()); } case 92: break; case 39: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, yytext()); } case 93: break; case 40: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 94: break; case 41: // general lookahead, find correct zzMarkedPos { int zzFState = 16; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 17; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 95: break; case 42: { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 96: break; case 43: // general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 97: break; case 44: // general lookahead, find correct zzMarkedPos { int zzFState = 9; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 10; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { // try to work around an apparent jflex bug where it // gets a space at the token end by getting // wrong the length of the trailing context. while (yylength() > 0) { char last = yycharat(yylength()-1); if (last == ' ' || last == '\t' || (last >= '\n' && last <= '\r' || last == '\u0085')) { yypushback(1); } else { break; } } return getNext(); } case 98: break; case 45: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 99: break; case 46: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 100: break; case 47: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { // try to work around an apparent jflex bug where it // gets a space at the token end by getting // wrong the length of the trailing context. while (yylength() > 0) { char last = yycharat(yylength()-1); if (last == ' ' || last == '\t' || (last >= '\n' && last <= '\r' || last == '\u0085')) { yypushback(1); } else { break; } } String s; if (yylength() == 2) { // ""I."", etc. yypushback(1); // return a period next time; s = yytext(); // return the word without the final period } else if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); // return the word without the final period } else { s = yytext(); // return the word WITH the final period yypushback(1); // (redpulication:) also return a period for next time } return getNext(s, yytext()); } case 101: break; case 48: // lookahead expression with fixed lookahead length yypushback(2); { return getNext(); } case 102: break; case 49: // general lookahead, find correct zzMarkedPos { int zzFState = 11; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 12; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 103: break; case 50: { if (splitAssimilations) { yypushback(3) ; return getNext(); } else { return getNext(); } } case 104: break; case 51: // lookahead expression with fixed lookahead length yypushback(1); { return getNormalizedAmpNext(); } case 105: break; case 52: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } return getNext(txt, yytext()); } case 106: break; case 53: // lookahead expression with fixed lookahead length yypushback(4); { return getNext(); } case 107: break; case 54: { String txt = yytext(); if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 108: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }"	"  public Object next() throws java.io.IOException {
    int zzInput;
    int zzAction;

    // cached fields:
    int zzCurrentPosL;
    int zzMarkedPosL;
    int zzEndReadL = zzEndRead;
    char [] zzBufferL = zzBuffer;
    char [] zzCMapL = ZZ_CMAP;

    int [] zzTransL = ZZ_TRANS;
    int [] zzRowMapL = ZZ_ROWMAP;
    int [] zzAttrL = ZZ_ATTRIBUTE;

    while (true) {
      zzMarkedPosL = zzMarkedPos;

      yychar+= zzMarkedPosL-zzStartRead;

      zzAction = -1;

      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
  
      zzState = ZZ_LEXSTATE[zzLexicalState];

      // set up zzAction for empty match case:
      int zzAttributes = zzAttrL[zzState];
      if ( (zzAttributes & 1) == 1 ) {
        zzAction = zzState;
      }


      zzForAction: {
        while (true) {
    
          if (zzCurrentPosL < zzEndReadL)
            zzInput = zzBufferL[zzCurrentPosL++];
          else if (zzAtEOF) {
            zzInput = YYEOF;
            break zzForAction;
          }
          else {
            // store back cached positions
            zzCurrentPos  = zzCurrentPosL;
            zzMarkedPos   = zzMarkedPosL;
            boolean eof = zzRefill();
            // get translated positions and possibly new buffer
            zzCurrentPosL  = zzCurrentPos;
            zzMarkedPosL   = zzMarkedPos;
            zzBufferL      = zzBuffer;
            zzEndReadL     = zzEndRead;
            if (eof) {
              zzInput = YYEOF;
              break zzForAction;
            }
            else {
              zzInput = zzBufferL[zzCurrentPosL++];
            }
          }
          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
          if (zzNext == -1) break zzForAction;
          zzState = zzNext;

          zzAttributes = zzAttrL[zzState];
          if ( (zzAttributes & 1) == 1 ) {
            zzAction = zzState;
            zzMarkedPosL = zzCurrentPosL;
            if ( (zzAttributes & 8) == 8 ) break zzForAction;
          }

        }
      }

      // store back cached position
      zzMarkedPos = zzMarkedPosL;

      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
        case 1: 
          { String str = yytext();
          int first = str.charAt(0);
          String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));
          switch (untokenizable) {
            case NONE_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              break;
            case FIRST_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              if ( ! this.seenUntokenizableCharacter) {
                LOGGER.warning(msg);
                this.seenUntokenizableCharacter = true;
              }
              break;
            case ALL_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              LOGGER.warning(msg);
              this.seenUntokenizableCharacter = true;
              break;
            case NONE_KEEP:
              return getNext();
            case FIRST_KEEP:
              if ( ! this.seenUntokenizableCharacter) {
                LOGGER.warning(msg);
                this.seenUntokenizableCharacter = true;
              }
              return getNext();
            case ALL_KEEP:
              LOGGER.warning(msg);
              this.seenUntokenizableCharacter = true;
              return getNext();
          }
          }
        case 55: break;
        case 2: 
          { return getNext(""<"", yytext());
          }
        case 56: break;
        case 3: 
          { return getNext();
          }
        case 57: break;
        case 4: 
          { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {
                    return getNext(ptbmdash, yytext());
                  } else {
                    return getNext();
                  }
          }
        case 58: break;
        case 5: 
          { if (tokenizeNLs) {
                      return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns
                  } else if (invertible) {
                      prevWordAfter.append(yytext());
                  }
          }
        case 59: break;
        case 6: 
          { final String origTxt = yytext();
                          String tmp = removeSoftHyphens(origTxt);
                          if (americanize) {
                            tmp = Americanize.americanize(tmp);
                          }
                          return getNext(tmp, origTxt);
          }
        case 60: break;
        case 7: 
          { if (invertible) {
                     prevWordAfter.append(yytext());
                  }
          }
        case 61: break;
        case 8: 
          { return handleQuotes(yytext(), false);
          }
        case 62: break;
        case 9: 
          { if (escapeForwardSlashAsterisk) {
                    return getNext(delimit(yytext(), '/'), yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 63: break;
        case 10: 
          { return getNext("">"", yytext());
          }
        case 64: break;
        case 11: 
          { if (ptb3Dashes) {
                            return getNext(ptbmdash, yytext()); }
                          else {
                            return getNext();
                          }
          }
        case 65: break;
        case 12: 
          { return getNext(removeSoftHyphens(yytext()),
                                         yytext());
          }
        case 66: break;
        case 13: 
          { return handleEllipsis(yytext());
          }
        case 67: break;
        case 14: 
          { return normalizeFractions(yytext());
          }
        case 68: break;
        case 15: 
          { if (normalizeCurrency) {
                            return getNext(normalizeCurrency(yytext()), yytext()); }
                          else {
                            return getNext();
                          }
          }
        case 69: break;
        case 16: 
          { if (normalizeOtherBrackets) {
                    return getNext(closebrace, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 70: break;
        case 17: 
          { if (normalizeParentheses) {
                    return getNext(openparen, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 71: break;
        case 18: 
          { if (normalizeParentheses) {
                    return getNext(closeparen, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 72: break;
        case 19: 
          { if (escapeForwardSlashAsterisk) {
                    return getNext(delimit(yytext(), '*'), yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 73: break;
        case 20: 
          { if (normalizeOtherBrackets) {
                    return getNext(openbrace, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 74: break;
        case 21: 
          { if (normalizeOtherBrackets) {
                    return getNext(""-RSB-"", yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 75: break;
        case 22: 
          { if (normalizeOtherBrackets) {
                    return getNext(""-LSB-"", yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 76: break;
        case 23: 
          { if (invertible) {
                            prevWordAfter.append(yytext());
                        }
          }
        case 77: break;
        case 24: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 13;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
            while (zzFPos <= zzMarkedPos) {
              zzFinL[zzFPos++] = false;
            }

            zzFState = 14;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { return getNext();
          }
        case 78: break;
        case 25: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return getNext();
          }
        case 79: break;
        case 26: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return handleQuotes(yytext(), true);
          }
        case 80: break;
        case 27: 
          { final String origTxt = yytext();
                          String txt = origTxt;
                          if (normalizeSpace) {
                            // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                            txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                          }
                          return getNext(txt, origTxt);
          }
        case 81: break;
        case 28: 
          { String txt = yytext();
                  String origText = txt;
                  if (normalizeParentheses) {
                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                  }
                  return getNext(txt, origText);
          }
        case 82: break;
        case 29: 
          { return getNext(removeSoftHyphens(yytext()), yytext());
          }
        case 83: break;
        case 30: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 3;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
            while (zzFPos <= zzMarkedPos) {
              zzFinL[zzFPos++] = false;
            }

            zzFState = 4;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { final String origTxt = yytext();
                          String tmp = removeSoftHyphens(origTxt);
                          if (americanize) {
                            tmp = Americanize.americanize(tmp);
                          }
                          return getNext(tmp, origTxt);
          }
        case 84: break;
        case 31: 
          { if (escapeForwardSlashAsterisk) {
                            return getNext(delimit(yytext(), '/'), yytext());
                          } else {
                            return getNext();
                          }
          }
        case 85: break;
        case 32: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return getNext(removeSoftHyphens(yytext()),
                                         yytext());
          }
        case 86: break;
        case 33: 
          { // this one should only match if we're basically at the end of file
                          // since the last one matches two things, even newlines
                          String s;
                          if (strictTreebank3 && ! ""U.S."".equals(yytext())) {
                            yypushback(1); // return a period for next time
                            s = yytext();
                          } else {
                            s = yytext();
                            yypushback(1); // return a period for next time
                          }
                          return getNext(s, yytext());
          }
        case 87: break;
        case 34: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { String txt = yytext();
                  String origText = txt;
                  if (normalizeParentheses) {
                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                  }
                  return getNext(txt, origText);
          }
        case 88: break;
        case 35: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 1;
          { /* invert quote - often but not always right */
                  return handleQuotes(yytext(), true);
          }
        case 89: break;
        case 36: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return handleQuotes(yytext(), false);
          }
        case 90: break;
        case 37: 
          { return getNormalizedAmpNext();
          }
        case 91: break;
        case 38: 
          { String txt = yytext();
                  if (escapeForwardSlashAsterisk) {
                    txt = delimit(txt, '/');
                  }
                  if (normalizeSpace) {
                    // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                    txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                  }
                  return getNext(txt, yytext());
          }
        case 92: break;
        case 39: 
          { String txt = yytext();
                  if (escapeForwardSlashAsterisk) {
                    txt = delimit(txt, '/');
                  }
                  if (normalizeSpace) {
                    // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                    txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space

                  }
                  return getNext(txt, yytext());
          }
        case 93: break;
        case 40: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 5;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
            while (zzFPos <= zzMarkedPos) {
              zzFinL[zzFPos++] = false;
            }

            zzFState = 6;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { final String txt = yytext();
                          return getNext(removeSoftHyphens(txt),
                                         txt);
          }
        case 94: break;
        case 41: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 16;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
            while (zzFPos <= zzMarkedPos) {
              zzFinL[zzFPos++] = false;
            }

            zzFState = 17;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { return getNext();
          }
        case 95: break;
        case 42: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 15;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
            while (zzFPos <= zzMarkedPos) {
              zzFinL[zzFPos++] = false;
            }

            zzFState = 14;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { return getNext();
          }
        case 96: break;
        case 43: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 9;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
            while (zzFPos <= zzMarkedPos) {
              zzFinL[zzFPos++] = false;
            }

            zzFState = 10;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { // try to work around an apparent jflex bug where it
                          // gets a space at the token end by getting
                          // wrong the length of the trailing context.
                          while (yylength() > 0) {
                            char last = yycharat(yylength()-1);
                            if (last == ' ' || last == '\t' || (last >= '\n' && last <= '\r' || last == '\u0085')) {
                              yypushback(1);
                            } else {
                              break;
                            }
                          }
			  return getNext();
          }
        case 97: break;
        case 44: 
          { String txt = yytext();
                          if (escapeForwardSlashAsterisk) {
                            txt = delimit(txt, '/');
                            txt = delimit(txt, '*');
                          }
                          return getNext(txt, yytext());
          }
        case 98: break;
        case 45: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return getNext(removeSoftHyphens(yytext()),
                                               yytext());
          }
        case 99: break;
        case 46: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 7;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
            while (zzFPos <= zzMarkedPos) {
              zzFinL[zzFPos++] = false;
            }

            zzFState = 8;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { // try to work around an apparent jflex bug where it
                          // gets a space at the token end by getting
                          // wrong the length of the trailing context.
                          while (yylength() > 0) {
                            char last = yycharat(yylength()-1);
                            if (last == ' ' || last == '\t' || (last >= '\n' && last <= '\r' || last == '\u0085')) {
                              yypushback(1);
                            } else {
                              break;
                            }
                          }
                          String s;
			  if (yylength() == 2) { // ""I."", etc.
			    yypushback(1); // return a period next time;
			    s = yytext(); // return the word without the final period
                          } else if (strictTreebank3 && ! ""U.S."".equals(yytext())) {
                            yypushback(1); // return a period for next time
                            s = yytext(); // return the word without the final period
                          } else {
                            s = yytext(); // return the word WITH the final period
                            yypushback(1); // (redpulication:) also return a period for next time
                          }
                          return getNext(s, yytext());
          }
        case 100: break;
        case 47: 
          // lookahead expression with fixed lookahead length
          yypushback(2);
          { return getNext();
          }
        case 101: break;
        case 48: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 11;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
            while (zzFPos <= zzMarkedPos) {
              zzFinL[zzFPos++] = false;
            }

            zzFState = 12;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { String s;
                          if (strictTreebank3 && ! ""U.S."".equals(yytext())) {
                            yypushback(1); // return a period for next time
                            s = yytext();
                          } else {
                            s = yytext();
                            yypushback(1); // return a period for next time
                          }
                          return getNext(s, yytext());
          }
        case 102: break;
        case 49: 
          { if (splitAssimilations) {
                            yypushback(3) ; return getNext();
                          } else {
                            return getNext();
                          }
          }
        case 103: break;
        case 50: 
          { if (splitAssimilations) {
                            yypushback(2) ; return getNext();
                          } else {
                            return getNext();
                          }
          }
        case 104: break;
        case 51: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return getNormalizedAmpNext();
          }
        case 105: break;
        case 52: 
          { String txt = yytext();
                          if (escapeForwardSlashAsterisk) {
                            txt = delimit(txt, '/');
                          }
                          return getNext(txt, yytext());
          }
        case 106: break;
        case 53: 
          // lookahead expression with fixed lookahead length
          yypushback(4);
          { return getNext();
          }
        case 107: break;
        case 54: 
          { String txt = yytext();
                          if (normalizeSpace) {
                            // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                            txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                          }
                          if (normalizeParentheses) {
                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                          }
                          return getNext(txt, yytext());
          }
        case 108: break;
        default: 
          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
            zzAtEOF = true;
              {
                if (invertible) {
            prevWordAfter.append(yytext());
            String str = prevWordAfter.toString();
            prevWordAfter.setLength(0);
            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);
          }
          return null;
              }
          } 
          else {
            zzScanError(ZZ_NO_MATCH);
          }
      }
    }
  }
"	Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.	Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.	0	1	17	739	4512
public Task<EncodedImage> get(List<CacheKey> keys, final AtomicBoolean isCancelled) { Preconditions.checkArgument(!keys.isEmpty()); for (CacheKey key : keys) { final EncodedImage pinnedImage = mStagingArea.get(key); if (pinnedImage != null) { return foundPinnedImage(key, pinnedImage); } } Task<EncodedImage> masterTask = getAsync(keys.get(0), isCancelled); if (keys.size() == 1) { return masterTask; } for (final CacheKey key : keys.subList(1, keys.size())) { masterTask = masterTask.continueWithTask( new Continuation<EncodedImage, Task<EncodedImage>>() { @Override public Task<EncodedImage> then(Task<EncodedImage> previousTask) throws Exception { // If we've got a hit, stop. If this is cancelled, stop. Otherwise, keep going. if (previousTask.isCancelled() || previousTask.getResult() != null) { return previousTask; } return getAsync(key, isCancelled); } }, mReadExecutor); } return masterTask; }	"  public Task<EncodedImage> get(final CacheKey key, final AtomicBoolean isCancelled) {
    Preconditions.checkNotNull(key);
    Preconditions.checkNotNull(isCancelled);

    final EncodedImage pinnedImage = mStagingArea.get(key);
    if (pinnedImage != null) {
      FLog.v(TAG, ""Found image for %s in staging area"", key.toString());
      mImageCacheStatsTracker.onStagingAreaHit();
      return Task.forResult(pinnedImage);
    }

    try {
      return Task.call(
          new Callable<EncodedImage>() {
            @Override
            public EncodedImage call()
                throws Exception {
              if (isCancelled.get()) {
                throw new CancellationException();
              }
              EncodedImage result = mStagingArea.get(key);
              if (result != null) {
                FLog.v(TAG, ""Found image for %s in staging area"", key.toString());
                mImageCacheStatsTracker.onStagingAreaHit();
              } else {
                FLog.v(TAG, ""Did not find image for %s in staging area"", key.toString());
                mImageCacheStatsTracker.onStagingAreaMiss();

                try {
                  final PooledByteBuffer buffer = readFromDiskCache(key);
                  CloseableReference<PooledByteBuffer> ref = CloseableReference.of(buffer);
                  try {
                    result = new EncodedImage(ref);
                  } finally {
                    CloseableReference.closeSafely(ref);
                  }
                } catch (Exception exception) {
                  return null;
                }
              }

              if (Thread.interrupted()) {
                FLog.v(TAG, ""Host thread was interrupted, decreasing reference count"");
                if (result != null) {
                  result.close();
                }
                throw new InterruptedException();
              } else {
                return result;
              }
            }
          },
          mReadExecutor);
    } catch (Exception exception) {
      // Log failure
      // TODO: 3697790
      FLog.w(
          TAG,
          exception,
          ""Failed to schedule disk-cache read for %s"",
          key.toString());
      return Task.forError(exception);
    }
  }
"	Performs lookup of a series of disk cache keys in a single thread.	Performs key-value look up in disk cache.	1	0	13	31	190
public List<List<CoreLabel>> toStatement(List<CoreLabel> question) { TokenSequenceMatcher matcher; if ((matcher = triggerWhatIsThere.matcher(question)).matches()) { // must come before triggerWhatIs return postProcess(question, processWhatIsThere(matcher)); } else if ((matcher = triggerWhNNIs.matcher(question)).matches()) { // must come before triggerWhatIs return postProcess(question, processWhNNIs(matcher)); } else if ((matcher = triggerWhNNHave.matcher(question)).matches()) { // must come before triggerWhatHave return postProcess(question, processWhNNHaveIs(matcher)); } else if ((matcher = triggerWhNNHaveNN.matcher(question)).matches()) { // must come before triggerWhatHave return postProcess(question, processWhNNHaveNN(matcher)); } else if ((matcher = triggerHow.matcher(question)).matches()) { // must come before triggerWhatIs return postProcess(question, processHow(matcher)); } else if ((matcher = triggerHowMuchDo.matcher(question)).matches()) { return postProcess(question, processHowMuchDo(matcher)); } else if ((matcher = triggerWhatIs.matcher(question)).matches()) { return postProcess(question, processWhatIs(matcher)); } else if ((matcher = triggerWhatHave.matcher(question)).matches()) { return postProcess(question, processWhatHave(matcher)); } else if ((matcher = triggerWhereDo.matcher(question)).matches()) { return postProcess(question, processWhereDo(matcher, question)); } else if ((matcher = triggerWhereIs.matcher(question)).matches()) { return postProcess(question, processWhereIs(matcher)); } else if ((matcher = triggerWhoIs.matcher(question)).matches()) { return postProcess(question, processWhoIs(matcher)); } else if ((matcher = triggerWhoDid.matcher(question)).matches()) { return postProcess(question, processWhoDid(matcher)); } else if ((matcher = triggerWhatDo.matcher(question)).matches()) { return postProcess(question, processWhatDo(matcher)); } else if ((matcher = triggerWhenDo.matcher(question)).matches()) { return postProcess(question, processWhenDo(matcher)); } else { return Collections.emptyList(); } }	"  public List<List<CoreLabel>> toStatement(List<CoreLabel> question) {
    TokenSequenceMatcher matcher;
    if ((matcher = triggerWhatIsThere.matcher(question)).matches()) {  // must come before triggerWhatIs
      return postProcess(question, processWhatIsThere(matcher));
    } else if ((matcher = triggerWhNNIs.matcher(question)).matches()) {  // must come before triggerWhatIs
      return postProcess(question, processWhNNIs(matcher));
    } else if ((matcher = triggerWhNNHave.matcher(question)).matches()) {  // must come before triggerWhatHave
      return postProcess(question, processWhNNHaveIs(matcher));
    } else if ((matcher = triggerWhNNHaveNN.matcher(question)).matches()) {  // must come before triggerWhatHave
      return postProcess(question, processWhNNHaveNN(matcher));
    } else if ((matcher = triggerWhatIs.matcher(question)).matches()) {
      return postProcess(question, processWhatIs(matcher));
    } else if ((matcher = triggerWhatHave.matcher(question)).matches()) {
      return postProcess(question, processWhatHave(matcher));
    } else if ((matcher = triggerWhereDo.matcher(question)).matches()) {
      return postProcess(question, processWhereDo(matcher, question));
    } else if ((matcher = triggerWhereIs.matcher(question)).matches()) {
      return postProcess(question, processWhereIs(matcher));
    } else if ((matcher = triggerWhoIs.matcher(question)).matches()) {
      return postProcess(question, processWhoIs(matcher));
    } else if ((matcher = triggerWhoDid.matcher(question)).matches()) {
      return postProcess(question, processWhoDid(matcher));
    } else if ((matcher = triggerWhatDo.matcher(question)).matches()) {
      return postProcess(question, processWhatDo(matcher));
    } else if ((matcher = triggerWhenDo.matcher(question)).matches()) {
      return postProcess(question, processWhenDo(matcher));
    } else if ((matcher = triggerHow.matcher(question)).matches()) {
      return postProcess(question, processHow(matcher));
    } else {
      return Collections.emptyList();
    }
  }
"	Convert a question to a statement, if possible.	Convert a question to a statement, if possible.	0	1	21	35	447
"public boolean checkAlreadyExist(AccountDatabase.AccountName s) { // Query in the realm database RealmQuery<AccountDatabase> query = realm.where(AccountDatabase.class); // Checking if string equals to is exist or not query.equalTo(""name"", s.toString()); RealmResults<AccountDatabase> result1 = query.findAll(); // Here checking if count of that values is greater than zero return result1.size() > 0; }"	"    public boolean checkAlreadyExist(AccountDatabase.AccountName s) {

        // Query in the realm database
        RealmQuery<AccountDatabase> query = realm.where(AccountDatabase.class);

        // Checking if string equals to is exist or not
        query.equalTo(""name"", s.toString());
        RealmResults<AccountDatabase> result1 = query.findAll();

        // Here checking if count of that values is greater than zero
        return (result1.size() > 0) ? true : false;
    }
"	This function check if the selected account is already existed.	This function check if the selected account is already existed.	0	1	7	13	79
"private ASN1Object toASN1Object( X509Certificate cert) throws CertificateEncodingException { try { return new ASN1InputStream(cert.getEncoded()).readObject(); } catch (Exception e) { throw new CertificateEncodingException(""Exception while encoding certificate: "" + e.toString()); } }"	"    private DERObject toASN1Object(
        X509Certificate cert)
        throws CertificateEncodingException
    {
        try
        {
            return new ASN1InputStream(cert.getEncoded()).readObject();
        }
        catch (Exception e)
        {
            throw new CertificateEncodingException(""Exception while encoding certificate: "" + e.toString());
        }
    }
"	Return a ASN1Object containing the encoded certificate.	Return a DERObject containing the encoded certificate.	1	0	8	15	52
"private Expression translate0(RexNode expr, RexImpTable.NullAs nullAs) { if (expr instanceof RexInputRef) { final int index = ((RexInputRef) expr).getIndex(); Expression x = inputGetter.field(list, index); return list.append( ""v"", nullAs.handle( list.append(""v"", x))); } if (expr instanceof RexLocalRef) { return translate( program.getExprList().get(((RexLocalRef) expr).getIndex()), nullAs); } if (expr instanceof RexLiteral) { return translateLiteral( expr, typeFactory.createTypeWithNullability( expr.getType(), isNullable(expr) && nullAs != RexImpTable.NullAs.NOT_POSSIBLE), typeFactory, nullAs); } if (expr instanceof RexCall) { final RexCall call = (RexCall) expr; final SqlOperator operator = call.getOperator(); RexImpTable.CallImplementor implementor = RexImpTable.INSTANCE.get(operator); if (implementor != null) { return implementor.implement(this, call, nullAs); } } switch (expr.getKind()) { default: throw new RuntimeException( ""cannot translate expression "" + expr); } }"	"    private Expression translate0(RexNode expr, RexImpTable.NullAs nullAs) {
        if (expr instanceof RexInputRef) {
            final int index = ((RexInputRef) expr).getIndex();
            Expression x = inputGetter.field(list, index);
            return nullAs.handle(list.append(""v"", x));
        }
        if (expr instanceof RexLocalRef) {
            return translate(
                program.getExprList().get(((RexLocalRef) expr).getIndex()),
                nullAs);
        }
        if (expr instanceof RexLiteral) {
            return translateLiteral(
                expr,
                typeFactory.createTypeWithNullability(
                    expr.getType(),
                    isNullable(expr)
                    && nullAs != RexImpTable.NullAs.NOT_POSSIBLE),
                typeFactory,
                nullAs);
        }
        if (expr instanceof RexCall) {
            final RexCall call = (RexCall) expr;
            final SqlOperator operator = call.getOperator();
            RexImpTable.CallImplementor implementor =
                RexImpTable.INSTANCE.get(operator);
            if (implementor != null) {
                return implementor.implement(this, call, nullAs);
            }
        }
        switch (expr.getKind()) {
        default:
            throw new RuntimeException(
                ""cannot translate expression "" + expr);
        }
    }
"	Translates an expression that is not in the cache.	Translates an expression that is not in the cache.	0	1	10	40	214
public static String jenkinsJobName(BuildConfig bc) { String namespace = bc.getMetadata().getNamespace(); String name = bc.getMetadata().getName(); return jenkinsJobName(namespace, name); }	"  public static String jenkinsJobName(BuildConfig bc, String defaultNamespace) {
    String namespace = bc.getMetadata().getNamespace();
    String name = bc.getMetadata().getName();
    return jenkinsJobName(namespace, name, defaultNamespace);
  }
"	Finds the Jenkins job name for the given  BuildConfig.	Finds the Jenkins job for the given BuildConfig and defaultNamespace	1	0	6	7	38
public String toDefaultValue(Schema schema) { if (schema.getDefault() != null) { return schema.getDefault().toString(); } return getPropertyDefaultValue(schema); }	"    public String toDefaultValue(Schema schema) {
        if (schema.getDefault() != null) {
            return schema.getDefault().toString();
        }

        if (ModelUtils.isBooleanSchema(schema)) {
            return ""null"";
        } else if (ModelUtils.isDateSchema(schema)) {
            return ""null"";
        } else if (ModelUtils.isDateTimeSchema(schema)) {
            return ""null"";
        } else if (ModelUtils.isNumberSchema(schema)) {
            return ""null"";
        } else if (ModelUtils.isIntegerSchema(schema)) {
            return ""null"";
        } else if (ModelUtils.isStringSchema(schema)) {
            return ""null"";
        } else if (ModelUtils.isObjectSchema(schema)) {
            return ""null"";
        } else {
            return ""null"";
        }
    }
"	Return the default value of the property	Return the default value of the property	0	1	7	8	35
public static TokenSequencePattern compile(SequencePattern.PatternExpr nodeSequencePattern) { return new TokenSequencePattern(null, nodeSequencePattern); }	"  public static TokenSequencePattern compile(Env env, String... strings)
  {
    try {
      List<SequencePattern.PatternExpr> patterns = new ArrayList<SequencePattern.PatternExpr>();
      for (String string:strings) {
        // TODO: Check token sequence parser?
        SequencePattern.PatternExpr pattern = env.parser.parseSequence(env, string);
        patterns.add(pattern);
      }
      SequencePattern.PatternExpr nodeSequencePattern = new SequencePattern.SequencePatternExpr(patterns);
      return new TokenSequencePattern(StringUtils.join(strings), nodeSequencePattern);
    } catch (Exception ex) {
      throw new RuntimeException(ex);
    }
  }
"	Compiles a PatternExpr into a TokenSequencePattern.	Compiles a sequence of regular expression a TokenSequencePattern using the specified environment.	1	0	5	5	20
private boolean isBreakOnOpcode(Integer opcode) { boolean shouldBreak = false; if (config.isBreakOnPingPong()) { // break on every message type shouldBreak = true; } else { // break only on non-ping/pong boolean isPing = opcode.equals(WebSocketMessage.OPCODE_PING); boolean isPong = opcode.equals(WebSocketMessage.OPCODE_PONG); if (!isPing && !isPong) { shouldBreak = true; } } return shouldBreak; }	"	private boolean isBreakOnOpcode(Integer opcode) {
		if (config.isBreakOnPingPong()) {
			// break on every message type
			return true;
		} else {
			// break only on non-ping/pong
			boolean isPing = opcode.equals(WebSocketMessage.OPCODE_PING);
			boolean isPong = opcode.equals(WebSocketMessage.OPCODE_PONG);
			
			if (!isPing && !isPong) {
				return true;
			}
		}
		return false;
	}
"	Check out if breakpoint should be applied on given  WebSocketMessageDTO#opcode.	Check out if breakpoint should be applied on given WebSocketMessageDTO#opcode.	0	1	9	17	80
public DataFetcher getDataFetcher(FieldCoordinates coordinates, GraphQLFieldDefinition fieldDefinition) { return getDataFetcherImpl(coordinates, fieldDefinition, dataFetcherMap, systemDataFetcherMap); }	"    public DataFetcher getDataFetcher(GraphQLFieldsContainer parentType, GraphQLFieldDefinition fieldDefinition) {
        return getDataFetcherImpl(parentType, fieldDefinition, dataFetcherMap, systemDataFetcherMap);
    }
"	Returns a data fetcher associated with a field located at specified coordinates.	Returns a data fetcher associated with a field within a container type	1	0	5	4	24
public static RelNode createDistinctRel(RelNode rel) { return LogicalAggregate.create(rel, ImmutableBitSet.range(rel.getRowType().getFieldCount()), null, ImmutableList.of()); }	"  public static RelNode createDistinctRel(RelNode rel) {
    return LogicalAggregate.create(rel,
        ImmutableBitSet.range(rel.getRowType().getFieldCount()), null,
        ImmutableList.<AggregateCall>of());
  }
"	Creates a LogicalAggregate that removes all duplicates from the result of an underlying relational expression.	Creates a LogicalAggregate that removes all duplicates from the result of an underlying relational expression.	0	1	7	6	36
public static List<SLARegistrationBean> fromJSONArray(JSONArray array) { List<SLARegistrationBean> list = new ArrayList<SLARegistrationBean>(); for (Object obj : array) { list.add(new SLARegistrationBean((JSONObject) obj)); } return list; }	"    public static List<SLAEvent> fromJSONArray(JSONArray array) {
        List<SLAEvent> list = new ArrayList<SLAEvent>();
        for (Object obj : array) {
            list.add(new JsonSLARegistrationEvent((JSONObject) obj));
        }
        return list;
    }
"	Convert a JSONArray into a SLARegistrationBean list.	Convert a JSONArray into a SLAEvent list.	1	0	9	9	45
public static EString substring(Expr<String> left, int right) { return factory.createString(Ops.SUBSTR1ARG, left, factory.createConstant(right)); }	"    public static EString substring(Expr<String> left, int right) {
        return createString(Ops.SUBSTR1ARG, left, createConstant(right));
    }
"	Expr : left.substring(right)	Expr : left.substring(right)	0	1	6	4	30
public boolean isEmpty() { return this.tags.isEmpty(); }	"        public boolean isEmpty() {
            return tags.isEmpty();
        }
"	Checks if the tag stack is empty	DOCUMENT ME!	1	0	5	5	14
public static EDateTime<Date> currentTimestamp() { return currentTimestamp(Date.class); }	"    public static EDateTime<Date> currentTimestamp() {
        return ODateTime.create(Date.class, Ops.DateTimeOps.CURRENT_TIMESTAMP);
    }
"	Get an expression representing the current time instant as a EDateTime instance	Get an expression representing the current time instant as a EDateTime instance	0	1	6	4	16
"public static String getReconcileHashCode(TreeMap<String, AtomicInteger> instanceCountMap) { String reconcileHashCode = """"; for (Map.Entry<String, AtomicInteger> mapEntry : instanceCountMap .entrySet()) { reconcileHashCode = reconcileHashCode + mapEntry.getKey() + STATUS_DELIMITER + mapEntry.getValue().get() + STATUS_DELIMITER; } return reconcileHashCode; }"	"    public String getReconcileHashCode() {
        TreeMap<String, AtomicInteger> instanceCountMap = new TreeMap<String, AtomicInteger>();
        populateInstanceCountMap(instanceCountMap);
        return getReconcileHashCode(instanceCountMap);
    }
"	Gets the reconciliation hashcode.	Gets the hash code for this applications instance.	1	0	11	11	57
"public int yylex() throws java.io.IOException { int yy_input; int yy_action; // cached fields: int yy_currentPos_l; int yy_startRead_l; int yy_markedPos_l; int yy_endRead_l = yy_endRead; char[] yy_buffer_l = yy_buffer; char[] yycmap_l = yycmap; int[] yytrans_l = yytrans; int[] yy_rowMap_l = yy_rowMap; byte[] yy_attr_l = YY_ATTRIBUTE; while (true) { yy_markedPos_l = yy_markedPos; yy_action = -1; yy_startRead_l = yy_currentPos_l = yy_currentPos = yy_startRead = yy_markedPos_l; yy_state = yy_lexical_state; yy_forAction: { while (true) { if (yy_currentPos_l < yy_endRead_l) { yy_input = yy_buffer_l[yy_currentPos_l++]; } else if (yy_atEOF) { yy_input = YYEOF; break yy_forAction; } else { // store back cached positions yy_currentPos = yy_currentPos_l; yy_markedPos = yy_markedPos_l; boolean eof = yy_refill(); // get translated positions and possibly new buffer yy_currentPos_l = yy_currentPos; yy_markedPos_l = yy_markedPos; yy_buffer_l = yy_buffer; yy_endRead_l = yy_endRead; if (eof) { yy_input = YYEOF; break yy_forAction; } else { yy_input = yy_buffer_l[yy_currentPos_l++]; } } int yy_next = yytrans_l[yy_rowMap_l[yy_state] + yycmap_l[yy_input]]; if (yy_next == -1) { break yy_forAction; } yy_state = yy_next; int yy_attributes = yy_attr_l[yy_state]; if ((yy_attributes & 1) == 1) { yy_action = yy_state; yy_markedPos_l = yy_currentPos_l; if ((yy_attributes & 8) == 8) { break yy_forAction; } } } } // store back cached position yy_markedPos = yy_markedPos_l; switch (yy_action) { case 4: case 9: case 10: case 13: { return ACCEPT; } case 19: break; case 5: case 6: case 7: { return IGNORE; } case 20: break; case 2: { return IGNORE; } case 21: break; case 15: { yybegin(SENTENCE); /* System.out.println(""Beginning of sentence""); */ return ACCEPT; } case 22: break; case 3: { System.out.print(yytext()); } case 23: break; case 16: case 17: { yybegin(YYINITIAL); /* System.out.println(""End of sentence""); */ return ACCEPT; } case 24: break; default: if (yy_input == YYEOF && yy_startRead == yy_currentPos) { yy_atEOF = true; return YYEOF; } else { yy_ScanError(YY_NO_MATCH); } } } }"	"  public int yylex() throws java.io.IOException {
    int zzInput;
    int zzAction;

    // cached fields:
    int zzCurrentPosL;
    int zzMarkedPosL;
    int zzEndReadL = zzEndRead;
    char [] zzBufferL = zzBuffer;
    char [] zzCMapL = ZZ_CMAP;

    int [] zzTransL = ZZ_TRANS;
    int [] zzRowMapL = ZZ_ROWMAP;
    int [] zzAttrL = ZZ_ATTRIBUTE;

    while (true) {
      zzMarkedPosL = zzMarkedPos;

      zzAction = -1;

      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
  
      zzState = ZZ_LEXSTATE[zzLexicalState];


      zzForAction: {
        while (true) {
    
          if (zzCurrentPosL < zzEndReadL)
            zzInput = zzBufferL[zzCurrentPosL++];
          else if (zzAtEOF) {
            zzInput = YYEOF;
            break zzForAction;
          }
          else {
            // store back cached positions
            zzCurrentPos  = zzCurrentPosL;
            zzMarkedPos   = zzMarkedPosL;
            boolean eof = zzRefill();
            // get translated positions and possibly new buffer
            zzCurrentPosL  = zzCurrentPos;
            zzMarkedPosL   = zzMarkedPos;
            zzBufferL      = zzBuffer;
            zzEndReadL     = zzEndRead;
            if (eof) {
              zzInput = YYEOF;
              break zzForAction;
            }
            else {
              zzInput = zzBufferL[zzCurrentPosL++];
            }
          }
          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
          if (zzNext == -1) break zzForAction;
          zzState = zzNext;

          int zzAttributes = zzAttrL[zzState];
          if ( (zzAttributes & 1) == 1 ) {
            zzAction = zzState;
            zzMarkedPosL = zzCurrentPosL;
            if ( (zzAttributes & 8) == 8 ) break zzForAction;
          }

        }
      }

      // store back cached position
      zzMarkedPos = zzMarkedPosL;

      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
        case 5: 
          { yybegin(YYINITIAL);
                     /* System.out.println(""End of sentence""); */
                            return ACCEPT;
          }
        case 6: break;
        case 3: 
          { return ACCEPT;
          }
        case 7: break;
        case 4: 
          { yybegin(SENTENCE);
			  /* System.out.println(""Beginning of sentence""); */
			  return ACCEPT;
          }
        case 8: break;
        case 2: 
          { System.out.print(yytext());
          }
        case 9: break;
        case 1: 
          { return IGNORE;
          }
        case 10: break;
        default: 
          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
            zzAtEOF = true;
            return YYEOF;
          } 
          else {
            zzScanError(ZZ_NO_MATCH);
          }
      }
    }
  }
"	Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.	Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.	0	1	17	131	441
protected TokenResponse executeRefreshToken() throws IOException { if (refreshToken == null) { return null; } return new RefreshTokenRequest(transport, jsonFactory, new GenericUrl(tokenServerEncodedUrl), refreshToken).setClientAuthentication(clientAuthentication) .setRequestInitializer(requestInitializer).execute(); }	"  protected TokenResponse executeRefreshToken() throws IOException {
    return new RefreshTokenRequest(transport, jsonFactory, new GenericUrl(tokenServerEncodedUrl),
        refreshToken).setClientAuthentication(clientAuthentication)
        .setRequestInitializer(requestInitializer).execute();
  }
"	Executes a request for new credentials from the token server.	Executes the request for a new refresh token from the authorization endpoint from #refreshToken().	1	0	6	10	47
public List<Pet> findPetsByTags(List<String> tags) throws ApiException { ApiResponse<List<Pet>> localVarResp = findPetsByTagsWithHttpInfo(tags); return localVarResp.getData(); }	"    public List<Pet> findPetsByTags(List<String> tags) throws ApiException {
        ApiResponse<List<Pet>> resp = findPetsByTagsWithHttpInfo(tags);
        return resp.getData();
    }
"	Finds Pets by tags	Finds Pets by tags	0	1	8	5	28
"public ClassLoader getClassLoader() { SecurityManager smgr = System.getSecurityManager(); ClassLoader loader = getClassLoaderImpl(); if (smgr != null && loader != null) { ClassLoader calling = VMStack.getCallingClassLoader(); if (calling != null && !calling.isAncestorOf(loader)) { smgr.checkPermission(new RuntimePermission(""getClassLoader"")); } } if (this.isPrimitive()) { return null; } if (loader == null) { loader = BootClassLoader.getInstance(); } return loader; }"	"    public ClassLoader getClassLoader() {
        SecurityManager smgr = System.getSecurityManager();
        if (smgr != null) {
            ClassLoader calling = VMStack.getCallingClassLoader();
            ClassLoader current = getClassLoaderImpl();

            if (calling != null && !calling.getClass().isInstance(current)) {
                smgr.checkPermission(new RuntimePermission(""getClassLoader""));
            }
        }
        
        ClassLoader loader = getClassLoaderImpl();
        if (loader == null) {
            loader = BootClassLoader.getInstance();
        }
        
        return loader;
    }
"	Returns the class loader which was used to load the class represented by this  Class.	Returns the class loader which was used to load the class represented by the receiver.	1	0	10	23	96
"protected boolean performInitialSync() { try { delaySnapshotIfNeeded(); } catch (InterruptedException e) { logger.info(""Interrupted while awaiting initial snapshot delay""); return false; } logger.info(""Beginning initial sync of '{}' at {}"", rsName, source.lastOffset(rsName)); source.startInitialSync(replicaSet.replicaSetName()); // Set up our recorder to buffer the last record ... try { bufferedRecorder.startBuffering(); } catch (InterruptedException e) { // Do nothing so that this thread is terminated ... logger.info(""Interrupted while waiting to flush the buffer before starting an initial sync of '{}'"", rsName); return false; } // Get the current timestamp of this processor ... final long syncStart = clock.currentTimeInMillis(); // We need to copy each collection, so put the collection IDs into a queue ... final List<CollectionId> collections = primaryClient.collections(); final Queue<CollectionId> collectionsToCopy = new ConcurrentLinkedQueue<>(collections); final int numThreads = Math.min(collections.size(), context.getConnectionContext().maxNumberOfCopyThreads()); final CountDownLatch latch = new CountDownLatch(numThreads); final AtomicBoolean aborted = new AtomicBoolean(false); final AtomicInteger replicatorThreadCounter = new AtomicInteger(0); final AtomicInteger numCollectionsCopied = new AtomicInteger(); final AtomicLong numDocumentsCopied = new AtomicLong(); // And start threads to pull collection IDs from the queue and perform the copies ... logger.info(""Preparing to use {} thread(s) to sync {} collection(s): {}"", numThreads, collections.size(), Strings.join("", "", collections)); for (int i = 0; i != numThreads; ++i) { copyThreads.submit(() -> { context.configureLoggingContext(replicaSet.replicaSetName() + ""-sync"" + replicatorThreadCounter.incrementAndGet()); // Continue to pull a collection ID and copy the collection ... try { CollectionId id = null; while (!aborted.get() && (id = collectionsToCopy.poll()) != null) { long start = clock.currentTimeInMillis(); logger.info(""Starting initial sync of '{}'"", id); long numDocs = copyCollection(id, syncStart); numCollectionsCopied.incrementAndGet(); numDocumentsCopied.addAndGet(numDocs); long duration = clock.currentTimeInMillis() - start; logger.info(""Completing initial sync of {} documents from '{}' in {}"", numDocs, id, Strings.duration(duration)); } } catch (InterruptedException e) { // Do nothing so that this thread is terminated ... aborted.set(true); } finally { latch.countDown(); } }); } // Wait for all of the threads to complete ... try { latch.await(); } catch (InterruptedException e) { Thread.interrupted(); aborted.set(true); } this.copyThreads.shutdown(); // Stopping the replicator does not interrupt *our* thread but does interrupt the copy threads. // Therefore, check the aborted state here ... long syncDuration = clock.currentTimeInMillis() - syncStart; if (aborted.get()) { int remaining = collections.size() - numCollectionsCopied.get(); logger.info(""Initial sync aborted after {} with {} of {} collections incomplete"", Strings.duration(syncDuration), remaining, collections.size()); return false; } // We completed the initial sync, so record this in the source ... source.stopInitialSync(replicaSet.replicaSetName()); try { // And immediately flush the last buffered source record with the updated offset ... bufferedRecorder.stopBuffering(source.lastOffset(rsName)); } catch (InterruptedException e) { logger.info(""Interrupted while waiting for last initial sync record from replica set '{}' to be recorded"", rsName); return false; } logger.info(""Initial sync of {} collections with a total of {} documents completed in {}"", collections.size(), numDocumentsCopied.get(), Strings.duration(syncDuration)); return true; }"	"    protected boolean performInitialSync() {
        delaySnapshotIfNeeded();

        logger.info(""Beginning initial sync of '{}' at {}"", rsName, source.lastOffset(rsName));
        source.startInitialSync(replicaSet.replicaSetName());

        // Set up our recorder to buffer the last record ...
        try {
            bufferedRecorder.startBuffering();
        } catch (InterruptedException e) {
            // Do nothing so that this thread is terminated ...
            logger.info(""Interrupted while waiting to flush the buffer before starting an initial sync of '{}'"", rsName);
            return false;
        }

        // Get the current timestamp of this processor ...
        final long syncStart = clock.currentTimeInMillis();

        // We need to copy each collection, so put the collection IDs into a queue ...
        final List<CollectionId> collections = primaryClient.collections();
        final Queue<CollectionId> collectionsToCopy = new ConcurrentLinkedQueue<>(collections);
        final int numThreads = Math.min(collections.size(), context.getConnectionContext().maxNumberOfCopyThreads());
        final CountDownLatch latch = new CountDownLatch(numThreads);
        final AtomicBoolean aborted = new AtomicBoolean(false);
        final AtomicInteger replicatorThreadCounter = new AtomicInteger(0);
        final AtomicInteger numCollectionsCopied = new AtomicInteger();
        final AtomicLong numDocumentsCopied = new AtomicLong();

        // And start threads to pull collection IDs from the queue and perform the copies ...
        logger.info(""Preparing to use {} thread(s) to sync {} collection(s): {}"",
                    numThreads, collections.size(), Strings.join("", "", collections));
        for (int i = 0; i != numThreads; ++i) {
            copyThreads.submit(() -> {
                context.configureLoggingContext(replicaSet.replicaSetName() + ""-sync"" + replicatorThreadCounter.incrementAndGet());
                // Continue to pull a collection ID and copy the collection ...
                try {
                    CollectionId id = null;
                    while (!aborted.get() && (id = collectionsToCopy.poll()) != null) {
                        long start = clock.currentTimeInMillis();
                        logger.info(""Starting initial sync of '{}'"", id);
                        long numDocs = copyCollection(id, syncStart);
                        numCollectionsCopied.incrementAndGet();
                        numDocumentsCopied.addAndGet(numDocs);
                        long duration = clock.currentTimeInMillis() - start;
                        logger.info(""Completing initial sync of {} documents from '{}' in {}"", numDocs, id, Strings.duration(duration));
                    }
                } catch (InterruptedException e) {
                    // Do nothing so that this thread is terminated ...
                    aborted.set(true);
                } finally {
                    latch.countDown();
                }
            });
        }

        // Wait for all of the threads to complete ...
        try {
            latch.await();
        } catch (InterruptedException e) {
            Thread.interrupted();
            aborted.set(true);
        }
        this.copyThreads.shutdown();

        // Stopping the replicator does not interrupt *our* thread but does interrupt the copy threads.
        // Therefore, check the aborted state here ...
        long syncDuration = clock.currentTimeInMillis() - syncStart;
        if (aborted.get()) {
            int remaining = collections.size() - numCollectionsCopied.get();
            logger.info(""Initial sync aborted after {} with {} of {} collections incomplete"",
                        Strings.duration(syncDuration), remaining, collections.size());
            return false;
        }

        // We completed the initial sync, so record this in the source ...
        source.stopInitialSync(replicaSet.replicaSetName());
        try {
            // And immediately flush the last buffered source record with the updated offset ...
            bufferedRecorder.stopBuffering(source.lastOffset(rsName));
        } catch (InterruptedException e) {
            logger.info(""Interrupted while waiting for last initial sync record from replica set '{}' to be recorded"", rsName);
            return false;
        }

        logger.info(""Initial sync of {} collections with a total of {} documents completed in {}"",
                    collections.size(), numDocumentsCopied.get(), Strings.duration(syncDuration));
        return true;
    }
"	Perform the initial sync of the collections in the replica set.	Perform the initial sync of the collections in the replica set.	0	1	14	95	780
public Q addFetchGroup(String fetchGroupName) { fetchGroups.add(fetchGroupName); return queryMixin.getSelf(); }	"    public Q addFetchGroup(String fetchGroupName) {
        fetchGroups.add(fetchGroupName);
        return (Q) this;
    }
"	Add the fetch group to the set of active fetch groups.	Add the fetch group to the set of active fetch groups.	0	1	5	5	21
public Future<HttpResponse> executeAsync(Executor executor) { FutureTask<HttpResponse> future = new FutureTask<HttpResponse>(new Callable<HttpResponse>() { public HttpResponse call() throws Exception { return execute(); } }); executor.execute(future); return future; }	"  public Future<HttpResponse> executeAsync(Executor exec) {
    final SettableFuture<HttpResponse> future = SettableFuture.create();
    exec.execute(new Runnable() {
      public void run() {
        try {
          future.set(execute());
        } catch (IOException ex) {
          future.setException(ex);
        }
      }
    });
    return future;
  }
"	Executes this request asynchronously in a single separate thread using the supplied executor.	Executes this request asynchronously using #executeAsync(Executor) in a single separate thread using the supplied Executor.	1	0	9	12	49
"public Object readObject() throws JMSException { initializeReading(); try { this.dataIn.mark(65); int type = this.dataIn.read(); if (type == -1) { throw new MessageEOFException(""reached end of data""); } if (type == MarshallingSupport.NULL) { return null; } if (type == MarshallingSupport.BIG_STRING_TYPE) { return MarshallingSupport.readUTF8(dataIn); } if (type == MarshallingSupport.STRING_TYPE) { return this.dataIn.readUTF(); } if (type == MarshallingSupport.LONG_TYPE) { return Long.valueOf(this.dataIn.readLong()); } if (type == MarshallingSupport.INTEGER_TYPE) { return Integer.valueOf(this.dataIn.readInt()); } if (type == MarshallingSupport.SHORT_TYPE) { return Short.valueOf(this.dataIn.readShort()); } if (type == MarshallingSupport.BYTE_TYPE) { return Byte.valueOf(this.dataIn.readByte()); } if (type == MarshallingSupport.FLOAT_TYPE) { return new Float(this.dataIn.readFloat()); } if (type == MarshallingSupport.DOUBLE_TYPE) { return new Double(this.dataIn.readDouble()); } if (type == MarshallingSupport.BOOLEAN_TYPE) { return this.dataIn.readBoolean() ? Boolean.TRUE : Boolean.FALSE; } if (type == MarshallingSupport.CHAR_TYPE) { return Character.valueOf(this.dataIn.readChar()); } if (type == MarshallingSupport.BYTE_ARRAY_TYPE) { int len = this.dataIn.readInt(); byte[] value = new byte[len]; this.dataIn.readFully(value); return value; } else { this.dataIn.reset(); throw new MessageFormatException(""unknown type""); } } catch (NumberFormatException mfe) { try { this.dataIn.reset(); } catch (IOException ioe) { throw JMSExceptionSupport.create(ioe); } throw mfe; } catch (EOFException e) { JMSException jmsEx = new MessageEOFException(e.getMessage()); jmsEx.setLinkedException(e); throw jmsEx; } catch (IOException e) { JMSException jmsEx = new MessageFormatException(e.getMessage()); jmsEx.setLinkedException(e); throw jmsEx; } }"	"    public Object readObject() throws JMSException {
        initializeReading();
        try {
            this.dataIn.mark(65);
            int type = this.dataIn.read();
            if (type == -1) {
                throw new MessageEOFException(""reached end of data"");
            }
            if (type == MarshallingSupport.NULL) {
                return null;
            }
            if (type == MarshallingSupport.BIG_STRING_TYPE) {
                return MarshallingSupport.readUTF8(dataIn);
            }
            if (type == MarshallingSupport.STRING_TYPE) {
                return this.dataIn.readUTF();
            }
            if (type == MarshallingSupport.LONG_TYPE) {
                return new Long(this.dataIn.readLong());
            }
            if (type == MarshallingSupport.INTEGER_TYPE) {
                return new Integer(this.dataIn.readInt());
            }
            if (type == MarshallingSupport.SHORT_TYPE) {
                return new Short(this.dataIn.readShort());
            }
            if (type == MarshallingSupport.BYTE_TYPE) {
                return new Byte(this.dataIn.readByte());
            }
            if (type == MarshallingSupport.FLOAT_TYPE) {
                return new Float(this.dataIn.readFloat());
            }
            if (type == MarshallingSupport.DOUBLE_TYPE) {
                return new Double(this.dataIn.readDouble());
            }
            if (type == MarshallingSupport.BOOLEAN_TYPE) {
                return this.dataIn.readBoolean() ? Boolean.TRUE : Boolean.FALSE;
            }
            if (type == MarshallingSupport.CHAR_TYPE) {
                return new Character(this.dataIn.readChar());
            }
            if (type == MarshallingSupport.BYTE_ARRAY_TYPE) {
                int len = this.dataIn.readInt();
                byte[] value = new byte[len];
                this.dataIn.readFully(value);
                return value;
            } else {
                this.dataIn.reset();
                throw new MessageFormatException(""unknown type"");
            }
        } catch (NumberFormatException mfe) {
            try {
                this.dataIn.reset();
            } catch (IOException ioe) {
                throw JMSExceptionSupport.create(ioe);
            }
            throw mfe;

        } catch (EOFException e) {
            JMSException jmsEx = new MessageEOFException(e.getMessage());
            jmsEx.setLinkedException(e);
            throw jmsEx;
        } catch (IOException e) {
            JMSException jmsEx = new MessageFormatException(e.getMessage());
            jmsEx.setLinkedException(e);
            throw jmsEx;
        }
    }
"	Reads an object from the stream message.	Reads an object from the stream message.	0	1	9	69	388
public Actions sendKeys(CharSequence... keys) { if (isBuildingActions()) { action.addAction(new SendKeysAction(jsonKeyboard, jsonMouse, null, keys)); return this; } for (CharSequence key : keys) { key.codePoints().forEach(codePoint -> { tick(defaultKeyboard.createKeyDown(codePoint)); tick(defaultKeyboard.createKeyUp(codePoint)); }); } return this; }	"  public Actions sendKeys(CharSequence... keysToSend) {
    return this.sendKeys(null, keysToSend);
  }
"	Sends keys to the active element.	Sends keys to the active element.	0	1	12	16	78
public AtmosphereRequest getRequest() { return atmosphereRequest; }	"    public HttpServletRequest getRequest() {
        return atmosphereRequest;
    }
"	Return the associated  AtmosphereRequest	Return the associated HttpServletRequest	1	0	4	5	10
public View getActiveDecorView() { final View [] views = getWindowDecorViews(); final Activity activity = activityUtils.getCurrentActivity(false); if(views !=null && views.length > 0) { int length = views.length; for(int i = length - 1; i >= 0; i--){ if(activity.hasWindowFocus() && getCurrentViews(TextView.class,(ViewGroup) views[i]).size()==1) { return views[i]; } else if(activity.hasWindowFocus() && activity.getWindow().getDecorView().equals(views[i])){ return views[i]; } else if(!activity.hasWindowFocus() && !activity.getWindow().getDecorView().equals(views[i])){ return views[i]; } } return views[views.length-1]; } else return null; }	"	public View getActiveDecorView()
	{
		View [] views = getWindowDecorViews();
		Activity activity = activityUtils.getCurrentActivity(false);
		if(views !=null && views.length > 0)
		{
			int length = views.length;
			for(int i = length - 1; i >= 0; i--){
				if(activity.hasWindowFocus() && activity.getWindow().getDecorView().equals(views[i])){
					return views[i];
				}
				else if(!activity.hasWindowFocus() && !activity.getWindow().getDecorView().equals(views[i])){ 
					return views[i];
				}
			}
			return views[views.length-1];
		}
		else
			return null;
	}
"	Returns the active DecorView.	Returns the active DecorView.	0	1	15	25	173
"public ClusterSummary getClusterInfo() throws TException { long start = System.nanoTime(); try { StormClusterState stormClusterState = data.getStormClusterState(); Map<String, Assignment> assignments = new HashMap<String, Assignment>(); // get TopologySummary List<TopologySummary> topologySummaries = NimbusUtils.getTopologySummary(stormClusterState, assignments); // all supervisors Map<String, SupervisorInfo> supervisorInfos = Cluster.get_all_SupervisorInfo(stormClusterState, null); // generate SupervisorSummaries List<SupervisorSummary> supervisorSummaries = NimbusUtils.mkSupervisorSummaries(supervisorInfos, assignments); NimbusSummary nimbusSummary = NimbusUtils.getNimbusSummary(stormClusterState, supervisorSummaries, data); return new ClusterSummary(nimbusSummary, supervisorSummaries, topologySummaries); } catch (TException e) { LOG.info(""Failed to get ClusterSummary "", e); throw e; } catch (Exception e) { LOG.info(""Failed to get ClusterSummary "", e); throw new TException(e); } finally { long end = System.nanoTime(); SimpleJStormMetric.updateNimbusHistogram(""getClusterInfo"", (end - start) / TimeUtils.NS_PER_US); } }"	"    public ClusterSummary getClusterInfo() throws TException {
        long start = System.nanoTime();
        try {

            StormClusterState stormClusterState = data.getStormClusterState();

            Map<String, Assignment> assignments =
                    new HashMap<String, Assignment>();

            // get TopologySummary
            List<TopologySummary> topologySummaries =
                    NimbusUtils.getTopologySummary(stormClusterState,
                            assignments);

            // all supervisors
            Map<String, SupervisorInfo> supervisorInfos =
                    Cluster.get_all_SupervisorInfo(stormClusterState, null);

            // generate SupervisorSummaries
            List<SupervisorSummary> supervisorSummaries =
                    NimbusUtils.mkSupervisorSummaries(supervisorInfos,
                            assignments);

            NimbusSummary nimbusSummary =
                    NimbusUtils.getNimbusSummary(stormClusterState,
                            supervisorSummaries, data);

            ClusterSummary ret =
                    new ClusterSummary(nimbusSummary, supervisorSummaries,
                            topologySummaries);

            return ret;

        } catch (TException e) {
            LOG.info(""Failed to get ClusterSummary "", e);
            throw e;
        } catch (Exception e) {
            LOG.info(""Failed to get ClusterSummary "", e);
            throw new TException(e);
        }finally {
            double spend = (System.nanoTime() - start)/1000000.0d;
            SimpleJStormMetric.updateHistorgram(""getClusterInfo"", spend);
            LOG.info(""getClusterInfo spend {}ms"", spend);
        }
    }
"	get cluster's summary, it will contain SupervisorSummary and TopologySummary	get cluster's summary, it will contain SupervisorSummary and	1	0	9	31	186
"public Mono<BigDecimal> fakeOuterNumberSerialize(BigDecimal body) throws RestClientException { Object postBody = body; String path = UriComponentsBuilder.fromPath(""/fake/outer/number"").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { ""*/*"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<BigDecimal> returnType = new ParameterizedTypeReference<BigDecimal>() {}; return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType); }"	"    public Mono<BigDecimal> fakeOuterNumberSerialize(BigDecimal body) throws RestClientException {
        Object postBody = body;
        
        String path = UriComponentsBuilder.fromPath(""/fake/outer/number"").build().toUriString();
        
        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();
        final HttpHeaders headerParams = new HttpHeaders();
        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();

        final String[] accepts = { 
            ""*/*""
        };
        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);
        final String[] contentTypes = { };
        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);

        String[] authNames = new String[] {  };

        ParameterizedTypeReference<BigDecimal> returnType = new ParameterizedTypeReference<BigDecimal>() {};
        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);
    }
"	Test serialization of outer number types 200 - Output number	Test serialization of outer number types 200 - Output number	0	1	8	23	177
public boolean isResolvable(PicoContainer container, ComponentAdapter adapter, Class expectedType) { final Class collectionType = getCollectionType(expectedType); return collectionType != null && (emptyCollection || getResolvingAdapters(container, adapter, expectedType).length > 0); }	"    public boolean isResolvable(PicoContainer container, ComponentAdapter adapter, Class expectedType) {
        final Class collectionType = getCollectionType(expectedType);
        if (collectionType != null) {
            return emptyCollection
                    || !getMatchingComponentAdapters(container, adapter, componentKeyType, getValueType(expectedType)).isEmpty();
        }
        return false;
    }
"	Check for a successful dependency resolution of the parameter for the expected type.	Test for dependency resolution of the parameter for the expected type.	1	0	8	6	45
public OracleQuery clone(Connection conn){ return new OracleQuery(conn, getTemplates(), getMetadata().clone()); }	"    public OracleQuery clone(Connection conn){
        return new OracleQuery(conn, templates, getMetadata().clone());   
    }
"	Clone the state of this query to a new SQLQueryImpl instance with the given Connection	Clone the state of this query to a new SQLQueryImpl instance with the given Connection	0	1	6	4	27
"public ResultSet executeQuery(String sql) throws SQLException { if( type==ResultSet.TYPE_FORWARD_ONLY && concurrency==ResultSet.CONCUR_READ_ONLY ) { ResultSet rs = internalExecuteQuery( sql ); if( rs != null ) return rs; else throw new SQLException(""No ResultSet was produced.""); } else return new freetds.CursorResultSet(this, sql); }"	"   public ResultSet executeQuery(String sql) throws SQLException
   {
        if ( type == ResultSet.TYPE_FORWARD_ONLY
                && concurrency == ResultSet.CONCUR_READ_ONLY ) {
            return internalExecuteQuery( getTds(sql), sql );
        }
        else {
            return new freetds.CursorResultSet( this, sql );
        }
   }
"	Execute an SQL statement that returns a single ResultSet.	Execute a SQL statement that retruns a single ResultSet	1	0	8	17	64
"@SuppressWarnings(""unchecked"") public static String append(final String url, final Map<String, ?> params) { if (params == null || params.isEmpty()) return url; final StringBuilder result = new StringBuilder(url); // Add trailing slash if the base URL doesn't have any path segments. // The following test is checking for the last slash not being part of // the protocol to host separator '://'. int firstColon = url.indexOf(':'); int lastSlash = url.lastIndexOf('/'); if (firstColon + 2 == lastSlash) result.append('/'); result.append('?'); Entry<String, ?> entry; Object value; Iterator<?> iterator = params.entrySet().iterator(); entry = (Entry<String, ?>) iterator.next(); result.append(entry.getKey()); result.append('='); value = entry.getValue(); if (value != null) result.append(value); while (iterator.hasNext()) { result.append('&'); entry = (Entry<String, ?>) iterator.next(); result.append(entry.getKey()); result.append('='); value = entry.getValue(); if (value != null) result.append(value); } return result.toString(); }"	"	@SuppressWarnings(""unchecked"")
	public static String append(String url, final Map<String, ?> params) {
		if (params == null || params.isEmpty())
			return url;

		StringBuilder result = new StringBuilder();
		if (!url.endsWith(""/""))
			url += ""/"";

		Entry<String, ?> entry;
		Object value;
		Iterator<?> iterator = params.entrySet().iterator();
		entry = (Entry<String, ?>) iterator.next();
		result.append(entry.getKey());
		result.append('=');
		value = entry.getValue();
		if (value != null)
			result.append(value);

		while (iterator.hasNext()) {
			result.append('&');
			entry = (Entry<String, ?>) iterator.next();
			result.append(entry.getKey());
			result.append('=');
			value = entry.getValue();
			if (value != null)
				result.append(value);
		}

		return url + '?' + result.toString();
	}
"	Append given query parameters to base URL	Append given parameters to base URL	1	0	10	40	269
public Iterator<Component> getComponentIterator() { return Collections.unmodifiableList(components).iterator(); }	"    public Iterator<Component> getComponentIterator() {
        return java.util.Collections.unmodifiableList(components).iterator();
    }
"	Gets the component container iterator for going through all the components (tab contents).	Gets the component container iterator for going trough all the components in the container.	1	0	5	5	18
public ApiResponse<Void> logoutUserWithHttpInfo() throws ApiException { okhttp3.Call localVarCall = logoutUserValidateBeforeCall(null, null); return localVarApiClient.execute(localVarCall); }	"    public ApiResponse<Void> logoutUserWithHttpInfo() throws ApiException {
        okhttp3.Call call = logoutUserValidateBeforeCall(null, null);
        return apiClient.execute(call);
    }
"	Logs out current logged in user session	Logs out current logged in user session	0	1	6	5	27
public String getVerboseMessage() { return getVerboseMessage(true); }	"  public String getVerboseMessage() {
    return generateMessage() + ""\n\n"" + ErrorHelper.buildCausesMessage(getCause());
  }
"	generates the message that will be displayed to the client.	generates the message that will be displayed to the client.	0	1	5	4	13
private static X509ExtendedTrustManager findFirstX509TrustManager(TrustManager[] tms) throws KeyManagementException { for (TrustManager tm : tms) { if (tm instanceof X509ExtendedTrustManager) { return (X509ExtendedTrustManager) tm; } if (tm instanceof X509TrustManager) { return new X509ExtendedTrustManagerWrapper((X509TrustManager) tm); } } return null; }	"    private static X509TrustManager findFirstX509TrustManager(TrustManager[] tms) {
        for (TrustManager tm : tms) {
            if (tm instanceof X509TrustManager) {
                return (X509TrustManager)tm;
            }
        }
        return null;
    }
"	Finds the first  X509ExtendedTrustManager or  X509TrustManager element in the provided array.	Finds the first X509TrustManager element in the provided array.	1	0	10	14	58
public Interval gap(ReadableInterval interval) { interval = DateTimeUtils.getReadableInterval(interval); if (overlaps(interval) || abuts(interval)) { return null; } long otherStart = interval.getStartMillis(); long otherEnd = interval.getEndMillis(); long thisStart = getStartMillis(); long thisEnd = getEndMillis(); if (thisStart >= otherEnd) { return new Interval(otherEnd, thisStart, getChronology()); } else { return new Interval(thisEnd, otherStart, getChronology()); } }	"    public Interval gap(ReadableInterval interval) {
        interval = DateTimeUtils.getReadableInterval(interval);
        if (overlaps(interval) || abuts(interval)) {
            return null;
        }
        long otherStart = interval.getStartMillis();
        long otherEnd = interval.getEndMillis();
        long thisStart = getStartMillis();
        long thisEnd = getEndMillis();
        if (thisStart >= otherEnd) {
            return new Interval(otherEnd, thisStart);
        } else {
            return new Interval(thisEnd, otherStart);
        }
    }
"	Gets the gap between this interval and another interval.	Gets the gap between this interval and that specified.	1	0	7	16	96
public static RequestQueue newRequestQueue(IRestProtocol implRestConnection, int threadPoolSize) { return newRequestQueue(RestParser.getInstance(implRestConnection), threadPoolSize); }	"    public static RequestQueue newRequestQueue(ImplRestConnection implRestConnection, int threadPoolSize) {
        return newRequestQueue(HttpRestParser.getInstance(implRestConnection), threadPoolSize);
    }
"	Create a new request queue, using NoHttp default request executor  RestProtocol and default response parser  RestParser.	Create a new request queue, using NoHttp default request executor HttpRestConnection and default response parser HttpRestParser.	1	0	6	4	25
public static String deprocess(String str, STextProcessor processor) { if ((str == null) || (str.length() <= 1)) return str; // make sure that LRE/PDF are added around the string STextEnvironment env = new STextEnvironment(null, false, STextEnvironment.ORIENT_UNKNOWN); if (!env.isProcessingNeeded()) return str; return STextEngine.fullToLeanText(processor, env, str, null); }	"	public static String deprocess(String str, STextProcessor processor) {
		if ((str == null) || (str.length() <= 1) || !isProcessingNeeded())
			return str;

		// make sure that LRE/PDF are added around the string
		STextEnvironment env = new STextEnvironment(null, false, STextEnvironment.ORIENT_UNKNOWN);
		return STextEngine.fullToLeanText(processor, env, str, null);
	}
"	Removes directional formatting characters in the given string.	Remove directional formatting characters in the given string that were inserted by the #processTyped processTyped method.	1	0	6	12	82
public static Properties parse(String s, Properties props) throws SQLException { return new ConnectStringParser(s).parse_(props); }	"    Properties parse(Properties props)
        throws SQLException
    {
        if (props == null) {
            props = new Properties();
        }
        while (i < n) {
            parsePair(props);
        }
        return props;
    }
"	Parses the connect string into an existing Properties object.	Parses the connect string into a Properties object.	1	0	6	6	26
public static String quote(String name) { if ( name == null || name.length() == 0 || isQuoted( name ) ) { return name; } else { return new StringBuffer( name.length() + 2 ).append('`').append( name ).append( '`' ).toString(); } }	"	public static String quote(String name) {
		if ( name == null || name.length() == 0 || isQuoted( name ) ) {
			return name;
		}
		else {
			return new StringBuilder( name.length() + 2 ).append('`').append( name ).append( '`' ).toString();
		}
	}
"	Return a representation of the given name ensuring quoting (wrapped with '`' characters).	Return a representation of the given name ensuring quoting (wrapped with '`' characters).	0	1	8	9	65
public long get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }	"    public long get(WithAttributes attributes) {
        return attributes.getAttributes().get(this);
    }
"	Extracts the attribute map from the specified  WithAttributes and returns the value of this attribute from the map.	Analogous to #get(WithAttributes) except returning a primitive long.	1	0	6	5	19
public static EString substring(Expr<String> left, int beginIndex, int endIndex) { return operationFactory.createString(Ops.SUBSTR2ARGS, left, exprFactory.createConstant(beginIndex), exprFactory.createConstant(endIndex)); }	"    public static EString substring(Expr<String> left, int beginIndex, int endIndex) {
        return factory.createString(Ops.SUBSTR2ARGS, left, factory.createConstant(beginIndex), factory.createConstant(endIndex));
    }
"	Expr : left.substring(beginIndex, endIndex)	Expr : left.substring(beginIndex, endIndex)	0	1	6	4	39
"public ResultSetMetaData getMetaData() throws SQLException { try { debugCodeCall(""getMetaData""); checkClosed(); ResultInterface result = command.getMetaData(); if(result == null) { return null; } int id = getNextId(TraceObject.RESULT_SET_META_DATA); if(debug()) { debugCodeAssign(""ResultSetMetaData"", TraceObject.RESULT_SET_META_DATA, id); debugCodeCall(""getMetaData""); } JdbcResultSetMetaData meta = new JdbcResultSetMetaData(null, this, result, session.getTrace(), id); return meta; } catch(Throwable e) { throw logAndConvert(e); } }"	"    public ResultSetMetaData getMetaData() throws SQLException {
        try {
            debugCodeCall(""getMetaData"");
            checkClosed();
            return null;
        } catch(Throwable e) {
            throw logAndConvert(e);
        }
    }
"	Gets the result set metadata of the query returned when the statement is executed.	[Not supported] Gets the result set metadata of the query returned when the statement is executed.	1	0	8	21	110
public static Set<BitSet> getUniqueKeys(RelNode rel, boolean ignoreNulls) { final BuiltInMetadata.UniqueKeys metadata = rel.metadata(BuiltInMetadata.UniqueKeys.class); return metadata.getUniqueKeys(ignoreNulls); }	"  public static Set<BitSet> getUniqueKeys(RelNode rel, boolean ignoreNulls) {
    return (Set<BitSet>) rel.getCluster().getMetadataProvider()
        .getRelMetadata(
            rel,
            ""getUniqueKeys"",
            new Object[]{ignoreNulls});
  }
"	Returns the  BuiltInMetadata.UniqueKeys#getUniqueKeys(boolean) statistic.	Determines the set of unique minimal keys for this expression, optionally ignoring nulls in the columns in the expression.	1	0	7	6	33
public DateTime roundHalfEvenCopy() { DateTime instant = iInstant; return (DateTime)instant.withMillis(iField.roundHalfEven(instant.getMillis())); }	"    public DateTime roundHalfEvenCopy() {
        DateTime instant = iInstant;
        return (DateTime)instant.toCopy(iField.roundHalfEven(instant.getMillis()));
    }
"	Rounds to the nearest whole unit of this field on a copy of this DateTime.	Rounds to the nearest whole unit of this field on a copy of this DateTime.	0	1	7	5	28
"public DockerClientConfigBuilder withProperties(Properties p) { return withUri(p.getProperty(""docker.io.url"")) .withVersion(p.getProperty(""docker.io.version"")) .withUsername(p.getProperty(""docker.io.username"")) .withPassword(p.getProperty(""docker.io.password"")) .withEmail(p.getProperty(""docker.io.email"")) .withReadTimeout(Integer.valueOf(p.getProperty(""docker.io.readTimeout"", ""0""))) .withLoggingFilter(Boolean.valueOf(p.getProperty(""docker.io.enableLoggingFilter"", ""true""))) .withKeystore(p.getProperty(""docker.io.keystore"")) .withKeystorePassword(p.getProperty(""docker.io.keystorePassword"")) .withTruststore(p.getProperty(""docker.io.truststore"")) .withTruststorePassword(p.getProperty(""docker.io.truststorePassword"")); }"	"        public DockerClientConfigBuilder withProperties(Properties p) {
            return withUri(p.getProperty(""docker.io.url""))
                    .withVersion(p.getProperty(""docker.io.version""))
                    .withUsername(p.getProperty(""docker.io.username""))
                    .withPassword(p.getProperty(""docker.io.password""))
                    .withEmail(p.getProperty(""docker.io.email""))
                    .withReadTimeout(Integer.valueOf(p.getProperty(""docker.io.readTimeout"", ""0"")))
                    .withLoggingFilter(Boolean.valueOf(p.getProperty(""docker.io.enableLoggingFilter"", ""true"")));
        }
"	This will set all fields in the builder to those contained in the Properties object.	This will set all fields in the builder to those contained in the Properties object.	0	1	8	14	159
public boolean scrollUpList(int index) { return scroller.scrollList(waiter.waitForAndGetView(index, ListView.class), Scroller.UP, false); }	"	public boolean scrollUpList(int index) {
		return scroller.scrollList(waiter.waitForAndGetView(index, ListView.class), Scroller.UP);
	}
"	Scrolls up a list with a given index.	Scrolls up a list with a given index.	0	1	7	4	28
protected Object defaultValue(Field field, Conversion<?> conversion) throws IOException { Schema schema = field.schema(); LogicalType logicalType = schema.getLogicalType(); Object rawDefaultValue = data.deepCopy(schema, data.getDefaultValue(field)); if (conversion == null || logicalType == null) { return rawDefaultValue; } else { return Conversions.convertToLogicalType(rawDefaultValue, schema, logicalType, conversion); } }	"  protected Object defaultValue(Field field) throws IOException {
    return data.deepCopy(field.schema(), data.getDefaultValue(field));
  }
"	Gets the default value of the given field, if any.	Gets the default value of the given field, if any.	0	1	7	12	73
"public static Schema unaliasSchema(OpenAPI openAPI, Schema schema) { Map<String, Schema> allSchemas = getSchemas(openAPI); if (allSchemas == null || allSchemas.isEmpty()) { // skip the warning as the spec can have no model defined //LOGGER.warn(""allSchemas cannot be null/empty in unaliasSchema. Returned 'schema'""); return schema; } if (schema != null && StringUtils.isNotEmpty(schema.get$ref())) { Schema ref = allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())); if (ref == null) { LOGGER.warn(""{} is not defined"", schema.get$ref()); return schema; } else if (ref.getEnum() != null && !ref.getEnum().isEmpty()) { // top-level enum class return schema; } else if (isArraySchema(ref)) { if (generateAliasAsModel) { return schema; // generate a model extending array } else { return unaliasSchema(openAPI, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()))); } } else if (isComposedSchema(ref)) { return schema; } else if (isMapSchema(ref)) { if (ref.getProperties() != null && !ref.getProperties().isEmpty()) // has at least one property return schema; // treat it as model else { if (generateAliasAsModel) { return schema; // generate a model extending map } else { // treat it as a typical map return unaliasSchema(openAPI, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()))); } } } else if (isObjectSchema(ref)) { // model if (ref.getProperties() != null && !ref.getProperties().isEmpty()) { // has at least one property return schema; } else { // free form object (type: object) return unaliasSchema(openAPI, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()))); } } else { return unaliasSchema(openAPI, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()))); } } return schema; }"	"    public static Schema unaliasSchema(Map<String, Schema> allSchemas, Schema schema) {
        if (allSchemas == null || allSchemas.isEmpty()) {
            // skip the warning as the spec can have no model defined
            //LOGGER.warn(""allSchemas cannot be null/empty in unaliasSchema. Returned 'schema'"");
            return schema;
        }

        if (schema != null && StringUtils.isNotEmpty(schema.get$ref())) {
            Schema ref = allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()));
            if (ref == null) {
                LOGGER.warn(""{} is not defined"", schema.get$ref());
                return schema;
            } else if (ref.getEnum() != null && !ref.getEnum().isEmpty()) {
                // top-level enum class
                return schema;
            } else if (isArraySchema(ref)) {
                if (generateAliasAsModel) {
                    return schema; // generate a model extending array
                } else {
                    return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));
                }
            } else if (isComposedSchema(ref)) {
                return schema;
            } else if (isMapSchema(ref)) {
                if (ref.getProperties() != null && !ref.getProperties().isEmpty()) // has at least one property
                    return schema; // treat it as model
                else {
                    if (generateAliasAsModel) {
                        return schema; // generate a model extending map
                    } else {
                        // treat it as a typical map
                        return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));
                    }
                }
            } else if (isObjectSchema(ref)) { // model
                if (ref.getProperties() != null && !ref.getProperties().isEmpty()) { // has at least one property
                    return schema;
                } else { // free form object (type: object)
                    return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));
                }
            } else {
                return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));
            }
        }
        return schema;
    }
"	Get the actual schema from aliases.	Get the actual schema from aliases.	0	1	19	48	435
public String getSearchPath() { // Java Mode doesn't need any default external jars at the moment. // This is here for Android Mode so that it can add its android.jar file. return null; }	"  public String getSearchPath() {
    // Java Mode doesn't need any default external jars at the moment.
    return """";
  }
"	Any modes that extend JavaMode can override this method to add additional	Any modes that extend JavaMode can override this method to add additional jars to be included in the classpath for code completion and error checking	1	0	4	6	42
"public synchronized List<ColumnIdentifier> getColumns(TableIdentifier tbl) { String schema = getSchemaToUse(tbl.getSchema()); TableIdentifier toSearch = tbl.createCopy(); toSearch.adjustCase(dbConnection); if (toSearch.getSchema() == null) { toSearch.setSchema(schema); } List<ColumnIdentifier> cols = this.objects.get(toSearch); if (cols == null) { try { TableDefinition def = dbConnection.getMetadata().getTableDefinition(toSearch); addTable(def); } catch (SQLException sql) { LogMgr.logWarning(""DbObjectCache.getColumns()"", ""Error retrieving table definition"", sql); return null; } } // To support Oracle public synonyms, try to find a table with that name but without a schema if (retrieveOraclePublicSynonyms && toSearch.getSchema() != null && cols == null) { toSearch.setSchema(null); toSearch.setType(null); cols = this.objects.get(toSearch); if (cols == null) { // retrieve Oracle PUBLIC synonyms this.getTables(""PUBLIC""); cols = this.objects.get(toSearch); } } if (CollectionUtil.isEmpty(cols)) { TableIdentifier tblToUse = null; // use the stored key because that might carry the correct type attribute // TabelIdentifier.equals() doesn't compare the type, only the expression // so we'll get a containsKey() == true even if the type is different // (which is necessary because the TableIdentifier passed to this // method will never contain a type!) // only using objects.get() would not return anything! if (objects.containsKey(toSearch)) { // we have already retrieved the list of tables, but not the columns for this table // the table identifier in the object map contains correct type and schema information, so we need // to use that tblToUse = findEntry(toSearch); } else { // retrieve the real table identifier based on the table name tblToUse = this.dbConnection.getMetadata().findObject(toSearch); } try { cols = this.dbConnection.getMetadata().getTableColumns(tblToUse); } catch (Throwable e) { LogMgr.logError(""DbObjectCache.getColumns"", ""Error retrieving columns for "" + tblToUse, e); cols = null; } if (tblToUse != null && CollectionUtil.isNonEmpty(cols)) { this.objects.put(tblToUse, cols); } } return Collections.unmodifiableList(cols); }"	"	public List<ColumnIdentifier> getColumns(TableIdentifier tbl)
	{
		String schema = getSchemaToUse(tbl.getSchema());

		if (this.objects.size() == 0 || !schemasInCache.contains(schema == null ? NULL_SCHEMA : schema))
		{
			this.getTables(schema);
		}

		TableIdentifier toSearch = tbl.createCopy();
		toSearch.adjustCase(dbConnection);
		if (toSearch.getSchema() == null)
		{
			toSearch.setSchema(schema);
		}

		List<ColumnIdentifier> cols = this.objects.get(toSearch);

		// To support Oracle public synonyms, try to find a table with that name but without a schema
		if (retrieveOraclePublicSynonyms && toSearch.getSchema() != null && cols == null)
		{
			toSearch.setSchema(null);
			toSearch.setType(null);
			cols = this.objects.get(toSearch);
			if (cols == null)
			{
				// retrieve Oracle PUBLIC synonyms
				this.getTables(""PUBLIC"");
				cols = this.objects.get(toSearch);
			}
		}

		if (CollectionUtil.isEmpty(cols))
		{
			TableIdentifier tblToUse = null;

			// use the stored key because that might carry the correct type attribute
			// TabelIdentifier.equals() doesn't compare the type, only the expression
			// so we'll get a containsKey() == true even if the type is different
			// (which is necessary because the TableIdentifier passed to this
			// method will never contain a type!)
			// only using objects.get() would not return anything!
			if (objects.containsKey(toSearch))
			{
				// we have already retrieved the list of tables, but not the columns for this table
				// the table identifier in the object map contains correct type and schema information, so we need
				// to use that
				tblToUse = findEntry(toSearch);
			}
			else
			{
				// retrieve the real table identifier based on the table name
				tblToUse = this.dbConnection.getMetadata().findObject(toSearch);
			}

			try
			{
				cols = this.dbConnection.getMetadata().getTableColumns(tblToUse);
			}
			catch (Throwable e)
			{
				LogMgr.logError(""DbObjectCache.getColumns"", ""Error retrieving columns for "" + tblToUse, e);
				cols = null;
			}

			if (tblToUse != null && CollectionUtil.isNonEmpty(cols))
			{
				this.objects.put(tblToUse, cols);
			}

		}
		return Collections.unmodifiableList(cols);
	}
"	Return the columns for the given table.	Return the columns for the given table	1	0	11	83	459
@Override public final TYPE next() { if (next == null) { return fromIterator.next(); } else { final TYPE result = next; next = null; return result; } }	"    @Override
    public final TYPE next() {
        TYPE result = next;
        next = null;
        result = (result == null ? fromIterator.next() : result);
        return result;
    }
"	Returns the next element of the Iterable.	Returns the next element of the iteration.	1	0	7	12	37
public Object getObject(String name) throws JMSException { initializeReading(); Object result = map.get(name); if (result instanceof UTF8Buffer) { result = result.toString(); } return result; }	"    public Object getObject(String name) throws JMSException {
        initializeReading();
        return map.get(name);
    }
"	Returns the value of the object with the specified name.	Returns the value of the object with the specified name.	0	1	7	10	40
public MenuItem addItem(SafeHtml html, ScheduledCommand cmd) { return addItem(new MenuItem(html, cmd)); }	"  public MenuItem addItem(String text, boolean asHTML, Command cmd) {
    return addItem(new MenuItem(text, asHTML, cmd));
  }
"	Adds a menu item to the bar containing SafeHtml, that will fire the given command when it is selected.	Adds a menu item to the bar, that will fire the given command when it is selected.	1	0	6	4	24
"public static int getNumberOfMatches(String regex, TextView view, Set<TextView> uniqueTextViews){ if(view == null) { return uniqueTextViews.size(); } Pattern pattern = null; try{ pattern = Pattern.compile(regex); }catch(PatternSyntaxException e){ pattern = Pattern.compile(regex, Pattern.LITERAL); } String viewText = view.getText().toString(); viewText = viewText.replaceAll(""[\n\r]"", "" ""); Matcher matcher = pattern.matcher(viewText); if (matcher.find()){ uniqueTextViews.add(view); } if (view.getError() != null){ matcher = pattern.matcher(view.getError().toString()); if (matcher.find()){ uniqueTextViews.add(view); } } if (view.getText().toString().equals("""") && view.getHint() != null){ matcher = pattern.matcher(view.getHint().toString()); if (matcher.find()){ uniqueTextViews.add(view); } } return uniqueTextViews.size(); }"	"	public static int getNumberOfMatches(String regex, TextView view, Set<TextView> uniqueTextViews){
		Pattern pattern = null;
		try{
			pattern = Pattern.compile(regex);
		}catch(PatternSyntaxException e){
			pattern = Pattern.compile(regex, Pattern.LITERAL);
		}
		Matcher matcher = pattern.matcher(view.getText().toString());
		if (matcher.find()){
			uniqueTextViews.add(view);
		}
		if (view.getError() != null){
			matcher = pattern.matcher(view.getError().toString());
			if (matcher.find()){
				uniqueTextViews.add(view);
			}
		}	
		if (view.getText().toString().equals("""") && view.getHint() != null){
			matcher = pattern.matcher(view.getHint().toString());
			if (matcher.find()){
				uniqueTextViews.add(view);
			}
		}	
		return uniqueTextViews.size();		
	}
"	Checks if a View matches a certain string and returns the amount of total matches.	Checks if a View matches a certain string and returns the amount of total matches.	0	1	9	33	209
public <V extends Visitor<? super X>> V visit(V visitor) { for (X x : this) { visitor.visit(x); } return visitor; }	"    public <P extends Visitor<? super X>> P visit(P predicate)
    {
        for (X x : this) {
            predicate.visit(x);
        }

        return predicate;
    }
"	Applies  visitor to each item	Applies predicate to each item	1	0	7	10	33
public String toString() { return ISOTimePeriodFormat.getInstance().standard().print(toTimePeriod()); }	"    public String toString() {
        return ISODurationFormat.getInstance().standard().print(this);
    }
"	Gets the value as a String in the ISO8601 duration format.	Gets the value as a String in the ISO8601 duration format.	0	1	6	4	22
"public RepositoryMetadata lookupComponent(Class<?> repositoryClass) { if (repositoriesMetadata.containsKey(repositoryClass)) { return repositoriesMetadata.get(repositoryClass); } throw new RuntimeException(""Unknown Repository class "" + repositoryClass.getName()); }"	"    public RepositoryMetadata lookupComponent(Class<?> repoClass)
    {
        if (repositoriesMetadata.containsKey(repoClass))
        {
            return repositoriesMetadata.get(repoClass);
        }
        throw new RuntimeException(""Unknown Repository class "" + repoClass.getName());
    }
"	Lookup the  RepositoryMetadata for a specific Repository class.	Repository access - lookup the Repository component meta data for a specific Repository class.	1	0	7	10	43
public int[] set(PartialInstant instant, int fieldIndex, int[] values, int newValue) { FieldUtils.verifyValueBounds(this, newValue, getMinimumValue(instant), getMaximumValue(instant)); values[fieldIndex] = newValue; return values; }	"    public long set(long instant, String text, Locale locale) {
        try {
            return set(instant, Integer.parseInt(text));
        } catch (NumberFormatException ex) {
            throw new IllegalArgumentException(""Invalid "" + getName() + "" text: "" + text);
        }
    }
"	Sets a value using the specified partial instant.	Sets a value in the milliseconds supplied from a human-readable, text value.	1	0	7	6	49
public VideoCallProvider getVideoCallProvider() { return mVideoCallProvider; }	"    public ConnectionService.VideoCallProvider getVideoCallProvider() {
        return mVideoCallProvider;
    }
"	Returns the  VideoCallProvider for the connection.	Returns the ConnectionService.VideoCallProvider for the connection.	1	0	4	5	10
public String[] checkAllWords(String words) { List<String> misspelledWords = new ArrayList<String>(); StringWordTokenizer tokenizer = new StringWordTokenizer(words); while (tokenizer.hasMoreWords()) { String word = tokenizer.nextWord(); if (!isWordCorrect(word, tokenizer.isNewSentence())) { misspelledWords.add(word); } } return misspelledWords.toArray(new String[0]); }	"    public String[] checkAllWords(String words) {
        List<String> misspeltWords = new ArrayList<String>();
        StringWordTokenizer tokenizer = new StringWordTokenizer(words);

        while (tokenizer.hasMoreWords()) {
            String word = tokenizer.nextWord();
            if (!isWordCorrect(word, tokenizer.isNewSentence())) {
                misspeltWords.add(word);
            }
        }
        return misspeltWords.toArray(new String[0]);
    }
"	Spell checks all words in the input string and returns an array of misspelled words.	Spell checks all words in the input string and returns an array of misspelt words.	1	0	9	14	76
public static final Test suite() { return null; }	"        public static Test suite(String name) {
            return new TestSuite(
                    JtdsDataSourceUnitTest.Test_JtdsDataSource_getConnection.class, name);
        }
"	Provides a null test suite so that JUnit will not try to instantiate this class directly.	Construct a test suite for this library.	1	0	4	5	12
boolean findCellForSpan(int[] cellXY, int spanX, int spanY) { return findCellForSpan(cellXY, spanX, spanY, true); }	"        boolean findCellForSpan(int[] cellXY, int spanX, int spanY) {
            // return the span represented by the CellInfo only there is no view there
            //   (this.cell == null) and there is enough space

            if (this.cell == null && this.spanX >= spanX && this.spanY >= spanY) {
                if (cellXY != null) {
                    cellXY[0] = cellX;
                    cellXY[1] = cellY;
                }
                return true;
            }

            int startX = 0;
            if (intersectX >= 0) {
                startX = Math.max(startX, intersectX - (spanX - 1));
            }
            int endX = mCountX - (spanX - 1);
            if (intersectX >= 0) {
                endX = Math.min(endX, intersectX + (spanX - 1));
            }
            int startY = 0;
            if (intersectY >= 0) {
                startY = Math.max(startY, intersectY - (spanY - 1));
            }
            int endY = mCountY - (spanY - 1);
            if (intersectY >= 0) {
                endY = Math.min(endY, intersectY + (spanY - 1));
            }

            for (int x = startX; x < endX; x++) {
                inner:
                for (int y = startY; y < endY; y++) {
                    for (int i = 0; i < spanX; i++) {
                        for (int j = 0; j < spanY; j++) {
                            if (mOccupied[x + i][y + j]) {
                                // small optimization: we can skip to below the row we just found
                                // an occupied cell
                                y += j;
                                continue inner;
                            }
                        }
                    }
                    if (cellXY != null) {
                        cellXY[0] = x;
                        cellXY[1] = y;
                    }
                    return true;
                }
            }
            return false;
        }
"	This method can be called only once! Calling #findVacantCellsFromOccupied will restore the ability to call this method.	Finds the upper-left coordinate of the first rectangle in the grid that can hold a cell of the specified dimensions.	1	0	5	4	28
public static FxEnvironment getFilteredEnvironment() { return new FxFilteredEnvironment(getEnvironment()); }	"    public static FxEnvironment getFilteredEnvironment() {
        return new FilteredEnvironment(getEnvironment());
    }
"	Return a  com.flexive.shared.structure.FxFilteredEnvironment for the calling user.	Return a FilteredEnvironment for the calling user.	1	0	5	5	17
public Split start(L location) { if (stopwatchSource.isMonitored(location)) { return stopwatchSource.getMonitor(location).start(); } else { return Split.DISABLED; } }	"	public Split start(L location) {
		if (stopwatchSource.isMonitored(location)) {
			return stopwatchSource.getMonitor(location).start();
		} else {
			return null;
		}
	}
"	If given location is monitored, then a  Stopwatch is started and  Split returned - otherwise disabled Split is returned.	If given location is monitored, then a Stopwatch is started and Split returned - otherwise null is returned.	1	0	7	9	36
"public Menu getControlMenu(final Control c) { Menu controlMenu = ControlHandler.getInstance().getMenu(c); if(controlMenu == null) { throw new CoreLayerException(c.getClass() +"" Has no menu""); } return controlMenu; }"	"	public Menu getControlMenu(final Control c) {

		Menu menu = Display.syncExec(new ResultRunnable<Menu>() {

			@Override
			public Menu run() {
				Menu m = c.getMenu();
				return m;
			}
		});

		if (menu == null) {
			throw new CoreLayerException(
					c.getClass() +"" Has no menu"");
		}

		return menu;	
	}
"	Returns menu of given control	Gets Menu of specified control.	1	0	8	9	47
"public String toDefaultValue(Schema p) { if (p instanceof StringSchema) { StringSchema dp = (StringSchema) p; if (dp.getDefault() != null) { return ""@\"""" + dp.getDefault() + ""\""""; } } else if (p instanceof BooleanSchema) { BooleanSchema dp = (BooleanSchema) p; if (dp.getDefault() != null) { if (dp.getDefault().toString().equalsIgnoreCase(""false"")) return ""@(NO)""; else return ""@(YES)""; } } else if (p instanceof DateSchema) { // TODO } else if (p instanceof DateTimeSchema) { // TODO } else if (p instanceof NumberSchema) { NumberSchema dp = (NumberSchema) p; if (dp.getDefault() != null) { return ""@"" + dp.getDefault().toString(); } } else if (p instanceof IntegerSchema) { IntegerSchema dp = (IntegerSchema) p; if (dp.getDefault() != null) { return ""@"" + dp.getDefault().toString(); } } return null; }"	"    public String toDefaultValue(Property p) {
        if (p instanceof StringProperty) {
            StringProperty dp = (StringProperty) p;
            if (dp.getDefault() != null) {
                return ""@\"""" + dp.getDefault() + ""\"""";
            }
        } else if (p instanceof BooleanProperty) {
            BooleanProperty dp = (BooleanProperty) p;
            if (dp.getDefault() != null) {
                if (dp.getDefault().toString().equalsIgnoreCase(""false""))
                    return ""@(NO)"";
                else
                    return ""@(YES)"";
            }
        } else if (p instanceof DateProperty) {
            // TODO
        } else if (p instanceof DateTimeProperty) {
            // TODO
        } else if (p instanceof DoubleProperty) {
            DoubleProperty dp = (DoubleProperty) p;
            if (dp.getDefault() != null) {
                return ""@"" + dp.getDefault().toString();
            }
        } else if (p instanceof FloatProperty) {
            FloatProperty dp = (FloatProperty) p;
            if (dp.getDefault() != null) {
                return ""@"" + dp.getDefault().toString();
            }
        } else if (p instanceof IntegerProperty) {
            IntegerProperty dp = (IntegerProperty) p;
            if (dp.getDefault() != null) {
                return ""@"" + dp.getDefault().toString();
            }
        } else if (p instanceof LongProperty) {
            LongProperty dp = (LongProperty) p;
            if (dp.getDefault() != null) {
                return ""@"" + dp.getDefault().toString();
            }
        }

        return null;
    }
"	Return the default value of the schema	Return the default value of the property	1	0	15	33	219
public ReadableInstant withDateTimeZone(DateTimeZone newDateTimeZone) { final Chronology originalChrono = getChronology(); if (originalChrono == null) { // Without an original chronology, no new time zone can be // set. Call withMillis to allow subclass to decide if a clone // should be made or not. return withMillis(getMillis()); } return withChronology(originalChrono.withDateTimeZone(newDateTimeZone)); }	"    public ReadableInstant withDateTimeZone(DateTimeZone newDateTimeZone) {
        Chronology newChronology = getChronology();
        newChronology = newChronology == null ? ISOChronology.getInstance(newDateTimeZone)
            : newChronology.withDateTimeZone(newDateTimeZone);
        return withChronology(newChronology);
    }
"	Gets a copy of this instant with a different time zone, preserving the millisecond instant.	Gets a copy of this instant with a different time zone.	1	0	7	11	74
public static String export() { RequestLog current = RLOG.get(); record(new Durations(current.aggregateDurations())); record(new Threads(current.threadIds)); return LogFormatterProvider.getInstance().format(current.info); }	"    public static String export() {
        RequestLog current = RLOG.get();
        record(new Durations(current.aggregateDurations()));
        record(new Threads(current.threadIds));
        try {
            return current.mapper.writeValueAsString(current.info);
        } catch (JsonProcessingException jpe) {
            String msg = String.format(""Exporting mega log line with id: '%s' to JSON failed."", current.logId);
            LOG.warn(msg, jpe);
            return msg;
        }
    }
"	Exports current thread's request log object as a formatted string without resetting it.	Exports current thread's request log object as a JSON string without resetting it.	1	0	6	8	48
"public static String getClassName(String memberID, boolean isClassMember) { int pos = memberID.indexOf(ALT_MEMBER_SEPARATOR); // uses alternative separator, easy if (pos != -1) return memberID.substring(0, pos); pos = memberID.indexOf('('); if ( pos != -1 ) { // has a descriptor, is a method ID, strip last member part pos = memberID.lastIndexOf('.', pos); return pos != -1 ? memberID.substring(0, pos) : """"; } if (isClassMember) { // field or class name, cannot decide, assume it is a field pos = memberID.lastIndexOf('.'); return pos != -1 ? memberID.substring(0, pos) : """"; } else { // assume it is a class name return memberID; } }"	"    public static String getClassName(String signature, boolean isClassMember) {
        int pos = signature.indexOf(ALT_MEMBER_SEPARATOR);
        // uses alternative separator, easy
        if (pos != -1) return signature.substring(0, pos);

        pos = signature.indexOf('(');
        if ( pos != -1 ) {
            // has a descriptor, is a method signature, strip last member part
            pos = signature.lastIndexOf('.', pos);
            return pos != -1 ? signature.substring(0, pos) : """";
        }

        if (isClassMember) {
            // field or class name, cannot decide, assume it is a field
            pos = signature.lastIndexOf('.');
            return pos != -1 ? signature.substring(0, pos) : """";
        } else {
            // assume it is a class name
            return signature;
        }
    }
"	Parse a member ID, with or without classname, with or without descriptor.	Parse a signature, with or without classname, with or without descriptor.	1	0	8	23	164
public final FacebookException getError() { return error; }	"    public final FacebookRequestError getError() {
        return error;
    }
"	Returns the error returned for this request, if any.	Returns information about any errors that may have occurred during the request.	1	0	4	5	11
private String terminalToShowWhenClosing(String handle) { int terminalClosing = terminals_.indexOfTerminal(handle); if (terminalClosing > 0) return terminals_.terminalHandleAtIndex(terminalClosing - 1); else if (terminalClosing + 1 < terminals_.terminalCount()) return terminals_.terminalHandleAtIndex(terminalClosing + 1); else return null; }	"   private int terminalToShowWhenClosing(int terminalClosing)
   {
      if (terminalClosing > 0)
         return terminalClosing - 1;
      else if (terminalClosing + 1 < getTerminalCount())
         return terminalClosing + 1;
      else
         return -1;
   }
"	Handle of terminal to show after closing indicated terminal.	Index of terminal to show after closing indicated terminal index	1	0	8	11	55
public NVP<Long, Double> reset(final long newStartMs, final long newCount) { final long[] priorWindow = TIME_WINDOW_UPDATER.getAndSet(this, windowRangeFromMs(newStartMs, windowWidth)); final long priorCount = count; count = newCount; return new NVP<Long, Double>(priorWindow[1], calcRate(priorCount, windowWidth)); }	"	public long reset() {
		final long priorCount = count;
		count = 0;
		return priorCount;
	}
"	Resets the count to zero and sets the time window according to the passed ms timestamp	Resets the count to zero	1	0	7	8	63
private int[] getEnteredTime(Boolean[] enteredZeros) { int amOrPm = -1; int startIndex = 1; if (!mIs24HourMode && isTypedTimeFullyLegal()) { int keyCode = mTypedTimes.get(mTypedTimes.size() - 1); if (keyCode == getAmOrPmKeyCode(AM)) { amOrPm = AM; } else if (keyCode == getAmOrPmKeyCode(PM)){ amOrPm = PM; } startIndex = 2; } int minute = -1; int hour = -1; int second = 0; int shift = mEnableSeconds ? 2 : 0; for (int i = startIndex; i <= mTypedTimes.size(); i++) { int val = getValFromKeyCode(mTypedTimes.get(mTypedTimes.size() - i)); if (mEnableSeconds) { if (i == startIndex) { second = val; } else if (i == startIndex + 1) { second += 10*val; if (enteredZeros != null && val == 0) { enteredZeros[2] = true; } } } if (i == startIndex + shift) { minute = val; } else if (i == startIndex + shift + 1) { minute += 10*val; if (enteredZeros != null && val == 0) { enteredZeros[1] = true; } } else if (i == startIndex + shift + 2) { hour = val; } else if (i == startIndex + shift + 3) { hour += 10*val; if (enteredZeros != null && val == 0) { enteredZeros[0] = true; } } } return new int[] {hour, minute, second, amOrPm}; }	"    private int[] getEnteredTime(Boolean[] enteredZeros) {
        int amOrPm = -1;
        int startIndex = 1;
        if (!mIs24HourMode && isTypedTimeFullyLegal()) {
            int keyCode = mTypedTimes.get(mTypedTimes.size() - 1);
            if (keyCode == getAmOrPmKeyCode(AM)) {
                amOrPm = AM;
            } else if (keyCode == getAmOrPmKeyCode(PM)){
                amOrPm = PM;
            }
            startIndex = 2;
        }
        int minute = -1;
        int hour = -1;
        for (int i = startIndex; i <= mTypedTimes.size(); i++) {
            int val = getValFromKeyCode(mTypedTimes.get(mTypedTimes.size() - i));
            if (i == startIndex) {
                minute = val;
            } else if (i == startIndex+1) {
                minute += 10*val;
                if (enteredZeros != null && val == 0) {
                    enteredZeros[1] = true;
                }
            } else if (i == startIndex+2) {
                hour = val;
            } else if (i == startIndex+3) {
                hour += 10*val;
                if (enteredZeros != null && val == 0) {
                    enteredZeros[0] = true;
                }
            }
        }

        return new int[] {hour, minute, amOrPm};
    }
"	Get the currently-entered time, as integer values of the hours, minutes and seconds typed.	Get the currently-entered time, as integer values of the hours and minutes typed.	1	0	16	48	297
final public Token getNextToken() { if (this.token.next != null) { this.token = this.token.next; } else { this.token = this.token.next = this.token_source.getNextToken(); } this.jj_ntk = -1; this.jj_gen++; return this.token; }	"    final public Token getNextToken() {
        if (token.next != null) {
            token = token.next;
        } else {
            token = token.next = token_source.getNextToken();
        }

        jj_ntk = -1;
        jj_gen++;

        return token;
    }
"	Get the next token	DOCUMENT ME!	1	0	9	14	52
public static String deprocess(String str) { if ((str == null) || (str.length() <= 1)) return str; STextEnvironment env = new STextEnvironment(null, false, STextEnvironment.ORIENT_UNKNOWN); if (!env.isProcessingNeeded()) return str; StringBuffer buf = new StringBuffer(); int strLen = str.length(); for (int i = 0; i < strLen; i++) { char c = str.charAt(i); switch (c) { case LRM : continue; case LRE : continue; case PDF : continue; default : buf.append(c); } } return buf.toString(); }	"	public static String deprocess(String str) {
		if ((str == null) || (str.length() <= 1) || !isProcessingNeeded())
			return str;

		StringBuffer buf = new StringBuffer();
		int strLen = str.length();
		for (int i = 0; i < strLen; i++) {
			char c = str.charAt(i);
			switch (c) {
				case LRM :
					continue;
				case LRE :
					continue;
				case PDF :
					continue;
				default :
					buf.append(c);
			}
		}
		return buf.toString();
	}
"	Removes directional formatting characters in the given string.	Remove directional formatting characters in the given string that were inserted by one of the #process process methods.	1	0	9	26	125
"public boolean isBoolean() { return raw.equals(""true"") || raw.equals(""false""); }"	"    public boolean isBoolean() {
        return arg.equals(""true"") || arg.equals(""false"");
    }
"	Checks whether this ChatSection's value can be parsed as a boolean	Checks whether this ChatSection's argument can be parsed as a boolean	1	0	6	5	25
public Material asMaterialFromName() { return Material.getMaterial(raw.toUpperCase()); }	"    public Material asMaterialFromName() {
        return Material.getMaterial(arg.toUpperCase());
    }
"	Gets the material whose name is the same as the raw value (ignores case)	Gets the material whose name is the same as the raw arg (ignores case)	1	0	5	5	17
public ArrayList getAllImageSrcs() { return this.img_src_all; }	"    public ArrayList getAllImageSrcs() {
        return img_src_all;
    }
"	Get the list of src attributes for all images	DOCUMENT ME!	1	0	5	5	11
public DrillFuncHolder findDrillFunction(FunctionResolver functionResolver, FunctionCall functionCall) { AtomicLong version = new AtomicLong(); String newFunctionName = functionReplacement(functionCall); // Dynamic UDFS: First try with exact match. If not found, we may need to // update the registry, so sync with remote. if (useDynamicUdfs) { List<DrillFuncHolder> functions = localFunctionRegistry.getMethods(newFunctionName, version); FunctionResolver exactResolver = FunctionResolverFactory.getExactResolver(functionCall); DrillFuncHolder holder = exactResolver.getBestMatch(functions, functionCall); if (holder != null) { return holder; } syncWithRemoteRegistry(version.get()); } // Whether Dynamic UDFs or not: look in the registry for // an inexact match. List<DrillFuncHolder> functions = localFunctionRegistry.getMethods(newFunctionName, version); return functionResolver.getBestMatch(functions, functionCall); }	"  public DrillFuncHolder findDrillFunction(FunctionResolver functionResolver, FunctionCall functionCall) {
    AtomicLong version = new AtomicLong();
    String newFunctionName = functionReplacement(functionCall);
    List<DrillFuncHolder> functions = localFunctionRegistry.getMethods(newFunctionName, version);
    FunctionResolver exactResolver = FunctionResolverFactory.getExactResolver(functionCall);
    DrillFuncHolder holder = exactResolver.getBestMatch(functions, functionCall);

    if (holder == null) {
      syncWithRemoteRegistry(version.get());
      List<DrillFuncHolder> updatedFunctions = localFunctionRegistry.getMethods(newFunctionName, version);
      holder = functionResolver.getBestMatch(updatedFunctions, functionCall);
    }

    return holder;
  }
"	First attempts to find the Drill function implementation that matches the name, arg types and return type.	First attempts to finds the Drill function implementation that matches the name, arg types and return type.	1	0	8	24	146
public Timer getTimer(TimerDesc timerDesc) { return getTimer(timerDesc.getName(), timerDesc.getDurationUnit(), timerDesc.getTimeUnit()); }	"  public Timer getTimer(String name) {
    return getTimer(name, TimeUnit.MILLISECONDS, TimeUnit.SECONDS);
  }
"	Create a new  Timer from the description and registers it under the given group and name.	Creates a new com.yammer.metrics.core.Timer and registers it under the given group and name, measuring elapsed time in milliseconds and invocations per second.	1	0	5	6	28
public String getSubstituteExpression() { return this.substituteExpression; }	"    public String getSubstituteExpression() {
        return substituteExpression;
    }
"	Returns the substitution regular expression used in the export	DOCUMENT ME!	1	0	5	5	11
"private PartitionTemplate assembleSar( final String name, final Configuration config, final Configuration assembly ) throws LoomException { final Configuration[] blockConfig = assembly.getChildren( ""block"" ); final ComponentTemplate[] blocks = buildBlocks( blockConfig, config ); final PartitionTemplate blockPartition = new PartitionTemplate( ContainerConstants.BLOCK_PARTITION, new String[]{ContainerConstants.LISTENER_PARTITION}, PartitionTemplate.EMPTY_SET, blocks ); final Configuration[] listenerConfig = assembly.getChildren( ""listener"" ); final ComponentTemplate[] listeners = buildBlockListeners( listenerConfig, config ); final PartitionTemplate listenerPartition = new PartitionTemplate( ContainerConstants.LISTENER_PARTITION, new String[ 0 ], PartitionTemplate.EMPTY_SET, listeners ); final PartitionTemplate[] partitions = new PartitionTemplate[]{blockPartition, listenerPartition}; return new PartitionTemplate( name, new String[ 0 ], partitions, ComponentTemplate.EMPTY_SET ); }"	"    private PartitionMetaData assembleSar( final String name,
                                           final Configuration config,
                                           final Configuration assembly )
        throws LoomException
    {
        final Configuration[] blockConfig = assembly.getChildren( ""block"" );
        final ComponentMetaData[] blocks = buildBlocks( blockConfig, config );
        final PartitionMetaData blockPartition =
            new PartitionMetaData( ContainerConstants.BLOCK_PARTITION,
                                   new String[]{ContainerConstants.LISTENER_PARTITION},
                                   PartitionMetaData.EMPTY_SET,
                                   blocks );

        final Configuration[] listenerConfig = assembly.getChildren( ""listener"" );
        final ComponentMetaData[] listeners = buildBlockListeners( listenerConfig, config );
        final PartitionMetaData listenerPartition =
            new PartitionMetaData( ContainerConstants.LISTENER_PARTITION,
                                   new String[ 0 ],
                                   PartitionMetaData.EMPTY_SET,
                                   listeners );

        final PartitionMetaData[] partitions =
            new PartitionMetaData[]{blockPartition, listenerPartition};

        return new PartitionMetaData( name,
                                      new String[ 0 ],
                                      partitions,
                                      ComponentMetaData.EMPTY_SET );
    }
"	Create a  PartitionTemplate object based on specified name and assembly configuration.	Create a PartitionMetaData object based on specified name and assembly configuration.	1	0	8	31	148
"public Element writeSchema(Class javaType, Types types) throws Exception { // If an array the component type should be processed first String componentTypeName = null; Class componentType = null; if (javaType.isArray()) { String dimString = ""[]""; componentType = javaType.getComponentType(); if (componentType.isArray()) { while (componentType.isArray()) { dimString += ""[]""; componentType = componentType.getComponentType(); } } componentTypeName = types.getQNameString(types.getTypeQName(componentType)) + dimString; } // Use Types helper method to actually create the complexType return types.createArrayElement(componentTypeName); }"	"    public boolean writeSchema(Types types) throws Exception {
        return false;
    }
"	Return XML schema for the specified type, suitable for insertion into the &lt;types&gt; element of a WSDL document, or underneath an &lt;element&gt; or &lt;attribute&gt; declaration.	Return XML schema for the specified type, suitable for insertion into the element of a WSDL document.	1	0	11	23	118
"public static final Weblogger getRoller() { if (rollerInstance == null) { throw new IllegalStateException(""Roller Weblogger has not been bootstrapped yet""); } return rollerInstance; }"	"    public static final Roller getRoller() {
        if (rollerInstance == null) {
            throw new IllegalStateException(""Roller Weblogger has not been bootstrapped yet"");
        }
        
        return rollerInstance;
    }
"	Accessor to the Weblogger Weblogger business tier.	Accessor to the Roller Weblogger business tier.	1	0	7	9	34
public Chronology getChronology(Object object, Chronology chrono) { if (chrono != null) { return chrono; } Calendar cal = (Calendar) object; DateTimeZone zone = null; try { zone = DateTimeZone.getInstance(cal.getTimeZone()); } catch (IllegalArgumentException ex) { zone = DateTimeZone.getDefault(); } return getChronology(cal, zone); }	"    public Chronology getChronology(Object object) {
        Calendar cal = (Calendar) object;
        DateTimeZone zone = null;
        try {
            zone = DateTimeZone.getInstance(cal.getTimeZone());
            
        } catch (IllegalArgumentException ex) {
            zone = DateTimeZone.getDefault();
        }
        return getChronology(cal, zone);
    }
"	Gets the chronology.	Gets the chronology, which is the GJChronology if a GregorianCalendar is used,	1	0	7	15	68
public static EBoolean endsWith(Expr<String> left, Expr<String> right) { return operationFactory.createBoolean(Ops.ENDSWITH, left, right); }	"    public static EBoolean endsWith(Expr<String> left, Expr<String> right, boolean caseSensitive) {
        if (caseSensitive){
            return endsWith(left, right);            
        }else{
            return operationFactory.createBoolean(Ops.ENDSWITH_IC, left, right);
        }
    }
"	Expr : left.endsWith(right)	Expr : left.endsWith(right) (ignore case)	1	0	6	4	27
public double distanceTo(double x, double y, double z) { final double a = this.x - x; final double b = this.y - y; final double c = this.z - z; return Math.sqrt(a * a + b * b + c * c); }	"	public float distanceTo(float x, float y, float z) {
		final float a = this.x - x;
		final float b = this.y - y;
		final float c = this.z - z;
		return (float) Math.sqrt(a * a + b * b + c * c);
	}
"	@param double x The point x coordinate.	@param float x The point x coordinate.	1	0	8	8	56
"public void updatePetWithForm (Long petId, String name, String status) throws ApiException { Object postBody = null; // verify the required parameter 'petId' is set if (petId == null) { throw new ApiException(400, ""Missing the required parameter 'petId' when calling updatePetWithForm""); } // create path and map variables String path = ""/pet/{petId}"".replaceAll(""\\{format\\}"",""json"").replaceAll(""\\{"" + ""petId"" + ""\\}"", apiInvoker.escapeString(petId.toString())); // query params List<Pair> queryParams = new ArrayList<Pair>(); // header params Map<String, String> headerParams = new HashMap<String, String>(); // form params Map<String, String> formParams = new HashMap<String, String>(); String[] contentTypes = { ""application/x-www-form-urlencoded"" }; String contentType = contentTypes.length > 0 ? contentTypes[0] : ""application/json""; if (contentType.startsWith(""multipart/form-data"")) { // file uploading MultipartEntityBuilder builder = MultipartEntityBuilder.create(); if (name != null) { builder.addTextBody(""name"", ApiInvoker.parameterToString(name), ApiInvoker.TEXT_PLAIN_UTF8); } if (status != null) { builder.addTextBody(""status"", ApiInvoker.parameterToString(status), ApiInvoker.TEXT_PLAIN_UTF8); } HttpEntity httpEntity = builder.build(); postBody = httpEntity; } else { // normal form params formParams.put(""name"", ApiInvoker.parameterToString(name)); formParams.put(""status"", ApiInvoker.parameterToString(status)); } try { String response = apiInvoker.invokeAPI(basePath, path, ""POST"", queryParams, postBody, headerParams, formParams, contentType); if(response != null){ return ; } else { return ; } } catch (ApiException ex) { throw ex; } }"	"  public void  updatePetWithForm (String petId, String name, String status) throws ApiException {
    Object postBody = null;
    
    // verify the required parameter 'petId' is set
    if (petId == null) {
       throw new ApiException(400, ""Missing the required parameter 'petId' when calling updatePetWithForm"");
    }
    

    // create path and map variables
    String path = ""/pet/{petId}"".replaceAll(""\\{format\\}"",""json"").replaceAll(""\\{"" + ""petId"" + ""\\}"", apiInvoker.escapeString(petId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    

    

    String[] contentTypes = {
      ""application/x-www-form-urlencoded""
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : ""application/json"";

    if (contentType.startsWith(""multipart/form-data"")) {
      // file uploading
      MultipartEntityBuilder builder = MultipartEntityBuilder.create();
      
      if (name != null) {
        builder.addTextBody(""name"", ApiInvoker.parameterToString(name), ApiInvoker.TEXT_PLAIN_UTF8);
      }
      
      if (status != null) {
        builder.addTextBody(""status"", ApiInvoker.parameterToString(status), ApiInvoker.TEXT_PLAIN_UTF8);
      }
      

      HttpEntity httpEntity = builder.build();
      postBody = httpEntity;
    } else {
      // normal form params
      formParams.put(""name"", ApiInvoker.parameterToString(name));
      formParams.put(""status"", ApiInvoker.parameterToString(status));
      
    }

    try {
      String response = apiInvoker.invokeAPI(basePath, path, ""POST"", queryParams, postBody, headerParams, formParams, contentType);
      if(response != null){
        return ;
      }
      else {
        return ;
      }
    } catch (ApiException ex) {
      throw ex;
    }
  }
"	@param petId ID of pet that needs to be updated	@param petId ID of pet that needs to be updated	0	1	10	63	377
public MultiIterator init(IndexSupport indexSupport){ this.indexSupport = indexSupport; this.iterators = new Iterator<?>[sources.size()]; this.lastEntry = new boolean[iterators.length]; this.values = new Object[iterators.length]; return this; }	"    public MultiIterator init(IteratorFactory iteratorFactory){
        this.iteratorFactory = iteratorFactory;
        this.iterators = new Iterator<?>[sources.size()];
        this.lastEntry = new boolean[iterators.length];
        this.values = new Object[iterators.length];
        return this;
    }
"	@param indexSupport	@param iteratorFactory	1	0	7	8	46
"public String invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); b.append(""?""); if (queryParams != null){ for (Pair queryParam : queryParams){ if (!queryParam.getName().isEmpty()) { b.append(escapeString(queryParam.getName())); b.append(""=""); b.append(escapeString(queryParam.getValue())); b.append(""&""); } } } String querystring = b.substring(0, b.length() - 1); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(""GET"".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (""POST"".equals(method)) { if (contentType.startsWith(""application/x-www-form-urlencoded"")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (""PUT"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (""DELETE"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, ""unknown method type "" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return """"; } } else { String message = ""error""; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { // e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }"	"  public String invokeAPI(String path, String method, Set<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {
    updateParamsForAuth(authNames, queryParams, headerParams);

    Client client = getClient();

    StringBuilder b = new StringBuilder();
    b.append(""?"");
    if (queryParams != null){
      for (Pair queryParam : queryParams){
        if (!queryParam.getName().isEmpty()) {
          b.append(escapeString(queryParam.getName()));
          b.append(""="");
          b.append(escapeString(queryParam.getValue()));
          b.append(""&"");
        }
      }
    }

    String querystring = b.substring(0, b.length() - 1);

    Builder builder;
    if (accept == null)
      builder = client.resource(basePath + path + querystring).getRequestBuilder();
    else
      builder = client.resource(basePath + path + querystring).accept(accept);

    for(String key : headerParams.keySet()) {
      builder = builder.header(key, headerParams.get(key));
    }
    for(String key : defaultHeaderMap.keySet()) {
      if(!headerParams.containsKey(key)) {
        builder = builder.header(key, defaultHeaderMap.get(key));
      }
    }

    ClientResponse response = null;

    if(""GET"".equals(method)) {
      response = (ClientResponse) builder.get(ClientResponse.class);
    }
    else if (""POST"".equals(method)) {
      if (contentType.startsWith(""application/x-www-form-urlencoded"")) {
        String encodedFormParams = this
            .getXWWWFormUrlencodedParams(formParams);
        response = builder.type(contentType).post(ClientResponse.class,
            encodedFormParams);
      } else if (body == null) {
        response = builder.post(ClientResponse.class, null);
      } else if(body instanceof FormDataMultiPart) {
        response = builder.type(contentType).post(ClientResponse.class, body);
      }
      else
        response = builder.type(contentType).post(ClientResponse.class, serialize(body));
    }
    else if (""PUT"".equals(method)) {
      if (""application/x-www-form-urlencoded"".equals(contentType)) {
          String encodedFormParams = this
              .getXWWWFormUrlencodedParams(formParams);
          response = builder.type(contentType).put(ClientResponse.class,
              encodedFormParams);
      } else if(body == null) {
        response = builder.put(ClientResponse.class, serialize(body));
      } else {
          response = builder.type(contentType).put(ClientResponse.class, serialize(body));
      }
    }
    else if (""DELETE"".equals(method)) {
      if (""application/x-www-form-urlencoded"".equals(contentType)) {
        String encodedFormParams = this
            .getXWWWFormUrlencodedParams(formParams);
        response = builder.type(contentType).delete(ClientResponse.class,
            encodedFormParams);
      } else if(body == null) {
        response = builder.delete(ClientResponse.class);
      } else {
        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));
      }
    }
    else {
      throw new ApiException(500, ""unknown method type "" + method);
    }

    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {
      return null;
    }
    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {
      if(response.hasEntity()) {
        return (String) response.getEntity(String.class);
      }
      else {
        return """";
      }
    }
    else {
      String message = ""error"";
      String respBody = null;
      if(response.hasEntity()) {
        try{
          respBody = String.valueOf(response.getEntity(String.class));
          message = respBody;
        }
        catch (RuntimeException e) {
          // e.printStackTrace();
        }
      }
      throw new ApiException(
                response.getClientResponseStatus().getStatusCode(),
                message,
                response.getHeaders(),
                respBody);
    }
  }
"	@param queryParams The query parameters	@param queryParams The query parameters	0	1	16	113	736
"public boolean isValid(Litmus litmus) { if (inputRowType == null) { return litmus.fail(null); } if (exprs == null) { return litmus.fail(null); } if (projects == null) { return litmus.fail(null); } if (outputRowType == null) { return litmus.fail(null); } // If the input row type is a struct (contains fields) then the leading // expressions must be references to those fields. But we don't require // this if the input row type is, say, a java class. if (inputRowType.isStruct()) { if (!RexUtil.containIdentity(exprs, inputRowType, litmus)) { return litmus.fail(null); } // None of the other fields should be inputRefs. for (int i = inputRowType.getFieldCount(); i < exprs.size(); i++) { RexNode expr = exprs.get(i); if (expr instanceof RexInputRef) { return litmus.fail(null); } } } // todo: enable // CHECKSTYLE: IGNORE 1 if (false && RexUtil.containNoCommonExprs(exprs, litmus)) { return litmus.fail(null); } if (!RexUtil.containNoForwardRefs(exprs, inputRowType, litmus)) { return litmus.fail(null); } if (!RexUtil.containNoNonTrivialAggs(exprs, litmus)) { return litmus.fail(null); } final Checker checker = new Checker( litmus, inputRowType, new AbstractList<RelDataType>() { public RelDataType get(int index) { return exprs.get(index).getType(); } @Override public int size() { return exprs.size(); } // CHECKSTYLE: IGNORE 1 }); if (condition != null) { if (!SqlTypeUtil.inBooleanFamily(condition.getType())) { return litmus.fail(""condition must be boolean""); } condition.accept(checker); if (checker.failCount > 0) { return litmus.fail(null); } } for (int i = 0; i < projects.size(); i++) { projects.get(i).accept(checker); if (checker.failCount > 0) { return litmus.fail(null); } } for (int i = 0; i < exprs.size(); i++) { exprs.get(i).accept(checker); if (checker.failCount > 0) { return litmus.fail(null); } } return litmus.succeed(); }"	"  public boolean isValid(boolean fail) {
    if (inputRowType == null) {
      assert !fail;
      return false;
    }
    if (exprs == null) {
      assert !fail;
      return false;
    }
    if (projects == null) {
      assert !fail;
      return false;
    }
    if (outputRowType == null) {
      assert !fail;
      return false;
    }

    // If the input row type is a struct (contains fields) then the leading
    // expressions must be references to those fields. But we don't require
    // this if the input row type is, say, a java class.
    if (inputRowType.isStruct()) {
      if (!RexUtil.containIdentity(exprs, inputRowType, fail)) {
        assert !fail;
        return false;
      }

      // None of the other fields should be inputRefs.
      for (int i = inputRowType.getFieldCount(); i < exprs.size(); i++) {
        RexNode expr = exprs.get(i);
        if (expr instanceof RexInputRef) {
          assert !fail;
          return false;
        }
      }
    }
    // todo: enable
    // CHECKSTYLE: IGNORE 1
    if (false && RexUtil.containCommonExprs(exprs, fail)) {
      assert !fail;
      return false;
    }
    if (RexUtil.containForwardRefs(exprs, inputRowType, fail)) {
      assert !fail;
      return false;
    }
    if (RexUtil.containNonTrivialAggs(exprs, fail)) {
      assert !fail;
      return false;
    }
    final Checker checker =
        new Checker(
            fail,
            inputRowType,
            new AbstractList<RelDataType>() {
              public RelDataType get(int index) {
                return exprs.get(index).getType();
              }

              @Override public int size() {
                return exprs.size();
              }
              // CHECKSTYLE: IGNORE 1
            });
    if (condition != null) {
      if (!SqlTypeUtil.inBooleanFamily(condition.getType())) {
        assert !fail : ""condition must be boolean"";
        return false;
      }
      condition.accept(checker);
      if (checker.failCount > 0) {
        assert !fail;
        return false;
      }
    }
    for (int i = 0; i < projects.size(); i++) {
      projects.get(i).accept(checker);
      if (checker.failCount > 0) {
        assert !fail;
        return false;
      }
    }
    for (int i = 0; i < exprs.size(); i++) {
      exprs.get(i).accept(checker);
      if (checker.failCount > 0) {
        assert !fail;
        return false;
      }
    }
    return true;
  }
"	@param litmus What to do if an error is detected	@param fail Whether to fail	1	0	11	79	478
@Deprecated public Graph executeSparqlQuery(ConstructQuery query, TripleCollection defaultGraph) { return (Graph) executeSparqlQuery((Query) query, defaultGraph); }	"    @Deprecated
    public ImmutableGraph executeSparqlQuery(ConstructQuery query,
            Graph defaultGraph) {
        return (ImmutableGraph) executeSparqlQuery((Query) query, defaultGraph);
    }
"	@param defaultGraph the default graph against which to execute the query if not FROM clause is present	@param defaultGraph the default ImmutableGraph against which to execute the query if not FROM clause is present	1	0	7	7	28
"public Action timedout(AtmosphereRequest request, AtmosphereResponse response) throws IOException, ServletException { AtmosphereResourceImpl r = null; try { if (trackActiveRequest) { long l = (Long) request.getAttribute(MAX_INACTIVE); if (l == -1) { // The closedDetector closed the connection. return timedoutAction; } request.setAttribute(MAX_INACTIVE, (long) -1); } logger.debug(""Timing out the connection for request {}"", request); // Something went wrong. if (request == null || response == null) { logger.warn(""Invalid Request/Response: {}/{}"", request, response); return timedoutAction; } r = (AtmosphereResourceImpl) request.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE); if (r != null && r.getAtmosphereResourceEvent().isSuspended()) { r.getAtmosphereResourceEvent().setIsResumedOnTimeout(true); Broadcaster b = r.getBroadcaster(); if (b instanceof DefaultBroadcaster) { ((DefaultBroadcaster) b).broadcastOnResume(r); } if (request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT) != null) { r.getAtmosphereResourceEvent().setIsResumedOnTimeout( (Boolean) request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT)); } invokeAtmosphereHandler(r); } } catch (Throwable t) { logger.error(""failed to timeout resource {}"", r, t); } finally { try { if (r != null) { r.notifyListeners(); r.setIsInScope(false); r.cancel(); } } catch (Throwable t) { logger.trace(""timedout"", t); } finally { try { response.getOutputStream().close(); } catch (Throwable t) { try { response.getWriter().close(); } catch (Throwable t2) { } } if (r != null) { destroyResource(r); } } } return timedoutAction; }"	"    public Action timedout(HttpServletRequest request, HttpServletResponse response)
            throws IOException, ServletException {

        AtmosphereResourceImpl r = null;
        try {
            if (trackActiveRequest) {
                long l = (Long) request.getAttribute(MAX_INACTIVE);
                if (l == -1) {
                    // The closedDetector closed the connection.
                    return timedoutAction;
                }
                request.setAttribute(MAX_INACTIVE, (long) -1);
            }

            logger.debug(""Timing out the connection for request {}"", request);

            // Something went wrong.
            if (request == null || response == null) {
                logger.warn(""Invalid Request/Response: {}/{}"", request, response);
                return timedoutAction;
            }

            r = (AtmosphereResourceImpl) request.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE);

            if (r != null && r.getAtmosphereResourceEvent().isSuspended()) {
                r.getAtmosphereResourceEvent().setIsResumedOnTimeout(true);

                Broadcaster b = r.getBroadcaster();
                if (b instanceof DefaultBroadcaster) {
                    ((DefaultBroadcaster) b).broadcastOnResume(r);
                }

                if (request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT) != null) {
                    r.getAtmosphereResourceEvent().setIsResumedOnTimeout(
                            (Boolean) request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT));
                }

                invokeAtmosphereHandler(r);
            }
        } catch (Throwable t) {
            logger.error(""failed to timeout resource {}"", r, t);
        } finally {
            try {
                if (r != null) {
                    r.notifyListeners();
                    r.setIsInScope(false);
                    r.cancel();
                }
            } catch (Throwable t) {
                logger.trace(""timedout"", t);
            } finally {

                try {
                    response.getOutputStream().close();
                } catch (Throwable t) {
                    try {
                        response.getWriter().close();
                    } catch (Throwable t2) {
                    }
                }

                if (r != null) {
                    destroyResource(r);
                }
            }
        }

        return timedoutAction;
    }
"	@param request the  AtmosphereRequest	@param request the HttpServletRequest	1	0	13	70	351
"public boolean supports(AuthenticationToken token) { if ( log.isInfoEnabled() ) { log.info( ""Received null AuthenticationToken. Returning false for supports(token) implementation (can't "" + ""process null tokens)."" ); } return token != null && getAuthenticationTokenClass().isAssignableFrom(token.getClass()); }"	"    public boolean supports(Class tokenClass) {
        return getAuthenticationTokenClass().isAssignableFrom( tokenClass );
    }
"	@param token the token being submitted for authentication.	@param tokenClass the class of the authenticationToken being submitted for authentication.	1	0	8	9	64
private RectF drawBoxWithShadow(Canvas c, int width, int height) { Resources res = mContext.getResources(); float shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur); float keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance); float corner = res.getDimension(R.dimen.widget_preview_corner_radius); RectF bounds = new RectF(shadowBlur, shadowBlur, width - shadowBlur, height - shadowBlur - keyShadowDistance); ShadowGenerator.drawShadow(c, bounds, Color.WHITE, shadowBlur, keyShadowDistance, corner); return bounds; }	"    private RectF drawBoxWithShadow(Canvas c, Paint p, int width, int height) {
        Resources res = mContext.getResources();
        float shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur);
        float keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance);
        float corner = res.getDimension(R.dimen.widget_preview_corner_radius);

        RectF bounds = new RectF(shadowBlur, shadowBlur,
                width - shadowBlur, height - shadowBlur - keyShadowDistance);
        p.setColor(Color.WHITE);

        // Key shadow
        p.setShadowLayer(shadowBlur, 0, keyShadowDistance,
                ShadowGenerator.KEY_SHADOW_ALPHA << 24);
        c.drawRoundRect(bounds, corner, corner, p);

        // Ambient shadow
        p.setShadowLayer(shadowBlur, 0, 0,
                ColorUtils.setAlphaComponent(Color.BLACK, ShadowGenerator.AMBIENT_SHADOW_ALPHA));
        c.drawRoundRect(bounds, corner, corner, p);

        p.clearShadowLayer();
        return bounds;
    }
"	@param preview bitmap that can be recycled	@param preview bitmap that can be recycled	0	1	8	12	92
public ServletRegistration.Dynamic addServlet(String name, Class<? extends Servlet> klass) { final ServletHolder holder = new ServletHolder(checkNotNull(klass)); holder.setName(name); handler.getServletHandler().addServlet(holder); return holder.getRegistration(); }	"    public ServletBuilder addServlet(Class<? extends Servlet> klass,
                                     String urlPattern) {
        final ServletHolder holder = new ServletHolder(checkNotNull(klass));
        final ServletBuilder builder = new ServletBuilder(holder, handler);
        builder.addUrlPattern(checkNotNull(urlPattern));
        return builder;
    }
"	@param klass the servlet class	@param urlPattern the URL pattern for requests that should be handled by instances of klass	1	0	7	8	49
public FilterRegistration.Dynamic addFilter(String name, Class<? extends Filter> klass) { final FilterHolder holder = new FilterHolder(checkNotNull(klass)); holder.setName(name); handler.getServletHandler().addFilter(holder); return holder.getRegistration(); }	"    public FilterBuilder addFilter(Class<? extends Filter> klass,
                                   String urlPattern) {
        final FilterHolder holder = new FilterHolder(checkNotNull(klass));
        final FilterBuilder filterConfig = new FilterBuilder(holder, handler);
        filterConfig.addUrlPattern(checkNotNull(urlPattern));
        return filterConfig;
    }
"	@param klass the filter class	@param urlPattern the URL pattern for requests that should be handled by instances of klass	1	0	7	8	49
private boolean paramAppend(StringBuilder sb, String name, String value, ParameterParser parser) { boolean isEdited = false; if (name != null) { sb.append(name); isEdited = true; } if (value != null) { sb.append(parser.getDefaultKeyValueSeparator()); sb.append(value); isEdited = true; } return isEdited; }	"    private boolean paramAppend(StringBuilder sb, String name, String value) {
        boolean isEdited = false;
        
        if (name != null) {
            sb.append(name);
            isEdited = true;
        }
        
        if (value != null) {
            sb.append('=');
            sb.append(value);
            isEdited = true;
        }
        
        return isEdited;
    }
"	@param name Null = not to append parameter.	@param name Null = not to append parameter.	0	1	7	17	68
public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws ApiException { return uploadFileWithRequiredFileWithHttpInfo(petId, requiredFile, additionalMetadata).getData(); }	"  public ModelApiResponse uploadFileWithRequiredFile(Long petId, File file, String additionalMetadata) throws ApiException {
    return uploadFileWithRequiredFileWithHttpInfo(petId, file, additionalMetadata).getData();
      }
"	@param requiredFile file to upload (required)	@param file file to upload (required)	1	0	5	4	30
public boolean searchWithTimeoutFor(Class<? extends TextView> viewClass, String regex, int expectedMinimumNumberOfMatches, boolean scroll, boolean visible) { final long endTime = System.currentTimeMillis() + TIMEOUT; while (System.currentTimeMillis() < endTime) { sleeper.sleep(); final boolean foundAnyMatchingView = searchFor(viewClass, regex, expectedMinimumNumberOfMatches, scroll, visible); if (foundAnyMatchingView){ return true; } } return false; }	"	public boolean searchWithTimeoutFor(Class<? extends TextView> viewClass, String regex, int expectedMinimumNumberOfMatches, boolean scroll) {
		final long endTime = System.currentTimeMillis() + TIMEOUT;

		while (System.currentTimeMillis() < endTime) {
			sleeper.sleep();
			final boolean foundAnyMatchingView = searchFor(viewClass, regex, expectedMinimumNumberOfMatches, scroll);
			if (foundAnyMatchingView){
				return true;
			}
		}

		return false;
	}
"	@param viewClass what kind of  View to search for, e.g.  Button.class or  TextView.class	@param viewClass what kind of View to search for, e.g. Button.class or TextView.class	0	1	8	14	77
public static int availablePort(int preferred) { int rtn = -1; try { rtn = tryPort(preferred); } catch (IOException ignored) { } return rtn; }	"    public static int availablePort(int prefered) {
        int rtn = -1;
        try {
            rtn = tryPort(prefered);
        } catch (IOException e) {

        }
        return rtn;
    }
"	@param preferred preferred port	@param prefered	1	0	7	9	34
public synchronized <T extends AbstractTypeServerPluginContainer> T getPluginContainerByPlugin(String pluginName) { for (AbstractTypeServerPluginContainer pc : this.pluginContainers.values()) { if (null != pc.getPluginManager().getPluginEnvironment(pluginName)) { return (T) pc; } } return null; }	"    public synchronized <T extends AbstractTypeServerPluginContainer> T getPluginContainerByPlugin(PluginKey pluginKey) {
        for (AbstractTypeServerPluginContainer pc : this.pluginContainers.values()) {
            try {
                if (pc.getSupportedServerPluginType().equals(new ServerPluginType(pluginKey.getPluginType()))) {
                    if (null != pc.getPluginManager().getPluginEnvironment(pluginKey.getPluginName())) {
                        return (T) pc;
                    }
                }
            } catch (Exception skip) {
                // should never really happen
                log.error(""Bad plugin key: "" + pluginKey);
            }
        }
        return null;
    }
"	@param pluginName	@param pluginKey	1	0	9	10	50
"public String getValue(String key) throws NotFoundException, NotLeaderException { if (cluster.getLocalRole() != Role.LEADER) { throw new NotLeaderException(); } if (!entries.containsKey(key)) { throw new NotFoundException(); } String value = entries.get(key); logger.info(String.format(""Get key %s: %s"", key, value)); return value; }"	"    public String getValue(String entryId) throws RecordNotFoundException {
        if (!entries.containsKey(entryId)) {
            throw new RecordNotFoundException();
        }
        return entries.get(entryId);
    }
"	@param key	@param entryId	1	0	7	13	81
"private boolean scanSingleNode(Plugin plugin, StructuralNode node) { Thread thread; Plugin test; HttpMessage msg; log.debug(""scanSingleNode node plugin="" + plugin.getName() + "" node="" + node.getName()); // do not poll for isStop here to allow every plugin to run but terminate immediately. //if (isStop()) return; try { if (node == null || node.getHistoryReference() == null) { log.debug(""scanSingleNode node or href null, returning: node="" + node); return false; } if (HistoryReference.TYPE_SCANNER == node.getHistoryReference().getHistoryType()) { log.debug(""Ignoring \""scanner\"" type href""); return false; } if (!nodeInScope(node.getName())) { log.debug(""scanSingleNode node not in scope""); return false; } msg = node.getHistoryReference().getHttpMessage(); if (msg == null) { // Likely to be a temporary node log.debug(""scanSingleNode msg null""); return false; } test = plugin.getClass().newInstance(); test.setConfig(plugin.getConfig()); test.setDelayInMs(plugin.getDelayInMs()); test.setDefaultAlertThreshold(plugin.getAlertThreshold()); test.setDefaultAttackStrength(plugin.getAttackStrength()); test.setTechSet(getTechSet()); test.init(msg, this); notifyHostProgress(plugin.getName() + "": "" + msg.getRequestHeader().getURI().toString()); } catch (Exception e) { log.error(e.getMessage() + "" "" + node.getName(), e); return false; } do { if (this.isStop()) { return false; } thread = threadPool.getFreeThreadAndRun(test); if (thread == null) { Util.sleep(200); } } while (thread == null); return true; }"	"    private boolean scanSingleNode(Plugin plugin, SiteNode node) {
        Thread thread;
        Plugin test;
        HttpMessage msg;
        
        log.debug(""scanSingleNode node plugin="" + plugin.getName() + "" node="" + node);

        // do not poll for isStop here to allow every plugin to run but terminate immediately.
        //if (isStop()) return;

        try {
            if (node == null || node.getHistoryReference() == null) {
                log.debug(""scanSingleNode node or href null, returning: node="" + node);
                return false;
            }
            
            if (HistoryReference.TYPE_SCANNER == node.getHistoryReference().getHistoryType()) {
                log.debug(""Ignoring \""scanner\"" type href"");
                return false;
            }

            if (!nodeInScope(node)) {
                log.debug(""scanSingleNode node not in scope"");
                return false;
            }
            
            msg = node.getHistoryReference().getHttpMessage();

            if (msg == null) {
                // Likely to be a temporary node
                log.debug(""scanSingleNode msg null"");
                return false;
            }

            test = plugin.getClass().newInstance();
            test.setConfig(plugin.getConfig());
            test.setDelayInMs(plugin.getDelayInMs());
            test.setDefaultAlertThreshold(plugin.getAlertThreshold());
            test.setDefaultAttackStrength(plugin.getAttackStrength());
            test.setTechSet(getTechSet());
            test.init(msg, this);
            notifyHostProgress(plugin.getName() + "": "" + msg.getRequestHeader().getURI().toString());

        } catch (Exception e) {
            if (node != null) {
                log.error(e.getMessage() + "" "" + node.getNodeName(), e);
                
            } else {
                log.error(e.getMessage(), e);
            }
            
            return false;
        }

        do {
            thread = threadPool.getFreeThreadAndRun(test);
            if (thread == null) {
                Util.sleep(200);
            }
            
        } while (thread == null);

        return true;
    }
"	@param plugin	@param plugin	0	1	9	62	364
public Order placeOrder(Order order) throws ApiException { ApiResponse<Order> resp = placeOrderWithHttpInfo(order); return resp.getData(); }	"    public Order placeOrder(Order body) throws ApiException {
        ApiResponse<Order> resp = placeOrderWithHttpInfo(body);
        return resp.getData();
    }
"	@param order order placed for purchasing the pet (required)	@param body order placed for purchasing the pet (required)	1	0	6	5	25
public FilterBuilder addFilter(Class<? extends Filter> klass, String urlPattern) { final FilterHolder holder = new FilterHolder(checkNotNull(klass)); final FilterBuilder filterConfig = new FilterBuilder(holder, handler); filterConfig.addUrlPattern(checkNotNull(urlPattern)); return filterConfig; }	"    public FilterRegistration.Dynamic addFilter(String name, Class<? extends Filter> klass) {
        final FilterHolder holder = new FilterHolder(checkNotNull(klass));
        holder.setName(name);
        handler.getServletHandler().addFilter(holder);
        return holder.getRegistration();
    }
"	@param klass the filter class	@param name the filter's name	1	0	7	9	50
"private static Method getMethod(Class<?> clazz, String attributeName) { try { char string[] = attributeName.toCharArray(); string[0] = Character.toUpperCase( string[0] ); String casedAttributeName = new String( string ); try { return clazz.getDeclaredMethod( ""get"" + casedAttributeName ); } catch ( NoSuchMethodException e ) { return clazz.getDeclaredMethod( ""is"" + casedAttributeName ); } } catch ( NoSuchMethodException e ) { return null; } }"	"	private static Method getMethod(Class<?> clazz, String methodName) {
		try {
			char string[] = methodName.toCharArray();
			string[0] = Character.toUpperCase( string[0] );
			methodName = new String( string );
			try {
				return clazz.getDeclaredMethod( ""get"" + methodName );
			}
			catch ( NoSuchMethodException e ) {
				return clazz.getDeclaredMethod( ""is"" + methodName );
			}
		}
		catch ( NoSuchMethodException e ) {
			return null;
		}
	}
"	@param attributeName The attribute name.	@param methodName The method name.	1	0	9	17	89
public final List<ModuleReference> getDependentModulesRecursively(final ModuleReference ref) throws Exception { return getDependentModulesRecursively(ref, new ArrayList<ModuleReference>()); }	"    public synchronized final List<String> getDependentModulesRecursively(final String id) throws Exception {
        final List<String> res = new ArrayList<String>();
        for (final String depModule : getDependentModules(id)) {
            res.add(depModule);
            // the graph has no cycle, so we don't need to protected against infinite loop

            res.addAll(this.getDependentModulesRecursively(depModule));
        }
        Collections.reverse(res);
        return res;
    }
"	@param ref the module.	@param id the module.	1	0	8	5	26
public static SummaryEntry[] querySummaries(Variations variationPatterns, String scenarioPattern) { return getDefault().internalQuerySummaries(variationPatterns, scenarioPattern); }	"    public static SummaryEntry[] querySummaries(Variations variationPatterns, boolean global) {
        return getDefault().internalQuerySummaries(variationPatterns, null);
    }
"	@param scenarioPattern	@param global	1	0	6	5	26
"public Emitter emit(final String event, final Object... args) { EventThread.exec(new Runnable() { @Override public void run() { if (events.containsKey(event)) { Socket.super.emit(event, args); return; } List<Object> _args = new ArrayList<Object>(args.length + 1); _args.add(event); _args.addAll(Arrays.asList(args)); JSONArray jsonArgs = new JSONArray(_args); int parserType = Parser.EVENT; if (HasBinaryData.hasBinary(jsonArgs)) { parserType = Parser.BINARY_EVENT; } Packet packet = new Packet(parserType, jsonArgs); if (_args.get(_args.size() - 1) instanceof Ack) { logger.fine(String.format(""emitting packet with ack id %d"", Socket.this.ids)); Socket.this.acks.put(Socket.this.ids, (Ack)_args.remove(_args.size() - 1)); packet.id = Socket.this.ids++; } Socket.this.packet(packet); } }); return this; }"	"    public Emitter emit(final String event, final Object... arguments) {
        EventThread.exec(new Runnable() {
            @Override
            public void run() {
                if (events.containsKey(event)) {
                    Socket.super.emit(event, arguments);
                    return;
                }

                List<Object> args = new ArrayList<Object>(arguments.length + 1);
                args.add(event);
                args.addAll(Arrays.asList(arguments));
                JSONArray _args = new JSONArray(args);
                int parserType = Parser.EVENT;
                if (HasBinaryData.hasBinary(_args)) { parserType = Parser.BINARY_EVENT; }
                Packet packet = new Packet(parserType, _args);

                if (args.get(args.size() - 1) instanceof Ack) {
                    logger.fine(String.format(""emitting packet with ack id %d"", Socket.this.ids));
                    Socket.this.acks.put(Socket.this.ids, (Ack)args.remove(args.size() - 1));
                    packet.id = Socket.this.ids++;
                }

                Socket.this.packet(packet);
            }
        });
        return this;
    }
"	@param args data to send.	@param args data to send.	0	1	15	29	202
public boolean waitForText(String text, int expectedMinimumNumberOfMatches, long timeout, boolean scroll) { final long endTime = System.currentTimeMillis() + timeout; while (true) { final boolean timedOut = System.currentTimeMillis() > endTime; if (timedOut){ return false; } sleeper.sleep(); final boolean foundAnyTextView = searcher.searchFor(TextView.class, text, expectedMinimumNumberOfMatches, scroll); if (foundAnyTextView){ return true; } final boolean foundAnyEditText = searcher.searchFor(EditText.class, text, 1, scroll); if (foundAnyEditText){ return true; } } }	"	public boolean waitForText(String text, int matches, long timeout, boolean scroll) {
        final long endTime = System.currentTimeMillis() + timeout;

		while (true) {
			final boolean timedOut = System.currentTimeMillis() > endTime;
			if (timedOut){
				return false;
			}

			sleeper.sleep();

			final boolean foundAnyTextView = searcher.searchFor(TextView.class, text, matches, scroll);
			if (foundAnyTextView){
				return true;
			}

			final boolean foundAnyEditText = searcher.searchFor(EditText.class, text, 1, scroll);
			if (foundAnyEditText){
				return true;
			}
        }
    }
"	@param scroll  true if scrolling should be performed	@param scroll true if scrolling should be performed	0	1	9	23	107
"private FileSelection expandSelectionFromMetadataCache(FileSelection selection, List<Path> metaFilePaths) throws IOException { // get the metadata for the root directory by reading the metadata file // parquetTableMetadata contains the metadata for all files in the selection root folder, but we need to make sure // we only select the files that are part of selection (by setting fileSet appropriately) // get (and set internal field) the metadata for the directory by reading the metadata file FileSystem processUserFileSystem = ImpersonationUtil.createFileSystem(ImpersonationUtil.getProcessUserName(), fs.getConf()); parquetTableMetadata = Metadata.readBlockMeta(processUserFileSystem, metaFilePaths, metaContext, readerConfig); if (ignoreExpandingSelection(parquetTableMetadata)) { return selection; } if (corruptDatesAutoCorrected) { ParquetReaderUtility.correctDatesInMetadataCache(this.parquetTableMetadata); } ParquetReaderUtility.transformBinaryInMetadataCache(parquetTableMetadata, readerConfig); List<FileStatus> fileStatuses = selection.getStatuses(fs); if (fileSet == null) { fileSet = new HashSet<>(); } final Path first = fileStatuses.get(0).getPath(); if (fileStatuses.size() == 1 && selection.getSelectionRoot().equals(first)) { // we are selecting all files from selection root. Expand the file list from the cache for (MetadataBase.ParquetFileMetadata file : parquetTableMetadata.getFiles()) { fileSet.add(file.getPath()); } } else if (selection.isExpandedPartial() && !selection.hadWildcard() && cacheFileRoot != null) { if (selection.wasAllPartitionsPruned()) { // if all partitions were previously pruned, we only need to read 1 file (for the schema) fileSet.add(this.parquetTableMetadata.getFiles().get(0).getPath()); } else { // we are here if the selection is in the expanded_partial state (i.e it has directories). We get the // list of files from the metadata cache file that is present in the cacheFileRoot directory and populate // the fileSet. However, this is *not* the final list of files that will be scanned in execution since the // second phase of partition pruning will apply on the files and modify the file selection appropriately. for (MetadataBase.ParquetFileMetadata file : this.parquetTableMetadata.getFiles()) { fileSet.add(file.getPath()); } } } else { // we need to expand the files from fileStatuses for (FileStatus status : fileStatuses) { Path currentCacheFileRoot = status.getPath(); if (status.isDirectory()) { // TODO [DRILL-4496] read the metadata cache files in parallel // Depending on the version of metadata this may represent more than 1 metadata file paths. List<Path> metaPaths = populateMetaPaths(currentCacheFileRoot, fs); MetadataBase.ParquetTableMetadataBase metadata = Metadata.readBlockMeta(processUserFileSystem, metaPaths, metaContext, readerConfig); if (ignoreExpandingSelection(metadata)) { return selection; } for (MetadataBase.ParquetFileMetadata file : metadata.getFiles()) { fileSet.add(file.getPath()); } } else { final Path path = Path.getPathWithoutSchemeAndAuthority(currentCacheFileRoot); fileSet.add(path); } } } if (fileSet.isEmpty()) { // no files were found, most likely we tried to query some empty sub folders logger.warn(""The table is empty but with outdated invalid metadata cache files. Please, delete them.""); return null; } List<Path> fileNames = new ArrayList<>(fileSet); // when creating the file selection, set the selection root without the URI prefix // The reason is that the file names above have been created in the form // /a/b/c.parquet and the format of the selection root must match that of the file names // otherwise downstream operations such as partition pruning can break. Path metaRootPath = Path.getPathWithoutSchemeAndAuthority(selection.getSelectionRoot()); this.selectionRoot = metaRootPath; // Use the FileSelection constructor directly here instead of the FileSelection.create() method // because create() changes the root to include the scheme and authority; In future, if create() // is the preferred way to instantiate a file selection, we may need to do something different... // WARNING: file statuses and file names are inconsistent FileSelection newSelection = new FileSelection(selection.getStatuses(fs), fileNames, metaRootPath, cacheFileRoot, selection.wasAllPartitionsPruned()); newSelection.setExpandedFully(); newSelection.setMetaContext(metaContext); return newSelection; }"	"  private FileSelection expandSelectionFromMetadataCache(FileSelection selection, Path metaFilePath) throws IOException {
    // get the metadata for the root directory by reading the metadata file
    // parquetTableMetadata contains the metadata for all files in the selection root folder, but we need to make sure
    // we only select the files that are part of selection (by setting fileSet appropriately)

    // get (and set internal field) the metadata for the directory by reading the metadata file
    FileSystem processUserFileSystem = ImpersonationUtil.createFileSystem(ImpersonationUtil.getProcessUserName(), fs.getConf());
    parquetTableMetadata = Metadata.readBlockMeta(processUserFileSystem, metaFilePath, metaContext, readerConfig);
    if (ignoreExpandingSelection(parquetTableMetadata)) {
      return selection;
    }
    if (corruptDatesAutoCorrected) {
      ParquetReaderUtility.correctDatesInMetadataCache(this.parquetTableMetadata);
    }
    ParquetReaderUtility.transformBinaryInMetadataCache(parquetTableMetadata, readerConfig);
    List<FileStatus> fileStatuses = selection.getStatuses(fs);

    if (fileSet == null) {
      fileSet = new HashSet<>();
    }

    final Path first = fileStatuses.get(0).getPath();
    if (fileStatuses.size() == 1 && selection.getSelectionRoot().equals(first)) {
      // we are selecting all files from selection root. Expand the file list from the cache
      for (MetadataBase.ParquetFileMetadata file : parquetTableMetadata.getFiles()) {
        fileSet.add(file.getPath());
      }

    } else if (selection.isExpandedPartial() && !selection.hadWildcard() && cacheFileRoot != null) {
      if (selection.wasAllPartitionsPruned()) {
        // if all partitions were previously pruned, we only need to read 1 file (for the schema)
        fileSet.add(this.parquetTableMetadata.getFiles().get(0).getPath());
      } else {
        // we are here if the selection is in the expanded_partial state (i.e it has directories).  We get the
        // list of files from the metadata cache file that is present in the cacheFileRoot directory and populate
        // the fileSet. However, this is *not* the final list of files that will be scanned in execution since the
        // second phase of partition pruning will apply on the files and modify the file selection appropriately.
        for (MetadataBase.ParquetFileMetadata file : this.parquetTableMetadata.getFiles()) {
          fileSet.add(file.getPath());
        }
      }
    } else {
      // we need to expand the files from fileStatuses
      for (FileStatus status : fileStatuses) {
        Path currentCacheFileRoot = status.getPath();
        if (status.isDirectory()) {
          //TODO [DRILL-4496] read the metadata cache files in parallel
          Path metaPath = new Path(currentCacheFileRoot, Metadata.METADATA_FILENAME);
          MetadataBase.ParquetTableMetadataBase metadata = Metadata.readBlockMeta(processUserFileSystem, metaPath, metaContext, readerConfig);
          if (ignoreExpandingSelection(metadata)) {
            return selection;
          }
          for (MetadataBase.ParquetFileMetadata file : metadata.getFiles()) {
            fileSet.add(file.getPath());
          }
        } else {
          final Path path = Path.getPathWithoutSchemeAndAuthority(currentCacheFileRoot);
          fileSet.add(path);
        }
      }
    }

    if (fileSet.isEmpty()) {
      // no files were found, most likely we tried to query some empty sub folders
      logger.warn(""The table is empty but with outdated invalid metadata cache files. Please, delete them."");
      return null;
    }

    List<Path> fileNames = new ArrayList<>(fileSet);

    // when creating the file selection, set the selection root without the URI prefix
    // The reason is that the file names above have been created in the form
    // /a/b/c.parquet and the format of the selection root must match that of the file names
    // otherwise downstream operations such as partition pruning can break.
    Path metaRootPath = Path.getPathWithoutSchemeAndAuthority(selection.getSelectionRoot());
    this.selectionRoot = metaRootPath;

    // Use the FileSelection constructor directly here instead of the FileSelection.create() method
    // because create() changes the root to include the scheme and authority; In future, if create()
    // is the preferred way to instantiate a file selection, we may need to do something different...
    // WARNING: file statuses and file names are inconsistent
    FileSelection newSelection = new FileSelection(selection.getStatuses(fs), fileNames, metaRootPath, cacheFileRoot,
        selection.wasAllPartitionsPruned());

    newSelection.setExpandedFully();
    newSelection.setMetaContext(metaContext);
    return newSelection;
  }
"	@param metaFilePaths metadata cache file path	@param metaFilePath metadata cache file path	1	0	14	90	815
protected String setEscapedParameter(HttpMessage message, String param, String value) { return variant.setEscapedParameter(message, originalPair, param, value); }	"    protected String setEscapedParameter(HttpMessage msg, String param, String value) {
        return variant.setEscapedParameter(msg, originalPair, param, value);
    }
"	@param value the value of the parameter	@param value	1	0	5	4	28
"public PumpEnactResult applyAPSRequest(APSResult request) { request.rate = applyBasalConstraints(request.rate); PumpEnactResult result; if (!isInitialized()) { result = new PumpEnactResult(); result.comment = MainApp.sResources.getString(R.string.pumpNotInitialized); result.enacted = false; result.success = false; log.debug(""applyAPSRequest: "" + MainApp.sResources.getString(R.string.pumpNotInitialized)); return result; } if (isSuspended()) { result = new PumpEnactResult(); result.comment = MainApp.sResources.getString(R.string.pumpsuspended); result.enacted = false; result.success = false; log.debug(""applyAPSRequest: "" + MainApp.sResources.getString(R.string.pumpsuspended)); return result; } if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: "" + request.toString()); if ((request.rate == 0 && request.duration == 0) || Math.abs(request.rate - getBaseBasalRate()) < getPumpDescription().basalStep) { if (isTempBasalInProgress()) { if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: cancelTempBasal()""); result = cancelTempBasal(false); } else { result = new PumpEnactResult(); result.absolute = request.rate; result.duration = 0; result.enacted = false; result.comment = ""Basal set correctly""; result.success = true; if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: Basal set correctly""); } } else if (isTempBasalInProgress() && getTempBasalRemainingMinutesFromHistory() > 5 && Math.abs(request.rate - getTempBasalAbsoluteRateHistory()) < getPumpDescription().basalStep) { result = new PumpEnactResult(); result.absolute = getTempBasalAbsoluteRateHistory(); result.duration = getTempBasalFromHistory(System.currentTimeMillis()).getPlannedRemainingMinutes(); result.enacted = false; result.comment = ""Temp basal set correctly""; result.success = true; if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: Temp basal set correctly""); } else { if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: setTempBasalAbsolute()""); result = setTempBasalAbsolute(request.rate, request.duration); } return result; }"	"    public boolean applyAPSRequest(APSResult request, Callback callback) {
        PumpInterface pump = getActivePump();
        request.rate = applyBasalConstraints(request.rate);

        if (!pump.isInitialized()) {
            log.debug(""applyAPSRequest: "" + MainApp.sResources.getString(R.string.pumpNotInitialized));
            if (callback != null) {
                callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpNotInitialized)).enacted(false).success(false)).run();
            }
            return false;
        }

        if (pump.isSuspended()) {
            log.debug(""applyAPSRequest: "" + MainApp.sResources.getString(R.string.pumpsuspended));
            if (callback != null) {
                callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpsuspended)).enacted(false).success(false)).run();
            }
            return false;
        }

        if (request.smb != 0) {
            long lastSMBTime = getLastBolusTime();
            if (lastSMBTime != 0 && lastSMBTime + 4.5 * 60 * 1000 > System.currentTimeMillis()) {
                log.debug(""SMB requsted but still in 5 min interval"");
            } else {
                DetailedBolusInfo detailedBolusInfo = new DetailedBolusInfo();
                detailedBolusInfo.eventType = CareportalEvent.CORRECTIONBOLUS;
                detailedBolusInfo.insulin = request.smb;
                detailedBolusInfo.isSMB = true;
                detailedBolusInfo.source = Source.USER;
                getCommandQueue().bolus(detailedBolusInfo, callback);
            }
        }

        if (Config.logCongigBuilderActions)
            log.debug(""applyAPSRequest: "" + request.toString());
        if ((request.rate == 0 && request.duration == 0) || Math.abs(request.rate - pump.getBaseBasalRate()) < pump.getPumpDescription().basalStep) {
            if (isTempBasalInProgress()) {
                if (Config.logCongigBuilderActions)
                    log.debug(""applyAPSRequest: cancelTempBasal()"");
                getCommandQueue().cancelTempBasal(false, callback);
                return true;
            } else {
                if (Config.logCongigBuilderActions)
                    log.debug(""applyAPSRequest: Basal set correctly"");
                if (callback != null) {
                    callback.result(new PumpEnactResult().absolute(request.rate).duration(0).enacted(false).success(true).comment(""Basal set correctly"")).run();
                }
                return false;
            }
        } else if (isTempBasalInProgress()
                && getTempBasalRemainingMinutesFromHistory() > 5
                && Math.abs(request.rate - getTempBasalAbsoluteRateHistory()) < pump.getPumpDescription().basalStep) {
            if (Config.logCongigBuilderActions)
                log.debug(""applyAPSRequest: Temp basal set correctly"");
            if (callback != null) {
                callback.result(new PumpEnactResult().absolute(getTempBasalAbsoluteRateHistory()).duration(getTempBasalFromHistory(System.currentTimeMillis()).getPlannedRemainingMinutes()).enacted(false).success(true).comment(""Temp basal set correctly"")).run();
            }
            return false;
        } else {
            if (Config.logCongigBuilderActions)
                log.debug(""applyAPSRequest: setTempBasalAbsolute()"");
            getCommandQueue().tempBasalAbsolute(request.rate, request.duration, false, callback);
            return true;
        }
    }
"	@param request	@param request	0	1	10	58	385
"protected AtmosphereHandlerWrapper map(AtmosphereRequest req) throws ServletException { String path; if (req.getPathInfo() != null) { path = req.getServletPath() + req.getPathInfo(); } else { path = req.getServletPath(); } if (path == null || path.length() <= 1) { path = ""/all""; } AtmosphereHandlerWrapper atmosphereHandlerWrapper = map(path); if (atmosphereHandlerWrapper == null) { atmosphereHandlerWrapper = map(""/all""); } if (atmosphereHandlerWrapper == null) { throw new AtmosphereMappingException(""No AtmosphereHandler maps request for "" + path); } config.getBroadcasterFactory().add(atmosphereHandlerWrapper.broadcaster, atmosphereHandlerWrapper.broadcaster.getID()); return atmosphereHandlerWrapper; }"	"    protected AtmosphereHandlerWrapper map(HttpServletRequest req) throws ServletException {
        String path;
        if (req.getPathInfo() != null) {
            path = req.getServletPath() + req.getPathInfo();
        } else {
            path = req.getServletPath();
        }
        if (path == null || path.length() <= 1) {
            path = ""/all"";
        }

        AtmosphereHandlerWrapper atmosphereHandlerWrapper = map(path);
        if (atmosphereHandlerWrapper == null) {
            atmosphereHandlerWrapper = map(""/all"");
        }

        if (atmosphereHandlerWrapper == null) {
            throw new AtmosphereMappingException(""No AtmosphereHandler maps request for "" + path);
        }
        config.getBroadcasterFactory().add(atmosphereHandlerWrapper.broadcaster,
                atmosphereHandlerWrapper.broadcaster.getID());
        return atmosphereHandlerWrapper;
    }
"	@param req the  AtmosphereResponse	@param req the HttpServletResponse	1	0	8	24	129
public static Set<ConfiguredClassHierarchy<EntityClass>> createEntityHierarchies(AnnotationsBindingContext bindingContext) { Map<ClassInfo, List<ClassInfo>> processedClassInfos = new HashMap<ClassInfo, List<ClassInfo>>(); for ( ClassInfo info : bindingContext.getIndex().getKnownClasses() ) { if ( !isEntityClass( info ) ) { continue; } if ( processedClassInfos.containsKey( info ) ) { continue; } List<ClassInfo> configuredClassList = new ArrayList<ClassInfo>(); ClassInfo tmpClassInfo = info; Class<?> clazz = bindingContext.locateClassByName( tmpClassInfo.toString() ); while ( clazz != null && !clazz.equals( Object.class ) ) { tmpClassInfo = bindingContext.getIndex().getClassByName( DotName.createSimple( clazz.getName() ) ); clazz = clazz.getSuperclass(); if ( tmpClassInfo == null ) { continue; } if ( existsHierarchyWithClassInfoAsLeaf( processedClassInfos, tmpClassInfo ) ) { List<ClassInfo> classInfoList = processedClassInfos.get( tmpClassInfo ); for ( ClassInfo tmpInfo : configuredClassList ) { classInfoList.add( tmpInfo ); processedClassInfos.put( tmpInfo, classInfoList ); } break; } else { configuredClassList.add( 0, tmpClassInfo ); processedClassInfos.put( tmpClassInfo, configuredClassList ); } } } Set<ConfiguredClassHierarchy<EntityClass>> hierarchies = new HashSet<ConfiguredClassHierarchy<EntityClass>>(); List<List<ClassInfo>> processedList = new ArrayList<List<ClassInfo>>(); for ( List<ClassInfo> classInfoList : processedClassInfos.values() ) { if ( !processedList.contains( classInfoList ) ) { hierarchies.add( ConfiguredClassHierarchy.createEntityClassHierarchy( classInfoList, bindingContext ) ); processedList.add( classInfoList ); } } return hierarchies; }	"	public static Set<ConfiguredClassHierarchy<EntityClass>> createEntityHierarchies(AnnotationsBindingContext context) {
		ClassLoaderService classLoaderService = context.getServiceRegistry().getService( ClassLoaderService.class );
		Map<ClassInfo, List<ClassInfo>> processedClassInfos = new HashMap<ClassInfo, List<ClassInfo>>();

		for ( ClassInfo info : context.getIndex().getKnownClasses() ) {
			if ( !isEntityClass( info ) ) {
				continue;
			}

			if ( processedClassInfos.containsKey( info ) ) {
				continue;
			}

			List<ClassInfo> configuredClassList = new ArrayList<ClassInfo>();
			ClassInfo tmpClassInfo = info;
			Class<?> clazz = classLoaderService.classForName( tmpClassInfo.toString() );
			while ( clazz != null && !clazz.equals( Object.class ) ) {
				tmpClassInfo = context.getIndex().getClassByName( DotName.createSimple( clazz.getName() ) );
				clazz = clazz.getSuperclass();
				if ( tmpClassInfo == null ) {
					continue;
				}

				if ( existsHierarchyWithClassInfoAsLeaf( processedClassInfos, tmpClassInfo ) ) {
					List<ClassInfo> classInfoList = processedClassInfos.get( tmpClassInfo );
					for ( ClassInfo tmpInfo : configuredClassList ) {
						classInfoList.add( tmpInfo );
						processedClassInfos.put( tmpInfo, classInfoList );
					}
					break;
				}
				else {
					configuredClassList.add( 0, tmpClassInfo );
					processedClassInfos.put( tmpClassInfo, configuredClassList );
				}
			}
		}

		Set<ConfiguredClassHierarchy<EntityClass>> hierarchies = new HashSet<ConfiguredClassHierarchy<EntityClass>>();
		List<List<ClassInfo>> processedList = new ArrayList<List<ClassInfo>>();
		for ( List<ClassInfo> classInfoList : processedClassInfos.values() ) {
			if ( !processedList.contains( classInfoList ) ) {
				hierarchies.add( ConfiguredClassHierarchy.createEntityClassHierarchy( classInfoList, context ) );
				processedList.add( classInfoList );
			}
		}

		return hierarchies;
	}
"	@param bindingContext The binding context, giving access to needed services and information	@param context the annotation binding context with access to the service registry and the annotation index	1	0	13	49	271
"private HttpSession getMatchingHttpSession(List<HttpCookie> cookies, final Set<String> tokens) { // Pre-checks if (sessions.isEmpty()) { return null; } List<HttpSession> matchingSessions = new LinkedList<>(sessions); for (String token : tokens) { // Get the corresponding cookie from the cookies list HttpCookie matchingCookie = null; for (HttpCookie cookie : cookies) { if (cookie.getName().equals(token)) { matchingCookie = cookie; break; } } // Filter the sessions that do not match the cookie value Iterator<HttpSession> it = matchingSessions.iterator(); while (it.hasNext()) { if (!it.next().matchesToken(token, matchingCookie)) { it.remove(); } } } // Return the matching session if (matchingSessions.size() >= 1) { if (matchingSessions.size() > 1) { log.warn(""Multiple sessions matching the cookies from response for site: "" + getSite() + "". Using first one.""); } return matchingSessions.get(0); } return null; }"	"	private HttpSession getMatchingHttpSession(List<HttpCookie> cookies, final HttpSessionTokensSet siteTokens) {

		return CookieBasedSessionManagementHelper.getMatchingHttpSession(sessions, cookies, siteTokens);
	}
"	@param cookies the cookies present in the request header of the message	@param cookies the cookies present in the request header of the message	0	1	11	38	204
public int compareTo(Object reference) { ServiceReference other = (ServiceReference) reference; Long id = (Long) getProperty(Constants.SERVICE_ID); Long otherId = (Long) other.getProperty(Constants.SERVICE_ID); if (id.equals(otherId)) { return 0; // same service } Integer rank = (Integer) getProperty(Constants.SERVICE_RANKING); Integer otherRank = (Integer) other .getProperty(Constants.SERVICE_RANKING); // If no rank, then spec says it defaults to zero. rank = (rank == null) ? new Integer(0) : rank; otherRank = (otherRank == null) ? new Integer(0) : otherRank; // Sort by rank in ascending order. if (rank.compareTo(otherRank) < 0) { return -1; // lower rank } else if (rank.compareTo(otherRank) > 0) { return 1; // higher rank } // If ranks are equal, then sort by service id in descending order. return (id.compareTo(otherId) < 0) ? 1 : -1; }	"    public int compareTo(Object arg0) {
        throw new UnsupportedOperationException(""This feature has not yet been implemented."");

    }
"	@param reference the service reference	@param arg0 the object	1	0	7	31	196
public static float length(float x, float y, float z) { return (float) Math.sqrt(length2(x, y, z)); }	"	public static double length(double x, double y, double z) {
		return Math.sqrt(length2(x, y, z));
	}
"	@param x float The x component.	@param x double The x component.	1	0	7	5	33
public boolean onCollapseStart(CommonCardView viewCard) { Card card = viewCard.getCard(); if (card!=null){ String itemId = card.getId(); if (mExpandedIds.contains(itemId)) { return true; } } return false; }	"    public boolean onCollapseStart(CardView viewCard) {
        Card card = viewCard.getCard();
        if (card!=null){
            String itemId = card.getId();
            if (mExpandedIds.contains(itemId)) {
                return true;
            }
        }
        return false;
    }
"	@param viewCard	@param viewCard	0	1	8	11	47
public OuterComposite fakeOuterCompositeSerialize(OuterComposite outerComposite) throws ApiException { ApiResponse<OuterComposite> resp = fakeOuterCompositeSerializeWithHttpInfo(outerComposite); return resp.getData(); }	"    public OuterComposite fakeOuterCompositeSerialize(OuterComposite body) throws ApiException {
        ApiResponse<OuterComposite> resp = fakeOuterCompositeSerializeWithHttpInfo(body);
        return resp.getData();
    }
"	@param outerComposite Input composite as post body (optional)	@param body Input composite as post body (optional)	1	0	6	5	25
private static CoreLabel fromProto(CoreNLPProtos.Token proto) { CoreLabel word = new CoreLabel(); // Required fields word.setWord(proto.getWord()); // Optional fields if (proto.hasPos()) { word.setTag(proto.getPos()); } if (proto.hasValue()) { word.setValue(proto.getValue()); } if (proto.hasCategory()) { word.setCategory(proto.getCategory()); } if (proto.hasBefore()) { word.setBefore(proto.getBefore()); } if (proto.hasAfter()) { word.setAfter(proto.getAfter()); } if (proto.hasOriginalText()) { word.setOriginalText(proto.getOriginalText()); } if (proto.hasNer()) { word.setNER(proto.getNer()); } if (proto.hasLemma()) { word.setLemma(proto.getLemma()); } if (proto.hasBeginChar()) { word.setBeginPosition(proto.getBeginChar()); } if (proto.hasEndChar()) { word.setEndPosition(proto.getEndChar()); } if (proto.hasSpeaker()) { word.set(SpeakerAnnotation.class, proto.getSpeaker()); } if (proto.hasUtterance()) { word.set(UtteranceAnnotation.class, proto.getUtterance()); } if (proto.hasBeginIndex()) { word.set(BeginIndexAnnotation.class, proto.getBeginIndex()); } if (proto.hasEndIndex()) { word.set(EndIndexAnnotation.class, proto.getEndIndex()); } if (proto.hasTokenBeginIndex()) { word.set(TokenBeginAnnotation.class, proto.getTokenBeginIndex()); } if (proto.hasTokenEndIndex()) { word.set(TokenEndAnnotation.class, proto.getTokenEndIndex()); } if (proto.hasNormalizedNER()) { word.set(NormalizedNamedEntityTagAnnotation.class, proto.getNormalizedNER()); } if (proto.hasTimexValue()) { word.set(TimexAnnotation.class, fromProto(proto.getTimexValue())); } if (proto.getXmlContextCount() > 0) { word.set(XmlContextAnnotation.class, proto.getXmlContextList()); } if (proto.hasCorefClusterID()) { word.set(CorefClusterIdAnnotation.class, proto.getCorefClusterID()); } // Non-default annotators if (proto.hasGender()) { word.set(GenderAnnotation.class, proto.getGender()); } if (proto.hasTrueCase()) { word.set(TrueCaseAnnotation.class, proto.getTrueCase()); } if (proto.hasTrueCaseText()) { word.set(TrueCaseTextAnnotation.class, proto.getTrueCaseText()); } // Return return word; }	"  private static CoreLabel fromProto(CoreMapProtos.CoreLabel proto) {
    CoreLabel word = new CoreLabel();
    // Required fields
    word.setWord(proto.getWord());
    // Optional fields
    if (proto.hasPos()) { word.setTag(proto.getPos()); }
    if (proto.hasValue()) { word.setValue(proto.getValue()); }
    if (proto.hasCategory()) { word.setCategory(proto.getCategory()); }
    if (proto.hasBefore()) { word.setBefore(proto.getBefore()); }
    if (proto.hasAfter()) { word.setAfter(proto.getAfter()); }
    if (proto.hasOriginalText()) { word.setOriginalText(proto.getOriginalText()); }
    if (proto.hasNer()) { word.setNER(proto.getNer()); }
    if (proto.hasLemma()) { word.setLemma(proto.getLemma()); }
    if (proto.hasBeginChar()) { word.setBeginPosition(proto.getBeginChar()); }
    if (proto.hasEndChar()) { word.setEndPosition(proto.getEndChar()); }
    if (proto.hasSpeaker()) { word.set(SpeakerAnnotation.class, proto.getSpeaker()); }
    if (proto.hasUtterance()) { word.set(UtteranceAnnotation.class, proto.getUtterance()); }
    if (proto.hasBeginIndex()) { word.set(BeginIndexAnnotation.class, proto.getBeginIndex()); }
    if (proto.hasEndIndex()) { word.set(EndIndexAnnotation.class, proto.getEndIndex()); }
    if (proto.hasTokenBeginIndex()) { word.set(TokenBeginAnnotation.class, proto.getTokenBeginIndex()); }
    if (proto.hasTokenEndIndex()) { word.set(TokenEndAnnotation.class, proto.getTokenEndIndex()); }
    if (proto.hasNormalizedNER()) { word.set(NormalizedNamedEntityTagAnnotation.class, proto.getNormalizedNER()); }
    // Return
    return word;
  }
"	@param proto The serialized protobuf to read the CoreLabel from.	@param proto The serialized protobuf to read the CoreLabel from.	0	1	8	33	504
protected static TableId parse(String[] parts, int numParts, boolean useCatalogBeforeSchema) { if (numParts == 0) return null; if (numParts == 1) return new TableId(null, null, parts[0]); // table only if (numParts == 2) { if (useCatalogBeforeSchema) return new TableId(parts[0], null, parts[1]); // catalog & table only return new TableId(null, parts[0], parts[1]); // catalog & table only } return new TableId(parts[0], parts[1], parts[2]); // catalog & table only }	"    public static TableId parse(String str, char delimiter, boolean useCatalogBeforeSchema) {
        String[] parts = str.split(""[\\"" + delimiter + ""]"");
        if (parts.length == 0) return null;
        if (parts.length == 1) return new TableId(null, null, parts[0]); // table only
        if (parts.length == 2) {
            if (useCatalogBeforeSchema) return new TableId(parts[0], null, parts[1]); // catalog & table only
            return new TableId(null, parts[0], parts[1]); // catalog & table only
        }
        return new TableId(parts[0], parts[1], parts[2]); // catalog & table only
    }
"	@param parts the parts of the identifier; may not be null	@param str the input string	1	0	10	10	132
private static EntityKey getOptionalObjectKey(QueryParameters queryParameters, SharedSessionContractImplementor session) { final Object optionalObject = queryParameters.getOptionalObject(); final Serializable optionalId = queryParameters.getOptionalId(); final String optionalEntityName = queryParameters.getOptionalEntityName(); if ( optionalObject != null && optionalEntityName != null ) { return session.generateEntityKey( optionalId, session.getEntityPersister( optionalEntityName, optionalObject ) ); } else { return null; } }	"	private static EntityKey getOptionalObjectKey(QueryParameters queryParameters, SessionImplementor session) {
		final Object optionalObject = queryParameters.getOptionalObject();
		final Serializable optionalId = queryParameters.getOptionalId();
		final String optionalEntityName = queryParameters.getOptionalEntityName();

		if ( optionalObject != null && optionalEntityName != null ) {
			return session.generateEntityKey(
					optionalId, session.getEntityPersister(
							optionalEntityName,
							optionalObject
					)
			);
		}
		else {
			return null;
		}

	}
"	@param session The session from which the request originated.	@param session The session from which the request originated.	0	1	8	19	71
public double get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }	"    public double get(WithAttributes attributes) {
        return attributes.getAttributes().get(this);
    }
"	@param withAttributes an object containing an AttributeMap	@param attributes an object containing an AttributeMap	1	0	6	5	19
"public OuterComposite fakeOuterCompositeSerialize(OuterComposite body) throws ApiException { Object localVarPostBody = body; // create path and map variables String localVarPath = ""/fake/outer/composite"".replaceAll(""\\{format\\}"",""json""); // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { ""*/*"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<OuterComposite> localVarReturnType = new GenericType<OuterComposite>() {}; return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	"  public OuterComposite fakeOuterCompositeSerialize(OuterComposite outerComposite) throws ApiException {
    Object localVarPostBody = outerComposite;
    
    // create path and map variables
    String localVarPath = ""/fake/outer/composite"".replaceAll(""\\{format\\}"",""json"");

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    final String[] localVarAccepts = {
      ""*/*""
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    GenericType<OuterComposite> localVarReturnType = new GenericType<OuterComposite>() {};
    return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);
      }
"	@param body Input composite as post body (optional)	@param outerComposite Input composite as post body (optional)	1	0	8	30	176
public static boolean filter(String path, Collection<String> includes, Collection<String> excludes, boolean allowPartialMatches) { includes = (includes == null ? Collections.<String> emptyList() : includes); excludes = (excludes == null ? Collections.<String> emptyList() : excludes); if (includes.isEmpty() && excludes.isEmpty()) { return true; } if (Regex.simpleMatch(excludes, path)) { return false; } boolean exactIncludeMatch = false; // true if the current position was specifically mentioned boolean pathIsPrefixOfAnInclude = false; // true if potentially a sub scope can be included if (includes.isEmpty()) { // implied match anything exactIncludeMatch = true; } else { for (String include : includes) { // check for prefix matches as well to see if we need to zero in, something like: obj1.arr1.* or *.field // note, this does not work well with middle matches, like obj1.*.obj3 if (include.charAt(0) == '*') { if (Regex.simpleMatch(include, path)) { exactIncludeMatch = true; break; } // pathIsPrefixOfAnInclude = true; // continue; } if (include.startsWith(path)) { if (include.length() == path.length()) { exactIncludeMatch = true; break; } else if (include.length() > path.length() && include.charAt(path.length()) == '.') { // include might may match deeper paths. Dive deeper. pathIsPrefixOfAnInclude = true; continue; } } if (Regex.simpleMatch(include, path)) { exactIncludeMatch = true; break; } } } // if match or part of the path (based on the passed param) if (exactIncludeMatch || (allowPartialMatches && pathIsPrefixOfAnInclude)) { return true; } return false; }	"    public static boolean filter(String path, Collection<String> includes, Collection<String> excludes) {
        includes = (includes == null ? Collections.<String> emptyList() : includes);
        excludes = (excludes == null ? Collections.<String> emptyList() : excludes);

        if (includes.isEmpty() && excludes.isEmpty()) {
            return true;
        }

        if (Regex.simpleMatch(excludes, path)) {
            return false;
        }

        boolean exactIncludeMatch = false; // true if the current position was specifically mentioned
        boolean pathIsPrefixOfAnInclude = false; // true if potentially a sub scope can be included
        if (includes.isEmpty()) {
            // implied match anything
            exactIncludeMatch = true;
        }
        else {
            for (String include : includes) {
                // check for prefix matches as well to see if we need to zero in, something like: obj1.arr1.* or *.field
                // note, this does not work well with middle matches, like obj1.*.obj3
                if (include.charAt(0) == '*') {
                    if (Regex.simpleMatch(include, path)) {
                        exactIncludeMatch = true;
                        break;
                    }
//                    pathIsPrefixOfAnInclude = true;
//                    continue;
                }
                if (include.startsWith(path)) {
                    if (include.length() == path.length()) {
                        exactIncludeMatch = true;
                        break;
                    }
                    else if (include.length() > path.length() && include.charAt(path.length()) == '.') {
                        // include might may match deeper paths. Dive deeper.
                        pathIsPrefixOfAnInclude = true;
                        continue;
                    }
                }
                if (Regex.simpleMatch(include, path)) {
                    exactIncludeMatch = true;
                    break;
                }
            }
        }

        if (pathIsPrefixOfAnInclude || exactIncludeMatch) {
            // if match or part of the path
            return true;
        }
        
        return false;
    }
"	@param includes	@param includes	0	1	14	56	344
"public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws RestClientException { Object postBody = new Object(); // verify the required parameter 'petId' is set if (petId == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'petId' when calling uploadFileWithRequiredFile""); } // verify the required parameter 'requiredFile' is set if (requiredFile == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile""); } // create path and map variables final Map<String, Object> uriVariables = new HashMap<String, Object>(); uriVariables.put(""petId"", petId); String path = UriComponentsBuilder.fromPath(""/fake/{petId}/uploadImageWithRequiredFile"").buildAndExpand(uriVariables).toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); if (additionalMetadata != null) formParams.add(""additionalMetadata"", additionalMetadata); if (requiredFile != null) formParams.add(""requiredFile"", new FileSystemResource(requiredFile)); final String[] accepts = { ""application/json"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { ""multipart/form-data"" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { ""petstore_auth"" }; ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {}; return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }"	"    public ModelApiResponse uploadFileWithRequiredFile(Long petId, File file, String additionalMetadata) throws RestClientException {
        Object postBody = new Object();
        
        // verify the required parameter 'petId' is set
        if (petId == null) {
            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'petId' when calling uploadFileWithRequiredFile"");
        }
        
        // verify the required parameter 'file' is set
        if (file == null) {
            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'file' when calling uploadFileWithRequiredFile"");
        }
        
        // create path and map variables
        final Map<String, Object> uriVariables = new HashMap<String, Object>();
        uriVariables.put(""petId"", petId);
        String path = UriComponentsBuilder.fromPath(""/fake/{petId}/uploadImageWithRequiredFile"").buildAndExpand(uriVariables).toUriString();
        
        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();
        final HttpHeaders headerParams = new HttpHeaders();
        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();
        
        if (additionalMetadata != null)
            formParams.add(""additionalMetadata"", additionalMetadata);
        if (file != null)
            formParams.add(""file"", new FileSystemResource(file));

        final String[] accepts = { 
            ""application/json""
        };
        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);
        final String[] contentTypes = { 
            ""multipart/form-data""
        };
        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);

        String[] authNames = new String[] { ""petstore_auth"" };

        ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {};
        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);
    }
"	@param requiredFile file to upload	@param file file to upload	1	0	8	42	327
"public Client testClientModel(Client client) throws ApiException { Object localVarPostBody = client; // verify the required parameter 'client' is set if (client == null) { throw new ApiException(400, ""Missing the required parameter 'client' when calling testClientModel""); } // create path and map variables String localVarPath = ""/fake""; // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { ""application/json"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { ""application/json"" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Client> localVarReturnType = new GenericType<Client>() {}; return apiClient.invokeAPI(localVarPath, ""PATCH"", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	"  public Client testClientModel(Client body) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, ""Missing the required parameter 'body' when calling testClientModel"");
    }
    
    // create path and map variables
    String localVarPath = ""/fake"";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    final String[] localVarAccepts = {
      ""application/json""
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      ""application/json""
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    GenericType<Client> localVarReturnType = new GenericType<Client>() {};
    return apiClient.invokeAPI(localVarPath, ""PATCH"", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);
      }
"	@param client client model (required)	@param body client model (required)	1	0	8	36	210
private ColumnState buildUnionList(ContainerState parent, ColumnMetadata columnSchema) { // The variant must start out empty. assert columnSchema.variantSchema().size() == 0; // Create the union writer, bound to an empty list shim. final UnionWriterImpl unionWriter = new UnionWriterImpl(columnSchema); unionWriter.bindShim(new EmptyListShim()); final VariantObjectWriter unionObjWriter = new VariantObjectWriter(unionWriter); // Create the list vector. Starts with the default (dummy) data // vector which corresponds to the empty union shim above. // Don't get the list vector from the vector cache. List vectors may // have content that varies from batch to batch. Only the leaf // vectors can be cached. final ListVector listVector = new ListVector(columnSchema.schema(), parent.loader().allocator(), null); // Create the list vector state that tracks the list vector lifecycle. final ListVectorState vectorState = new ListVectorState(unionWriter, listVector); // Create the list writer: an array of unions. final AbstractObjectWriter listWriter = new ArrayObjectWriter( new ListWriterImpl(columnSchema, listVector, unionObjWriter)); // Create the manager for the columns within the list (which may or // may not be grouped into a union.) final ListState listState = new ListState(parent.loader(), parent.vectorCache().childCache(columnSchema.name())); // Bind the union state to the union writer to handle column additions. unionWriter.bindListener(listState); // Assemble it all into a union column state. return new UnionColumnState(parent.loader(), listWriter, vectorState, listState); }	"  private ColumnState buildUnionList(ContainerState parent, ColumnReadProjection colProj) {
    ColumnMetadata columnSchema = colProj.providedSchema();

    // The variant must start out empty.

    assert columnSchema.variantSchema().size() == 0;

    // Create the union writer, bound to an empty list shim.

    final UnionWriterImpl unionWriter = new UnionWriterImpl(columnSchema);
    unionWriter.bindShim(new EmptyListShim());
    final VariantObjectWriter unionObjWriter = new VariantObjectWriter(unionWriter);

    // Create the list vector. Starts with the default (dummy) data
    // vector which corresponds to the empty union shim above.
    // Don't get the list vector from the vector cache. List vectors may
    // have content that varies from batch to batch. Only the leaf
    // vectors can be cached.

    final ListVector listVector = new ListVector(columnSchema.schema(),
        parent.loader().allocator(), null);

    // Create the list vector state that tracks the list vector lifecycle.

    final ListVectorState vectorState = new ListVectorState(unionWriter, listVector);

    // Create the list writer: an array of unions.

    final AbstractObjectWriter listWriter = new ArrayObjectWriter(
        new ListWriterImpl(columnSchema, listVector, unionObjWriter));

    // Create the manager for the columns within the list (which may or
    // may not be grouped into a union.)

    final ListState listState = new ListState(parent.loader(),
        parent.vectorCache().childCache(columnSchema.name()));

    // Bind the union state to the union writer to handle column additions.

    unionWriter.bindListener(listState);

    // Assemble it all into a union column state.

    return new UnionColumnState(parent.loader(),
        listWriter, vectorState, listState);
  }
"	@param parent the parent (tuple, union or list) that holds this list	@param parent the parent (tuple, union or list) that holds this list	0	1	8	38	299
public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws ApiException { ApiResponse<ModelApiResponse> resp = uploadFileWithRequiredFileWithHttpInfo(petId, requiredFile, additionalMetadata); return resp.getData(); }	"    public ModelApiResponse uploadFileWithRequiredFile(Long petId, File file, String additionalMetadata) throws ApiException {
        ApiResponse<ModelApiResponse> resp = uploadFileWithRequiredFileWithHttpInfo(petId, file, additionalMetadata);
        return resp.getData();
    }
"	@param requiredFile file to upload (required)	@param file file to upload (required)	1	0	6	5	35
"public QuoteAnnotator(Properties props, boolean verbose) { USE_SINGLE = Boolean.parseBoolean(props.getProperty(""singleQuotes"", ""false"")); MAX_LENGTH = Integer.parseInt(props.getProperty(""maxLength"", ""-1"")); ASCII_QUOTES = Boolean.parseBoolean(props.getProperty(""asciiQuotes"", ""false"")); ALLOW_EMBEDDED_SAME = Boolean.parseBoolean(props.getProperty(""allowEmbeddedSame"", ""false"")); SMART_QUOTES = Boolean.parseBoolean(props.getProperty(""smartQuotes"", ""false"")); EXTRACT_UNCLOSED = Boolean.parseBoolean(props.getProperty(""extractUnclosedQuotes"", ""false"")); VERBOSE = verbose; Timing timer = null; if (VERBOSE) { timer = new Timing(); log.info(""Preparing quote annotator...""); } if (VERBOSE) { timer.stop(""done.""); } }"	"  public QuoteAnnotator(String name, Properties props, boolean verbose) {
    USE_SINGLE = Boolean.parseBoolean(props.getProperty(name + ""."" + ""singleQuotes"", ""false""));
    MAX_LENGTH = Integer.parseInt(props.getProperty(name + ""."" + ""maxLength"", ""-1""));
    ASCII_QUOTES = Boolean.parseBoolean(props.getProperty(name + ""."" + ""asciiQuotes"", ""false""));
    ALLOW_EMBEDDED_SAME = Boolean.parseBoolean(props.getProperty(name + ""."" + ""allowEmbeddedSame"", ""false""));
    SMART_QUOTES = Boolean.parseBoolean(props.getProperty(name + ""."" + ""smartQuotes"", ""false""));
    EXTRACT_UNCLOSED = Boolean.parseBoolean(props.getProperty(name + ""."" + ""extractUnclosedQuotes"", ""false""));
    ATTRIBUTE_QUOTES = Boolean.parseBoolean(props.getProperty(name + ""."" + ""attributeQuotes"", ""true""));

    VERBOSE = verbose;
    Timing timer = null;
    if (VERBOSE) {
      timer = new Timing();
      log.info(""Preparing quote annotator..."");
    }
    if (ATTRIBUTE_QUOTES)
      quoteAttributionAnnotator = new QuoteAttributionAnnotator(props);

    if (VERBOSE) {
      timer.stop(""done."");
    }
  }
"	@param verbose whether or not to output verbose information.	@param verbose whether or not to output verbose information.	0	1	8	20	157
"public double getLeadingRowCount(RexNode condition, String tabIdxName, DrillScanRelBase scanRel) { String conditionAsStr = nullConditionAsString; Map<String, StatisticsPayload> payloadMap; if ((scanRel instanceof DrillScanRel && ((DrillScanRel)scanRel).getGroupScan() instanceof DbGroupScan) || (scanRel instanceof ScanPrel && ((ScanPrel)scanRel).getGroupScan() instanceof DbGroupScan)) { if (condition == null && fullTableScanPayload != null) { return fullTableScanPayload.getLeadingRowCount(); } else if (condition != null) { conditionAsStr = convertRexToString(condition, scanRel.getRowType()); payloadMap = statsCache.get(conditionAsStr); if (payloadMap != null) { if (payloadMap.get(tabIdxName) != null) { return payloadMap.get(tabIdxName).getLeadingRowCount(); } // Unlike rowcount, leading rowcount is dependent on the index. So, if tab/idx is // not found, we are out of luck! } } } if (statsAvailable) { logger.debug(""Statistics: Leading filter row count is UNKNOWN for filter: {}"", conditionAsStr); } return ROWCOUNT_UNKNOWN; }"	"  public double getLeadingRowCount(RexNode condition, String tabIdxName, RelNode scanRel) {
    String conditionAsStr = nullConditionAsString;
    Map<String, StatisticsPayload> payloadMap;
    if ((scanRel instanceof DrillScanRel && ((DrillScanRel)scanRel).getGroupScan() instanceof DbGroupScan)
        || (scanRel instanceof ScanPrel && ((ScanPrel)scanRel).getGroupScan() instanceof DbGroupScan)) {
      if (condition == null && fullTableScanPayload != null) {
        return fullTableScanPayload.getLeadingRowCount();
      } else if (condition != null) {
        conditionAsStr = convertRexToString(condition, scanRel.getRowType());
        payloadMap = statsCache.get(conditionAsStr);
        if (payloadMap != null) {
          if (payloadMap.get(tabIdxName) != null) {
            return payloadMap.get(tabIdxName).getLeadingRowCount();
          }
          // Unlike rowcount, leading rowcount is dependent on the index. So, if tab/idx is
          // not found, we are out of luck!
        }
      }
    }
    if (statsAvailable) {
      logger.debug(""Statistics: Leading filter row count is UNKNOWN for filter: {}"", conditionAsStr);
    }
    return ROWCOUNT_UNKNOWN;
  }
"	@param tabIdxName - The table/index identifier	@param tabIdxName - The table/index identifier	0	1	14	25	204
"public Task<Boolean> contains(final List<CacheKey> keys) { if (keys.isEmpty()) { return Task.forResult(false); } for (CacheKey key : keys) { EncodedImage pinnedImage = mStagingArea.get(key); if (pinnedImage != null) { pinnedImage.close(); FLog.v(TAG, ""Found image for %s in staging area"", key.toString()); mImageCacheStatsTracker.onStagingAreaHit(); return Task.forResult(true); } } Task<Boolean> masterTask = containsAsync(keys.get(0)); if (keys.size() == 1) { return masterTask; } for (final CacheKey key : keys.subList(1, keys.size())) { masterTask = masterTask.continueWithTask( new Continuation<Boolean, Task<Boolean>>() { @Override public Task<Boolean> then(Task<Boolean> previousTask) throws Exception { if (previousTask.isCancelled() || previousTask.getResult()) { return previousTask; } return containsAsync(key); } }, mReadExecutor); } return masterTask; }"	"  public Task<Boolean> contains(final CacheKey key) {
    Preconditions.checkNotNull(key);

    final EncodedImage pinnedImage = mStagingArea.get(key);
    if (pinnedImage != null) {
      pinnedImage.close();
      FLog.v(TAG, ""Found image for %s in staging area"", key.toString());
      mImageCacheStatsTracker.onStagingAreaHit();
      return Task.forResult(true);
    }

    try {
      return Task.call(
          new Callable<Boolean>() {
            @Override
            public Boolean call() throws Exception {
              EncodedImage result = mStagingArea.get(key);
              if (result != null) {
                result.close();
                FLog.v(TAG, ""Found image for %s in staging area"", key.toString());
                mImageCacheStatsTracker.onStagingAreaHit();
                return true;
              } else {
                FLog.v(TAG, ""Did not find image for %s in staging area"", key.toString());
                mImageCacheStatsTracker.onStagingAreaMiss();
                try {
                  return mFileCache.hasKey(key);
                } catch (Exception exception) {
                  return false;
                }
              }
            }
          },
          mReadExecutor);
    } catch (Exception exception) {
      // Log failure
      // TODO: 3697790
      FLog.w(
          TAG,
          exception,
          ""Failed to schedule disk-cache read for %s"",
          key.toString());
      return Task.forError(exception);
    }
  }
"	@param keys	@param key	1	0	13	33	196
public static Area getClickbox(@Nonnull Client client, Model model, int orientation, int localX, int localY) { if (model == null) { return null; } List<Triangle> triangles = model.getTriangles().stream() .map(triangle -> triangle.rotate(orientation)) .collect(Collectors.toList()); List<Vertex> vertices = model.getVertices().stream() .map(v -> v.rotate(orientation)) .collect(Collectors.toList()); Area clickBox = get2DGeometry(client, triangles, orientation, localX, localY); Area visibleAABB = getAABB(client, vertices, orientation, localX, localY); if (visibleAABB == null || clickBox == null) { return null; } clickBox.intersect(visibleAABB); return clickBox; }	"	public static Area getClickbox(@Nonnull Client client, Model model, int orientation, int tileX, int tileY)
	{
		if (model == null)
		{
			return null;
		}

		List<Triangle> triangles = model.getTriangles().stream()
			.map(triangle -> triangle.rotate(orientation))
			.collect(Collectors.toList());

		List<Vertex> vertices = model.getVertices().stream()
				.map(v -> v.rotate(orientation))
				.collect(Collectors.toList());

		Area clickBox = get2DGeometry(client, triangles, orientation, tileX, tileY);
		Area visibleAABB = getAABB(client, vertices, orientation, tileX, tileY);

		if (visibleAABB == null || clickBox == null)
		{
			return null;
		}

		clickBox.intersect(visibleAABB);
		return clickBox;
	}
"	@param localX the x-axis coordinate of the tile	@param tileX the x-axis coordinate of the tile	1	0	9	27	143
private boolean isCached(Serializable collectionKey, CollectionPersister persister) { if ( persister.hasCache() ) { CacheKey cacheKey = context.getSession().generateCacheKey( collectionKey, persister.getKeyType(), persister.getRole() ); return persister.getCacheAccessStrategy().get( cacheKey, context.getSession().getTimestamp() ) != null; } return false; }	"	private boolean isCached(EntityKey entityKey, EntityPersister persister) {
		if ( persister.hasCache() ) {
			CacheKey key = context.getSession().generateCacheKey(
					entityKey.getIdentifier(),
					persister.getIdentifierType(),
					entityKey.getEntityName()
			);
			return persister.getCacheAccessStrategy().get( key, context.getSession().getTimestamp() ) != null;
		}
		return false;
	}
"	@param id A key that must be included in the batch fetch	@param id The identifier of the entity currently demanding load.	1	0	10	12	65
private ColumnState buildPrimitive(ContainerState parent, ColumnMetadata columnSchema) { final ValueVector vector; if (parent.projection().isProjected(columnSchema) || allowCreation(parent)) { // Create the vector for the column. vector = parent.vectorCache().vectorFor(columnSchema.schema()); // In permissive mode, the mode or precision of the vector may differ // from that requested. Update the schema to match. if (parent.vectorCache().isPermissive() && !vector.getField().isEquivalent(columnSchema.schema())) { columnSchema = ((PrimitiveColumnMetadata) columnSchema).mergeWith(vector.getField()); } } else { // Column is not projected. No materialized backing for the column. vector = null; } // Create the writer. final AbstractObjectWriter colWriter = ColumnWriterFactory.buildColumnWriter(columnSchema, vector); // Build the vector state which manages the vector. VectorState vectorState; if (vector == null) { vectorState = new NullVectorState(); } else if (columnSchema.isArray()) { vectorState = new RepeatedVectorState(colWriter.array(), (RepeatedValueVector) vector); } else if (columnSchema.isNullable()) { vectorState = new NullableVectorState( colWriter, (NullableVector) vector); } else { vectorState = SimpleVectorState.vectorState(columnSchema, colWriter.events(), vector); } // Create the column state which binds the vector and writer together. return new PrimitiveColumnState(parent.loader(), colWriter, vectorState); }	"  private ColumnState buildPrimitive(ContainerState parent, ColumnReadProjection colProj) {
    ColumnMetadata columnSchema = colProj.providedSchema();

    ValueVector vector;
    if (!colProj.isProjected() && !allowCreation(parent)) {

      // Column is not projected. No materialized backing for the column.

      vector = null;
    } else {

      // Create the vector for the column.

      vector = parent.vectorCache().addOrGet(columnSchema.schema());

      // In permissive mode, the mode or precision of the vector may differ
      // from that requested. Update the schema to match.

      if (parent.vectorCache().isPermissive() && ! vector.getField().isEquivalent(columnSchema.schema())) {
        columnSchema = ((PrimitiveColumnMetadata) columnSchema).mergeWith(vector.getField());
      }
    }

    // Create the writer.

    final AbstractObjectWriter colWriter = ColumnWriterFactory.buildColumnWriter(
        columnSchema, colProj.conversionFactory(), vector);

    // Build the vector state which manages the vector.

    VectorState vectorState;
    if (vector == null) {
      vectorState = new NullVectorState();
    } else if (columnSchema.isArray()) {
      vectorState = new RepeatedVectorState(colWriter.array(), (RepeatedValueVector) vector);
    } else if (columnSchema.isNullable()) {
      vectorState = new NullableVectorState(
          colWriter, (NullableVector) vector);
    } else {
      vectorState = SimpleVectorState.vectorState(columnSchema,
            colWriter.events(), vector);
    }

    // Create the column state which binds the vector and writer together.

    return new PrimitiveColumnState(parent.loader(), colWriter,
        vectorState);
  }
"	@param colProj implied projection type for the column	@param colProj implied projection type for the column	0	1	11	41	273
"public String toDefaultValueWithParam(String name, Schema schema) { return "" = data."" + name + "";""; }"	"    public String toDefaultValueWithParam(String name, Property p) {
        return "" = data."" + name + "";"";
    }
"	@param schema Property schema	@param p Swagger property object	1	0	6	4	23
"protected boolean isDisconnectRequest(AtmosphereRequest request) { if (""GET"".equals(request.getMethod())) { if (request.getParameterMap().containsKey(""disconnect"")) { return true; } } else if (""POST"".equals(request.getMethod())) { try { String data = decodePostData(request.getContentType(), extractString(request.getReader())); request.setAttribute(POST_MESSAGE_RECEIVED, data); if (data != null && data.length() > 0) { List<SocketIOPacketImpl> list = SocketIOPacketImpl.parse(data); if (!list.isEmpty()) { if (SocketIOPacketImpl.PacketType.DISCONNECT.equals(list.get(0).getFrameType())) { return true; } } } } catch (IOException e) { e.printStackTrace(); } } return false; }"	"    protected boolean isDisconnectRequest(HttpServletRequest request) {

        if (""GET"".equals(request.getMethod())) {

            if (request.getParameterMap().containsKey(""disconnect"")) {
                return true;
            }

        } else if (""POST"".equals(request.getMethod())) {
            try {
                String data = decodePostData(request.getContentType(), extractString(request.getReader()));
                request.setAttribute(POST_MESSAGE_RECEIVED, data);
                if (data != null && data.length() > 0) {
                    List<SocketIOPacketImpl> list = SocketIOPacketImpl.parse(data);
                    if (!list.isEmpty()) {
                        if (SocketIOPacketImpl.PacketType.DISCONNECT.equals(list.get(0).getFrameType())) {
                            return true;
                        }
                    }

                }
            } catch (IOException e) {
                e.printStackTrace();
            }

        }

        return false;
    }
"	@param request	@param request	0	1	14	30	158
"public TableSchema create(String schemaPrefix, String envelopSchemaName, Table table, ColumnNameFilter filter, ColumnMappers mappers, CustomKeyMapper keysMapper) { if (schemaPrefix == null) { schemaPrefix = """"; } // Build the schemas ... final TableId tableId = table.id(); final String tableIdStr = tableSchemaName(tableId); final String schemaNamePrefix = schemaPrefix + tableIdStr; LOGGER.debug(""Mapping table '{}' to schemas under '{}'"", tableId, schemaNamePrefix); SchemaBuilder valSchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + "".Value"")); SchemaBuilder keySchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + "".Key"")); AtomicBoolean hasPrimaryKey = new AtomicBoolean(false); Key tableKey = new Key.Builder(table).customKeyMapper(keysMapper).build(); tableKey.keyColumns().forEach(column -> { addField(keySchemaBuilder, column, null); hasPrimaryKey.set(true); }); table.columns() .stream() .filter(column -> filter == null || filter.matches(tableId.catalog(), tableId.schema(), tableId.table(), column.name())) .forEach(column -> { ColumnMapper mapper = mappers == null ? null : mappers.mapperFor(tableId, column); addField(valSchemaBuilder, column, mapper); }); Schema valSchema = valSchemaBuilder.optional().build(); Schema keySchema = hasPrimaryKey.get() ? keySchemaBuilder.build() : null; if (LOGGER.isDebugEnabled()) { LOGGER.debug(""Mapped primary key for table '{}' to schema: {}"", tableId, SchemaUtil.asDetailedString(keySchema)); LOGGER.debug(""Mapped columns for table '{}' to schema: {}"", tableId, SchemaUtil.asDetailedString(valSchema)); } Envelope envelope = Envelope.defineSchema() .withName(schemaNameAdjuster.adjust(envelopSchemaName)) .withRecord(valSchema) .withSource(sourceInfoSchema) .build(); // Create the generators ... Function<Object[], Object> keyGenerator = createKeyGenerator(keySchema, tableId, tableKey.keyColumns()); Function<Object[], Struct> valueGenerator = createValueGenerator(valSchema, tableId, table.columns(), filter, mappers); // And the table schema ... return new TableSchema(tableId, keySchema, keyGenerator, envelope, valSchema, valueGenerator); }"	"    public TableSchema create(String schemaPrefix, String envelopSchemaName, Table table, ColumnNameFilter filter, ColumnMappers mappers) {
        if (schemaPrefix == null) {
            schemaPrefix = """";
        }

        // Build the schemas ...
        final TableId tableId = table.id();
        final String tableIdStr = tableSchemaName(tableId);
        final String schemaNamePrefix = schemaPrefix + tableIdStr;
        LOGGER.debug(""Mapping table '{}' to schemas under '{}'"", tableId, schemaNamePrefix);
        SchemaBuilder valSchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + "".Value""));
        SchemaBuilder keySchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + "".Key""));
        AtomicBoolean hasPrimaryKey = new AtomicBoolean(false);
        table.columns().forEach(column -> {
            if (table.isPrimaryKeyColumn(column.name())) {
                // The column is part of the primary key, so ALWAYS add it to the PK schema ...
                addField(keySchemaBuilder, column, null);
                hasPrimaryKey.set(true);
            }
            if (filter == null || filter.matches(tableId.catalog(), tableId.schema(), tableId.table(), column.name())) {
                // Add the column to the value schema only if the column has not been filtered ...
                ColumnMapper mapper = mappers == null ? null : mappers.mapperFor(tableId, column);
                addField(valSchemaBuilder, column, mapper);
            }
        });
        Schema valSchema = valSchemaBuilder.optional().build();
        Schema keySchema = hasPrimaryKey.get() ? keySchemaBuilder.build() : null;

        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug(""Mapped primary key for table '{}' to schema: {}"", tableId, SchemaUtil.asDetailedString(keySchema));
            LOGGER.debug(""Mapped columns for table '{}' to schema: {}"", tableId, SchemaUtil.asDetailedString(valSchema));
        }

        Envelope envelope = Envelope.defineSchema()
                .withName(schemaNameAdjuster.adjust(envelopSchemaName))
                .withRecord(valSchema)
                .withSource(sourceInfoSchema)
                .build();


        // Create the generators ...
        Function<Object[], Object> keyGenerator = createKeyGenerator(keySchema, tableId, table.primaryKeyColumns());
        Function<Object[], Struct> valueGenerator = createValueGenerator(valSchema, tableId, table.columns(), filter, mappers);

        // And the table schema ...
        return new TableSchema(tableId, keySchema, keyGenerator, envelope, valSchema, valueGenerator);
    }
"	@param schemaPrefix the prefix added to the table identifier to construct the schema names; may be null if there is no prefix	@param schemaPrefix the prefix added to the table identifier to construct the schema names; may be null if there is no prefix	0	1	11	51	433
protected boolean processExtensionPopupChildren(PopupMenuUtils.PopupMenuInvokerWrapper invokerWrapper) { boolean childEnable = false; for (int index = 0; index < this.getItemCount(); index++) { JMenuItem item = this.getItem(index); if (isEnableForComponent(item, invokerWrapper)) { childEnable = true; } } return childEnable; }	"	protected boolean processExtensionPopupChildren(Component invoker) {
		boolean childEnable = false;
		for (int index = 0; index < this.getItemCount(); index++) {
			JMenuItem item = this.getItem(index);
			if (item instanceof PopupMenuHistoryReference) {
				PopupMenuHistoryReference itemRef=(PopupMenuHistoryReference) item;
				if (itemRef.isEnableForComponent(invoker)) {
					childEnable = true;
				}
			}
		}
		return childEnable;
	}
"	@param invokerWrapper the wrapped invoker	@param invoker the component of the invoker	1	0	9	11	57
public Object execute(String commandName, Map<String, ?> parameters) { Response response; if (parameters == null || parameters.size() == 0) { response = driver.execute(commandName); } else { response = driver.execute(commandName, parameters); } return response.getValue(); }	"  public Object execute(DriverCommand commandName, Map<String, ?> parameters) {
    Response response;

    if (parameters == null || parameters.size() == 0) {
      response = driver.execute(commandName);
    } else {
      response = driver.execute(commandName, parameters);
    }

    return response.getValue();
  }
"	@param parameters The parameters to execute that command with	@param parameters The parameters to execute that command with	0	1	8	12	57
public Client call123testSpecialTags(Client body, Map<String, Object> params) throws IOException { HttpResponse response = call123testSpecialTagsForHttpResponse(body, params); TypeReference typeRef = new TypeReference<Client>() {}; return apiClient.getObjectMapper().readValue(response.getContent(), typeRef); }	"    public Client call123testSpecialTags(Client client, Map<String, Object> params) throws IOException {
        HttpResponse response = call123testSpecialTagsForHttpResponse(client, params);
        TypeReference typeRef = new TypeReference<Client>() {};
        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);
    }
"	@param body client model	@param client client model	1	0	8	6	51
public Configuration setCacheConcurrencyStrategy(String entityName, String concurrencyStrategy) { setCacheConcurrencyStrategy( entityName, concurrencyStrategy, entityName ); return this; }	"	public Configuration setCacheConcurrencyStrategy(String clazz, String concurrencyStrategy)
			throws MappingException {
		setCacheConcurrencyStrategy( clazz, concurrencyStrategy, clazz );
		return this;
	}
"	@param entityName The name of the entity to which we shoudl associate these cache settings	@param clazz	1	0	5	5	24
"public void createUsersWithArrayInput (java.util.List<User> body) throws ApiException { Object postBody = body; // create path and map variables String path = ""/user/createWithArray"".replaceAll(""\\{format\\}"",""json""); // query params java.util.List<Pair> queryParams = new java.util.ArrayList<Pair>(); java.util.Map<String, String> headerParams = new java.util.HashMap<String, String>(); java.util.Map<String, Object> formParams = new java.util.HashMap<String, Object>(); final String[] accepts = { ""application/json"", ""application/xml"" }; final String accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final String contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; apiClient.invokeAPI(path, ""POST"", queryParams, postBody, headerParams, formParams, accept, contentType, authNames, null); }"	"  public void createUsersWithArrayInput (List<User> body) throws ApiException {
    Object postBody = body;
    
    // create path and map variables
    String path = ""/user/createWithArray"".replaceAll(""\\{format\\}"",""json"");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    Map<String, String> headerParams = new HashMap<String, String>();
    Map<String, Object> formParams = new HashMap<String, Object>();

    

    

    

    final String[] accepts = {
      ""application/json"", ""application/xml""
    };
    final String accept = apiClient.selectHeaderAccept(accepts);

    final String[] contentTypes = {
      
    };
    final String contentType = apiClient.selectHeaderContentType(contentTypes);

    String[] authNames = new String[] {  };

    
    apiClient.invokeAPI(path, ""POST"", queryParams, postBody, headerParams, formParams, accept, contentType, authNames, null);
    
  }
"	@param body List of user object	@param body List of user object	0	1	10	34	183
"public Client testClassname(Client client) throws ApiException { Object localVarPostBody = client; // verify the required parameter 'client' is set if (client == null) { throw new ApiException(400, ""Missing the required parameter 'client' when calling testClassname""); } // create path and map variables String localVarPath = ""/fake_classname_test""; // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { ""application/json"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { ""application/json"" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { ""api_key_query"" }; GenericType<Client> localVarReturnType = new GenericType<Client>() {}; return apiClient.invokeAPI(localVarPath, ""PATCH"", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	"  public Client testClassname(Client body) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, ""Missing the required parameter 'body' when calling testClassname"");
    }
    
    // create path and map variables
    String localVarPath = ""/fake_classname_test"";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    final String[] localVarAccepts = {
      ""application/json""
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      ""application/json""
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { ""api_key_query"" };

    GenericType<Client> localVarReturnType = new GenericType<Client>() {};
    return apiClient.invokeAPI(localVarPath, ""PATCH"", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);
      }
"	@param client client model (required)	@param body client model (required)	1	0	8	36	213
protected Socket createSocket(SocketFactory socketFactory, URI remoteLocation, URI localLocation) throws IOException, UnknownHostException { String host = resolveHostName(remoteLocation.getHost()); SocketAddress sockAddress = new InetSocketAddress(host, remoteLocation.getPort()); SocketAddress localAddress = new InetSocketAddress(InetAddress.getByName(localLocation.getHost()), localLocation.getPort()); Socket sock = socketFactory.createSocket(); initialiseSocket(sock); sock.bind(localAddress); sock.connect(sockAddress); return sock; }	"    protected Socket createSocket(URI remoteLocation, URI localLocation) throws IOException, UnknownHostException {
        String host = resolveHostName(remoteLocation.getHost());
        SocketAddress sockAddress = new InetSocketAddress(host, remoteLocation.getPort());
        SocketAddress localAddress = new InetSocketAddress(InetAddress.getByName(localLocation.getHost()), localLocation.getPort());
        Socket sock = new Socket();
        initialiseSocket(sock);
        sock.bind(localAddress);
        sock.connect(sockAddress);
        return sock;
    }
"	@param localLocation	@param localLocation	0	1	7	11	89
public static Annotation fromProto(CoreNLPProtos.Document proto) { // Set text Annotation ann = new Annotation(proto.getText()); // Add tokens List<CoreLabel> tokens = new ArrayList<CoreLabel>(proto.getTokenCount()); for (CoreNLPProtos.Token token : proto.getTokenList()) { CoreLabel coreLabel = fromProto(token); // Set docid if (proto.hasDocID()) { coreLabel.setDocID(proto.getDocID()); } tokens.add(coreLabel); } if (!tokens.isEmpty()) { ann.set(TokensAnnotation.class, tokens); } // Add sentences List<CoreMap> sentences = new ArrayList<CoreMap>(proto.getSentenceCount()); for (int sentIndex = 0; sentIndex < proto.getSentenceCount(); ++sentIndex) { CoreNLPProtos.Sentence sentence = proto.getSentence(sentIndex); CoreMap map = fromProto(sentence); if (!tokens.isEmpty() && sentence.hasTokenOffsetBegin() && sentence.hasTokenOffsetEnd()) { // Set tokens for sentence map.set(TokensAnnotation.class, tokens.subList(sentence.getTokenOffsetBegin(), sentence.getTokenOffsetEnd())); // Set sentence index + token index + paragraph index for (int i = sentence.getTokenOffsetBegin(); i < sentence.getTokenOffsetEnd(); ++i) { tokens.get(i).setSentIndex(sentIndex); tokens.get(i).setIndex(i - sentence.getTokenOffsetBegin() + 1); if (sentence.hasParagraph()) { tokens.get(i).set(ParagraphAnnotation.class, sentence.getParagraph()); } } // Set text map.set(TextAnnotation.class, proto.getText().substring(sentence.getCharacterOffsetBegin(), sentence.getCharacterOffsetEnd())); } // End iteration sentences.add(map); } if (!sentences.isEmpty()) { ann.set(SentencesAnnotation.class, sentences); } // Set DocID String docid = null; if (proto.hasDocID()) { docid = proto.getDocID(); ann.set(DocIDAnnotation.class, docid); } // Set coref chain Map<Integer, CorefChain> corefChains = new HashMap<Integer, CorefChain>(); for (CoreNLPProtos.CorefChain chainProto : proto.getCorefChainList()) { CorefChain chain = fromProto(chainProto, ann); corefChains.put(chain.getChainID(), chain); } if (!corefChains.isEmpty()) { ann.set(CorefChainAnnotation.class, corefChains); } // Set dependency graphs // We need to wait until here, since this is the first time we see tokens for (int i = 0; i < proto.getSentenceCount(); ++i) { CoreNLPProtos.Sentence sentence = proto.getSentenceList().get(i); CoreMap map = sentences.get(i); List<CoreLabel> sentenceTokens = map.get(TokensAnnotation.class); if (sentence.hasBasicDependencies()) { map.set(BasicDependenciesAnnotation.class, fromProto(sentence.getBasicDependencies(), sentenceTokens, docid)); } if (sentence.hasCollapsedDependencies()) { map.set(CollapsedDependenciesAnnotation.class, fromProto(sentence.getCollapsedDependencies(), sentenceTokens, docid)); } if (sentence.hasCollapsedCCProcessedDependencies()) { map.set(CollapsedCCProcessedDependenciesAnnotation.class, fromProto(sentence.getCollapsedCCProcessedDependencies(), sentenceTokens, docid)); } } // Redo some light annotation for (CoreMap sentence : sentences) { if (sentence.containsKey(TokensAnnotation.class)) { sentence.set(NumerizedTokensAnnotation.class, NumberNormalizer.findAndMergeNumbers(sentence)); } } // Return return ann; }	"  public static Annotation fromProto(CoreMapProtos.Document proto) {
    // Set text
    Annotation ann = new Annotation(proto.getText());

    // Add tokens
    List<CoreLabel> tokens = new ArrayList<CoreLabel>(proto.getTokenCount());
    for (CoreMapProtos.CoreLabel token : proto.getTokenList()) {
      CoreLabel coreLabel = fromProto(token);
      // Set docid
      if (proto.hasDocID()) { coreLabel.setDocID(proto.getDocID()); }
      tokens.add(coreLabel);
    }
    if (!tokens.isEmpty()) { ann.set(TokensAnnotation.class, tokens); }

    // Add sentences
    List<CoreMap> sentences = new ArrayList<CoreMap>(proto.getSentenceCount());
    for (int sentIndex = 0; sentIndex < proto.getSentenceCount(); ++sentIndex) {
      CoreMapProtos.Sentence sentence = proto.getSentence(sentIndex);
      CoreMap map = fromProto(sentence);
      if (!tokens.isEmpty() && sentence.hasTokenOffsetBegin() && sentence.hasTokenOffsetEnd()) {
        // Set tokens for sentence
        map.set(TokensAnnotation.class, tokens.subList(sentence.getTokenOffsetBegin(), sentence.getTokenOffsetEnd()));
        // Set sentence index + token index + paragraph index
        for (int i = sentence.getTokenOffsetBegin(); i < sentence.getTokenOffsetEnd(); ++i) {
          tokens.get(i).setSentIndex(sentIndex);
          tokens.get(i).setIndex(i - sentence.getTokenOffsetBegin() + 1);
          if (sentence.hasParagraph()) { tokens.get(i).set(ParagraphAnnotation.class, sentence.getParagraph()); }
        }
        // Set text
        map.set(TextAnnotation.class, proto.getText().substring(sentence.getCharacterOffsetBegin(), sentence.getCharacterOffsetEnd()));
      }
      // End iteration
      sentences.add(map);
    }
    if (!sentences.isEmpty()) { ann.set(SentencesAnnotation.class, sentences); }

    // Set DocID
    String docid = null;
    if (proto.hasDocID()) {
      docid = proto.getDocID();
      ann.set(DocIDAnnotation.class, docid);
    }

    // Set coref chain
    Map<Integer, CorefChain> corefChains = new HashMap<Integer, CorefChain>();
    for (CoreMapProtos.CorefChain chainProto : proto.getCorefChainList()) {
      CorefChain chain = fromProto(chainProto, ann);
      corefChains.put(chain.getChainID(), chain);
    }
    if (!corefChains.isEmpty()) { ann.set(CorefChainAnnotation.class, corefChains); }

    // Set dependency graphs
    // We need to wait until here, since this is the first time we see tokens
    for (int i = 0; i < proto.getSentenceCount(); ++i) {
      CoreMapProtos.Sentence sentence = proto.getSentenceList().get(i);
      CoreMap map = sentences.get(i);
      List<CoreLabel> sentenceTokens = map.get(TokensAnnotation.class);
      if (sentence.hasBasicDependencies()) {
        map.set(BasicDependenciesAnnotation.class, fromProto(sentence.getBasicDependencies(), sentenceTokens, docid));
      }
      if (sentence.hasCollapsedDependencies()) {
        map.set(CollapsedDependenciesAnnotation.class, fromProto(sentence.getCollapsedDependencies(), sentenceTokens, docid));
      }
      if (sentence.hasCollapsedCCProcessedDependencies()) {
        map.set(CollapsedCCProcessedDependenciesAnnotation.class, fromProto(sentence.getCollapsedCCProcessedDependencies(), sentenceTokens, docid));
      }
    }

    // Redo some light annotation
    for (CoreMap sentence : sentences) {
      if (sentence.containsKey(TokensAnnotation.class)) {
        sentence.set(NumerizedTokensAnnotation.class, NumberNormalizer.findAndMergeNumbers(sentence));
      }
    }

    // Return
    return ann;
  }
"	@param proto The protocol buffer to read the document from.	@param proto The protocol buffer to read the document from.	0	1	15	79	653
"public List<CodegenSecurity> fromSecurity(Map<String, SecurityScheme> securitySchemeMap) { if (securitySchemeMap == null) { return Collections.emptyList(); } List<CodegenSecurity> codegenSecurities = new ArrayList<CodegenSecurity>(securitySchemeMap.size()); for (String key : securitySchemeMap.keySet()) { final SecurityScheme securityScheme = securitySchemeMap.get(key); CodegenSecurity cs = CodegenModelFactory.newInstance(CodegenModelType.SECURITY); cs.name = key; cs.type = securityScheme.getType().toString(); cs.isCode = cs.isPassword = cs.isApplication = cs.isImplicit = false; if (SecurityScheme.Type.APIKEY.equals(securityScheme.getType())) { cs.isBasic = cs.isOAuth = false; cs.isApiKey = true; cs.keyParamName = securityScheme.getName(); cs.isKeyInHeader = securityScheme.getIn() == SecurityScheme.In.HEADER; cs.isKeyInQuery = !cs.isKeyInHeader; } else if (SecurityScheme.Type.HTTP.equals(securityScheme.getType())) { cs.isKeyInHeader = cs.isKeyInQuery = cs.isApiKey = cs.isOAuth = false; cs.isBasic = true; } else if (SecurityScheme.Type.OAUTH2.equals(securityScheme.getType())) { cs.isKeyInHeader = cs.isKeyInQuery = cs.isApiKey = cs.isBasic = false; cs.isOAuth = true; final OAuthFlows flows = securityScheme.getFlows(); if (securityScheme.getFlows() == null) { throw new RuntimeException(""missing oauth flow in "" + cs.name); } if (flows.getPassword() != null) { setOauth2Info(cs, flows.getPassword()); cs.isPassword = true; cs.flow = ""password""; } else if (flows.getImplicit() != null) { setOauth2Info(cs, flows.getImplicit()); cs.isImplicit = true; cs.flow = ""implicit""; } else if (flows.getClientCredentials() != null) { setOauth2Info(cs, flows.getClientCredentials()); cs.isApplication = true; cs.flow = ""application""; } else if (flows.getAuthorizationCode() != null) { setOauth2Info(cs, flows.getAuthorizationCode()); cs.isCode = true; cs.flow = ""accessCode""; } else { throw new RuntimeException(""Could not identify any oauth2 flow in "" + cs.name); } } codegenSecurities.add(cs); } // sort auth methods to maintain the same order Collections.sort(codegenSecurities, new Comparator<CodegenSecurity>() { @Override public int compare(CodegenSecurity one, CodegenSecurity another) { return ObjectUtils.compare(one.name, another.name); } }); // set 'hasMore' Iterator<CodegenSecurity> it = codegenSecurities.iterator(); while (it.hasNext()) { final CodegenSecurity security = it.next(); security.hasMore = it.hasNext(); } return codegenSecurities; }"	"    public List<CodegenSecurity> fromSecurity(Map<String, SecuritySchemeDefinition> schemes) {
        if (schemes == null) {
            return Collections.emptyList();
        }

        List<CodegenSecurity> secs = new ArrayList<CodegenSecurity>(schemes.size());
        for (Iterator<Map.Entry<String, SecuritySchemeDefinition>> it = schemes.entrySet().iterator(); it.hasNext(); ) {
            final Map.Entry<String, SecuritySchemeDefinition> entry = it.next();
            final SecuritySchemeDefinition schemeDefinition = entry.getValue();

            CodegenSecurity sec = CodegenModelFactory.newInstance(CodegenModelType.SECURITY);
            sec.name = entry.getKey();
            sec.type = schemeDefinition.getType();
            sec.isCode = sec.isPassword = sec.isApplication = sec.isImplicit = false;
            sec.vendorExtensions = schemeDefinition.getVendorExtensions();

            if (schemeDefinition instanceof ApiKeyAuthDefinition) {
                final ApiKeyAuthDefinition apiKeyDefinition = (ApiKeyAuthDefinition) schemeDefinition;
                sec.isBasic = sec.isOAuth = false;
                sec.isApiKey = true;
                sec.keyParamName = apiKeyDefinition.getName();
                sec.isKeyInHeader = apiKeyDefinition.getIn() == In.HEADER;
                sec.isKeyInQuery = !sec.isKeyInHeader;
            } else if(schemeDefinition instanceof BasicAuthDefinition) {
                sec.isKeyInHeader = sec.isKeyInQuery = sec.isApiKey = sec.isOAuth = false;
                sec.isBasic = true;
            } else {
                final OAuth2Definition oauth2Definition = (OAuth2Definition) schemeDefinition;
                sec.isKeyInHeader = sec.isKeyInQuery = sec.isApiKey = sec.isBasic = false;
                sec.isOAuth = true;
                sec.flow = oauth2Definition.getFlow();
                if (sec.flow == null) {
                    throw new RuntimeException(""missing oauth flow in "" + sec.name);
                }
                switch(sec.flow) {
                    case ""accessCode"":
                        sec.isCode = true;
                        break;
                    case ""password"":
                        sec.isPassword = true;
                        break;
                    case ""application"":
                        sec.isApplication = true;
                        break;
                    case ""implicit"":
                        sec.isImplicit = true;
                        break;
                    default:
                        throw new RuntimeException(""unknown oauth flow: "" + sec.flow);
                }
                sec.authorizationUrl = oauth2Definition.getAuthorizationUrl();
                sec.tokenUrl = oauth2Definition.getTokenUrl();
                if (oauth2Definition.getScopes() != null) {
                    List<Map<String, Object>> scopes = new ArrayList<Map<String, Object>>();
                    int count = 0, numScopes = oauth2Definition.getScopes().size();
                    for(Map.Entry<String, String> scopeEntry : oauth2Definition.getScopes().entrySet()) {
                        Map<String, Object> scope = new HashMap<String, Object>();
                        scope.put(""scope"", scopeEntry.getKey());
                        scope.put(""description"", escapeText(scopeEntry.getValue()));

                        count += 1;
                        if (count < numScopes) {
                            scope.put(""hasMore"", ""true"");
                        } else {
                            scope.put(""hasMore"", null);
                        }

                        scopes.add(scope);
                    }
                    sec.scopes = scopes;
                }
            }

            secs.add(sec);
        }

        // sort auth methods to maintain the same order
        Collections.sort(secs, new Comparator<CodegenSecurity>() {
            @Override
            public int compare(CodegenSecurity one, CodegenSecurity another) {
                return ObjectUtils.compare(one.name, another.name);
            }
        });
        // set 'hasMore'
        Iterator<CodegenSecurity> it = secs.iterator();
        while (it.hasNext()) {
            final CodegenSecurity security = it.next();
            security.hasMore = it.hasNext();
        }

        return secs;
    }
"	@param securitySchemeMap a map of OAS SecuritySchemeDefinition object	@param schemes a map of Swagger SecuritySchemeDefinition object	1	0	17	71	478
"private StringBuilder appendIfNotNull(StringBuilder source, String addStr, String delimiter) { if (addStr != null) { if (addStr.length() == 0) { delimiter = """"; } return source.append(addStr).append(delimiter); } return source; }"	"    private String appendIfNotNull(String sourceStr, String appendStr, String delimiter) {
        if (appendStr != null) {
            if (appendStr.length() == 0) {
                delimiter = """";
            }
            sourceStr += delimiter + appendStr;
        }
        return sourceStr;
    }
"	@param addStrStr The String to append	@param appendStr The String to append	1	0	9	12	51
public static ParquetTableMetadataBase readBlockMeta(FileSystem fs, String path, MetadataContext metaContext, ParquetFormatConfig formatConfig) throws IOException { Metadata metadata = new Metadata(fs, formatConfig); metadata.readBlockMeta(path, false, metaContext); return metadata.parquetTableMetadata; }	"  public static ParquetTableMetadataBase readBlockMeta(FileSystem fs, String path, MetadataContext metaContext) throws IOException {
    Metadata metadata = new Metadata(fs);
    metadata.readBlockMeta(path, false, metaContext);
    return metadata.parquetTableMetadata;
  }
"	@param fs	@param fs	0	1	6	6	45
"public Action cancelled(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException { synchronized (req) { AtmosphereResourceImpl r = null; try { if (trackActiveRequest) { long l = (Long) req.getAttribute(MAX_INACTIVE); if (l == -1) { // The closedDetector closed the connection. return timedoutAction; } req.setAttribute(MAX_INACTIVE, (long) -1); } logger.debug(""Cancelling the connection for request {}"", req); r = (AtmosphereResourceImpl) req.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE); if (r != null) { r.getAtmosphereResourceEvent().setCancelled(true); invokeAtmosphereHandler(r); try { r.getResponse().sendError(503); r.getResponse().getOutputStream().close(); } catch (Throwable t) { try { r.getResponse().getWriter().close(); } catch (Throwable t2) { } } } } catch (Throwable ex) { // Something wrong happenned, ignore the exception logger.debug(""failed to cancel resource: "" + r, ex); } finally { try { if (r != null) { r.notifyListeners(); r.setIsInScope(false); r.cancel(); } } catch (Throwable t) { logger.trace(""cancel"", t); } finally { if (r != null) { destroyResource(r); } } } } return cancelledAction; }"	"    public Action cancelled(HttpServletRequest req, HttpServletResponse res)
            throws IOException, ServletException {

        synchronized (req) {
            AtmosphereResourceImpl r = null;
            try {
                if (trackActiveRequest) {
                    long l = (Long) req.getAttribute(MAX_INACTIVE);
                    if (l == -1) {
                        // The closedDetector closed the connection.
                        return timedoutAction;
                    }
                    req.setAttribute(MAX_INACTIVE, (long) -1);
                }

                logger.debug(""Cancelling the connection for request {}"", req);

                r = (AtmosphereResourceImpl) req.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE);
                if (r != null) {
                    r.getAtmosphereResourceEvent().setCancelled(true);
                    invokeAtmosphereHandler(r);

                    try {
                        r.getResponse().sendError(503);
                        r.getResponse().getOutputStream().close();
                    } catch (Throwable t) {
                        try {
                            r.getResponse().getWriter().close();
                        } catch (Throwable t2) {
                        }
                    }
                }
            } catch (Throwable ex) {
                // Something wrong happenned, ignore the exception
                logger.debug(""failed to cancel resource: "" + r, ex);
            } finally {
                try {
                    if (r != null) {
                        r.notifyListeners();
                        r.setIsInScope(false);
                        r.cancel();
                    }
                } catch (Throwable t) {
                    logger.trace(""cancel"", t);
                } finally {
                    if (r != null) {
                        destroyResource(r);
                    }
                }
            }
        }

        return cancelledAction;
    }
"	@param req the  AtmosphereRequest	@param req the HttpServletRequest	1	0	12	55	274
public int recordObject(CollectionId id, Document object, Instant timestamp) throws InterruptedException { source.collectionEvent(replicaSetName, id); final Struct sourceValue = source.struct(); final Map<String, ?> offset = source.lastOffset(replicaSetName); String objId = idObjToJson(object); assert objId != null; return createRecords(sourceValue, offset, Operation.READ, objId, object, timestamp); }	"        public int recordObject(CollectionId id, Document object, long timestamp) throws InterruptedException {
            source.collectionEvent(replicaSetName, id);
            final Struct sourceValue = source.struct();
            final Map<String, ?> offset = source.lastOffset(replicaSetName);
            String objId = idObjToJson(object);
            assert objId != null;
            return createRecords(sourceValue, offset, Operation.READ, objId, object, timestamp);
        }
"	@param object the document; may not be null	@param object the document; may not be null	0	1	6	9	74
public static Connection generateProxy(LogicalConnectionImpl logicalConnection) { BorrowedConnectionProxy handler = new BorrowedConnectionProxy( logicalConnection ); return ( Connection ) Proxy.newProxyInstance( getProxyClassLoader(), PROXY_INTERFACES, handler ); }	"	public static Connection generateProxy(ConnectionManager connectionManager) {
		BorrowedConnectionProxy handler = new BorrowedConnectionProxy( connectionManager );
		return ( Connection ) Proxy.newProxyInstance(
				getProxyClassLoader(),
		        PROXY_INTERFACES,
		        handler
		);
	}
"	@param logicalConnection The logical connection to wrap with the connection proxy.	@param connectionManager The connection manager to wrap with the connection proxy.	1	0	6	9	34
public static final ExecutableElement elementFromUse(MethodInvocationTree node) { return (ExecutableElement)TreeInfo.symbol((JCTree)node.getMethodSelect()); }	"    public static final Element elementFromUse(ExpressionTree node) {
        return InternalUtils.symbol(node);
    }
"	@param node the method invocation	@param node the tree corresponding to a use of an element	1	0	7	5	27
"public void addPet (Pet pet) throws TimeoutException, ExecutionException, InterruptedException, ApiException { Object postBody = pet; // verify the required parameter 'pet' is set if (pet == null) { VolleyError error = new VolleyError(""Missing the required parameter 'pet' when calling addPet"", new ApiException(400, ""Missing the required parameter 'pet' when calling addPet"")); } // create path and map variables String path = ""/pet""; // query params List<Pair> queryParams = new ArrayList<Pair>(); // header params Map<String, String> headerParams = new HashMap<String, String>(); // form params Map<String, String> formParams = new HashMap<String, String>(); String[] contentTypes = { }; String contentType = contentTypes.length > 0 ? contentTypes[0] : ""application/json""; if (contentType.startsWith(""multipart/form-data"")) { // file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); HttpEntity httpEntity = localVarBuilder.build(); postBody = httpEntity; } else { // normal form params } String[] authNames = new String[] { ""petstore_auth"" }; try { String localVarResponse = apiInvoker.invokeAPI (basePath, path, ""POST"", queryParams, postBody, headerParams, formParams, contentType, authNames); if (localVarResponse != null) { return ; } else { return ; } } catch (ApiException ex) { throw ex; } catch (InterruptedException ex) { throw ex; } catch (ExecutionException ex) { if (ex.getCause() instanceof VolleyError) { VolleyError volleyError = (VolleyError)ex.getCause(); if (volleyError.networkResponse != null) { throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage()); } } throw ex; } catch (TimeoutException ex) { throw ex; } }"	"  public void addPet (Pet body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = body;
    // verify the required parameter 'body' is set
    if (body == null) {
      VolleyError error = new VolleyError(""Missing the required parameter 'body' when calling addPet"",
        new ApiException(400, ""Missing the required parameter 'body' when calling addPet""));
    }

    // create path and map variables
    String path = ""/pet"";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      ""application/json"",
      ""application/xml""
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : ""application/json"";

    if (contentType.startsWith(""multipart/form-data"")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { ""petstore_auth"" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, ""POST"", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return ;
      } else {
         return ;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }
"	@param pet Pet object that needs to be added to the store	@param body Pet object that needs to be added to the store	1	0	11	56	349
"public Lock acquirePutFromLoadLock(SharedSessionContractImplementor session, Object key, long txTimestamp) { if (trace) { log.tracef(""acquirePutFromLoadLock(%s#%s, %d)"", cache.getName(), key, txTimestamp); } boolean locked = false; PendingPutMap pending = pendingPuts.get( key ); for (;;) { try { if (pending != null) { locked = pending.acquireLock(100, TimeUnit.MILLISECONDS); if (locked) { boolean valid = false; try { if (pending.isRemoved()) { // this deals with a race between retrieving the map from cache vs. removing that // and locking the map pending.releaseLock(); locked = false; pending = null; if (trace) { log.tracef(""Record removed when waiting for the lock.""); } continue; } final PendingPut toCancel = pending.remove(session); if (toCancel != null) { valid = !toCancel.completed; toCancel.completed = true; } else { // this is a naked put if (pending.hasInvalidator()) { valid = false; } // we need this check since registerPendingPut (creating new pp) can get between invalidation // and naked put caused by the invalidation else if (pending.lastInvalidationEnd != Long.MIN_VALUE) { // if this transaction started afterQuery last invalidation we can continue valid = txTimestamp > pending.lastInvalidationEnd; } else { valid = txTimestamp > regionInvalidationTimestamp; } } return valid ? pending : null; } finally { if (!valid && pending != null) { pending.releaseLock(); locked = false; } if (trace) { log.tracef(""acquirePutFromLoadLock(%s#%s, %d) ended with %s, valid: %s"", cache.getName(), key, txTimestamp, pending, valid); } } } else { if (trace) { log.tracef(""acquirePutFromLoadLock(%s#%s, %d) failed to lock"", cache.getName(), key, txTimestamp); } // oops, we have leaked record for this owner, but we don't want to wait here return null; } } else { long regionInvalidationTimestamp = this.regionInvalidationTimestamp; if (txTimestamp <= regionInvalidationTimestamp) { if (trace) { log.tracef(""acquirePutFromLoadLock(%s#%s, %d) failed due to region invalidated at %d"", cache.getName(), key, txTimestamp, regionInvalidationTimestamp); } return null; } else { if (trace) { log.tracef(""Region invalidated at %d, this transaction started at %d"", regionInvalidationTimestamp, txTimestamp); } } PendingPut pendingPut = new PendingPut(session); pending = new PendingPutMap(pendingPut); PendingPutMap existing = pendingPuts.putIfAbsent(key, pending); if (existing != null) { pending = existing; } // continue in next loop with lock acquisition } } catch (Throwable t) { if (locked) { pending.releaseLock(); } if (t instanceof RuntimeException) { throw (RuntimeException) t; } else if (t instanceof Error) { throw (Error) t; } else { throw new RuntimeException(t); } } } }"	"	public Lock acquirePutFromLoadLock(SessionImplementor session, Object key, long txTimestamp) {
		if (trace) {
			log.tracef(""acquirePutFromLoadLock(%s#%s, %d)"", cache.getName(), key, txTimestamp);
		}
		boolean locked = false;

		PendingPutMap pending = pendingPuts.get( key );
		for (;;) {
			try {
				if (pending != null) {
					locked = pending.acquireLock(100, TimeUnit.MILLISECONDS);
					if (locked) {
						boolean valid = false;
						try {
							if (pending.isRemoved()) {
								// this deals with a race between retrieving the map from cache vs. removing that
								// and locking the map
								pending.releaseLock();
								locked = false;
								pending = null;
								if (trace) {
									log.tracef(""Record removed when waiting for the lock."");
								}
								continue;
							}
							final PendingPut toCancel = pending.remove(session);
							if (toCancel != null) {
								valid = !toCancel.completed;
								toCancel.completed = true;
							}
							else {
								// this is a naked put
								if (pending.hasInvalidator()) {
									valid = false;
								}
								// we need this check since registerPendingPut (creating new pp) can get between invalidation
								// and naked put caused by the invalidation
								else if (pending.lastInvalidationEnd != Long.MIN_VALUE) {
									// if this transaction started afterQuery last invalidation we can continue
									valid = txTimestamp > pending.lastInvalidationEnd;
								}
								else {
									valid = txTimestamp > regionInvalidationTimestamp;
								}
							}
							return valid ? pending : null;
						}
						finally {
							if (!valid && pending != null) {
								pending.releaseLock();
								locked = false;
							}
							if (trace) {
								log.tracef(""acquirePutFromLoadLock(%s#%s, %d) ended with %s, valid: %s"", cache.getName(), key, txTimestamp, pending, valid);
							}
						}
					}
					else {
						if (trace) {
							log.tracef(""acquirePutFromLoadLock(%s#%s, %d) failed to lock"", cache.getName(), key, txTimestamp);
						}
						// oops, we have leaked record for this owner, but we don't want to wait here
						return null;
					}
				}
				else {
					long regionInvalidationTimestamp = this.regionInvalidationTimestamp;
					if (txTimestamp <= regionInvalidationTimestamp) {
						if (trace) {
							log.tracef(""acquirePutFromLoadLock(%s#%s, %d) failed due to region invalidated at %d"", cache.getName(), key, txTimestamp, regionInvalidationTimestamp);
						}
						return null;
					}
					else {
						if (trace) {
							log.tracef(""Region invalidated at %d, this transaction started at %d"", regionInvalidationTimestamp, txTimestamp);
						}
					}

					PendingPut pendingPut = new PendingPut(session);
					pending = new PendingPutMap(pendingPut);
					PendingPutMap existing = pendingPuts.putIfAbsent(key, pending);
					if (existing != null) {
						pending = existing;
					}
					// continue in next loop with lock acquisition
				}
			}
			catch (Throwable t) {
				if (locked) {
					pending.releaseLock();
				}

				if (t instanceof RuntimeException) {
					throw (RuntimeException) t;
				}
				else if (t instanceof Error) {
					throw (Error) t;
				}
				else {
					throw new RuntimeException(t);
				}
			}
		}
	}
"	@param txTimestamp	@param txTimestamp	0	1	19	106	608
public static BooleanOperation predicate(Operator operation, Expression<?>... args) { return new BooleanOperation(operation, args); }	"    public static BooleanOperation predicate(Operator operator, Expression<?>... args) {
        return new BooleanOperation(operator, args);
    }
"	@param operation	@param operator operator	1	0	5	4	23
public int compareTo(ReadablePartial partial) { // override to perform faster if (this == partial) { return 0; } if (partial instanceof LocalDate) { LocalDate other = (LocalDate) partial; if (iChronology.equals(other.iChronology)) { return (iLocalMillis < other.iLocalMillis ? -1 : (iLocalMillis == other.iLocalMillis ? 0 : 1)); } } return super.compareTo(partial); }	"    public int compareTo(Object partial) {
        // override to perform faster
        if (this == partial) {
            return 0;
        }
        if (partial instanceof LocalDate) {
            LocalDate other = (LocalDate) partial;
            if (iChronology.equals(other.iChronology)) {
                return (iLocalMillis < other.iLocalMillis ? -1 :
                            (iLocalMillis == other.iLocalMillis ? 0 : 1));

            }
        }
        return super.compareTo(partial);
    }
"	@param partial an object to check against	@param partial an object to check against	0	1	11	16	78
public ServiceBuilder signatureType(OAuth1SignatureType signatureType) { this.signatureType = signatureType; return this; }	"    public ServiceBuilder signatureType(SignatureType signatureType) {
        Preconditions.checkNotNull(signatureType, ""Signature type can't be null"");
        this.signatureType = signatureType;
        return this;
    }
"	@param signatureType OAuth1SignatureType	@param signatureType SignatureType	1	0	6	5	16
"public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); final String url = buildUrl(path, queryParams); final Request.Builder reqBuilder = new Request.Builder().url(url); processHeaderParams(headerParams, reqBuilder); String contentType = (String) headerParams.get(""Content-Type""); // ensuring a default content type if (contentType == null) contentType = ""application/json""; RequestBody reqBody; if (!HttpMethod.permitsRequestBody(method)) { reqBody = null; } else if (""application/x-www-form-urlencoded"".equals(contentType)) { reqBody = buildRequestBodyFormEncoding(formParams); } else if (""multipart/form-data"".equals(contentType)) { reqBody = buildRequestBodyMultipart(formParams); } else if (body == null) { if (""DELETE"".equals(method)) { // allow calling DELETE without sending a request body reqBody = null; } else { // use an empty request body (for POST, PUT and PATCH) reqBody = RequestBody.create(MediaType.parse(contentType), """"); } } else { reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType)); } Request request = reqBuilder.method(method, reqBody).build(); return httpClient.newCall(request); }"	"  public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
    updateParamsForAuth(authNames, queryParams, headerParams);

    final String url = buildUrl(path, queryParams);
    final Request.Builder reqBuilder = new Request.Builder().url(url);
    processHeaderParams(headerParams, reqBuilder);

    String contentType = (String) headerParams.get(""Content-Type"");
    // ensuring a default content type
    if (contentType == null) contentType = ""application/json"";

    RequestBody reqBody;
    if (!HttpMethod.permitsRequestBody(method)) {
      reqBody = null;
    } else if (""application/x-www-form-urlencoded"".equals(contentType)) {
      reqBody = buildRequestBodyFormEncoding(formParams);
    } else if (""multipart/form-data"".equals(contentType)) {
      reqBody = buildRequestBodyMultipart(formParams);
    } else if (body == null) {
      if (""DELETE"".equals(method)) {
        // allow calling DELETE without sending a request body
        reqBody = null;
      } else {
        // use an empty request body (for POST, PUT and PATCH)
        reqBody = RequestBody.create(MediaType.parse(contentType), """");
      }
    } else {
      reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType));
    }

    Request request = null;

    if(progressRequestListener != null && reqBody != null) {
      ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, progressRequestListener);
      request = reqBuilder.method(method, progressRequestBody).build();
    } else {
      request = reqBuilder.method(method, reqBody).build();
    }

    return httpClient.newCall(request);
  }
"	@param body The request body object	@param body The request body object	0	1	14	34	285
public BrokerRequest optimize(BrokerRequest brokerRequest) { optimizeFilterQueryTree(brokerRequest); return brokerRequest; }	"  public BrokerRequest optimize(BrokerRequest inputReq) {
    // Flatten the query tree if possible
    return flatten(inputReq);
  }
"	@param brokerRequest BrokerRequest that is to be optimized	@param inputReq BrokerRequest that is to be optimized	1	0	5	7	17
public View waitForView(int id, int index, int timeout, boolean scroll){ Set<View> uniqueViewsMatchingId = new HashSet<View>(); long endTime = SystemClock.uptimeMillis() + timeout; while (SystemClock.uptimeMillis() <= endTime) { sleeper.sleep(); for (View view : viewFetcher.getAllViews(false)) { Integer idOfView = Integer.valueOf(view.getId()); if (idOfView.equals(id)) { uniqueViewsMatchingId.add(view); if(uniqueViewsMatchingId.size() > index) { return view; } } } if(scroll) scroller.scroll(Scroller.DOWN); } return null; }	"	public View waitForView(int id, int index){
		ArrayList<View> viewsMatchingId = new ArrayList<View>();
		long endTime = SystemClock.uptimeMillis() + SMALL_TIMEOUT;

		while (SystemClock.uptimeMillis() <= endTime) {
			sleeper.sleep();

			for (View view : viewFetcher.getAllViews(false)) {
				Integer idOfView = Integer.valueOf(view.getId());

				if (idOfView.equals(id)) {
					viewsMatchingId.add(view);

					if(viewsMatchingId.size() > index) {
						return viewsMatchingId.get(index);
					}
				}
			}
			viewsMatchingId.clear();
		}
		return null;
	}
"	@param view the id of the view to wait for	@param view the id of the view to wait for	0	1	12	24	118
public RexProgram normalize(RexBuilder rexBuilder, RexSimplify simplify) { // Normalize program by creating program builder from the program, then // converting to a program. getProgram does not need to normalize // because the builder was normalized on creation. assert isValid(Litmus.THROW, null); final RexProgramBuilder builder = RexProgramBuilder.create(rexBuilder, inputRowType, exprs, projects, condition, outputRowType, true, simplify); return builder.getProgram(false); }	"  public RexProgram normalize(RexBuilder rexBuilder, boolean simplify) {
    // Normalize program by creating program builder from the program, then
    // converting to a program. getProgram does not need to normalize
    // because the builder was normalized on creation.
    assert isValid(Litmus.THROW, null);
    final RexProgramBuilder builder =
        RexProgramBuilder.create(rexBuilder, inputRowType, exprs, projects,
            condition, outputRowType, true, simplify);
    return builder.getProgram(false);
  }
"	@param simplify Simplifier to simplify (in addition to normalizing), or null to not simplify	@param simplify Whether to simplify (in addition to normalizing)	1	0	6	11	85
public Action resumed(AtmosphereRequest request, AtmosphereResponse response) throws IOException, ServletException { return action(request, response); }	"    public Action resumed(HttpServletRequest request, HttpServletResponse response)
            throws IOException, ServletException {
        return action(request, response);
    }
"	@param response the  AtmosphereResponse	@param response the HttpServletResponse	1	0	5	5	24
"public String toDefaultValue(Schema schema) { if (ModelUtils.isBooleanSchema(schema)) { return ""null""; } else if (ModelUtils.isDateSchema(schema)) { return ""null""; } else if (ModelUtils.isDateTimeSchema(schema)) { return ""null""; } else if (ModelUtils.isNumberSchema(schema)) { return ""null""; } else if (ModelUtils.isIntegerSchema(schema)) { return ""null""; } else if (ModelUtils.isStringSchema(schema)) { return ""null""; } else if (ModelUtils.isObjectSchema(schema)) { return ""null""; } else { return ""null""; } }"	"    public String toDefaultValue(Property p) {
        if (p instanceof StringProperty) {
            return ""null"";
        } else if (p instanceof BooleanProperty) {
            return ""null"";
        } else if (p instanceof DateProperty) {
            return ""null"";
        } else if (p instanceof DateTimeProperty) {
            return ""null"";
        } else if (p instanceof DoubleProperty) {
            DoubleProperty dp = (DoubleProperty) p;
            if (dp.getDefault() != null) {
                return dp.getDefault().toString();
            }
            return ""null"";
        } else if (p instanceof FloatProperty) {
            FloatProperty dp = (FloatProperty) p;
            if (dp.getDefault() != null) {
                return dp.getDefault().toString();
            }
            return ""null"";
        } else if (p instanceof IntegerProperty) {
            IntegerProperty dp = (IntegerProperty) p;
            if (dp.getDefault() != null) {
                return dp.getDefault().toString();
            }
            return ""null"";
        } else if (p instanceof LongProperty) {
            LongProperty dp = (LongProperty) p;
            if (dp.getDefault() != null) {
                return dp.getDefault().toString();
            }
            return ""null"";
        } else {
            return ""null"";
        }
    }
"	@param schema Property schema	@param p Swagger property object	1	0	12	20	128
"public void updatePetWithForm (Long petId, String name, String status) throws ApiException { Object postBody = null; // verify the required parameter 'petId' is set if (petId == null) { throw new ApiException(400, ""Missing the required parameter 'petId' when calling updatePetWithForm""); } // create path and map variables String path = ""/pet/{petId}"".replaceAll(""\\{format\\}"",""json"").replaceAll(""\\{"" + ""petId"" + ""\\}"", apiInvoker.escapeString(petId.toString())); // query params List<Pair> queryParams = new ArrayList<Pair>(); // header params Map<String, String> headerParams = new HashMap<String, String>(); // form params Map<String, String> formParams = new HashMap<String, String>(); String[] contentTypes = { ""application/x-www-form-urlencoded"" }; String contentType = contentTypes.length > 0 ? contentTypes[0] : ""application/json""; if (contentType.startsWith(""multipart/form-data"")) { // file uploading MultipartEntityBuilder builder = MultipartEntityBuilder.create(); if (name != null) { builder.addTextBody(""name"", ApiInvoker.parameterToString(name), ApiInvoker.TEXT_PLAIN_UTF8); } if (status != null) { builder.addTextBody(""status"", ApiInvoker.parameterToString(status), ApiInvoker.TEXT_PLAIN_UTF8); } HttpEntity httpEntity = builder.build(); postBody = httpEntity; } else { // normal form params formParams.put(""name"", ApiInvoker.parameterToString(name)); formParams.put(""status"", ApiInvoker.parameterToString(status)); } try { String response = apiInvoker.invokeAPI(basePath, path, ""POST"", queryParams, postBody, headerParams, formParams, contentType); if(response != null){ return ; } else { return ; } } catch (ApiException ex) { throw ex; } }"	"  public void  updatePetWithForm (String petId, String name, String status) throws ApiException {
    Object postBody = null;
    
    // verify the required parameter 'petId' is set
    if (petId == null) {
       throw new ApiException(400, ""Missing the required parameter 'petId' when calling updatePetWithForm"");
    }
    

    // create path and map variables
    String path = ""/pet/{petId}"".replaceAll(""\\{format\\}"",""json"").replaceAll(""\\{"" + ""petId"" + ""\\}"", apiInvoker.escapeString(petId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    

    

    String[] contentTypes = {
      ""application/x-www-form-urlencoded""
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : ""application/json"";

    if (contentType.startsWith(""multipart/form-data"")) {
      // file uploading
      MultipartEntityBuilder builder = MultipartEntityBuilder.create();
      
      if (name != null) {
        builder.addTextBody(""name"", ApiInvoker.parameterToString(name), ApiInvoker.TEXT_PLAIN_UTF8);
      }
      
      if (status != null) {
        builder.addTextBody(""status"", ApiInvoker.parameterToString(status), ApiInvoker.TEXT_PLAIN_UTF8);
      }
      

      HttpEntity httpEntity = builder.build();
      postBody = httpEntity;
    } else {
      // normal form params
      formParams.put(""name"", ApiInvoker.parameterToString(name));
      formParams.put(""status"", ApiInvoker.parameterToString(status));
      
    }

    try {
      String response = apiInvoker.invokeAPI(basePath, path, ""POST"", queryParams, postBody, headerParams, formParams, contentType);
      if(response != null){
        return ;
      }
      else {
        return ;
      }
    } catch (ApiException ex) {
      throw ex;
    }
  }
"	@param status Updated status of the pet	@param status Updated status of the pet	0	1	10	63	377
"public static String getObjectName(AssetFile asset, ObjectPath path) { Deserializer deser = new Deserializer(asset); String name = null; try { UnityObject obj = deser.deserialize(path); name = obj.getValue(""m_Name""); } catch (OutOfMemoryError ex) { // Deserializer choked on an array size and clogged the heap, try // to clean up this mess deser = null; System.gc(); } catch (Throwable ex) { } return name; }"	"    public static String getObjectName(AssetFile asset, AssetObjectPath path) {
        Deserializer deser = new Deserializer(asset);
        String name = null;
        
        try {
            UnityObject obj = deser.deserialize(path);
            name = obj.getValue(""m_Name"");
        } catch (OutOfMemoryError ex) {
            // Deserializer choked on an array size and clogged the heap, try
            // to clean up this mess
            deser = null;
            System.gc();
        } catch (Throwable ex) {
        }
        
        return name;
    }
"	@param path object path	@param path object path	0	1	7	18	91
"private int scanURL(String url, User user, int maxChildren) throws ApiException { log.debug(""API Spider scanning url: "" + url); URI startURI; try { // Try to build uri startURI = new URI(url, true); } catch (URIException e) { throw new ApiException(ApiException.Type.BAD_FORMAT); } SiteNode startNode = Model.getSingleton().getSession().getSiteTree().findNode(startURI); String scheme = startURI.getScheme(); if (scheme == null || (!scheme.equalsIgnoreCase(""http"") && !scheme.equalsIgnoreCase(""https""))) { throw new ApiException(ApiException.Type.BAD_FORMAT); } Target target = new Target(startNode); target.setRecurse(true); Object[] objs = null; if (maxChildren > 0) { // Add the filters to filter on maximum number of children MaxChildrenFetchFilter maxChildrenFetchFilter = new MaxChildrenFetchFilter(); maxChildrenFetchFilter.setMaxChildren(maxChildren); maxChildrenFetchFilter.setModel(extension.getModel()); MaxChildrenParseFilter maxChildrenParseFilter = new MaxChildrenParseFilter(); maxChildrenParseFilter.setMaxChildren(maxChildren); maxChildrenParseFilter.setModel(extension.getModel()); objs = new Object[] { maxChildrenFetchFilter, maxChildrenParseFilter }; } return extension.startScan(target.getDisplayName(), target, user, objs); }"	"	private int scanURL(String url, User user) throws ApiException {
		log.debug(""API Spider scanning url: "" + url);

		URI startURI;
		try {
			// Try to build uri
			startURI = new URI(url, true);
		} catch (URIException e) {
			throw new ApiException(ApiException.Type.BAD_FORMAT);
		}

		SiteNode startNode = Model.getSingleton().getSession().getSiteTree().findNode(startURI);
		String scheme = startURI.getScheme();
		if (scheme == null || (!scheme.equalsIgnoreCase(""http"") && !scheme.equalsIgnoreCase(""https""))) {
			throw new ApiException(ApiException.Type.BAD_FORMAT);
		}
		Target target = new Target(startNode);
		target.setRecurse(true);
		return extension.startScan(target.getDisplayName(), target, user, null);
	}
"	@param user the user to scan as, or null if the scan is done without the perspective of any user	@param user the user to scan as, or null if the scan is done without the perspective of any user	0	1	9	38	240
"public Object getPathComponent(int index) { int pathLength = getPathCount(); if(index < 0 || index >= pathLength) throw new IllegalArgumentException(""Index "" + index + "" is out of the specified range""); TreePath path = this; for(int i = pathLength-1; i != index; i--) { path = path.getParentPath(); } return path.getLastPathComponent(); }"	"    public Object getPathComponent(int element) {
        int          pathLength = getPathCount();

        if(element < 0 || element >= pathLength)
            throw new IllegalArgumentException(""Index "" + element + "" is out of the specified range"");

        TreePath         path = this;

        for(int i = pathLength-1; i != element; i--) {
           path = path.parentPath;
        }
        return path.lastPathComponent;
    }
"	@param index the index of the element requested	@param element an int specifying an element in the path, where 0 is the first element in the path	1	0	8	16	78
private ColumnState buildMap(ContainerState parent, ColumnMetadata columnSchema) { // When dynamically adding columns, must add the (empty) // map by itself, then add columns to the map via separate // calls. assert columnSchema.isMap(); assert columnSchema.tupleSchema().isEmpty(); // Create the vector, vector state and writer. if (columnSchema.isArray()) { return buildMapArray(parent, columnSchema); } else { return buildSingleMap(parent, columnSchema); } }	"  private ColumnState buildMap(ContainerState parent, ColumnReadProjection colProj) {
    ColumnMetadata columnSchema = colProj.providedSchema();

    // When dynamically adding columns, must add the (empty)
    // map by itself, then add columns to the map via separate
    // calls.

    assert columnSchema.isMap();
    assert columnSchema.tupleSchema().isEmpty();

    // Create the vector, vector state and writer.

    if (columnSchema.isArray()) {
      return buildMapArray(parent, colProj);
    } else {
      return buildSingleMap(parent, colProj);
    }
  }
"	@param colProj implied projection type for the column	@param colProj implied projection type for the column	0	1	7	16	95
public String getShortName(long instant, Locale locale) { if (locale == null) { locale = Locale.getDefault(); } String nameKey = getNameKey(instant); if (nameKey == null) { return iID; } String name = cNameProvider.getShortName(locale, iID, nameKey); if (name != null) { return name; } return offsetFormatter().print(instant, this); }	"    public String getShortName(long millis, Locale locale) {
        if (locale == null) {
            locale = Locale.getDefault();
        }
        String nameKey = getNameKey(millis);
        if (nameKey == null) {
            return iID;
        }
        String name = cNameProvider.getShortName(locale, iID, nameKey);
        if (name != null) {
            return name;
        }
        return offsetFormatter().print(millis, this);
    }
"	@param instant milliseconds from 1970-01-01T00:00:00Z to get the name for	@param millis milliseconds from 1970-01-01T00:00:00Z to get the name for	1	0	7	15	76
public boolean isFlagSet(int flagsToCheck) { return (flags & flagsToCheck) != 0; }	"    public boolean isFlagSet(int flag) {
        return (flags & flag) != 0;
    }
"	@param flagsToCheck the flags to check	@param flag the flag to check	1	0	6	5	18
private long localToUTC(long localInstant) { DateTimeZone zone = getZone(); int offset = zone.getOffsetFromLocal(localInstant); localInstant -= offset; if (offset != zone.getOffset(localInstant)) { throw new IllegalInstantException(localInstant, zone.getID()); } return localInstant; }	"    private long localToUTC(long instant) {
        DateTimeZone zone = getZone();
        int offset = zone.getOffsetFromLocal(instant);
        instant -= offset;
        if (offset != zone.getOffset(instant)) {
            throw new IllegalArgumentException
                (""Illegal instant due to time zone offset transition: "" +
                    DateTimeFormat.forPattern(""yyyy-MM-dd'T'HH:mm:ss.SSS"").print(new Instant(instant)));
        }
        return instant;
    }
"	@param localInstant the instant from 1970-01-01T00:00:00 local time	@param instant instant from 1970-01-01T00:00:00 local time	1	0	7	10	54
"public static int[] getExpectedOutputRegion(int[] requestRegion, Rect cropRect){ Rect requestRect = new Rect(requestRegion[0], requestRegion[1], requestRegion[2], requestRegion[3]); Rect resultRect = new Rect(); assertTrue(""Input 3A region must intersect cropped region"", resultRect.setIntersect(requestRect, cropRect)); return new int[] { resultRect.left, resultRect.top, resultRect.right, resultRect.bottom, requestRegion[4]}; }"	"    public static MeteringRectangle[] getExpectedOutputRegion(
            MeteringRectangle[] requestRegions, Rect cropRect){
        MeteringRectangle[] resultRegions = new MeteringRectangle[requestRegions.length];
        for (int i = 0; i < requestRegions.length; i++) {
            Rect requestRect = requestRegions[i].getRect();
            Rect resultRect = new Rect();
            assertTrue(""Input 3A region must intersect cropped region"",
                        resultRect.setIntersect(requestRect, cropRect));
            resultRegions[i] = new MeteringRectangle(
                    resultRect,
                    requestRegions[i].getMeteringWeight());
        }
        return resultRegions;
    }
"	@param requestRegion The input 3A region [xmin, ymin, xmax, ymax, weight]	@param requestRegions The input 3A regions	1	0	8	15	95
private CollectionPersister getPersister(SharedSessionContractImplementor session) { return session.getFactory().getMetamodel().collectionPersister( role ); }	"	private CollectionPersister getPersister(SessionImplementor session) {
		return session.getFactory().getCollectionPersister( role );
	}
"	@param session The session from which the request is originating.	@param session The session from which the request is originating.	0	1	6	4	22
"public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); for(String key : queryParams.keySet()) { String value = queryParams.get(key); if (value != null){ if(b.toString().length() == 0) b.append(""?""); else b.append(""&""); b.append(escapeString(key)).append(""="").append(escapeString(value)); } } String querystring = b.toString(); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(""GET"".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (""POST"".equals(method)) { if (contentType.startsWith(""application/x-www-form-urlencoded"")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (""PUT"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (""DELETE"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, ""unknown method type "" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return """"; } } else { String message = ""error""; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { // e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }"	"  public String invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {
    updateParamsForAuth(authNames, queryParams, headerParams);

    Client client = getClient();

    StringBuilder b = new StringBuilder();
    b.append(""?"");
    if (queryParams != null){
      for (Pair queryParam : queryParams){
        if (!queryParam.getName().isEmpty()) {
          b.append(escapeString(queryParam.getName()));
          b.append(""="");
          b.append(escapeString(queryParam.getValue()));
          b.append(""&"");
        }
      }
    }

    String querystring = b.substring(0, b.length() - 1);

    Builder builder;
    if (accept == null)
      builder = client.resource(basePath + path + querystring).getRequestBuilder();
    else
      builder = client.resource(basePath + path + querystring).accept(accept);

    for(String key : headerParams.keySet()) {
      builder = builder.header(key, headerParams.get(key));
    }
    for(String key : defaultHeaderMap.keySet()) {
      if(!headerParams.containsKey(key)) {
        builder = builder.header(key, defaultHeaderMap.get(key));
      }
    }

    ClientResponse response = null;

    if(""GET"".equals(method)) {
      response = (ClientResponse) builder.get(ClientResponse.class);
    }
    else if (""POST"".equals(method)) {
      if (contentType.startsWith(""application/x-www-form-urlencoded"")) {
        String encodedFormParams = this
            .getXWWWFormUrlencodedParams(formParams);
        response = builder.type(contentType).post(ClientResponse.class,
            encodedFormParams);
      } else if (body == null) {
        response = builder.post(ClientResponse.class, null);
      } else if(body instanceof FormDataMultiPart) {
        response = builder.type(contentType).post(ClientResponse.class, body);
      }
      else
        response = builder.type(contentType).post(ClientResponse.class, serialize(body));
    }
    else if (""PUT"".equals(method)) {
      if (""application/x-www-form-urlencoded"".equals(contentType)) {
          String encodedFormParams = this
              .getXWWWFormUrlencodedParams(formParams);
          response = builder.type(contentType).put(ClientResponse.class,
              encodedFormParams);
      } else if(body == null) {
        response = builder.put(ClientResponse.class, serialize(body));
      } else {
          response = builder.type(contentType).put(ClientResponse.class, serialize(body));
      }
    }
    else if (""DELETE"".equals(method)) {
      if (""application/x-www-form-urlencoded"".equals(contentType)) {
        String encodedFormParams = this
            .getXWWWFormUrlencodedParams(formParams);
        response = builder.type(contentType).delete(ClientResponse.class,
            encodedFormParams);
      } else if(body == null) {
        response = builder.delete(ClientResponse.class);
      } else {
        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));
      }
    }
    else {
      throw new ApiException(500, ""unknown method type "" + method);
    }

    if(response.getStatusInfo() == ClientResponse.Status.NO_CONTENT) {
      return null;
    }
    else if(response.getStatusInfo().getFamily() == Family.SUCCESSFUL) {
      if(response.hasEntity()) {
        return (String) response.getEntity(String.class);
      }
      else {
        return """";
      }
    }
    else {
      String message = ""error"";
      String respBody = null;
      if(response.hasEntity()) {
        try{
          respBody = String.valueOf(response.getEntity(String.class));
          message = respBody;
        }
        catch (RuntimeException e) {
          // e.printStackTrace();
        }
      }
      throw new ApiException(
                response.getStatusInfo().getStatusCode(),
                message,
                response.getHeaders(),
                respBody);
    }
  }
"	@param queryParams The query parameters	@param queryParams The query parameters	0	1	16	111	730
"public Collection<Tree> getRelatedNodes(Tree t, Tree root) { if (root.value() == null) { root.setValue(""ROOT""); // todo: cdm: it doesn't seem like this line should be here } Set<Tree> nodeList = new LinkedHashSet<Tree>(); for (TregexPattern p : targetPatterns) { // cdm: I deleted: && nodeList.isEmpty() TregexMatcher m = p.matcher(root); while (m.findAt(t)) { nodeList.add(m.getNode(""target"")); //System.out.println(""found "" + this + ""("" + t + "", "" + m.getNode(""target"") + "") using pattern "" + p); } } return nodeList; }"	"  public Collection<TreeGraphNode> getRelatedNodes(TreeGraphNode t, TreeGraphNode root, HeadFinder headFinder) {
    Set<TreeGraphNode> nodeList = new ArraySet<TreeGraphNode>();
    for (TregexPattern p : targetPatterns) {    // cdm: I deleted: && nodeList.isEmpty()
      // Initialize the TregexMatcher with the HeadFinder so that we
      // can use the same HeadFinder through the entire process of
      // building the dependencies
      TregexMatcher m = p.matcher(root, headFinder);
      while (m.findAt(t)) {
        TreeGraphNode target = (TreeGraphNode) m.getNode(""target"");
        if (target == null) {
          throw new AssertionError(""Expression has no target: "" + p);
        }
        nodeList.add(target);
        if (DEBUG) {
          System.err.println(""found "" + this + ""("" + t + ""-"" + t.headWordNode() + "", "" + m.getNode(""target"") + ""-"" + ((TreeGraphNode) m.getNode(""target"")).headWordNode() + "") using pattern "" + p);
          for (String nodeName : m.getNodeNames()) {
            if (nodeName.equals(""target""))
              continue;
            System.err.println(""  node "" + nodeName + "": "" + m.getNode(nodeName));
          }
        }
      }
    }
    return nodeList;
  }
"	@param t Target for finding governors of t related by this GR	@param t Target for finding dependents of t related by this GR	1	0	10	15	151
public Object nullSafeGet(ResultSet rs, String name, SharedSessionContractImplementor session, Object owner) throws SQLException { return nullSafeGet( rs, new String[] { name }, session, owner ); }	"	public Object nullSafeGet(ResultSet rs, String name, SessionImplementor session, Object owner) throws SQLException {
		return nullSafeGet( rs, new String[] { name }, session, owner );
	}
"	@param session The session from which the request is originating.	@param session The session from which the request is originating.	0	1	7	4	38
"public void createUser (User user) throws ApiException { Object localVarPostBody = user; // verify the required parameter 'user' is set if (user == null) { throw new ApiException(400, ""Missing the required parameter 'user' when calling createUser""); } // create path and map variables String localVarPath = ""/user"".replaceAll(""\\{format\\}"",""json""); // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); // header params Map<String, String> localVarHeaderParams = new HashMap<String, String>(); // form params Map<String, String> localVarFormParams = new HashMap<String, String>(); String[] localVarContentTypes = { ""application/json"" }; String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : ""application/json""; if (localVarContentType.startsWith(""multipart/form-data"")) { // file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); localVarPostBody = localVarBuilder.build(); } else { // normal form params } try { String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, ""POST"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType); if(localVarResponse != null){ return ; } else { return ; } } catch (ApiException ex) { throw ex; } }"	"  public void  createUser (User body) throws ApiException {
    Object localVarPostBody = body;
    // verify the required parameter 'body' is set
    if (body == null) {
       throw new ApiException(400, ""Missing the required parameter 'body' when calling createUser"");
    }

    // create path and map variables
    String localVarPath = ""/user"".replaceAll(""\\{format\\}"",""json"");

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    // form params
    Map<String, String> localVarFormParams = new HashMap<String, String>();



    String[] localVarContentTypes = {
      
    };
    String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : ""application/json"";

    if (localVarContentType.startsWith(""multipart/form-data"")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      localVarPostBody = localVarBuilder.build();
    } else {
      // normal form params
          }

    try {
      String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, ""POST"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType);
      if(localVarResponse != null){
        return ;
      }
      else {
        return ;
      }
    } catch (ApiException ex) {
      throw ex;
    }
  }
"	@param user Created user object	@param body Created user object	1	0	8	47	252
public CodegenModel fromModel(String name, Schema model, Map<String, Schema> allDefinitions) { CodegenModel codegenModel = super.fromModel(name, model, allDefinitions); return codegenModel; }	"    public CodegenModel fromModel(String name, Model model, Map<String, Model> allDefinitions) {
        CodegenModel codegenModel = super.fromModel(name, model, allDefinitions);
        return codegenModel;
    }
"	@param allDefinitions a map of all OpenAPI models from the spec	@param allDefinitions a map of all Swagger models from the spec	1	0	6	5	33
public List<String> dependencyPathBetween(int start, int end) { // Get paths from a node to the root of the sentence LinkedList<Integer> rootToStart = new LinkedList<>(); LinkedList<Integer> rootToEnd = new LinkedList<>(); int startAncestor = start; while (sentence.governor(startAncestor).isPresent() && sentence.governor(startAncestor).get() >= 0) { rootToStart.addFirst(startAncestor); startAncestor = sentence.governor(startAncestor).get(); } if (startAncestor == -1) { rootToStart.addFirst(-1); } int endAncestor = start; while (sentence.governor(endAncestor).isPresent() && sentence.governor(endAncestor).get() >= 0) { rootToEnd.addFirst(endAncestor); endAncestor = sentence.governor(endAncestor).get(); } if (endAncestor == -1) { rootToEnd.addFirst(-1); } // Get least common node return null; // TODO(gabor) write me! }	"  public List<String> dependencyPathBetween(int start, int end, Function<Sentence, List<String>> selector) {
    // Get paths from a node to the root of the sentence
    LinkedList<Integer> rootToStart = new LinkedList<>();
    LinkedList<Integer> rootToEnd = new LinkedList<>();
    int startAncestor = start;
    List<Optional<Integer>> governors = sentence.governors();
    Set<Integer> seenVertices = new HashSet<>();
    while (startAncestor >= 0 && governors.get(startAncestor).isPresent()) {
      if (seenVertices.contains(startAncestor)) {
        return Collections.EMPTY_LIST;
      }
      seenVertices.add(startAncestor);
      rootToStart.addFirst(startAncestor);
      startAncestor = governors.get(startAncestor).get();
    }
    if (startAncestor == -1) {
      rootToStart.addFirst(-1);
    }
    int endAncestor = end;
    seenVertices.clear();
    while (endAncestor >= 0 && governors.get(endAncestor).isPresent()) {
      if (seenVertices.contains(endAncestor)) {
        return Collections.EMPTY_LIST;
      }
      seenVertices.add(endAncestor);
      rootToEnd.addFirst(endAncestor);
      endAncestor = governors.get(endAncestor).get();
    }
    if (endAncestor == -1) {
      rootToEnd.addFirst(-1);
    }

    // Get least common node
    int leastCommonNodeIndex = (rootToStart.size() == 0 || rootToEnd.size() == 0 || !rootToStart.get(0).equals(rootToEnd.get(0))) ? -1 : 0;
    for (int i = 1; i < Math.min(rootToStart.size(), rootToEnd.size()); ++i) {
      if (rootToStart.get(i).equals(rootToEnd.get(i))) {
        leastCommonNodeIndex = i;
      }
    }

    // Construct the path
    if (leastCommonNodeIndex < 0) {
      return Collections.EMPTY_LIST;
    }
    List<String> path = new ArrayList<>();
    for (int i = rootToStart.size() - 1; i > leastCommonNodeIndex; --i) {
      path.add(selector.apply(sentence).get(rootToStart.get(i)));
      path.add(""<-"" + sentence.incomingDependencyLabel(rootToStart.get(i)).orElse(""dep"") + ""-"");
    }
    path.add(selector.apply(sentence).get(rootToStart.get(leastCommonNodeIndex)));
    for (int i = leastCommonNodeIndex + 1; i < rootToEnd.size(); ++i) {
      path.add(""-"" + sentence.incomingDependencyLabel(rootToEnd.get(i)).orElse(""dep"") + ""->"");
      path.add(selector.apply(sentence).get(rootToEnd.get(i)));
    }
    return path;
  }
"	@param  The type of the element we are getting.	@param The type of the element we are getting.	0	1	8	27	178
"public static Path relativize(Path baseDir, Path childPath) { Path fullPathWithoutSchemeAndAuthority = Path.getPathWithoutSchemeAndAuthority(childPath); Path basePathWithoutSchemeAndAuthority = Path.getPathWithoutSchemeAndAuthority(baseDir); // Since hadoop Path hasn't relativize() we use uri.relativize() to get relative path Path relativeFilePath = new Path(basePathWithoutSchemeAndAuthority.toUri() .relativize(fullPathWithoutSchemeAndAuthority.toUri())); if (relativeFilePath.isAbsolute()) { throw new IllegalStateException(String.format(""Path %s is not a subpath of %s."", basePathWithoutSchemeAndAuthority.toUri().getPath(), fullPathWithoutSchemeAndAuthority.toUri().getPath())); } return relativeFilePath; }"	"  public static String relativize(String baseDir, String childPath) {
    Path fullPathWithoutSchemeAndAuthority = Path.getPathWithoutSchemeAndAuthority(new Path(childPath));
    Path basePathWithoutSchemeAndAuthority = Path.getPathWithoutSchemeAndAuthority(new Path(baseDir));

    // Since hadoop Path hasn't relativize() we use uri.relativize() to get relative path
    Path relativeFilePath = new Path(basePathWithoutSchemeAndAuthority.toUri()
        .relativize(fullPathWithoutSchemeAndAuthority.toUri()));
    if (relativeFilePath.isAbsolute()) {
      throw new IllegalStateException(String.format(""Path %s is not a subpath of %s."",
          basePathWithoutSchemeAndAuthority.toUri().getPath(), fullPathWithoutSchemeAndAuthority.toUri().getPath()));
    }
    return relativeFilePath.toUri().getPath();
  }
"	@param childPath full absolute path	@param childPath full absolute path	0	1	9	14	118
"public Boolean fakeOuterBooleanSerialize(Boolean booleanPostBody) throws ApiException { Object localVarPostBody = booleanPostBody; // create path and map variables String localVarPath = ""/fake/outer/boolean"".replaceAll(""\\{format\\}"",""json""); // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { ""*/*"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {}; return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	"  public Boolean fakeOuterBooleanSerialize(Boolean body) throws ApiException {
    Object localVarPostBody = body;
    
    // create path and map variables
    String localVarPath = ""/fake/outer/boolean"".replaceAll(""\\{format\\}"",""json"");

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    final String[] localVarAccepts = {
      
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {};
    return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);
      }
"	@param booleanPostBody Input boolean as post body (optional)	@param body Input boolean as post body (optional)	1	0	8	30	176
"public static Struct fromLogical(Schema schema, SpecialValueDecimal value) { Struct result = new Struct(schema); final BigDecimal decimalValue = value.getDecimalValue().orElse(null); assert decimalValue != null : ""Unable to encode special value""; result.put(VALUE_FIELD, decimalValue.unscaledValue().toByteArray()); result.put(SCALE_FIELD, decimalValue.scale()); return result; }"	"    public static Struct fromLogical(Schema schema, DebeziumDecimal value) {
        Struct result = new Struct(schema);
        final BigDecimal decimalValue = value.getDecimalValue().orElse(null);
        assert decimalValue != null : ""Unable to encode special value"";
        result.put(VALUE_FIELD, decimalValue.unscaledValue().toByteArray());
        result.put(SCALE_FIELD, decimalValue.scale());
        return result;
    }
"	@param schema of the encoded value	@param schema of the encoded value	0	1	7	9	74
private boolean isCached(Serializable collectionKey, CollectionPersister persister) { if ( persister.hasCache() ) { CacheKey cacheKey = context.getSession().generateCacheKey( collectionKey, persister.getKeyType(), persister.getRole() ); return persister.getCacheAccessStrategy().get( cacheKey, context.getSession().getTimestamp() ) != null; } return false; }	"	private boolean isCached(EntityKey entityKey, EntityPersister persister) {
		if ( persister.hasCache() ) {
			CacheKey key = context.getSession().generateCacheKey(
					entityKey.getIdentifier(),
					persister.getIdentifierType(),
					entityKey.getEntityName()
			);
			return persister.getCacheAccessStrategy().get( key, context.getSession().getTimestamp() ) != null;
		}
		return false;
	}
"	@param collectionPersister The persister for the collection role.	@param persister The persister for the entities being loaded.	1	0	10	12	65
"private long insertData(ContentValues inputValues, boolean callerIsSyncAdapter) { final Long rawContactId = inputValues.getAsLong(Data.RAW_CONTACT_ID); if (rawContactId == null) { throw new IllegalArgumentException(Data.RAW_CONTACT_ID + "" is required""); } final String mimeType = inputValues.getAsString(Data.MIMETYPE); if (TextUtils.isEmpty(mimeType)) { throw new IllegalArgumentException(Data.MIMETYPE + "" is required""); } // The input seem valid, create a shallow copy. final ContentValues values = new ContentValues(inputValues); // Populate the relevant values before inserting the new entry into the database. replacePackageNameByPackageId(values); // Replace the mimetype by the corresponding mimetype ID. values.put(DataColumns.MIMETYPE_ID, mDbHelper.get().getMimeTypeId(mimeType)); values.remove(Data.MIMETYPE); // Insert the new entry. final SQLiteDatabase db = mDbHelper.get().getWritableDatabase(); final TransactionContext context = mTransactionContext.get(); final long dataId = getDataRowHandler(mimeType).insert(db, context, rawContactId, values); context.markRawContactDirtyAndChanged(rawContactId, callerIsSyncAdapter); context.rawContactUpdated(rawContactId); return dataId; }"	"    private long insertData(ContentValues values, boolean callerIsSyncAdapter) {
        long id = 0;
        mValues.clear();
        mValues.putAll(values);

        Long rawContactId = mValues.getAsLong(Data.RAW_CONTACT_ID);
        if (rawContactId == null) {
            throw new IllegalArgumentException(Data.RAW_CONTACT_ID + "" is required"");
        }

        // Replace package with internal mapping.
        final String packageName = mValues.getAsString(Data.RES_PACKAGE);
        if (packageName != null) {
            mValues.put(DataColumns.PACKAGE_ID, mDbHelper.get().getPackageId(packageName));
        }
        mValues.remove(Data.RES_PACKAGE);

        // Replace mimetype with internal mapping.
        final String mimeType = mValues.getAsString(Data.MIMETYPE);
        if (TextUtils.isEmpty(mimeType)) {
            throw new IllegalArgumentException(Data.MIMETYPE + "" is required"");
        }

        mValues.put(DataColumns.MIMETYPE_ID, mDbHelper.get().getMimeTypeId(mimeType));
        mValues.remove(Data.MIMETYPE);

        DataRowHandler rowHandler = getDataRowHandler(mimeType);
        final SQLiteDatabase db = mDbHelper.get().getWritableDatabase();
        id = rowHandler.insert(db, mTransactionContext.get(), rawContactId, mValues);
        mTransactionContext.get().markRawContactDirtyAndChanged(rawContactId, callerIsSyncAdapter);
        mTransactionContext.get().rawContactUpdated(rawContactId);
        return id;
    }
"	@param inputValues The values for the new row.	@param values the values for the new row	1	0	8	32	207
public Call buildCall(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException { Request request = buildRequest(path, method, queryParams, collectionQueryParams, body, headerParams, formParams, authNames, callback); return httpClient.newCall(request); }	"    public Call buildCall(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Request request = buildRequest(path, method, queryParams, collectionQueryParams, body, headerParams, formParams, authNames, progressRequestListener);

        return httpClient.newCall(request);
    }
"	@param body The request body object	@param body The request body object	0	1	6	6	75
private ColumnState buildUnionList(ContainerState parent, ColumnReadProjection colProj) { ColumnMetadata columnSchema = colProj.providedSchema(); // The variant must start out empty. assert columnSchema.variantSchema().size() == 0; // Create the union writer, bound to an empty list shim. final UnionWriterImpl unionWriter = new UnionWriterImpl(columnSchema); unionWriter.bindShim(new EmptyListShim()); final VariantObjectWriter unionObjWriter = new VariantObjectWriter(unionWriter); // Create the list vector. Starts with the default (dummy) data // vector which corresponds to the empty union shim above. // Don't get the list vector from the vector cache. List vectors may // have content that varies from batch to batch. Only the leaf // vectors can be cached. final ListVector listVector = new ListVector(columnSchema.schema(), parent.loader().allocator(), null); // Create the list vector state that tracks the list vector lifecycle. final ListVectorState vectorState = new ListVectorState(unionWriter, listVector); // Create the list writer: an array of unions. final AbstractObjectWriter listWriter = new ArrayObjectWriter( new ListWriterImpl(columnSchema, listVector, unionObjWriter)); // Create the manager for the columns within the list (which may or // may not be grouped into a union.) final ListState listState = new ListState(parent.loader(), parent.vectorCache().childCache(columnSchema.name())); // Bind the union state to the union writer to handle column additions. unionWriter.bindListener(listState); // Assemble it all into a union column state. return new UnionColumnState(parent.loader(), listWriter, vectorState, listState); }	"  private ColumnState buildUnionList(ContainerState parent, ColumnTransform outputCol) {
    ColumnMetadata columnSchema = outputCol.outputSchema();

    // The variant must start out empty.

    assert columnSchema.variantSchema().size() == 0;

    // Create the union writer, bound to an empty list shim.

    final UnionWriterImpl unionWriter = new UnionWriterImpl(columnSchema);
    unionWriter.bindShim(new EmptyListShim());
    final VariantObjectWriter unionObjWriter = new VariantObjectWriter(unionWriter);

    // Create the list vector. Starts with the default (dummy) data
    // vector which corresponds to the empty union shim above.
    // Don't get the list vector from the vector cache. List vectors may
    // have content that varies from batch to batch. Only the leaf
    // vectors can be cached.

    final ListVector listVector = new ListVector(columnSchema.schema(),
        parent.loader().allocator(), null);

    // Create the list vector state that tracks the list vector lifecycle.

    final ListVectorState vectorState = new ListVectorState(unionWriter, listVector);

    // Create the list writer: an array of unions.

    final AbstractObjectWriter listWriter = new ArrayObjectWriter(
        new ListWriterImpl(columnSchema, listVector, unionObjWriter));

    // Create the manager for the columns within the list (which may or
    // may not be grouped into a union.)

    final ListState listState = new ListState(parent.loader(),
        parent.vectorCache().childCache(columnSchema.name()),
        ImpliedTupleRequest.ALL_MEMBERS);

    // Bind the union state to the union writer to handle column additions.

    unionWriter.bindListener(listState);

    // Assemble it all into a union column state.

    return new UnionColumnState(parent.loader(),
        listWriter, vectorState, listState);
  }
"	@param columnSchema metadata description of the list (must be empty of subtypes)	@param columnSchema metadata description of the list (must be empty of subtypes)	0	1	8	47	306
public int create(Object[] row, Instant ts) throws InterruptedException { return create(row, ts, 0, 1); }	"        public int create(Object[] row, long ts) throws InterruptedException {
            return create(row, ts, 0, 1);
        }
"	@param row the values of the row, in the same order as the columns in the  Table definition in the  MySqlSchema.	@param row the values of the row, in the same order as the columns in the Table definition in the MySqlSchema.	0	1	5	4	28
"private static File getKylinPropertiesFile(String path) { if (path == null) return null; File propFile = new File(path, KYLIN_CONF_PROPERTIES_FILE); if (propFile.exists()) { logger.info(KYLIN_CONF_PROPERTIES_FILE + "" was found at "" + propFile.getAbsolutePath()); } logger.info(KYLIN_CONF_PROPERTIES_FILE + "" was NOT found at "" + propFile.getAbsolutePath()); return null; }"	"    private static File getKylinPropertiesFile(String path, String env) {
        File dir = new File(path);
        System.out.println(dir.getAbsolutePath());
        if (dir.exists() && dir.isDirectory()) {
            File propFile = new File(dir, KYLIN_CONF_PROPERTIES_FILE);
            String fName = KYLIN_CONF_PROPERTIES_FILE;
            File envPropFile = null;
            if (env != null) {
                fName = fName.replace(""."", ""_"" + env + ""."");
                envPropFile = new File(dir, fName);
            }
            if (envPropFile != null && envPropFile.exists()) {
                logger.info(fName + "" found in "" + path);
                return envPropFile;
            }
            if (propFile != null && propFile.exists()) {
                logger.info(KYLIN_CONF_PROPERTIES_FILE + "" found in "" + path);
                return propFile;
            }
        }
        return null;
    }
"	@param path	@param path	0	1	9	13	75
public static Point getCanvasTextLocation(Client client, Graphics2D graphics, LocalPoint localLocation, String text, int zOffset) { int plane = client.getPlane(); Point p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset); if (p == null) { return null; } FontMetrics fm = graphics.getFontMetrics(); Rectangle2D bounds = fm.getStringBounds(text, graphics); int xOffset = p.getX() - (int) (bounds.getWidth() / 2); return new Point(xOffset, p.getY()); }	"	public static Point getCanvasTextLocation(Client client, Graphics2D graphics, Point localLocation, String text, int zOffset)
	{
		int plane = client.getPlane();

		Point p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset);

		if (p == null)
		{
			return null;
		}

		FontMetrics fm = graphics.getFontMetrics();
		Rectangle2D bounds = fm.getStringBounds(text, graphics);
		int xOffset = p.getX() - (int) (bounds.getWidth() / 2);

		return new Point(xOffset, p.getY());
	}
"	@param graphics	@param graphics	0	1	8	18	109
public long add(long instant, int months) { if (months == 0) { return instant; // the easy case } // // Save time part first. // long timePart = iChronology.millisOfDay().get(instant); // // // Get this year and month. // int thisYear = iChronology.year().get(instant); int thisMonth = iChronology.getMonthOfYear(instant, thisYear); // ---------------------------------------------------------- // // Do not refactor without careful consideration. // Order of calculation is important. // int yearToUse; // Initially, monthToUse is zero-based int monthToUse = thisMonth - 1 + months; if (monthToUse >= 0) { yearToUse = thisYear + (monthToUse / MAX); monthToUse = (monthToUse % MAX) + 1; } else { yearToUse = thisYear + (monthToUse / MAX) - 1; monthToUse = Math.abs(monthToUse); int remMonthToUse = monthToUse % MAX; // Take care of the boundary condition if (remMonthToUse == 0) { remMonthToUse = MAX; } monthToUse = MAX - remMonthToUse + 1; // Take care of the boundary condition if (monthToUse == 1) { yearToUse += 1; } } // End of do not refactor. // ---------------------------------------------------------- // // Quietly force DOM to nearest sane value. // int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth); int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse); if (dayToUse > maxDay) { dayToUse = maxDay; } // // get proper date part, and return result // long datePart = iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse); return datePart + timePart; }	"    public long add(long millis, int months) {
        if (months == 0) {
            return millis; // the easy case
        }
        //
        // Save time part first.
        //
        long timePart = iChronology.millisOfDay().get(millis);
        //
        //
        // Get this year and month.
        //
        int thisYear = iChronology.year().get(millis);
        int thisMonth = iChronology.getMonthOfYear(millis, thisYear);
        // ----------------------------------------------------------
        //
        // Do not refactor without careful consideration.
        // Order of calculation is important.
        //
        int yearToUse;
        // Initially, monthToUse is zero-based
        int monthToUse = thisMonth - 1 + months;
        if (monthToUse >= 0) {
            yearToUse = thisYear + (monthToUse / MAX);
            monthToUse = (monthToUse % MAX) + 1;
        } else {
            yearToUse = thisYear + (monthToUse / MAX) - 1;
            monthToUse = Math.abs(monthToUse);
            int remMonthToUse = monthToUse % MAX;
            // Take care of the boundary condition
            if (remMonthToUse == 0) {
                remMonthToUse = MAX;
            }
            monthToUse = MAX - remMonthToUse + 1;
            // Take care of the boundary condition
            if (monthToUse == 1) {
                yearToUse += 1;
            }
        }
        // End of do not refactor.
        // ----------------------------------------------------------

        //
        // Quietly force DOM to nearest sane value.
        //
        int dayToUse = iChronology.getDayOfMonth(millis, thisYear, thisMonth);
        int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse);
        if (dayToUse > maxDay) {
            dayToUse = maxDay;
        }
        //
        // get proper date part, and return result
        //
        long datePart =
            iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse);
        return datePart + timePart;
    }
"	@param instant the time instant in millis to update.	@param millis the time instant in millis to update.	1	0	10	58	420
private SQLResponse execute(String correctedSql, SQLRequest sqlRequest) throws Exception { Connection conn = null; Statement stat = null; ResultSet resultSet = null; Boolean isPushDown = false; List<List<String>> results = Lists.newArrayList(); List<SelectedColumnMeta> columnMetas = Lists.newArrayList(); try { conn = cacheService.getOLAPDataSource(sqlRequest.getProject()).getConnection(); // special case for prepare query. if (BackdoorToggles.getPrepareOnly()) { return getPrepareOnlySqlResponse(correctedSql, conn, isPushDown, results, columnMetas); } stat = conn.createStatement(); processStatementAttr(stat, sqlRequest); resultSet = stat.executeQuery(correctedSql); ResultSetMetaData metaData = resultSet.getMetaData(); int columnCount = metaData.getColumnCount(); // Fill in selected column meta for (int i = 1; i <= columnCount; ++i) { columnMetas.add(new SelectedColumnMeta(metaData.isAutoIncrement(i), metaData.isCaseSensitive(i), metaData.isSearchable(i), metaData.isCurrency(i), metaData.isNullable(i), metaData.isSigned(i), metaData.getColumnDisplaySize(i), metaData.getColumnLabel(i), metaData.getColumnName(i), metaData.getSchemaName(i), metaData.getCatalogName(i), metaData.getTableName(i), metaData.getPrecision(i), metaData.getScale(i), metaData.getColumnType(i), metaData.getColumnTypeName(i), metaData.isReadOnly(i), metaData.isWritable(i), metaData.isDefinitelyWritable(i))); } // fill in results while (resultSet.next()) { List<String> oneRow = Lists.newArrayListWithCapacity(columnCount); for (int i = 0; i < columnCount; i++) { oneRow.add((resultSet.getString(i + 1))); } results.add(oneRow); } } catch (SQLException sqlException) { isPushDown = PushDownUtil.doPushDownQuery(sqlRequest.getProject(), correctedSql, results, columnMetas, sqlException); } finally { close(resultSet, stat, conn); } return getSqlResponse(isPushDown, results, columnMetas); }	"    private SQLResponse execute(String correctedSql, SQLRequest sqlRequest, Connection conn) throws Exception {
        Statement stat = null;
        ResultSet resultSet = null;
        Boolean isPushDown = false;

        List<List<String>> results = Lists.newArrayList();
        List<SelectedColumnMeta> columnMetas = Lists.newArrayList();

        try {

            // special case for prepare query. 
            if (BackdoorToggles.getPrepareOnly()) {
                return getPrepareOnlySqlResponse(correctedSql, conn, isPushDown, results, columnMetas);
            }

            stat = conn.createStatement();
            processStatementAttr(stat, sqlRequest);
            resultSet = stat.executeQuery(correctedSql);

            ResultSetMetaData metaData = resultSet.getMetaData();
            int columnCount = metaData.getColumnCount();

            // Fill in selected column meta
            for (int i = 1; i <= columnCount; ++i) {
                columnMetas.add(new SelectedColumnMeta(metaData.isAutoIncrement(i), metaData.isCaseSensitive(i),
                        metaData.isSearchable(i), metaData.isCurrency(i), metaData.isNullable(i), metaData.isSigned(i),
                        metaData.getColumnDisplaySize(i), metaData.getColumnLabel(i), metaData.getColumnName(i),
                        metaData.getSchemaName(i), metaData.getCatalogName(i), metaData.getTableName(i),
                        metaData.getPrecision(i), metaData.getScale(i), metaData.getColumnType(i),
                        metaData.getColumnTypeName(i), metaData.isReadOnly(i), metaData.isWritable(i),
                        metaData.isDefinitelyWritable(i)));
            }

            // fill in results
            while (resultSet.next()) {
                List<String> oneRow = Lists.newArrayListWithCapacity(columnCount);
                for (int i = 0; i < columnCount; i++) {
                    oneRow.add((resultSet.getString(i + 1)));
                }

                results.add(oneRow);
            }
        } catch (SQLException sqlException) {
            isPushDown = PushDownUtil.doPushDownQuery(sqlRequest.getProject(), correctedSql, conn.getSchema(), results,
                    columnMetas, sqlException);
            if (!isPushDown) {
                throw sqlException;
            }
        } finally {
            close(resultSet, stat, null);//conn is passed in, not my duty to close
        }

        return getSqlResponse(isPushDown, results, columnMetas);
    }
"	@param sqlRequest	@param sqlRequest	0	1	12	54	376
public Action suspended(AtmosphereRequest request, AtmosphereResponse response) throws IOException, ServletException { return action(request, response); }	"    public Action suspended(HttpServletRequest request, HttpServletResponse response)
            throws IOException, ServletException {
        return action(request, response);
    }
"	@param request the  AtmosphereRequest	@param request the HttpServletRequest	1	0	5	5	24
public ClusterFixtureBuilder withBits(String...bitNames) { this.bitNames = bitNames; bitCount = bitNames.length; return this; }	"  public ClusterFixtureBuilder withBits(String bitNames[]) {
    this.bitNames = bitNames;
    bitCount = bitNames.length;
    return this;
  }
"	@param bitNames array of (unique) Drillbit names	@param bitNames array of (unique) Drillbit names	0	1	6	6	20
"public static Object increment(Object version, VersionType versionType, SharedSessionContractImplementor session) { final Object next = versionType.next( version, session ); if ( LOG.isTraceEnabled() ) { LOG.tracef( ""Incrementing: %s to %s"", versionType.toLoggableString( version, session.getFactory() ), versionType.toLoggableString( next, session.getFactory() ) ); } return next; }"	"	public static Object increment(Object version, VersionType versionType, SessionImplementor session) {
		final Object next = versionType.next( version, session );
		if ( LOG.isTraceEnabled() ) {
			LOG.tracef(
					""Incrementing: %s to %s"",
					versionType.toLoggableString( version, session.getFactory() ),
					versionType.toLoggableString( next, session.getFactory() )
			);
		}
		return next;
	}
"	@param session The originating session	@param session The originating session	0	1	8	12	75
private RectF drawBoxWithShadow(Canvas c, Paint p, int width, int height) { Resources res = mContext.getResources(); float shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur); float keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance); float corner = res.getDimension(R.dimen.widget_preview_corner_radius); RectF bounds = new RectF(shadowBlur, shadowBlur, width - shadowBlur, height - shadowBlur - keyShadowDistance); p.setColor(Color.WHITE); // Key shadow p.setShadowLayer(shadowBlur, 0, keyShadowDistance, ShadowGenerator.KEY_SHADOW_ALPHA << 24); c.drawRoundRect(bounds, corner, corner, p); // Ambient shadow p.setShadowLayer(shadowBlur, 0, 0, ColorUtils.setAlphaComponent(Color.BLACK, ShadowGenerator.AMBIENT_SHADOW_ALPHA)); c.drawRoundRect(bounds, corner, corner, p); p.clearShadowLayer(); return bounds; }	"    private RectF drawBoxWithShadow(Canvas c, int width, int height) {
        Resources res = mContext.getResources();

        ShadowGenerator.Builder builder = new ShadowGenerator.Builder(Color.WHITE);
        builder.shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur);
        builder.radius = res.getDimension(R.dimen.widget_preview_corner_radius);
        builder.keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance);

        builder.bounds.set(builder.shadowBlur, builder.shadowBlur,
                width - builder.shadowBlur,
                height - builder.shadowBlur - builder.keyShadowDistance);
        builder.drawShadow(c);
        return builder.bounds;
    }
"	@param preview bitmap that can be recycled	@param preview bitmap that can be recycled	0	1	8	24	156
"public Action resumed(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { logger.debug(""(resumed) invoked:\n HttpServletRequest: {}\n HttpServletResponse: {}"", request, response); return action(request, response); }"	"    public Action resumed(HttpServletRequest req, HttpServletResponse res)
            throws IOException, ServletException {
        if (logger.isLoggable(Level.FINE)) {
            logger.fine(""(resumed) invoked:\n HttpServletRequest: "" + req
                    + ""\n HttpServletResponse: "" + res);
        }
        return action(req, res);
    }
"	@param response the  HttpServletResponse	@param res the HttpServletResponse	1	0	5	6	52
public byte getStatus(final int id, final String path) { byte status; BaseDownloadTask.IRunningTask task = FileDownloadList.getImpl().get(id); if (task == null) { status = FileDownloadServiceProxy.getImpl().getStatus(id); } else { status = task.getOrigin().getStatus(); } if (path != null && status == FileDownloadStatus.INVALID_STATUS) { if (FileDownloadUtils.isFilenameConverted(FileDownloadHelper.getAppContext()) && new File(path).exists()) { status = FileDownloadStatus.completed; } } return status; }	"    public byte getStatus(final int downloadId, final String path) {
        byte status;
        BaseDownloadTask.IRunningTask task = FileDownloadList.getImpl().get(downloadId);
        if (task == null) {
            status = FileDownloadServiceProxy.getImpl().getStatus(downloadId);
        } else {
            status = task.getOrigin().getStatus();
        }

        if (path != null && status == FileDownloadStatus.INVALID_STATUS) {
            if (FileDownloadUtils.isFilenameConverted(FileDownloadHelper.getAppContext()) &&
                    new File(path).exists()) {
                status = FileDownloadStatus.completed;
            }
        }

        return status;
    }
"	@param id The downloadId.	@param downloadId The downloadId.	1	0	9	19	101
public JoinSequence createJoinSequence(boolean implicit, AssociationType associationType, String tableAlias, JoinType joinType, String[] columns) { JoinSequence joinSequence = createJoinSequence(); joinSequence.setUseThetaStyle( implicit ); // Implicit joins use theta style (WHERE pk = fk), explicit joins use JOIN (after from) joinSequence.addJoin( associationType, tableAlias, joinType, columns ); return joinSequence; }	"	public JoinSequence createJoinSequence(boolean implicit, AssociationType associationType, String tableAlias, int joinType, String[] columns) {
		JoinSequence joinSequence = createJoinSequence();
		joinSequence.setUseThetaStyle( implicit );	// Implicit joins use theta style (WHERE pk = fk), explicit joins use JOIN (after from)
		joinSequence.addJoin( associationType, tableAlias, joinType, columns );
		return joinSequence;
	}
"	@param tableAlias The table alias to use in qualifying the join conditions	@param tableAlias The table alias to use in qualifying the join conditions	0	1	5	7	71
"public Client call123testSpecialTags(Client body) throws ApiException { Object localVarPostBody = body; // verify the required parameter 'body' is set if (body == null) { throw new ApiException(400, ""Missing the required parameter 'body' when calling call123testSpecialTags""); } // create path and map variables String localVarPath = ""/another-fake/dummy"".replaceAll(""\\{format\\}"",""json""); // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { ""application/json"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { ""application/json"" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Client> localVarReturnType = new GenericType<Client>() {}; return apiClient.invokeAPI(localVarPath, ""PATCH"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	"  public Client call123testSpecialTags(Client client) throws ApiException {
    Object localVarPostBody = client;
    
    // verify the required parameter 'client' is set
    if (client == null) {
      throw new ApiException(400, ""Missing the required parameter 'client' when calling call123testSpecialTags"");
    }
    
    // create path and map variables
    String localVarPath = ""/another-fake/dummy"".replaceAll(""\\{format\\}"",""json"");

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    final String[] localVarAccepts = {
      ""application/json""
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      ""application/json""
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    GenericType<Client> localVarReturnType = new GenericType<Client>() {};
    return apiClient.invokeAPI(localVarPath, ""PATCH"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);
      }
"	@param body client model (required)	@param client client model (required)	1	0	8	35	219
public int read(Object[] row, Instant ts, int rowNumber, int numberOfRows) throws InterruptedException { return converter.read(source, row, rowNumber, numberOfRows, includedColumns, ts, consumer); }	"        public int read(Object[] row, long ts, int rowNumber, int numberOfRows) throws InterruptedException {
            return converter.read(source, row, rowNumber, numberOfRows, includedColumns, ts, consumer);
        }
"	@param rowNumber the number of this row; must be 0 or more	@param rowNumber the number of this row; must be 0 or more	0	1	5	4	41
public long add(long instant, int years) { if (years == 0) { return instant; } int thisYear = get(instant); int newYear = thisYear + years; return set(instant, newYear); }	"    public long add(long millis, int years) {
        if (years == 0) {
            return millis;
        }
        int thisYear = get(millis);
        int newYear = thisYear + years;
        return set(millis, newYear);
    }
"	@param instant the time instant in millis to update.	@param millis the time instant in millis to update.	1	0	6	9	43
"public Mono<Client> testClientModel(Client body) throws RestClientException { Object postBody = body; // verify the required parameter 'body' is set if (body == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'body' when calling testClientModel""); } String path = UriComponentsBuilder.fromPath(""/fake"").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { ""application/json"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { ""application/json"" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {}; return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }"	"    public Mono<Client> testClientModel(Client client) throws RestClientException {
        Object postBody = client;
        
        // verify the required parameter 'client' is set
        if (client == null) {
            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'client' when calling testClientModel"");
        }
        
        String path = UriComponentsBuilder.fromPath(""/fake"").build().toUriString();
        
        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();
        final HttpHeaders headerParams = new HttpHeaders();
        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();

        final String[] accepts = { 
            ""application/json""
        };
        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);
        final String[] contentTypes = { 
            ""application/json""
        };
        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);

        String[] authNames = new String[] {  };

        ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {};
        return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);
    }
"	@param body client model	@param client client model	1	0	8	29	201
"Tuple2<Boolean, String> setFwkMetadata(String name, String sqlExpr, boolean createTable) throws SQLException { if (Boolean.getBoolean(NOAUTO_CREATE_METADATA)) return Tuple2.create(false, null); final SQLSystem sys = getServer().getSQLSystem(); final SQLSyntax syntax = sys.getSyntax(); final SQLDataSource ds = this.getDBSystemRoot().getDataSource(); synchronized (this.getTreeMutex()) { // don't refresh until after the insert, that way if the refresh triggers an access to // the metadata name will already be set to value. final boolean shouldRefresh; if (createTable && !this.contains(METADATA_TABLENAME)) { final SQLCreateMoveableTable create = getCreateMetadata(syntax); ds.execute(create.asString(getDBRoot().getName())); shouldRefresh = true; } else { shouldRefresh = false; } final Tuple2<Boolean, String> res; if (createTable || this.contains(METADATA_TABLENAME)) { // don't use SQLRowValues, cause it means getting the SQLTable and thus calling // fetchTables(), but setFwkMetadata() might itself be called by fetchTables() // furthermore SQLRowValues support only rowable tables final List<String> queries = new ArrayList<String>(); final SQLName tableName = new SQLName(this.getBase().getName(), this.getName(), METADATA_TABLENAME); final String where = "" WHERE "" + SQLBase.quoteIdentifier(""NAME"") + "" = "" + getBase().quoteString(name); queries.add(""DELETE FROM "" + tableName.quote() + where); final String returning = sys == SQLSystem.POSTGRESQL ? "" RETURNING "" + SQLBase.quoteIdentifier(""VALUE"") : """"; final String ins = syntax.getInsertOne(tableName, Arrays.asList(""NAME"", ""VALUE""), getBase().quoteString(name), sqlExpr) + returning; queries.add(ins); final List<? extends ResultSetHandler> handlers; if (returning.length() == 0) { queries.add(""SELECT "" + SQLBase.quoteIdentifier(""VALUE"") + "" FROM "" + tableName.quote() + where); handlers = Arrays.asList(null, null, SQLDataSource.SCALAR_HANDLER); } else { handlers = Arrays.asList(null, SQLDataSource.SCALAR_HANDLER); } final List<?> ress = SQLUtils.executeMultiple(getDBSystemRoot(), queries, handlers); res = Tuple2.create(true, (String) ress.get(ress.size() - 1)); } else { res = Tuple2.create(false, null); } if (shouldRefresh) this.fetchTable(METADATA_TABLENAME); return res; } }"	"    boolean setFwkMetadata(String name, String value, boolean createTable) throws SQLException {
        if (Boolean.getBoolean(NOAUTO_CREATE_METADATA))
            return false;

        synchronized (this.getTreeMutex()) {
            // don't refresh until after the insert, that way if the refresh triggers an access to
            // the metadata name will already be set to value.
            final boolean shouldRefresh;
            if (createTable && !this.contains(METADATA_TABLENAME)) {
                final SQLCreateMoveableTable create = getCreateMetadata(getServer().getSQLSystem().getSyntax());
                this.getBase().getDataSource().execute(create.asString(getDBRoot().getName()));
                shouldRefresh = true;
            } else
                shouldRefresh = false;

            final boolean res;
            if (createTable || this.contains(METADATA_TABLENAME)) {
                // don't use SQLRowValues, cause it means getting the SQLTable and thus calling
                // fetchTables(), but setFwkMetadata() might itself be called by fetchTables()
                // furthermore SQLRowValues support only rowable tables
                final SQLName tableName = new SQLName(this.getBase().getName(), this.getName(), METADATA_TABLENAME);
                final String del = SQLSelect.quote(""DELETE FROM %i WHERE %i = %s"", tableName, ""NAME"", name);
                final String ins = SQLSelect.quote(""INSERT INTO %i(%i,%i) VALUES(%s,%s)"", tableName, ""NAME"", ""VALUE"", name, value);
                SQLUtils.executeAtomic(this.getBase().getDataSource(), new SQLFactory<Object>() {
                    public Object create() throws SQLException {
                        getBase().getDataSource().execute(del);
                        getBase().getDataSource().execute(ins);
                        return null;
                    }
                });
                res = true;
            } else
                res = false;
            if (shouldRefresh)
                this.fetchTable(METADATA_TABLENAME);
            return res;
        }
    }
"	"@param sqlExpr SQL value of the metadata, e.g. ""'ACME, inc'""."	"@param value value of the metadata, eg ""ACME, inc""."	1	0	15	55	484
"public Mono<ModelApiResponse> uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws RestClientException { Object postBody = null; // verify the required parameter 'petId' is set if (petId == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'petId' when calling uploadFileWithRequiredFile""); } // verify the required parameter 'requiredFile' is set if (requiredFile == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile""); } // create path and map variables final Map<String, Object> uriVariables = new HashMap<String, Object>(); uriVariables.put(""petId"", petId); String path = UriComponentsBuilder.fromPath(""/fake/{petId}/uploadImageWithRequiredFile"").buildAndExpand(uriVariables).toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); if (additionalMetadata != null) formParams.add(""additionalMetadata"", additionalMetadata); if (requiredFile != null) formParams.add(""requiredFile"", new FileSystemResource(requiredFile)); final String[] accepts = { ""application/json"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { ""multipart/form-data"" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { ""petstore_auth"" }; ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {}; return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }"	"    public Mono<ModelApiResponse> uploadFileWithRequiredFile(Long petId, File file, String additionalMetadata) throws RestClientException {
        Object postBody = null;
        
        // verify the required parameter 'petId' is set
        if (petId == null) {
            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'petId' when calling uploadFileWithRequiredFile"");
        }
        
        // verify the required parameter 'file' is set
        if (file == null) {
            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'file' when calling uploadFileWithRequiredFile"");
        }
        
        // create path and map variables
        final Map<String, Object> uriVariables = new HashMap<String, Object>();
        uriVariables.put(""petId"", petId);
        String path = UriComponentsBuilder.fromPath(""/fake/{petId}/uploadImageWithRequiredFile"").buildAndExpand(uriVariables).toUriString();
        
        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();
        final HttpHeaders headerParams = new HttpHeaders();
        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();
        
        if (additionalMetadata != null)
            formParams.add(""additionalMetadata"", additionalMetadata);
        if (file != null)
            formParams.add(""file"", new FileSystemResource(file));

        final String[] accepts = { 
            ""application/json""
        };
        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);
        final String[] contentTypes = { 
            ""multipart/form-data""
        };
        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);

        String[] authNames = new String[] { ""petstore_auth"" };

        ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {};
        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);
    }
"	@param petId ID of pet to update	@param petId ID of pet to update	0	1	8	42	325
public Client testClientModel(Client body) throws IOException { HttpResponse response = testClientModelForHttpResponse(body); TypeReference typeRef = new TypeReference<Client>() {}; return apiClient.getObjectMapper().readValue(response.getContent(), typeRef); }	"    public Client testClientModel(Client client) throws IOException {
        HttpResponse response = testClientModelForHttpResponse(client);
        TypeReference typeRef = new TypeReference<Client>() {};
        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);
    }
"	@param body client model	@param client client model	1	0	8	6	43
private static CoreLabel createDatum(String token, String label, int index) { CoreLabel newTok = new CoreLabel(); newTok.set(CoreAnnotations.CharAnnotation.class, token); newTok.set(CoreAnnotations.AnswerAnnotation.class, label); newTok.set(CoreAnnotations.GoldAnswerAnnotation.class, label); newTok.setIndex(index); return newTok; }	"  private static CoreLabel createDatum(CoreLabel cl, String token, String label) {
    CoreLabel newTok = new CoreLabel();
    newTok.set(CoreAnnotations.TextAnnotation.class, token);
    newTok.set(CoreAnnotations.CharAnnotation.class, token);
    newTok.set(CoreAnnotations.AnswerAnnotation.class, label);
    newTok.set(CoreAnnotations.GoldAnswerAnnotation.class, label);
    if (cl != null && cl.containsKey(CoreAnnotations.DomainAnnotation.class))
      newTok.set(CoreAnnotations.DomainAnnotation.class,
                 cl.get(CoreAnnotations.DomainAnnotation.class));
    return newTok;
  }
"	@param token	@param cl	1	0	6	9	62
public static RequestQueue newRequestQueue(IRestProtocol implRestConnection, int threadPoolSize) { return newRequestQueue(RestParser.getInstance(implRestConnection), threadPoolSize); }	"    public static RequestQueue newRequestQueue(ImplRestConnection implRestConnection, int threadPoolSize) {
        return newRequestQueue(HttpRestParser.getInstance(implRestConnection), threadPoolSize);
    }
"	@param implRestConnection network operating interface, The implementation of the network layer.	@param implRestConnection network operating interface, The implementation of the network layer.	0	1	6	4	25
public static Point getCanvasTextLocation(Client client, Graphics2D graphics, LocalPoint localLocation, String text, int zOffset) { int plane = client.getPlane(); Point p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset); if (p == null) { return null; } FontMetrics fm = graphics.getFontMetrics(); Rectangle2D bounds = fm.getStringBounds(text, graphics); int xOffset = p.getX() - (int) (bounds.getWidth() / 2); return new Point(xOffset, p.getY()); }	"	public static Point getCanvasTextLocation(Client client, Graphics2D graphics, Point localLocation, String text, int zOffset)
	{
		int plane = client.getPlane();

		Point p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset);

		if (p == null)
		{
			return null;
		}

		FontMetrics fm = graphics.getFontMetrics();
		Rectangle2D bounds = fm.getStringBounds(text, graphics);
		int xOffset = p.getX() - (int) (bounds.getWidth() / 2);

		return new Point(xOffset, p.getY());
	}
"	@param text string for width measurement	@param text string for width measurement	0	1	8	18	109
"private static Consumer<List> mongoChecker(final String... expected) { return actual -> { if (expected == null) { Assert.assertThat(""null mongo Query"", actual, CoreMatchers.nullValue()); return; } if (expected.length == 0) { CalciteAssert.assertArrayEqual(""empty Mongo query"", expected, actual.toArray(new Object[0])); return; } final BsonDocument expectedBson = BsonDocument.parse(String.join("","", expected)); final BsonDocument actualBson = BsonDocument.parse(((List<?>) actual.get(0)) .stream() .map(Objects::toString) .collect(Collectors.joining(""\n""))); // compare Bson (not string) representation if (!expectedBson.equals(actualBson)) { final JsonWriterSettings settings = JsonWriterSettings.builder().indent(true).build(); // used to pretty print Assertion error Assert.assertEquals(""expected and actual Mongo queries do not match"", expectedBson.toJson(settings), actualBson.toJson(settings)); Assert.fail(""Should have failed previously because (expected != actual) is already known""); } }; }"	"  private static Consumer<List> mongoChecker(final String... strings) {
    return actual -> {
      Object[] actualArray =
          actual == null || actual.isEmpty()
              ? null
              : ((List) actual.get(0)).toArray();
      CalciteAssert.assertArrayEqual(""expected MongoDB query not found"",
          strings, actualArray);
    };
  }
"	@param expected Expected query (as array)	@param strings Expected expressions	1	0	11	31	223
public Object get(SharedSessionContractImplementor session, Object key, long txTimestamp) throws CacheException { if ( !region.checkValid() ) { return null; } final Object val = cache.get( key ); if ( val == null ) { putValidator.registerPendingPut(session, key, txTimestamp ); } return val; }	"	public Object get(SessionImplementor session, Object key, long txTimestamp) throws CacheException {
		if ( !region.checkValid() ) {
			return null;
		}
		final Object val = cache.get( key );
		if ( val == null ) {
			putValidator.registerPendingPut(session, key, txTimestamp );
		}
		return val;
	}
"	@param key The key of the item to be retrieved	@param key The key of the item to be retrieved	0	1	7	11	59
private RectF drawBoxWithShadow(Canvas c, int width, int height) { Resources res = mContext.getResources(); float shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur); float keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance); float corner = res.getDimension(R.dimen.widget_preview_corner_radius); RectF bounds = new RectF(shadowBlur, shadowBlur, width - shadowBlur, height - shadowBlur - keyShadowDistance); ShadowGenerator.drawShadow(c, bounds, Color.WHITE, shadowBlur, keyShadowDistance, corner); return bounds; }	"    private RectF drawBoxWithShadow(Canvas c, Paint p, int width, int height) {
        Resources res = mContext.getResources();
        float shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur);
        float keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance);
        float corner = res.getDimension(R.dimen.widget_preview_corner_radius);

        RectF bounds = new RectF(shadowBlur, shadowBlur,
                width - shadowBlur, height - shadowBlur - keyShadowDistance);
        p.setColor(Color.WHITE);

        // Key shadow
        p.setShadowLayer(shadowBlur, 0, keyShadowDistance,
                ShadowGenerator.KEY_SHADOW_ALPHA << 24);
        c.drawRoundRect(bounds, corner, corner, p);

        // Ambient shadow
        p.setShadowLayer(shadowBlur, 0, 0,
                ColorUtils.setAlphaComponent(Color.BLACK, ShadowGenerator.AMBIENT_SHADOW_ALPHA));
        c.drawRoundRect(bounds, corner, corner, p);

        p.clearShadowLayer();
        return bounds;
    }
"	@param info information about the widget	@param info information about the widget	0	1	8	12	92
public static int generateId(final String url, final String path) { return CustomComponentHolder.getImpl().getIdGeneratorInstance() .generateId(url, path, false); }	"    public static int generateId(final String url, final String path, final boolean pathAsDirectory) {
        return CustomComponentHolder.getImpl().getIdGeneratorInstance().generateId(url, path, pathAsDirectory);
    }
"	@param url The downloading URL.	@param url The downloading URL.	0	1	6	5	32
public ArrayList<View> getViews(View parent, boolean onlySufficientlyVisible) { final ArrayList<View> views = new ArrayList<View>(); final View parentToUse; if (parent == null){ inst.waitForIdleSync(); return getAllViews(onlySufficientlyVisible); }else{ parentToUse = parent; views.add(parentToUse); if (parentToUse instanceof ViewGroup) { addChildren(views, (ViewGroup) parentToUse, onlySufficientlyVisible); } } return views; }	"	public ArrayList<View> getViews(View parent, boolean onlyFullyVisible) {
		final ArrayList<View> views = new ArrayList<View>();
		final View parentToUse;

		if (parent == null){
			inst.waitForIdleSync();
			return getAllViews(onlyFullyVisible);
		}else{
			parentToUse = parent;

			views.add(parentToUse);

			if (parentToUse instanceof ViewGroup) {
				addChildren(views, (ViewGroup) parentToUse, onlyFullyVisible);
			}
		}


		return views;
	}
"	@param onlySufficientlyVisible if only sufficiently visible views should be returned	@param onlyFullyVisible if only fully visible views should be returned	1	0	10	21	80
private SQLResponse execute(String correctedSql, SQLRequest sqlRequest, Connection conn) throws Exception { Statement stat = null; ResultSet resultSet = null; Boolean isPushDown = false; List<List<String>> results = Lists.newArrayList(); List<SelectedColumnMeta> columnMetas = Lists.newArrayList(); try { // special case for prepare query. if (BackdoorToggles.getPrepareOnly()) { return getPrepareOnlySqlResponse(correctedSql, conn, isPushDown, results, columnMetas); } stat = conn.createStatement(); processStatementAttr(stat, sqlRequest); resultSet = stat.executeQuery(correctedSql); ResultSetMetaData metaData = resultSet.getMetaData(); int columnCount = metaData.getColumnCount(); // Fill in selected column meta for (int i = 1; i <= columnCount; ++i) { columnMetas.add(new SelectedColumnMeta(metaData.isAutoIncrement(i), metaData.isCaseSensitive(i), metaData.isSearchable(i), metaData.isCurrency(i), metaData.isNullable(i), metaData.isSigned(i), metaData.getColumnDisplaySize(i), metaData.getColumnLabel(i), metaData.getColumnName(i), metaData.getSchemaName(i), metaData.getCatalogName(i), metaData.getTableName(i), metaData.getPrecision(i), metaData.getScale(i), metaData.getColumnType(i), metaData.getColumnTypeName(i), metaData.isReadOnly(i), metaData.isWritable(i), metaData.isDefinitelyWritable(i))); } // fill in results while (resultSet.next()) { List<String> oneRow = Lists.newArrayListWithCapacity(columnCount); for (int i = 0; i < columnCount; i++) { oneRow.add((resultSet.getString(i + 1))); } results.add(oneRow); } } catch (SQLException sqlException) { isPushDown = PushDownUtil.doPushDownQuery(sqlRequest.getProject(), correctedSql, conn.getSchema(), results, columnMetas, sqlException); if (!isPushDown) { throw sqlException; } } finally { close(resultSet, stat, null);//conn is passed in, not my duty to close } return getSqlResponse(isPushDown, results, columnMetas); }	"    private SQLResponse execute(String correctedSql, SQLRequest sqlRequest) throws Exception {
        Connection conn = null;
        Statement stat = null;
        ResultSet resultSet = null;
        Boolean isPushDown = false;

        List<List<String>> results = Lists.newArrayList();
        List<SelectedColumnMeta> columnMetas = Lists.newArrayList();

        try {
            conn = QueryConnection.getConnection(sqlRequest.getProject());

            // special case for prepare query. 
            if (BackdoorToggles.getPrepareOnly()) {
                return getPrepareOnlySqlResponse(correctedSql, conn, isPushDown, results, columnMetas);
            }

            stat = conn.createStatement();
            processStatementAttr(stat, sqlRequest);
            resultSet = stat.executeQuery(correctedSql);

            ResultSetMetaData metaData = resultSet.getMetaData();
            int columnCount = metaData.getColumnCount();

            // Fill in selected column meta
            for (int i = 1; i <= columnCount; ++i) {
                columnMetas.add(new SelectedColumnMeta(metaData.isAutoIncrement(i), metaData.isCaseSensitive(i),
                        metaData.isSearchable(i), metaData.isCurrency(i), metaData.isNullable(i), metaData.isSigned(i),
                        metaData.getColumnDisplaySize(i), metaData.getColumnLabel(i), metaData.getColumnName(i),
                        metaData.getSchemaName(i), metaData.getCatalogName(i), metaData.getTableName(i),
                        metaData.getPrecision(i), metaData.getScale(i), metaData.getColumnType(i),
                        metaData.getColumnTypeName(i), metaData.isReadOnly(i), metaData.isWritable(i),
                        metaData.isDefinitelyWritable(i)));
            }

            // fill in results
            while (resultSet.next()) {
                List<String> oneRow = Lists.newArrayListWithCapacity(columnCount);
                for (int i = 0; i < columnCount; i++) {
                    oneRow.add((resultSet.getString(i + 1)));
                }

                results.add(oneRow);
            }
        } catch (SQLException sqlException) {
            isPushDown = PushDownUtil.doPushDownQuery(sqlRequest.getProject(), correctedSql, conn.getSchema(), results, columnMetas,
                    sqlException);
            if (!isPushDown) {
                throw sqlException;
            }
        } finally {
            close(resultSet, stat, conn);
        }

        return getSqlResponse(isPushDown, results, columnMetas);
    }
"	@param correctedSql	@param correctedSql	0	1	12	55	389
public List<WebElement> apply(WebDriver driver) { WebElement current = findElement(parent, driver); List<WebElement> allChildren = current.findElements(childLocator); // The original code only checked the first element. Fair enough. if (!allChildren.isEmpty() && allChildren.get(0).isDisplayed()) { return allChildren; } return null; }	"      public List<WebElement> apply(WebDriver webDriver) {
        Boolean displayed = false;
        Boolean exists = false;
        try {
          exists = findElement(locator, webDriver).findElements(sub_locator).size() > 0;
          displayed =
            findElement(locator, webDriver).findElement(sub_locator).isDisplayed();
        } catch (Exception e) {
          int i = 0;
        }
        return (exists && displayed) ?
               findElement(locator, webDriver).findElements(sub_locator) :
               null;
      }
"	"@param parent used to check parent element. For example table with locator By.id(""fish"")"	"@param locator used to check parent element. For example table with locator By.xpath(""//table"")"	1	0	6	12	66
private boolean paramAppend(StringBuilder sb, String name, String value, ParameterParser parser) { boolean isEdited = false; if (name != null) { sb.append(name); isEdited = true; } if (value != null) { sb.append(parser.getDefaultKeyValueSeparator()); sb.append(value); isEdited = true; } return isEdited; }	"    private boolean paramAppend(StringBuilder sb, String name, String value) {
        boolean isEdited = false;
        
        if (name != null) {
            sb.append(name);
            isEdited = true;
        }
        
        if (value != null) {
            sb.append('=');
            sb.append(value);
            isEdited = true;
        }
        
        return isEdited;
    }
"	@param value null = not to append parameter value.	@param value null = not to append parameter value.	0	1	7	17	68
public static BroadcasterFactory buildAndReplaceDefaultfactory(Class<? extends Broadcaster> clazz, AtmosphereServlet.AtmosphereConfig c) throws InstantiationException, IllegalAccessException { factory = new DefaultBroadcasterFactory(clazz); config = c; return factory; }	"    public static BroadcasterFactory buildAndReplaceDefaultfactory(Class<? extends Broadcaster> clazz, BroadcasterConfig config)
            throws InstantiationException, IllegalAccessException {

        factory = new DefaultBroadcasterFactory(clazz);
        return factory;
    }
"	@param clazz A class implementing  Broadcaster	@param clazz A class implementing Broadcaster	0	1	6	8	34
public int[] set(ReadablePartial partial, int fieldIndex, int[] values, int newValue) { FieldUtils.verifyValueBounds(this, newValue, getMinimumValue(partial, values), getMaximumValue(partial, values)); values[fieldIndex] = newValue; // may need to adjust smaller fields if (fieldIndex < partial.size()) { for (int i = fieldIndex + 1; i < partial.size(); i++) { DateTimeField field = partial.getField(i); if (values[i] > field.getMaximumValue(partial, values)) { values[i] = field.getMaximumValue(partial, values); } if (values[i] < field.getMinimumValue(partial, values)) { values[i] = field.getMinimumValue(partial, values); } } } return values; }	"    public int[] set(ReadablePartial instant, int fieldIndex, int[] values, int newValue) {
        FieldUtils.verifyValueBounds(this, newValue, getMinimumValue(instant, values), getMaximumValue(instant, values));
        values[fieldIndex] = newValue;
        
        // may need to adjust smaller fields
        if (fieldIndex < instant.getFieldSize()) {
            for (int i = fieldIndex + 1; i < instant.getFieldSize(); i++) {
                DateTimeField field = instant.getField(i);
                if (values[i] > field.getMaximumValue(instant, values)) {
                    values[i] = field.getMaximumValue(instant, values);
                }
                if (values[i] < field.getMinimumValue(instant, values)) {
                    values[i] = field.getMinimumValue(instant, values);
                }
            }
        }
        return values;
    }
"	@param partial the partial instant	@param instant the partial instant	1	0	13	19	155
"public static String uniquify(String name, Set<String> nameList) { if (name == null) { name = ""EXPR$""; } if (nameList.add(name)) { return name; } String aliasBase = name; for (int j = 0;; j++) { name = aliasBase + j; if (nameList.add(name)) { return name; } } }"	"    public static String uniquify(String name, Collection<String> nameList)
    {
        if (name == null) {
            name = ""EXPR$"";
        }
        if (nameList.contains(name)) {
            String aliasBase = name;
            for (int j = 0;; j++) {
                name = aliasBase + j;
                if (!nameList.contains(name)) {
                    break;
                }
            }
        }
        nameList.add(name);
        return name;
    }
"	@param nameList Collection of names already used	@param nameList Collection of names already used	0	1	8	17	75
"public ApiResponse<Client> testSpecialTagsWithHttpInfo(Client client) throws ApiException { Object localVarPostBody = client; // verify the required parameter 'client' is set if (client == null) { throw new ApiException(400, ""Missing the required parameter 'client' when calling testSpecialTags""); } // create path and map variables String localVarPath = ""/another-fake/dummy""; // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { ""application/json"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { ""application/json"" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Client> localVarReturnType = new GenericType<Client>() {}; return apiClient.invokeAPI(localVarPath, ""PATCH"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	"  public ApiResponse<Client> testSpecialTagsWithHttpInfo(Client body) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, ""Missing the required parameter 'body' when calling testSpecialTags"");
    }
    
    // create path and map variables
    String localVarPath = ""/another-fake/dummy"";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    final String[] localVarAccepts = {
      ""application/json""
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      ""application/json""
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    GenericType<Client> localVarReturnType = new GenericType<Client>() {};
    return apiClient.invokeAPI(localVarPath, ""PATCH"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);
      }
"	@param client client model (required)	@param body client model (required)	1	0	8	35	204
protected String getParameterDataType(Parameter parameter, Schema schema) { return null; }	"   protected String getParameterDataType(Parameter parameter, Property property) {
        return null;
   }
"	@param schema Schema	@param property	1	0	4	4	15
"public Mono<ModelApiResponse> uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws RestClientException { Object postBody = null; // verify the required parameter 'petId' is set if (petId == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'petId' when calling uploadFileWithRequiredFile""); } // verify the required parameter 'requiredFile' is set if (requiredFile == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile""); } // create path and map variables final Map<String, Object> uriVariables = new HashMap<String, Object>(); uriVariables.put(""petId"", petId); String path = UriComponentsBuilder.fromPath(""/fake/{petId}/uploadImageWithRequiredFile"").buildAndExpand(uriVariables).toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); if (additionalMetadata != null) formParams.add(""additionalMetadata"", additionalMetadata); if (requiredFile != null) formParams.add(""requiredFile"", new FileSystemResource(requiredFile)); final String[] accepts = { ""application/json"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { ""multipart/form-data"" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { ""petstore_auth"" }; ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {}; return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }"	"    public Mono<ModelApiResponse> uploadFileWithRequiredFile(Long petId, File file, String additionalMetadata) throws RestClientException {
        Object postBody = null;
        
        // verify the required parameter 'petId' is set
        if (petId == null) {
            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'petId' when calling uploadFileWithRequiredFile"");
        }
        
        // verify the required parameter 'file' is set
        if (file == null) {
            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'file' when calling uploadFileWithRequiredFile"");
        }
        
        // create path and map variables
        final Map<String, Object> uriVariables = new HashMap<String, Object>();
        uriVariables.put(""petId"", petId);
        String path = UriComponentsBuilder.fromPath(""/fake/{petId}/uploadImageWithRequiredFile"").buildAndExpand(uriVariables).toUriString();
        
        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();
        final HttpHeaders headerParams = new HttpHeaders();
        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();
        
        if (additionalMetadata != null)
            formParams.add(""additionalMetadata"", additionalMetadata);
        if (file != null)
            formParams.add(""file"", new FileSystemResource(file));

        final String[] accepts = { 
            ""application/json""
        };
        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);
        final String[] contentTypes = { 
            ""multipart/form-data""
        };
        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);

        String[] authNames = new String[] { ""petstore_auth"" };

        ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {};
        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);
    }
"	@param requiredFile file to upload	@param file file to upload	1	0	8	42	325
private boolean hasSingleValue(ColumnStatistics columnStatistics, long rowCount) { return columnStatistics != null && isSingleVal(columnStatistics, rowCount); }	"  private boolean hasSingleValue(ColumnMetadata columnChunkMetaData, long rowCount) {
    return (columnChunkMetaData != null) && (columnChunkMetaData.hasSingleValue(rowCount));
  }
"	@param columnStatistics metadata to check	@param columnChunkMetaData metadata to check	1	0	6	4	25
"public int[] add(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { if (valueToAdd == 0) { return values; } // there are more efficient algorithms than this (especially for time only fields) // trouble is when dealing with days and months, so we use this technique of // adding/removing one from the larger field at a time DateTimeField nextField = null; while (valueToAdd > 0) { int max = getMaximumValue(instant, values); long proposed = values[fieldIndex] + valueToAdd; if (proposed <= max) { values[fieldIndex] = (int) proposed; break; } if (nextField == null) { if (fieldIndex == 0) { throw new IllegalArgumentException(""Maximum value exceeded for add""); } nextField = instant.getField(fieldIndex - 1); if (getRangeDurationField() != nextField.getDurationField()) { throw new IllegalArgumentException(""Fields invalid for add""); } } valueToAdd -= (max + 1) - values[fieldIndex]; values = nextField.add(instant, fieldIndex - 1, values, 1); values[fieldIndex] = getMinimumValue(instant, values); } while (valueToAdd < 0) { int min = getMinimumValue(instant, values); long proposed = values[fieldIndex] + valueToAdd; if (proposed >= min) { values[fieldIndex] = (int) proposed; break; } if (nextField == null) { if (fieldIndex == 0) { throw new IllegalArgumentException(""Maximum value exceeded for add""); } nextField = instant.getField(fieldIndex - 1); if (getRangeDurationField() != nextField.getDurationField()) { throw new IllegalArgumentException(""Fields invalid for add""); } } valueToAdd -= (min - 1) - values[fieldIndex]; values = nextField.add(instant, fieldIndex - 1, values, -1); values[fieldIndex] = getMaximumValue(instant, values); } return set(instant, fieldIndex, values, values[fieldIndex]); // adjusts smaller fields }"	"    public int[] add(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd) {
        if (valueToAdd == 0) {
            return values;
        }
        // there are more efficient algorithms than this (especially for time only fields)
        // trouble is when dealing with days and months, so we use this technique of
        // adding/removing one from the larger field at a time
        DateTimeField nextField = null;
        
        while (valueToAdd > 0) {
            int max = getMaximumValue(instant, values);
            long proposed = values[fieldIndex] + valueToAdd;
            if (proposed <= max) {
                values[fieldIndex] = (int) proposed;
                break;
            }
            if (nextField == null) {
                if (fieldIndex == 0) {
                    throw new IllegalArgumentException(""Maximum value exceeded for add"");
                }
                nextField = instant.getField(fieldIndex - 1);
                if (getRangeDurationField() != nextField.getDurationField()) {
                    throw new IllegalArgumentException(""Fields invalid for add"");
                }
            }
            valueToAdd -= (max + 1) - values[fieldIndex];
            values = nextField.add(instant, fieldIndex - 1, values, 1);
            values[fieldIndex] = getMinimumValue(instant, values);
        }
        while (valueToAdd < 0) {
            int min = getMinimumValue(instant, values);
            long proposed = values[fieldIndex] + valueToAdd;
            if (proposed >= min) {
                values[fieldIndex] = (int) proposed;
                break;
            }
            if (nextField == null) {
                if (fieldIndex == 0) {
                    throw new IllegalArgumentException(""Maximum value exceeded for add"");
                }
                nextField = instant.getField(fieldIndex - 1);
                if (getRangeDurationField() != nextField.getDurationField()) {
                    throw new IllegalArgumentException(""Fields invalid for add"");
                }
            }
            valueToAdd -= (min - 1) - values[fieldIndex];
            values = nextField.add(instant, fieldIndex - 1, values, -1);
            values[fieldIndex] = getMaximumValue(instant, values);
        }
        
        return set(instant, fieldIndex, values, values[fieldIndex]);  // adjusts smaller fields
    }
"	@param valueToAdd the value to add, in the units of the field	@param valueToAdd the value to add, in the units of the field	0	1	11	53	389
"private HttpURLConnection createHttpURLConnection(IBasicRequest request) throws Exception { // 1.Pre operation notice request.onPreExecute(); // 2.Build URL String urlStr = request.url(); Logger.i(""Request address: "" + urlStr); URL url = new URL(urlStr); HttpURLConnection connection; Proxy proxy = request.getProxy(); if (proxy == null) connection = (HttpURLConnection) url.openConnection(); else connection = (HttpURLConnection) url.openConnection(proxy); connection.setConnectTimeout(request.getConnectTimeout()); connection.setReadTimeout(request.getReadTimeout()); connection.setInstanceFollowRedirects(false); if (connection instanceof HttpsURLConnection) { SSLSocketFactory sslSocketFactory = request.getSSLSocketFactory(); if (sslSocketFactory != null) ((HttpsURLConnection) connection).setSSLSocketFactory(sslSocketFactory); HostnameVerifier hostnameVerifier = request.getHostnameVerifier(); if (hostnameVerifier != null) ((HttpsURLConnection) connection).setHostnameVerifier(hostnameVerifier); } // 3. Base attribute RequestMethod requestMethod = request.getRequestMethod(); String requestMethodStr = requestMethod.toString(); Logger.i(""Request method: "" + requestMethodStr); // Fix delete patch error. try { connection.setRequestMethod(requestMethodStr); } catch (ProtocolException protocol) { try { Field methodField = connection.getClass().getDeclaredField(""method""); methodField.setAccessible(true); methodField.set(connection, requestMethodStr); } catch (Exception noSuchFieldIllegalAccess) { throw protocol; } } connection.setDoInput(true); connection.setDoOutput(requestMethod.allowRequestBody()); // 4.Set request headers setHeaders(url.toURI(), connection, request); // 5. Connect connection.connect(); return connection; }"	"    protected HttpURLConnection createHttpURLConnection(BasicServerRequest request) throws IOException, URISyntaxException {
        // 1.Pre operation notice
        request.onPreExecute();

        // 2.Build URL
        String urlStr = request.url();
        Logger.i(""Request address: "" + urlStr);
        URL url = new URL(urlStr);
        HttpURLConnection connection;
        Proxy proxy = request.getProxy();
        if (proxy == null)
            connection = (HttpURLConnection) url.openConnection();
        else
            connection = (HttpURLConnection) url.openConnection(proxy);

        connection.setConnectTimeout(request.getConnectTimeout());
        connection.setReadTimeout(request.getReadTimeout());
        connection.setInstanceFollowRedirects(false);

        if (connection instanceof HttpsURLConnection) {
            SSLSocketFactory sslSocketFactory = request.getSSLSocketFactory();
            if (sslSocketFactory != null)
                ((HttpsURLConnection) connection).setSSLSocketFactory(sslSocketFactory);
            HostnameVerifier hostnameVerifier = request.getHostnameVerifier();
            if (hostnameVerifier != null)
                ((HttpsURLConnection) connection).setHostnameVerifier(hostnameVerifier);
        }

        // 3. Base attribute
        RequestMethod requestMethod = request.getRequestMethod();
        Logger.i(""Request method: "" + requestMethod.toString());
        // Fix delete patch error.
        try {
            connection.setRequestMethod(requestMethod.toString());
        } catch (ProtocolException protocol) {
            try {
                Field methodField = connection.getClass().getDeclaredField(""method"");
                methodField.setAccessible(true);
                methodField.set(connection, requestMethod.toString());
            } catch (Exception noSuchFieldIllegalAccess) {
                throw protocol;
            }
        }

        connection.setDoInput(true);
        connection.setDoOutput(requestMethod.allowRequestBody());

        // 4.Set request headers
        URI uri = null;
        try {
            uri = url.toURI();
        } catch (URISyntaxException e) {
            Logger.w(e);
        }
        setHeaders(uri, connection, request);

        // 5. Connect
        connection.connect();

        // 6. Write request body
        if (requestMethod.allowRequestBody()) {
            Logger.i(""-------Send request data start-------"");
            OutputStream outputStream = IOUtils.toBufferedOutputStream(connection.getOutputStream());
            request.onWriteRequestBody(outputStream);
            IOUtils.flushQuietly(outputStream);
            IOUtils.closeQuietly(outputStream);
            Logger.i(""-------Send request data end-------"");
        }

        return connection;
    }
"	@param request  IBasicRequest.	@param request BasicServerRequest.	1	0	10	56	307
public static float length(float x, float y, float z) { return (float) Math.sqrt(length2(x, y, z)); }	"	public static double length(double x, double y, double z) {
		return Math.sqrt(length2(x, y, z));
	}
"	@param z float The z component.	@param z double The z component.	1	0	7	5	33
public static DownloadRequest createDownloadRequest(String url, RequestMethod requestMethod, String fileFolder, String filename, boolean isRange, boolean isDeleteOld) { return new RestDownloadRequestor(url, requestMethod, fileFolder, filename, isRange, isDeleteOld); }	"    public static DownloadRequest createDownloadRequest(String url, RequestMethod requestMethod, String fileFloder, String filename, boolean isRange, boolean isDeleteOld) {
        return new RestDownloadRequestor(url, requestMethod, fileFloder, filename, isRange, isDeleteOld);
    }
"	@param isRange Whether the breakpoint continuingly	@param isRange Whether the breakpoint continuingly	0	1	5	4	42
public static long durationNanos(int years, int months, int days, int hours, int minutes, long seconds) { return durationNanos(years, months, days, hours, minutes, seconds, 0); }	"    public static double durationNanos(int years, int months, int days, int hours, int minutes, double seconds) {
        return durationNanos(years, months, days, hours, minutes, seconds, 0);
    }
"	@param seconds a number of seconds	@param seconds a number of seconds from ChronoUnit#MONTHS is used.	1	0	5	4	43
"private SQLResponse execute(String correctedSql, SQLRequest sqlRequest) throws Exception { Connection conn = null; Statement stat = null; ResultSet resultSet = null; List<List<String>> results = Lists.newArrayList(); List<SelectedColumnMeta> columnMetas = Lists.newArrayList(); try { conn = cacheService.getOLAPDataSource(sqlRequest.getProject()).getConnection(); if (sqlRequest instanceof PrepareSqlRequest) { PreparedStatement preparedState = conn.prepareStatement(correctedSql); processStatementAttr(preparedState, sqlRequest); for (int i = 0; i < ((PrepareSqlRequest) sqlRequest).getParams().length; i++) { setParam(preparedState, i + 1, ((PrepareSqlRequest) sqlRequest).getParams()[i]); } resultSet = preparedState.executeQuery(); } else { stat = conn.createStatement(); processStatementAttr(stat, sqlRequest); resultSet = stat.executeQuery(correctedSql); } ResultSetMetaData metaData = resultSet.getMetaData(); int columnCount = metaData.getColumnCount(); // Fill in selected column meta for (int i = 1; i <= columnCount; ++i) { columnMetas.add(new SelectedColumnMeta(metaData.isAutoIncrement(i), metaData.isCaseSensitive(i), metaData.isSearchable(i), metaData.isCurrency(i), metaData.isNullable(i), metaData.isSigned(i), metaData.getColumnDisplaySize(i), metaData.getColumnLabel(i), metaData.getColumnName(i), metaData.getSchemaName(i), metaData.getCatalogName(i), metaData.getTableName(i), metaData.getPrecision(i), metaData.getScale(i), metaData.getColumnType(i), metaData.getColumnTypeName(i), metaData.isReadOnly(i), metaData.isWritable(i), metaData.isDefinitelyWritable(i))); } // fill in results while (resultSet.next()) { List<String> oneRow = Lists.newArrayListWithCapacity(columnCount); for (int i = 0; i < columnCount; i++) { oneRow.add((resultSet.getString(i + 1))); } results.add(oneRow); } } finally { close(resultSet, stat, conn); } boolean isPartialResult = false; String cube = """"; StringBuilder sb = new StringBuilder(""Scan count for each storageContext: ""); long totalScanCount = 0; if (OLAPContext.getThreadLocalContexts() != null) { // contexts can be null in case of 'explain plan for' for (OLAPContext ctx : OLAPContext.getThreadLocalContexts()) { if (ctx.realization != null) { isPartialResult |= ctx.storageContext.isPartialResultReturned(); cube = ctx.realization.getName(); totalScanCount += ctx.storageContext.getTotalScanCount(); sb.append(ctx.storageContext.getTotalScanCount() + "",""); } } } logger.info(sb.toString()); SQLResponse response = new SQLResponse(columnMetas, results, cube, 0, false, null, isPartialResult); response.setTotalScanCount(totalScanCount); return response; }"	"    private SQLResponse execute(String sql, SQLRequest sqlRequest) throws Exception {
        Connection conn = null;
        Statement stat = null;
        ResultSet resultSet = null;

        List<List<String>> results = Lists.newArrayList();
        List<SelectedColumnMeta> columnMetas = Lists.newArrayList();

        try {
            conn = cacheService.getOLAPDataSource(sqlRequest.getProject()).getConnection();

            if (sqlRequest instanceof PrepareSqlRequest) {
                PreparedStatement preparedState = conn.prepareStatement(sql);
                processStatementAttr(preparedState, sqlRequest);

                for (int i = 0; i < ((PrepareSqlRequest) sqlRequest).getParams().length; i++) {
                    setParam(preparedState, i + 1, ((PrepareSqlRequest) sqlRequest).getParams()[i]);
                }

                resultSet = preparedState.executeQuery();
            } else {
                stat = conn.createStatement();
                processStatementAttr(stat, sqlRequest);
                resultSet = stat.executeQuery(sql);
            }

            ResultSetMetaData metaData = resultSet.getMetaData();
            int columnCount = metaData.getColumnCount();

            // Fill in selected column meta
            for (int i = 1; i <= columnCount; ++i) {
                columnMetas.add(new SelectedColumnMeta(metaData.isAutoIncrement(i), metaData.isCaseSensitive(i), metaData.isSearchable(i), metaData.isCurrency(i), metaData.isNullable(i), metaData.isSigned(i), metaData.getColumnDisplaySize(i), metaData.getColumnLabel(i), metaData.getColumnName(i), metaData.getSchemaName(i), metaData.getCatalogName(i), metaData.getTableName(i), metaData.getPrecision(i), metaData.getScale(i), metaData.getColumnType(i), metaData.getColumnTypeName(i), metaData.isReadOnly(i), metaData.isWritable(i), metaData.isDefinitelyWritable(i)));
            }

            // fill in results
            while (resultSet.next()) {
                List<String> oneRow = Lists.newArrayListWithCapacity(columnCount);
                for (int i = 0; i < columnCount; i++) {
                    oneRow.add((resultSet.getString(i + 1)));
                }

                results.add(oneRow);
            }
        } finally {
            close(resultSet, stat, conn);
        }

        boolean isPartialResult = false;
        String cube = """";
        StringBuilder sb = new StringBuilder(""Scan count for each storageContext: "");
        long totalScanCount = 0;
        if (OLAPContext.getThreadLocalContexts() != null) { // contexts can be null in case of 'explain plan for'
            for (OLAPContext ctx : OLAPContext.getThreadLocalContexts()) {
                if (ctx.realization != null) {
                    isPartialResult |= ctx.storageContext.isPartialResultReturned();
                    cube = ctx.realization.getName();
                    totalScanCount += ctx.storageContext.getTotalScanCount();
                    sb.append(ctx.storageContext.getTotalScanCount() + "","");
                }
            }
        }
        logger.info(sb.toString());

        SQLResponse response = new SQLResponse(columnMetas, results, cube, 0, false, null, isPartialResult);
        response.setTotalScanCount(totalScanCount);

        return response;
    }
"	@param correctedSql	@param sql	1	0	12	69	534
"public String invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); b.append(""?""); if (queryParams != null){ for (Pair queryParam : queryParams){ if (!queryParam.getName().isEmpty()) { b.append(escapeString(queryParam.getName())); b.append(""=""); b.append(escapeString(queryParam.getValue())); b.append(""&""); } } } String querystring = b.substring(0, b.length() - 1); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(""GET"".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (""POST"".equals(method)) { if (contentType.startsWith(""application/x-www-form-urlencoded"")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (""PUT"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (""DELETE"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, ""unknown method type "" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return """"; } } else { String message = ""error""; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { // e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }"	"  public String invokeAPI(String path, String method, Set<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {
    updateParamsForAuth(authNames, queryParams, headerParams);

    Client client = getClient();

    StringBuilder b = new StringBuilder();
    b.append(""?"");
    if (queryParams != null){
      for (Pair queryParam : queryParams){
        if (!queryParam.getName().isEmpty()) {
          b.append(escapeString(queryParam.getName()));
          b.append(""="");
          b.append(escapeString(queryParam.getValue()));
          b.append(""&"");
        }
      }
    }

    String querystring = b.substring(0, b.length() - 1);

    Builder builder;
    if (accept == null)
      builder = client.resource(basePath + path + querystring).getRequestBuilder();
    else
      builder = client.resource(basePath + path + querystring).accept(accept);

    for(String key : headerParams.keySet()) {
      builder = builder.header(key, headerParams.get(key));
    }
    for(String key : defaultHeaderMap.keySet()) {
      if(!headerParams.containsKey(key)) {
        builder = builder.header(key, defaultHeaderMap.get(key));
      }
    }

    ClientResponse response = null;

    if(""GET"".equals(method)) {
      response = (ClientResponse) builder.get(ClientResponse.class);
    }
    else if (""POST"".equals(method)) {
      if (contentType.startsWith(""application/x-www-form-urlencoded"")) {
        String encodedFormParams = this
            .getXWWWFormUrlencodedParams(formParams);
        response = builder.type(contentType).post(ClientResponse.class,
            encodedFormParams);
      } else if (body == null) {
        response = builder.post(ClientResponse.class, null);
      } else if(body instanceof FormDataMultiPart) {
        response = builder.type(contentType).post(ClientResponse.class, body);
      }
      else
        response = builder.type(contentType).post(ClientResponse.class, serialize(body));
    }
    else if (""PUT"".equals(method)) {
      if (""application/x-www-form-urlencoded"".equals(contentType)) {
          String encodedFormParams = this
              .getXWWWFormUrlencodedParams(formParams);
          response = builder.type(contentType).put(ClientResponse.class,
              encodedFormParams);
      } else if(body == null) {
        response = builder.put(ClientResponse.class, serialize(body));
      } else {
          response = builder.type(contentType).put(ClientResponse.class, serialize(body));
      }
    }
    else if (""DELETE"".equals(method)) {
      if (""application/x-www-form-urlencoded"".equals(contentType)) {
        String encodedFormParams = this
            .getXWWWFormUrlencodedParams(formParams);
        response = builder.type(contentType).delete(ClientResponse.class,
            encodedFormParams);
      } else if(body == null) {
        response = builder.delete(ClientResponse.class);
      } else {
        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));
      }
    }
    else {
      throw new ApiException(500, ""unknown method type "" + method);
    }

    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {
      return null;
    }
    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {
      if(response.hasEntity()) {
        return (String) response.getEntity(String.class);
      }
      else {
        return """";
      }
    }
    else {
      String message = ""error"";
      String respBody = null;
      if(response.hasEntity()) {
        try{
          respBody = String.valueOf(response.getEntity(String.class));
          message = respBody;
        }
        catch (RuntimeException e) {
          // e.printStackTrace();
        }
      }
      throw new ApiException(
                response.getClientResponseStatus().getStatusCode(),
                message,
                response.getHeaders(),
                respBody);
    }
  }
"	@param formParams The form parameters	@param formParams The form parameters	0	1	16	113	736
public static BooleanOperation booleanOperation(Operator operator, Expression<?>... args) { return predicate(operator, args); }	"    public static BooleanOperation booleanOperation(Operator operation, Expression<?>... args) {
        return predicate(operation, args);
    }
"	@param args operation arguments	@param args	1	0	5	4	22
public static Criterion between(String propertyName, Object low, Object high) { return new BetweenExpression( propertyName, low, high ); }	"	public static Criterion between(String propertyName, Object lo, Object hi) {
		return new BetweenExpression( propertyName, lo, hi );
	}
"	@param propertyName The name of the property	@param propertyName The name of the property	0	1	5	4	27
"public int get(DateTimeFieldType type) { for (int i = 0, isize = size(); i < isize; i++) { if (getFieldType(i) == type) { return getValue(i); } } throw new IllegalArgumentException(""Field '"" + type + ""' is not supported""); }"	"    public int get(DateTimeField field) {
        for (int i = 0, isize = getFieldSize(); i < isize; i++) {
            if (getField(i) == field) {
                return getValue(i);
            }
        }
        throw new IllegalArgumentException(""Field '"" + field + ""' is not supported"");
    }
"	@param type a DateTimeFieldType instance that is supported by this partial	@param field a DateTimeField instance that is supported by this partial	1	0	9	9	64
"public int compareTo(ReadablePartial partial) { if (partial == null) { throw new IllegalArgumentException(""The instant must not be null""); } int thisValue = get(); int otherValue = partial.get(getFieldType()); if (thisValue < otherValue) { return -1; } else if (thisValue > otherValue) { return 1; } else { return 0; } }"	"    public int compareTo(ReadableInstant instant) {
        if (instant == null) {
            throw new IllegalArgumentException(""The instant must not be null"");
        }
        int thisValue = get();
        int otherValue = instant.get(getField());
        if (thisValue < otherValue) {
            return -1;
        } else if (thisValue > otherValue) {
            return 1;
        } else {
            return 0;
        }
    }
"	@param partial the partial to compare to	@param instant the instant to compare to	1	0	7	15	74
private void setCurrent(RelNode root, Correlate corRel) { currentRel = corRel; if (corRel != null) { cm = new CorelMapBuilder().build(Util.first(root, corRel)); } }	"  private void setCurrent(RelNode root, LogicalCorrelate corRel) {
    currentRel = corRel;
    if (corRel != null) {
      cm = new CorelMapBuilder().build(Util.first(root, corRel));
    }
  }
"	@param relBuilder Builder for relational expressions	@param relBuilder Builder for relational expressions	0	1	10	7	39
"private HttpSession getMatchingHttpSession(List<HttpCookie> cookies, final Set<String> tokens) { // Pre-checks if (sessions.isEmpty()) { return null; } List<HttpSession> matchingSessions = new LinkedList<>(sessions); for (String token : tokens) { // Get the corresponding cookie from the cookies list HttpCookie matchingCookie = null; for (HttpCookie cookie : cookies) { if (cookie.getName().equals(token)) { matchingCookie = cookie; break; } } // Filter the sessions that do not match the cookie value Iterator<HttpSession> it = matchingSessions.iterator(); while (it.hasNext()) { if (!it.next().matchesToken(token, matchingCookie)) { it.remove(); } } } // Return the matching session if (matchingSessions.size() >= 1) { if (matchingSessions.size() > 1) { log.warn(""Multiple sessions matching the cookies from response for site: "" + getSite() + "". Using first one.""); } return matchingSessions.get(0); } return null; }"	"	private HttpSession getMatchingHttpSession(List<HttpCookie> cookies, final HttpSessionTokensSet siteTokens) {

		return CookieBasedSessionManagementHelper.getMatchingHttpSession(sessions, cookies, siteTokens);
	}
"	@param tokens the tokens	@param siteTokens the tokens	1	0	11	38	204
public Tree prune(Filter<Tree> filter, TreeFactory tf) { // is the current node to be pruned? if ( ! filter.accept(this)) { return null; } // if not, recurse over all children List<Tree> l = new ArrayList<Tree>(); Tree[] kids = children(); for (int i = 0; i < kids.length; i++) { Tree prunedChild = kids[i].prune(filter, tf); if (prunedChild != null) { l.add(prunedChild); } } // and check if this node has lost all its children if (l.isEmpty() && !(kids.length == 0)) { return null; } // if we're still ok, copy the node if (isLeaf()) { return tf.newLeaf(label()); } return tf.newTreeNode(label(), l); }	"  public Tree prune(Predicate<Tree> filter, TreeFactory tf) {
    // is the current node to be pruned?
    if ( ! filter.test(this)) {
      return null;
    }
    // if not, recurse over all children
    List<Tree> l = new ArrayList<>();
    Tree[] kids = children();
    for (Tree kid : kids) {
      Tree prunedChild = kid.prune(filter, tf);
      if (prunedChild != null) {
        l.add(prunedChild);
      }
    }
    // and check if this node has lost all its children
    if (l.isEmpty() && !(kids.length == 0)) {
      return null;
    }
    // if we're still ok, copy the node
    if (isLeaf()) {
      return tf.newLeaf(label());
    }
    return tf.newTreeNode(label(), l);
  }
"	@param tf the TreeFactory to be used to make new Tree nodes if needed	@param tf the TreeFactory to be used to make new Tree nodes if needed	0	1	9	25	178
@CheckForNull public final SCMRevision fetch(@NonNull String thingName, @CheckForNull TaskListener listener) throws IOException, InterruptedException { return retrieve(thingName, defaultListener(listener)); }	"    @CheckForNull
    public final SCMRevision fetch(@NonNull String revision, @CheckForNull TaskListener listener)
            throws IOException, InterruptedException {
        return retrieve(revision, defaultListener(listener));
    }
"	@param thingName might be a branch name, a tag name, a cryptographic hash, a thingName number, etc.	@param revision might be a branch name, a tag name, a cryptographic hash, a revision number, etc.	1	0	6	7	34
public FluentWait<T> withTimeout(Duration timeout) { this.timeout = timeout; return this; }	"  public FluentWait<T> withTimeout(java.time.Duration timeout) {
    this.timeout = timeout;
    return this;
  }
"	@param timeout The timeout duration.	@param timeout The timeout duration.	0	1	6	5	17
"protected String getExample(Schema schema) { if (schema.getExample() != null) { return schema.getExample().toString(); } else if (ModelUtils.isDateTimeSchema(schema)) { return ""2000-01-23T04:56:07.000Z""; } else if (ModelUtils.isDateSchema(schema)) { return ""2000-01-23""; } else if (ModelUtils.isBooleanSchema(schema)) { return ""true""; } else if (ModelUtils.isNumberSchema(schema)) { if (ModelUtils.isFloatSchema(schema)) { // float return ""1.3579""; } else { // double return ""3.149""; } } else if (ModelUtils.isPasswordSchema(schema)) { return ""********""; } else if (ModelUtils.isUUIDSchema(schema)) { return ""046b6c7f-0b8a-43b9-b35d-6489e6daee91""; // do these last in case the specific types above are derived from these classes } else if (ModelUtils.isStringSchema(schema)) { return ""aeiou""; } else if (ModelUtils.isIntegerSchema(schema)) { if (ModelUtils.isLongSchema(schema)) { // long return ""123456789""; } else { //integer return ""123""; } } else { LOGGER.debug(""default example value not implemented for {}. Default to UNDEFINED_EXAMPLE_VALUE"", schema); return ""UNDEFINED_EXAMPLE_VALUE""; } }"	"    protected String getExample(Property property) {
        if (property.getExample() != null) {
            return property.getExample().toString();
        } else if (property instanceof DateTimeProperty) {
            return ""2000-01-23T04:56:07.000Z"";
        } else if (property instanceof DateProperty) {
            return ""2000-01-23"";
        } else if (property instanceof BooleanProperty) {
            return ""true"";
        } else if (property instanceof LongProperty) {
            return ""123456789"";
        } else if (property instanceof DoubleProperty) { // derived from DecimalProperty so make sure this is first
            return ""3.149"";
        }  else if (property instanceof DecimalProperty) {
            return ""1.3579"";
        } else if (property instanceof PasswordProperty) {
            return ""********"";
        } else if (property instanceof UUIDProperty) {
            return ""046b6c7f-0b8a-43b9-b35d-6489e6daee91"";
        // do these last in case the specific types above are derived from these classes
        } else if (property instanceof StringProperty) {
            return ""aeiou"";
        } else if (property instanceof BaseIntegerProperty) {
            return ""123"";
        } else if (property instanceof AbstractNumericProperty) {
            return ""1.23"";
        }
        LOGGER.warn(""default example value not implemented for "" + property);
        return """";
    }
"	@param schema Schema to get example string for	@param property Property to get example string for	1	0	16	34	279
public Client testClassname(Client client) throws ApiException { return testClassnameWithHttpInfo(client).getData(); }	"  public Client testClassname(Client body) throws ApiException {
    return testClassnameWithHttpInfo(body).getData();
      }
"	@param client client model (required)	@param body client model (required)	1	0	5	4	20
"public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); for(String key : queryParams.keySet()) { String value = queryParams.get(key); if (value != null){ if(b.toString().length() == 0) b.append(""?""); else b.append(""&""); b.append(escapeString(key)).append(""="").append(escapeString(value)); } } String querystring = b.toString(); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(""GET"".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (""POST"".equals(method)) { if (contentType.startsWith(""application/x-www-form-urlencoded"")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (""PUT"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (""DELETE"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, ""unknown method type "" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return """"; } } else { String message = ""error""; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { // e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }"	"  public String invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {
    updateParamsForAuth(authNames, queryParams, headerParams);

    Client client = getClient();

    StringBuilder b = new StringBuilder();
    b.append(""?"");
    if (queryParams != null){
      for (Pair queryParam : queryParams){
        if (!queryParam.getName().isEmpty()) {
          b.append(escapeString(queryParam.getName()));
          b.append(""="");
          b.append(escapeString(queryParam.getValue()));
          b.append(""&"");
        }
      }
    }

    String querystring = b.substring(0, b.length() - 1);

    Builder builder;
    if (accept == null)
      builder = client.resource(basePath + path + querystring).getRequestBuilder();
    else
      builder = client.resource(basePath + path + querystring).accept(accept);

    for(String key : headerParams.keySet()) {
      builder = builder.header(key, headerParams.get(key));
    }
    for(String key : defaultHeaderMap.keySet()) {
      if(!headerParams.containsKey(key)) {
        builder = builder.header(key, defaultHeaderMap.get(key));
      }
    }

    ClientResponse response = null;

    if(""GET"".equals(method)) {
      response = (ClientResponse) builder.get(ClientResponse.class);
    }
    else if (""POST"".equals(method)) {
      if (contentType.startsWith(""application/x-www-form-urlencoded"")) {
        String encodedFormParams = this
            .getXWWWFormUrlencodedParams(formParams);
        response = builder.type(contentType).post(ClientResponse.class,
            encodedFormParams);
      } else if (body == null) {
        response = builder.post(ClientResponse.class, null);
      } else if(body instanceof FormDataMultiPart) {
        response = builder.type(contentType).post(ClientResponse.class, body);
      }
      else
        response = builder.type(contentType).post(ClientResponse.class, serialize(body));
    }
    else if (""PUT"".equals(method)) {
      if (""application/x-www-form-urlencoded"".equals(contentType)) {
          String encodedFormParams = this
              .getXWWWFormUrlencodedParams(formParams);
          response = builder.type(contentType).put(ClientResponse.class,
              encodedFormParams);
      } else if(body == null) {
        response = builder.put(ClientResponse.class, serialize(body));
      } else {
          response = builder.type(contentType).put(ClientResponse.class, serialize(body));
      }
    }
    else if (""DELETE"".equals(method)) {
      if (""application/x-www-form-urlencoded"".equals(contentType)) {
        String encodedFormParams = this
            .getXWWWFormUrlencodedParams(formParams);
        response = builder.type(contentType).delete(ClientResponse.class,
            encodedFormParams);
      } else if(body == null) {
        response = builder.delete(ClientResponse.class);
      } else {
        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));
      }
    }
    else {
      throw new ApiException(500, ""unknown method type "" + method);
    }

    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {
      return null;
    }
    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {
      if(response.hasEntity()) {
        return (String) response.getEntity(String.class);
      }
      else {
        return """";
      }
    }
    else {
      String message = ""error"";
      String respBody = null;
      if(response.hasEntity()) {
        try{
          respBody = String.valueOf(response.getEntity(String.class));
          message = respBody;
        }
        catch (RuntimeException e) {
          // e.printStackTrace();
        }
      }
      throw new ApiException(
                response.getClientResponseStatus().getStatusCode(),
                message,
                response.getHeaders(),
                respBody);
    }
  }
"	@param formParams The form parameters	@param formParams The form parameters	0	1	16	111	730
public String createFileName(URL url, String prefixSubstitute, String substituteReplacement) { File file = new File(directory_prefix + File.separator + url.getFile()); return file.getAbsolutePath().replaceAll(prefixSubstitute, substituteReplacement); }	"    public String createFileName(URL url) {
        File file = new File(directory_prefix + File.separator + url.getFile());

        return file.getAbsolutePath();
    }
"	@param url URL of resource, which has been downloaded and shall be saved	@param url DOCUMENT ME!	1	0	8	6	43
public MultiIterator init(IteratorSource iteratorSource){ this.iteratorSource = iteratorSource; this.iterators = new Iterator<?>[sources.size()]; this.lastEntry = new boolean[iterators.length]; this.values = new Object[iterators.length]; return this; }	"    public MultiIterator init(IndexSupport indexSupport){
        this.indexSupport = indexSupport;
        this.iterators = new Iterator<?>[sources.size()];
        this.lastEntry = new boolean[iterators.length];
        this.values = new Object[iterators.length];
        return this;
    }
"	@param indexSupport	@param indexSupport	0	1	7	8	46
"InputStream openSourceFile(String path) throws IOException { if (path.startsWith(""gen/"")) { // generated file? String rest = path.substring(""gen/"".length()); File fileInGenDir = new File(getGenDir(), rest); if (!fileInGenDir.isFile()) { return null; } return new BufferedInputStream(new FileInputStream(fileInGenDir)); } else { // regular source file? URL resource = recompiler.getResourceLoader().getResource(path); if (resource == null) { return null; } return resource.openStream(); } }"	"  InputStream openSourceFile(String resourceName) throws IOException {
    URL resource = recompiler.getResourceLoader().getResource(resourceName);
    return resource == null ? null : resource.openStream();
  }
"	"@param path location of the file relative to its directory in the classpath, or (if it starts with ""gen/""), a generated file."	@param resourceName the relative path to a resource in the module's classpath.	1	0	9	21	114
public Single<Client> rxTestClassname(Client client) { return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> { delegate.testClassname(client, fut); })); }	"    public Single<Client> rxTestClassname(Client body) {
        return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> {
            delegate.testClassname(body, fut);
        }));
    }
"	@param client client model (required)	@param body client model (required)	1	0	10	6	36
private RexNode adjustCondition(LogicalProject project, LogicalJoin semiJoin) { // create two RexPrograms -- the bottom one representing a // concatenation of the project and the RHS of the semijoin and the // top one representing the semijoin condition RexBuilder rexBuilder = project.getCluster().getRexBuilder(); RelDataTypeFactory typeFactory = rexBuilder.getTypeFactory(); RelNode rightChild = semiJoin.getRight(); // for the bottom RexProgram, the input is a concatenation of the // child of the project and the RHS of the semijoin RelDataType bottomInputRowType = SqlValidatorUtil.deriveJoinRowType( project.getInput().getRowType(), rightChild.getRowType(), JoinRelType.INNER, typeFactory, null, semiJoin.getSystemFieldList()); RexProgramBuilder bottomProgramBuilder = new RexProgramBuilder(bottomInputRowType, rexBuilder); // add the project expressions, then add input references for the RHS // of the semijoin for (Pair<RexNode, String> pair : project.getNamedProjects()) { bottomProgramBuilder.addProject(pair.left, pair.right); } int nLeftFields = project.getInput().getRowType().getFieldCount(); List<RelDataTypeField> rightFields = rightChild.getRowType().getFieldList(); int nRightFields = rightFields.size(); for (int i = 0; i < nRightFields; i++) { final RelDataTypeField field = rightFields.get(i); RexNode inputRef = rexBuilder.makeInputRef( field.getType(), i + nLeftFields); bottomProgramBuilder.addProject(inputRef, field.getName()); } RexProgram bottomProgram = bottomProgramBuilder.getProgram(); // input rowtype into the top program is the concatenation of the // project and the RHS of the semijoin RelDataType topInputRowType = SqlValidatorUtil.deriveJoinRowType( project.getRowType(), rightChild.getRowType(), JoinRelType.INNER, typeFactory, null, semiJoin.getSystemFieldList()); RexProgramBuilder topProgramBuilder = new RexProgramBuilder( topInputRowType, rexBuilder); topProgramBuilder.addIdentity(); topProgramBuilder.addCondition(semiJoin.getCondition()); RexProgram topProgram = topProgramBuilder.getProgram(); // merge the programs and expand out the local references to form // the new semijoin condition; it now references a concatenation of // the project's child and the RHS of the semijoin RexProgram mergedProgram = RexProgramBuilder.mergePrograms( topProgram, bottomProgram, rexBuilder); return mergedProgram.expandLocalRef( mergedProgram.getCondition()); }	"  private RexNode adjustCondition(LogicalProject project, SemiJoin semiJoin) {
    // create two RexPrograms -- the bottom one representing a
    // concatenation of the project and the RHS of the semijoin and the
    // top one representing the semijoin condition

    RexBuilder rexBuilder = project.getCluster().getRexBuilder();
    RelDataTypeFactory typeFactory = rexBuilder.getTypeFactory();
    RelNode rightChild = semiJoin.getRight();

    // for the bottom RexProgram, the input is a concatenation of the
    // child of the project and the RHS of the semijoin
    RelDataType bottomInputRowType =
        SqlValidatorUtil.deriveJoinRowType(
            project.getInput().getRowType(),
            rightChild.getRowType(),
            JoinRelType.INNER,
            typeFactory,
            null,
            semiJoin.getSystemFieldList());
    RexProgramBuilder bottomProgramBuilder =
        new RexProgramBuilder(bottomInputRowType, rexBuilder);

    // add the project expressions, then add input references for the RHS
    // of the semijoin
    for (Pair<RexNode, String> pair : project.getNamedProjects()) {
      bottomProgramBuilder.addProject(pair.left, pair.right);
    }
    int nLeftFields = project.getInput().getRowType().getFieldCount();
    List<RelDataTypeField> rightFields =
        rightChild.getRowType().getFieldList();
    int nRightFields = rightFields.size();
    for (int i = 0; i < nRightFields; i++) {
      final RelDataTypeField field = rightFields.get(i);
      RexNode inputRef =
          rexBuilder.makeInputRef(
              field.getType(), i + nLeftFields);
      bottomProgramBuilder.addProject(inputRef, field.getName());
    }
    RexProgram bottomProgram = bottomProgramBuilder.getProgram();

    // input rowtype into the top program is the concatenation of the
    // project and the RHS of the semijoin
    RelDataType topInputRowType =
        SqlValidatorUtil.deriveJoinRowType(
            project.getRowType(),
            rightChild.getRowType(),
            JoinRelType.INNER,
            typeFactory,
            null,
            semiJoin.getSystemFieldList());
    RexProgramBuilder topProgramBuilder =
        new RexProgramBuilder(
            topInputRowType,
            rexBuilder);
    topProgramBuilder.addIdentity();
    topProgramBuilder.addCondition(semiJoin.getCondition());
    RexProgram topProgram = topProgramBuilder.getProgram();

    // merge the programs and expand out the local references to form
    // the new semijoin condition; it now references a concatenation of
    // the project's child and the RHS of the semijoin
    RexProgram mergedProgram =
        RexProgramBuilder.mergePrograms(
            topProgram,
            bottomProgram,
            rexBuilder);

    return mergedProgram.expandLocalRef(
        mergedProgram.getCondition());
  }
"	@param project LogicalProject on the LHS of the semijoin	@param project LogicalProject on the LHS of the semijoin	0	1	9	71	411
"public void updateUser (String username, User user) throws TimeoutException, ExecutionException, InterruptedException, ApiException { Object postBody = user; // verify the required parameter 'username' is set if (username == null) { VolleyError error = new VolleyError(""Missing the required parameter 'username' when calling updateUser"", new ApiException(400, ""Missing the required parameter 'username' when calling updateUser"")); } // verify the required parameter 'user' is set if (user == null) { VolleyError error = new VolleyError(""Missing the required parameter 'user' when calling updateUser"", new ApiException(400, ""Missing the required parameter 'user' when calling updateUser"")); } // create path and map variables String path = ""/user/{username}"".replaceAll(""\\{"" + ""username"" + ""\\}"", apiInvoker.escapeString(username.toString())); // query params List<Pair> queryParams = new ArrayList<Pair>(); // header params Map<String, String> headerParams = new HashMap<String, String>(); // form params Map<String, String> formParams = new HashMap<String, String>(); String[] contentTypes = { ""application/json"" }; String contentType = contentTypes.length > 0 ? contentTypes[0] : ""application/json""; if (contentType.startsWith(""multipart/form-data"")) { // file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); HttpEntity httpEntity = localVarBuilder.build(); postBody = httpEntity; } else { // normal form params } String[] authNames = new String[] { }; try { String localVarResponse = apiInvoker.invokeAPI (basePath, path, ""PUT"", queryParams, postBody, headerParams, formParams, contentType, authNames); if (localVarResponse != null) { return ; } else { return ; } } catch (ApiException ex) { throw ex; } catch (InterruptedException ex) { throw ex; } catch (ExecutionException ex) { if (ex.getCause() instanceof VolleyError) { VolleyError volleyError = (VolleyError)ex.getCause(); if (volleyError.networkResponse != null) { throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage()); } } throw ex; } catch (TimeoutException ex) { throw ex; } }"	"  public void updateUser (String username, User body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = body;
    // verify the required parameter 'username' is set
    if (username == null) {
      VolleyError error = new VolleyError(""Missing the required parameter 'username' when calling updateUser"",
        new ApiException(400, ""Missing the required parameter 'username' when calling updateUser""));
    }
    // verify the required parameter 'body' is set
    if (body == null) {
      VolleyError error = new VolleyError(""Missing the required parameter 'body' when calling updateUser"",
        new ApiException(400, ""Missing the required parameter 'body' when calling updateUser""));
    }

    // create path and map variables
    String path = ""/user/{username}"".replaceAll(""\\{"" + ""username"" + ""\\}"", apiInvoker.escapeString(username.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : ""application/json"";

    if (contentType.startsWith(""multipart/form-data"")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, ""PUT"", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return ;
      } else {
         return ;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }
"	@param user Updated user object	@param body Updated user object	1	0	11	62	441
public static TupleMetadata expandMetadata(TupleMetadata base, ImplicitColumnManager metadataProj, int dirCount) { TupleMetadata metadataSchema = new TupleSchema(); for (ColumnMetadata col : base) { metadataSchema.addColumn(col); } for (FileMetadataColumnDefn fileColDefn : metadataProj.fileMetadataColDefns()) { metadataSchema.add(MaterializedField.create(fileColDefn.colName(), fileColDefn.dataType())); } for (int i = 0; i < dirCount; i++) { metadataSchema.add(MaterializedField.create(metadataProj.partitionName(i), PartitionColumn.dataType())); } return metadataSchema; }	"  public static TupleMetadata expandMetadata(TupleMetadata base, FileMetadataManager metadataProj, int dirCount) {
    TupleMetadata metadataSchema = new TupleSchema();
    for (ColumnMetadata col : base) {
      metadataSchema.addColumn(col);
    }
    for (FileMetadataColumnDefn fileColDefn : metadataProj.fileMetadataColDefns()) {
      metadataSchema.add(MaterializedField.create(fileColDefn.colName(), fileColDefn.dataType()));
    }
    for (int i = 0; i < dirCount; i++) {
      metadataSchema.add(MaterializedField.create(metadataProj.partitionName(i),
          PartitionColumn.dataType()));
    }
    return metadataSchema;
  }
"	@param base the table part of the expansion	@param base the table part of the expansion	0	1	9	15	105
public boolean searchEditText(String text) { boolean found = searcher.searchWithTimeoutFor(EditText.class, text, 1, true); return found; }	"	public boolean searchEditText(String search) {
		boolean found = searcher.searchWithTimeoutFor(EditText.class, search, 1, true);
		return found;
	}
"	@param text the text to search for	@param search the search string to be searched	1	0	7	5	27
public static MemberID parse(String memberID, boolean isClassMember) { return parse(memberID, isClassMember, null); }	"    public static MemberID parse(String signature, boolean isClassMember) {
        return parse(signature, isClassMember, null);
    }
"	@param isClassMember If the ID is ambiguous, if true always assume that the last simple member name is a method or field, else assume it is a class name.	@param isClassMember If the signature is ambiguous, if true always assume that the last simple member name is a method or field, else assume it is a class name.	1	0	5	5	23
"ChromeResponse execute(DriverCommand driverCommand, Object... parameters) { Command command = new Command(new SessionId(""[No sessionId]""), new Context(""[No context]""), driverCommand, parameters); try { return executor.execute(command); } catch (Exception e) { if (e instanceof IllegalArgumentException || e instanceof FatalChromeException) { //These exceptions may leave the extension hung, or in an //inconsistent state, so we restart Chrome stopClient(); init(); } if (e instanceof RuntimeException) { throw (RuntimeException)e; } else { throw new WebDriverException(e); } } }"	"  ChromeResponse execute(String commandName, Object... parameters) {
    Command command = new Command(new SessionId(""[No sessionId]""),
                                  new Context(""[No context]""),
                                  commandName,
                                  parameters);
    try {
      return executor.execute(command);
    } catch (Exception e) {
      if (e instanceof IllegalArgumentException ||
          e instanceof FatalChromeException) {
        //These exceptions may leave the extension hung, or in an
        //inconsistent state, so we restart Chrome
        /*if (e instanceof FatalChromeException) {
          try { Thread.sleep(100000000); } catch (InterruptedException e2) {}
        }*/
        stopClient();
        init();
      }
      if (e instanceof RuntimeException) {
        throw (RuntimeException)e;
      } else {
        throw new WebDriverException(e);
      }
    }
  }
"	@param driverCommand command to execute	@param commandName command to execute	1	0	9	23	127
"public List<String> dependencyPathBetween(int start, int end, Optional<Function<Sentence, List<String>>> selector) { // Get paths from a node to the root of the sentence LinkedList<Integer> rootToStart = new LinkedList<>(); LinkedList<Integer> rootToEnd = new LinkedList<>(); int startAncestor = start; List<Optional<Integer>> governors = sentence.governors(); Set<Integer> seenVertices = new HashSet<>(); while (startAncestor >= 0 && governors.get(startAncestor).isPresent()) { if (seenVertices.contains(startAncestor)) { // Found loopiness -- revert to BFS return loopyDependencyPathBetween(start, end, selector); } seenVertices.add(startAncestor); rootToStart.addFirst(startAncestor); startAncestor = governors.get(startAncestor).get(); } if (startAncestor == -1) { rootToStart.addFirst(-1); } int endAncestor = end; seenVertices.clear(); while (endAncestor >= 0 && governors.get(endAncestor).isPresent()) { if (seenVertices.contains(endAncestor)) { // Found loopiness -- revert to BFS return loopyDependencyPathBetween(start, end, selector); } seenVertices.add(endAncestor); rootToEnd.addFirst(endAncestor); endAncestor = governors.get(endAncestor).get(); } if (endAncestor == -1) { rootToEnd.addFirst(-1); } // Get least common node int leastCommonNodeIndex = (rootToStart.size() == 0 || rootToEnd.size() == 0 || !rootToStart.get(0).equals(rootToEnd.get(0))) ? -1 : 0; for (int i = 1; i < Math.min(rootToStart.size(), rootToEnd.size()); ++i) { if (rootToStart.get(i).equals(rootToEnd.get(i))) { leastCommonNodeIndex = i; } } // Construct the path if (leastCommonNodeIndex < 0) { return Collections.emptyList(); } List<String> path = new ArrayList<>(); Optional<List<String>> words = selector.map(x -> x.apply(sentence)); for (int i = rootToStart.size() - 1; i > leastCommonNodeIndex; --i) { final int index = i; words.ifPresent(x -> path.add(x.get(rootToStart.get(index)))); path.add(""<-"" + sentence.incomingDependencyLabel(rootToStart.get(i)).orElse(""dep"") + ""-""); } if (words.isPresent()) { path.add(words.get().get(rootToStart.get(leastCommonNodeIndex))); } for (int i = leastCommonNodeIndex + 1; i < rootToEnd.size(); ++i) { final int index = i; path.add(""-"" + sentence.incomingDependencyLabel(rootToEnd.get(i)).orElse(""dep"") + ""->""); words.ifPresent(x -> path.add(x.get(rootToEnd.get(index)))); } return path; }"	"  public List<String> dependencyPathBetween(int start, int end, Function<Sentence, List<String>> selector) {
    // Get paths from a node to the root of the sentence
    LinkedList<Integer> rootToStart = new LinkedList<>();
    LinkedList<Integer> rootToEnd = new LinkedList<>();
    int startAncestor = start;
    List<Optional<Integer>> governors = sentence.governors();
    Set<Integer> seenVertices = new HashSet<>();
    while (startAncestor >= 0 && governors.get(startAncestor).isPresent()) {
      if (seenVertices.contains(startAncestor)) {
        return Collections.EMPTY_LIST;
      }
      seenVertices.add(startAncestor);
      rootToStart.addFirst(startAncestor);
      startAncestor = governors.get(startAncestor).get();
    }
    if (startAncestor == -1) {
      rootToStart.addFirst(-1);
    }
    int endAncestor = end;
    seenVertices.clear();
    while (endAncestor >= 0 && governors.get(endAncestor).isPresent()) {
      if (seenVertices.contains(endAncestor)) {
        return Collections.EMPTY_LIST;
      }
      seenVertices.add(endAncestor);
      rootToEnd.addFirst(endAncestor);
      endAncestor = governors.get(endAncestor).get();
    }
    if (endAncestor == -1) {
      rootToEnd.addFirst(-1);
    }

    // Get least common node
    int leastCommonNodeIndex = (rootToStart.size() == 0 || rootToEnd.size() == 0 || !rootToStart.get(0).equals(rootToEnd.get(0))) ? -1 : 0;
    for (int i = 1; i < Math.min(rootToStart.size(), rootToEnd.size()); ++i) {
      if (rootToStart.get(i).equals(rootToEnd.get(i))) {
        leastCommonNodeIndex = i;
      }
    }

    // Construct the path
    if (leastCommonNodeIndex < 0) {
      return Collections.EMPTY_LIST;
    }
    List<String> path = new ArrayList<>();
    for (int i = rootToStart.size() - 1; i > leastCommonNodeIndex; --i) {
      path.add(selector.apply(sentence).get(rootToStart.get(i)));
      path.add(""<-"" + sentence.incomingDependencyLabel(rootToStart.get(i)).orElse(""dep"") + ""-"");
    }
    path.add(selector.apply(sentence).get(rootToStart.get(leastCommonNodeIndex)));
    for (int i = leastCommonNodeIndex + 1; i < rootToEnd.size(); ++i) {
      path.add(""-"" + sentence.incomingDependencyLabel(rootToEnd.get(i)).orElse(""dep"") + ""->"");
      path.add(selector.apply(sentence).get(rootToEnd.get(i)));
    }
    return path;
  }
"	@param end The end word, 0-indexed.	@param selector The property of the sentence we are getting the mode of. For example, Sentence::posTags	1	0	11	64	555
"public Order getOrderById (Long orderId) throws ApiException { Object postBody = null; // verify the required parameter 'orderId' is set if (orderId == null) { throw new ApiException(400, ""Missing the required parameter 'orderId' when calling getOrderById""); } // create path and map variables String path = ""/store/order/{orderId}"".replaceAll(""\\{format\\}"",""json"").replaceAll(""\\{"" + ""orderId"" + ""\\}"", apiInvoker.escapeString(orderId.toString())); // query params List<Pair> queryParams = new ArrayList<Pair>(); // header params Map<String, String> headerParams = new HashMap<String, String>(); // form params Map<String, String> formParams = new HashMap<String, String>(); String[] contentTypes = { }; String contentType = contentTypes.length > 0 ? contentTypes[0] : ""application/json""; if (contentType.startsWith(""multipart/form-data"")) { // file uploading MultipartEntityBuilder builder = MultipartEntityBuilder.create(); HttpEntity httpEntity = builder.build(); postBody = httpEntity; } else { // normal form params } try { String response = apiInvoker.invokeAPI(basePath, path, ""GET"", queryParams, postBody, headerParams, formParams, contentType); if(response != null){ return (Order) ApiInvoker.deserialize(response, """", Order.class); } else { return null; } } catch (ApiException ex) { throw ex; } }"	"  public Order  getOrderById (String orderId) throws ApiException {
    Object postBody = null;
    
    // verify the required parameter 'orderId' is set
    if (orderId == null) {
       throw new ApiException(400, ""Missing the required parameter 'orderId' when calling getOrderById"");
    }
    

    // create path and map variables
    String path = ""/store/order/{orderId}"".replaceAll(""\\{format\\}"",""json"").replaceAll(""\\{"" + ""orderId"" + ""\\}"", apiInvoker.escapeString(orderId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    

    

    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : ""application/json"";

    if (contentType.startsWith(""multipart/form-data"")) {
      // file uploading
      MultipartEntityBuilder builder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = builder.build();
      postBody = httpEntity;
    } else {
      // normal form params
      
    }

    try {
      String response = apiInvoker.invokeAPI(basePath, path, ""GET"", queryParams, postBody, headerParams, formParams, contentType);
      if(response != null){
        return (Order) ApiInvoker.deserialize(response, """", Order.class);
      }
      else {
        return null;
      }
    } catch (ApiException ex) {
      throw ex;
    }
  }
"	@param orderId ID of pet that needs to be fetched	@param orderId ID of pet that needs to be fetched	0	1	10	53	299
"String evaluate(String url, String host) throws ScriptException { try { return (String) pacImpl.invokeFunction(""FindProxyForURL"", url, host); } catch (NoSuchMethodException | ScriptAbuseException e) { throw new ScriptException(e); } }"	"    public String evaluate(String destURL, String destHost) throws ScriptException {
        try {
            return (String) pacImpl.invokeFunction(""FindProxyForURL"", destURL, destHost);
        } catch (NoSuchMethodException | ScriptAbuseException e) {
            throw new ScriptException(e);
        }
    }
"	@param url the url param of FindProxyForURL(url, host)	@param destURL the url param of FindProxyForURL(url, host)	1	0	7	8	48
"public Order placeOrder(Order order) throws RestClientException { Object postBody = order; // verify the required parameter 'order' is set if (order == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'order' when calling placeOrder""); } String path = UriComponentsBuilder.fromPath(""/store/order"").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { ""application/xml"", ""application/json"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<Order> returnType = new ParameterizedTypeReference<Order>() {}; return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }"	"    public Order placeOrder(Order body) throws RestClientException {
        Object postBody = body;
        
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'body' when calling placeOrder"");
        }
        
        String path = UriComponentsBuilder.fromPath(""/store/order"").build().toUriString();
        
        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();
        final HttpHeaders headerParams = new HttpHeaders();
        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();

        final String[] accepts = { 
            ""application/xml"", ""application/json""
        };
        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);
        final String[] contentTypes = { };
        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);

        String[] authNames = new String[] {  };

        ParameterizedTypeReference<Order> returnType = new ParameterizedTypeReference<Order>() {};
        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);
    }
"	@param order order placed for purchasing the pet	@param body order placed for purchasing the pet	1	0	8	27	203
"public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); final String url = buildUrl(path, queryParams); final Request.Builder reqBuilder = new Request.Builder().url(url); processHeaderParams(headerParams, reqBuilder); String contentType = (String) headerParams.get(""Content-Type""); // ensuring a default content type if (contentType == null) contentType = ""application/json""; RequestBody reqBody; if (!HttpMethod.permitsRequestBody(method)) { reqBody = null; } else if (""application/x-www-form-urlencoded"".equals(contentType)) { reqBody = buildRequestBodyFormEncoding(formParams); } else if (""multipart/form-data"".equals(contentType)) { reqBody = buildRequestBodyMultipart(formParams); } else if (body == null) { if (""DELETE"".equals(method)) { // allow calling DELETE without sending a request body reqBody = null; } else { // use an empty request body (for POST, PUT and PATCH) reqBody = RequestBody.create(MediaType.parse(contentType), """"); } } else { reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType)); } Request request = reqBuilder.method(method, reqBody).build(); return httpClient.newCall(request); }"	"  public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
    updateParamsForAuth(authNames, queryParams, headerParams);

    final String url = buildUrl(path, queryParams);
    final Request.Builder reqBuilder = new Request.Builder().url(url);
    processHeaderParams(headerParams, reqBuilder);

    String contentType = (String) headerParams.get(""Content-Type"");
    // ensuring a default content type
    if (contentType == null) {
      contentType = ""application/json"";
    }

    RequestBody reqBody;
    if (!HttpMethod.permitsRequestBody(method)) {
      reqBody = null;
    } else if (""application/x-www-form-urlencoded"".equals(contentType)) {
      reqBody = buildRequestBodyFormEncoding(formParams);
    } else if (""multipart/form-data"".equals(contentType)) {
      reqBody = buildRequestBodyMultipart(formParams);
    } else if (body == null) {
      if (""DELETE"".equals(method)) {
        // allow calling DELETE without sending a request body
        reqBody = null;
      } else {
        // use an empty request body (for POST, PUT and PATCH)
        reqBody = RequestBody.create(MediaType.parse(contentType), """");
      }
    } else {
      reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType));
    }

    Request request = null;

    if(progressRequestListener != null && reqBody != null) {
      ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, progressRequestListener);
      request = reqBuilder.method(method, progressRequestBody).build();
    } else {
      request = reqBuilder.method(method, reqBody).build();
    }

    return httpClient.newCall(request);
  }
"	@param authNames The authentications to apply	@param authNames The authentications to apply	0	1	14	34	285
"public static RemoteProxy getNewBasicRemoteProxy(String browser, String url, GridRegistry registry) throws MalformedURLException { GridNodeConfiguration config = new GridNodeConfiguration(); URL u = new URL(url); config.host = u.getHost(); config.port = u.getPort(); config.role = ""webdriver""; RegistrationRequest req = RegistrationRequest.build(config); req.getConfiguration().capabilities.clear(); DesiredCapabilities capability = new DesiredCapabilities(); capability.setBrowserName(browser); req.getConfiguration().capabilities.add(capability); return createProxy(registry, req); }"	"  public static RemoteProxy getNewBasicRemoteProxy(String browser, String url, Registry registry) throws MalformedURLException {

    GridNodeConfiguration config = new GridNodeConfiguration();
    URL u = new URL(url);
    config.host = u.getHost();
    config.port = u.getPort();
    config.role = ""webdriver"";
    RegistrationRequest req = RegistrationRequest.build(config);
    req.getConfiguration().capabilities.clear();

    DesiredCapabilities capability = new DesiredCapabilities();
    capability.setBrowserName(browser);
    req.getConfiguration().capabilities.add(capability);

    return createProxy(registry, req);

  }
"	@param browser	@param browser	0	1	6	18	101
public Boolean fakeOuterBooleanSerialize(Boolean booleanPostBody) throws ApiException { return fakeOuterBooleanSerializeWithHttpInfo(booleanPostBody).getData(); }	"  public Boolean fakeOuterBooleanSerialize(Boolean body) throws ApiException {
    return fakeOuterBooleanSerializeWithHttpInfo(body).getData();
      }
"	@param booleanPostBody Input boolean as post body (optional)	@param body Input boolean as post body (optional)	1	0	5	4	20
"public boolean putFromLoad(SharedSessionContractImplementor session, Object key, Object value, long txTimestamp, Object version, boolean minimalPutOverride) throws CacheException { if ( !region.checkValid() ) { if ( TRACE_ENABLED ) { log.tracef( ""Region %s not valid"", region.getName() ); } return false; } // In theory, since putForExternalRead is already as minimal as it can // get, we shouldn't be need this check. However, without the check and // without https://issues.jboss.org/browse/ISPN-1986, it's impossible to // know whether the put actually occurred. Knowing this is crucial so // that Hibernate can expose accurate statistics. if ( minimalPutOverride && cache.containsKey( key ) ) { return false; } PutFromLoadValidator.Lock lock = putValidator.acquirePutFromLoadLock(session, key, txTimestamp); if ( lock == null) { if ( TRACE_ENABLED ) { log.tracef( ""Put from load lock not acquired for key %s"", key ); } return false; } try { writeCache.putForExternalRead( key, value ); } finally { putValidator.releasePutFromLoadLock( key, lock); } return true; }"	"	public boolean putFromLoad(SessionImplementor session, Object key, Object value, long txTimestamp, Object version, boolean minimalPutOverride)
			throws CacheException {
		if ( !region.checkValid() ) {
			if ( TRACE_ENABLED ) {
				log.tracef( ""Region %s not valid"", region.getName() );
			}
			return false;
		}

		// In theory, since putForExternalRead is already as minimal as it can
		// get, we shouldn't be need this check. However, without the check and
		// without https://issues.jboss.org/browse/ISPN-1986, it's impossible to
		// know whether the put actually occurred. Knowing this is crucial so
		// that Hibernate can expose accurate statistics.
		if ( minimalPutOverride && cache.containsKey( key ) ) {
			return false;
		}

		PutFromLoadValidator.Lock lock = putValidator.acquirePutFromLoadLock(session, key, txTimestamp);
		if ( lock == null) {
			if ( TRACE_ENABLED ) {
				log.tracef( ""Put from load lock not acquired for key %s"", key );
			}
			return false;
		}

		try {
			writeCache.putForExternalRead( key, value );
		}
		finally {
			putValidator.releasePutFromLoadLock( key, lock);
		}

		return true;
	}
"	@param version the item version number	@param version the item version number	0	1	9	36	226
public boolean waitForSpace(long timeout, int highWaterMark) throws InterruptedException { if (parent != null) { if (!parent.waitForSpace(timeout, highWaterMark)) { return false; } } synchronized (usageMutex) { percentUsage=caclPercentUsage(); if (percentUsage >= highWaterMark) { long deadline = timeout > 0 ? System.currentTimeMillis() + timeout : Long.MAX_VALUE; long timeleft = deadline; while (timeleft > 0) { percentUsage=caclPercentUsage(); if (percentUsage >= highWaterMark) { usageMutex.wait(pollingTime); timeleft = deadline - System.currentTimeMillis(); } else { break; } } } return percentUsage < highWaterMark; } }	"    public boolean waitForSpace(long timeout) throws InterruptedException {
        if (parent != null) {
            if (!parent.waitForSpace(timeout)) {
                return false;
            }
        }
        synchronized (usageMutex) {
            percentUsage=caclPercentUsage();
            if (percentUsage >= 100) {
                long deadline = timeout > 0 ? System.currentTimeMillis() + timeout : Long.MAX_VALUE;
                long timeleft = deadline;
                while (timeleft > 0) {
                    percentUsage=caclPercentUsage();
                    if (percentUsage >= 100) {
                        usageMutex.wait(pollingTime);
                        timeleft = deadline - System.currentTimeMillis();
                    } else {
                        break;
                    }
                }
            }
            return percentUsage < 100;
        }
    }
"	@param timeout	@param timeout	0	1	13	25	117
"static public IStructuredTextExpert getStatefulExpert(String type, StructuredTextEnvironment environment) { StructuredTextTypeHandler handler = StructuredTextTypeHandlerFactory.getHandler(type); if (handler == null) throw new IllegalArgumentException(""Invalid type argument""); //$NON-NLS-1$ return getStatefulExpert(handler, environment); }"	"	static public ISTextExpert getStatefulExpert(String type, STextEnvironment environment) {
		STextTypeHandler handler = STextTypeHandlerFactory.getHandler(type);
		if (handler == null)
			throw new IllegalArgumentException(""Invalid type argument""); //$NON-NLS-1$
		return getStatefulExpert(handler, environment);
	}
"	@param environment the current environment, which may affect the behavior of the expert. This parameter may be specified as null, in which case the  StructuredTextEnvironment#DEFAULT environment should be assumed.	@param environment the current environment, which may affect the behavior of the expert. This parameter may be specified as null, in which case the STextEnvironment#DEFAULT environment should be assumed.	1	0	6	8	54
"public static QName getXSIType(Parameter param) { if (param.getMIMEType() != null) { return getMIMETypeQName(param.getMIMEType()); } QName xmlType = null; TypeEntry te = param.getType(); // If the TypeEntry describes an Element, get // the referenced Type. if (te != null && te instanceof Element && te.getRefType() != null) { te = te.getRefType(); } // If the TypeEntry is a CollectionType, use // the TypeEntry representing the component Type // So for example a parameter that takes a // collection type for // <element name=""A"" type=""xsd:string"" maxOccurs=""unbounded""/> // will be // new ParameterDesc(<QName of A>, IN, // <QName of xsd:string>, // String[]) if (te != null && te instanceof CollectionType && te.getRefType() != null) { te = te.getRefType(); } if (te != null) { xmlType = te.getQName(); } return xmlType; }"	"    public static QName getXSIType(TypeEntry te) {
        QName xmlType = null;

        // If the TypeEntry describes an Element, get
        // the referenced Type.
        if (te != null &&
            te instanceof Element &&
            te.getRefType() != null) {
            te = te.getRefType();
        } 
        // If the TypeEntry is a CollectionType, use
        // the TypeEntry representing the component Type
        // So for example a parameter that takes a 
        // collection type for
        // <element name=""A"" type=""xsd:string"" maxOccurs=""unbounded""/>
        // will be 
        // new ParameterDesc(<QName of A>, IN,
        //                   <QName of xsd:string>,
        //                   String[])
        if (te != null &&
            te instanceof CollectionType &&
            te.getRefType() != null) {
            te = te.getRefType();
        }
        if (te != null) {
            xmlType = te.getQName();
        }
        return xmlType;
    }
"	@param param is a parameter	@param te is the typeEntry from the Parameters object, which represents the parameter	1	0	7	36	207
public static Polygon getCanvasTileAreaPoly(Client client, LocalPoint localLocation, int size) { int plane = client.getPlane(); int halfTile = LOCAL_TILE_SIZE / 2; // If the size is 5, we need to shift it up and left 2 units, then expand by 5 units to make a 5x5 int aoeSize = size / 2; // Shift over one half tile as localLocation is the center point of the tile, and then shift the area size Point topLeft = new Point(localLocation.getX() - (aoeSize * LOCAL_TILE_SIZE) - halfTile, localLocation.getY() - (aoeSize * LOCAL_TILE_SIZE) - halfTile); // expand by size Point bottomRight = new Point(topLeft.getX() + size * LOCAL_TILE_SIZE - 1, topLeft.getY() + size * LOCAL_TILE_SIZE - 1); // Take the x of top left and the y of bottom right to create bottom left Point bottomLeft = new Point(topLeft.getX(), bottomRight.getY()); // Similarly for top right Point topRight = new Point(bottomRight.getX(), topLeft.getY()); Point p1 = worldToCanvas(client, topLeft.getX(), topLeft.getY(), plane); Point p2 = worldToCanvas(client, topRight.getX(), topRight.getY(), plane); Point p3 = worldToCanvas(client, bottomRight.getX(), bottomRight.getY(), plane); Point p4 = worldToCanvas(client, bottomLeft.getX(), bottomLeft.getY(), plane); if (p1 == null || p2 == null || p3 == null || p4 == null) { return null; } Polygon poly = new Polygon(); poly.addPoint(p1.getX(), p1.getY()); poly.addPoint(p2.getX(), p2.getY()); poly.addPoint(p3.getX(), p3.getY()); poly.addPoint(p4.getX(), p4.getY()); return poly; }	"	public static Polygon getCanvasTileAreaPoly(Client client, Point localLocation, int size)
	{
		int plane = client.getPlane();
		int halfTile = LOCAL_TILE_SIZE / 2;

		// If the size is 5, we need to shift it up and left 2 units, then expand by 5 units to make a 5x5
		int aoeSize = size / 2;

		// Shift over one half tile as localLocation is the center point of the tile, and then shift the area size
		Point topLeft = new Point(localLocation.getX() - (aoeSize * LOCAL_TILE_SIZE) - halfTile,
			localLocation.getY() - (aoeSize * LOCAL_TILE_SIZE) - halfTile);
		// expand by size
		Point bottomRight = new Point(topLeft.getX() + size * LOCAL_TILE_SIZE - 1,
			topLeft.getY() + size * LOCAL_TILE_SIZE - 1);
		// Take the x of top left and the y of bottom right to create bottom left
		Point bottomLeft = new Point(topLeft.getX(), bottomRight.getY());
		// Similarly for top right
		Point topRight = new Point(bottomRight.getX(), topLeft.getY());

		Point p1 = worldToCanvas(client, topLeft.getX(), topLeft.getY(), plane);
		Point p2 = worldToCanvas(client, topRight.getX(), topRight.getY(), plane);
		Point p3 = worldToCanvas(client, bottomRight.getX(), bottomRight.getY(), plane);
		Point p4 = worldToCanvas(client, bottomLeft.getX(), bottomLeft.getY(), plane);

		if (p1 == null || p2 == null || p3 == null || p4 == null)
		{
			return null;
		}

		Polygon poly = new Polygon();
		poly.addPoint(p1.getX(), p1.getY());
		poly.addPoint(p2.getX(), p2.getY());
		poly.addPoint(p3.getX(), p3.getY());
		poly.addPoint(p4.getX(), p4.getY());

		return poly;
	}
"	@param size size of the area. Ex. Lizardman Shaman AoE is a 3x3, so size = 3	@param size size of the area. Ex. Lizardman Shaman AoE is a 3x3, so size = 3	0	1	9	38	371
"public static Schema unaliasSchema(OpenAPI openAPI, Schema schema) { Map<String, Schema> allSchemas = getSchemas(openAPI); if (allSchemas == null || allSchemas.isEmpty()) { // skip the warning as the spec can have no model defined //LOGGER.warn(""allSchemas cannot be null/empty in unaliasSchema. Returned 'schema'""); return schema; } if (schema != null && StringUtils.isNotEmpty(schema.get$ref())) { Schema ref = allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())); if (ref == null) { LOGGER.warn(""{} is not defined"", schema.get$ref()); return schema; } else if (ref.getEnum() != null && !ref.getEnum().isEmpty()) { // top-level enum class return schema; } else if (isArraySchema(ref)) { if (generateAliasAsModel) { return schema; // generate a model extending array } else { return unaliasSchema(openAPI, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()))); } } else if (isComposedSchema(ref)) { return schema; } else if (isMapSchema(ref)) { if (ref.getProperties() != null && !ref.getProperties().isEmpty()) // has at least one property return schema; // treat it as model else { if (generateAliasAsModel) { return schema; // generate a model extending map } else { // treat it as a typical map return unaliasSchema(openAPI, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()))); } } } else if (isObjectSchema(ref)) { // model if (ref.getProperties() != null && !ref.getProperties().isEmpty()) { // has at least one property return schema; } else { // free form object (type: object) return unaliasSchema(openAPI, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()))); } } else { return unaliasSchema(openAPI, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()))); } } return schema; }"	"    public static Schema unaliasSchema(Map<String, Schema> allSchemas, Schema schema) {
        if (allSchemas == null || allSchemas.isEmpty()) {
            // skip the warning as the spec can have no model defined
            //LOGGER.warn(""allSchemas cannot be null/empty in unaliasSchema. Returned 'schema'"");
            return schema;
        }

        if (schema != null && StringUtils.isNotEmpty(schema.get$ref())) {
            Schema ref = allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()));
            if (ref == null) {
                LOGGER.warn(""{} is not defined"", schema.get$ref());
                return schema;
            } else if (ref.getEnum() != null && !ref.getEnum().isEmpty()) {
                // top-level enum class
                return schema;
            } else if (isArraySchema(ref)) {
                if (generateAliasAsModel) {
                    return schema; // generate a model extending array
                } else {
                    return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));
                }
            } else if (isComposedSchema(ref)) {
                return schema;
            } else if (isMapSchema(ref)) {
                if (ref.getProperties() != null && !ref.getProperties().isEmpty()) // has at least one property
                    return schema; // treat it as model
                else {
                    if (generateAliasAsModel) {
                        return schema; // generate a model extending map
                    } else {
                        // treat it as a typical map
                        return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));
                    }
                }
            } else if (isObjectSchema(ref)) { // model
                if (ref.getProperties() != null && !ref.getProperties().isEmpty()) { // has at least one property
                    return schema;
                } else { // free form object (type: object)
                    return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));
                }
            } else {
                return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));
            }
        }
        return schema;
    }
"	@param openAPI specification being checked	@param allSchemas all schemas	1	0	19	48	435
public Call testEndpointParametersAsync(BigDecimal number, Double _double, String string, byte[] _byte, Integer integer, Integer int32, Long int64, Float _float, byte[] binary, Date date, Date dateTime, String password, final ApiCallback<Void> callback) throws ApiException { ProgressResponseBody.ProgressListener progressListener = null; ProgressRequestBody.ProgressRequestListener progressRequestListener = null; if (callback != null) { progressListener = new ProgressResponseBody.ProgressListener() { @Override public void update(long bytesRead, long contentLength, boolean done) { callback.onDownloadProgress(bytesRead, contentLength, done); } }; progressRequestListener = new ProgressRequestBody.ProgressRequestListener() { @Override public void onRequestProgress(long bytesWritten, long contentLength, boolean done) { callback.onUploadProgress(bytesWritten, contentLength, done); } }; } Call call = testEndpointParametersCall(number, _double, string, _byte, integer, int32, int64, _float, binary, date, dateTime, password, progressListener, progressRequestListener); apiClient.executeAsync(call, callback); return call; }	"  public Call testEndpointParametersAsync(String number, Double _double, String string, byte[] _byte, Integer integer, Integer int32, Long int64, Float _float, byte[] binary, Date date, Date dateTime, String password, final ApiCallback<Void> callback) throws ApiException {

    ProgressResponseBody.ProgressListener progressListener = null;
    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

    if (callback != null) {
      progressListener = new ProgressResponseBody.ProgressListener() {
        @Override
        public void update(long bytesRead, long contentLength, boolean done) {
          callback.onDownloadProgress(bytesRead, contentLength, done);
        }
      };

      progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
        @Override
        public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
          callback.onUploadProgress(bytesWritten, contentLength, done);
        }
      };
    }

    Call call = testEndpointParametersCall(number, _double, string, _byte, integer, int32, int64, _float, binary, date, dateTime, password, progressListener, progressRequestListener);
    apiClient.executeAsync(call, callback);
    return call;
  }
"	@param callback The callback to be executed when the API call finishes	@param callback The callback to be executed when the API call finishes	0	1	11	26	187
"public Client testSpecialTags(Client client) throws RestClientException { Object postBody = client; // verify the required parameter 'client' is set if (client == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'client' when calling testSpecialTags""); } String path = UriComponentsBuilder.fromPath(""/another-fake/dummy"").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { ""application/json"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { ""application/json"" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {}; return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }"	"    public Client testSpecialTags(Client body) throws RestClientException {
        Object postBody = body;
        
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'body' when calling testSpecialTags"");
        }
        
        String path = UriComponentsBuilder.fromPath(""/another-fake/dummy"").build().toUriString();
        
        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();
        final HttpHeaders headerParams = new HttpHeaders();
        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();

        final String[] accepts = { 
            ""application/json""
        };
        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);
        final String[] contentTypes = { 
            ""application/json""
        };
        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);

        String[] authNames = new String[] {  };

        ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {};
        return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);
    }
"	@param client client model	@param body client model	1	0	8	29	204
private ColumnState buildSimpleList(ContainerState parent, ColumnReadProjection colProj) { ColumnMetadata columnSchema = colProj.providedSchema(); // The variant must have the one and only type. assert columnSchema.variantSchema().size() == 1; assert columnSchema.variantSchema().isSimple(); // Create the manager for the one and only column within the list. final ListState listState = new ListState(parent.loader(), parent.vectorCache().childCache(columnSchema.name())); // Create the child vector, writer and state. final ColumnMetadata memberSchema = columnSchema.variantSchema().listSubtype(); final ColumnState memberState = buildColumn(listState, memberSchema); listState.setSubColumn(memberState); // Create the list vector. Contains a single type. final ListVector listVector = new ListVector(columnSchema.schema().cloneEmpty(), parent.loader().allocator(), null); listVector.setChildVector(memberState.vector()); // Create the list writer: an array of the one type. final ListWriterImpl listWriter = new ListWriterImpl(columnSchema, listVector, memberState.writer()); final AbstractObjectWriter listObjWriter = new ArrayObjectWriter(listWriter); // Create the list vector state that tracks the list vector lifecycle. final ListVectorState vectorState = new ListVectorState(listWriter, memberState.writer().events(), listVector); // Assemble it all into a union column state. return new UnionColumnState(parent.loader(), listObjWriter, vectorState, listState); }	"  private ColumnState buildSimpleList(ContainerState parent, ColumnTransform outputCol) {
    ColumnMetadata columnSchema = outputCol.outputSchema();

    // The variant must have the one and only type.

    assert columnSchema.variantSchema().size() == 1;
    assert columnSchema.variantSchema().isSimple();

    // Create the manager for the one and only column within the list.

    final ListState listState = new ListState(parent.loader(),
        parent.vectorCache().childCache(columnSchema.name()),
        new ImpliedTupleRequest(true));

    // Create the child vector, writer and state.

    final ColumnMetadata memberSchema = columnSchema.variantSchema().listSubtype();
    final ColumnState memberState = buildColumn(listState, memberSchema);
    listState.setSubColumn(memberState);

    // Create the list vector. Contains a single type.

    final ListVector listVector = new ListVector(columnSchema.schema().cloneEmpty(),
        parent.loader().allocator(), null);
    listVector.setChildVector(memberState.vector());

    // Create the list writer: an array of the one type.

    final ListWriterImpl listWriter = new ListWriterImpl(columnSchema,
        listVector, memberState.writer());
    final AbstractObjectWriter listObjWriter = new ArrayObjectWriter(listWriter);

    // Create the list vector state that tracks the list vector lifecycle.

    final ListVectorState vectorState = new ListVectorState(listWriter,
        memberState.writer().events(), listVector);

    // Assemble it all into a union column state.

    return new UnionColumnState(parent.loader(),
        listObjWriter, vectorState, listState);
  }
"	@param parent the parent (tuple, union or list) that holds this list	@param parent the parent (tuple, union or list) that holds this list	0	1	8	42	264
public static boolean canEdit(Permissions perms, Permissions user2Perms) { if(isAdmin(perms)) return true; if(isAdmin(user2Perms)) return false; return getManagementLevel(perms) > getManagementLevel(user2Perms); }	"	public static boolean canEdit(User manager, User toEdit)
	{
		if(isAdmin(manager))
			return true;
		if(isAdmin(toEdit))
			return false;

		return getManagementLevel(manager) > getManagementLevel(toEdit);
	}
"	@param perms The permissions of the user trying to edit the given user	@param manager The manager user (the one accessing the application)	1	0	6	11	43
public Struct update(Object before, Struct after, Struct source, Long timestamp) { Struct struct = new Struct(schema); struct.put(FieldName.OPERATION, Operation.UPDATE.code()); if (before != null) struct.put(FieldName.BEFORE, before); struct.put(FieldName.AFTER, after); if (source != null) struct.put(FieldName.SOURCE, source); if (timestamp != null) struct.put(FieldName.TIMESTAMP, timestamp); return struct; }	"    public Struct update(Struct before, Struct after, Struct source, Long timestamp) {
        Struct struct = new Struct(schema);
        struct.put(FieldName.OPERATION, Operation.UPDATE.code());
        if (before != null) struct.put(FieldName.BEFORE, before);
        struct.put(FieldName.AFTER, after);
        if (source != null) struct.put(FieldName.SOURCE, source);
        if (timestamp != null) struct.put(FieldName.TIMESTAMP, timestamp);
        return struct;
    }
"	@param before the state of the record before the update; may be null	@param before the state of the record before the update; may be null	0	1	6	10	96
private RectF drawBoxWithShadow(Canvas c, Paint p, int width, int height) { Resources res = mContext.getResources(); float shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur); float keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance); float corner = res.getDimension(R.dimen.widget_preview_corner_radius); RectF bounds = new RectF(shadowBlur, shadowBlur, width - shadowBlur, height - shadowBlur - keyShadowDistance); p.setColor(Color.WHITE); // Key shadow p.setShadowLayer(shadowBlur, 0, keyShadowDistance, ShadowGenerator.KEY_SHADOW_ALPHA << 24); c.drawRoundRect(bounds, corner, corner, p); // Ambient shadow p.setShadowLayer(shadowBlur, 0, 0, ColorUtils.setAlphaComponent(Color.BLACK, ShadowGenerator.AMBIENT_SHADOW_ALPHA)); c.drawRoundRect(bounds, corner, corner, p); p.clearShadowLayer(); return bounds; }	"    private RectF drawBoxWithShadow(Canvas c, int width, int height) {
        Resources res = mContext.getResources();

        ShadowGenerator.Builder builder = new ShadowGenerator.Builder(Color.WHITE);
        builder.shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur);
        builder.radius = res.getDimension(R.dimen.widget_preview_corner_radius);
        builder.keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance);

        builder.bounds.set(builder.shadowBlur, builder.shadowBlur,
                width - builder.shadowBlur,
                height - builder.shadowBlur - builder.keyShadowDistance);
        builder.drawShadow(c);
        return builder.bounds;
    }
"	@param launcher	@param launcher	0	1	8	24	156
public DateTime withPeriodAdded(ReadablePeriod period, int scalar) { if (period == null || scalar == 0) { return this; } long instant = getChronology().add(getMillis(), period, scalar); return withMillis(instant); }	"    public DateTime withPeriodAdded(ReadablePeriod periodToAdd, int scalar) {
        if (periodToAdd == null || scalar == 0) {
            return this;
        }
        long instant = periodToAdd.addTo(getMillis(), scalar, getChronology());
        return withMillis(instant);
    }
"	@param period the period to add to this one, null means zero	@param periodToAdd the period to add to this one, null means zero	1	0	7	8	48
"public static String getClassName(String memberID, boolean isClassMember) { int pos = memberID.indexOf(ALT_MEMBER_SEPARATOR); // uses alternative separator, easy if (pos != -1) return memberID.substring(0, pos); pos = memberID.indexOf('('); if ( pos != -1 ) { // has a descriptor, is a method ID, strip last member part pos = memberID.lastIndexOf('.', pos); return pos != -1 ? memberID.substring(0, pos) : """"; } if (isClassMember) { // field or class name, cannot decide, assume it is a field pos = memberID.lastIndexOf('.'); return pos != -1 ? memberID.substring(0, pos) : """"; } else { // assume it is a class name return memberID; } }"	"    public static String getClassName(String signature, boolean isClassMember) {
        int pos = signature.indexOf(ALT_MEMBER_SEPARATOR);
        // uses alternative separator, easy
        if (pos != -1) return signature.substring(0, pos);

        pos = signature.indexOf('(');
        if ( pos != -1 ) {
            // has a descriptor, is a method signature, strip last member part
            pos = signature.lastIndexOf('.', pos);
            return pos != -1 ? signature.substring(0, pos) : """";
        }

        if (isClassMember) {
            // field or class name, cannot decide, assume it is a field
            pos = signature.lastIndexOf('.');
            return pos != -1 ? signature.substring(0, pos) : """";
        } else {
            // assume it is a class name
            return signature;
        }
    }
"	@param isClassMember If the ID is ambiguous, if true always assume that the last simple member name is a method or field, else assume it is a class name.	@param isClassMember If the signature is ambiguous, if true always assume that the last simple member name is a method or field, else assume it is a class name.	1	0	8	23	164
private ColumnState buildSimpleList(ContainerState parent, ColumnReadProjection colProj) { ColumnMetadata columnSchema = colProj.providedSchema(); // The variant must have the one and only type. assert columnSchema.variantSchema().size() == 1; assert columnSchema.variantSchema().isSimple(); // Create the manager for the one and only column within the list. final ListState listState = new ListState(parent.loader(), parent.vectorCache().childCache(columnSchema.name())); // Create the child vector, writer and state. final ColumnMetadata memberSchema = columnSchema.variantSchema().listSubtype(); final ColumnState memberState = buildColumn(listState, memberSchema); listState.setSubColumn(memberState); // Create the list vector. Contains a single type. final ListVector listVector = new ListVector(columnSchema.schema().cloneEmpty(), parent.loader().allocator(), null); listVector.setChildVector(memberState.vector()); // Create the list writer: an array of the one type. final ListWriterImpl listWriter = new ListWriterImpl(columnSchema, listVector, memberState.writer()); final AbstractObjectWriter listObjWriter = new ArrayObjectWriter(listWriter); // Create the list vector state that tracks the list vector lifecycle. final ListVectorState vectorState = new ListVectorState(listWriter, memberState.writer().events(), listVector); // Assemble it all into a union column state. return new UnionColumnState(parent.loader(), listObjWriter, vectorState, listState); }	"  private ColumnState buildSimpleList(ContainerState parent, ColumnTransform outputCol) {
    ColumnMetadata columnSchema = outputCol.outputSchema();

    // The variant must have the one and only type.

    assert columnSchema.variantSchema().size() == 1;
    assert columnSchema.variantSchema().isSimple();

    // Create the manager for the one and only column within the list.

    final ListState listState = new ListState(parent.loader(),
        parent.vectorCache().childCache(columnSchema.name()),
        new ImpliedTupleRequest(true));

    // Create the child vector, writer and state.

    final ColumnMetadata memberSchema = columnSchema.variantSchema().listSubtype();
    final ColumnState memberState = buildColumn(listState, memberSchema);
    listState.setSubColumn(memberState);

    // Create the list vector. Contains a single type.

    final ListVector listVector = new ListVector(columnSchema.schema().cloneEmpty(),
        parent.loader().allocator(), null);
    listVector.setChildVector(memberState.vector());

    // Create the list writer: an array of the one type.

    final ListWriterImpl listWriter = new ListWriterImpl(columnSchema,
        listVector, memberState.writer());
    final AbstractObjectWriter listObjWriter = new ArrayObjectWriter(listWriter);

    // Create the list vector state that tracks the list vector lifecycle.

    final ListVectorState vectorState = new ListVectorState(listWriter,
        memberState.writer().events(), listVector);

    // Assemble it all into a union column state.

    return new UnionColumnState(parent.loader(),
        listObjWriter, vectorState, listState);
  }
"	@param columnSchema metadata description of the list which must contain exactly one subtype	@param columnSchema metadata description of the list which must contain exactly one subtype	0	1	8	42	264
public static EBoolean isNotEmpty(EMap<?,?> map) { return operationFactory.createBoolean(Ops.MAP_ISNOTEMPTY,(Expr<?>) map); }	"    public static EBoolean isNotEmpty(PMap<?,?> map) {
        return operationFactory.createBoolean(Ops.MAP_ISNOTEMPTY,(Expr<?>) map);
    }
"	@param collection	@param collection	0	1	7	4	27
public Field withValidation(Validator... validators) { Validator actualValidator = validator; for (Validator validator : validators) { if (validator != null) actualValidator = validator.and(actualValidator); } return new Field(name(), displayName(), type(), width(), description(), importance(), dependents, defaultValueGenerator, actualValidator, recommender); }	"    public Field withValidation(Predicate<String>... predicates) {
        return new Field(name(), description(), defaultValueGenerator, (config, field, problems) -> {
            String value = config.getString(field);
            for (Predicate<String> predicate : predicates) {
                if (predicate != null) {
                    try {
                        if (!predicate.test(value)) {
                            problems.accept(""The "" + field.name() + "" value '"" + value + ""' is not valid"");
                            return 1;
                        }
                    } catch (Throwable t) {
                        problems.accept(""The "" + field.name() + "" value '"" + value + ""' is not allowed: "" + t.getMessage());
                        return 1;
                    }
                }
            }
            return 0;
        });
    }
"	@param validators the additional validation function(s); may be null	@param predicates the functions that attempt to validate the object; may be null	1	0	9	9	72
protected SourceInfo update(Long lsn, Instant commitTime, Long txId, TableId tableId) { this.lsn = lsn; this.useconds = Conversions.toEpochMicros(commitTime); this.txId = txId; if (tableId != null && tableId.schema() != null) { this.schemaName = tableId.schema(); } if (tableId != null && tableId.table() != null) { this.tableName = tableId.table(); } return this; }	"    protected SourceInfo update(Long lsn, Long useconds, Long txId, TableId tableId) {
        this.lsn = lsn;
        this.useconds = useconds;
        this.txId = txId;
        if (tableId != null && tableId.schema() != null) {
            this.schemaName = tableId.schema();
        }
        if (tableId != null && tableId.table() != null) {
            this.tableName = tableId.table();
        }
        return this;
    }
"	@param txId the ID of the transaction that generated the transaction; may be null if this information nis not available	@param txId the ID of the transaction that generated the transaction; may be null if this information nis not available	0	1	8	13	83
"private List<HttpCookie> prepareCookies(String uriS) { if (parent.getSpiderParam().isSendCookies()) { java.net.URI uri = null; try { uri = new java.net.URI(uriS); } catch (URISyntaxException e) { log.error(""Error while preparing cookies. "", e); } return parent.getCookieManager().getCookieStore().get(uri); } return null; }"	"	private List<HttpCookie> prepareCookies(HttpMessage msg) {
		if (parent.getSpiderParam().isSendCookies()) {
			java.net.URI uri = null;
			try {
				uri = new java.net.URI(msg.getRequestHeader().getURI().toString());
			} catch (URISyntaxException e) {
				log.error(""Error while preparing cookies. "", e);
			}
			return parent.getCookieManager().getCookieStore().get(uri);
		}
		return null;
	}
"	@param uriS the uri	@param msg the response message where the uri was found	1	0	11	13	76
"public Action timedout(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException { logger.trace(""Timing out {}"", req); if (trackActiveRequest(req) && completeLifecycle(req.resource(), false)) { config.framework().notify(Action.TYPE.TIMEOUT, req, res); } return timedoutAction; }"	"    public Action timedout(AtmosphereRequest request, AtmosphereResponse response)
            throws IOException, ServletException {

        AtmosphereResourceImpl r = null;

        try {
            SessionTimeoutSupport.restoreTimeout(request);

            if (trackActiveRequest) {
                long l = (Long) request.getAttribute(MAX_INACTIVE);
                if (l == -1) {
                    // The closedDetector closed the connection.
                    return timedoutAction;
                }
                request.setAttribute(MAX_INACTIVE, (long) -1);
            }

            logger.debug(""Timing out the connection for request {}"", request);

            // Something went wrong.
            if (request == null || response == null) {
                logger.warn(""Invalid Request/Response: {}/{}"", request, response);
                return timedoutAction;
            }

            r = (AtmosphereResourceImpl) request.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE);

            if (r != null && r.isCancelled()) {
                return cancelledAction;
            }

            if (r == null) {
                logger.debug(""AtmosphereResource was null, failed to timeout AtmosphereRequest {}"", request);
            }

            if (r != null && r.getAtmosphereResourceEvent().isSuspended()) {
                r.getAtmosphereResourceEvent().setIsResumedOnTimeout(true);

                Broadcaster b = r.getBroadcaster();
                if (b instanceof DefaultBroadcaster) {
                    ((DefaultBroadcaster) b).broadcastOnResume(r);
                }

                if (request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT) != null) {
                    r.getAtmosphereResourceEvent().setIsResumedOnTimeout(
                            (Boolean) request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT));
                }

                invokeAtmosphereHandler(r);
            }
        } catch (Throwable t) {
            logger.error(""failed to timeout resource {}"", r, t);
        } finally {
            config.framework().notify(Action.TYPE.TIMEOUT, request, response);
            try {
                if (r != null) {
                    r.notifyListeners();
                    r.setIsInScope(false);
                    r.cancel();
                }
            } catch (Throwable t) {
                logger.trace(""timedout"", t);
            } finally {
                try {
                    response.getOutputStream().close();
                } catch (Throwable t) {
                    try {
                        response.getWriter().close();
                    } catch (Throwable t2) {
                    }
                }

                if (r != null) {
                    r._destroy();
                }
            }
        }

        return timedoutAction;
    }
"	@param res the  AtmosphereResponse	@param response the AtmosphereResponse	1	0	8	10	67
"public static Token seek(Parser parser, String path) { // return current token if no path is given if (!StringUtils.hasText(path)) { return null; } List<String> tokens = StringUtils.tokenize(path, "".""); return seek(parser, tokens.toArray(new String[tokens.size()])); }"	"    public static Token seek(String path, Parser parser) {
        // return current token if no path is given
        if (!StringUtils.hasText(path)) {
            return null;
        }

        List<String> tokens = StringUtils.tokenize(path, ""."");
        return seek(parser, tokens.toArray(new String[tokens.size()]));
    }
"	@param parser	@param parser	0	1	7	10	68
"private double[] makeDatumUsingEmbedding(List<IN> info, int loc, List<FeatureFactory<IN>> featureFactories, PaddedList<IN> pInfo, List<String> featuresC, List<Clique> windowCliques) { double[] featureValArr; List<double[]> embeddingList = new ArrayList<double[]>(); int concatEmbeddingLen = 0; String currentWord = null; for (int currLoc = loc-2; currLoc <= loc+2; currLoc++) { double[] embedding = null; if (currLoc >=0 && currLoc < info.size()) { currentWord = info.get(loc).get(CoreAnnotations.TextAnnotation.class); String word = currentWord.toLowerCase(); word = word.replaceAll(""(-)?\\d+(\\.\\d*)?"", ""0""); if (embeddings.containsKey(word)) embedding = embeddings.get(word); else embedding = embeddings.get(""UNKNOWN""); } else { embedding = embeddings.get(""PADDING""); } for (int e = 0; e < embedding.length; e++) { featuresC.add(""EMBEDDING-("" + (currLoc-loc) + "")-"" + e); } if (flags.addCapitalFeatures) { int numOfCapitalFeatures = 4; double[] newEmbedding = new double[embedding.length + numOfCapitalFeatures]; int currLen = embedding.length; System.arraycopy(embedding, 0, newEmbedding, 0, currLen); for (int e = 0; e < numOfCapitalFeatures; e++) featuresC.add(""CAPITAL-("" + (currLoc-loc) + "")-"" + e); if (currLoc >=0 && currLoc < info.size()) { // skip PADDING // check if word is all caps if (currentWord.toUpperCase().equals(currentWord)) newEmbedding[currLen] = 1; else { currLen += 1; // check if word is all lower if (currentWord.toLowerCase().equals(currentWord)) newEmbedding[currLen] = 1; else { currLen += 1; // check first letter cap if (Character.isUpperCase(currentWord.charAt(0))) newEmbedding[currLen] = 1; else { currLen += 1; // check if at least one non-initial letter is cap String remainder = currentWord.substring(1); if (!remainder.toLowerCase().equals(remainder)) newEmbedding[currLen] = 1; } } } } embedding = newEmbedding; } embeddingList.add(embedding); concatEmbeddingLen += embedding.length; } double[] concatEmbedding = new double[concatEmbeddingLen]; int currPos = 0; for (double[] em: embeddingList) { System.arraycopy(em, 0, concatEmbedding, currPos, em.length); currPos += em.length; } if (flags.prependEmbedding) { int additionalFeatureCount = 0; for (Clique c : windowCliques) { for (FeatureFactory featureFactory : featureFactories) { Collection<String> fCol = featureFactory.getCliqueFeatures(pInfo, loc, c); //todo useless copy because of typing reasons featuresC.addAll(fCol); additionalFeatureCount += fCol.size(); } } featureValArr = new double[concatEmbedding.length + additionalFeatureCount]; System.arraycopy(concatEmbedding, 0, featureValArr, 0, concatEmbedding.length); Arrays.fill(featureValArr, concatEmbedding.length, featureValArr.length, 1.0); } else { featureValArr = concatEmbedding; } if (flags.addBiasToEmbedding) { featuresC.add(""BIAS-FEATURE""); double[] newFeatureValArr = new double[featureValArr.length + 1]; System.arraycopy(featureValArr, 0, newFeatureValArr, 0, featureValArr.length); newFeatureValArr[newFeatureValArr.length-1] = 1; featureValArr = newFeatureValArr; } return featureValArr; }"	"  private double[] makeDatumUsingEmbedding(List<IN> info, int loc, FeatureFactory<IN> featureFactory, PaddedList<IN> pInfo, List<String> featuresC, List<Clique> windowCliques) {
    double[] featureValArr;
    List<double[]> embeddingList = new ArrayList<double[]>();
    int concatEmbeddingLen = 0;
    String currentWord = null;
    for (int currLoc = loc-2; currLoc <= loc+2; currLoc++) {
      double[] embedding = null;
      if (currLoc >=0 && currLoc < info.size()) {
        currentWord = info.get(loc).get(CoreAnnotations.TextAnnotation.class);
        String word = currentWord.toLowerCase();
        word = word.replaceAll(""(-)?\\d+(\\.\\d*)?"", ""0"");
        if (embeddings.containsKey(word))
          embedding = embeddings.get(word);
        else
          embedding = embeddings.get(""UNKNOWN"");
      } else {
        embedding = embeddings.get(""PADDING"");
      }

      for (int e = 0; e < embedding.length; e++) {
        featuresC.add(""EMBEDDING-("" + (currLoc-loc) + "")-"" + e);
      }

      if (flags.addCapitalFeatures) {
        int numOfCapitalFeatures = 4;
        double[] newEmbedding = new double[embedding.length + numOfCapitalFeatures];
        int currLen = embedding.length;
        System.arraycopy(embedding, 0, newEmbedding, 0, currLen);
        for (int e = 0; e < numOfCapitalFeatures; e++)
          featuresC.add(""CAPITAL-("" + (currLoc-loc) + "")-"" + e);

        if (currLoc >=0 && currLoc < info.size()) { // skip PADDING
          // check if word is all caps
          if (currentWord.toUpperCase().equals(currentWord))
            newEmbedding[currLen] = 1;
          else {
            currLen += 1;
            // check if word is all lower
            if (currentWord.toLowerCase().equals(currentWord))
              newEmbedding[currLen] = 1;
            else {
              currLen += 1;
              // check first letter cap
              if (Character.isUpperCase(currentWord.charAt(0)))
                newEmbedding[currLen] = 1;
              else {
                currLen += 1;
                // check if at least one non-initial letter is cap
                String remainder = currentWord.substring(1);
                if (!remainder.toLowerCase().equals(remainder))
                  newEmbedding[currLen] = 1;
              }
            }
          }
        }
        embedding = newEmbedding;
      }

      embeddingList.add(embedding);
      concatEmbeddingLen += embedding.length;
    }
    double[] concatEmbedding = new double[concatEmbeddingLen];
    int currPos = 0;
    for (double[] em: embeddingList) {
      System.arraycopy(em, 0, concatEmbedding, currPos, em.length);
      currPos += em.length;
    }

    if (flags.prependEmbedding) {
      int additionalFeatureCount = 0;
      for (Clique c : windowCliques) {
        Collection<String> fCol = featureFactory.getCliqueFeatures(pInfo, loc, c); //todo useless copy because of typing reasons
        featuresC.addAll(fCol);
        additionalFeatureCount += fCol.size();
      }
      featureValArr = new double[concatEmbedding.length + additionalFeatureCount];
      System.arraycopy(concatEmbedding, 0, featureValArr, 0, concatEmbedding.length);
      Arrays.fill(featureValArr, concatEmbedding.length, featureValArr.length, 1.0);
    } else {
      featureValArr = concatEmbedding;
    }

    if (flags.addBiasToEmbedding) {
      featuresC.add(""BIAS-FEATURE"");
      double[] newFeatureValArr = new double[featureValArr.length + 1];
      System.arraycopy(featureValArr, 0, newFeatureValArr, 0, featureValArr.length);
      newFeatureValArr[newFeatureValArr.length-1] = 1;
      featureValArr = newFeatureValArr;
    }
    return featureValArr;
  }
"	@param info The input data	@param info The input data	0	1	20	94	682
public static Properties getPartitionMetadata(final HivePartition partition, final HiveTableWithColumnCache table) { final Properties properties; restoreColumns(table, partition); properties = MetaStoreUtils.getPartitionMetadata(partition, table); // SerDe expects properties from Table, but above call doesn't add Table properties. // Include Table properties in final list in order to not to break SerDes that depend on // Table properties. For example AvroSerDe gets the schema from properties (passed as second argument) for (Map.Entry<String, String> entry : table.getParameters().entrySet()) { if (entry.getKey() != null && entry.getKey() != null) { properties.put(entry.getKey(), entry.getValue()); } } return properties; }	"  public static Properties getPartitionMetadata(final Partition partition, final Table table) {
    final Properties properties = MetaStoreUtils.getPartitionMetadata(partition, table);

    // SerDe expects properties from Table, but above call doesn't add Table properties.
    // Include Table properties in final list in order to not to break SerDes that depend on
    // Table properties. For example AvroSerDe gets the schema from properties (passed as second argument)
    for (Map.Entry<String, String> entry : table.getParameters().entrySet()) {
      if (entry.getKey() != null && entry.getKey() != null) {
        properties.put(entry.getKey(), entry.getValue());
      }
    }

    return properties;
  }
"	@param table the source of table level parameters	@param table	1	0	9	17	143
public char get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }	"    public char get(WithAttributes attributes) {
        return attributes.getAttributes().get(this);
    }
"	@param withAttributes an object containing an AttributeMap	@param attributes an object containing an AttributeMap	1	0	6	5	19
public static boolean filter(String path, Collection<String> includes, Collection<String> excludes) { includes = (includes == null ? Collections.<String> emptyList() : includes); excludes = (excludes == null ? Collections.<String> emptyList() : excludes); if (includes.isEmpty() && excludes.isEmpty()) { return true; } if (Regex.simpleMatch(excludes, path)) { return false; } boolean exactIncludeMatch = false; // true if the current position was specifically mentioned boolean pathIsPrefixOfAnInclude = false; // true if potentially a sub scope can be included if (includes.isEmpty()) { // implied match anything exactIncludeMatch = true; } else { for (String include : includes) { // check for prefix matches as well to see if we need to zero in, something like: obj1.arr1.* or *.field // note, this does not work well with middle matches, like obj1.*.obj3 if (include.charAt(0) == '*') { if (Regex.simpleMatch(include, path)) { exactIncludeMatch = true; break; } pathIsPrefixOfAnInclude = true; continue; } if (include.startsWith(path)) { if (include.length() == path.length()) { exactIncludeMatch = true; break; } else if (include.length() > path.length() && include.charAt(path.length()) == '.') { // include might may match deeper paths. Dive deeper. pathIsPrefixOfAnInclude = true; continue; } } if (Regex.simpleMatch(include, path)) { exactIncludeMatch = true; break; } } } if (!(pathIsPrefixOfAnInclude || exactIncludeMatch)) { // skip subkeys, not interesting. return false; } else if (exactIncludeMatch) { return true; } return false; }	"    public static boolean filter(String path, List<String> includes, List<String> excludes) {
        includes = (includes == null ? Collections.<String> emptyList() : includes);
        excludes = (excludes == null ? Collections.<String> emptyList() : excludes);

        if (includes.isEmpty() && excludes.isEmpty()) {
            return true;
        }

        if (Regex.simpleMatch(excludes, path)) {
            return false;
        }

        boolean exactIncludeMatch = false; // true if the current position was specifically mentioned
        boolean pathIsPrefixOfAnInclude = false; // true if potentially a sub scope can be included
        if (includes.isEmpty()) {
            // implied match anything
            exactIncludeMatch = true;
        }
        else {
            for (String include : includes) {
                // check for prefix matches as well to see if we need to zero in, something like: obj1.arr1.* or *.field
                // note, this does not work well with middle matches, like obj1.*.obj3
                if (include.charAt(0) == '*') {
                    if (Regex.simpleMatch(include, path)) {
                        exactIncludeMatch = true;
                        break;
                    }
                    pathIsPrefixOfAnInclude = true;
                    continue;
                }
                if (include.startsWith(path)) {
                    if (include.length() == path.length()) {
                        exactIncludeMatch = true;
                        break;
                    }
                    else if (include.length() > path.length() && include.charAt(path.length()) == '.') {
                        // include might may match deeper paths. Dive deeper.
                        pathIsPrefixOfAnInclude = true;
                        continue;
                    }
                }
                if (Regex.simpleMatch(include, path)) {
                    exactIncludeMatch = true;
                    break;
                }
            }
        }

        if (!(pathIsPrefixOfAnInclude || exactIncludeMatch)) {
            // skip subkeys, not interesting.
            return false;
        }

        else if (exactIncludeMatch) {
            return true;
        }
        return true;
    }
"	@param includes	@param includes	0	1	14	59	336
"protected QualifiedName determineGeneratorTableName(Properties params, JdbcEnvironment jdbcEnvironment) { final String tableName = ConfigurationHelper.getString( TABLE_PARAM, params, DEF_TABLE ); if ( tableName.contains( ""."" ) ) { return QualifiedNameParser.INSTANCE.parse( tableName ); } else { // todo : need to incorporate implicit catalog and schema names final Identifier catalog = jdbcEnvironment.getIdentifierHelper().toIdentifier( ConfigurationHelper.getString( CATALOG, params ) ); final Identifier schema = jdbcEnvironment.getIdentifierHelper().toIdentifier( ConfigurationHelper.getString( SCHEMA, params ) ); return new QualifiedNameParser.NameParts( catalog, schema, jdbcEnvironment.getIdentifierHelper().toIdentifier( tableName ) ); } }"	"	protected QualifiedName determineGeneratorTableName(Properties params, Dialect dialect) {
		final ObjectNameNormalizer normalizer = (ObjectNameNormalizer) params.get( IDENTIFIER_NORMALIZER );

		return QualifiedNameParser.INSTANCE.parse(
				ConfigurationHelper.getString( TABLE_PARAM, params, DEF_TABLE ),
				normalizer.normalizeIdentifierQuoting( params.getProperty( CATALOG ) ),
				normalizer.normalizeIdentifierQuoting( params.getProperty( SCHEMA ) )
		);
	}
"	@param jdbcEnvironment The JDBC environment	@param dialect The dialect in effect	1	0	10	22	114
public BooleanExpression notIn(T... right) { if (right.length == 1){ return ne(right[0]); }else{ return in(right).not(); } }	"    public BooleanExpression notIn(D... right) {
        if (right.length == 1){
            return ne(right[0]);
        }else{
            return in(right).not();
        }
    }
"	@param right rhs of the comparison	@param right rhs of the comparison	0	1	9	8	38
"public ApiResponse<Boolean> fakeOuterBooleanSerializeWithHttpInfo(Boolean booleanPostBody) throws ApiException { Object localVarPostBody = booleanPostBody; // create path and map variables String localVarPath = ""/fake/outer/boolean""; // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { ""*/*"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {}; return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	"  public ApiResponse<Boolean> fakeOuterBooleanSerializeWithHttpInfo(Boolean body) throws ApiException {
    Object localVarPostBody = body;
    
    // create path and map variables
    String localVarPath = ""/fake/outer/boolean"";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    final String[] localVarAccepts = {
      
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {};
    return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);
      }
"	@param booleanPostBody Input boolean as post body (optional)	@param body Input boolean as post body (optional)	1	0	8	30	161
public Single<Client> rxCall123testSpecialTags(Client body) { return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> { delegate.call123testSpecialTags(body, fut); })); }	"    public Single<Client> rxCall123testSpecialTags(Client client) {
        return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> {
            delegate.call123testSpecialTags(client, fut);
        }));
    }
"	@param body client model (required)	@param client client model (required)	1	0	10	6	36
"public List<TypedDependency> typedDependenciesCCprocessed(boolean includeExtras) { List<TypedDependency> tdl = typedDependencies(false); // Adds stuff to the basic dependencies. // We don't want to simply call typedDependencies with // ""includeExtras"" because the collapseDependencies method may add // the extras in a way that makes more logical sense. For // example, the English dependencies, when CC processed, have more // nsubjs than they originally do. If we wait until that occurs // to add xsubj for xcomp dependencies, we get better coverage. if (includeExtras) { getTreeDeps(root(), tdl, new NoPunctTypedDependencyFilter(puncFilter), extraTreeDepFilter()); } collapseDependencies(tdl, true, includeExtras); return tdl; }"	"  public List<TypedDependency> typedDependenciesCCprocessed(Extras includeExtras) {
    List<TypedDependency> tdl = typedDependencies(includeExtras);
    collapseDependencies(tdl, true, includeExtras);
    return tdl;
  }
"	"@param includeExtras If true, the list of typed dependencies returned may include ""extras"", such as controlled subject links."	"@param includeExtras If true, the list of typed dependencies returned may include ""extras"", such as controlled subject links."	0	1	8	16	139
public static TupleMetadata expandMetadata(TupleMetadata base, ImplicitColumnManager metadataProj, int dirCount) { TupleMetadata metadataSchema = new TupleSchema(); for (ColumnMetadata col : base) { metadataSchema.addColumn(col); } for (FileMetadataColumnDefn fileColDefn : metadataProj.fileMetadataColDefns()) { metadataSchema.add(MaterializedField.create(fileColDefn.colName(), fileColDefn.dataType())); } for (int i = 0; i < dirCount; i++) { metadataSchema.add(MaterializedField.create(metadataProj.partitionName(i), PartitionColumn.dataType())); } return metadataSchema; }	"  public static TupleMetadata expandMetadata(TupleMetadata base, FileMetadataManager metadataProj, int dirCount) {
    TupleMetadata metadataSchema = new TupleSchema();
    for (ColumnMetadata col : base) {
      metadataSchema.addColumn(col);
    }
    for (FileMetadataColumnDefn fileColDefn : metadataProj.fileMetadataColDefns()) {
      metadataSchema.add(MaterializedField.create(fileColDefn.colName(), fileColDefn.dataType()));
    }
    for (int i = 0; i < dirCount; i++) {
      metadataSchema.add(MaterializedField.create(metadataProj.partitionName(i),
          PartitionColumn.dataType()));
    }
    return metadataSchema;
  }
"	@param dirCount number of partition directories	@param dirCount number of partition directories	0	1	9	15	105
public String getInitParameter(String key, String defaultValue) { String s = getInitParameter(key); if (s == null) { return defaultValue; } return s; }	"    public String getInitParameter(String closedAtmosphereThinkTime, String defaultValue) {
        String s = getInitParameter(closedAtmosphereThinkTime);
        if (s == null) {
            return defaultValue;
        }
        return s;
    }
"	@param key	@param closedAtmosphereThinkTime	1	0	6	8	32
public StringBuilder toStringBuilder(StringBuilder sb, boolean printOnlyLabelValue) { if (isLeaf()) { if (label() != null) { if(printOnlyLabelValue) { sb.append(label().value()); } else { sb.append(label()); } } return sb; } else { sb.append('('); if (label() != null) { if (printOnlyLabelValue) { if (value() != null) { sb.append(label().value()); } // don't print a null, just nothing! } else { sb.append(label()); } } Tree[] kids = children(); if (kids != null) { for (Tree kid : kids) { sb.append(' '); kid.toStringBuilder(sb, printOnlyLabelValue); } } return sb.append(')'); } }	"  public StringBuilder toStringBuilder(StringBuilder sb, Function<Label,String> labelFormatter) {
    if (isLeaf()) {
      if (label() != null) {
        sb.append(labelFormatter.apply(label()));
      }
      return sb;
    } else {
      sb.append('(');
      if (label() != null) {
        sb.append(labelFormatter.apply(label()));
      }
      Tree[] kids = children();
      if (kids != null) {
        for (Tree kid : kids) {
          sb.append(' ');
          kid.toStringBuilder(sb, labelFormatter);
        }
      }
      return sb.append(')');
    }
  }
"	@param printOnlyLabelValue If true, print only the value() of each node's label	@param labelFormatter Formatting routine for how to print a Label	1	0	14	33	181
private RectF drawBoxWithShadow(Canvas c, Paint p, int width, int height) { Resources res = mContext.getResources(); float shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur); float keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance); float corner = res.getDimension(R.dimen.widget_preview_corner_radius); RectF bounds = new RectF(shadowBlur, shadowBlur, width - shadowBlur, height - shadowBlur - keyShadowDistance); p.setColor(Color.WHITE); // Key shadow p.setShadowLayer(shadowBlur, 0, keyShadowDistance, ShadowGenerator.KEY_SHADOW_ALPHA << 24); c.drawRoundRect(bounds, corner, corner, p); // Ambient shadow p.setShadowLayer(shadowBlur, 0, 0, ColorUtils.setAlphaComponent(Color.BLACK, ShadowGenerator.AMBIENT_SHADOW_ALPHA)); c.drawRoundRect(bounds, corner, corner, p); p.clearShadowLayer(); return bounds; }	"    private RectF drawBoxWithShadow(Canvas c, int width, int height) {
        Resources res = mContext.getResources();

        ShadowGenerator.Builder builder = new ShadowGenerator.Builder(Color.WHITE);
        builder.shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur);
        builder.radius = res.getDimension(R.dimen.widget_preview_corner_radius);
        builder.keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance);

        builder.bounds.set(builder.shadowBlur, builder.shadowBlur,
                width - builder.shadowBlur,
                height - builder.shadowBlur - builder.keyShadowDistance);
        builder.drawShadow(c);
        return builder.bounds;
    }
"	@param info information about the widget	@param info information about the widget	0	1	8	24	156
public static Criterion between(String propertyName, Object low, Object high) { return new BetweenExpression( propertyName, low, high ); }	"	public static Criterion between(String propertyName, Object lo, Object hi) {
		return new BetweenExpression( propertyName, lo, hi );
	}
"	@param high The high value	@param hi The high value	1	0	5	4	27
public Builder builder(RelNode rel, Clause... clauses) { final Clause maxClause = maxClause(); boolean needNew = false; // If old and new clause are equal and belong to below set, // then new SELECT wrap is not required Set<Clause> nonWrapSet = ImmutableSet.of(Clause.SELECT); for (Clause clause : clauses) { if (maxClause.ordinal() > clause.ordinal() || (maxClause.equals(clause) && !nonWrapSet.contains(clause))) { needNew = true; } } SqlSelect select; Expressions.FluentList<Clause> clauseList = Expressions.list(); if (needNew) { select = subSelect(); } else { select = asSelect(); clauseList.addAll(this.clauses); } clauseList.appendAll(clauses); Context newContext; final SqlNodeList selectList = select.getSelectList(); if (selectList != null) { newContext = new Context(selectList.size()) { public SqlNode field(int ordinal) { final SqlNode selectItem = selectList.get(ordinal); switch (selectItem.getKind()) { case AS: return ((SqlCall) selectItem).operand(0); } return selectItem; } }; } else { newContext = aliasContext(aliases, aliases.size() > 1); } return new Builder(rel, clauseList, select, newContext); }	"    public Builder builder(JdbcRel rel, Clause... clauses) {
      final Clause maxClause = maxClause();
      boolean needNew = false;
      for (Clause clause : clauses) {
        if (maxClause.ordinal() >= clause.ordinal()) {
          needNew = true;
        }
      }
      SqlSelect select;
      Expressions.FluentList<Clause> clauseList = Expressions.list();
      if (needNew) {
        select = subSelect();
      } else {
        select = asSelect();
        clauseList.addAll(this.clauses);
      }
      clauseList.appendAll(clauses);
      Context newContext;
      final SqlNodeList selectList = select.getSelectList();
      if (selectList != null) {
        newContext = new Context(selectList.size()) {
          @Override public SqlNode field(int ordinal) {
            final SqlNode selectItem = selectList.get(ordinal);
            switch (selectItem.getKind()) {
            case AS:
              return ((SqlCall) selectItem).operand(0);
            }
            return selectItem;
          }
        };
      } else {
        newContext = aliasContext(aliases, aliases.size() > 1);
      }
      return new Builder(rel, clauseList, select, newContext);
    }
"	@param rel Relational expression being implemented	@param rel Relational expression being implemented	0	1	13	40	247
public static RuleSet getDrillBasicRules(OptimizerRulesContext optimizerRulesContext) { if (DRILL_BASIC_RULES == null) { DRILL_BASIC_RULES = new DrillRuleSet(ImmutableSet.<RelOptRule> builder().add( // // Add support for Distinct Union (by using Union-All followed by Distinct) UnionToDistinctRule.INSTANCE, // Add support for WHERE style joins. DrillFilterJoinRules.DRILL_FILTER_ON_JOIN, DrillFilterJoinRules.DRILL_JOIN, // End support for WHERE style joins. /* Filter push-down related rules */ DrillPushFilterPastProjectRule.INSTANCE, FilterSetOpTransposeRule.INSTANCE, FilterMergeRule.INSTANCE, AggregateRemoveRule.INSTANCE, ProjectRemoveRule.NAME_CALC_INSTANCE, SortRemoveRule.INSTANCE, DrillMergeProjectRule.getInstance(true, RelFactories.DEFAULT_PROJECT_FACTORY, optimizerRulesContext.getFunctionRegistry()), AggregateExpandDistinctAggregatesRule.INSTANCE, DrillReduceAggregatesRule.INSTANCE, /* Projection push-down related rules */ DrillPushProjectPastFilterRule.INSTANCE, DrillPushProjectPastJoinRule.INSTANCE, DrillPushProjIntoScan.INSTANCE, DrillProjectSetOpTransposeRule.INSTANCE, PruneScanRule.getFilterOnProject(optimizerRulesContext), PruneScanRule.getFilterOnScan(optimizerRulesContext), PruneScanRule.getFilterOnProjectParquet(optimizerRulesContext), PruneScanRule.getFilterOnScanParquet(optimizerRulesContext), /* Convert from Calcite Logical to Drill Logical Rules. */ ExpandConversionRule.INSTANCE, DrillScanRule.INSTANCE, DrillFilterRule.INSTANCE, DrillProjectRule.INSTANCE, DrillWindowRule.INSTANCE, DrillAggregateRule.INSTANCE, DrillLimitRule.INSTANCE, DrillSortRule.INSTANCE, DrillJoinRule.INSTANCE, DrillUnionAllRule.INSTANCE, DrillValuesRule.INSTANCE ) .build()); } return DRILL_BASIC_RULES; }	"  public static RuleSet getDrillBasicRules(QueryContext context) {
    if (DRILL_BASIC_RULES == null) {

      DRILL_BASIC_RULES = new DrillRuleSet(ImmutableSet.<RelOptRule> builder().add( //
      // Add support for Distinct Union (by using Union-All followed by Distinct)
      UnionToDistinctRule.INSTANCE,

      // Add support for WHERE style joins.
      DrillFilterJoinRules.DRILL_FILTER_ON_JOIN,
      DrillFilterJoinRules.DRILL_JOIN,
      // End support for WHERE style joins.

      /*
       Filter push-down related rules
       */
      DrillPushFilterPastProjectRule.INSTANCE,
      FilterSetOpTransposeRule.INSTANCE,

      FilterMergeRule.INSTANCE,
      AggregateRemoveRule.INSTANCE,
      ProjectRemoveRule.NAME_CALC_INSTANCE,
      SortRemoveRule.INSTANCE,

      DrillMergeProjectRule.getInstance(true, RelFactories.DEFAULT_PROJECT_FACTORY, context.getFunctionRegistry()),
      AggregateExpandDistinctAggregatesRule.INSTANCE,
      DrillReduceAggregatesRule.INSTANCE,

      /*
       Projection push-down related rules
       */
      DrillPushProjectPastFilterRule.INSTANCE,
      DrillPushProjectPastJoinRule.INSTANCE,
      DrillPushProjIntoScan.INSTANCE,
      DrillProjectSetOpTransposeRule.INSTANCE,

      PruneScanRule.getFilterOnProject(context),
      PruneScanRule.getFilterOnScan(context),
      PruneScanRule.getFilterOnProjectParquet(context),
      PruneScanRule.getFilterOnScanParquet(context),

      /*
       Convert from Calcite Logical to Drill Logical Rules.
       */
      ExpandConversionRule.INSTANCE,
      DrillScanRule.INSTANCE,
      DrillFilterRule.INSTANCE,
      DrillProjectRule.INSTANCE,
      DrillWindowRule.INSTANCE,
      DrillAggregateRule.INSTANCE,

      DrillLimitRule.INSTANCE,
      DrillSortRule.INSTANCE,
      DrillJoinRule.INSTANCE,
      DrillUnionAllRule.INSTANCE,
      DrillValuesRule.INSTANCE
      )
      .build());
    }

    return DRILL_BASIC_RULES;
  }
"	@param optimizerRulesContext - shared state used during planning, currently used here to gain access to the function registry described above.	@param context - shared state used during planning, currently used here to gain access to the fucntion registry described above.	1	0	11	63	219
"public static RemoteProxy getNewBasicRemoteProxy(List<Map<String, Object>> caps, String url,Registry registry) { RegistrationRequest req = new RegistrationRequest(); req.setCapabilities(caps); Map<String, Object> config = new HashMap<String, Object>(); config.put(""url"", url); req.setConfiguration(config); return new RemoteProxy(req,registry); }"	"	public static RemoteProxy getNewBasicRemoteProxy(List<Map<String, Object>> caps, String url) {

		RegistrationRequest req = new RegistrationRequest();

		req.setCapabilities(caps);

		Map<String, Object> config = new HashMap<String, Object>();
		config.put(""url"", url);
		req.setConfiguration(config);
		return new RemoteProxy(req);

	}
"	@param url	@param url	0	1	8	13	71
"private URL determineSuiteUrl(String startURL, String suiteURL) throws IOException { if (suiteURL.startsWith(""https://"") || suiteURL.startsWith(""http://"")) { return verifySuiteUrl(new URL(suiteURL)); } // Is the suiteURL a file? Path path = Paths.get(suiteURL); if (Files.exists(path)) { // Not all drivers can read files from the disk, so we need to host the suite somewhere. try (SocketLock lock = new SocketLock()) { server = new Server(); HttpConfiguration httpConfig = new HttpConfiguration(); ServerConnector http = new ServerConnector(server, new HttpConnectionFactory(httpConfig)); int port = PortProber.findFreePort(); http.setPort(port); http.setIdleTimeout(500000); server.setConnectors(new Connector[]{http}); ResourceHandler handler = new ResourceHandler(); handler.setDirectoriesListed(true); handler.setWelcomeFiles(new String[]{path.getFileName().toString(), ""index.html""}); handler.setBaseResource(new PathResource(path.toFile().getParentFile().toPath().toRealPath())); ContextHandler context = new ContextHandler(""/tests""); context.setHandler(handler); server.setHandler(context); server.start(); PortProber.waitForPortUp(port, 15, SECONDS); URL serverUrl = server.getURI().toURL(); return new URL(serverUrl.getProtocol(), serverUrl.getHost(), serverUrl.getPort(), ""/tests/""); } catch (Exception e) { throw new IOException(e); } } // Well then, it must be a URL relative to whatever the browserUrl. Probe and find out. URL browser = new URL(startURL); return verifySuiteUrl(new URL(browser, suiteURL)); }"	"  private URL determineSuiteUrl(String browserUrl, String suiteURL) throws IOException {
    if (suiteURL.startsWith(""https://"") || suiteURL.startsWith(""http://"")) {
      return verifySuiteUrl(new URL(suiteURL));
    }

    // Is the suiteURL a file?
    Path path = Paths.get(suiteURL);
    if (Files.exists(path)) {
      // Not all drivers can read files from the disk, so we need to host the suite somewhere.
      try (SocketLock lock = new SocketLock()) {
        server = new Server();
        HttpConfiguration httpConfig = new HttpConfiguration();

        ServerConnector http = new ServerConnector(server, new HttpConnectionFactory(httpConfig));
        int port = PortProber.findFreePort();
        http.setPort(port);
        http.setIdleTimeout(500000);
        server.setConnectors(new Connector[]{http});

        ResourceHandler handler = new ResourceHandler();
        handler.setDirectoriesListed(true);
        handler.setWelcomeFiles(new String[]{path.getFileName().toString(), ""index.html""});
        handler.setBaseResource(new PathResource(path.toFile().getParentFile().toPath().toRealPath()));

        ContextHandler context = new ContextHandler(""/tests"");
        context.setHandler(handler);

        server.setHandler(context);
        server.start();

        PortProber.waitForPortUp(port, 15, SECONDS);

        URL serverUrl = server.getURI().toURL();
        return new URL(serverUrl.getProtocol(), serverUrl.getHost(), serverUrl.getPort(),
                       ""/tests/"");
      } catch (Exception e) {
        throw new IOException(e);
      }
    }

    // Well then, it must be a URL relative to whatever the browserUrl. Probe and find out.
    URL browser = new URL(browserUrl);
    return verifySuiteUrl(new URL(browser, suiteURL));
  }
"	@param outputFile - The file to which we'll output the HTML results	@param outputFile - The file to which we'll output the HTML results	0	1	11	45	351
public static int bitCount(long lng) { lng = (lng & 0x5555555555555555L) + ((lng >> 1) & 0x5555555555555555L); lng = (lng & 0x3333333333333333L) + ((lng >> 2) & 0x3333333333333333L); // adjust for 64-bit integer int i = (int) ((lng >>> 32) + lng); i = (i & 0x0F0F0F0F) + ((i >> 4) & 0x0F0F0F0F); i = (i & 0x00FF00FF) + ((i >> 8) & 0x00FF00FF); i = (i & 0x0000FFFF) + ((i >> 16) & 0x0000FFFF); return i; }	"    public static int bitCount(long v) {
        // Combines techniques from several sources
        v -=  (v >>> 1) & 0x5555555555555555L;
        v = (v & 0x3333333333333333L) + ((v >> 2) & 0x3333333333333333L);
        int i =  ((int)(v >>> 32)) + (int) v;
        i = (i & 0x0F0F0F0F) + ((i >> 4) & 0x0F0F0F0F);
        i += i >>> 8;
        i += i >>> 16;
        return i  & 0x0000007F;
    }
"	@param lng the long to examine.	@param v the long to examine.	1	0	8	12	115
public static <T> Stream<T> from( T object ) { return new Stream<T>( new RepeatingObjectIterator<T>( object ), null ) ; }	"    @SuppressWarnings(""unchecked"")
    public static <T> Stream<T> from( T[] array ) {
        return new Stream<T>( primitiveArrayToList( array ).iterator(), null ) ;
    }
"	@param  The type of the  Object.	@param The type of the array.	1	0	8	5	27
"public Request buildRequest(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); final String url = buildUrl(path, queryParams, collectionQueryParams); final Request.Builder reqBuilder = new Request.Builder().url(url); processHeaderParams(headerParams, reqBuilder); String contentType = (String) headerParams.get(""Content-Type""); // ensuring a default content type if (contentType == null) { contentType = ""application/json""; } RequestBody reqBody; if (!HttpMethod.permitsRequestBody(method)) { reqBody = null; } else if (""application/x-www-form-urlencoded"".equals(contentType)) { reqBody = buildRequestBodyFormEncoding(formParams); } else if (""multipart/form-data"".equals(contentType)) { reqBody = buildRequestBodyMultipart(formParams); } else if (body == null) { if (""DELETE"".equals(method)) { // allow calling DELETE without sending a request body reqBody = null; } else { // use an empty request body (for POST, PUT and PATCH) reqBody = RequestBody.create(MediaType.parse(contentType), """"); } } else { reqBody = serialize(body, contentType); } // Associate callback with request (if not null) so interceptor can // access it when creating ProgressResponseBody reqBuilder.tag(callback); Request request = null; if (callback != null && reqBody != null) { ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, callback); request = reqBuilder.method(method, progressRequestBody).build(); } else { request = reqBuilder.method(method, reqBody).build(); } return request; }"	"    public Request buildRequest(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        updateParamsForAuth(authNames, queryParams, headerParams);

        final String url = buildUrl(path, queryParams, collectionQueryParams);
        final Request.Builder reqBuilder = new Request.Builder().url(url);
        processHeaderParams(headerParams, reqBuilder);

        String contentType = (String) headerParams.get(""Content-Type"");
        // ensuring a default content type
        if (contentType == null) {
            contentType = ""application/json"";
        }

        RequestBody reqBody;
        if (!HttpMethod.permitsRequestBody(method)) {
            reqBody = null;
        } else if (""application/x-www-form-urlencoded"".equals(contentType)) {
            reqBody = buildRequestBodyFormEncoding(formParams);
        } else if (""multipart/form-data"".equals(contentType)) {
            reqBody = buildRequestBodyMultipart(formParams);
        } else if (body == null) {
            if (""DELETE"".equals(method)) {
                // allow calling DELETE without sending a request body
                reqBody = null;
            } else {
                // use an empty request body (for POST, PUT and PATCH)
                reqBody = RequestBody.create(MediaType.parse(contentType), """");
            }
        } else {
            reqBody = serialize(body, contentType);
        }

        Request request = null;

        if(progressRequestListener != null && reqBody != null) {
            ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, progressRequestListener);
            request = reqBuilder.method(method, progressRequestBody).build();
        } else {
            request = reqBuilder.method(method, reqBody).build();
        }

        return request;
    }
"	@param path The sub-path of the HTTP URL	@param path The sub-path of the HTTP URL	0	1	14	48	350
public ArrayList<View> getAllViews(boolean onlySufficientlyVisible) { Activity activity = activityUtils.getCurrentActivity(false); final View [] views = getWindowDecorViews(); final ArrayList<View> allViews = new ArrayList<View>(); final View [] nonDecorViews = getNonDecorViews(views); if(views !=null && views.length > 0) { if(!activity.hasWindowFocus()){ for(View view : views){ if(!activity.getWindow().getDecorView().equals(view)){ try{ addChildren(allViews,(ViewGroup) view, onlySufficientlyVisible); } catch (Exception ignored) {} } } } else{ for(View view : nonDecorViews){ try{ addChildren(allViews,(ViewGroup) view, onlySufficientlyVisible); } catch (Exception ignored) {} } try{ addChildren(allViews,(ViewGroup) getRecentDecorView(views), onlySufficientlyVisible); } catch (Exception ignored) {} } } return allViews; }	"	public ArrayList<View> getAllViews(boolean onlyFullyVisible)
	{
		Activity activity = activityUtils.getCurrentActivity(false);
		final View [] views = getWindowDecorViews();
		final ArrayList<View> allViews = new ArrayList<View>();
		final View [] nonDecorViews = getNonDecorViews(views);
		if(views !=null && views.length > 0)
		{
			if(!activity.hasWindowFocus()){
				for(View view : views){
					if(!activity.getWindow().getDecorView().equals(view)){
						try{
							addChildren(allViews,(ViewGroup) view, onlyFullyVisible);
						}
						catch (Exception ignored) {}
					}
				}
			}
			else{
				for(View view : nonDecorViews){
					try{
						addChildren(allViews,(ViewGroup) view, onlyFullyVisible);
					}
					catch (Exception ignored) {}
				}	
				try{
					addChildren(allViews,(ViewGroup) getRecentDecorView(views), onlyFullyVisible);
				}
				catch (Exception ignored) {}
			}
		}
		return allViews;
	}
"	@param onlySufficientlyVisible if only sufficiently visible views should be returned	@param onlyFullyVisible if only fully visible views should be returned	1	0	15	34	180
"public void createUsersWithListInput (List<User> user) throws ApiException { Object localVarPostBody = user; // verify the required parameter 'user' is set if (user == null) { throw new ApiException(400, ""Missing the required parameter 'user' when calling createUsersWithListInput""); } // create path and map variables String localVarPath = ""/user/createWithList"".replaceAll(""\\{format\\}"",""json""); // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); // header params Map<String, String> localVarHeaderParams = new HashMap<String, String>(); // form params Map<String, String> localVarFormParams = new HashMap<String, String>(); String[] localVarContentTypes = { }; String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : ""application/json""; if (localVarContentType.startsWith(""multipart/form-data"")) { // file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); localVarPostBody = localVarBuilder.build(); } else { // normal form params } try { String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, ""POST"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType); if(localVarResponse != null){ return ; } else { return ; } } catch (ApiException ex) { throw ex; } }"	"  public void  createUsersWithListInput (List<User> body) throws ApiException {
    Object localVarPostBody = body;
    // verify the required parameter 'body' is set
    if (body == null) {
       throw new ApiException(400, ""Missing the required parameter 'body' when calling createUsersWithListInput"");
    }

    // create path and map variables
    String localVarPath = ""/user/createWithList"".replaceAll(""\\{format\\}"",""json"");

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    // form params
    Map<String, String> localVarFormParams = new HashMap<String, String>();



    String[] localVarContentTypes = {
      
    };
    String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : ""application/json"";

    if (localVarContentType.startsWith(""multipart/form-data"")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      localVarPostBody = localVarBuilder.build();
    } else {
      // normal form params
          }

    try {
      String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, ""POST"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType);
      if(localVarResponse != null){
        return ;
      }
      else {
        return ;
      }
    } catch (ApiException ex) {
      throw ex;
    }
  }
"	@param user List of user object	@param body List of user object	1	0	8	47	250
public static <T> Stream<T> from( T object ) { return new Stream<T>( new RepeatingObjectIterator<T>( object ), null ) ; }	"    @SuppressWarnings(""unchecked"")
    public static <T> Stream<T> from( T[] array ) {
        return new Stream<T>( primitiveArrayToList( array ).iterator(), null ) ;
    }
"	@param object The object to return each time an element is requested.	@param array An array of Object to iterate	1	0	8	5	27
"public static String getClassName(String memberID, boolean isClassMember) { int pos = memberID.indexOf(ALT_MEMBER_SEPARATOR); // uses alternative separator, easy if (pos != -1) return memberID.substring(0, pos); pos = memberID.indexOf('('); if ( pos != -1 ) { // has a descriptor, is a method ID, strip last member part pos = memberID.lastIndexOf('.', pos); return pos != -1 ? memberID.substring(0, pos) : """"; } if (isClassMember) { // field or class name, cannot decide, assume it is a field pos = memberID.lastIndexOf('.'); return pos != -1 ? memberID.substring(0, pos) : """"; } else { // assume it is a class name return memberID; } }"	"    public static String getClassName(String signature, boolean isClassMember) {
        int pos = signature.indexOf(ALT_MEMBER_SEPARATOR);
        // uses alternative separator, easy
        if (pos != -1) return signature.substring(0, pos);

        pos = signature.indexOf('(');
        if ( pos != -1 ) {
            // has a descriptor, is a method signature, strip last member part
            pos = signature.lastIndexOf('.', pos);
            return pos != -1 ? signature.substring(0, pos) : """";
        }

        if (isClassMember) {
            // field or class name, cannot decide, assume it is a field
            pos = signature.lastIndexOf('.');
            return pos != -1 ? signature.substring(0, pos) : """";
        } else {
            // assume it is a class name
            return signature;
        }
    }
"	@param memberID the member ID to parse.	@param signature the signature to parse.	1	0	8	23	164
public int get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }	"    public int get(WithAttributes attributes) {
        return attributes.getAttributes().get(this);
    }
"	@param withAttributes an object containing an AttributeMap	@param attributes an object containing an AttributeMap	1	0	6	5	19
"public boolean remove(final BaseDownloadTask willRemoveDownload, final int removeByStatus) { boolean succeed; synchronized (list) { succeed = list.remove(willRemoveDownload); } if (succeed) { //  switch (removeByStatus) { case FileDownloadStatus.warn: willRemoveDownload.getDriver().notifyWarn(); break; case FileDownloadStatus.error: willRemoveDownload.getDriver().notifyError(); break; case FileDownloadStatus.paused: willRemoveDownload.getDriver().notifyPaused(); break; case FileDownloadStatus.completed: Throwable ex = null; try{ willRemoveDownload.getDriver().notifyBlockComplete(); }catch (Throwable e){ ex = e; } if (ex != null) { willRemoveDownload.setStatus(FileDownloadStatus.error); willRemoveDownload.setEx(ex); willRemoveDownload.getDriver().notifyError(); } else { willRemoveDownload.getDriver().notifyCompleted(); } break; } } else { FileDownloadLog.e(this, ""remove error, not exist: %s"", willRemoveDownload); } return succeed; }"	"    public boolean remove(final BaseFileDownloadInternal willRemoveDownload, final int removeByStatus) {
        boolean succeed;
        synchronized (list) {
            succeed = list.remove(willRemoveDownload);
        }

        if (succeed) {
            // 
            switch (removeByStatus) {
                case FileDownloadStatus.warn:
                    willRemoveDownload.getDriver().notifyWarn();
                    break;
                case FileDownloadStatus.error:
                    willRemoveDownload.getDriver().notifyError();
                    break;
                case FileDownloadStatus.paused:
                    willRemoveDownload.getDriver().notifyPaused();
                    break;
                case FileDownloadStatus.completed:
                    Throwable ex = null;
                    try{
                        willRemoveDownload.getDriver().notifyBlockComplete();
                    }catch (Throwable e){
                        ex = e;
                    }

                    if (ex != null) {
                        willRemoveDownload.setStatus(FileDownloadStatus.error);
                        willRemoveDownload.setEx(ex);
                        willRemoveDownload.getDriver().notifyError();
                    } else {
                        willRemoveDownload.getDriver().notifyCompleted();
                    }
                    break;
            }

        } else {
            FileDownloadLog.e(this, ""remove error, not exist: %s"", willRemoveDownload);
        }

        return succeed;
    }
"	@param willRemoveDownload	@param willRemoveDownload	0	1	11	43	185
"public Boolean fakeOuterBooleanSerialize(Boolean booleanPostBody) throws ApiException { Object localVarPostBody = booleanPostBody; // create path and map variables String localVarPath = ""/fake/outer/boolean""; // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { ""*/*"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {}; return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	"  public Boolean fakeOuterBooleanSerialize(Boolean body) throws ApiException {
    Object localVarPostBody = body;
    
    // create path and map variables
    String localVarPath = ""/fake/outer/boolean"";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    final String[] localVarAccepts = {
      
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {};
    return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);
      }
"	@param booleanPostBody Input boolean as post body (optional)	@param body Input boolean as post body (optional)	1	0	8	31	171
"public int compareTo(ReadablePartial other) { if (this == other) { return 0; } if (size() != other.size()) { throw new ClassCastException(""ReadablePartial objects must have matching field types""); } for (int i = 0, isize = size(); i < isize; i++) { if (getFieldType(i) != other.getFieldType(i)) { throw new ClassCastException(""ReadablePartial objects must have matching field types""); } } // fields are ordered largest first for (int i = 0, isize = size(); i < isize; i++) { if (getValue(i) > other.getValue(i)) { return 1; } if (getValue(i) < other.getValue(i)) { return -1; } } return 0; }"	"    public int compareTo(Object partial) {
        if (this == partial) {
            return 0;
        }
        ReadablePartial other = (ReadablePartial) partial;
        if (size() != other.size()) {
            throw new ClassCastException(""ReadablePartial objects must have matching field types"");
        }
        for (int i = 0, isize = size(); i < isize; i++) {
            if (getFieldType(i) != other.getFieldType(i)) {
                throw new ClassCastException(""ReadablePartial objects must have matching field types"");
            }
        }
        // fields are ordered largest first
        for (int i = 0, isize = size(); i < isize; i++) {
            if (getValue(i) > other.getValue(i)) {
                return 1;
            }
            if (getValue(i) < other.getValue(i)) {
                return -1;
            }
        }
        return 0;
    }
"	@param other an object to check against	@param partial an object to check against	1	0	9	24	162
private static EntityKey getOptionalObjectKey(QueryParameters queryParameters, SharedSessionContractImplementor session) { final Object optionalObject = queryParameters.getOptionalObject(); final Serializable optionalId = queryParameters.getOptionalId(); final String optionalEntityName = queryParameters.getOptionalEntityName(); if ( optionalObject != null && optionalEntityName != null ) { return session.generateEntityKey( optionalId, session.getEntityPersister( optionalEntityName, optionalObject ) ); } else { return null; } }	"	private static EntityKey getOptionalObjectKey(QueryParameters queryParameters, SessionImplementor session) {
		final Object optionalObject = queryParameters.getOptionalObject();
		final Serializable optionalId = queryParameters.getOptionalId();
		final String optionalEntityName = queryParameters.getOptionalEntityName();

		if ( optionalObject != null && optionalEntityName != null ) {
			return session.generateEntityKey(
					optionalId, session.getEntityPersister(
							optionalEntityName,
							optionalObject
					)
			);
		}
		else {
			return null;
		}

	}
"	@param queryParameters The query parameters specified by the user.	@param queryParameters The query parameters specified by the user.	0	1	8	19	71
"public ApiResponse<Client> testClientModelWithHttpInfo(Client client) throws ApiException { Object localVarPostBody = client; // verify the required parameter 'client' is set if (client == null) { throw new ApiException(400, ""Missing the required parameter 'client' when calling testClientModel""); } // create path and map variables String localVarPath = ""/fake""; // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { ""application/json"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { ""application/json"" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Client> localVarReturnType = new GenericType<Client>() {}; return apiClient.invokeAPI(localVarPath, ""PATCH"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	"  public ApiResponse<Client> testClientModelWithHttpInfo(Client body) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, ""Missing the required parameter 'body' when calling testClientModel"");
    }
    
    // create path and map variables
    String localVarPath = ""/fake"";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    final String[] localVarAccepts = {
      ""application/json""
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      ""application/json""
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    GenericType<Client> localVarReturnType = new GenericType<Client>() {};
    return apiClient.invokeAPI(localVarPath, ""PATCH"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);
      }
"	@param client client model (required)	@param body client model (required)	1	0	8	35	200
"public Object getCollection(Serializable key, SharedSessionContractImplementor session, Object owner) { CollectionPersister persister = getPersister( session ); final PersistenceContext persistenceContext = session.getPersistenceContext(); final EntityMode entityMode = persister.getOwnerEntityPersister().getEntityMode(); // check if collection is currently being loaded PersistentCollection collection = persistenceContext.getLoadContexts().locateLoadingCollection( persister, key ); if ( collection == null ) { // check if it is already completely loaded, but unowned collection = persistenceContext.useUnownedCollection( new CollectionKey(persister, key, entityMode) ); if ( collection == null ) { collection = persistenceContext.getCollection( new CollectionKey(persister, key, entityMode) ); if ( collection == null ) { // create a new collection wrapper, to be initialized later collection = instantiate( session, persister, key ); collection.setOwner( owner ); persistenceContext.addUninitializedCollection( persister, collection, key ); // some collections are not lazy: if ( initializeImmediately() ) { session.initializeCollection( collection, false ); } else if ( !persister.isLazy() ) { persistenceContext.addNonLazyCollection( collection ); } if ( hasHolder() ) { session.getPersistenceContext().addCollectionHolder( collection ); } } } if ( LOG.isTraceEnabled() ) { LOG.tracef( ""Created collection wrapper: %s"", MessageHelper.collectionInfoString( persister, collection, key, session ) ); } } collection.setOwner(owner); return collection.getValue(); }"	"	public Object getCollection(Serializable key, SessionImplementor session, Object owner) {

		CollectionPersister persister = getPersister( session );
		final PersistenceContext persistenceContext = session.getPersistenceContext();
		final EntityMode entityMode = persister.getOwnerEntityPersister().getEntityMode();

		// check if collection is currently being loaded
		PersistentCollection collection = persistenceContext.getLoadContexts().locateLoadingCollection( persister, key );
		
		if ( collection == null ) {
			
			// check if it is already completely loaded, but unowned
			collection = persistenceContext.useUnownedCollection( new CollectionKey(persister, key, entityMode) );
			
			if ( collection == null ) {

				collection = persistenceContext.getCollection( new CollectionKey(persister, key, entityMode) );

				if ( collection == null ) {
					// create a new collection wrapper, to be initialized later
					collection = instantiate( session, persister, key );

					collection.setOwner( owner );

					persistenceContext.addUninitializedCollection( persister, collection, key );

					// some collections are not lazy:
					if ( initializeImmediately() ) {
						session.initializeCollection( collection, false );
					}
					else if ( !persister.isLazy() ) {
						persistenceContext.addNonLazyCollection( collection );
					}

					if ( hasHolder() ) {
						session.getPersistenceContext().addCollectionHolder( collection );
					}
				}

			}
			
			if ( LOG.isTraceEnabled() ) {
				LOG.tracef( ""Created collection wrapper: %s"",
						MessageHelper.collectionInfoString( persister, collection,
								key, session ) );
			}
			
		}
		
		collection.setOwner(owner);

		return collection.getValue();
	}
"	@param session The session from which the request is originating.	@param session The session from which the request is originating.	0	1	14	54	268
public static FileSelection create(List<FileStatus> statuses, List<Path> files, Path root) { return FileSelection.create(statuses, files, root, null, false); }	"  public static FileSelection create(final List<FileStatus> statuses, final List<String> files, final String root) {
    return FileSelection.create(statuses, files, root, null, false);
  }
"	@param statuses list of file statuses	@param statuses list of file statuses	0	1	6	4	33
"public List<TypedDependency> typedDependenciesCollapsed(boolean includeExtras) { List<TypedDependency> tdl = typedDependencies(false); // Adds stuff to the basic dependencies. // We don't want to simply call typedDependencies with // ""includeExtras"" because the collapseDependencies method may add // the extras in a way that makes more logical sense. For // example, the English dependencies, when CC processed, have more // nsubjs than they originally do. If we wait until that occurs // to add xsubj for xcomp dependencies, we get better coverage. if (includeExtras) { getTreeDeps(root(), tdl, new NoPunctTypedDependencyFilter(puncFilter), extraTreeDepFilter()); } collapseDependencies(tdl, false, includeExtras); return tdl; }"	"  public List<TypedDependency> typedDependenciesCollapsed(Extras includeExtras) {
    List<TypedDependency> tdl = typedDependencies(includeExtras);
    collapseDependencies(tdl, false, includeExtras);
    return tdl;
  }
"	"@param includeExtras If true, the list of typed dependencies returned may include ""extras"", like controlling subjects"	"@param includeExtras If true, the list of typed dependencies returned may include ""extras"", like controlling subjects"	0	1	8	16	139
"public Boolean fakeOuterBooleanSerialize(Boolean body) throws RestClientException { Object postBody = body; String path = UriComponentsBuilder.fromPath(""/fake/outer/boolean"").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { ""*/*"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<Boolean> returnType = new ParameterizedTypeReference<Boolean>() {}; return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }"	"    public Boolean fakeOuterBooleanSerialize(Boolean booleanPostBody) throws RestClientException {
        Object postBody = booleanPostBody;
        
        String path = UriComponentsBuilder.fromPath(""/fake/outer/boolean"").build().toUriString();
        
        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();
        final HttpHeaders headerParams = new HttpHeaders();
        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();

        final String[] accepts = { 
            ""*/*""
        };
        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);
        final String[] contentTypes = { };
        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);

        String[] authNames = new String[] {  };

        ParameterizedTypeReference<Boolean> returnType = new ParameterizedTypeReference<Boolean>() {};
        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);
    }
"	@param body Input boolean as post body	@param booleanPostBody Input boolean as post body	1	0	8	22	160
"public Collection<Tree> getRelatedNodes(Tree t, Tree root) { if (root.value() == null) { root.setValue(""ROOT""); // todo: cdm: it doesn't seem like this line should be here } Set<Tree> nodeList = new LinkedHashSet<Tree>(); for (TregexPattern p : targetPatterns) { // cdm: I deleted: && nodeList.isEmpty() TregexMatcher m = p.matcher(root); while (m.findAt(t)) { nodeList.add(m.getNode(""target"")); //System.out.println(""found "" + this + ""("" + t + "", "" + m.getNode(""target"") + "") using pattern "" + p); } } return nodeList; }"	"  public Collection<TreeGraphNode> getRelatedNodes(TreeGraphNode t, TreeGraphNode root, HeadFinder headFinder) {
    Set<TreeGraphNode> nodeList = new ArraySet<TreeGraphNode>();
    for (TregexPattern p : targetPatterns) {    // cdm: I deleted: && nodeList.isEmpty()
      // Initialize the TregexMatcher with the HeadFinder so that we
      // can use the same HeadFinder through the entire process of
      // building the dependencies
      TregexMatcher m = p.matcher(root, headFinder);
      while (m.findAt(t)) {
        TreeGraphNode target = (TreeGraphNode) m.getNode(""target"");
        if (target == null) {
          throw new AssertionError(""Expression has no target: "" + p);
        }
        nodeList.add(target);
        if (DEBUG) {
          System.err.println(""found "" + this + ""("" + t + ""-"" + t.headWordNode() + "", "" + m.getNode(""target"") + ""-"" + ((TreeGraphNode) m.getNode(""target"")).headWordNode() + "") using pattern "" + p);
          for (String nodeName : m.getNodeNames()) {
            if (nodeName.equals(""target""))
              continue;
            System.err.println(""  node "" + nodeName + "": "" + m.getNode(nodeName));
          }
        }
      }
    }
    return nodeList;
  }
"	@param root The root of the Tree	@param root The root of the Tree	0	1	10	15	151
public static FromContext getInstance(String fromString) { if (NAME.getFromString().equalsIgnoreCase(fromString)) return NAME; else if (ALIAS.getFromString().equalsIgnoreCase(fromString)) return ALIAS; else if (METADATA.getFromString().equalsIgnoreCase(fromString)) return METADATA; else if (BEANINFO.getFromString().equalsIgnoreCase(fromString)) return BEANINFO; else if (SCOPE.getFromString().equalsIgnoreCase(fromString)) return SCOPE; else if (ID.getFromString().equalsIgnoreCase(fromString)) return ID; else return new DynamicFromContext(fromString); }	"   public static FromContext getInstance(String optionString)
   {
      if (NAME.getFromString().equalsIgnoreCase(optionString))
         return NAME;
      else if (METADATA.getFromString().equalsIgnoreCase(optionString))
         return METADATA;
      else if (SCOPE.getFromString().equalsIgnoreCase(optionString))
         return SCOPE;
      else if (ID.getFromString().equalsIgnoreCase(optionString))
         return ID;
      else
         return new DynamicFromContext(optionString);
   }
"	@param fromString type	@param optionString type	1	0	11	19	107
"public boolean applyAPSRequest(APSResult request, Callback callback) { PumpInterface pump = getActivePump(); request.rate = applyBasalConstraints(request.rate); PumpEnactResult result; if (!pump.isInitialized()) { log.debug(""applyAPSRequest: "" + MainApp.sResources.getString(R.string.pumpNotInitialized)); if (callback != null) { callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpNotInitialized)).enacted(false).success(false)).run(); } return false; } if (pump.isSuspended()) { log.debug(""applyAPSRequest: "" + MainApp.sResources.getString(R.string.pumpsuspended)); if (callback != null) { callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpsuspended)).enacted(false).success(false)).run(); } return false; } if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: "" + request.toString()); if ((request.rate == 0 && request.duration == 0) || Math.abs(request.rate - pump.getBaseBasalRate()) < pump.getPumpDescription().basalStep) { if (isTempBasalInProgress()) { if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: cancelTempBasal()""); getCommandQueue().cancelTempBasal(false, callback); return true; } else { if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: Basal set correctly""); if (callback != null) { callback.result(new PumpEnactResult().absolute(request.rate).duration(0).enacted(false).success(true).comment(""Basal set correctly"")).run(); } return false; } } else if (isTempBasalInProgress() && getTempBasalRemainingMinutesFromHistory() > 5 && Math.abs(request.rate - getTempBasalAbsoluteRateHistory()) < pump.getPumpDescription().basalStep) { if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: Temp basal set correctly""); if (callback != null) { callback.result(new PumpEnactResult().absolute(getTempBasalAbsoluteRateHistory()).duration(getTempBasalFromHistory(System.currentTimeMillis()).getPlannedRemainingMinutes()).enacted(false).success(true).comment(""Temp basal set correctly"")).run(); } return false; } else { if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: setTempBasalAbsolute()""); getCommandQueue().tempBasalAbsolute(request.rate, request.duration, false, callback); return true; } }"	"    public PumpEnactResult applyAPSRequest(APSResult request) {
        request.rate = applyBasalConstraints(request.rate);
        PumpEnactResult result;

        if (!isInitialized()) {
            result = new PumpEnactResult();
            result.comment = MainApp.sResources.getString(R.string.pumpNotInitialized);
            result.enacted = false;
            result.success = false;
            log.debug(""applyAPSRequest: "" + MainApp.sResources.getString(R.string.pumpNotInitialized));
            return result;
        }

        if (isSuspended()) {
            result = new PumpEnactResult();
            result.comment = MainApp.sResources.getString(R.string.pumpsuspended);
            result.enacted = false;
            result.success = false;
            log.debug(""applyAPSRequest: "" + MainApp.sResources.getString(R.string.pumpsuspended));
            return result;
        }

        if (Config.logCongigBuilderActions)
            log.debug(""applyAPSRequest: "" + request.toString());
        if ((request.rate == 0 && request.duration == 0) || Math.abs(request.rate - getBaseBasalRate()) < getPumpDescription().basalStep) {
            if (isTempBasalInProgress()) {
                if (Config.logCongigBuilderActions)
                    log.debug(""applyAPSRequest: cancelTempBasal()"");
                result = cancelTempBasal(false);
            } else {
                result = new PumpEnactResult();
                result.absolute = request.rate;
                result.duration = 0;
                result.enacted = false;
                result.comment = ""Basal set correctly"";
                result.success = true;
                if (Config.logCongigBuilderActions)
                    log.debug(""applyAPSRequest: Basal set correctly"");
            }
        } else if (isTempBasalInProgress()
                && getTempBasalRemainingMinutesFromHistory() > 5
                && Math.abs(request.rate - getTempBasalAbsoluteRateHistory()) < getPumpDescription().basalStep) {
            result = new PumpEnactResult();
            result.absolute = getTempBasalAbsoluteRateHistory();
            result.duration = getTempBasalFromHistory(System.currentTimeMillis()).getPlannedRemainingMinutes();
            result.enacted = false;
            result.comment = ""Temp basal set correctly"";
            result.success = true;
            if (Config.logCongigBuilderActions)
                log.debug(""applyAPSRequest: Temp basal set correctly"");
        } else {
            if (Config.logCongigBuilderActions)
                log.debug(""applyAPSRequest: setTempBasalAbsolute()"");
            result = setTempBasalAbsolute(request.rate, request.duration);
        }
        return result;
    }
"	@param request	@param request	0	1	13	54	474
"public Order placeOrder (Order order) throws ApiException { Object localVarPostBody = order; // verify the required parameter 'order' is set if (order == null) { throw new ApiException(400, ""Missing the required parameter 'order' when calling placeOrder""); } // create path and map variables String localVarPath = ""/store/order"".replaceAll(""\\{format\\}"",""json""); // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); // header params Map<String, String> localVarHeaderParams = new HashMap<String, String>(); // form params Map<String, String> localVarFormParams = new HashMap<String, String>(); String[] localVarContentTypes = { ""application/json"" }; String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : ""application/json""; if (localVarContentType.startsWith(""multipart/form-data"")) { // file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); localVarPostBody = localVarBuilder.build(); } else { // normal form params } try { String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, ""POST"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType); if(localVarResponse != null){ return (Order) ApiInvoker.deserialize(localVarResponse, """", Order.class); } else { return null; } } catch (ApiException ex) { throw ex; } }"	"  public Order  placeOrder (Order body) throws ApiException {
    Object localVarPostBody = body;
    // verify the required parameter 'body' is set
    if (body == null) {
       throw new ApiException(400, ""Missing the required parameter 'body' when calling placeOrder"");
    }

    // create path and map variables
    String localVarPath = ""/store/order"".replaceAll(""\\{format\\}"",""json"");

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    // form params
    Map<String, String> localVarFormParams = new HashMap<String, String>();



    String[] localVarContentTypes = {
      
    };
    String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : ""application/json"";

    if (localVarContentType.startsWith(""multipart/form-data"")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      localVarPostBody = localVarBuilder.build();
    } else {
      // normal form params
          }

    try {
      String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, ""POST"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType);
      if(localVarResponse != null){
        return (Order) ApiInvoker.deserialize(localVarResponse, """", Order.class);
      }
      else {
        return null;
      }
    } catch (ApiException ex) {
      throw ex;
    }
  }
"	@param order order placed for purchasing the pet	@param body order placed for purchasing the pet	1	0	10	47	269
"public Collection<String> getCandidateEIPs(String myInstanceId, String myZone) { if (myZone == null) { myZone = ""us-east-1d""; } Collection<String> eipCandidates = (DiscoveryManager.getInstance() .getEurekaClientConfig().shouldUseDnsForFetchingServiceUrls() ? getEIPsForZoneFromDNS(myZone) : getEIPsForZoneFromConfig(myZone)); if (eipCandidates == null || eipCandidates.size() == 0) { throw new RuntimeException( ""Could not get any elastic ips from the EIP pool for zone :"" + myZone); } return eipCandidates; }"	"    public Collection<String> getCandidateEIPs(String myInstanceId, String myZone, String myPublicIP) {

        if (myZone == null) {
            myZone = ""us-east-1d"";
            myPublicIP = ""us-east-1d"";
        }
        Collection<String> eipCandidates = (DiscoveryManager.getInstance()
                .getEurekaClientConfig().shouldUseDnsForFetchingServiceUrls() ? getEIPsForZoneFromDNS(myZone)
                        : getEIPsForZoneFromConfig(myZone));

        if (eipCandidates == null || eipCandidates.size() == 0) {
            throw new RuntimeException(
                    ""Could not get any elastic ips from the EIP pool for zone :""
                    + myZone);
        }
       
        return eipCandidates;
    }
"	@param myZone the zone where this instance is in	@param myZone the zone where this instance is in	0	1	8	18	95
public Actions release(WebElement target) { if (isBuildingActions()) { action.addAction(new ButtonReleaseAction(jsonMouse, (Locatable) target)); return this; } return moveToElement(target).release(); }	"  public Actions release(WebElement onElement) {
    action.addAction(new ButtonReleaseAction(mouse, (Locatable) onElement));
    return this;
  }
"	@param target Element to release the mouse button above.	@param onElement Element to release the mouse button above.	1	0	9	8	44
public ApiResponse<Order> getOrderByIdWithHttpInfo(String orderId) throws ApiException { Call call = getOrderByIdCall(orderId, null, null); Type localVarReturnType = new TypeToken<Order>(){}.getType(); return apiClient.execute(call, localVarReturnType); }	"  public ApiResponse<Order> getOrderByIdWithHttpInfo(Long orderId) throws ApiException {
    Call call = getOrderByIdCall(orderId, null, null);
    Type localVarReturnType = new TypeToken<Order>(){}.getType();
    return apiClient.execute(call, localVarReturnType);
  }
"	@param orderId ID of pet that needs to be fetched (required)	@param orderId ID of pet that needs to be fetched (required)	0	1	8	6	45
public boolean searchText(String text, int minimumNumberOfMatches, boolean scroll) { return searcher.searchWithTimeoutFor(TextView.class, text, minimumNumberOfMatches, scroll); }	"	public boolean searchText(String regex, int expectedMinimumNumberOfMatches, boolean scroll) {
		return searcher.searchWithTimeoutFor(TextView.class, regex, expectedMinimumNumberOfMatches, scroll);
	}
"	@param text the text to search for. The parameter will be interpreted as a regular expression.	@param regex the text to search for. The parameter will be interpreted as a regular expression.	1	0	6	4	29
protected TextMessage objectToText(Session session, ObjectMessage objectMessage) throws JMSException { TextMessage answer = session.createTextMessage(marshall(session, objectMessage)); copyProperties(objectMessage, answer); return answer; }	"    protected Message objectToText(Session session, Message message) throws JMSException {
        if (message instanceof ObjectMessage) {
            TextMessage answer = session.createTextMessage(marshall(session, (ObjectMessage) message));
            copyProperties(message, answer);
            return answer;
        }
        return message;
	}
"	@param objectMessage - object message to transform to text message	@param message - if this is an ObjectMessage, it will be transformed to a TextMessage	1	0	7	7	37
public static byte[] readByteCode(ZipInputStream zip) throws IOException { ByteArrayOutputStream bout = new ByteArrayOutputStream(); InputStream in = new BufferedInputStream( zip ); int b; while ( ( b = in.read() ) != -1 ) { bout.write( b ); } return bout.toByteArray(); }	"	public static byte[] readByteCode(InputStream inputStream) throws IOException {
		if ( inputStream == null ) {
			throw new IOException( ""null input stream"" );
		}

		byte[] buffer = new byte[409600];
		byte[] classBytes = new byte[0];
		int r = 0;

		try {
			r = inputStream.read( buffer );
			while ( r >= buffer.length ) {
				byte[] temp = new byte[ classBytes.length + buffer.length ];
				System.arraycopy( classBytes, 0, temp, 0, classBytes.length );
				System.arraycopy( buffer, 0, temp, classBytes.length, buffer.length );
				classBytes = temp;
			}
			if ( r != -1 ) {
				byte[] temp = new byte[ classBytes.length + r ];
				System.arraycopy( classBytes, 0, temp, 0, classBytes.length );
				System.arraycopy( buffer, 0, temp, classBytes.length, r );
				classBytes = temp;
			}
		}
		finally {
			try {
				inputStream.close();
			}
			catch (IOException ignore) {
				// intentionally empty
			}
		}

		return classBytes;
	}
"	@param zip The zip entry stream.	@param inputStream	1	0	7	10	59
"public String invokeAPI(String path, String method, Set<QueryParam> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); b.append(""?""); if (queryParams != null){ for (QueryParam queryParam : queryParams){ if (!queryParam.getName().isEmpty()) { b.append(escapeString(queryParam.getName())); b.append(""=""); b.append(escapeString(queryParam.getValue())); b.append(""&""); } } } String querystring = b.substring(0, b.length() - 1); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(""GET"".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (""POST"".equals(method)) { if (contentType.startsWith(""application/x-www-form-urlencoded"")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (""PUT"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (""DELETE"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, ""unknown method type "" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return """"; } } else { String message = ""error""; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { // e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }"	"  public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {
    updateParamsForAuth(authNames, queryParams, headerParams);

    Client client = getClient();

    StringBuilder b = new StringBuilder();
    for(String key : queryParams.keySet()) {
      String value = queryParams.get(key);
      if (value != null){
        if(b.toString().length() == 0)
          b.append(""?"");
        else
          b.append(""&"");
        b.append(escapeString(key)).append(""="").append(escapeString(value));
      }
    }
    String querystring = b.toString();

    Builder builder;
    if (accept == null)
      builder = client.resource(basePath + path + querystring).getRequestBuilder();
    else
      builder = client.resource(basePath + path + querystring).accept(accept);

    for(String key : headerParams.keySet()) {
      builder = builder.header(key, headerParams.get(key));
    }
    for(String key : defaultHeaderMap.keySet()) {
      if(!headerParams.containsKey(key)) {
        builder = builder.header(key, defaultHeaderMap.get(key));
      }
    }

    ClientResponse response = null;

    if(""GET"".equals(method)) {
      response = (ClientResponse) builder.get(ClientResponse.class);
    }
    else if (""POST"".equals(method)) {
      if (contentType.startsWith(""application/x-www-form-urlencoded"")) {
        String encodedFormParams = this
            .getXWWWFormUrlencodedParams(formParams);
        response = builder.type(contentType).post(ClientResponse.class,
            encodedFormParams);
      } else if (body == null) {
        response = builder.post(ClientResponse.class, null);
      } else if(body instanceof FormDataMultiPart) {
        response = builder.type(contentType).post(ClientResponse.class, body);
      }
      else
        response = builder.type(contentType).post(ClientResponse.class, serialize(body));
    }
    else if (""PUT"".equals(method)) {
      if (""application/x-www-form-urlencoded"".equals(contentType)) {
          String encodedFormParams = this
              .getXWWWFormUrlencodedParams(formParams);
          response = builder.type(contentType).put(ClientResponse.class,
              encodedFormParams);
      } else if(body == null) {
        response = builder.put(ClientResponse.class, serialize(body));
      } else {
          response = builder.type(contentType).put(ClientResponse.class, serialize(body));
      }
    }
    else if (""DELETE"".equals(method)) {
      if (""application/x-www-form-urlencoded"".equals(contentType)) {
        String encodedFormParams = this
            .getXWWWFormUrlencodedParams(formParams);
        response = builder.type(contentType).delete(ClientResponse.class,
            encodedFormParams);
      } else if(body == null) {
        response = builder.delete(ClientResponse.class);
      } else {
        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));
      }
    }
    else {
      throw new ApiException(500, ""unknown method type "" + method);
    }

    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {
      return null;
    }
    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {
      if(response.hasEntity()) {
        return (String) response.getEntity(String.class);
      }
      else {
        return """";
      }
    }
    else {
      String message = ""error"";
      String respBody = null;
      if(response.hasEntity()) {
        try{
          respBody = String.valueOf(response.getEntity(String.class));
          message = respBody;
        }
        catch (RuntimeException e) {
          // e.printStackTrace();
        }
      }
      throw new ApiException(
                response.getClientResponseStatus().getStatusCode(),
                message,
                response.getHeaders(),
                respBody);
    }
  }
"	@param body The request body object	@param body The request body object	0	1	16	113	736
public int compareTo(ByteArrayWritable that) { return WritableComparator.compareBytes(this.data, this.offset, this.length, that.data, that.offset, that.length); }	"    public int compareTo(final byte[] that) {
        return WritableComparator.compareBytes(this.data, this.offset, this.length, that, 0, that.length);
    }
"	@param that The other bytes writable	@param that	1	0	6	5	32
"public BroadcastAction filter(String broadcasterId, Object originalMessage, Object o) { if (o instanceof String) { String message = (String) o; StringBuffer buffer = new StringBuffer(message.length()); for (int i = 0; i < message.length(); i++) { char c = message.charAt(i); switch (c) { case '\b': buffer.append(""\\b""); break; case '\f': buffer.append(""\\f""); break; case '\n': buffer.append(""<br />""); break; case '\r': // ignore break; case '\t': buffer.append(""\\t""); break; case '\'': buffer.append(""\\'""); break; case '\""': buffer.append(""\\\""""); break; case '\\': buffer.append(""\\\\""); break; case '<': buffer.append(""&lt;""); break; case '>': buffer.append(""&gt;""); break; case '&': buffer.append(""&amp;""); break; default: buffer.append(c); } } return new BroadcastAction(buffer.toString()); } else { return new BroadcastAction(o); } }"	"    public BroadcastAction filter(Object originalMessage, Object o) {
        if (o instanceof String) {
            String message = (String) o;

            StringBuffer buffer = new StringBuffer(message.length());

            for (int i = 0; i < message.length(); i++) {
                char c = message.charAt(i);
                switch (c) {
                    case '\b':
                        buffer.append(""\\b"");
                        break;
                    case '\f':
                        buffer.append(""\\f"");
                        break;
                    case '\n':
                        buffer.append(""<br />"");
                        break;
                    case '\r':
                        // ignore
                        break;
                    case '\t':
                        buffer.append(""\\t"");
                        break;
                    case '\'':
                        buffer.append(""\\'"");
                        break;
                    case '\""':
                        buffer.append(""\\\"""");
                        break;
                    case '\\':
                        buffer.append(""\\\\"");
                        break;
                    case '<':
                        buffer.append(""&lt;"");
                        break;
                    case '>':
                        buffer.append(""&gt;"");
                        break;
                    case '&':
                        buffer.append(""&amp;"");
                        break;
                    default:
                        buffer.append(c);
                }
            }
            return new BroadcastAction(buffer.toString());
        } else {
            return new BroadcastAction(o);
        }
    }
"	@param o The object to introspect.	@param o The object to introspect.	0	1	11	52	288
public int[] addInField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { int current = values[fieldIndex]; int wrapped = FieldUtils.getWrappedValue (current, valueToAdd, getMinimumValue(instant), getMaximumValue(instant)); return set(instant, fieldIndex, values, wrapped); // adjusts smaller fields }	"    public int[] addInField(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd) {
        int current = values[fieldIndex];
        int wrapped = FieldUtils.getWrappedValue
            (current, valueToAdd, getMinimumValue(instant), getMaximumValue(instant));
        return set(instant, fieldIndex, values, wrapped);  // adjusts smaller fields
    }
"	@param fieldIndex the index of this field in the instant	@param fieldIndex the index of this field in the instant	0	1	7	7	66
"public Mono<Client> testClassname(Client body) throws RestClientException { Object postBody = body; // verify the required parameter 'body' is set if (body == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'body' when calling testClassname""); } String path = UriComponentsBuilder.fromPath(""/fake_classname_test"").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { ""application/json"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { ""application/json"" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { ""api_key_query"" }; ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {}; return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }"	"    public Mono<Client> testClassname(Client client) throws RestClientException {
        Object postBody = client;
        
        // verify the required parameter 'client' is set
        if (client == null) {
            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'client' when calling testClassname"");
        }
        
        String path = UriComponentsBuilder.fromPath(""/fake_classname_test"").build().toUriString();
        
        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();
        final HttpHeaders headerParams = new HttpHeaders();
        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();

        final String[] accepts = { 
            ""application/json""
        };
        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);
        final String[] contentTypes = { 
            ""application/json""
        };
        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);

        String[] authNames = new String[] { ""api_key_query"" };

        ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {};
        return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);
    }
"	@param body client model	@param client client model	1	0	8	29	204
private boolean limitTranslation(Matrix transform, boolean shouldLimitX, boolean shouldLimitY) { if (!shouldLimitX && !shouldLimitY) { return false; } RectF b = mTempRect; b.set(mImageBounds); transform.mapRect(b); float offsetLeft = !shouldLimitX ? 0 : getOffset(b.left, b.right, mViewBounds.left, mViewBounds.right, mImageBounds.centerX()); float offsetTop = !shouldLimitY ? 0 : getOffset(b.top, b.bottom, mViewBounds.top, mViewBounds.bottom, mImageBounds.centerY()); if (offsetLeft != 0 || offsetTop != 0) { transform.postTranslate(offsetLeft, offsetTop); return true; } return false; }	"  private boolean limitTranslation(Matrix transform, boolean limitX, boolean limitY) {
    RectF bounds = mTempRect;
    bounds.set(mImageBounds);
    transform.mapRect(bounds);
    float offsetLeft = limitX ?
        getOffset(bounds.left, bounds.right, mViewBounds.left, mViewBounds.right) : 0;
    float offsetTop = limitY ?
        getOffset(bounds.top, bounds.bottom, mViewBounds.top, mViewBounds.bottom) : 0;
    if (offsetLeft != 0 || offsetTop != 0) {
      transform.postTranslate(offsetLeft, offsetTop);
      return true;
    }
    return false;
  }
"	@param shouldLimitY whether to apply the limit on the y-axis	@param limitY whether to apply the limit on the y-axis	1	0	7	18	126
public String getAuthorizationUrl(OAuth1RequestToken requestToken) { return api.getAuthorizationUrl(requestToken); }	"    public String getAuthorizationUrl(Token requestToken) {
        return api.getAuthorizationUrl(requestToken);
    }
"	@param requestToken the request token you need to authorize	@param requestToken the request token you need to authorize	0	1	5	4	16
"public void createUsersWithArrayInput (List<User> user) throws ApiException { Object localVarPostBody = user; // verify the required parameter 'user' is set if (user == null) { throw new ApiException(400, ""Missing the required parameter 'user' when calling createUsersWithArrayInput""); } // create path and map variables String localVarPath = ""/user/createWithArray"".replaceAll(""\\{format\\}"",""json""); // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); // header params Map<String, String> localVarHeaderParams = new HashMap<String, String>(); // form params Map<String, String> localVarFormParams = new HashMap<String, String>(); String[] localVarContentTypes = { }; String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : ""application/json""; if (localVarContentType.startsWith(""multipart/form-data"")) { // file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); localVarPostBody = localVarBuilder.build(); } else { // normal form params } try { String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, ""POST"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType); if(localVarResponse != null){ return ; } else { return ; } } catch (ApiException ex) { throw ex; } }"	"  public void  createUsersWithArrayInput (List<User> body) throws ApiException {
    Object localVarPostBody = body;
    // verify the required parameter 'body' is set
    if (body == null) {
       throw new ApiException(400, ""Missing the required parameter 'body' when calling createUsersWithArrayInput"");
    }

    // create path and map variables
    String localVarPath = ""/user/createWithArray"".replaceAll(""\\{format\\}"",""json"");

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    // form params
    Map<String, String> localVarFormParams = new HashMap<String, String>();



    String[] localVarContentTypes = {
      
    };
    String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : ""application/json"";

    if (localVarContentType.startsWith(""multipart/form-data"")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      localVarPostBody = localVarBuilder.build();
    } else {
      // normal form params
          }

    try {
      String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, ""POST"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType);
      if(localVarResponse != null){
        return ;
      }
      else {
        return ;
      }
    } catch (ApiException ex) {
      throw ex;
    }
  }
"	@param user List of user object	@param body List of user object	1	0	8	47	250
public byte getStatus(final int id, final String path) { byte status; BaseDownloadTask.IRunningTask task = FileDownloadList.getImpl().get(id); if (task == null) { status = FileDownloadServiceProxy.getImpl().getStatus(id); } else { status = task.getOrigin().getStatus(); } if (path != null && status == FileDownloadStatus.INVALID_STATUS) { if (FileDownloadUtils.isFilenameConverted(FileDownloadHelper.getAppContext()) && new File(path).exists()) { status = FileDownloadStatus.completed; } } return status; }	"    public byte getStatus(final int downloadId, final String path) {
        byte status;
        BaseDownloadTask.IRunningTask task = FileDownloadList.getImpl().get(downloadId);
        if (task == null) {
            status = FileDownloadServiceProxy.getImpl().getStatus(downloadId);
        } else {
            status = task.getOrigin().getStatus();
        }

        if (path != null && status == FileDownloadStatus.INVALID_STATUS) {
            if (FileDownloadUtils.isFilenameConverted(FileDownloadHelper.getAppContext()) &&
                    new File(path).exists()) {
                status = FileDownloadStatus.completed;
            }
        }

        return status;
    }
"	@param path The target file path.	@param path Use to judge whether has already completed downloading.	1	0	9	19	101
private boolean scrollScrollView(int direction, ArrayList<ScrollView> scrollViews){ int[] xy = new int[2]; ScrollView scroll = viewFetcher.getView(ScrollView.class, scrollViews, 0); scroll.getLocationOnScreen(xy); int height = scroll.getHeight(); int to = 0; if (direction == DOWN) { to = (height); } else if (direction == UP) { to = (-height); } scrollAmount = scroll.getScrollY(); scrollScrollViewTo(scroll,0, to); if (scrollAmount == scroll.getScrollY()) { return false; } else{ return true; } }	"	private boolean scrollScrollView(Direction direction, ArrayList<ScrollView> scrollViews){
		int yStart = 0;
		int yEnd = 0;
		int[] xy = new int[2];
		int x = activityUtils.getCurrentActivity(false).getWindowManager()
		.getDefaultDisplay().getWidth() / 2;
		ScrollView scroll = viewFetcher.getView(ScrollView.class, scrollViews, 0);
		scroll.getLocationOnScreen(xy);

		if (direction == Direction.DOWN) {
			yStart = ((xy[1] + scroll.getHeight()) - 20);
			yEnd = (xy[1] + 30);
		}
		else if (direction == Direction.UP){
			yStart = (xy[1] + 20);
			yEnd = ((xy[1] + scroll.getHeight()) - 30);
		}

		scrollAmount = scroll.getScrollY();
		drag(x, x,getDragablePosition(yStart, direction), yEnd, 40);
		if (scrollAmount == scroll.getScrollY()) {
			return false;
		}
		else
			return true;
	}
"	@param direction the direction to be scrolled	@param direction the direction to be scrolled	0	1	8	24	113
protected boolean isNull(Object owner, SharedSessionContractImplementor session) { return false; }	"	protected boolean isNull(Object owner, SessionImplementor session) {
		return false;
	}
"	@param id The entity id to resolve	@param id The entity id to resolve	0	1	4	4	15
"public static String getConsoleIconPath(DesiredCapabilities cap, GridRegistry registry) { String name = consoleIconName(cap, registry); String path = ""org/openqa/grid/images/""; InputStream in = Thread.currentThread().getContextClassLoader() .getResourceAsStream(path + name + "".png""); if (in == null) { return null; } return ""/grid/resources/"" + path + name + "".png""; }"	"  public static String getConsoleIconPath(DesiredCapabilities cap, Registry registry) {
    String name = consoleIconName(cap, registry);
    String path = ""org/openqa/grid/images/"";
    InputStream in =
        Thread.currentThread().getContextClassLoader()
            .getResourceAsStream(path + name + "".png"");
    if (in == null) {
      return null;
    }
    return ""/grid/resources/"" + path + name + "".png"";
  }
"	@param cap - Capability	@param cap - Capability	0	1	9	12	82
"public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) { if (fieldType == null) { throw new IllegalArgumentException(""Field type must not be null""); } DateTimeField field = fieldType.getField(iChronoUTC); return append0(new TextField(iChrono, field, iLocale, true)); }"	"    public DateTimeFormatterBuilder appendShortText(final DateTimeField field) {
        return append0(new TextField(iChrono, field, iLocale, true));
    }
"	@param fieldType type of field to append	@param field field should operate in UTC or be time zone agnostic	1	0	7	8	54
public TransportLogger createTransportLogger(Transport next, Logger log) throws IOException { return createTransportLogger(next, getNextId(), log, defaultLogWriterName, defaultDynamicManagement, defaultInitialBehavior, defaultJmxPort); }	"    public TransportLogger createTransportLogger(Transport next, Log log) throws IOException {
        return createTransportLogger(next, getNextId(), log, defaultLogWriterName, defaultDynamicManagement, defaultInitialBehavior, defaultJmxPort);
    }
"	@param next The next Transport layer in the Transport stack.	@param next The next Transport layer in the Transport stack.	0	1	5	4	34
"Action action(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException { boolean webSocketEnabled = false; if (req.getHeaders(""Connection"") != null && req.getHeaders(""Connection"").hasMoreElements()) { String[] e = req.getHeaders(""Connection"").nextElement().toString().split("",""); for (String upgrade : e) { if (upgrade.equalsIgnoreCase(""Upgrade"")) { webSocketEnabled = true; break; } } } if (webSocketEnabled && !supportWebSocket()) { res.setStatus(501); res.addHeader(X_ATMOSPHERE_ERROR, ""Websocket protocol not supported""); res.flushBuffer(); return new Action(); } if (config.handlers().isEmpty()) { logger.error(""No AtmosphereHandler found. Make sure you define it inside META-INF/atmosphere.xml""); throw new AtmosphereMappingException(""No AtmosphereHandler found. Make sure you define it inside META-INF/atmosphere.xml""); } if (supportSession()) { // Create the session needed to support the Resume // operation from disparate requests. HttpSession session = req.getSession(true); // Do not allow times out. if (session.getMaxInactiveInterval() == DEFAULT_SESSION_TIMEOUT) { session.setMaxInactiveInterval(-1); } } req.setAttribute(FrameworkConfig.SUPPORT_SESSION, supportSession()); AtmosphereHandlerWrapper handlerWrapper = map(req); // Check Broadcaster state. If destroyed, replace it. Broadcaster b = handlerWrapper.broadcaster; if (b.isDestroyed()) { synchronized (handlerWrapper) { config.getBroadcasterFactory().remove(b, b.getID()); handlerWrapper.broadcaster = config.getBroadcasterFactory().get(b.getID()); } } AtmosphereResourceImpl resource = new AtmosphereResourceImpl(config, handlerWrapper.broadcaster, req, res, this, handlerWrapper.atmosphereHandler); req.setAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE, resource); req.setAttribute(FrameworkConfig.ATMOSPHERE_HANDLER, handlerWrapper.atmosphereHandler); try { handlerWrapper.atmosphereHandler.onRequest(resource); } catch (IOException t) { resource.onThrowable(t); throw t; } if (trackActiveRequest && resource.getAtmosphereResourceEvent().isSuspended() && req.getAttribute(FrameworkConfig.CANCEL_SUSPEND_OPERATION) == null) { req.setAttribute(MAX_INACTIVE, System.currentTimeMillis()); aliveRequests.put(req, resource); } return resource.action(); }"	"    Action action(HttpServletRequest req, HttpServletResponse res)
            throws IOException, ServletException {

        boolean webSocketEnabled = false;
        if (req.getHeaders(""Connection"") != null && req.getHeaders(""Connection"").hasMoreElements()) {
            String[] e = req.getHeaders(""Connection"").nextElement().toString().split("","");
            for (String upgrade : e) {
                if (upgrade.equalsIgnoreCase(""Upgrade"")) {
                    webSocketEnabled = true;
                    break;
                }
            }
        }

        if (webSocketEnabled && !supportWebSocket()) {
            res.setStatus(501);
            res.addHeader(X_ATMOSPHERE_ERROR, ""Websocket protocol not supported"");
            res.flushBuffer();
            return new Action();
        }

        if (config.handlers().isEmpty()) {
            logger.error(""No AtmosphereHandler found. Make sure you define it inside META-INF/atmosphere.xml"");
            throw new AtmosphereMappingException(""No AtmosphereHandler found. Make sure you define it inside META-INF/atmosphere.xml"");
        }

        if (supportSession()) {
            // Create the session needed to support the Resume
            // operation from disparate requests.
            HttpSession session = req.getSession(true);
            // Do not allow times out.
            if (session.getMaxInactiveInterval() == DEFAULT_SESSION_TIMEOUT) {
                session.setMaxInactiveInterval(-1);
            }
        }

        req.setAttribute(FrameworkConfig.SUPPORT_SESSION, supportSession());

        AtmosphereHandlerWrapper handlerWrapper = map(req);
        // Check Broadcaster state. If destroyed, replace it.
        Broadcaster b = handlerWrapper.broadcaster;
        if (b.isDestroyed()) {
            synchronized (handlerWrapper) {
                config.getBroadcasterFactory().remove(b, b.getID());
                handlerWrapper.broadcaster = config.getBroadcasterFactory().get(b.getID());
            }
        }
        AtmosphereResourceImpl resource = new AtmosphereResourceImpl(config, handlerWrapper.broadcaster, req, res, this, handlerWrapper.atmosphereHandler);

        req.setAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE, resource);
        req.setAttribute(FrameworkConfig.ATMOSPHERE_HANDLER, handlerWrapper.atmosphereHandler);

        try {
            handlerWrapper.atmosphereHandler.onRequest(resource);
        } catch (IOException t) {
            resource.onThrowable(t);
            throw t;
        }

        if (trackActiveRequest && resource.getAtmosphereResourceEvent().isSuspended() && req.getAttribute(FrameworkConfig.CANCEL_SUSPEND_OPERATION) == null) {
            req.setAttribute(MAX_INACTIVE, System.currentTimeMillis());
            aliveRequests.put(req, resource);
        }
        return resource.action();
    }
"	@param res the  AtmosphereResponse	@param res the HttpServletResponse	1	0	11	66	440
public Index parseAndUpdateIndex(List<JaxbRoot<XMLEntityMappings>> mappings, Index annotationIndex) { for ( JaxbRoot<XMLEntityMappings> root : mappings ) { root.getRoot().toString(); } return annotationIndex; }	"	public Index parseAndUpdateIndex(Set<String> mappingFileNames, Index annotationIndex) {
		ClassLoaderService classLoaderService = meta.getServiceRegistry().getService( ClassLoaderService.class );
		Set<InputStream> mappingStreams = new HashSet<InputStream>();
		for ( String fileName : mappingFileNames ) {

			XMLEntityMappings entityMappings;
			try {
				entityMappings = XmlHelper.unmarshallXml(
						fileName, ORM2_MAPPING_XSD, XMLEntityMappings.class, classLoaderService
				).getRoot();
			}
			catch ( JAXBException orm2Exception ) {
				// if we cannot parse against orm_2_0.xsd we try orm_1_0.xsd for backwards compatibility
				try {
					entityMappings = XmlHelper.unmarshallXml(
							fileName, ORM1_MAPPING_XSD, XMLEntityMappings.class, classLoaderService
					).getRoot();
				}
				catch ( JAXBException orm1Exception ) {
					throw new AnnotationException( ""Unable to parse xml configuration."", orm1Exception );
				}
			}

			entityMappings.toString();
		}

		return null;
	}
"	@param mappings list of  XMLEntityMappings created from the specified orm xml files	@param mappingFileNames the file names of the xml files to parse	1	0	8	7	35
public boolean searchWithTimeoutFor(Class<? extends TextView> viewClass, String regex, int expectedMinimumNumberOfMatches, boolean scroll) { final long endTime = System.currentTimeMillis() + TIMEOUT; while (System.currentTimeMillis() < endTime) { sleeper.sleep(); final boolean foundAnyMatchingView = searchFor(viewClass, regex, expectedMinimumNumberOfMatches, scroll); if (foundAnyMatchingView){ return true; } } return false; }	"	public boolean searchWithTimeoutFor(Class<? extends TextView> viewClass, String regex, int matches, boolean scroll) {
		final long endTime = System.currentTimeMillis() + TIMEOUT;

		while (System.currentTimeMillis() < endTime) {
			sleeper.sleep();
			final boolean foundAnyMatchingView = searchFor(viewClass, regex, matches, scroll);
			if (foundAnyMatchingView){
				return true;
			}
		}

		return false;
	}
"	@param expectedMinimumNumberOfMatches the minimum number of matches expected to be found.  0 matches means that one or more matches are expected to be found	@param matches the number of matches expected to be found. 0 matches means that one or more matches are expected to be found	1	0	8	14	72
private RexNode adjustCondition(LogicalProject project, SemiJoin semiJoin) { // create two RexPrograms -- the bottom one representing a // concatenation of the project and the RHS of the semijoin and the // top one representing the semijoin condition RexBuilder rexBuilder = project.getCluster().getRexBuilder(); RelDataTypeFactory typeFactory = rexBuilder.getTypeFactory(); RelNode rightChild = semiJoin.getRight(); // for the bottom RexProgram, the input is a concatenation of the // child of the project and the RHS of the semijoin RelDataType bottomInputRowType = Join.deriveJoinRowType( project.getInput().getRowType(), rightChild.getRowType(), JoinRelType.INNER, typeFactory, null, semiJoin.getSystemFieldList()); RexProgramBuilder bottomProgramBuilder = new RexProgramBuilder(bottomInputRowType, rexBuilder); // add the project expressions, then add input references for the RHS // of the semijoin for (Pair<RexNode, String> pair : project.getNamedProjects()) { bottomProgramBuilder.addProject(pair.left, pair.right); } int nLeftFields = project.getInput().getRowType().getFieldCount(); List<RelDataTypeField> rightFields = rightChild.getRowType().getFieldList(); int nRightFields = rightFields.size(); for (int i = 0; i < nRightFields; i++) { final RelDataTypeField field = rightFields.get(i); RexNode inputRef = rexBuilder.makeInputRef( field.getType(), i + nLeftFields); bottomProgramBuilder.addProject(inputRef, field.getName()); } RexProgram bottomProgram = bottomProgramBuilder.getProgram(); // input rowtype into the top program is the concatenation of the // project and the RHS of the semijoin RelDataType topInputRowType = Join.deriveJoinRowType( project.getRowType(), rightChild.getRowType(), JoinRelType.INNER, typeFactory, null, semiJoin.getSystemFieldList()); RexProgramBuilder topProgramBuilder = new RexProgramBuilder( topInputRowType, rexBuilder); topProgramBuilder.addIdentity(); topProgramBuilder.addCondition(semiJoin.getCondition()); RexProgram topProgram = topProgramBuilder.getProgram(); // merge the programs and expand out the local references to form // the new semijoin condition; it now references a concatenation of // the project's child and the RHS of the semijoin RexProgram mergedProgram = RexProgramBuilder.mergePrograms( topProgram, bottomProgram, rexBuilder); return mergedProgram.expandLocalRef( mergedProgram.getCondition()); }	"  private RexNode adjustCondition(ProjectRel project, SemiJoinRel semiJoin) {
    // create two RexPrograms -- the bottom one representing a
    // concatenation of the project and the RHS of the semijoin and the
    // top one representing the semijoin condition

    RexBuilder rexBuilder = project.getCluster().getRexBuilder();
    RelDataTypeFactory typeFactory = rexBuilder.getTypeFactory();
    RelNode rightChild = semiJoin.getRight();

    // for the bottom RexProgram, the input is a concatenation of the
    // child of the project and the RHS of the semijoin
    RelDataType bottomInputRowType =
        JoinRelBase.deriveJoinRowType(
            project.getChild().getRowType(),
            rightChild.getRowType(),
            JoinRelType.INNER,
            typeFactory,
            null,
            semiJoin.getSystemFieldList());
    RexProgramBuilder bottomProgramBuilder =
        new RexProgramBuilder(bottomInputRowType, rexBuilder);

    // add the project expressions, then add input references for the RHS
    // of the semijoin
    for (Pair<RexNode, String> pair : project.getNamedProjects()) {
      bottomProgramBuilder.addProject(pair.left, pair.right);
    }
    int nLeftFields = project.getChild().getRowType().getFieldCount();
    List<RelDataTypeField> rightFields =
        rightChild.getRowType().getFieldList();
    int nRightFields = rightFields.size();
    for (int i = 0; i < nRightFields; i++) {
      final RelDataTypeField field = rightFields.get(i);
      RexNode inputRef =
          rexBuilder.makeInputRef(
              field.getType(), i + nLeftFields);
      bottomProgramBuilder.addProject(inputRef, field.getName());
    }
    RexProgram bottomProgram = bottomProgramBuilder.getProgram();

    // input rowtype into the top program is the concatenation of the
    // project and the RHS of the semijoin
    RelDataType topInputRowType =
        JoinRelBase.deriveJoinRowType(
            project.getRowType(),
            rightChild.getRowType(),
            JoinRelType.INNER,
            typeFactory,
            null,
            semiJoin.getSystemFieldList());
    RexProgramBuilder topProgramBuilder =
        new RexProgramBuilder(
            topInputRowType,
            rexBuilder);
    topProgramBuilder.addIdentity();
    topProgramBuilder.addCondition(semiJoin.getCondition());
    RexProgram topProgram = topProgramBuilder.getProgram();

    // merge the programs and expand out the local references to form
    // the new semijoin condition; it now references a concatenation of
    // the project's child and the RHS of the semijoin
    RexProgram mergedProgram =
        RexProgramBuilder.mergePrograms(
            topProgram,
            bottomProgram,
            rexBuilder);

    return mergedProgram.expandLocalRef(
        mergedProgram.getCondition());
  }
"	@param project LogicalProject on the LHS of the semijoin	@param project ProjectRel on the LHS of the semijoin	1	0	9	71	411
"public Index parseAndUpdateIndex(Set<String> mappingFileNames, Index annotationIndex) { ClassLoaderService classLoaderService = meta.getServiceRegistry().getService( ClassLoaderService.class ); Set<InputStream> mappingStreams = new HashSet<InputStream>(); for ( String fileName : mappingFileNames ) { EntityMappings entityMappings; try { entityMappings = XmlHelper.unmarshallXml( fileName, ORM2_MAPPING_XSD, EntityMappings.class, classLoaderService ).getRoot(); } catch ( JAXBException orm2Exception ) { // if we cannot parse against orm_2_0.xsd we try orm_1_0.xsd for backwards compatibility try { entityMappings = XmlHelper.unmarshallXml( fileName, ORM1_MAPPING_XSD, EntityMappings.class, classLoaderService ).getRoot(); } catch ( JAXBException orm1Exception ) { throw new AnnotationException( ""Unable to parse xml configuration."", orm1Exception ); } } entityMappings.toString(); } return null; }"	"	public Index parseAndUpdateIndex(List<JaxbRoot<XMLEntityMappings>> mappings, Index annotationIndex) {
		for ( JaxbRoot<XMLEntityMappings> root : mappings ) {
			root.getRoot().toString();
		}
		return annotationIndex;
	}
"	@param mappingFileNames the file names of the xml files to parse	@param mappings list of XMLEntityMappings created from the specified orm xml files	1	0	12	29	139
"private void preparHtmlForGlobalDescription(OpenAPI openAPI) { if (openAPI.getInfo() == null) { return; } String currentDescription = openAPI.getInfo().getDescription(); if (currentDescription != null && !currentDescription.isEmpty()) { Markdown markInstance = new Markdown(); openAPI.getInfo().setDescription( markInstance.toHtml(currentDescription) ); } else { LOGGER.error(""OpenAPI object description is empty ["" + openAPI.getInfo().getTitle() + ""]""); } }"	"    private void preparHtmlForGlobalDescription(Swagger swagger) {
        String currentDescription = swagger.getInfo().getDescription();
        if (currentDescription != null && !currentDescription.isEmpty()) {
            Markdown markInstance = new Markdown();
            swagger.getInfo().setDescription( markInstance.toHtml(currentDescription) );
        } else {
            LOGGER.error(""Swagger object description is empty ["" + swagger.getInfo().getTitle() + ""]"");
        }
    }
"	"@param swagger The base object containing the global description through ""Info"" class"	"@param swagger The base object containing the global description through ""Info"" class"	0	1	10	14	94
"private boolean searchForButton(String regex, int matches) { sleeper.sleep(); inst.waitForIdleSync(); Pattern p = Pattern.compile(regex); Matcher matcher; ArrayList<Button> buttonList = viewFetcher.getCurrentViews(Button.class); if(matches == 0) matches = 1; for(Button button : buttonList){ matcher = p.matcher(button.getText().toString()); if(matcher.find()){ countMatches++; } if (countMatches == matches) { countMatches = 0; return true; } } if (scroller.scroll(Scroller.Direction.DOWN)) { return searchForButton(regex, matches); } else { if (countMatches > 0) Log.d(LOG_TAG, "" There are only "" + countMatches + "" matches of "" + regex); countMatches = 0; return false; } }"	"	private boolean searchForButton(String search, int matches) {
		sleeper.sleep();
		inst.waitForIdleSync();
		Pattern p = Pattern.compile(search);
		Matcher matcher;
		ArrayList<Button> buttonList = viewFetcher.getCurrentViews(Button.class);
		if(matches == 0)
			matches = 1;
		for(Button button : buttonList){
			matcher = p.matcher(button.getText().toString());
			if(matcher.find()){	
				countMatches++;
			}
			if (countMatches == matches) {
				countMatches = 0;
				return true;
			} 	
		}

		if (scroller.scroll(Scroller.Direction.DOWN))
		{
			return searchForButton(search, matches);
		} else {
			if (countMatches > 0)
				Log.d(LOG_TAG, "" There are only "" + countMatches + "" matches of "" + search);
			countMatches = 0;
			return false;
		}

	}
"	@param regex the text to search for. The parameter will be interpreted as a regular expression.	@param search the string to be searched. The parameter will be interpreted as a regular expression.	1	0	11	31	154
"public void updateUser (String username, User user) throws TimeoutException, ExecutionException, InterruptedException, ApiException { Object postBody = user; // verify the required parameter 'username' is set if (username == null) { VolleyError error = new VolleyError(""Missing the required parameter 'username' when calling updateUser"", new ApiException(400, ""Missing the required parameter 'username' when calling updateUser"")); } // verify the required parameter 'user' is set if (user == null) { VolleyError error = new VolleyError(""Missing the required parameter 'user' when calling updateUser"", new ApiException(400, ""Missing the required parameter 'user' when calling updateUser"")); } // create path and map variables String path = ""/user/{username}"".replaceAll(""\\{"" + ""username"" + ""\\}"", apiInvoker.escapeString(username.toString())); // query params List<Pair> queryParams = new ArrayList<Pair>(); // header params Map<String, String> headerParams = new HashMap<String, String>(); // form params Map<String, String> formParams = new HashMap<String, String>(); String[] contentTypes = { ""application/json"" }; String contentType = contentTypes.length > 0 ? contentTypes[0] : ""application/json""; if (contentType.startsWith(""multipart/form-data"")) { // file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); HttpEntity httpEntity = localVarBuilder.build(); postBody = httpEntity; } else { // normal form params } String[] authNames = new String[] { }; try { String localVarResponse = apiInvoker.invokeAPI (basePath, path, ""PUT"", queryParams, postBody, headerParams, formParams, contentType, authNames); if (localVarResponse != null) { return ; } else { return ; } } catch (ApiException ex) { throw ex; } catch (InterruptedException ex) { throw ex; } catch (ExecutionException ex) { if (ex.getCause() instanceof VolleyError) { VolleyError volleyError = (VolleyError)ex.getCause(); if (volleyError.networkResponse != null) { throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage()); } } throw ex; } catch (TimeoutException ex) { throw ex; } }"	"  public void updateUser (String username, User body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = body;
    // verify the required parameter 'username' is set
    if (username == null) {
      VolleyError error = new VolleyError(""Missing the required parameter 'username' when calling updateUser"",
        new ApiException(400, ""Missing the required parameter 'username' when calling updateUser""));
    }
    // verify the required parameter 'body' is set
    if (body == null) {
      VolleyError error = new VolleyError(""Missing the required parameter 'body' when calling updateUser"",
        new ApiException(400, ""Missing the required parameter 'body' when calling updateUser""));
    }

    // create path and map variables
    String path = ""/user/{username}"".replaceAll(""\\{"" + ""username"" + ""\\}"", apiInvoker.escapeString(username.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : ""application/json"";

    if (contentType.startsWith(""multipart/form-data"")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, ""PUT"", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return ;
      } else {
         return ;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }
"	@param username name that need to be deleted	@param username name that need to be deleted	0	1	11	62	441
"protected QualifiedName determineGeneratorTableName(Properties params, JdbcEnvironment jdbcEnvironment) { final String tableName = ConfigurationHelper.getString( TABLE_PARAM, params, DEF_TABLE ); if ( tableName.contains( ""."" ) ) { return QualifiedNameParser.INSTANCE.parse( tableName ); } else { // todo : need to incorporate implicit catalog and schema names final Identifier catalog = jdbcEnvironment.getIdentifierHelper().toIdentifier( ConfigurationHelper.getString( CATALOG, params ) ); final Identifier schema = jdbcEnvironment.getIdentifierHelper().toIdentifier( ConfigurationHelper.getString( SCHEMA, params ) ); return new QualifiedNameParser.NameParts( catalog, schema, jdbcEnvironment.getIdentifierHelper().toIdentifier( tableName ) ); } }"	"	protected QualifiedName determineGeneratorTableName(Properties params, Dialect dialect) {
		final ObjectNameNormalizer normalizer = (ObjectNameNormalizer) params.get( IDENTIFIER_NORMALIZER );

		return QualifiedNameParser.INSTANCE.parse(
				ConfigurationHelper.getString( TABLE_PARAM, params, DEF_TABLE ),
				normalizer.normalizeIdentifierQuoting( params.getProperty( CATALOG ) ),
				normalizer.normalizeIdentifierQuoting( params.getProperty( SCHEMA ) )
		);
	}
"	@param params The params supplied in the generator config (plus some standard useful extras).	@param params The params supplied in the generator config (plus some standard useful extras).	0	1	10	22	114
"public void createUsersWithArrayInput (List<User> user) throws TimeoutException, ExecutionException, InterruptedException, ApiException { Object postBody = user; // verify the required parameter 'user' is set if (user == null) { VolleyError error = new VolleyError(""Missing the required parameter 'user' when calling createUsersWithArrayInput"", new ApiException(400, ""Missing the required parameter 'user' when calling createUsersWithArrayInput"")); } // create path and map variables String path = ""/user/createWithArray""; // query params List<Pair> queryParams = new ArrayList<Pair>(); // header params Map<String, String> headerParams = new HashMap<String, String>(); // form params Map<String, String> formParams = new HashMap<String, String>(); String[] contentTypes = { }; String contentType = contentTypes.length > 0 ? contentTypes[0] : ""application/json""; if (contentType.startsWith(""multipart/form-data"")) { // file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); HttpEntity httpEntity = localVarBuilder.build(); postBody = httpEntity; } else { // normal form params } String[] authNames = new String[] { }; try { String localVarResponse = apiInvoker.invokeAPI (basePath, path, ""POST"", queryParams, postBody, headerParams, formParams, contentType, authNames); if (localVarResponse != null) { return ; } else { return ; } } catch (ApiException ex) { throw ex; } catch (InterruptedException ex) { throw ex; } catch (ExecutionException ex) { if (ex.getCause() instanceof VolleyError) { VolleyError volleyError = (VolleyError)ex.getCause(); if (volleyError.networkResponse != null) { throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage()); } } throw ex; } catch (TimeoutException ex) { throw ex; } }"	"  public void createUsersWithArrayInput (List<User> body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = body;
    // verify the required parameter 'body' is set
    if (body == null) {
      VolleyError error = new VolleyError(""Missing the required parameter 'body' when calling createUsersWithArrayInput"",
        new ApiException(400, ""Missing the required parameter 'body' when calling createUsersWithArrayInput""));
    }

    // create path and map variables
    String path = ""/user/createWithArray"";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : ""application/json"";

    if (contentType.startsWith(""multipart/form-data"")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, ""POST"", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return ;
      } else {
         return ;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }
"	@param user List of user object	@param body List of user object	1	0	11	56	349
"private int scanURL(String url, User user, int maxChildren) throws ApiException { log.debug(""API Spider scanning url: "" + url); URI startURI; try { // Try to build uri startURI = new URI(url, true); } catch (URIException e) { throw new ApiException(ApiException.Type.BAD_FORMAT); } SiteNode startNode = Model.getSingleton().getSession().getSiteTree().findNode(startURI); String scheme = startURI.getScheme(); if (scheme == null || (!scheme.equalsIgnoreCase(""http"") && !scheme.equalsIgnoreCase(""https""))) { throw new ApiException(ApiException.Type.BAD_FORMAT); } Target target = new Target(startNode); target.setRecurse(true); Object[] objs = null; if (maxChildren > 0) { // Add the filters to filter on maximum number of children MaxChildrenFetchFilter maxChildrenFetchFilter = new MaxChildrenFetchFilter(); maxChildrenFetchFilter.setMaxChildren(maxChildren); maxChildrenFetchFilter.setModel(extension.getModel()); MaxChildrenParseFilter maxChildrenParseFilter = new MaxChildrenParseFilter(); maxChildrenParseFilter.setMaxChildren(maxChildren); maxChildrenParseFilter.setModel(extension.getModel()); objs = new Object[] { maxChildrenFetchFilter, maxChildrenParseFilter }; } return extension.startScan(target.getDisplayName(), target, user, objs); }"	"	private int scanURL(String url, User user) throws ApiException {
		log.debug(""API Spider scanning url: "" + url);

		URI startURI;
		try {
			// Try to build uri
			startURI = new URI(url, true);
		} catch (URIException e) {
			throw new ApiException(ApiException.Type.BAD_FORMAT);
		}

		SiteNode startNode = Model.getSingleton().getSession().getSiteTree().findNode(startURI);
		String scheme = startURI.getScheme();
		if (scheme == null || (!scheme.equalsIgnoreCase(""http"") && !scheme.equalsIgnoreCase(""https""))) {
			throw new ApiException(ApiException.Type.BAD_FORMAT);
		}
		Target target = new Target(startNode);
		target.setRecurse(true);
		return extension.startScan(target.getDisplayName(), target, user, null);
	}
"	@param url the url to start the spider scan	@param url the url to start the spider scan	0	1	9	38	240
"static String formatSQLParsingError(String sql, DrillSqlParseException ex) { final String sqlErrorMessageHeader = ""SQL Query: ""; final SqlParserPos pos = ex.getPos(); if (pos != null) { int issueLineNumber = pos.getLineNum() - 1; // recalculates to base 0 int issueColumnNumber = pos.getColumnNum() - 1; // recalculates to base 0 int messageHeaderLength = sqlErrorMessageHeader.length(); // If the issue happens on the first line, header width should be calculated alongside with the sql query int shiftLength = (issueLineNumber == 0) ? issueColumnNumber + messageHeaderLength : issueColumnNumber; StringBuilder sb = new StringBuilder(); String[] lines = sql.split(DrillParserUtil.EOL); for (int i = 0; i < lines.length; i++) { sb.append(lines[i]); if (i == issueLineNumber) { sb .append(DrillParserUtil.EOL) .append(StringUtils.repeat(' ', shiftLength)) .append(""^""); } if (i < lines.length - 1) { sb.append(DrillParserUtil.EOL); } } sql = sb.toString(); } return sqlErrorMessageHeader + sql; }"	"  static String formatSQLParsingError(String sql, SqlParserPos pos) {
    if (pos == null) {
      return sql;
    }
    StringBuilder sb = new StringBuilder();
    String[] lines = sql.split(""\n"");
    for (int i = 0; i < lines.length; i++) {
      String line = lines[i];
      sb.append(line).append(""\n"");
      if (i == (pos.getLineNum() - 1)) {
        for (int j = 0; j < pos.getColumnNum() - 1; j++) {
          sb.append("" "");
        }
        sb.append(""^\n"");
      }
    }
    return sb.toString();
  }
"	@param ex exception object	@param pos the position of the error	1	0	13	33	210
private HiscoreLookup getCorrectLookupFor(final ChatMessage chatMessage) { final String player; final HiscoreEndpoint ironmanStatus; if (chatMessage.getType().equals(ChatMessageType.PRIVATE_MESSAGE_SENT)) { player = client.getLocalPlayer().getName(); ironmanStatus = hiscoreEndpoint; } else { player = sanitize(chatMessage.getName()); if (player.equals(client.getLocalPlayer().getName())) { // Get ironman status from for the local player ironmanStatus = hiscoreEndpoint; } else { // Get ironman status from their icon in chat ironmanStatus = getHiscoreEndpointByName(chatMessage.getName()); } } return new HiscoreLookup(player, ironmanStatus); }	"	private HiscoreLookup getCorrectLookupFor(final SetMessage setMessage)
	{
		final String player;
		final HiscoreEndpoint ironmanStatus;

		if (setMessage.getType().equals(ChatMessageType.PRIVATE_MESSAGE_SENT))
		{
			player = client.getLocalPlayer().getName();
			ironmanStatus = hiscoreEndpoint;
		}
		else
		{
			player = sanitize(setMessage.getName());

			if (player.equals(client.getLocalPlayer().getName()))
			{
				// Get ironman status from for the local player
				ironmanStatus = hiscoreEndpoint;
			}
			else
			{
				// Get ironman status from their icon in chat
				ironmanStatus = getHiscoreEndpointByName(setMessage.getName());
			}
		}

		return new HiscoreLookup(player, ironmanStatus);
	}
"	@param chatMessage chat message	@param setMessage chat message	1	0	10	29	116
public PendingMessageCursor getSubscriberPendingMessageCursor(String clientId, String name, Store tmpStorage, int maxBatchSize, Subscription sub) { return new VMPendingMessageCursor(); }	"    public PendingMessageCursor getSubscriberPendingMessageCursor(String clientId, String name, Store tmpStorage, int maxBatchSize) {
        return new VMPendingMessageCursor();
    }
"	@param clientId	@param clientId	0	1	5	4	27
public Action resumed(AtmosphereRequest request, AtmosphereResponse response) throws IOException, ServletException { return action(request, response); }	"    public Action resumed(HttpServletRequest request, HttpServletResponse response)
            throws IOException, ServletException {
        return action(request, response);
    }
"	@param request the  AtmosphereRequest	@param request the HttpServletRequest	1	0	5	5	24
public static int numberOfTrailingZeros(long lng) { return bitCount((lng & -lng) - 1); }	"    public static int numberOfTrailingZeros(long v) {
        int low = (int) v;
        return low !=0 ? Integer.numberOfTrailingZeros(low)
                       : 32 + Integer.numberOfTrailingZeros((int) (v >>> 32));
    }
"	@param lng the long to examine.	@param v the long to examine.	1	0	7	5	23
protected String setEscapedParameter(HttpMessage message, String param, String value) { return variant.setEscapedParameter(message, originalPair, param, value); }	"    protected String setEscapedParameter(HttpMessage msg, String param, String value) {
        return variant.setEscapedParameter(msg, originalPair, param, value);
    }
"	@param message the message that will be changed	@param msg	1	0	5	4	28
public static RuleSet getDrillUserConfigurableLogicalRules(OptimizerRulesContext optimizerRulesContext) { PlannerSettings ps = optimizerRulesContext.getPlannerSettings(); // This list is used to store rules that can be turned on an off // by user facing planning options Builder userConfigurableRules = ImmutableSet.<RelOptRule>builder(); if (ps.isConstantFoldingEnabled()) { // TODO - DRILL-2218 userConfigurableRules.add(ReduceExpressionsRule.PROJECT_INSTANCE); userConfigurableRules.add(DrillReduceExpressionsRule.FILTER_INSTANCE_DRILL); userConfigurableRules.add(DrillReduceExpressionsRule.CALC_INSTANCE_DRILL); } return new DrillRuleSet(userConfigurableRules.build()); }	"  public static RuleSet getDrillUserConfigurableLogicalRules(QueryContext queryContext) {
    PlannerSettings ps = queryContext.getPlannerSettings();

    // This list is used to store rules that can be turned on an off
    // by user facing planning options
    Builder userConfigurableRules = ImmutableSet.<RelOptRule>builder();

    if (ps.isConstantFoldingEnabled()) {
      // TODO - DRILL-2218
      userConfigurableRules.add(ReduceExpressionsRule.PROJECT_INSTANCE);

      userConfigurableRules.add(DrillReduceExpressionsRule.FILTER_INSTANCE_DRILL);
      userConfigurableRules.add(DrillReduceExpressionsRule.CALC_INSTANCE_DRILL);
    }

    return new DrillRuleSet(userConfigurableRules.build());
  }
"	@param optimizerRulesContext - used to get the list of planner settings, other rules may also in the future need to get other query state from this, such as the available list of UDFs (as is used by the DrillMergeProjectRule created in getDrillBasicRules())	@param queryContext - used to get the list of planner settings, other rules may also in the future need to get other query state from this, such as the available list of UDFs (as is used by the DrillMergeProjectRule created in getDrillBasicRules())	1	0	7	18	95
"private Expression translate0(RexNode expr, RexImpTable.NullAs nullAs) { if (expr instanceof RexInputRef) { final int index = ((RexInputRef) expr).getIndex(); Expression x = inputGetter.field(list, index); return nullAs.handle(list.append(""v"", x)); } if (expr instanceof RexLocalRef) { return translate( program.getExprList().get(((RexLocalRef) expr).getIndex()), nullAs); } if (expr instanceof RexLiteral) { return translateLiteral(expr, null, typeFactory, nullAs); } if (expr instanceof RexCall) { final RexCall call = (RexCall) expr; final SqlOperator operator = call.getOperator(); RexImpTable.CallImplementor implementor = RexImpTable.INSTANCE.get(operator); if (implementor != null) { return implementor.implement(this, call, nullAs); } } switch (expr.getKind()) { default: throw new RuntimeException( ""cannot translate expression "" + expr); } }"	"    private Expression translate0(RexNode expr, boolean mayBeNull) {
        if (expr instanceof RexInputRef) {
            final int index = ((RexInputRef) expr).getIndex();
            return inputGetter.field(list, index);
        }
        if (expr instanceof RexLocalRef) {
            return translate(
                program.getExprList().get(((RexLocalRef) expr).getIndex()),
                mayBeNull);
        }
        if (expr instanceof RexLiteral) {
            return translateLiteral(expr, null, typeFactory);
        }
        if (expr instanceof RexCall) {
            final RexCall call = (RexCall) expr;
            final SqlOperator operator = call.getOperator();
            RexImpTable.CallImplementor implementor =
                RexImpTable.INSTANCE.get(operator);
            if (implementor != null) {
                return implementor.implement(this, call, mayBeNull);
            }
        }
        switch (expr.getKind()) {
        default:
            throw new RuntimeException(
                ""cannot translate expression "" + expr);
        }
    }
"	@param nullAs If false, if expression is definitely not null at runtime. Therefore we can optimize. For example, we can cast to int using x.intValue().	@param mayBeNull If false, if expression is definitely not null at runtime. Therefore we can optimize. For example, we can cast to int using x.intValue().	1	0	10	30	187
"public int performExecuteUpdate(QueryParameters queryParameters, SharedSessionContractImplementor session) throws HibernateException { if ( traceEnabled ) { LOG.tracev( ""Execute update: {0}"", getSourceQuery() ); queryParameters.traceParameters( session.getFactory() ); } if ( translators.length != 1 ) { LOG.splitQueries( getSourceQuery(), translators.length ); } int result = 0; for ( QueryTranslator translator : translators ) { result += translator.executeUpdate( queryParameters, session ); } return result; }"	"	public int performExecuteUpdate(QueryParameters queryParameters, SessionImplementor session)
			throws HibernateException {
		if ( traceEnabled ) {
			LOG.tracev( ""Execute update: {0}"", getSourceQuery() );
			queryParameters.traceParameters( session.getFactory() );
		}
		if ( translators.length != 1 ) {
			LOG.splitQueries( getSourceQuery(), translators.length );
		}
		int result = 0;
		for ( QueryTranslator translator : translators ) {
			result += translator.executeUpdate( queryParameters, session );
		}
		return result;
	}
"	@param session The session	@param session The session	0	1	8	16	92
public boolean waitForText(String text, int minimumNumberOfMatches, long timeout) { return robotiumUtils.waitForText(text, minimumNumberOfMatches, timeout); }	"	public boolean waitForText(String text, int expectedMinimumNumberOfMatches, long timeout) {
       return robotiumUtils.waitForText(text, expectedMinimumNumberOfMatches, timeout);
    }
"	@param minimumNumberOfMatches the minimum number of text matches that are expected to be shown.  0 means any number of matches	@param expectedMinimumNumberOfMatches the minimum number of matches of text that must be shown. 0 means any number of matches	1	0	5	4	26
public Order placeOrder(Order order, Map<String, Object> params) throws IOException { HttpResponse response = placeOrderForHttpResponse(order, params); TypeReference typeRef = new TypeReference<Order>() {}; return apiClient.getObjectMapper().readValue(response.getContent(), typeRef); }	"    public Order placeOrder(Order body, Map<String, Object> params) throws IOException {
        HttpResponse response = placeOrderForHttpResponse(body, params);
        TypeReference typeRef = new TypeReference<Order>() {};
        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);
    }
"	@param params Map of query params. A collection will be interpreted as passing in multiple instances of the same query param.	@param params Map of query params. A collection will be interpreted as passing in multiple instances of the same query param.	0	1	8	6	51
public static DownloadQueue newDownloadQueue() { return newDownloadQueue(2); }	"	public static DownloadQueue newDownloadQueue(Context context) {
		return newDownloadQueue(context, 2);
	}
"	@param context ApplicationContext	@param context ApplicationContext	0	1	5	4	14
"private SQLResponse execute(String correctedSql, SQLRequest sqlRequest) throws Exception { Connection conn = null; Statement stat = null; ResultSet resultSet = null; List<List<String>> results = Lists.newArrayList(); List<SelectedColumnMeta> columnMetas = Lists.newArrayList(); try { conn = cacheService.getOLAPDataSource(sqlRequest.getProject()).getConnection(); if (sqlRequest instanceof PrepareSqlRequest) { PreparedStatement preparedState = conn.prepareStatement(correctedSql); processStatementAttr(preparedState, sqlRequest); for (int i = 0; i < ((PrepareSqlRequest) sqlRequest).getParams().length; i++) { setParam(preparedState, i + 1, ((PrepareSqlRequest) sqlRequest).getParams()[i]); } resultSet = preparedState.executeQuery(); } else { stat = conn.createStatement(); processStatementAttr(stat, sqlRequest); resultSet = stat.executeQuery(correctedSql); } ResultSetMetaData metaData = resultSet.getMetaData(); int columnCount = metaData.getColumnCount(); // Fill in selected column meta for (int i = 1; i <= columnCount; ++i) { columnMetas.add(new SelectedColumnMeta(metaData.isAutoIncrement(i), metaData.isCaseSensitive(i), metaData.isSearchable(i), metaData.isCurrency(i), metaData.isNullable(i), metaData.isSigned(i), metaData.getColumnDisplaySize(i), metaData.getColumnLabel(i), metaData.getColumnName(i), metaData.getSchemaName(i), metaData.getCatalogName(i), metaData.getTableName(i), metaData.getPrecision(i), metaData.getScale(i), metaData.getColumnType(i), metaData.getColumnTypeName(i), metaData.isReadOnly(i), metaData.isWritable(i), metaData.isDefinitelyWritable(i))); } // fill in results while (resultSet.next()) { List<String> oneRow = Lists.newArrayListWithCapacity(columnCount); for (int i = 0; i < columnCount; i++) { oneRow.add((resultSet.getString(i + 1))); } results.add(oneRow); } } finally { close(resultSet, stat, conn); } boolean isPartialResult = false; String cube = """"; StringBuilder sb = new StringBuilder(""Scan count for each storageContext: ""); long totalScanCount = 0; if (OLAPContext.getThreadLocalContexts() != null) { // contexts can be null in case of 'explain plan for' for (OLAPContext ctx : OLAPContext.getThreadLocalContexts()) { if (ctx.realization != null) { isPartialResult |= ctx.storageContext.isPartialResultReturned(); cube = ctx.realization.getName(); totalScanCount += ctx.storageContext.getTotalScanCount(); sb.append(ctx.storageContext.getTotalScanCount() + "",""); } } } logger.info(sb.toString()); SQLResponse response = new SQLResponse(columnMetas, results, cube, 0, false, null, isPartialResult); response.setTotalScanCount(totalScanCount); return response; }"	"    private SQLResponse execute(String sql, SQLRequest sqlRequest) throws Exception {
        Connection conn = null;
        Statement stat = null;
        ResultSet resultSet = null;

        List<List<String>> results = Lists.newArrayList();
        List<SelectedColumnMeta> columnMetas = Lists.newArrayList();

        try {
            conn = cacheService.getOLAPDataSource(sqlRequest.getProject()).getConnection();

            if (sqlRequest instanceof PrepareSqlRequest) {
                PreparedStatement preparedState = conn.prepareStatement(sql);
                processStatementAttr(preparedState, sqlRequest);

                for (int i = 0; i < ((PrepareSqlRequest) sqlRequest).getParams().length; i++) {
                    setParam(preparedState, i + 1, ((PrepareSqlRequest) sqlRequest).getParams()[i]);
                }

                resultSet = preparedState.executeQuery();
            } else {
                stat = conn.createStatement();
                processStatementAttr(stat, sqlRequest);
                resultSet = stat.executeQuery(sql);
            }

            ResultSetMetaData metaData = resultSet.getMetaData();
            int columnCount = metaData.getColumnCount();

            // Fill in selected column meta
            for (int i = 1; i <= columnCount; ++i) {
                columnMetas.add(new SelectedColumnMeta(metaData.isAutoIncrement(i), metaData.isCaseSensitive(i), metaData.isSearchable(i), metaData.isCurrency(i), metaData.isNullable(i), metaData.isSigned(i), metaData.getColumnDisplaySize(i), metaData.getColumnLabel(i), metaData.getColumnName(i), metaData.getSchemaName(i), metaData.getCatalogName(i), metaData.getTableName(i), metaData.getPrecision(i), metaData.getScale(i), metaData.getColumnType(i), metaData.getColumnTypeName(i), metaData.isReadOnly(i), metaData.isWritable(i), metaData.isDefinitelyWritable(i)));
            }

            // fill in results
            while (resultSet.next()) {
                List<String> oneRow = Lists.newArrayListWithCapacity(columnCount);
                for (int i = 0; i < columnCount; i++) {
                    oneRow.add((resultSet.getString(i + 1)));
                }

                results.add(oneRow);
            }
        } finally {
            close(resultSet, stat, conn);
        }

        boolean isPartialResult = false;
        String cube = """";
        StringBuilder sb = new StringBuilder(""Scan count for each storageContext: "");
        long totalScanCount = 0;
        if (OLAPContext.getThreadLocalContexts() != null) { // contexts can be null in case of 'explain plan for'
            for (OLAPContext ctx : OLAPContext.getThreadLocalContexts()) {
                if (ctx.realization != null) {
                    isPartialResult |= ctx.storageContext.isPartialResultReturned();
                    cube = ctx.realization.getName();
                    totalScanCount += ctx.storageContext.getTotalScanCount();
                    sb.append(ctx.storageContext.getTotalScanCount() + "","");
                }
            }
        }
        logger.info(sb.toString());

        SQLResponse response = new SQLResponse(columnMetas, results, cube, 0, false, null, isPartialResult);
        response.setTotalScanCount(totalScanCount);

        return response;
    }
"	@param sqlRequest	@param sqlRequest	0	1	12	69	534
public WebElement searchForWebElement(final By by, int minimumNumberOfMatches, int timeout, boolean scroll){ if(minimumNumberOfMatches < 1){ minimumNumberOfMatches = 1; } List<WebElement> viewsFromScreen = webUtils.getCurrentWebElements(by); addViewsToList (webElements, viewsFromScreen); return getViewFromList(webElements, minimumNumberOfMatches); }	"	public WebElement searchForWebElement(final By by, int match, int timeout, boolean scroll){

		if(match < 1){
			match = 1;
		}

		List<WebElement> viewsFromScreen = webUtils.getCurrentWebElements(by);
		addViewsToList (webElements, viewsFromScreen);

		return getViewFromList(webElements, match);
	}
"	@param minimumNumberOfMatches the minimum number of matches that are expected to be shown.  0 means any number of matches	@param match if multiple objects match the text, this determines which one will be clicked	1	0	7	12	53
public Call updatePetWithFormAsync(Long petId, String name, String status, final ApiCallback<Void> callback) throws ApiException { ProgressResponseBody.ProgressListener progressListener = null; ProgressRequestBody.ProgressRequestListener progressRequestListener = null; if (callback != null) { progressListener = new ProgressResponseBody.ProgressListener() { @Override public void update(long bytesRead, long contentLength, boolean done) { callback.onDownloadProgress(bytesRead, contentLength, done); } }; progressRequestListener = new ProgressRequestBody.ProgressRequestListener() { @Override public void onRequestProgress(long bytesWritten, long contentLength, boolean done) { callback.onUploadProgress(bytesWritten, contentLength, done); } }; } Call call = updatePetWithFormCall(petId, name, status, progressListener, progressRequestListener); apiClient.executeAsync(call, callback); return call; }	"  public Call updatePetWithFormAsync(String petId, String name, String status, final ApiCallback<Void> callback) throws ApiException {

    ProgressResponseBody.ProgressListener progressListener = null;
    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

    if (callback != null) {
      progressListener = new ProgressResponseBody.ProgressListener() {
        @Override
        public void update(long bytesRead, long contentLength, boolean done) {
          callback.onDownloadProgress(bytesRead, contentLength, done);
        }
      };

      progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
        @Override
        public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
          callback.onUploadProgress(bytesWritten, contentLength, done);
        }
      };
    }

    Call call = updatePetWithFormCall(petId, name, status, progressListener, progressRequestListener);
    apiClient.executeAsync(call, callback);
    return call;
  }
"	@param status Updated status of the pet (optional)	@param status Updated status of the pet (optional)	0	1	11	26	138
public final DBCompareColExpr in(Collection<?> values) { if (values==null || values.isEmpty()) return cmp(DBCmpType.EQUAL, null); // create expression return cmp(DBCmpType.IN, values); }	"    public DBCompareColExpr in(Object value)
    {
        return cmp(DBCmpType.IN, listToArray(value));
    }
"	@param list the values to compare this column with	@param value the int value	1	0	6	9	44
public static int numberOfLeadingZeros(long lng) { lng |= lng >> 1; lng |= lng >> 2; lng |= lng >> 4; lng |= lng >> 8; lng |= lng >> 16; lng |= lng >> 32; return bitCount(~lng); }	"    public static int numberOfLeadingZeros(long v) {
        // After Hacker's Delight, Figure 5-6
        if (v < 0) {
            return 0;
        }
        if (v == 0) {
            return 64;
        }
        // On a 64-bit VM, the two previous tests should probably be replaced by
        // if (v <= 0) return ((int) (~v >> 57)) & 64;

        int n = 1;
        int i = (int) (v >>> 32);
        if (i == 0) {
            n +=  32;
            i = (int) v;
        }
        if (i >>> 16 == 0) {
            n +=  16;
            i <<= 16;
        }
        if (i >>> 24 == 0) {
            n +=  8;
            i <<= 8;
        }
        if (i >>> 28 == 0) {
            n +=  4;
            i <<= 4;
        }
        if (i >>> 30 == 0) {
            n +=  2;
            i <<= 2;
        }
        return n - (i >>> 31);
    }
"	@param lng the long to examine.	@param v the long to examine.	1	0	6	11	46
"public List<String> dependencyPathBetween(int start, int end, Optional<Function<Sentence, List<String>>> selector) { // Get paths from a node to the root of the sentence LinkedList<Integer> rootToStart = new LinkedList<>(); LinkedList<Integer> rootToEnd = new LinkedList<>(); int startAncestor = start; List<Optional<Integer>> governors = sentence.governors(); Set<Integer> seenVertices = new HashSet<>(); while (startAncestor >= 0 && governors.get(startAncestor).isPresent()) { if (seenVertices.contains(startAncestor)) { // Found loopiness -- revert to BFS return loopyDependencyPathBetween(start, end, selector); } seenVertices.add(startAncestor); rootToStart.addFirst(startAncestor); startAncestor = governors.get(startAncestor).get(); } if (startAncestor == -1) { rootToStart.addFirst(-1); } int endAncestor = end; seenVertices.clear(); while (endAncestor >= 0 && governors.get(endAncestor).isPresent()) { if (seenVertices.contains(endAncestor)) { // Found loopiness -- revert to BFS return loopyDependencyPathBetween(start, end, selector); } seenVertices.add(endAncestor); rootToEnd.addFirst(endAncestor); endAncestor = governors.get(endAncestor).get(); } if (endAncestor == -1) { rootToEnd.addFirst(-1); } // Get least common node int leastCommonNodeIndex = (rootToStart.size() == 0 || rootToEnd.size() == 0 || !rootToStart.get(0).equals(rootToEnd.get(0))) ? -1 : 0; for (int i = 1; i < Math.min(rootToStart.size(), rootToEnd.size()); ++i) { if (rootToStart.get(i).equals(rootToEnd.get(i))) { leastCommonNodeIndex = i; } } // Construct the path if (leastCommonNodeIndex < 0) { return Collections.emptyList(); } List<String> path = new ArrayList<>(); Optional<List<String>> words = selector.map(x -> x.apply(sentence)); for (int i = rootToStart.size() - 1; i > leastCommonNodeIndex; --i) { final int index = i; words.ifPresent(x -> path.add(x.get(rootToStart.get(index)))); path.add(""<-"" + sentence.incomingDependencyLabel(rootToStart.get(i)).orElse(""dep"") + ""-""); } if (words.isPresent()) { path.add(words.get().get(rootToStart.get(leastCommonNodeIndex))); } for (int i = leastCommonNodeIndex + 1; i < rootToEnd.size(); ++i) { final int index = i; path.add(""-"" + sentence.incomingDependencyLabel(rootToEnd.get(i)).orElse(""dep"") + ""->""); words.ifPresent(x -> path.add(x.get(rootToEnd.get(index)))); } return path; }"	"  public List<String> dependencyPathBetween(int start, int end, Function<Sentence, List<String>> selector) {
    // Get paths from a node to the root of the sentence
    LinkedList<Integer> rootToStart = new LinkedList<>();
    LinkedList<Integer> rootToEnd = new LinkedList<>();
    int startAncestor = start;
    List<Optional<Integer>> governors = sentence.governors();
    Set<Integer> seenVertices = new HashSet<>();
    while (startAncestor >= 0 && governors.get(startAncestor).isPresent()) {
      if (seenVertices.contains(startAncestor)) {
        return Collections.EMPTY_LIST;
      }
      seenVertices.add(startAncestor);
      rootToStart.addFirst(startAncestor);
      startAncestor = governors.get(startAncestor).get();
    }
    if (startAncestor == -1) {
      rootToStart.addFirst(-1);
    }
    int endAncestor = end;
    seenVertices.clear();
    while (endAncestor >= 0 && governors.get(endAncestor).isPresent()) {
      if (seenVertices.contains(endAncestor)) {
        return Collections.EMPTY_LIST;
      }
      seenVertices.add(endAncestor);
      rootToEnd.addFirst(endAncestor);
      endAncestor = governors.get(endAncestor).get();
    }
    if (endAncestor == -1) {
      rootToEnd.addFirst(-1);
    }

    // Get least common node
    int leastCommonNodeIndex = (rootToStart.size() == 0 || rootToEnd.size() == 0 || !rootToStart.get(0).equals(rootToEnd.get(0))) ? -1 : 0;
    for (int i = 1; i < Math.min(rootToStart.size(), rootToEnd.size()); ++i) {
      if (rootToStart.get(i).equals(rootToEnd.get(i))) {
        leastCommonNodeIndex = i;
      }
    }

    // Construct the path
    if (leastCommonNodeIndex < 0) {
      return Collections.EMPTY_LIST;
    }
    List<String> path = new ArrayList<>();
    for (int i = rootToStart.size() - 1; i > leastCommonNodeIndex; --i) {
      path.add(selector.apply(sentence).get(rootToStart.get(i)));
      path.add(""<-"" + sentence.incomingDependencyLabel(rootToStart.get(i)).orElse(""dep"") + ""-"");
    }
    path.add(selector.apply(sentence).get(rootToStart.get(leastCommonNodeIndex)));
    for (int i = leastCommonNodeIndex + 1; i < rootToEnd.size(); ++i) {
      path.add(""-"" + sentence.incomingDependencyLabel(rootToEnd.get(i)).orElse(""dep"") + ""->"");
      path.add(selector.apply(sentence).get(rootToEnd.get(i)));
    }
    return path;
  }
"	@param start The start word, 0-indexed.	@param span The span of the sentence to find the mode element in. This must be entirely contained in the sentence.	1	0	11	64	555
public boolean isSupported(DateTimeFieldType type) { for (int i = 0, isize = size(); i < isize; i++) { if (getFieldType(i) == type) { return true; } } return false; }	"    public boolean isSupported(DateTimeField field) {
        for (int i = 0, isize = getFieldSize(); i < isize; i++) {
            if (getField(i) == field) {
                return true;
            }
        }
        return false;
    }
"	@param type the type to check, may be null which returns false	@param field the field to check, may be null which returns false	1	0	8	9	45
public static Point getCanvasImageLocation(Client client, Graphics2D graphics, LocalPoint localLocation, BufferedImage image, int zOffset) { int plane = client.getPlane(); Point p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset); if (p == null) { return null; } int xOffset = p.getX() - image.getWidth() / 2; int yOffset = p.getY() - image.getHeight() / 2; return new Point(xOffset, yOffset); }	"	public static Point getCanvasImageLocation(Client client, Graphics2D graphics, Point localLocation, BufferedImage image, int zOffset)
	{
		int plane = client.getPlane();

		Point p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset);

		if (p == null)
		{
			return null;
		}

		int xOffset = p.getX() - image.getWidth() / 2;
		int yOffset = p.getY() - image.getHeight() / 2;

		return new Point(xOffset, yOffset);
	}
"	@param graphics	@param graphics	0	1	7	17	98
protected String getAsText(int fieldValue, Locale locale) { return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToText(fieldValue); }	"    public String getAsText(long instant, Locale locale) {
        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToText(get(instant));
    }
"	@param fieldValue the field value to query	@param instant the time instant in millis to query	1	0	6	4	23
"public static RemoteProxy getNewBasicRemoteProxy(Map<String, Object> cap, String url,Registry registry) { RegistrationRequest req = new RegistrationRequest(); req.addDesiredCapabilitiy(cap); Map<String, Object> config = new HashMap<String, Object>(); config.put(""url"", url); req.setConfiguration(config); return new RemoteProxy(req,registry); }"	"	public static RemoteProxy getNewBasicRemoteProxy(Map<String, Object> cap, String url) {

		RegistrationRequest req = new RegistrationRequest();

		req.addDesiredCapabilitiy(cap);

		Map<String, Object> config = new HashMap<String, Object>();
		config.put(""url"", url);
		req.setConfiguration(config);
		return new RemoteProxy(req);

	}
"	@param cap	@param cap	0	1	8	13	70
"public int[] add(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { if (valueToAdd == 0) { return values; } // there are more efficient algorithms than this (especially for time only fields) // trouble is when dealing with days and months, so we use this technique of // adding/removing one from the larger field at a time DateTimeField nextField = null; while (valueToAdd > 0) { int max = getMaximumValue(instant, values); long proposed = values[fieldIndex] + valueToAdd; if (proposed <= max) { values[fieldIndex] = (int) proposed; break; } if (nextField == null) { if (fieldIndex == 0) { throw new IllegalArgumentException(""Maximum value exceeded for add""); } nextField = instant.getField(fieldIndex - 1); if (getRangeDurationField() != nextField.getDurationField()) { throw new IllegalArgumentException(""Fields invalid for add""); } } valueToAdd -= (max + 1) - values[fieldIndex]; values = nextField.add(instant, fieldIndex - 1, values, 1); values[fieldIndex] = getMinimumValue(instant, values); } while (valueToAdd < 0) { int min = getMinimumValue(instant, values); long proposed = values[fieldIndex] + valueToAdd; if (proposed >= min) { values[fieldIndex] = (int) proposed; break; } if (nextField == null) { if (fieldIndex == 0) { throw new IllegalArgumentException(""Maximum value exceeded for add""); } nextField = instant.getField(fieldIndex - 1); if (getRangeDurationField() != nextField.getDurationField()) { throw new IllegalArgumentException(""Fields invalid for add""); } } valueToAdd -= (min - 1) - values[fieldIndex]; values = nextField.add(instant, fieldIndex - 1, values, -1); values[fieldIndex] = getMaximumValue(instant, values); } return set(instant, fieldIndex, values, values[fieldIndex]); // adjusts smaller fields }"	"    public int[] add(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd) {
        if (valueToAdd == 0) {
            return values;
        }
        // there are more efficient algorithms than this (especially for time only fields)
        // trouble is when dealing with days and months, so we use this technique of
        // adding/removing one from the larger field at a time
        DateTimeField nextField = null;
        
        while (valueToAdd > 0) {
            int max = getMaximumValue(instant, values);
            long proposed = values[fieldIndex] + valueToAdd;
            if (proposed <= max) {
                values[fieldIndex] = (int) proposed;
                break;
            }
            if (nextField == null) {
                if (fieldIndex == 0) {
                    throw new IllegalArgumentException(""Maximum value exceeded for add"");
                }
                nextField = instant.getField(fieldIndex - 1);
                if (getRangeDurationField() != nextField.getDurationField()) {
                    throw new IllegalArgumentException(""Fields invalid for add"");
                }
            }
            valueToAdd -= (max + 1) - values[fieldIndex];
            values = nextField.add(instant, fieldIndex - 1, values, 1);
            values[fieldIndex] = getMinimumValue(instant, values);
        }
        while (valueToAdd < 0) {
            int min = getMinimumValue(instant, values);
            long proposed = values[fieldIndex] + valueToAdd;
            if (proposed >= min) {
                values[fieldIndex] = (int) proposed;
                break;
            }
            if (nextField == null) {
                if (fieldIndex == 0) {
                    throw new IllegalArgumentException(""Maximum value exceeded for add"");
                }
                nextField = instant.getField(fieldIndex - 1);
                if (getRangeDurationField() != nextField.getDurationField()) {
                    throw new IllegalArgumentException(""Fields invalid for add"");
                }
            }
            valueToAdd -= (min - 1) - values[fieldIndex];
            values = nextField.add(instant, fieldIndex - 1, values, -1);
            values[fieldIndex] = getMaximumValue(instant, values);
        }
        
        return set(instant, fieldIndex, values, values[fieldIndex]);  // adjusts smaller fields
    }
"	@param values the values of the partial instant which should be updated	@param values the values of the partial instant which should be updated	0	1	11	53	389
"private MessageBatcher getBatcher(final String serviceUrl, String pBatcherName) { String batcherName = null; try { batcherName = new URL(serviceUrl).getHost(); } catch (MalformedURLException e1) { batcherName = serviceUrl; } String absoluteBatcherName = batcherName + ""-"" + pBatcherName; ConfigurationManager.getConfigInstance().setProperty( ""batcher."" + absoluteBatcherName + "".queue.maxMessages"", config.getMaxElementsInPeerReplicationPool()); ConfigurationManager.getConfigInstance().setProperty( ""batcher."" + absoluteBatcherName + "".batch.maxMessages"", 250); ConfigurationManager.getConfigInstance().setProperty( ""batcher."" + absoluteBatcherName + "".keepAliveTime"", config.getMaxIdleThreadAgeInMinutesForPeerReplication() * 60); ConfigurationManager.getConfigInstance().setProperty( ""batcher."" + absoluteBatcherName + "".maxThreads"", config.getMaxThreadsForPeerReplication()); return BatcherFactory.createBatcher(absoluteBatcherName, new MessageProcessor<ReplicationTask>() { private String BATCH_URL_PATH = ""apps/batch/"";; @Override public void process(List<ReplicationTask> tasks) { if (!tasks.get(0).isBatchingSupported()) { executeSingle(tasks); } else if (!executeBatch(tasks)) { executeSingle(tasks); } } private boolean executeBatch(List<ReplicationTask> tasks) { boolean success = true; boolean done = true; PeerEurekaNode.ReplicationList list = new PeerEurekaNode.ReplicationList(); for (ReplicationTask task : tasks) { Object[] args = { task.getAppName(), task.getId(), task.getAction(), new Date(System.currentTimeMillis()), new Date(task.getSubmitTime()) }; if (System.currentTimeMillis() - config.getMaxTimeForReplication() > task .getSubmitTime()) { logger.warn( ""Replication events older than the threshold. AppName : {}, Id: {}, Action : {}, Current Time : {}, Submit Time :{}"", args); continue; } PeerEurekaNode.ReplicationInstance instance = new PeerEurekaNode.ReplicationInstance(); instance.setAppName(task.getAppName()); instance.setId(task.getId()); InstanceInfo instanceInfo = task.getInstanceInfo(); if (instanceInfo != null) { String overriddenStatus = (task .getOverriddenStatus() == null ? null : task.getOverriddenStatus().name()); instance.setOverriddenStatus(overriddenStatus); instance.setLastDirtyTimestamp(instanceInfo .getLastDirtyTimestamp()); if (task.shouldReplicateInstanceInfo()) { instance.setInstanceInfo(instanceInfo); } String instanceStatus = instanceInfo .getStatus() == null ? null : instanceInfo.getStatus().name(); instance.setStatus(instanceStatus); } list.addReplicationInstance(instance); } if (list.getList().size() == 0) { return true; } list.setAction(tasks.get(0).getAction()); DynamicCounter.increment(""Batch_"" + list.getAction().name() + ""_tries""); do { done = true; ClientResponse response = null; try { response = jerseyApacheClient .resource(serviceUrl) .path(BATCH_URL_PATH) .accept(MediaType.APPLICATION_JSON_TYPE) .type(MediaType.APPLICATION_JSON_TYPE) .post(ClientResponse.class, list); if (isSuccess(response)) { return false; } DynamicCounter.increment(""Batch_"" + list.getAction().name() + ""_success""); PeerEurekaNode.ReplicationListResponse batchResponse = response .getEntity(PeerEurekaNode.ReplicationListResponse.class); int ctr = 0; for (PeerEurekaNode.ReplicationInstanceResponse singleResponse : batchResponse .getResponseList()) { int statusCode = singleResponse .getStatusCode(); if ((!isSuccess(response)) || (singleResponse .getResponseEntity() != null)) { if (singleResponse.getResponseEntity() != null) { tasks.get(ctr) .setPeerInstanceInfo( singleResponse .getResponseEntity()); } tasks.get(ctr) .handleFailure(statusCode); } ++ctr; } done = true; } catch (Throwable e) { if ((isNetworkConnectException(e))) { DynamicCounter.increment(""Batch_"" + list.getAction().name() + ""_retries""); done = false; } else { success = false; logger.info( ""Not re-trying this exception because it does not seem to be a network exception"", e); } } finally { if (response != null) { response.close(); } } } while (!done); return success; } private boolean isSuccess(ClientResponse response) { return response.getStatus() < 200 || response.getStatus() >= 300; } private void executeSingle(List<ReplicationTask> tasks) { for (ReplicationTask task : tasks) { boolean done = true; do { done = true; try { Object[] args = { task.getAppName(), task.getId(), task.getAction(), new Date(System.currentTimeMillis()), new Date(task.getSubmitTime()) }; if (System.currentTimeMillis() - config.getMaxTimeForReplication() > task .getSubmitTime()) { logger.warn( ""Replication events older than the threshold. AppName : {}, Id: {}, Action : {}, Current Time : {}, Submit Time :{}"", args); continue; } DynamicCounter.increment(""Single_"" + task.getAction().name() + ""_tries""); int statusCode = task.execute(); if (statusCode < 200 && statusCode > 299) { task.handleFailure(statusCode); } DynamicCounter.increment(""Single_"" + task.getAction().name() + ""_success""); } catch (Throwable e) { logger.error( name + task.getAppName() + ""/"" + task.getId() + "":"" + task.getAction(), e); try { Thread.sleep(RETRY_SLEEP_TIME_MS); } catch (InterruptedException e1) { } if ((isNetworkConnectException(e))) { DynamicCounter.increment(task .getAction().name() + ""_retries""); done = false; } else { logger.info( ""Not re-trying this exception because it does not seem to be a network exception"", e); } } } while (!done); } } }); }"	"    private MessageBatcher getBatcher(String serviceUrl, Action action) {
        String batcherName = null;
        try {
            batcherName = new URL(serviceUrl).getHost();
        } catch (MalformedURLException e1) {
            batcherName = serviceUrl;
        }
        String absoluteBatcherName = batcherName + ""-"" + action.name();
        ConfigurationManager.getConfigInstance().setProperty(
                ""batcher."" + absoluteBatcherName + "".queue.maxMessages"",
                config.getMaxElementsInPeerReplicationPool());
        ConfigurationManager.getConfigInstance().setProperty(
                ""batcher."" + absoluteBatcherName + "".keepAliveTime"",
                config.getMaxIdleThreadAgeInMinutesForPeerReplication() * 60);
        ConfigurationManager.getConfigInstance().setProperty(
                ""batcher."" + absoluteBatcherName + "".maxThreads"",
                config.getMaxThreadsForPeerReplication());

        return BatcherFactory.createBatcher(absoluteBatcherName,
                new MessageProcessor<ReplicationTask>() {

                    @Override
                    public void process(List<ReplicationTask> tasks) {
                        for (ReplicationTask task : tasks) {
                            boolean done = true;
                            do {
                                done = true;
                                try {
                                    Object[] args = {
                                            task.getAppName(),
                                            task.getId(),
                                            task.getAction(),
                                            new Date(System.currentTimeMillis()),
                                            new Date(task.getSubmitTime()) };
                                    if (System.currentTimeMillis()
                                            - config.getMaxTimeForReplication() > task
                                            .getSubmitTime()) {
                                        logger.warn(
                                                ""Replication events older than the threshold. AppName : {}, Id: {}, Action : {}, Current Time : {}, Submit Time :{}"",
                                                args);

                                        continue;
                                    }
                                    task.execute();
                                } catch (Throwable e) {
                                    logger.error(
                                            name + task.getAppName() + ""/""
                                                    + task.getId() + "":""
                                                    + task.getAction(), e);
                                    try {
                                        Thread.sleep(RETRY_SLEEP_TIME_MS);
                                    } catch (InterruptedException e1) {

                                    }
                                    if ((isNetworkConnectException(e))) {
                                        DynamicCounter.increment(task
                                                .getAction().name()
                                                + ""_retries"");
                                        done = false;
                                    } else {
                                        logger.info(
                                                ""Not re-trying this exception because it does not seem to be a network exception"",
                                                e);
                                    }
                                }
                            } while (!done);
                        }
                    }
                });
    }
"	@param action the action that indicates the type of replication event - registrations, heartbeat etc	@param action the action that indicates the type of replication event - registrations, heartbeat etc	0	1	20	215	1124
"private boolean searchForToggleButton(String regex, int matches) { sleeper.sleep(); inst.waitForIdleSync(); Pattern p = Pattern.compile(regex); Matcher matcher; ArrayList<ToggleButton> toggleButtonList = viewFetcher.getCurrentViews(ToggleButton.class); if(matches == 0) matches = 1; for(ToggleButton toggleButton : toggleButtonList){ matcher = p.matcher(toggleButton.getText().toString()); if(matcher.find()){ countMatches++; } if (countMatches == matches) { countMatches=0; return true; } } if (scroller.scroll(Scroller.Direction.DOWN)) { return searchForToggleButton(regex, matches); } else { if(countMatches > 0) Log.d(LOG_TAG, "" There are only "" + countMatches + "" matches of "" + regex); countMatches = 0; return false; } }"	"	private boolean searchForToggleButton(String search, int matches) {
		sleeper.sleep();
		inst.waitForIdleSync();
		Pattern p = Pattern.compile(search);
		Matcher matcher;
		ArrayList<ToggleButton> toggleButtonList = viewFetcher.getCurrentViews(ToggleButton.class);
		if(matches == 0)
			matches = 1;
		for(ToggleButton toggleButton : toggleButtonList){
			matcher = p.matcher(toggleButton.getText().toString());
			if(matcher.find()){	
				countMatches++;
			}
			if (countMatches == matches) {
				countMatches=0;
				return true;
			} 
		}

		if (scroller.scroll(Scroller.Direction.DOWN))
		{
			return searchForToggleButton(search, matches);
		} else {
			if(countMatches > 0)
				Log.d(LOG_TAG, "" There are only "" + countMatches + "" matches of "" + search);
			countMatches = 0;
			return false;
		}
		
	}
"	@param regex the text to search for. The parameter will be interpreted as a regular expression.	@param search the string to be searched. The parameter will be interpreted as a regular expression.	1	0	11	31	154
public int get(long instant) { // Get an initial estimate of the year, and the millis value that // represents the start of that year. Then verify estimate and fix if // necessary. int year; long unitMillis = getDurationUnitMillis(); if (instant >= 0) { year = 1970 + (int) (instant / unitMillis); } else { year = 1970 + (int) ((instant - unitMillis + 1) / unitMillis); } long yearStart = iChronology.getYearMillis(year); if ((yearStart ^ instant) < 0) { // Sign mismatch, operation overflowed. return getOverflow(instant); } long diff = instant - yearStart; if (diff < 0) { // Subtract one year to fix estimate. year--; } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) { // One year may need to be added to fix estimate. long oneYear; if (iChronology.isLeapYear(year)) { oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L; } else { oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L; } yearStart += oneYear; if ((yearStart ^ instant) < 0) { // Sign mismatch, operation overflowed. return getOverflow(instant); } if (yearStart <= instant) { // Didn't go too far, so actually add one year. year++; } } return year; }	"    public int get(long millis) {
        // Get an initial estimate of the year, and the millis value
        // that represents the start of that year.
        int year = 1970 + (int) (millis / iRoughMillisPerYear);
        long yearStartMillis = iChronology.getYearMillis(year);

        if (millis > yearStartMillis) {
            for (;;) {
                // Actual year may be greater than what we estimated. Check if
                // year should advance.
                if (iChronology.isLeapYear(year)) {
                    yearStartMillis += DateTimeConstants.MILLIS_PER_DAY * 366L;
                } else {
                    yearStartMillis += DateTimeConstants.MILLIS_PER_DAY * 365L;
                }
                if (millis < yearStartMillis) {
                    // Year was correct, no need to advance.
                    break;
                }
                year++;
                if (millis == yearStartMillis) {
                    // Millis is at start of year; year is now correct, so no
                    // need to check anymore.
                    break;
                }
                if ((millis ^ yearStartMillis) < 0) {
                    // Sign mismatch, operation overflowed.
                    return getOverflow(millis);
                }
            }
        } else if (millis < yearStartMillis) {
            for (;;) {
                // Actual year less than what we estimated. Go to previous year
                // and check.
                year--;
                if (iChronology.isLeapYear(year)) {
                    yearStartMillis -= DateTimeConstants.MILLIS_PER_DAY * 366L;
                } else {
                    yearStartMillis -= DateTimeConstants.MILLIS_PER_DAY * 365L;
                }
                if (millis >= yearStartMillis) {
                    // Year is now correct.
                    break;
                }
                if ((millis ^ yearStartMillis) < 0) {
                    // Sign mismatch, operation overflowed.
                    return getOverflow(millis);
                }
            }
        }

        return year;
    }
"	@param instant the time instant in millis to query.	@param millis the time instant in millis to query.	1	0	12	49	254
public int delete(Object[] row, Instant ts) throws InterruptedException { return delete(row, ts, 0, 1); }	"        public int delete(Object[] row, long ts) throws InterruptedException {
            return delete(row, ts, 0, 1);
        }
"	@param ts the timestamp for this row	@param ts the timestamp for this row	0	1	5	4	28
"public String getTypeDeclaration(Schema p) { if (ModelUtils.isArraySchema(p)) { ArraySchema ap = (ArraySchema) p; Schema inner = ap.getItems(); return getTypeDeclaration(inner) + ""[]""; } else if (ModelUtils.isMapSchema(p)) { Schema inner = (Schema) p.getAdditionalProperties(); // TODO not sure if the following map/hash declaration is correct return ""{String, "" + getTypeDeclaration(inner) + ""}""; } else if (!languageSpecificPrimitives.contains(getSchemaType(p))) { return packageName + "".Model."" + super.getTypeDeclaration(p); } return super.getTypeDeclaration(p); }"	"    public String getTypeDeclaration(Property p) {
        if (p instanceof ArrayProperty) {
            ArrayProperty ap = (ArrayProperty) p;
            Property inner = ap.getItems();
            return getTypeDeclaration(inner) + ""[]"";
        } else if (p instanceof MapProperty) {
            MapProperty mp = (MapProperty) p;
            Property inner = mp.getAdditionalProperties();
            // TODO not sure if the following map/hash declaration is correct
            return ""{String, "" + getTypeDeclaration(inner) + ""}"";
        } else if (!languageSpecificPrimitives.contains(getSwaggerType(p))) {
            return packageName + "".Model."" + super.getTypeDeclaration(p);
        }
        return super.getTypeDeclaration(p);
    }
"	@param p OpenAPI Schema object	@param p Swagger Property object	1	0	10	15	130
"public static SemgrexPattern compile(String semgrex, Env env) { try { SemgrexParser parser = new SemgrexParser(new StringReader(semgrex + ""\n"")); SemgrexPattern newPattern = parser.Root(); newPattern.env = env; newPattern.patternString = semgrex; return newPattern; } catch (ParseException ex) { throw new SemgrexParseException(""Error parsing semgrex pattern "" + semgrex, ex); } catch (TokenMgrError er) { throw new SemgrexParseException(""Error parsing semgrex pattern "" + semgrex, er); } }"	"  public static SemgrexPattern compile(String semgrex) {
    try {
      SemgrexParser parser = new SemgrexParser(new StringReader(semgrex + ""\n""));
      SemgrexPattern newPattern = parser.Root();
      newPattern.patternString = semgrex;
      return newPattern;
    } catch (ParseException ex) {
      throw new SemgrexParseException(""Error parsing semgrex pattern "" + semgrex, ex);
    } catch (TokenMgrError er) {
      throw new SemgrexParseException(""Error parsing semgrex pattern "" + semgrex, er);
    }
  }
"	@param semgrex the pattern string	@param semgrex the pattern string	0	1	9	14	97
public long set(long instant, int era) { Utils.verifyValueBounds(this, era, DateTimeConstants.BCE, DateTimeConstants.CE); int oldEra = get(instant); if (oldEra != era) { int year = iChronology.year().get(instant); return iChronology.year().set(instant, -year); } else { return instant; } }	"    public long set(long millis, int era) {
        super.verifyValueBounds(era, DateTimeConstants.BCE, DateTimeConstants.CE);
            
        int oldEra = get(millis);
        if (oldEra != era) {
            int year = iChronology.year().get(millis);
            return iChronology.year().set(millis, -year);
        } else {
            return millis;
        }
    }
"	@param instant the time instant in millis to update.	@param millis the time instant in millis to update.	1	0	9	12	71
"public static String ensurePrerequisiteAnnotators(String[] annotators) { // Get an unordered set of annotators Set<String> unorderedAnnotators = new LinkedHashSet<>(); // linked to preserve order Collections.addAll(unorderedAnnotators, annotators); for (String annotator : annotators) { // Add the annotator if (!getNamedAnnotators().containsKey(annotator.toLowerCase())) { throw new IllegalArgumentException(""Unknown annotator: "" + annotator); } // Add its transitive dependencies unorderedAnnotators.add(annotator.toLowerCase()); if (!Annotator.DEFAULT_REQUIREMENTS.containsKey(annotator.toLowerCase())) { throw new IllegalArgumentException(""Cannot infer requirements for annotator: "" + annotator); } Queue<String> fringe = new LinkedList<>(Annotator.DEFAULT_REQUIREMENTS.get(annotator.toLowerCase())); int ticks = 0; while (!fringe.isEmpty()) { ticks += 1; if (ticks == 1000000) { throw new IllegalStateException(""[INTERNAL ERROR] Annotators have a circular dependency.""); } String prereq = fringe.poll(); unorderedAnnotators.add(prereq); fringe.addAll(Annotator.DEFAULT_REQUIREMENTS.get(prereq.toLowerCase())); } } // Order the annotators List<String> orderedAnnotators = new ArrayList<>(); while (!unorderedAnnotators.isEmpty()) { boolean somethingAdded = false; // to make sure the dependencies are satisfiable // Loop over candidate annotators to add Iterator<String> iter = unorderedAnnotators.iterator(); while (iter.hasNext()) { String candidate = iter.next(); // Are the requirements satisfied? boolean canAdd = true; for (String prereq : Annotator.DEFAULT_REQUIREMENTS.get(candidate.toLowerCase())) { if (!orderedAnnotators.contains(prereq)) { canAdd = false; break; } } // If so, add the annotator if (canAdd) { orderedAnnotators.add(candidate); iter.remove(); somethingAdded = true; } } // Make sure we're making progress every iteration, to prevent an infinite loop if (!somethingAdded) { throw new IllegalArgumentException(""Unsatisfiable annotator list: "" + StringUtils.join(annotators, "","")); } } // Return return StringUtils.join(orderedAnnotators, "",""); }"	"  public static String ensurePrerequisiteAnnotators(String[] annotators, Properties props) {
    // Get an unordered set of annotators
    Set<String> unorderedAnnotators = new LinkedHashSet<>();  // linked to preserve order
    Collections.addAll(unorderedAnnotators, annotators);
    for (String annotator : annotators) {
      // Add the annotator
      if (!getNamedAnnotators().containsKey(annotator.toLowerCase())) {
        throw new IllegalArgumentException(""Unknown annotator: "" + annotator);
      }

      // Add its transitive dependencies
      unorderedAnnotators.add(annotator.toLowerCase());
      if (!Annotator.DEFAULT_REQUIREMENTS.containsKey(annotator.toLowerCase())) {
        throw new IllegalArgumentException(""Cannot infer requirements for annotator: "" + annotator);
      }
      Queue<String> fringe = new LinkedList<>(Annotator.DEFAULT_REQUIREMENTS.get(annotator.toLowerCase()));
      int ticks = 0;
      while (!fringe.isEmpty()) {
        ticks += 1;
        if (ticks == 1000000) {
          throw new IllegalStateException(""[INTERNAL ERROR] Annotators have a circular dependency."");
        }
        String prereq = fringe.poll();
        unorderedAnnotators.add(prereq);
        fringe.addAll(Annotator.DEFAULT_REQUIREMENTS.get(prereq.toLowerCase()));
      }
    }

    // Order the annotators
    List<String> orderedAnnotators = new ArrayList<>();
    while (!unorderedAnnotators.isEmpty()) {
      boolean somethingAdded = false;  // to make sure the dependencies are satisfiable
      // Loop over candidate annotators to add
      Iterator<String> iter = unorderedAnnotators.iterator();
      while (iter.hasNext()) {
        String candidate = iter.next();
        // Are the requirements satisfied?
        boolean canAdd = true;
        for (String prereq : Annotator.DEFAULT_REQUIREMENTS.get(candidate.toLowerCase())) {
          if (!orderedAnnotators.contains(prereq)) {
            canAdd = false;
            break;
          }
        }
        // If so, add the annotator
        if (canAdd) {
          orderedAnnotators.add(candidate);
          iter.remove();
          somethingAdded = true;
        }
      }
      // Make sure we're making progress every iteration, to prevent an infinite loop
      if (!somethingAdded) {
        throw new IllegalArgumentException(""Unsatisfiable annotator list: "" + StringUtils.join(annotators, "",""));
      }
    }

    // Remove depparse + parse -- these are redundant
    if (orderedAnnotators.contains(STANFORD_PARSE) && !ArrayUtils.contains(annotators, STANFORD_DEPENDENCIES)) {
      orderedAnnotators.remove(STANFORD_DEPENDENCIES);
    }

    // Tweak the properties, if necessary
    // (set the mention annotator to use dependency trees, if appropriate)
    if (orderedAnnotators.contains(Annotator.STANFORD_MENTION) && !orderedAnnotators.contains(Annotator.STANFORD_PARSE) &&
        !props.containsKey(""coref.md.type"")) {
      props.setProperty(""coref.md.type"", ""dep"");
    }
    // (ensure regexner is after ner)
    if (orderedAnnotators.contains(Annotator.STANFORD_NER) && orderedAnnotators.contains(STANFORD_REGEXNER)) {
      orderedAnnotators.remove(STANFORD_REGEXNER);
      int nerIndex = orderedAnnotators.indexOf(Annotator.STANFORD_NER);
      orderedAnnotators.add(nerIndex + 1, STANFORD_REGEXNER);
    }
    // (ensure coref is before openie)
    if (orderedAnnotators.contains(Annotator.STANFORD_COREF) && orderedAnnotators.contains(STANFORD_OPENIE)) {
      int maxIndex = Math.max(
          orderedAnnotators.indexOf(STANFORD_OPENIE),
          orderedAnnotators.indexOf(STANFORD_COREF)
          );
      if (Objects.equals(orderedAnnotators.get(maxIndex), STANFORD_OPENIE)) {
        orderedAnnotators.add(maxIndex, STANFORD_COREF);
        orderedAnnotators.remove(STANFORD_COREF);
      } else {
        orderedAnnotators.add(maxIndex + 1, STANFORD_OPENIE);
        orderedAnnotators.remove(STANFORD_OPENIE);
      }
    }

    // Return
    return StringUtils.join(orderedAnnotators, "","");
  }
"	@param annotators The annotators the user has requested.	@param annotators The annotators the user has requested.	0	1	13	61	417
"public PumpEnactResult setTempBasalAbsolute(Double absoluteRate, Integer durationInMinutes, boolean force) { Double rateAfterConstraints = applyBasalConstraints(absoluteRate); PumpEnactResult result = activePump.setTempBasalAbsolute(rateAfterConstraints, durationInMinutes, force); if (Config.logCongigBuilderActions) log.debug(""setTempBasalAbsolute rate: "" + rateAfterConstraints + "" durationInMinutes: "" + durationInMinutes + "" success: "" + result.success + "" enacted: "" + result.enacted); return result; }"	"    public PumpEnactResult setTempBasalAbsolute(Double absoluteRate, Integer durationInMinutes) {
        Double rateAfterConstraints = applyBasalConstraints(absoluteRate);
        PumpEnactResult result = activePump.setTempBasalAbsolute(rateAfterConstraints, durationInMinutes);
        if (Config.logCongigBuilderActions)
            log.debug(""setTempBasalAbsolute rate: "" + rateAfterConstraints + "" durationInMinutes: "" + durationInMinutes + "" success: "" + result.success + "" enacted: "" + result.enacted);
        return result;
    }
"	@param absoluteRate	@param absoluteRate	0	1	13	8	77
public double distanceTo(double x, double y, double z) { final double a = this.x - x; final double b = this.y - y; final double c = this.z - z; return Math.sqrt(a * a + b * b + c * c); }	"	public float distanceTo(float x, float y, float z) {
		final float a = this.x - x;
		final float b = this.y - y;
		final float c = this.z - z;
		return (float) Math.sqrt(a * a + b * b + c * c);
	}
"	@param double y The point y coordinate.	@param float y The point y coordinate.	1	0	8	8	56
"protected String locationToString(Location loc) { LineID line = locationToLineID(loc); int lineNumber = (line != null) ? (line.lineIdx() + 1) : loc.lineNumber(); return loc.declaringType().name() + ""."" + loc.method().name() + "":"" + lineNumber; }"	"  protected String locationToString(Location l) {
    LineID line = locationToLineID(l);
    int lineNumber;
    if (line != null) {
      lineNumber = line.lineIdx() + 1;
    } else {
      lineNumber = l.lineNumber();
    }
    return l.declaringType().name() + ""."" + l.method().name() + "":"" + lineNumber;
  }
"	@param loc a location	@param l a location	1	0	9	6	64
private boolean isAncestorOf(Object object1, Object object2) { if (object2 == null) return false; Object parent = getParent(object2); if (parent == object1) return true; return isAncestorOf(object1, parent); }	"	private boolean isAncestorOf(Object node, Object target) {
		if (target == null) return false;
		Object parent = getParent(target);
		if (parent == node) return true;
		return isAncestorOf(node, parent);
   }
"	@param object2 The second object to be tested.	@param target The target node.	1	0	6	8	43
"public OuterComposite fakeOuterCompositeSerialize(OuterComposite body) throws ApiException { Object localVarPostBody = body; // create path and map variables String localVarPath = ""/fake/outer/composite""; // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { ""*/*"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<OuterComposite> localVarReturnType = new GenericType<OuterComposite>() {}; return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	"  public OuterComposite fakeOuterCompositeSerialize(OuterComposite outerComposite) throws ApiException {
    Object localVarPostBody = outerComposite;
    
    // create path and map variables
    String localVarPath = ""/fake/outer/composite"";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    final String[] localVarAccepts = {
      ""*/*""
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    GenericType<OuterComposite> localVarReturnType = new GenericType<OuterComposite>() {};
    return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);
      }
"	@param body Input composite as post body (optional)	@param outerComposite Input composite as post body (optional)	1	0	8	31	171
"public ApiResponse<Order> placeOrderWithHttpInfo(Order order) throws ApiException { Object localVarPostBody = order; // verify the required parameter 'order' is set if (order == null) { throw new ApiException(400, ""Missing the required parameter 'order' when calling placeOrder""); } // create path and map variables String localVarPath = ""/store/order""; // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { ""application/xml"", ""application/json"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Order> localVarReturnType = new GenericType<Order>() {}; return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	"  public ApiResponse<Order> placeOrderWithHttpInfo(Order body) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, ""Missing the required parameter 'body' when calling placeOrder"");
    }
    
    // create path and map variables
    String localVarPath = ""/store/order"";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    final String[] localVarAccepts = {
      ""application/xml"", ""application/json""
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    GenericType<Order> localVarReturnType = new GenericType<Order>() {};
    return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);
      }
"	@param order order placed for purchasing the pet (required)	@param body order placed for purchasing the pet (required)	1	0	8	35	203
public boolean onExpandStart(CommonCardView viewCard) { Card card = viewCard.getCard(); if (card!=null){ String itemId = card.getId(); if (!mExpandedIds.contains(itemId)) { return true; } } return false; }	"    public boolean onExpandStart(CardView viewCard) {
        Card card = viewCard.getCard();
        if (card!=null){
            String itemId = card.getId();
            if (!mExpandedIds.contains(itemId)) {
                return true;
            }
        }
        return false;
    }
"	@param viewCard	@param viewCard	0	1	8	11	48
public ServletRegistration.Dynamic addServlet(String name, Servlet servlet) { final ServletHolder holder = new NonblockingServletHolder(checkNotNull(servlet)); holder.setName(name); handler.getServletHandler().addServlet(holder); return holder.getRegistration(); }	"    public ServletBuilder addServlet(Servlet servlet,
                                     String urlPattern) {
        final ServletHolder holder = new NonblockingServletHolder(checkNotNull(servlet));
        final ServletBuilder builder = new ServletBuilder(holder, handler);
        builder.addUrlPattern(checkNotNull(urlPattern));
        return builder;
    }
"	@param servlet the servlet instance	@param urlPattern the URL pattern for requests that should be handled by servlet	1	0	7	8	46
public Builder(DataFetcherResult<T> existing) { data = existing.getData(); localContext = existing.getLocalContext(); errors.addAll(existing.getErrors()); mapRelativeErrors = existing.isMapRelativeErrors(); }	"        public Builder(T data) {
            this.data = data;
        }
"	@param  the type of the result	@param the type of the result	0	1	6	7	36
public float get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }	"    public float get(WithAttributes attributes) {
        return attributes.getAttributes().get(this);
    }
"	@param withAttributes an object containing an AttributeMap	@param attributes an object containing an AttributeMap	1	0	6	5	19
"static OptiqConnection getConnection(SchemaSpec schemaSpec) throws ClassNotFoundException, SQLException { Class.forName(""net.hydromatic.optiq.jdbc.Driver""); Connection connection = DriverManager.getConnection(""jdbc:optiq:""); OptiqConnection optiqConnection = connection.unwrap(OptiqConnection.class); final SchemaPlus rootSchema = optiqConnection.getRootSchema(); switch (schemaSpec) { case JDBC_FOODMART: addSchema(rootSchema, schemaSpec); break; case CLONE_FOODMART: case JDBC_FOODMART_WITH_LATTICE: addSchema(rootSchema, SchemaSpec.JDBC_FOODMART); addSchema(rootSchema, schemaSpec); break; default: throw new AssertionError(""unknown schema "" + schemaSpec); } optiqConnection.setSchema(""foodmart2""); return optiqConnection; }"	"  static OptiqConnection getConnection(boolean withClone)
      throws ClassNotFoundException, SQLException {
    Class.forName(""net.hydromatic.optiq.jdbc.Driver"");
    Connection connection = DriverManager.getConnection(""jdbc:optiq:"");
    OptiqConnection optiqConnection =
        connection.unwrap(OptiqConnection.class);
    final SchemaPlus rootSchema = optiqConnection.getRootSchema();
    addSchema(rootSchema, SchemaSpec.JDBC_FOODMART);
    if (withClone) {
      addSchema(rootSchema, SchemaSpec.CLONE_FOODMART);
    }
    optiqConnection.setSchema(""foodmart2"");
    return optiqConnection;
  }
"	"@param schemaSpec Schema specification; whether to create a ""foodmart2"" schema as in-memory clone"	"@param withClone Whether to create a ""foodmart2"" schema as in-memory clone"	1	0	8	23	121
public static BooleanExpression fuzzyLike(Path<String> path, String value, int maxEdits) { Term term = new Term(path.getMetadata().getName(), value); return new QueryElement(new FuzzyQuery(term, maxEdits)); }	"    public static BooleanExpression fuzzyLike(Path<String> path, String value, float minimumSimilarity) {
        Term term = new Term(path.getMetadata().getName(), value);
        return new QueryElement(new FuzzyQuery(term, minimumSimilarity));
    }
"	@param maxEdits	@param minimumSimilarity	1	0	7	5	46
public boolean searchWithTimeoutFor(Class<? extends TextView> viewClass, String regex, int expectedMinimumNumberOfMatches, boolean scroll, boolean visible) { final long endTime = System.currentTimeMillis() + TIMEOUT; while (System.currentTimeMillis() < endTime) { sleeper.sleep(); final boolean foundAnyMatchingView = searchFor(viewClass, regex, expectedMinimumNumberOfMatches, scroll, visible); if (foundAnyMatchingView){ return true; } } return false; }	"	public boolean searchWithTimeoutFor(Class<? extends TextView> viewClass, String regex, int expectedMinimumNumberOfMatches, boolean scroll) {
		final long endTime = System.currentTimeMillis() + TIMEOUT;

		while (System.currentTimeMillis() < endTime) {
			sleeper.sleep();
			final boolean foundAnyMatchingView = searchFor(viewClass, regex, expectedMinimumNumberOfMatches, scroll);
			if (foundAnyMatchingView){
				return true;
			}
		}

		return false;
	}
"	@param scroll whether scrolling should be performed	@param scroll whether scrolling should be performed	0	1	8	14	77
public int get(long instant) { // 1970-01-01 is day of week 4, Thursday. long daysSince19700101; if (instant >= 0) { daysSince19700101 = instant / DateTimeConstants.MILLIS_PER_DAY; } else { daysSince19700101 = (instant - (DateTimeConstants.MILLIS_PER_DAY - 1)) / DateTimeConstants.MILLIS_PER_DAY; if (daysSince19700101 < -3) { return 7 + (int) ((daysSince19700101 + 4) % 7); } } return 1 + (int) ((daysSince19700101 + 3) % 7); }	"    public int get(long millis) {
        // 1970-01-01 is day of week 4, Thursday.

        long daysSince19700101;
        if (millis >= 0) {
            daysSince19700101 = millis / DateTimeConstants.MILLIS_PER_DAY;
        } else {
            daysSince19700101 = (millis - (DateTimeConstants.MILLIS_PER_DAY - 1))
                / DateTimeConstants.MILLIS_PER_DAY;
            if (daysSince19700101 < -3) {
                return 7 + (int) ((daysSince19700101 + 4) % 7);
            }
        }

        return 1 + (int) ((daysSince19700101 + 3) % 7);
    }
"	@param instant the time instant in millis to query	@param millis the time instant in millis to query	1	0	12	17	97
"public AtmosphereRequest queryString(String qs) { if (qs == null) return this; if (!qs.isEmpty()) { QueryStringDecoder decoder = new QueryStringDecoder(getRequestURI() + ""?"" + qs); Map<String, List<String>> m = decoder.getParameters(); Map<String, String[]> newM = new HashMap<String, String[]>(); for (Map.Entry<String, List<String>> q : m.entrySet()) { newM.put(q.getKey(), q.getValue().toArray(new String[q.getValue().size()])); } b.queryStrings(newM); } b.queryString = qs; return this; }"	"    public AtmosphereRequest queryString(String queryString) {

        if (queryString == null) return this;

        // Don't override the builder
        String qs = queryString;
        if (qs.isEmpty()) {
            qs = b.queryString;
        }
        if (!qs.isEmpty()) {
            QueryStringDecoder decoder = new QueryStringDecoder(getRequestURI() + ""?"" + qs);
            Map<String, List<String>> m = decoder.getParameters();
            Map<String, String[]> newM = new HashMap<String, String[]>();
            for (Map.Entry<String, List<String>> q : m.entrySet()) {
                newM.put(q.getKey(), q.getValue().toArray(new String[q.getValue().size()]));
            }
            b.queryStrings(newM);
            b.queryString = qs;
        }
        return this;
    }
"	@param qs	@param queryString	1	0	13	17	129
public Object buildResultRow(Object[] data, ResultSet resultSet, boolean hasTransformer, SharedSessionContractImplementor session) throws SQLException, HibernateException { final Object[] resultRow = buildResultRow( data, resultSet, session ); if ( hasTransformer ) { return resultRow; } else { return resultRow.length == 1 ? resultRow[0] : resultRow; } }	"	public Object buildResultRow(Object[] data, ResultSet resultSet, boolean hasTransformer, SessionImplementor session)
			throws SQLException, HibernateException {
		final Object[] resultRow = buildResultRow( data, resultSet, session );
		if ( hasTransformer ) {
			return resultRow;
		}
		else {
			return resultRow.length == 1
					? resultRow[0]
					: resultRow;
		}
	}
"	@param hasTransformer Does this query have an associated  org.hibernate.transform.ResultTransformer	@param hasTransformer Does this query have an associated org.hibernate.transform.ResultTransformer	0	1	9	13	62
private String terminalToShowWhenClosing(String handle) { int terminalClosing = terminals_.indexOfTerminal(handle); if (terminalClosing > 0) return terminals_.terminalHandleAtIndex(terminalClosing - 1); else if (terminalClosing + 1 < terminals_.terminalCount()) return terminals_.terminalHandleAtIndex(terminalClosing + 1); else return null; }	"   private int terminalToShowWhenClosing(int terminalClosing)
   {
      if (terminalClosing > 0)
         return terminalClosing - 1;
      else if (terminalClosing + 1 < getTerminalCount())
         return terminalClosing + 1;
      else
         return -1;
   }
"	@param handle terminal being closed	@param terminalClosing index of terminal being closed	1	0	8	11	55
public int read(Object[] row, Instant ts, int rowNumber, int numberOfRows) throws InterruptedException { return converter.read(source, row, rowNumber, numberOfRows, includedColumns, ts, consumer); }	"        public int read(Object[] row, long ts, int rowNumber, int numberOfRows) throws InterruptedException {
            return converter.read(source, row, rowNumber, numberOfRows, includedColumns, ts, consumer);
        }
"	@param row the values of the row, in the same order as the columns in the  Table definition in the  MySqlSchema.	@param row the values of the row, in the same order as the columns in the Table definition in the MySqlSchema.	0	1	5	4	41
public MergedSelectionSet collectFields(FieldCollectorParameters parameters, SelectionSet selectionSet) { Map<String, MergedFields> subFields = new LinkedHashMap<>(); List<String> visitedFragments = new ArrayList<>(); this.collectFields(parameters, selectionSet, visitedFragments, subFields); return newMergedSelectionSet().subFields(subFields).build(); }	"    private void collectFields(FieldCollectorParameters parameters, SelectionSet selectionSet, List<String> visitedFragments, Map<String, MergedFields> fields) {

        for (Selection selection : selectionSet.getSelections()) {
            if (selection instanceof Field) {
                collectField(parameters, fields, (Field) selection);
            } else if (selection instanceof InlineFragment) {
                collectInlineFragment(parameters, visitedFragments, fields, (InlineFragment) selection);
            } else if (selection instanceof FragmentSpread) {
                collectFragmentSpread(parameters, visitedFragments, fields, (FragmentSpread) selection);
            }
        }
    }
"	@param parameters the parameters to this method	@param parameters the parameters to this method	0	1	6	7	54
public Actions sendKeys(CharSequence... keys) { if (isBuildingActions()) { action.addAction(new SendKeysAction(jsonKeyboard, jsonMouse, null, keys)); return this; } for (CharSequence key : keys) { key.codePoints().forEach(codePoint -> { tick(defaultKeyboard.createKeyDown(codePoint)); tick(defaultKeyboard.createKeyUp(codePoint)); }); } return this; }	"  public Actions sendKeys(CharSequence... keysToSend) {
    return this.sendKeys(null, keysToSend);
  }
"	@param keys The keys.	@param keysToSend The keys.	1	0	12	16	78
"public static UserAuthenticator createAuthenticator(final DrillConfig config, ScanResult scan) throws DrillbitStartupException { final String authImplConfigured = config.getString(USER_AUTHENTICATOR_IMPL); if (Strings.isNullOrEmpty(authImplConfigured)) { throw new DrillbitStartupException(String.format(""Invalid value '%s' for BOOT option '%s'"", authImplConfigured, USER_AUTHENTICATOR_IMPL)); } final Collection<Class<? extends UserAuthenticator>> authImpls = scan.getImplementations(UserAuthenticator.class); for(Class<? extends UserAuthenticator> clazz : authImpls) { final UserAuthenticatorTemplate template = clazz.getAnnotation(UserAuthenticatorTemplate.class); if (template == null) { logger.warn(""{} doesn't have {} annotation. Skipping."", clazz.getCanonicalName(), UserAuthenticatorTemplate.class); continue; } if (Strings.isNullOrEmpty(template.type())) { logger.warn(""{} annotation doesn't have valid type field for UserAuthenticator implementation {}. Skipping.."", UserAuthenticatorTemplate.class, clazz.getCanonicalName()); continue; } if (template.type().equalsIgnoreCase(authImplConfigured)) { Constructor<?> validConstructor = null; for (Constructor<?> c : clazz.getConstructors()) { if (c.getParameterTypes().length == 0) { validConstructor = c; break; } } if (validConstructor == null) { logger.warn(""Skipping UserAuthenticator implementation class '{}' since it doesn't "" + ""implement a constructor [{}()]"", clazz.getCanonicalName(), clazz.getName()); continue; } // Instantiate authenticator and initialize it try { final UserAuthenticator authenticator = clazz.newInstance(); authenticator.setup(config); return authenticator; } catch(IllegalArgumentException | IllegalAccessException | InstantiationException e) { throw new DrillbitStartupException( String.format(""Failed to create and initialize the UserAuthenticator class '%s'"", clazz.getCanonicalName()), e); } } } String errMsg = String.format(""Failed to find the implementation of '%s' for type '%s'"", UserAuthenticator.class.getCanonicalName(), authImplConfigured); logger.error(errMsg); throw new DrillbitStartupException(errMsg); }"	"  public static UserAuthenticator createAuthenticator(final DrillConfig config) throws DrillbitStartupException {
    final String authImplConfigured = config.getString(USER_AUTHENTICATOR_IMPL);

    if (Strings.isNullOrEmpty(authImplConfigured)) {
      throw new DrillbitStartupException(String.format(""Invalid value '%s' for BOOT option '%s'"", authImplConfigured,
          USER_AUTHENTICATOR_IMPL));
    }

    final Collection<Class<? extends UserAuthenticator>> authImpls =
        PathScanner.scanForImplementations(UserAuthenticator.class,
            config.getStringList(ExecConstants.USER_AUTHENTICATOR_IMPL_PACKAGES));

    for(Class<? extends UserAuthenticator> clazz : authImpls) {
      final UserAuthenticatorTemplate template = clazz.getAnnotation(UserAuthenticatorTemplate.class);
      if (template == null) {
        logger.warn(""{} doesn't have {} annotation. Skipping."", clazz.getCanonicalName(), UserAuthenticatorTemplate.class);
        continue;
      }

      if (Strings.isNullOrEmpty(template.type())) {
        logger.warn(""{} annotation doesn't have valid type field for UserAuthenticator implementation {}. Skipping.."",
            UserAuthenticatorTemplate.class, clazz.getCanonicalName());
        continue;
      }

      if (template.type().equalsIgnoreCase(authImplConfigured)) {
        Constructor<?> validConstructor = null;
        for (Constructor<?> c : clazz.getConstructors()) {
          if (c.getParameterTypes().length == 0) {
            validConstructor = c;
            break;
          }
        }

        if (validConstructor == null) {
          logger.warn(""Skipping UserAuthenticator implementation class '{}' since it doesn't "" +
              ""implement a constructor [{}()]"", clazz.getCanonicalName(), clazz.getName());
          continue;
        }

        // Instantiate authenticator and initialize it
        try {
          final UserAuthenticator authenticator = clazz.newInstance();
          authenticator.setup(config);
          return authenticator;
        } catch(IllegalArgumentException | IllegalAccessException | InstantiationException e) {
          throw new DrillbitStartupException(
              String.format(""Failed to create and initialize the UserAuthenticator class '%s'"",
                  clazz.getCanonicalName()), e);
        }
      }
    }

    String errMsg = String.format(""Failed to find the implementation of '%s' for type '%s'"",
        UserAuthenticator.class.getCanonicalName(), authImplConfigured);
    logger.error(errMsg);
    throw new DrillbitStartupException(errMsg);
  }
"	@param config DrillConfig containing BOOT options.	@param config DrillConfig containing BOOT options.	0	1	13	58	393
"public OuterComposite fakeOuterCompositeSerialize(OuterComposite body) throws RestClientException { Object postBody = body; String path = UriComponentsBuilder.fromPath(""/fake/outer/composite"").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { ""*/*"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<OuterComposite> returnType = new ParameterizedTypeReference<OuterComposite>() {}; return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }"	"    public OuterComposite fakeOuterCompositeSerialize(OuterComposite outerComposite) throws RestClientException {
        Object postBody = outerComposite;
        
        String path = UriComponentsBuilder.fromPath(""/fake/outer/composite"").build().toUriString();
        
        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();
        final HttpHeaders headerParams = new HttpHeaders();
        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();

        final String[] accepts = { 
            ""*/*""
        };
        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);
        final String[] contentTypes = { };
        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);

        String[] authNames = new String[] {  };

        ParameterizedTypeReference<OuterComposite> returnType = new ParameterizedTypeReference<OuterComposite>() {};
        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);
    }
"	@param body Input composite as post body	@param outerComposite Input composite as post body	1	0	8	22	160
private static String findValidPath(EnvVar... vars) { for (EnvVar var : vars) { String path; if (var.mIsSysProp) { path = checkPath(System.getProperty(var.mName)); if (path != null) { return path; } } if (var.mIsEnvVar) { path = checkPath(System.getenv(var.mName)); if (path != null) { return path; } } } return null; }	"    private static String findValidPath(String... names) {
        for (String name : names) {
            String path;
            if (name.indexOf('.') != -1) {
                path = System.getProperty(name);
            } else {
                path = System.getenv(name);
            }

            if (path != null) {
                File f = new File(path);
                if (f.isDirectory()) {
                    return path;
                }
            }
        }

        return null;
    }
"	@param vars The variables to check. Order does matter.	@param names	1	0	11	22	83
"private Connection createConnection(ActiveMQConnectionRequestInfo connectionRequestInfo) throws JMSException { try { if (connectionRequestInfo.isUseInboundSessionEnabled()) { return new InboundConnectionProxy(); } if (manager == null) { throw new JMSException(""No JCA ConnectionManager configured! Either enable UseInboundSessionEnabled or get your JCA container to configure one.""); } return (Connection)manager.allocateConnection(factory, connectionRequestInfo); } catch (ResourceException e) { // Throw the root cause if it was a JMSException.. if (e.getCause() instanceof JMSException) { throw (JMSException)e.getCause(); } LOG.debug(""Connection could not be created:"", e); throw new JMSException(e.getMessage()); } }"	"    private Connection createConnection(ActiveMQConnectionRequestInfo info) throws JMSException {
        try {
            if (info.isUseInboundSessionEnabled()) {
                return new InboundConnectionProxy();
            }
            if (manager == null) {
                throw new JMSException(""No JCA ConnectionManager configured! Either enable UseInboundSessionEnabled or get your JCA container to configure one."");
            }
            return (Connection)manager.allocateConnection(factory, info);
        } catch (ResourceException e) {
            // Throw the root cause if it was a JMSException..
            if (e.getCause() instanceof JMSException) {
                throw (JMSException)e.getCause();
            }
            LOG.debug(""Connection could not be created:"", e);
            throw new JMSException(e.getMessage());
        }
    }
"	@param connectionRequestInfo	@param info	1	0	9	19	135
"public OuterComposite fakeOuterCompositeSerialize(OuterComposite outerComposite) throws ApiException { Object localVarPostBody = outerComposite; // create path and map variables String localVarPath = ""/fake/outer/composite"".replaceAll(""\\{format\\}"",""json""); // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { ""*/*"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<OuterComposite> localVarReturnType = new GenericType<OuterComposite>() {}; return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	"  public OuterComposite fakeOuterCompositeSerialize(OuterComposite body) throws ApiException {
    Object localVarPostBody = body;
    
    // create path and map variables
    String localVarPath = ""/fake/outer/composite"".replaceAll(""\\{format\\}"",""json"");

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    final String[] localVarAccepts = {
      
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    GenericType<OuterComposite> localVarReturnType = new GenericType<OuterComposite>() {};
    return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);
      }
"	@param outerComposite Input composite as post body (optional)	@param body Input composite as post body (optional)	1	0	8	30	176
"public ArrayList<TextView> clickInRecyclerView(int itemIndex, int recyclerViewIndex, int id, boolean longClick, int time) { View viewOnLine = null; final long endTime = SystemClock.uptimeMillis() + Timeout.getSmallTimeout(); if(itemIndex < 0) itemIndex = 0; ArrayList<View> views = new ArrayList<View>(); ViewGroup recyclerView = viewFetcher.getRecyclerView(recyclerViewIndex, Timeout.getSmallTimeout()); if(recyclerView == null){ Assert.fail(""RecyclerView is not found!""); } else{ failIfIndexHigherThenChildCount(recyclerView, itemIndex, endTime); viewOnLine = getViewOnRecyclerItemIndex((ViewGroup) recyclerView, recyclerViewIndex, itemIndex); } if(viewOnLine != null){ views = viewFetcher.getViews(viewOnLine, true); views = RobotiumUtils.removeInvisibleViews(views); if(id == 0){ clickOnScreen(viewOnLine, longClick, time); } else{ clickOnScreen(getView(id, views)); } } return RobotiumUtils.filterViews(TextView.class, views); }"	"	public ArrayList<TextView> clickInRecyclerView(int itemIndex, int recyclerViewIndex, boolean longClick, int time) {
		View viewOnLine = null;
		final long endTime = SystemClock.uptimeMillis() + Timeout.getSmallTimeout();

		if(itemIndex < 0)
			itemIndex = 0;

		ArrayList<View> views = new ArrayList<View>();
		ViewGroup recyclerView = viewFetcher.getRecyclerView(recyclerViewIndex, Timeout.getSmallTimeout());
		
		if(recyclerView == null){
			Assert.fail(""RecyclerView is not found!"");
		}
		else{
			failIfIndexHigherThenChildCount(recyclerView, itemIndex, endTime);
			viewOnLine = getViewOnRecyclerItemIndex((ViewGroup) recyclerView, recyclerViewIndex, itemIndex);
		}
		
		if(viewOnLine != null){
			views = viewFetcher.getViews(viewOnLine, true);
			views = RobotiumUtils.removeInvisibleViews(views);
			clickOnScreen(viewOnLine, longClick, time);
		}
		return RobotiumUtils.filterViews(TextView.class, views);
	}
"	@param recyclerViewIndex the index of the RecyclerView. E.g. Index 1 if two RecyclerViews are available	@param recyclerViewIndex the index of the RecyclerView. E.g. Index 1 if two RecyclerViews are available	0	1	10	32	176
"public Client call123testSpecialTags(Client body) throws RestClientException { Object postBody = body; // verify the required parameter 'body' is set if (body == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'body' when calling call123testSpecialTags""); } String path = UriComponentsBuilder.fromPath(""/another-fake/dummy"").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { ""application/json"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { ""application/json"" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {}; return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }"	"    public Client call123testSpecialTags(Client client) throws RestClientException {
        Object postBody = client;
        
        // verify the required parameter 'client' is set
        if (client == null) {
            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'client' when calling call123testSpecialTags"");
        }
        
        String path = UriComponentsBuilder.fromPath(""/another-fake/dummy"").build().toUriString();
        
        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();
        final HttpHeaders headerParams = new HttpHeaders();
        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();

        final String[] accepts = { 
            ""application/json""
        };
        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);
        final String[] contentTypes = { 
            ""application/json""
        };
        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);

        String[] authNames = new String[] {  };

        ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {};
        return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);
    }
"	@param body client model	@param client client model	1	0	8	29	204
"public List<TypedDependency> typedDependenciesCCprocessed(boolean includeExtras) { List<TypedDependency> tdl = typedDependencies(false); // Adds stuff to the basic dependencies. // We don't want to simply call typedDependencies with // ""includeExtras"" because the collapseDependencies method may add // the extras in a way that makes more logical sense. For // example, the English dependencies, when CC processed, have more // nsubjs than they originally do. If we wait until that occurs // to add xsubj for xcomp dependencies, we get better coverage. if (includeExtras) { getTreeDeps(root(), tdl, new NoPunctTypedDependencyFilter(puncFilter)); } collapseDependencies(tdl, true, includeExtras); return tdl; }"	"  public List<TypedDependency> typedDependenciesCCprocessed(Extras includeExtras) {
    List<TypedDependency> tdl = typedDependencies(includeExtras);
    collapseDependencies(tdl, true, includeExtras);
    return tdl;
  }
"	"@param includeExtras If true, the list of typed dependencies returned may include ""extras"", such as controlled subject links."	"@param includeExtras If true, the list of typed dependencies returned may include ""extras"", such as controlled subject links."	0	1	8	16	135
"public static Credentials getAssumedCredentials(String accountId, String role, String assumeRole, String externalId) { AssumeRoleRequest assumeRoleRequest = new AssumeRoleRequest() .withRoleArn(""arn:aws:iam::"" + accountId + "":role/"" + role) .withRoleSessionName(assumeRole); if (!StringUtils.isEmpty(externalId)) assumeRoleRequest.setExternalId(externalId); AssumeRoleResult roleResult = securityClient.assumeRole(assumeRoleRequest); return roleResult.getCredentials(); }"	"    public static Credentials getAssumedCredentials(String accountId, String role, String assumeRole) {
        AssumeRoleRequest assumeRoleRequest = new AssumeRoleRequest()
                .withRoleArn(""arn:aws:iam::"" + accountId + "":role/"" + role)
                .withRoleSessionName(assumeRole);
        AssumeRoleResult roleResult = securityClient.assumeRole(assumeRoleRequest);
        return roleResult.getCredentials();
    }
"	@param accountId	@param accountId	0	1	10	10	81
"public void updatePet (Pet pet) throws ApiException { Object localVarPostBody = pet; // verify the required parameter 'pet' is set if (pet == null) { throw new ApiException(400, ""Missing the required parameter 'pet' when calling updatePet""); } // create path and map variables String localVarPath = ""/pet"".replaceAll(""\\{format\\}"",""json""); // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); // header params Map<String, String> localVarHeaderParams = new HashMap<String, String>(); // form params Map<String, String> localVarFormParams = new HashMap<String, String>(); String[] localVarContentTypes = { }; String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : ""application/json""; if (localVarContentType.startsWith(""multipart/form-data"")) { // file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); localVarPostBody = localVarBuilder.build(); } else { // normal form params } try { String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, ""PUT"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType); if(localVarResponse != null){ return ; } else { return ; } } catch (ApiException ex) { throw ex; } }"	"  public void  updatePet (Pet body) throws ApiException {
    Object localVarPostBody = body;
    // verify the required parameter 'body' is set
    if (body == null) {
       throw new ApiException(400, ""Missing the required parameter 'body' when calling updatePet"");
    }

    // create path and map variables
    String localVarPath = ""/pet"".replaceAll(""\\{format\\}"",""json"");

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    // form params
    Map<String, String> localVarFormParams = new HashMap<String, String>();



    String[] localVarContentTypes = {
      ""application/json"",""application/xml""
    };
    String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : ""application/json"";

    if (localVarContentType.startsWith(""multipart/form-data"")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      localVarPostBody = localVarBuilder.build();
    } else {
      // normal form params
          }

    try {
      String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, ""PUT"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType);
      if(localVarResponse != null){
        return ;
      }
      else {
        return ;
      }
    } catch (ApiException ex) {
      throw ex;
    }
  }
"	@param pet Pet object that needs to be added to the store	@param body Pet object that needs to be added to the store	1	0	8	47	247
@Processor public Customer getCustomer(final String resourceUri) { return getClientProvider().getClient(Customer.class).getByResourceUri(resourceUri); }	"    @Processor
    public Customer getCustomer(final String id) {
        return getClientProvider().getClient(Customer.class).getById(id);
    }
"	@param resourceUri of the Customer to get. The resourceUri is the one specified on creation, and not Handshake's uid @sample.xml ../../../doc/mule-module-handshake.xml.sample handshake:get-customer	@param id of the Customer to get. The id is the one specified on creation, and not Handshake's uid @sample.xml ../../../doc/mule-module-handshake.xml.sample handshake:get-customer	1	0	7	6	26
public PendingMessageCursor getSubscriberPendingMessageCursor(String clientId, String name, Store tmpStorage, int maxBatchSize, Subscription sub) { return new VMPendingMessageCursor(); }	"    public PendingMessageCursor getSubscriberPendingMessageCursor(String clientId, String name, Store tmpStorage, int maxBatchSize) {
        return new VMPendingMessageCursor();
    }
"	@param maxBatchSize	@param maxBatchSize	0	1	5	4	27
public Timer getTimer(TimerDesc timerDesc) { return getTimer(timerDesc.getName(), timerDesc.getDurationUnit(), timerDesc.getTimeUnit()); }	"  public Timer getTimer(String name) {
    return getTimer(name, TimeUnit.MILLISECONDS, TimeUnit.SECONDS);
  }
"	@param timerDesc TimerDesc describing the timer	@param name the name of the metric	1	0	5	6	28
public static int getTileHeight(Client client, int localX, int localY, int plane) { int sceneX = localX >> LOCAL_COORD_BITS; int sceneY = localY >> LOCAL_COORD_BITS; if (sceneX >= 0 && sceneY >= 0 && sceneX <= 103 && sceneY <= 103) { byte[][][] tileSettings = client.getTileSettings(); int[][][] tileHeights = client.getTileHeights(); int var5 = plane; if (plane < 3 && (tileSettings[1][sceneX][sceneY] & 2) == 2) { var5 = plane + 1; } int var6 = localX & 127; int var7 = localY & 127; int var8 = var6 * tileHeights[var5][sceneX + 1][sceneY] + (128 - var6) * tileHeights[var5][sceneX][sceneY] >> 7; int var9 = tileHeights[var5][sceneX][sceneY + 1] * (128 - var6) + var6 * tileHeights[var5][sceneX + 1][sceneY + 1] >> 7; return (128 - var7) * var8 + var7 * var9 >> 7; } return 0; }	"	public static int getTileHeight(Client client, int x, int y, int plane)
	{
		int var3 = x >> 7;
		int var4 = y >> 7;
		if (var3 >= 0 && var4 >= 0 && var3 <= 103 && var4 <= 103)
		{
			byte[][][] tileSettings = client.getTileSettings();
			int[][][] tileHeights = client.getTileHeights();

			int var5 = plane;
			if (plane < 3 && (tileSettings[1][var3][var4] & 2) == 2)
			{
				var5 = plane + 1;
			}

			int var6 = x & 127;
			int var7 = y & 127;
			int var8 = var6 * tileHeights[var5][var3 + 1][var4] + (128 - var6) * tileHeights[var5][var3][var4] >> 7;
			int var9 = tileHeights[var5][var3][var4 + 1] * (128 - var6) + var6 * tileHeights[var5][var3 + 1][var4 + 1] >> 7;
			return (128 - var7) * var8 + var7 * var9 >> 7;
		}

		return 0;
	}
"	@param localY the ground coordinate on the y axis	@param y the ground coordinate on the y axis	1	0	13	25	210
"public boolean isASGEnabled(InstanceInfo instanceInfo) { CacheKey cacheKey = new CacheKey(getAccountId(instanceInfo, accountId), instanceInfo.getASGName()); asgCache.refresh(cacheKey); Boolean result = asgCache.getIfPresent(cacheKey); if (result != null) { return result; } else { logger.warn(""Cache value for asg {} does not exist yet"", cacheKey.asgName); return true; } }"	"    public boolean isASGEnabled(String asgName) {
        try {
            return asgCache.get(asgName);
        } catch (ExecutionException e) {
            logger.error(""Error getting cache value for asg : "" + asgName, e);
        }
        return true;
    }
"	@param instanceInfo the instanceInfo for the lookup	@param asgName - The name of the ASG	1	0	7	12	78
public static BufferedImage alphaOffset(final Image rawImg, final float percentage) { BufferedImage image = toARGB(rawImg); final int numComponents = image.getColorModel().getNumComponents(); final float[] scales = new float[numComponents]; final float[] offsets = new float[numComponents]; Arrays.fill(scales, 1f); Arrays.fill(offsets, 0f); scales[numComponents - 1] = percentage; return offset(image, scales, offsets); }	"	public static BufferedImage alphaOffset(final BufferedImage image, final float percentage)
	{
		final int numComponents = image.getColorModel().getNumComponents();
		final float[] scales = new float[numComponents];
		final float[] offsets = new float[numComponents];

		Arrays.fill(scales, 1f);
		Arrays.fill(offsets, 0f);
		scales[numComponents - 1] = percentage;
		return offset(image, scales, offsets);
	}
"	@param rawImg The image to be made more or less transparent.	@param image The image to be made more or less transparent.	1	0	8	13	89
public int delete(Object[] row, Instant ts, int rowNumber, int numberOfRows) throws InterruptedException { return converter.delete(source, row, rowNumber, numberOfRows, includedColumns, ts, consumer); }	"        public int delete(Object[] row, long ts, int rowNumber, int numberOfRows) throws InterruptedException {
            return converter.delete(source, row, rowNumber, numberOfRows, includedColumns, ts, consumer);
        }
"	@param ts the timestamp for this row	@param ts the timestamp for this row	0	1	5	4	41
public boolean searchButton(String text, boolean onlyVisible) { boolean found = searcher.searchWithTimeoutFor(Button.class, text, 0, true, onlyVisible); return found; }	"	public boolean searchButton(String text, boolean visible) {
		boolean found = searcher.searchWithTimeoutFor(Button.class, text, 0, true, visible);
		return found;
	}
"	@param onlyVisible  true if only  Buttons visible on the screen should be searched	@param visible true if only Buttons visible on the screen should be searched	1	0	7	5	32
"public Request buildRequest(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); final String url = buildUrl(path, queryParams, collectionQueryParams); final Request.Builder reqBuilder = new Request.Builder().url(url); processHeaderParams(headerParams, reqBuilder); String contentType = (String) headerParams.get(""Content-Type""); // ensuring a default content type if (contentType == null) { contentType = ""application/json""; } RequestBody reqBody; if (!HttpMethod.permitsRequestBody(method)) { reqBody = null; } else if (""application/x-www-form-urlencoded"".equals(contentType)) { reqBody = buildRequestBodyFormEncoding(formParams); } else if (""multipart/form-data"".equals(contentType)) { reqBody = buildRequestBodyMultipart(formParams); } else if (body == null) { if (""DELETE"".equals(method)) { // allow calling DELETE without sending a request body reqBody = null; } else { // use an empty request body (for POST, PUT and PATCH) reqBody = RequestBody.create(MediaType.parse(contentType), """"); } } else { reqBody = serialize(body, contentType); } // Associate callback with request (if not null) so interceptor can // access it when creating ProgressResponseBody reqBuilder.tag(callback); Request request = null; if (callback != null && reqBody != null) { ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, callback); request = reqBuilder.method(method, progressRequestBody).build(); } else { request = reqBuilder.method(method, reqBody).build(); } return request; }"	"    public Request buildRequest(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        updateParamsForAuth(authNames, queryParams, headerParams);

        final String url = buildUrl(path, queryParams, collectionQueryParams);
        final Request.Builder reqBuilder = new Request.Builder().url(url);
        processHeaderParams(headerParams, reqBuilder);

        String contentType = (String) headerParams.get(""Content-Type"");
        // ensuring a default content type
        if (contentType == null) {
            contentType = ""application/json"";
        }

        RequestBody reqBody;
        if (!HttpMethod.permitsRequestBody(method)) {
            reqBody = null;
        } else if (""application/x-www-form-urlencoded"".equals(contentType)) {
            reqBody = buildRequestBodyFormEncoding(formParams);
        } else if (""multipart/form-data"".equals(contentType)) {
            reqBody = buildRequestBodyMultipart(formParams);
        } else if (body == null) {
            if (""DELETE"".equals(method)) {
                // allow calling DELETE without sending a request body
                reqBody = null;
            } else {
                // use an empty request body (for POST, PUT and PATCH)
                reqBody = RequestBody.create(MediaType.parse(contentType), """");
            }
        } else {
            reqBody = serialize(body, contentType);
        }

        Request request = null;

        if(progressRequestListener != null && reqBody != null) {
            ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, progressRequestListener);
            request = reqBuilder.method(method, progressRequestBody).build();
        } else {
            request = reqBuilder.method(method, reqBody).build();
        }

        return request;
    }
"	@param callback Callback for upload/download progress	@param progressRequestListener Progress request listener	1	0	14	48	350
protected SourceInfo update(Long lsn, Instant commitTime, Long txId, TableId tableId) { this.lsn = lsn; this.useconds = Conversions.toEpochMicros(commitTime); this.txId = txId; if (tableId != null && tableId.schema() != null) { this.schemaName = tableId.schema(); } if (tableId != null && tableId.table() != null) { this.tableName = tableId.table(); } return this; }	"    protected SourceInfo update(Long lsn, Long useconds, Long txId, TableId tableId) {
        this.lsn = lsn;
        this.useconds = useconds;
        this.txId = txId;
        if (tableId != null && tableId.schema() != null) {
            this.schemaName = tableId.schema();
        }
        if (tableId != null && tableId.table() != null) {
            this.tableName = tableId.table();
        }
        return this;
    }
"	@param lsn the position in the server WAL for a particular event; may be null indicating that this information is not available	@param lsn the position in the server WAL for a particular event; may be null indicating that this information is not available	0	1	8	13	83
"public boolean applyAPSRequest(APSResult request, Callback callback) { PumpInterface pump = getActivePump(); request.rate = applyBasalConstraints(request.rate); PumpEnactResult result; if (!pump.isInitialized()) { log.debug(""applyAPSRequest: "" + MainApp.sResources.getString(R.string.pumpNotInitialized)); if (callback != null) { callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpNotInitialized)).enacted(false).success(false)).run(); } return false; } if (pump.isSuspended()) { log.debug(""applyAPSRequest: "" + MainApp.sResources.getString(R.string.pumpsuspended)); if (callback != null) { callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpsuspended)).enacted(false).success(false)).run(); } return false; } if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: "" + request.toString()); if ((request.rate == 0 && request.duration == 0) || Math.abs(request.rate - pump.getBaseBasalRate()) < pump.getPumpDescription().basalStep) { if (isTempBasalInProgress()) { if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: cancelTempBasal()""); getCommandQueue().cancelTempBasal(false, callback); return true; } else { if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: Basal set correctly""); if (callback != null) { callback.result(new PumpEnactResult().absolute(request.rate).duration(0).enacted(false).success(true).comment(""Basal set correctly"")).run(); } return false; } } else if (isTempBasalInProgress() && Math.abs(request.rate - getTempBasalAbsoluteRateHistory()) < pump.getPumpDescription().basalStep) { if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: Temp basal set correctly""); if (callback != null) { callback.result(new PumpEnactResult().absolute(getTempBasalAbsoluteRateHistory()).duration(getTempBasalFromHistory(System.currentTimeMillis()).getPlannedRemainingMinutes()).enacted(false).success(true).comment(""Temp basal set correctly"")).run(); } return false; } else { if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: setTempBasalAbsolute()""); getCommandQueue().tempBasalAbsolute(request.rate, request.duration, false, callback); return true; } }"	"    public PumpEnactResult applyAPSRequest(APSResult request) {
        request.rate = applyBasalConstraints(request.rate);
        PumpEnactResult result;

        if (!isInitialized()) {
            result = new PumpEnactResult();
            result.comment = MainApp.sResources.getString(R.string.pumpNotInitialized);
            result.enacted = false;
            result.success = false;
            log.debug(""applyAPSRequest: "" + MainApp.sResources.getString(R.string.pumpNotInitialized));
            return result;
        }

        if (isSuspended()) {
            result = new PumpEnactResult();
            result.comment = MainApp.sResources.getString(R.string.pumpsuspended);
            result.enacted = false;
            result.success = false;
            log.debug(""applyAPSRequest: "" + MainApp.sResources.getString(R.string.pumpsuspended));
            return result;
        }

        if (Config.logCongigBuilderActions)
            log.debug(""applyAPSRequest: "" + request.toString());
        if ((request.rate == 0 && request.duration == 0) || Math.abs(request.rate - getBaseBasalRate()) < getPumpDescription().basalStep) {
            if (isTempBasalInProgress()) {
                if (Config.logCongigBuilderActions)
                    log.debug(""applyAPSRequest: cancelTempBasal()"");
                result = cancelTempBasal(false);
            } else {
                result = new PumpEnactResult();
                result.absolute = request.rate;
                result.duration = 0;
                result.enacted = false;
                result.comment = ""Basal set correctly"";
                result.success = true;
                if (Config.logCongigBuilderActions)
                    log.debug(""applyAPSRequest: Basal set correctly"");
            }
        } else if (isTempBasalInProgress()
                && getTempBasalRemainingMinutesFromHistory() > 5
                && Math.abs(request.rate - getTempBasalAbsoluteRateHistory()) < getPumpDescription().basalStep) {
            result = new PumpEnactResult();
            result.absolute = getTempBasalAbsoluteRateHistory();
            result.duration = getTempBasalFromHistory(System.currentTimeMillis()).getPlannedRemainingMinutes();
            result.enacted = false;
            result.comment = ""Temp basal set correctly"";
            result.success = true;
            if (Config.logCongigBuilderActions)
                log.debug(""applyAPSRequest: Temp basal set correctly"");
        } else {
            if (Config.logCongigBuilderActions)
                log.debug(""applyAPSRequest: setTempBasalAbsolute()"");
            result = setTempBasalAbsolute(request.rate, request.duration);
        }
        return result;
    }
"	@param request	@param request	0	1	13	52	468
"public int compareTo(ReadablePartial partial) { if (partial == null) { throw new IllegalArgumentException(""The instant must not be null""); } int thisValue = get(); int otherValue = partial.get(getFieldType()); if (thisValue < otherValue) { return -1; } else if (thisValue > otherValue) { return 1; } else { return 0; } }"	"    public int compareTo(ReadablePartial instant) {
        if (instant == null) {
            throw new IllegalArgumentException(""The instant must not be null"");
        }
        int thisValue = get();
        int otherValue = instant.get(getField());
        if (thisValue < otherValue) {
            return -1;
        } else if (thisValue > otherValue) {
            return 1;
        } else {
            return 0;
        }
    }
"	@param partial the partial to compare to	@param instant the instant to compare to	1	0	7	15	74
public static GrammaticalRelation valueOf(String s, Collection<GrammaticalRelation> values) { for (GrammaticalRelation reln : values) { if (reln.toString().equals(s)) return reln; } return null; }	"  public static GrammaticalRelation valueOf(String s, Map<String, GrammaticalRelation> map) {
    if (map.containsKey(s)) {
      return map.get(s);
    }
    return null;
  }
"	@param values The set of GrammaticalRelations to look for it among.	@param map The map from string to GrammaticalRelation	1	0	8	8	40
"public Emitter emit(final String event, final Object... args) { EventThread.exec(new Runnable() { @Override public void run() { if (events.containsKey(event)) { Socket.super.emit(event, args); return; } List<Object> _args = new ArrayList<Object>(args.length + 1); _args.add(event); _args.addAll(Arrays.asList(args)); JSONArray jsonArgs = new JSONArray(_args); int parserType = Parser.EVENT; if (HasBinaryData.hasBinary(jsonArgs)) { parserType = Parser.BINARY_EVENT; } Packet packet = new Packet(parserType, jsonArgs); if (_args.get(_args.size() - 1) instanceof Ack) { logger.fine(String.format(""emitting packet with ack id %d"", Socket.this.ids)); Socket.this.acks.put(Socket.this.ids, (Ack)_args.remove(_args.size() - 1)); packet.id = Socket.this.ids++; } Socket.this.packet(packet); } }); return this; }"	"    public Emitter emit(final String event, final Object... arguments) {
        EventThread.exec(new Runnable() {
            @Override
            public void run() {
                if (events.containsKey(event)) {
                    Socket.super.emit(event, arguments);
                    return;
                }

                List<Object> args = new ArrayList<Object>(arguments.length + 1);
                args.add(event);
                args.addAll(Arrays.asList(arguments));
                JSONArray _args = new JSONArray(args);
                int parserType = Parser.EVENT;
                if (HasBinaryData.hasBinary(_args)) { parserType = Parser.BINARY_EVENT; }
                Packet packet = new Packet(parserType, _args);

                if (args.get(args.size() - 1) instanceof Ack) {
                    logger.fine(String.format(""emitting packet with ack id %d"", Socket.this.ids));
                    Socket.this.acks.put(Socket.this.ids, (Ack)args.remove(args.size() - 1));
                    packet.id = Socket.this.ids++;
                }

                Socket.this.packet(packet);
            }
        });
        return this;
    }
"	@param event an event name.	@param event an event name.	0	1	15	29	202
"public Order getOrderById(String orderId) throws ApiException { Object localVarPostBody = null; // verify the required parameter 'orderId' is set if (orderId == null) { throw new ApiException(400, ""Missing the required parameter 'orderId' when calling getOrderById""); } // create path and map variables String localVarPath = ""/store/order/{orderId}"".replaceAll(""\\{format\\}"",""json"") .replaceAll(""\\{"" + ""orderId"" + ""\\}"", apiClient.escapeString(orderId.toString())); // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { ""application/json"", ""application/xml"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { ""test_api_key_query"", ""test_api_key_header"" }; GenericType<Order> localVarReturnType = new GenericType<Order>() {}; return apiClient.invokeAPI(localVarPath, ""GET"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	"  public Order getOrderById(Long orderId) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'orderId' is set
    if (orderId == null) {
      throw new ApiException(400, ""Missing the required parameter 'orderId' when calling getOrderById"");
    }
    
    // create path and map variables
    String localVarPath = ""/store/order/{orderId}"".replaceAll(""\\{format\\}"",""json"")
      .replaceAll(""\\{"" + ""orderId"" + ""\\}"", apiClient.escapeString(orderId.toString()));

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    final String[] localVarAccepts = {
      ""application/xml"", ""application/json""
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    GenericType<Order> localVarReturnType = new GenericType<Order>() {};
    return apiClient.invokeAPI(localVarPath, ""GET"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);
      }
"	@param orderId ID of pet that needs to be fetched (required)	@param orderId ID of pet that needs to be fetched (required)	0	1	9	41	256
protected int addToolBarElements(JToolBar toolBar, Location location, int gridX) { return gridX; }	"	protected int addToolBarElements(JToolBar panelToolbar2, Location loc, int gridX) {
		// Override to add elements into the toolbar
		return gridX;
	}
"	@param toolBar the tool bar	@param panelToolbar2 the toolbar	1	0	4	4	18
private RexProgram createProgram(Filter filterRel) { RexProgramBuilder programBuilder = new RexProgramBuilder( filterRel.getRowType(), filterRel.getCluster().getRexBuilder()); programBuilder.addIdentity(); programBuilder.addCondition(filterRel.getCondition()); return programBuilder.getProgram(); }	"  private RexProgram createProgram(FilterRel filterRel) {
    RexProgramBuilder programBuilder =
        new RexProgramBuilder(
            filterRel.getRowType(),
            filterRel.getCluster().getRexBuilder());
    programBuilder.addIdentity();
    programBuilder.addCondition(filterRel.getCondition());
    return programBuilder.getProgram();
  }
"	@param filterRel the LogicalFilter	@param filterRel the FilterRel	1	0	7	10	48
protected void coordinateSharedCacheCleanup(SharedSessionContractImplementor session) { final BulkOperationCleanupAction action = new BulkOperationCleanupAction( session, getCustomQuery().getQuerySpaces() ); if ( session.isEventSource() ) { ( (EventSource) session ).getActionQueue().addAction( action ); } else { action.getAfterTransactionCompletionProcess().doAfterTransactionCompletion( true, session ); } }	"	protected void coordinateSharedCacheCleanup(SessionImplementor session) {
		final BulkOperationCleanupAction action = new BulkOperationCleanupAction( session, getCustomQuery().getQuerySpaces() );

		if ( session.isEventSource() ) {
			( (EventSource) session ).getActionQueue().addAction( action );
		}
		else {
			action.getAfterTransactionCompletionProcess().doAfterTransactionCompletion( true, session );
		}
	}
"	@param ps The prepared statement to which to bind the parameter values.	@param ps The prepared statement to which to bind the parameter values.	0	1	8	11	62
"public void createUser (User user) throws TimeoutException, ExecutionException, InterruptedException, ApiException { Object postBody = user; // verify the required parameter 'user' is set if (user == null) { VolleyError error = new VolleyError(""Missing the required parameter 'user' when calling createUser"", new ApiException(400, ""Missing the required parameter 'user' when calling createUser"")); } // create path and map variables String path = ""/user""; // query params List<Pair> queryParams = new ArrayList<Pair>(); // header params Map<String, String> headerParams = new HashMap<String, String>(); // form params Map<String, String> formParams = new HashMap<String, String>(); String[] contentTypes = { ""application/json"" }; String contentType = contentTypes.length > 0 ? contentTypes[0] : ""application/json""; if (contentType.startsWith(""multipart/form-data"")) { // file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); HttpEntity httpEntity = localVarBuilder.build(); postBody = httpEntity; } else { // normal form params } String[] authNames = new String[] { }; try { String localVarResponse = apiInvoker.invokeAPI (basePath, path, ""POST"", queryParams, postBody, headerParams, formParams, contentType, authNames); if (localVarResponse != null) { return ; } else { return ; } } catch (ApiException ex) { throw ex; } catch (InterruptedException ex) { throw ex; } catch (ExecutionException ex) { if (ex.getCause() instanceof VolleyError) { VolleyError volleyError = (VolleyError)ex.getCause(); if (volleyError.networkResponse != null) { throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage()); } } throw ex; } catch (TimeoutException ex) { throw ex; } }"	"  public void createUser (User body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = body;
    // verify the required parameter 'body' is set
    if (body == null) {
      VolleyError error = new VolleyError(""Missing the required parameter 'body' when calling createUser"",
        new ApiException(400, ""Missing the required parameter 'body' when calling createUser""));
    }

    // create path and map variables
    String path = ""/user"";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : ""application/json"";

    if (contentType.startsWith(""multipart/form-data"")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, ""POST"", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return ;
      } else {
         return ;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }
"	@param user Created user object	@param body Created user object	1	0	11	57	351
public TemplateExpressionImpl(Class<? extends T> type, Template template, Object... args){ this(type, template, Arrays.<Object>asList(args)); }	"    public TemplateExpressionImpl(Class<? extends T> type, Template template, Expression<?>... args){
        this(type, template, Arrays.<Expression<?>>asList(args));
    }    
"	@param template	@param template	0	1	7	4	31
"public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws RestClientException { Object postBody = new Object(); // verify the required parameter 'petId' is set if (petId == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'petId' when calling uploadFileWithRequiredFile""); } // verify the required parameter 'requiredFile' is set if (requiredFile == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile""); } // create path and map variables final Map<String, Object> uriVariables = new HashMap<String, Object>(); uriVariables.put(""petId"", petId); String path = UriComponentsBuilder.fromPath(""/fake/{petId}/uploadImageWithRequiredFile"").buildAndExpand(uriVariables).toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); if (additionalMetadata != null) formParams.add(""additionalMetadata"", additionalMetadata); if (requiredFile != null) formParams.add(""requiredFile"", new FileSystemResource(requiredFile)); final String[] accepts = { ""application/json"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { ""multipart/form-data"" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { ""petstore_auth"" }; ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {}; return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }"	"    public ModelApiResponse uploadFileWithRequiredFile(Long petId, File file, String additionalMetadata) throws RestClientException {
        Object postBody = new Object();
        
        // verify the required parameter 'petId' is set
        if (petId == null) {
            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'petId' when calling uploadFileWithRequiredFile"");
        }
        
        // verify the required parameter 'file' is set
        if (file == null) {
            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'file' when calling uploadFileWithRequiredFile"");
        }
        
        // create path and map variables
        final Map<String, Object> uriVariables = new HashMap<String, Object>();
        uriVariables.put(""petId"", petId);
        String path = UriComponentsBuilder.fromPath(""/fake/{petId}/uploadImageWithRequiredFile"").buildAndExpand(uriVariables).toUriString();
        
        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();
        final HttpHeaders headerParams = new HttpHeaders();
        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();
        
        if (additionalMetadata != null)
            formParams.add(""additionalMetadata"", additionalMetadata);
        if (file != null)
            formParams.add(""file"", new FileSystemResource(file));

        final String[] accepts = { 
            ""application/json""
        };
        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);
        final String[] contentTypes = { 
            ""multipart/form-data""
        };
        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);

        String[] authNames = new String[] { ""petstore_auth"" };

        ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {};
        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);
    }
"	@param petId ID of pet to update	@param petId ID of pet to update	0	1	8	42	327
public static List<Integer> getSubListIndex(Object[] tofind, Object[] tokens){ if(tofind.length > tokens.length) return null; List<Integer> allIndices = new ArrayList<Integer>(); boolean matched = false; int index = -1; int lastUnmatchedIndex = 0; for(int i = 0 ; i < tokens.length;){ for(int j = 0; j < tofind.length ;){ if(tofind[j].equals(tokens[i])){ index = i; i++; j++; if(j == tofind.length) { matched = true; break; } }else{ j = 0; i = lastUnmatchedIndex +1; lastUnmatchedIndex = i; index = -1; if(lastUnmatchedIndex == tokens.length) break; } if(i >= tokens.length){ index = -1; break; } } if(i == tokens.length || matched){ if(index >= 0) //index = index - l1.length + 1; allIndices.add(index - tofind.length + 1); matched = false; lastUnmatchedIndex = index; //break; } } //get starting point return allIndices; }	"  public static List<Integer> getSubListIndex(Object[] l1, Object[] l2){
    if(l1.length > l2.length)
      return null;
    List<Integer> allIndices = new ArrayList<Integer>();
    boolean matched = false;
    int index = -1;
    int lastUnmatchedIndex = 0;
    for(int i = 0 ; i < l2.length;){
      for(int j = 0; j < l1.length ;){
        if(l1[j].equals(l2[i])){
          index = i;
          i++;
          j++;
          if(j == l1.length)
          {
            matched = true;
            break;
          }
        }else{
          j = 0;
          i = lastUnmatchedIndex +1;
          lastUnmatchedIndex = i;
          index = -1;
          if(lastUnmatchedIndex == l2.length)
            break;
        }
        if(i >= l2.length){
          index = -1;
          break;
        }
      }
      if(i == l2.length || matched){
        if(index >= 0)
          //index = index - l1.length + 1;
          allIndices.add(index - l1.length + 1);
        matched = false;
        lastUnmatchedIndex = index;

        //break;
      }
    }
    //get starting point

    return allIndices;
  }
"	@param tokens	@param l2	1	0	13	46	211
"protected long copyCollection(CollectionId collectionId, Instant timestamp) throws InterruptedException { AtomicLong docCount = new AtomicLong(); primaryClient.executeBlocking(""sync '"" + collectionId + ""'"", primary -> { docCount.set(copyCollection(primary, collectionId, timestamp)); }); return docCount.get(); }"	"    protected long copyCollection(CollectionId collectionId, long timestamp) throws InterruptedException {
        AtomicLong docCount = new AtomicLong();
        primaryClient.executeBlocking(""sync '"" + collectionId + ""'"", primary -> {
            docCount.set(copyCollection(primary, collectionId, timestamp));
        });
        return docCount.get();
    }
"	@param timestamp the timestamp in milliseconds at which the copy operation was started	@param timestamp the timestamp in milliseconds at which the copy operation was started	0	1	9	8	60
public ScrollableResults scroll(ScrollMode mode, Expression<?> expr) { Query query = createQuery(expr); reset(); return query.scroll(mode); }	"    public ScrollableResults scroll(ScrollMode mode, Expr<?> expr) {
        Query query = createQuery(expr);
        reset();
        return query.scroll(mode);
    }
"	@param expr	@param expr	0	1	6	6	31
public StringBuilder toStringBuilder(StringBuilder sb, Function<Label,String> labelFormatter) { if (isLeaf()) { if (label() != null) { sb.append(labelFormatter.apply(label())); } return sb; } else { sb.append('('); if (label() != null) { sb.append(labelFormatter.apply(label())); } Tree[] kids = children(); if (kids != null) { for (Tree kid : kids) { sb.append(' '); kid.toStringBuilder(sb, labelFormatter); } } return sb.append(')'); } }	"  public StringBuilder toStringBuilder(StringBuilder sb, boolean printOnlyLabelValue) {
    if (isLeaf()) {
      if (label() != null) {
        if(printOnlyLabelValue) {
          sb.append(label().value());
        } else {
          sb.append(label());
        }
      }
      return sb;
    } else {
      sb.append('(');
      if (label() != null) {
        if (printOnlyLabelValue) {
          if (value() != null) {
            sb.append(label().value());
          }
          // don't print a null, just nothing!
        } else {
          sb.append(valueAndSentimentString());
        }
      }
      Tree[] kids = children();
      if (kids != null) {
        for (Tree kid : kids) {
          sb.append(' ');
          kid.toStringBuilder(sb, printOnlyLabelValue);
        }
      }
      return sb.append(')');
    }
  }
"	@param labelFormatter Formatting routine for how to print a Label	@param printOnlyLabelValue If true, print only the value() of each node's label	1	0	11	22	130
public static String quoteIdentifierInSqlExpr(TableDesc tableDesc, String sqlExpr, SqlDialect sqlDialect) { String table = tableDesc.getName(); boolean tableMatched = false; List<String> tabPatterns = getTableNameOrAliasPatterns(table); if (isIdentifierNeedToQuote(sqlExpr, table, tabPatterns)) { sqlExpr = quoteIdentifier(sqlExpr, table, tabPatterns, sqlDialect); tableMatched = true; } if (tableMatched) { for (ColumnDesc columnDesc : tableDesc.getColumns()) { String column = columnDesc.getName(); List<String> colPatterns = getColumnNameOrAliasPatterns(column); if (isIdentifierNeedToQuote(sqlExpr, column, colPatterns)) { sqlExpr = quoteIdentifier(sqlExpr, column, colPatterns, sqlDialect); } } } return sqlExpr; }	"    public static String quoteIdentifierInSqlExpr(TableDesc tableDesc, String sqlExpr) {
        String table = tableDesc.getName();
        boolean tableMatched = false;
        List<String> tabPatterns = getTableNameOrAliasPatterns(table);
        if (isIdentifierNeedToQuote(sqlExpr, table, tabPatterns)) {
            sqlExpr = quoteIdentifier(sqlExpr, table, tabPatterns);
            tableMatched = true;
        }

        if (tableMatched) {
            for (ColumnDesc columnDesc : tableDesc.getColumns()) {
                String column = columnDesc.getName();
                List<String> colPatterns = getColumnNameOrAliasPatterns(column);
                if (isIdentifierNeedToQuote(sqlExpr, column, colPatterns)) {
                    sqlExpr = quoteIdentifier(sqlExpr, column, colPatterns);
                }
            }
        }

        return sqlExpr;
    }
"	@param tableDesc	@param tableDesc	0	1	12	22	124
"public RepositoryMetadata lookupComponent(Class<?> repositoryClass) { if (repositoriesMetadata.containsKey(repositoryClass)) { return repositoriesMetadata.get(repositoryClass); } throw new RuntimeException(""Unknown Repository class "" + repositoryClass.getName()); }"	"    public RepositoryMetadata lookupComponent(Class<?> repoClass)
    {
        if (repositoriesMetadata.containsKey(repoClass))
        {
            return repositoriesMetadata.get(repoClass);
        }
        throw new RuntimeException(""Unknown Repository class "" + repoClass.getName());
    }
"	@param repositoryClass The repository class to lookup the method for	@param repoClass The Repository class to lookup the method for	1	0	7	10	43
public static StringTemplate stringTemplate(String template, ImmutableList<?> args) { return new StringTemplate(createTemplate(template), args); }	"    public static StringExpression stringTemplate(Template template, Object... args) {
        return new StringTemplate(template, ImmutableList.copyOf(args));
    }
"	@param template	@param template	0	1	6	4	26
public Location writeCommand(DataStructure command, boolean syncHint) throws IOException { return asyncDataManager.write(wireFormat.marshal(command), (syncHint && syncOnWrite)); }	"    public Location writeCommand(DataStructure command, boolean sync) throws IOException {
        return asyncDataManager.write(wireFormat.marshal(command), sync);
    }
"	@param syncHint	@param sync	1	0	6	4	32
protected SourceInfo update(Long lsn, Instant commitTime, Long txId, TableId tableId) { this.lsn = lsn; this.useconds = Conversions.toEpochMicros(commitTime); this.txId = txId; if (tableId != null && tableId.schema() != null) { this.schemaName = tableId.schema(); } if (tableId != null && tableId.table() != null) { this.tableName = tableId.table(); } return this; }	"    protected SourceInfo update(Long lsn, Long useconds, Long txId, TableId tableId) {
        this.lsn = lsn;
        this.useconds = useconds;
        this.txId = txId;
        if (tableId != null && tableId.schema() != null) {
            this.schemaName = tableId.schema();
        }
        if (tableId != null && tableId.table() != null) {
            this.tableName = tableId.table();
        }
        return this;
    }
"	@param tableId the table that should be included in the source info; may be null	@param tableId the table that should be included in the source info; may be null	0	1	8	13	83
public Task<Boolean> contains(final CacheKey key) { if (containsSync(key)) { return Task.forResult(true); } return containsAsync(key); }	"  public Task<Boolean> contains(final List<CacheKey> keys) {
    if (keys.isEmpty()) {
      return Task.forResult(false);
    }
    if (containsSync(keys)) {
      return Task.forResult(true);
    }
    Task<Boolean> masterTask = containsAsync(keys.get(0));
    if (keys.size() == 1) {
      return masterTask;
    }
    for (final CacheKey key : keys.subList(1, keys.size())) {
      masterTask = masterTask.continueWithTask(
          new Continuation<Boolean, Task<Boolean>>() {
            @Override
            public Task<Boolean> then(Task<Boolean> previousTask) throws Exception {
              if (previousTask.isCancelled() || previousTask.getResult()) {
                return previousTask;
              }
              return containsAsync(key);
            }
          },
          mReadExecutor);
    }
    return masterTask;
  }
"	@param key	@param keys	1	0	7	7	33
"public Builder field(UnaryOperator<GraphQLFieldDefinition.Builder> builderFunction) { assertNotNull(builderFunction, ""builderFunction can't be null""); GraphQLFieldDefinition.Builder builder = GraphQLFieldDefinition.newFieldDefinition(); builder = builderFunction.apply(builder); return field(builder); }"	"        public Builder field(BuilderFunction<GraphQLFieldDefinition.Builder> builderFunction) {
            assertNotNull(builderFunction, ""builderFunction can't be null"");
            GraphQLFieldDefinition.Builder builder = GraphQLFieldDefinition.newFieldDefinition();
            builder = builderFunction.apply(builder);
            return field(builder);
        }
"	@param builderFunction a supplier for the builder impl	@param builderFunction a supplier for the builder impl	0	1	7	7	46
"public DrillBuf retain(BufferAllocator target) { if (isEmpty) { return this; } if (BaseAllocator.DEBUG) { historicalLog.recordEvent(""retain(%s)"", target.getName()); } final BufferLedger otherLedger = this.ledger.getLedgerForAllocator(target); return otherLedger.newDrillBuf(offset, length, null); }"	"  public DrillBuf retain(BufferAllocator allocator) {

    if (isEmpty) {
      return this;
    }

    if (BaseAllocator.DEBUG) {
      historicalLog.recordEvent(""retain(%s)"", allocator.getName());
    }
    BufferLedger otherLedger = this.ledger.getLedgerForAllocator(allocator);
    return otherLedger.newDrillBuf(offset, length, null, true);
  }
"	@param target The target allocator to create an association with.	@param allocator The target allocator to create an association with.	1	0	7	13	63
public List<WebElement> apply(WebDriver driver) { List<WebElement> allChildren = findElement(parent, driver).findElements(childLocator); return allChildren.isEmpty() ? null : allChildren; }	"      public List<WebElement> apply(WebDriver webDriver) {
        List<WebElement> elements = null;
        try {
          elements = webDriver.findElement(locator).findElements(sub_locator);
        } catch (Exception e) {/**/}
        if (elements != null && elements.size() > 0) {
          return elements;
        }
        return null;
      }
"	"@param parent used to check parent element. For example table with locator By.xpath(""//table"")"	"@param locator used to check parent element. For example table with locator By.xpath(""//table"")"	1	0	7	6	34
public List<String> generateCreationCommands(Metadata metadata, boolean createNamespaces, Dialect dialect) { final ArrayList<String> commands = new ArrayList<String>(); doCreation( metadata, createNamespaces, dialect, new Target() { @Override public boolean acceptsImportScriptActions() { return true; } @Override public void prepare() { } @Override public void accept(String action) { commands.add( action ); } @Override public void release() { } } ); return commands; }	"	public List<String> generateCreationCommands(Metadata metadata, boolean createSchemas, Dialect dialect) {
		final ArrayList<String> commands = new ArrayList<String>();
		doCreation(
				metadata,
				createSchemas,
				dialect,
				new Target() {

					@Override
					public boolean acceptsImportScriptActions() {
						return true;
					}

					@Override
					public void prepare() {
					}

					@Override
					public void accept(String action) {
						commands.add( action );
					}

					@Override
					public void release() {
					}
				}
		);
		return commands;
	}
"	@param metadata The metadata for which to generate the creation commands.	@param metadata The metadata for which to generate the creation commands.	0	1	9	30	92
public boolean searchText(String text, int minimumNumberOfMatches, boolean scroll, boolean onlyVisible) { return searcher.searchWithTimeoutFor(TextView.class, text, minimumNumberOfMatches, scroll, onlyVisible); }	"	public boolean searchText(String text, int minimumNumberOfMatches, boolean scroll, boolean visible) {
		return searcher.searchWithTimeoutFor(TextView.class, text, minimumNumberOfMatches, scroll, visible);
	}
"	@param onlyVisible  true if only texts visible on the screen should be searched	@param visible true if only texts visible on the screen should be searched	1	0	6	4	34
public static RequestQueue newRequestQueue(IRestParser iRestParser, int threadPoolSize) { RequestQueue requestQueue = new RequestQueue(iRestParser, threadPoolSize); requestQueue.start(); return requestQueue; }	"    public static RequestQueue newRequestQueue(IRestParser implRestParser, int threadPoolSize) {
        RequestQueue requestQueue = new RequestQueue(implRestParser, threadPoolSize);
        requestQueue.start();
        return requestQueue;
    }
"	@param iRestParser the response parser, The result of parsing the network layer.	@param implRestParser the response parser, The result of parsing the network layer.	1	0	6	6	31
protected BroadcastAction filter(HttpServletRequest request, HttpServletResponse response, Object object) { BroadcastAction transformed = new BroadcastAction(object); for (PerRequestBroadcastFilter mf : perRequestFilters) { transformed = mf.filter(request, response, transformed.message()); if (transformed == null || transformed.action() == BroadcastAction.ACTION.ABORT) { return transformed; } } return transformed; }	"    protected BroadcastAction filter(HttpServletRequest request, Object object) {
        BroadcastAction transformed = new BroadcastAction(object);
        for (PerRequestBroadcastFilter mf : perRequestFilters) {
            transformed = mf.filter(request, transformed.message());
            if (transformed == null || transformed.action() == BroadcastAction.ACTION.ABORT) {
                return transformed;
            }
        }
        return transformed;
    }
"	@param request  javax.servlet.http.HttpServletRequest	@param request javax.servlet.http.HttpServletRequest	0	1	8	11	68
private static EntityKey getOptionalObjectKey(QueryParameters queryParameters, SharedSessionContractImplementor session) { final Object optionalObject = queryParameters.getOptionalObject(); final Serializable optionalId = queryParameters.getOptionalId(); final String optionalEntityName = queryParameters.getOptionalEntityName(); if ( optionalObject != null && optionalEntityName != null ) { return session.generateEntityKey( optionalId, session.getEntityPersister( optionalEntityName, optionalObject ) ); } else { return null; } }	"	private static EntityKey getOptionalObjectKey(QueryParameters queryParameters, SessionImplementor session) {
		final Object optionalObject = queryParameters.getOptionalObject();
		final Serializable optionalId = queryParameters.getOptionalId();
		final String optionalEntityName = queryParameters.getOptionalEntityName();

		if ( optionalObject != null && optionalEntityName != null ) {
			return session.generateEntityKey(
					optionalId, session.getEntityPersister(
							optionalEntityName,
							optionalObject
					)
			);
		}
		else {
			return null;
		}

	}
"	@param returnProxies Should proxies be generated	@param returnProxies Should proxies be generated	0	1	8	19	71
public int update(Object[] before, Object[] after, Instant ts) throws InterruptedException { return update(before, after, ts, 0, 1); }	"        public int update(Object[] before, Object[] after, long ts) throws InterruptedException {
            return update(before, after, ts, 0, 1);
        }
"	@param ts the timestamp for this row	@param ts the timestamp for this row	0	1	5	4	35
"public int recordEvent(Document oplogEvent, Document masterEvent, Instant timestamp, long txOrder) throws InterruptedException { source.opLogEvent(replicaSetName, oplogEvent, masterEvent, txOrder); final Struct sourceValue = source.struct(); final Map<String, ?> offset = source.lastOffset(replicaSetName); Document patchObj = oplogEvent.get(""o"", Document.class); // Updates have an 'o2' field, since the updated object in 'o' might not have the ObjectID ... Object o2 = oplogEvent.get(""o2""); String objId = o2 != null ? idObjToJson(o2) : idObjToJson(patchObj); assert objId != null; Operation operation = OPERATION_LITERALS.get(oplogEvent.getString(""op"")); return createRecords(sourceValue, offset, operation, objId, patchObj, timestamp); }"	"        public int recordEvent(Document oplogEvent, Document masterEvent, long timestamp, long txOrder) throws InterruptedException {
            source.opLogEvent(replicaSetName, oplogEvent, masterEvent, txOrder);
            final Struct sourceValue = source.struct();
            final Map<String, ?> offset = source.lastOffset(replicaSetName);
            Document patchObj = oplogEvent.get(""o"", Document.class);
            // Updates have an 'o2' field, since the updated object in 'o' might not have the ObjectID ...
            Object o2 = oplogEvent.get(""o2"");
            String objId = o2 != null ? idObjToJson(o2) : idObjToJson(patchObj);
            assert objId != null;
            Operation operation = OPERATION_LITERALS.get(oplogEvent.getString(""op""));
            return createRecords(sourceValue, offset, operation, objId, patchObj, timestamp);
        }
"	@param txOrder order of event in transaction; 0 for non-transactional event	@param txOrder order of event in transaction; 0 for non-transactional event	0	1	7	13	149
"public static DataFileReadResult decompress(byte[] b, int[] keys) { InputStream stream = new InputStream(b); int compression = stream.readUnsignedByte(); int compressedLength = stream.readInt(); if (compressedLength < 0 || compressedLength > 1000000) throw new RuntimeException(""Invalid data""); Crc32 crc32 = new Crc32(); crc32.update(b, 0, 5); // compression + length byte[] data; int revision = -1; switch (compression) { case CompressionType.NONE: { byte[] encryptedData = new byte[compressedLength]; stream.readBytes(encryptedData, 0, compressedLength); crc32.update(encryptedData, 0, compressedLength); byte[] decryptedData = decrypt(encryptedData, encryptedData.length, keys); if (stream.remaining() >= 2) { revision = stream.readUnsignedShort(); assert revision != -1; } data = decryptedData; break; } case CompressionType.BZ2: { byte[] encryptedData = new byte[compressedLength + 4]; stream.readBytes(encryptedData); crc32.update(encryptedData, 0, encryptedData.length); byte[] decryptedData = decrypt(encryptedData, encryptedData.length, keys); if (stream.remaining() >= 2) { revision = stream.readUnsignedShort(); assert revision != -1; } stream = new InputStream(decryptedData); int decompressedLength = stream.readInt(); data = BZip2.decompress(stream.getRemaining(), compressedLength); if (data == null) { return null; } assert data.length == decompressedLength; break; } case CompressionType.GZ: { byte[] encryptedData = new byte[compressedLength + 4]; stream.readBytes(encryptedData); crc32.update(encryptedData, 0, encryptedData.length); byte[] decryptedData = decrypt(encryptedData, encryptedData.length, keys); if (stream.remaining() >= 2) { revision = stream.readUnsignedShort(); assert revision != -1; } stream = new InputStream(decryptedData); int decompressedLength = stream.readInt(); data = GZip.decompress(stream.getRemaining(), compressedLength); if (data == null) { return null; } assert data.length == decompressedLength; break; } default: throw new RuntimeException(""Unknown decompression type""); } DataFileReadResult res = new DataFileReadResult(); res.data = data; res.revision = revision; int length = revision != -1 ? b.length - 2 : b.length;; res.crc = crc32.getHash(); res.whirlpool = Whirlpool.getHash(b, length); res.compression = compression; return res; }"	"	public static DataFileReadResult decompress(byte[] b)
	{
		InputStream stream = new InputStream(b);
		
		int compression = stream.readUnsignedByte();
		int compressedLength = stream.readInt();
		if (compressedLength < 0 || compressedLength > 1000000)
			throw new RuntimeException(""Invalid data"");
		
		byte[] data;
		int revision;
		switch (compression)
		{
			case CompressionType.NONE:
				data = new byte[compressedLength];
				revision = checkRevision(stream, compressedLength);
				stream.readBytes(data, 0, compressedLength);
				break;
			case CompressionType.BZ2:
			{
				int length = stream.readInt();
				revision = checkRevision(stream, compressedLength);
				data = BZip2.decompress(stream.getRemaining(), compressedLength);
				assert data.length == length;
				break;
			}
			case CompressionType.GZ:
			{
				int length = stream.readInt();
				revision = checkRevision(stream, compressedLength);
				data = GZip.decompress(stream.getRemaining(), compressedLength);
				assert data.length == length;
				break;
			}
			default:
				throw new RuntimeException(""Unknown decompression type"");
		}
		
		DataFileReadResult res = new DataFileReadResult();
		res.data = data;
		res.revision = revision;
		int length = revision != -1 ? b.length - 2 : b.length;
		res.crc = CRC32HGenerator.getHash(b, length);
		res.whirlpool = Whirlpool.getHash(b, length);
		res.compression = compression;
		return res;
	}
"	@param size size of file	@param size expected size of file	1	0	10	104	469
public Future<HttpResponse> executeAsync(Executor executor) { FutureTask<HttpResponse> future = new FutureTask<HttpResponse>(new Callable<HttpResponse>() { public HttpResponse call() throws Exception { return execute(); } }); executor.execute(future); return future; }	"  public Future<HttpResponse> executeAsync(Executor exec) {
    final SettableFuture<HttpResponse> future = SettableFuture.create();
    exec.execute(new Runnable() {
      public void run() {
        try {
          future.set(execute());
        } catch (IOException ex) {
          future.setException(ex);
        }
      }
    });
    return future;
  }
"	@param executor executor to run the asynchronous request	@param exec An executor to run the synchronous HttpRequest	1	0	9	12	49
public Single<Void> rxUpdateUser(String username, User user) { return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> { delegate.updateUser(username, user, fut); })); }	"    public Single<Void> rxUpdateUser(String username, User body) {
        return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> {
            delegate.updateUser(username, body, fut);
        }));
    }
"	@param username name that need to be deleted (required)	@param username name that need to be deleted (required)	0	1	10	6	41
public boolean isFlagSet(int flagsToCheck) { return isFlagSet(flags, flagsToCheck); }	"    public boolean isFlagSet(int flag) {
        return (flags & flag) != 0;
    }
"	@param flagsToCheck the flags to check	@param flag the flag to check	1	0	5	5	17
"protected Object convertSetToString(List<String> options, Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return """"; } if (data instanceof String) { // JDBC should return strings ... return data; } if (data instanceof Long) { // The binlog will contain a long with the indexes of the options in the set value ... long indexes = ((Long) data).longValue(); return convertSetValue(indexes, options); } return handleUnknownData(column, fieldDefn, data); }"	"    protected Object convertSetToString(String options, Column column, Field fieldDefn, Object data) {
        if (data == null) {
            data = fieldDefn.schema().defaultValue();
        }
        if (data == null) {
            if (column.isOptional()) return null;
            return """";
        }
        if (data instanceof String) {
            // JDBC should return strings ...
            return data;
        }
        if (data instanceof Long) {
            // The binlog will contain a long with the indexes of the options in the set value ...
            long indexes = ((Long) data).longValue();
            return convertSetValue(indexes, options);
        }
        return handleUnknownData(column, fieldDefn, data);
    }
"	@param options the characters that appear in the same order as defined in the column; may not be null	@param options the characters that appear in the same order as defined in the column; may not be null	0	1	8	20	129
"public ExecutionResult execute(ExecutionInput executionInput) { String requestString = executionInput.getRequestString(); String operationName = executionInput.getOperationName(); Object context = executionInput.getContext(); Object root = executionInput.getRoot(); Map<String, Object> arguments = executionInput.getArguments() != null ? executionInput.getArguments() : Collections.emptyMap(); log.debug(""Executing request. operation name: {}. Request: {} "", operationName, requestString); InstrumentationContext<ExecutionResult> executionCtx = instrumentation.beginExecution(new InstrumentationExecutionParameters(requestString, operationName, context, arguments)); InstrumentationContext<Document> parseCtx = instrumentation.beginParse(new InstrumentationExecutionParameters(requestString, operationName, context, arguments)); Parser parser = new Parser(); Document document; try { document = parser.parseDocument(requestString); parseCtx.onEnd(document); } catch (ParseCancellationException e) { RecognitionException recognitionException = (RecognitionException) e.getCause(); SourceLocation sourceLocation = null; if (recognitionException != null) { sourceLocation = new SourceLocation(recognitionException.getOffendingToken().getLine(), recognitionException.getOffendingToken().getCharPositionInLine()); } InvalidSyntaxError invalidSyntaxError = new InvalidSyntaxError(sourceLocation); return new ExecutionResultImpl(Collections.singletonList(invalidSyntaxError)); } InstrumentationContext<List<ValidationError>> validationCtx = instrumentation.beginValidation(new InstrumentationValidationParameters(requestString, operationName, context, arguments, document)); Validator validator = new Validator(); List<ValidationError> validationErrors = validator.validateDocument(graphQLSchema, document); validationCtx.onEnd(validationErrors); if (validationErrors.size() > 0) { return new ExecutionResultImpl(validationErrors); } ExecutionId executionId = idProvider.provide(requestString, operationName, context); Execution execution = new Execution(queryStrategy, mutationStrategy, subscriptionStrategy, instrumentation); ExecutionResult result = execution.execute(executionId, graphQLSchema, context, root, document, operationName, arguments); executionCtx.onEnd(result); return result; }"	"    public ExecutionResult execute(String requestString) {
        return execute(requestString, null);
    }
"	@param executionInput  ExecutionInput	@param requestString the query/mutation/subscription	1	0	11	48	332
protected int addToolBarElements(JToolBar toolBar, Location location, int gridX) { return gridX; }	"	protected int addToolBarElements(JToolBar panelToolbar2, Location loc, int gridX) {
		// Override to add elements into the toolbar
		return gridX;
	}
"	@param location the current location where elements will be added	@param loc the current location where elements can be added	1	0	4	4	18
"public Order placeOrder(Order order) throws ApiException { Object localVarPostBody = order; // verify the required parameter 'order' is set if (order == null) { throw new ApiException(400, ""Missing the required parameter 'order' when calling placeOrder""); } // create path and map variables String localVarPath = ""/store/order""; // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { ""application/xml"", ""application/json"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Order> localVarReturnType = new GenericType<Order>() {}; return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	"  public Order placeOrder(Order body) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, ""Missing the required parameter 'body' when calling placeOrder"");
    }
    
    // create path and map variables
    String localVarPath = ""/store/order"";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    final String[] localVarAccepts = {
      ""application/xml"", ""application/json""
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    GenericType<Order> localVarReturnType = new GenericType<Order>() {};
    return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);
      }
"	@param order order placed for purchasing the pet (required)	@param body order placed for purchasing the pet (required)	1	0	8	36	213
public FluentWait<T> pollingEvery(Duration interval) { this.interval = interval; return this; }	"  public FluentWait<T> pollingEvery(java.time.Duration interval) {
    this.interval = interval;
    return this;
  }
"	@param interval The timeout duration.	@param interval The timeout duration.	0	1	6	5	17
"public Mono<Order> placeOrder(Order body) throws RestClientException { Object postBody = body; // verify the required parameter 'body' is set if (body == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'body' when calling placeOrder""); } String path = UriComponentsBuilder.fromPath(""/store/order"").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { ""application/xml"", ""application/json"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<Order> returnType = new ParameterizedTypeReference<Order>() {}; return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }"	"    public Mono<Order> placeOrder(Order order) throws RestClientException {
        Object postBody = order;
        
        // verify the required parameter 'order' is set
        if (order == null) {
            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'order' when calling placeOrder"");
        }
        
        String path = UriComponentsBuilder.fromPath(""/store/order"").build().toUriString();
        
        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();
        final HttpHeaders headerParams = new HttpHeaders();
        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();

        final String[] accepts = { 
            ""application/xml"", ""application/json""
        };
        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);
        final String[] contentTypes = { };
        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);

        String[] authNames = new String[] {  };

        ParameterizedTypeReference<Order> returnType = new ParameterizedTypeReference<Order>() {};
        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);
    }
"	@param body order placed for purchasing the pet	@param order order placed for purchasing the pet	1	0	8	27	204
"public Request buildRequest(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); final String url = buildUrl(path, queryParams, collectionQueryParams); final Request.Builder reqBuilder = new Request.Builder().url(url); processHeaderParams(headerParams, reqBuilder); String contentType = (String) headerParams.get(""Content-Type""); // ensuring a default content type if (contentType == null) { contentType = ""application/json""; } RequestBody reqBody; if (!HttpMethod.permitsRequestBody(method)) { reqBody = null; } else if (""application/x-www-form-urlencoded"".equals(contentType)) { reqBody = buildRequestBodyFormEncoding(formParams); } else if (""multipart/form-data"".equals(contentType)) { reqBody = buildRequestBodyMultipart(formParams); } else if (body == null) { if (""DELETE"".equals(method)) { // allow calling DELETE without sending a request body reqBody = null; } else { // use an empty request body (for POST, PUT and PATCH) reqBody = RequestBody.create(MediaType.parse(contentType), """"); } } else { reqBody = serialize(body, contentType); } // Associate callback with request (if not null) so interceptor can // access it when creating ProgressResponseBody reqBuilder.tag(callback); Request request = null; if (callback != null && reqBody != null) { ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, callback); request = reqBuilder.method(method, progressRequestBody).build(); } else { request = reqBuilder.method(method, reqBody).build(); } return request; }"	"    public Request buildRequest(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        updateParamsForAuth(authNames, queryParams, headerParams);

        final String url = buildUrl(path, queryParams, collectionQueryParams);
        final Request.Builder reqBuilder = new Request.Builder().url(url);
        processHeaderParams(headerParams, reqBuilder);

        String contentType = (String) headerParams.get(""Content-Type"");
        // ensuring a default content type
        if (contentType == null) {
            contentType = ""application/json"";
        }

        RequestBody reqBody;
        if (!HttpMethod.permitsRequestBody(method)) {
            reqBody = null;
        } else if (""application/x-www-form-urlencoded"".equals(contentType)) {
            reqBody = buildRequestBodyFormEncoding(formParams);
        } else if (""multipart/form-data"".equals(contentType)) {
            reqBody = buildRequestBodyMultipart(formParams);
        } else if (body == null) {
            if (""DELETE"".equals(method)) {
                // allow calling DELETE without sending a request body
                reqBody = null;
            } else {
                // use an empty request body (for POST, PUT and PATCH)
                reqBody = RequestBody.create(MediaType.parse(contentType), """");
            }
        } else {
            reqBody = serialize(body, contentType);
        }

        Request request = null;

        if(progressRequestListener != null && reqBody != null) {
            ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, progressRequestListener);
            request = reqBuilder.method(method, progressRequestBody).build();
        } else {
            request = reqBuilder.method(method, reqBody).build();
        }

        return request;
    }
"	@param body The request body object	@param body The request body object	0	1	14	48	350
"public Action timedout(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { AtmosphereResourceImpl re; long l = (Long) request.getAttribute(MAX_INACTIVE); if (l == -1) { // The closedDetector closed the connection. return timedoutAction; } request.setAttribute(MAX_INACTIVE, (long) -1); // Something went wrong. if (request == null || response == null) { logger.warn(""Invalid Request/Response: {}/{}"", request, response); return timedoutAction; } re = (AtmosphereResourceImpl) request.getAttribute(AtmosphereServlet.ATMOSPHERE_RESOURCE); if (re != null) { re.getAtmosphereResourceEvent().setIsResumedOnTimeout(true); Broadcaster b = re.getBroadcaster(); if (b instanceof DefaultBroadcaster) { ((DefaultBroadcaster)b).broadcastOnResume(re); } if (re.getRequest().getAttribute(AtmosphereServlet.RESUMED_ON_TIMEOUT) != null) { re.getAtmosphereResourceEvent().setIsResumedOnTimeout( (Boolean) re.getRequest().getAttribute(AtmosphereServlet.RESUMED_ON_TIMEOUT)); } invokeAtmosphereHandler(re); } return timedoutAction; }"	"    public Action timedout(HttpServletRequest req, HttpServletResponse res)
            throws IOException, ServletException {

        AtmosphereResourceImpl re;
        long l = (Long) req.getAttribute(MAX_INACTIVE);
        if (l == -1) {
            // The closedDetector closed the connection.
            return timedoutAction;            
        }
        req.setAttribute(MAX_INACTIVE, (long)-1);

        // Something went wrong.
        if (req == null || res == null) {
            logger.warning(""Invalid Request/Response: "" + req + ""/"" + res);
            return timedoutAction;
        }

        re = (AtmosphereResourceImpl) req.getAttribute(AtmosphereServlet.ATMOSPHERE_RESOURCE);

        if (re != null) {
            re.getAtmosphereResourceEvent().setIsResumedOnTimeout(true);

            Broadcaster b = re.getBroadcaster();
            if (b instanceof DefaultBroadcaster) {
                ((DefaultBroadcaster)b).broadcastOnResume(re);
            }

            if (re.getRequest().getAttribute(AtmosphereServlet.RESUMED_ON_TIMEOUT) != null) {
                re.getAtmosphereResourceEvent().setIsResumedOnTimeout(
                        (Boolean) re.getRequest().getAttribute(AtmosphereServlet.RESUMED_ON_TIMEOUT));
            }
            invokeAtmosphereHandler(re);
        }

        return timedoutAction;
    }
"	@param request the  HttpServletRequest	@param req the HttpServletRequest	1	0	13	37	198
private RexNode convertUsing(SqlValidatorNamespace leftNamespace, SqlValidatorNamespace rightNamespace, List<String> nameList) { final List<RexNode> list = Lists.newArrayList(); for (String name : nameList) { List<RexNode> operands = new ArrayList<>(); int offset = 0; for (SqlValidatorNamespace n : ImmutableList.of(leftNamespace, rightNamespace)) { final RelDataType rowType = n.getRowType(); final RelDataTypeField field = catalogReader.field(rowType, name); operands.add(rexBuilder.makeInputRef(field.getType(), offset + field.getIndex())); offset += rowType.getFieldList().size(); } list.add(rexBuilder.makeCall(SqlStdOperatorTable.EQUALS, operands)); } return RexUtil.composeConjunction(rexBuilder, list, false); }	"    private RexNode convertUsing(RelNode leftRel, RelNode rightRel, List<String> nameList) {
        final List<RexNode> list = Lists.newArrayList();
        for (String name : nameList) {
            final RelDataType leftRowType = leftRel.getRowType();
            RelDataTypeField leftField = catalogReader.field(leftRowType, name);
            RexNode left = rexBuilder.makeInputRef(leftField.getType(), leftField.getIndex());
            final RelDataType rightRowType = rightRel.getRowType();
            RelDataTypeField rightField = catalogReader.field(rightRowType, name);
            RexNode right = rexBuilder.makeInputRef(rightField.getType(), leftRowType.getFieldList().size() + rightField.getIndex());
            RexNode equalsCall = rexBuilder.makeCall(SqlStdOperatorTable.EQUALS, left, right);
            list.add(equalsCall);
        }
        return RexUtil.composeConjunction(rexBuilder, list, false);
    }
"	@param leftNamespace Namespace of left input to join	@param leftRel Left input to the join	1	0	11	16	134
public BufferedImage getImage(int itemId, int quantity, boolean stackable) { try { return itemImages.get(new ImageKey(itemId, quantity, stackable)); } catch (ExecutionException ex) { return null; } }	"	public BufferedImage getImage(int itemId, int quantity)
	{
		try
		{
			return itemImages.get(itemId | (quantity << 16));
		}
		catch (ExecutionException ex)
		{
			return null;
		}
	}
"	@param quantity	@param quantity	0	1	7	12	43
protected String determineSegmentColumnName(Properties params, JdbcEnvironment jdbcEnvironment) { final String name = ConfigurationHelper.getString( SEGMENT_COLUMN_PARAM, params, DEF_SEGMENT_COLUMN ); return jdbcEnvironment.getIdentifierHelper().toIdentifier( name ).render( jdbcEnvironment.getDialect() ); }	"	protected String determineSegmentColumnName(Properties params, Dialect dialect) {
		final ObjectNameNormalizer normalizer = (ObjectNameNormalizer) params.get( IDENTIFIER_NORMALIZER );
		final String name = ConfigurationHelper.getString( SEGMENT_COLUMN_PARAM, params, DEF_SEGMENT_COLUMN );
		return normalizer.toDatabaseIdentifierText( name );
	}
"	@param jdbcEnvironment The JDBC environment	@param dialect The dialect in effect	1	0	6	5	42
"public ApiResponse<Boolean> fakeOuterBooleanSerializeWithHttpInfo(Boolean body) throws ApiException { Object localVarPostBody = body; // create path and map variables String localVarPath = ""/fake/outer/boolean""; // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { ""*/*"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {}; return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	"  public ApiResponse<Boolean> fakeOuterBooleanSerializeWithHttpInfo(Boolean booleanPostBody) throws ApiException {
    Object localVarPostBody = booleanPostBody;
    
    // create path and map variables
    String localVarPath = ""/fake/outer/boolean"";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    final String[] localVarAccepts = {
      ""*/*""
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {};
    return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);
      }
"	@param body Input boolean as post body (optional)	@param booleanPostBody Input boolean as post body (optional)	1	0	8	30	161
public String runHTMLSuite(String browser, String browserURL, String HTMLSuite, File outputFile, int timeoutInSeconds, boolean multiWindow) throws IOException { long timeoutInMs = 1000 * timeoutInSeconds; server.handleHTMLRunnerResults(this); BrowserLauncherFactory blf = new BrowserLauncherFactory(server); String sessionId = Long.toString(System.currentTimeMillis() % 1000000); BrowserLauncher launcher = blf.getBrowserLauncher(browser, sessionId, null); launcher.launchHTMLSuite(HTMLSuite, browserURL, multiWindow); long now = System.currentTimeMillis(); long end = now + timeoutInMs; while (results == null && System.currentTimeMillis() < end) { AsyncExecute.sleepTight(500); } launcher.close(); if (results == null) { throw new SeleniumCommandTimedOutException(); } if (outputFile != null) { FileWriter fw = new FileWriter(outputFile); results.write(fw); fw.close(); } return results.getResult().toUpperCase(); }	"    public String runHTMLSuite(String browser, String browserURL, String HTMLSuite, File outputFile, long timeoutInMs, boolean multiWindow) throws IOException {
        server.handleHTMLRunnerResults(this);
        BrowserLauncherFactory blf = new BrowserLauncherFactory(server);
        String sessionId = Long.toString(System.currentTimeMillis() % 1000000);
        BrowserLauncher launcher = blf.getBrowserLauncher(browser, sessionId, null);
        launcher.launchHTMLSuite(HTMLSuite, browserURL, multiWindow);
        long now = System.currentTimeMillis();
        long end = now + timeoutInMs;
        while (results == null && System.currentTimeMillis() < end) {
            AsyncExecute.sleepTight(500);
        }
        launcher.close();
        if (results == null) {
            throw new SeleniumCommandTimedOutException();
        }
        if (outputFile != null) {
            FileWriter fw = new FileWriter(outputFile);
            results.write(fw);
            fw.close();
        }
        
        return results.getResult().toUpperCase();
    }
"	@param outputFile - The file to which we'll output the HTML results	@param outputFile - The file to which we'll output the HTML results	0	1	8	25	168
public PendingMessageCursor getSubscriberPendingMessageCursor(Broker broker,String name,int maxBatchSize,Subscription subs) { return new VMPendingMessageCursor(AbstractPendingMessageCursor.isPrioritizedMessageSubscriber(broker, subs)); }	"    public PendingMessageCursor getSubscriberPendingMessageCursor(Broker broker,String name,int maxBatchSize) {
        return new VMPendingMessageCursor();
    }
"	@param broker	@param broker	0	1	6	4	31
"protected String[] convert(Path<?> leftHandSide, Object rightHandSide) { String str = rightHandSide.toString(); if (lowerCase){ str = str.toLowerCase(); } if (splitTerms) { if (str.equals("""")) { return new String[] { str }; } else { return StringUtils.split(str); } } else { return new String[] { str }; } }"	"    protected String convert(Path<?> path, Object value){
        return value.toString();
    }
"	@param leftHandSide	@param object	1	0	10	16	82
"private boolean searchForToggleButton(String regex, int matches) { sleeper.sleep(); inst.waitForIdleSync(); Pattern p = Pattern.compile(regex); Matcher matcher; ArrayList<ToggleButton> toggleButtonList = viewFetcher.getCurrentViews(ToggleButton.class); if(matches == 0) matches = 1; for(ToggleButton toggleButton : toggleButtonList){ matcher = p.matcher(toggleButton.getText().toString()); if(matcher.find()){ countMatches++; } if (countMatches == matches) { countMatches=0; return true; } } if (scroller.scroll(Scroller.Direction.DOWN)) { return searchForToggleButton(regex, matches); } else { if(countMatches > 0) Log.d(LOG_TAG, "" There are only "" + countMatches + "" matches of "" + regex); countMatches = 0; return false; } }"	"	private boolean searchForToggleButton(String search, int matches) {
		sleeper.sleep();
		inst.waitForIdleSync();
		Pattern p = Pattern.compile(search);
		Matcher matcher;
		ArrayList<ToggleButton> toggleButtonList = viewFetcher.getCurrentViews(ToggleButton.class);
		if(matches == 0)
			matches = 1;
		for(ToggleButton toggleButton : toggleButtonList){
			matcher = p.matcher(toggleButton.getText().toString());
			if(matcher.find()){	
				countMatches++;
			}
			if (countMatches == matches) {
				countMatches=0;
				return true;
			} 
		}

		if (scroller.scroll(Scroller.Direction.DOWN))
		{
			return searchForToggleButton(search, matches);
		} else {
			if(countMatches > 0)
				Log.d(LOG_TAG, "" There are only "" + countMatches + "" matches of "" + search);
			countMatches = 0;
			return false;
		}
		
	}
"	@param matches the number of matches expected to be found. 0 matches means that one or more matches are expected to be found	@param matches the number of matches expected to be found. 0 matches means that one or more matches are expected to be found	0	1	11	31	154
"private ClientResponse makeRemoteCall(Action action, String serviceUrl) throws Throwable { String urlPath = null; Stopwatch tracer = null; ClientResponse response = null; logger.debug(""Discovery Client talking to the server {}"", serviceUrl); try { // If the application is unknown do not register/renew/cancel but // refresh if ((UNKNOWN.equals(instanceInfo.getAppName()) && (!Action.Refresh.equals(action)) && (!Action.Refresh_Delta .equals(action)))) { return null; } WebResource r = discoveryApacheClient.resource(serviceUrl); String remoteRegionsToFetchStr; switch (action) { case Renew: tracer = RENEW_TIMER.start(); urlPath = ""apps/"" + appPathIdentifier; response = r .path(urlPath) .queryParam(""status"", instanceInfo.getStatus().toString()) .queryParam(""lastDirtyTimestamp"", instanceInfo.getLastDirtyTimestamp().toString()) .put(ClientResponse.class); break; case Refresh: tracer = REFRESH_TIMER.start(); final String vipAddress = clientConfig.getRegistryRefreshSingleVipAddress(); urlPath = vipAddress == null ? ""apps/"" : ""vips/"" + vipAddress; remoteRegionsToFetchStr = remoteRegionsToFetch.get(); if (!Strings.isNullOrEmpty(remoteRegionsToFetchStr)) { urlPath += ""?regions="" + remoteRegionsToFetchStr; } response = getUrl(serviceUrl + urlPath); break; case Refresh_Delta: tracer = REFRESH_DELTA_TIMER.start(); urlPath = ""apps/delta""; remoteRegionsToFetchStr = remoteRegionsToFetch.get(); if (!Strings.isNullOrEmpty(remoteRegionsToFetchStr)) { urlPath += ""?regions="" + remoteRegionsToFetchStr; } response = getUrl(serviceUrl + urlPath); break; case Register: tracer = REGISTER_TIMER.start(); urlPath = ""apps/"" + instanceInfo.getAppName(); response = r.path(urlPath) .type(MediaType.APPLICATION_JSON_TYPE) .post(ClientResponse.class, instanceInfo); break; case Cancel: tracer = CANCEL_TIMER.start(); urlPath = ""apps/"" + appPathIdentifier; response = r.path(urlPath).delete(ClientResponse.class); // Return without during de-registration if it is not registered // already and if we get a 404 if ((!isRegisteredWithDiscovery) && (response.getStatus() == Status.NOT_FOUND .getStatusCode())) { return response; } break; } if (logger.isDebugEnabled()) { logger.debug(""Finished a call to service url {} and url path {} with status code {}."", new String[] {serviceUrl, urlPath, String.valueOf(response.getStatus())}); } if (isOk(action, response.getStatus())) { return response; } else { logger.warn(""Action: "" + action + "" => returned status of "" + response.getStatus() + "" from "" + serviceUrl + urlPath); throw new RuntimeException(""Bad status: "" + response.getStatus()); } } catch (Throwable t) { closeResponse(response); logger.warn(""Can't get a response from "" + serviceUrl + urlPath, t); throw t; } finally { if (tracer != null) { tracer.stop(); } } }"	"    private ClientResponse makeRemoteCall(Action action, int serviceUrlIndex)
            throws Throwable {
        String urlPath = null;
        Stopwatch tracer = null;
        String serviceUrl = eurekaServiceUrls.get().get(serviceUrlIndex);
        ClientResponse response = null;
        logger.debug(""Discovery Client talking to the server {}"", serviceUrl);
        try {
            // If the application is unknown do not register/renew/cancel but
            // refresh
            if ((UNKNOWN.equals(instanceInfo.getAppName())
                    && (!Action.Refresh.equals(action)) && (!Action.Refresh_Delta
                    .equals(action)))) {
                return null;
            }
            WebResource r = discoveryApacheClient.resource(serviceUrl);
            String remoteRegionsToFetchStr;
            switch (action) {
            case Renew:
                tracer = RENEW_TIMER.start();
                urlPath = ""apps/"" + appPathIdentifier;
                response = r
                        .path(urlPath)
                        .queryParam(""status"",
                                instanceInfo.getStatus().toString())
                        .queryParam(""lastDirtyTimestamp"",
                                instanceInfo.getLastDirtyTimestamp().toString())
                        .put(ClientResponse.class);
                break;
            case Refresh:
                tracer = REFRESH_TIMER.start();
                final String vipAddress = clientConfig.getRegistryRefreshSingleVipAddress();
                urlPath = vipAddress == null ? ""apps/"" : ""vips/"" + vipAddress;
                remoteRegionsToFetchStr = remoteRegionsToFetch.get();
                if (!Strings.isNullOrEmpty(remoteRegionsToFetchStr)) {
                    urlPath += ""?regions="" + remoteRegionsToFetchStr;
                }
                response = getUrl(serviceUrl + urlPath);
                break;
            case Refresh_Delta:
                tracer = REFRESH_DELTA_TIMER.start();
                urlPath = ""apps/delta"";
                remoteRegionsToFetchStr = remoteRegionsToFetch.get();
                if (!Strings.isNullOrEmpty(remoteRegionsToFetchStr)) {
                    urlPath += ""?regions="" + remoteRegionsToFetchStr;
                }
                response = getUrl(serviceUrl + urlPath);
                break;
            case Register:
                tracer = REGISTER_TIMER.start();
                urlPath = ""apps/"" + instanceInfo.getAppName();
                response = r.path(urlPath)
                        .type(MediaType.APPLICATION_JSON_TYPE)
                        .post(ClientResponse.class, instanceInfo);
                break;
            case Cancel:
                tracer = CANCEL_TIMER.start();
                urlPath = ""apps/"" + appPathIdentifier;
                response = r.path(urlPath).delete(ClientResponse.class);
                // Return without during de-registration if it is not registered
                // already and if we get a 404
                if ((!isRegisteredWithDiscovery)
                        && (response.getStatus() == Status.NOT_FOUND
                                .getStatusCode())) {
                    return response;
                }
                break;
            }

            if (logger.isDebugEnabled()) {
                logger.debug(""Finished a call to service url {} and url path {} with status code {}."",
                            new String[] {serviceUrl, urlPath, String.valueOf(response.getStatus())});
            }
            if (isOk(action, response.getStatus())) {
                return response;
            } else {
                logger.warn(""Action: "" + action + ""  => returned status of ""
                        + response.getStatus() + "" from "" + serviceUrl
                        + urlPath);
                throw new RuntimeException(""Bad status: ""
                        + response.getStatus());
            }
        } catch (Throwable t) {
            closeResponse(response);
            String msg = ""Can't get a response from "" + serviceUrl + urlPath;
            if (eurekaServiceUrls.get().size() > (++serviceUrlIndex)) {
                logger.warn(msg, t);
                logger.warn(""Trying backup: ""
                        + eurekaServiceUrls.get().get(serviceUrlIndex));
                SERVER_RETRY_COUNTER.increment();
                return makeRemoteCall(action, serviceUrlIndex);
            } else {
                ALL_SERVER_FAILURE_COUNT.increment();
                logger.error(
                        msg
                                + ""\nCan't contact any eureka nodes - possibly a security group issue?"",
                        t);
                throw t;
            }
        } finally {
            if (tracer != null) {
                tracer.stop();
            }
        }
    }
"	@param action the action to be performed on eureka server.	@param action the action to be performed on eureka server. Try the fallback servers in case of problems communicating to the primary one.	1	0	14	91	590
public Actions clickAndHold(WebElement target) { if (isBuildingActions()) { action.addAction(new ClickAndHoldAction(jsonMouse, (Locatable) target)); return this; } return moveToElement(target).clickAndHold(); }	"  public Actions clickAndHold(WebElement onElement) {
    action.addAction(new ClickAndHoldAction(mouse, (Locatable) onElement));
    return this;
  }
"	@param target Element to move to and click.	@param onElement Element to move to and click.	1	0	9	8	44
"public static IType createType(IASTDeclarator declarator) { IASTDeclSpecifier declSpec = null; IASTNode node = declarator.getParent(); while( node instanceof IASTDeclarator ){ declarator = (IASTDeclarator) node; node = node.getParent(); } if( node instanceof IASTParameterDeclaration ) declSpec = ((IASTParameterDeclaration) node).getDeclSpecifier(); else if( node instanceof IASTSimpleDeclaration ) declSpec = ((IASTSimpleDeclaration)node).getDeclSpecifier(); else if( node instanceof IASTFunctionDefinition ) declSpec = ((IASTFunctionDefinition)node).getDeclSpecifier(); else if( node instanceof IASTTypeId ) declSpec = ((IASTTypeId)node).getDeclSpecifier(); boolean isParameter = ( node instanceof IASTParameterDeclaration || node.getParent() instanceof ICASTKnRFunctionDeclarator ); IType type = null; //C99 6.7.5.3-12 The storage class specifier for a parameter declaration is ignored unless the declared parameter is one of the //members of the parameter type list for a function definition. if( isParameter && node.getParent().getParent() instanceof IASTFunctionDefinition ){ type = createBaseType( declSpec ); } else { type = createType( declSpec ); } type = createType( type, declarator ); if( isParameter ) { //C99: 6.7.5.3-7 a declaration of a parameter as ""array of type"" shall be adjusted to ""qualified pointer to type"", where the //type qualifiers (if any) are those specified within the [ and ] of the array type derivation if( type instanceof IArrayType ){ CArrayType at = (CArrayType) type; type = new CQualifiedPointerType( at.getType(), at.getModifier() ); } else if( type instanceof IFunctionType ) { //-8 A declaration of a parameter as ""function returning type"" shall be adjusted to ""pointer to function returning type"" type = new CPointerType( type ); } } return type; }"	"	public static IType createType(IASTName name) {
		if (!(name.getParent() instanceof IASTDeclarator)) return null;
		
	    IASTDeclSpecifier declSpec = null;
		IASTDeclarator declarator = (IASTDeclarator) name.getParent();
		
		IASTNode node = declarator.getParent();
		while( node instanceof IASTDeclarator ){
			declarator = (IASTDeclarator) node;
			node = node.getParent();
		}
		
		if( node instanceof IASTParameterDeclaration )
			declSpec = ((IASTParameterDeclaration) node).getDeclSpecifier();
		else if( node instanceof IASTSimpleDeclaration )
			declSpec = ((IASTSimpleDeclaration)node).getDeclSpecifier();
		else if( node instanceof IASTFunctionDefinition )
			declSpec = ((IASTFunctionDefinition)node).getDeclSpecifier();
		else if( node instanceof IASTTypeId )
		    declSpec = ((IASTTypeId)node).getDeclSpecifier();
	
		boolean isParameter = ( node instanceof IASTParameterDeclaration || node.getParent() instanceof ICASTKnRFunctionDeclarator ); 
		
		IType type = null;
		
		//C99 6.7.5.3-12 The storage class specifier for a parameter declaration is ignored unless the declared parameter is one of the 
		//members of the parameter type list for a function definition.
		if( isParameter && node.getParent().getParent() instanceof IASTFunctionDefinition ){
		    type = createBaseType( declSpec );
		} else {
		    type = createType( declSpec );
		}
		
		type = createType( type, declarator );
		
		
        if( isParameter ) {
            //C99: 6.7.5.3-7 a declaration of a parameter as ""array of type"" shall be adjusted to ""qualified pointer to type"", where the
    		//type qualifiers (if any) are those specified within the [ and ] of the array type derivation
            if( type instanceof IArrayType ){
	            CArrayType at = (CArrayType) type;
	            type = new CQualifiedPointerType( at.getType(), at.getModifier() );
	        } else if( type instanceof IFunctionType ) {
	            //-8 A declaration of a parameter as ""function returning type"" shall be adjusted to ""pointer to function returning type""
	            type = new CPointerType( type );
	        }
        }
        
		return type;
	}
"	@param declarator the IASTDeclarator whose IType will be created	@param name the IASTName whose IType will be created	1	0	11	49	347
"public String invokeAPI(String path, String method, Set<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); b.append(""?""); if (queryParams != null){ for (Pair queryParam : queryParams){ if (!queryParam.getName().isEmpty()) { b.append(escapeString(queryParam.getName())); b.append(""=""); b.append(escapeString(queryParam.getValue())); b.append(""&""); } } } String querystring = b.substring(0, b.length() - 1); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(""GET"".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (""POST"".equals(method)) { if (contentType.startsWith(""application/x-www-form-urlencoded"")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (""PUT"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (""DELETE"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, ""unknown method type "" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return """"; } } else { String message = ""error""; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { // e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }"	"  public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {
    updateParamsForAuth(authNames, queryParams, headerParams);

    Client client = getClient();

    StringBuilder b = new StringBuilder();
    for(String key : queryParams.keySet()) {
      String value = queryParams.get(key);
      if (value != null){
        if(b.toString().length() == 0)
          b.append(""?"");
        else
          b.append(""&"");
        b.append(escapeString(key)).append(""="").append(escapeString(value));
      }
    }
    String querystring = b.toString();

    Builder builder;
    if (accept == null)
      builder = client.resource(basePath + path + querystring).getRequestBuilder();
    else
      builder = client.resource(basePath + path + querystring).accept(accept);

    for(String key : headerParams.keySet()) {
      builder = builder.header(key, headerParams.get(key));
    }
    for(String key : defaultHeaderMap.keySet()) {
      if(!headerParams.containsKey(key)) {
        builder = builder.header(key, defaultHeaderMap.get(key));
      }
    }

    ClientResponse response = null;

    if(""GET"".equals(method)) {
      response = (ClientResponse) builder.get(ClientResponse.class);
    }
    else if (""POST"".equals(method)) {
      if (contentType.startsWith(""application/x-www-form-urlencoded"")) {
        String encodedFormParams = this
            .getXWWWFormUrlencodedParams(formParams);
        response = builder.type(contentType).post(ClientResponse.class,
            encodedFormParams);
      } else if (body == null) {
        response = builder.post(ClientResponse.class, null);
      } else if(body instanceof FormDataMultiPart) {
        response = builder.type(contentType).post(ClientResponse.class, body);
      }
      else
        response = builder.type(contentType).post(ClientResponse.class, serialize(body));
    }
    else if (""PUT"".equals(method)) {
      if (""application/x-www-form-urlencoded"".equals(contentType)) {
          String encodedFormParams = this
              .getXWWWFormUrlencodedParams(formParams);
          response = builder.type(contentType).put(ClientResponse.class,
              encodedFormParams);
      } else if(body == null) {
        response = builder.put(ClientResponse.class, serialize(body));
      } else {
          response = builder.type(contentType).put(ClientResponse.class, serialize(body));
      }
    }
    else if (""DELETE"".equals(method)) {
      if (""application/x-www-form-urlencoded"".equals(contentType)) {
        String encodedFormParams = this
            .getXWWWFormUrlencodedParams(formParams);
        response = builder.type(contentType).delete(ClientResponse.class,
            encodedFormParams);
      } else if(body == null) {
        response = builder.delete(ClientResponse.class);
      } else {
        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));
      }
    }
    else {
      throw new ApiException(500, ""unknown method type "" + method);
    }

    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {
      return null;
    }
    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {
      if(response.hasEntity()) {
        return (String) response.getEntity(String.class);
      }
      else {
        return """";
      }
    }
    else {
      String message = ""error"";
      String respBody = null;
      if(response.hasEntity()) {
        try{
          respBody = String.valueOf(response.getEntity(String.class));
          message = respBody;
        }
        catch (RuntimeException e) {
          // e.printStackTrace();
        }
      }
      throw new ApiException(
                response.getClientResponseStatus().getStatusCode(),
                message,
                response.getHeaders(),
                respBody);
    }
  }
"	@param headerParams The header parameters	@param headerParams The header parameters	0	1	16	113	736
@Override public int onReceiveLiquid(int type,int vol, byte side) { if(type == this.type) { int rejectedVolume = Math.max((this.getStoredLiquid(type) + vol) - this.capacity, 0); this.liquidStored = vol - rejectedVolume; return rejectedVolume; } return vol; }	"	@Override
	public int onReceiveLiquid(int type,int amt, byte side)
	{
		if(type == this.type)
		{
		int rejectedLiquid = Math.max((this.getStoredLiquid(type) + amt) - this.capacity, 0);
		 this.liquidStored += watt - rejectedElectricity;
		return rejectedLiquid;
		}
		return watt;
	}
"	@param vols - The amount of vol this block recieved	@param watts - The amount of watt this block recieved	1	0	12	13	58
private static SemanticGraph fromProto(CoreNLPProtos.DependencyGraph proto, List<CoreLabel> sentence, String docid) { SemanticGraph graph = new SemanticGraph(); // first construct the actual nodes; keep them indexed by their index // This block is optimized as one of the places which take noticeable time // in datum caching int min = Integer.MAX_VALUE; int max = Integer.MIN_VALUE; for(CoreNLPProtos.DependencyGraph.Node in: proto.getNodeList()){ min = in.getIndex() < min ? in.getIndex() : min; max = in.getIndex() > max ? in.getIndex() : max; } IndexedWord[] nodes = new IndexedWord[max - min >= 0 ? max - min + 1 : 0]; for(CoreNLPProtos.DependencyGraph.Node in: proto.getNodeList()){ CoreLabel token = sentence.get(in.getIndex() - 1); // index starts at 1! IndexedWord word = new IndexedWord(docid, in.getSentenceIndex(), in.getIndex(), token); word.set(ValueAnnotation.class, word.get(TextAnnotation.class)); if(in.hasCopyAnnotation()){ word.set(CopyAnnotation.class, in.getCopyAnnotation()); } assert in.getIndex() == word.index(); nodes[in.getIndex() - min] = word; } for (IndexedWord node : nodes) { if (node != null) { graph.addVertex(node); } } // add all edges to the actual graph for(CoreNLPProtos.DependencyGraph.Edge ie: proto.getEdgeList()){ IndexedWord source = nodes[ie.getSource() - min]; assert(source != null); IndexedWord target = nodes[ie.getTarget() - min]; assert(target != null); synchronized (globalLock) { // this is not thread-safe: there are static fields in GrammaticalRelation assert ie.hasDep(); GrammaticalRelation rel = GrammaticalRelation.valueOf(ie.getDep()); graph.addEdge(source, target, rel, 1.0, ie.hasIsExtra() && ie.getIsExtra()); } } if (proto.getRootCount() > 0) { Collection<IndexedWord> roots = new ArrayList<IndexedWord>(); for(int rootI : proto.getRootList()){ roots.add(nodes[rootI - min]); } graph.setRoots(roots); } else { // Roots were not saved away // compute root nodes if non-empty if(!graph.isEmpty()){ graph.resetRoots(); } } return graph; }	"  private static SemanticGraph fromProto(CoreMapProtos.DependencyGraph proto, List<CoreLabel> sentence, String docid) {
    SemanticGraph graph = new SemanticGraph();

    // first construct the actual nodes; keep them indexed by their index
    // This block is optimized as one of the places which take noticeable time
    // in datum caching
    int min = Integer.MAX_VALUE;
    int max = Integer.MIN_VALUE;
    for(CoreMapProtos.DependencyGraph.Node in: proto.getNodeList()){
      min = in.getIndex() < min ? in.getIndex() : min;
      max = in.getIndex() > max ? in.getIndex() : max;
    }
    IndexedWord[] nodes = new IndexedWord[max - min >= 0 ? max - min + 1 : 0];
    for(CoreMapProtos.DependencyGraph.Node in: proto.getNodeList()){
      CoreLabel token = sentence.get(in.getIndex() - 1); // index starts at 1!
      IndexedWord word = new IndexedWord(docid, in.getSentenceIndex(), in.getIndex(), token);
      word.set(ValueAnnotation.class, word.get(TextAnnotation.class));
      if(in.hasCopyAnnotation()){ word.set(CopyAnnotation.class, in.getCopyAnnotation()); }
      assert in.getIndex() == word.index();
      nodes[in.getIndex() - min] = word;
    }
    for (IndexedWord node : nodes) {
      if (node != null) { graph.addVertex(node); }
    }

    // add all edges to the actual graph
    for(CoreMapProtos.DependencyGraph.Edge ie: proto.getEdgeList()){
      IndexedWord source = nodes[ie.getSource() - min];
      assert(source != null);
      IndexedWord target = nodes[ie.getTarget() - min];
      assert(target != null);
      synchronized (globalLock) {
        // this is not thread-safe: there are static fields in GrammaticalRelation
        assert ie.hasDep();
        GrammaticalRelation rel = GrammaticalRelation.valueOf(ie.getDep());
        graph.addEdge(source, target, rel, 1.0, ie.hasIsExtra() && ie.getIsExtra());
      }
    }

    if (proto.getRootCount() > 0) {
      Collection<IndexedWord> roots = new ArrayList<IndexedWord>();
      for(int rootI : proto.getRootList()){
        roots.add(nodes[rootI]);
      }
      graph.setRoots(roots);
    } else {
      // Roots were not saved away
      // compute root nodes if non-empty
      if(!graph.isEmpty()){
        graph.resetRoots();
      }
    }
    return graph;
  }
"	@param docid A docid must be supplied, as it is not saved by the serialized representation.	@param docid A docid must be supplied, as it is not saved by the serialized representation.	0	1	12	55	473
public Histogram getHistogram(SchemaPath column) { // Stats might not have materialized because of errors. if (!materialized) { return null; } return histogram.get(column); }	"  public Histogram getHistogram(String col) {
    // Stats might not have materialized because of errors.
    if (!materialized) {
      return null;
    }
    final String upperCol = col.toUpperCase();
    Histogram histogramCol = histogram.get(upperCol);
    if (histogramCol == null) {
      histogramCol = histogram.get(SchemaPath.getSimplePath(upperCol).toString());
    }
    return histogramCol;
  }
"	@param column path to the column whose histogram should be obtained	@param col	1	0	6	8	36
public Pair(String item1, String item2) { super(); this.item1 = item1; this.item2 = item2; }	"        public Pair(String item_1, String item_2) {
            super();
            this.item_1 = item_1;
            this.item_2 = item_2;
        }
"	@param apps the applications for which to compare this one.	@param apps the applications for which to compare this one.	0	1	6	6	23
"public String toDefaultValue(Schema p) { if (ModelUtils.isDateSchema(p)) { // TODO } else if (ModelUtils.isDateTimeSchema(p)) { // TODO } else if (ModelUtils.isNumberSchema(p)) { if (p.getDefault() != null) { return ""@"" + p.getDefault().toString(); } } else if (ModelUtils.isIntegerSchema(p)) { if (p.getDefault() != null) { return ""@"" + p.getDefault().toString(); } } else if (ModelUtils.isStringSchema(p)) { if (p.getDefault() != null) { return ""@\"""" + (String) p.getDefault() + ""\""""; } } else if (ModelUtils.isBooleanSchema(p)) { if (p.getDefault() != null) { if (p.getDefault().toString().equalsIgnoreCase(""false"")) return ""@(NO)""; else return ""@(YES)""; } } return null; }"	"    public String toDefaultValue(Property p) {
        if (p instanceof StringProperty) {
            StringProperty dp = (StringProperty) p;
            if (dp.getDefault() != null) {
                return ""@\"""" + dp.getDefault() + ""\"""";
            }
        } else if (p instanceof BooleanProperty) {
            BooleanProperty dp = (BooleanProperty) p;
            if (dp.getDefault() != null) {
                if (dp.getDefault().toString().equalsIgnoreCase(""false""))
                    return ""@(NO)"";
                else
                    return ""@(YES)"";
            }
        } else if (p instanceof DateProperty) {
            // TODO
        } else if (p instanceof DateTimeProperty) {
            // TODO
        } else if (p instanceof DoubleProperty) {
            DoubleProperty dp = (DoubleProperty) p;
            if (dp.getDefault() != null) {
                return ""@"" + dp.getDefault().toString();
            }
        } else if (p instanceof FloatProperty) {
            FloatProperty dp = (FloatProperty) p;
            if (dp.getDefault() != null) {
                return ""@"" + dp.getDefault().toString();
            }
        } else if (p instanceof IntegerProperty) {
            IntegerProperty dp = (IntegerProperty) p;
            if (dp.getDefault() != null) {
                return ""@"" + dp.getDefault().toString();
            }
        } else if (p instanceof LongProperty) {
            LongProperty dp = (LongProperty) p;
            if (dp.getDefault() != null) {
                return ""@"" + dp.getDefault().toString();
            }
        }

        return null;
    }
"	@param p Swagger schema object	@param p Swagger property object	1	0	15	29	206
"public long set(long instant, int year) { Utils.verifyValueBounds(this, Math.abs(year), iChronology.getMinYear(), iChronology.getMaxYear()); // // Do nothing if no real change is requested. // int thisWeekyear = get( instant ); if ( thisWeekyear == year ) { return instant; } // // Calculate the DayOfWeek (to be preserved). // int thisDow = iChronology.dayOfWeek().get( instant ); // // Calculate the maximum weeks in the target year. // int weeksInFromYear = iChronology.getWeeksInYear( thisWeekyear ); int weeksInToYear = iChronology.getWeeksInYear( year ); int maxOutWeeks = (weeksInToYear < weeksInFromYear) ? weeksInToYear : weeksInFromYear; // // Get the current week of the year. This will be preserved in // the output unless it is greater than the maximum possible // for the target weekyear. In that case it is adjusted // to the maximum possible. // int setToWeek = iChronology.weekOfWeekyear().get( instant ); if ( setToWeek > maxOutWeeks ) { setToWeek = maxOutWeeks; } // // Get a wroking copy of the current date-time. // This can be a convenience for debugging. // long workInstant = instant; // Get a copy // // Attempt to get close to the proper weekyear. // Note - we cannot currently call ourself, so we just call // set for the year. This at least gets us close. // workInstant = iChronology.year().set( workInstant, year ); // // Calculate the weekyear number for the get close to value // (which might not be equal to the year just set). // int workWoyYear = iChronology.weekyear().get( workInstant ); // // At most we are off by one year, which can be ""fixed"" by // adding/subtracting a week. // if ( workWoyYear < year ) { workInstant += DateTimeConstants.MILLIS_PER_WEEK; } else if ( workWoyYear > year ) { workInstant -= DateTimeConstants.MILLIS_PER_WEEK; } // // Set the proper week in the current weekyear. // // BEGIN: possible set WeekOfWeekyear logic. int currentWoyWeek = iChronology.weekOfWeekyear().get( workInstant ); // No range check required (we already know it is OK). workInstant = workInstant + (setToWeek - currentWoyWeek) * (long)DateTimeConstants.MILLIS_PER_WEEK; // END: possible set WeekOfWeekyear logic. // // Reset DayOfWeek to previous value. // workInstant = iChronology.dayOfWeek().set( workInstant, thisDow ); // // Return result. // return workInstant; }"	"    public long set(long millis, int year) {
        super.verifyValueBounds(Math.abs(year),
                                iChronology.getMinYear(), iChronology.getMaxYear());
        //
        // Do nothing if no real change is requested.
        //
        int thisWeekyear = get( millis );
        if ( thisWeekyear == year ) {
            return millis;
        }
        //
        // Calculate the DayOfWeek (to be preserved).
        //
        int thisDow = iChronology.dayOfWeek().get( millis );
        //
        // Calculate the maximum weeks in the target year.
        //
        int weeksInFromYear = iChronology.getWeeksInYear( thisWeekyear );
        int weeksInToYear = iChronology.getWeeksInYear( year );
        int maxOutWeeks = (weeksInToYear < weeksInFromYear) ?
            weeksInToYear : weeksInFromYear;
        //
        // Get the current week of the year. This will be preserved in
        // the output unless it is greater than the maximum possible
        // for the target weekyear.  In that case it is adjusted
        // to the maximum possible.
        //
        int setToWeek = iChronology.weekOfWeekyear().get( millis );
        if ( setToWeek > maxOutWeeks ) {
            setToWeek = maxOutWeeks;
        }
        //
        // Get a wroking copy of the current date-time.
        // This can be a convenience for debugging.
        //
        long workMillis = millis; // Get a copy
        //
        // Attempt to get close to the proper weekyear.
        // Note - we cannot currently call ourself, so we just call
        // set for the year.  This at least gets us close.
        //
        workMillis = iChronology.year().set( workMillis, year );
        //
        // Calculate the weekyear number for the get close to value
        // (which might not be equal to the year just set).
        //
        int workWoyYear = iChronology.weekyear().get( workMillis );

        // *TEMP Debugging
        /*
        MutableDateTime temp = new MutableDateTime(workMillis,
            ISOChronology.getInstance());
        System.out.println(""Current mdt value 01: ""
            + temp
            + "" "" + workWoyYear
        );
        System.out.println(""->Temp: "" + temp.toString()
            + "" WOYYr="" + temp.getWeekyear()
            + "" WOYWk="" + temp.getWeekOfWeekyear()
            + "" DoW="" + temp.getDayOfWeek()
        );
        */

        //
        // At most we are off by one year, which can be ""fixed"" by
        // adding/subtracting a week.
        //
        if ( workWoyYear < year ) {
            // System.out.println(""Year: Adding ""+workWoyYear+"" ""+year);
            workMillis += DateTimeConstants.MILLIS_PER_WEEK;
        } else if ( workWoyYear > year ) {
            // System.out.println(""Year: Subing ""+workWoyYear+"" ""+year);
            workMillis -= DateTimeConstants.MILLIS_PER_WEEK;
        }
        //
        // Set the proper week in the current weekyear.
        //

        // BEGIN: possible set WeekOfWeekyear logic.
        int currentWoyWeek = iChronology.weekOfWeekyear().get( workMillis );
        // No range check required (we already know it is OK).
        workMillis = workMillis + (setToWeek - currentWoyWeek)
            * (long)DateTimeConstants.MILLIS_PER_WEEK;
        // END: possible set WeekOfWeekyear logic.

        //
        // Reset DayOfWeek to previous value.
        //
        workMillis = iChronology.dayOfWeek().set( workMillis, thisDow );
        //
        // Return result.
        //
        return workMillis;
    }
"	@param instant the time instant in millis to update.	@param millis the time instant in millis to update.	1	0	8	78	485
public DurationType getDurationType(Object object, boolean precise) { if (precise) { return DurationType.getPreciseAllType(); } return DurationType.getAllType(); }	"    public DurationType getDurationType(Object object, boolean totalMillisMaster) {
        if (totalMillisMaster) {
            return DurationType.getPreciseAllType();
        }
        return DurationType.getAllType();
    }
"	@param precise true if a precise type is required	@param totalMillisMaster true if total millis based duration	1	0	6	7	30
public Client testClientModel(Client body) throws ApiException { return testClientModelWithHttpInfo(body).getData(); }	"  public Client testClientModel(Client client) throws ApiException {
    return testClientModelWithHttpInfo(client).getData();
      }
"	@param body client model (required)	@param client client model (required)	1	0	5	4	20
"public String invokeAPI(String path, String method, Set<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); b.append(""?""); if (queryParams != null){ for (Pair queryParam : queryParams){ if (!queryParam.getName().isEmpty()) { b.append(escapeString(queryParam.getName())); b.append(""=""); b.append(escapeString(queryParam.getValue())); b.append(""&""); } } } String querystring = b.substring(0, b.length() - 1); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(""GET"".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (""POST"".equals(method)) { if (contentType.startsWith(""application/x-www-form-urlencoded"")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (""PUT"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (""DELETE"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, ""unknown method type "" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return """"; } } else { String message = ""error""; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { // e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }"	"  public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {
    updateParamsForAuth(authNames, queryParams, headerParams);

    Client client = getClient();

    StringBuilder b = new StringBuilder();
    for(String key : queryParams.keySet()) {
      String value = queryParams.get(key);
      if (value != null){
        if(b.toString().length() == 0)
          b.append(""?"");
        else
          b.append(""&"");
        b.append(escapeString(key)).append(""="").append(escapeString(value));
      }
    }
    String querystring = b.toString();

    Builder builder;
    if (accept == null)
      builder = client.resource(basePath + path + querystring).getRequestBuilder();
    else
      builder = client.resource(basePath + path + querystring).accept(accept);

    for(String key : headerParams.keySet()) {
      builder = builder.header(key, headerParams.get(key));
    }
    for(String key : defaultHeaderMap.keySet()) {
      if(!headerParams.containsKey(key)) {
        builder = builder.header(key, defaultHeaderMap.get(key));
      }
    }

    ClientResponse response = null;

    if(""GET"".equals(method)) {
      response = (ClientResponse) builder.get(ClientResponse.class);
    }
    else if (""POST"".equals(method)) {
      if (contentType.startsWith(""application/x-www-form-urlencoded"")) {
        String encodedFormParams = this
            .getXWWWFormUrlencodedParams(formParams);
        response = builder.type(contentType).post(ClientResponse.class,
            encodedFormParams);
      } else if (body == null) {
        response = builder.post(ClientResponse.class, null);
      } else if(body instanceof FormDataMultiPart) {
        response = builder.type(contentType).post(ClientResponse.class, body);
      }
      else
        response = builder.type(contentType).post(ClientResponse.class, serialize(body));
    }
    else if (""PUT"".equals(method)) {
      if (""application/x-www-form-urlencoded"".equals(contentType)) {
          String encodedFormParams = this
              .getXWWWFormUrlencodedParams(formParams);
          response = builder.type(contentType).put(ClientResponse.class,
              encodedFormParams);
      } else if(body == null) {
        response = builder.put(ClientResponse.class, serialize(body));
      } else {
          response = builder.type(contentType).put(ClientResponse.class, serialize(body));
      }
    }
    else if (""DELETE"".equals(method)) {
      if (""application/x-www-form-urlencoded"".equals(contentType)) {
        String encodedFormParams = this
            .getXWWWFormUrlencodedParams(formParams);
        response = builder.type(contentType).delete(ClientResponse.class,
            encodedFormParams);
      } else if(body == null) {
        response = builder.delete(ClientResponse.class);
      } else {
        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));
      }
    }
    else {
      throw new ApiException(500, ""unknown method type "" + method);
    }

    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {
      return null;
    }
    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {
      if(response.hasEntity()) {
        return (String) response.getEntity(String.class);
      }
      else {
        return """";
      }
    }
    else {
      String message = ""error"";
      String respBody = null;
      if(response.hasEntity()) {
        try{
          respBody = String.valueOf(response.getEntity(String.class));
          message = respBody;
        }
        catch (RuntimeException e) {
          // e.printStackTrace();
        }
      }
      throw new ApiException(
                response.getClientResponseStatus().getStatusCode(),
                message,
                response.getHeaders(),
                respBody);
    }
  }
"	@param body The request body object	@param body The request body object	0	1	16	113	736
public long addWrapped(long instant, int years) { return add(instant, years); }	"    public long addWrapped(long millis, int years) {
        return add(millis, years);
    }
"	@param instant the time instant in millis to update.	@param millis the time instant in millis to update.	1	0	5	4	20
"public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); for(String key : queryParams.keySet()) { String value = queryParams.get(key); if (value != null){ if(b.toString().length() == 0) b.append(""?""); else b.append(""&""); b.append(escapeString(key)).append(""="").append(escapeString(value)); } } String querystring = b.toString(); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(""GET"".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (""POST"".equals(method)) { if (contentType.startsWith(""application/x-www-form-urlencoded"")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (""PUT"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (""DELETE"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, ""unknown method type "" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return """"; } } else { String message = ""error""; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { // e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }"	"  public String invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {
    updateParamsForAuth(authNames, queryParams, headerParams);

    Client client = getClient();

    StringBuilder b = new StringBuilder();
    b.append(""?"");
    if (queryParams != null){
      for (Pair queryParam : queryParams){
        if (!queryParam.getName().isEmpty()) {
          b.append(escapeString(queryParam.getName()));
          b.append(""="");
          b.append(escapeString(queryParam.getValue()));
          b.append(""&"");
        }
      }
    }

    String querystring = b.substring(0, b.length() - 1);

    Builder builder;
    if (accept == null)
      builder = client.resource(basePath + path + querystring).getRequestBuilder();
    else
      builder = client.resource(basePath + path + querystring).accept(accept);

    for(String key : headerParams.keySet()) {
      builder = builder.header(key, headerParams.get(key));
    }
    for(String key : defaultHeaderMap.keySet()) {
      if(!headerParams.containsKey(key)) {
        builder = builder.header(key, defaultHeaderMap.get(key));
      }
    }

    ClientResponse response = null;

    if(""GET"".equals(method)) {
      response = (ClientResponse) builder.get(ClientResponse.class);
    }
    else if (""POST"".equals(method)) {
      if (contentType.startsWith(""application/x-www-form-urlencoded"")) {
        String encodedFormParams = this
            .getXWWWFormUrlencodedParams(formParams);
        response = builder.type(contentType).post(ClientResponse.class,
            encodedFormParams);
      } else if (body == null) {
        response = builder.post(ClientResponse.class, null);
      } else if(body instanceof FormDataMultiPart) {
        response = builder.type(contentType).post(ClientResponse.class, body);
      }
      else
        response = builder.type(contentType).post(ClientResponse.class, serialize(body));
    }
    else if (""PUT"".equals(method)) {
      if (""application/x-www-form-urlencoded"".equals(contentType)) {
          String encodedFormParams = this
              .getXWWWFormUrlencodedParams(formParams);
          response = builder.type(contentType).put(ClientResponse.class,
              encodedFormParams);
      } else if(body == null) {
        response = builder.put(ClientResponse.class, serialize(body));
      } else {
          response = builder.type(contentType).put(ClientResponse.class, serialize(body));
      }
    }
    else if (""DELETE"".equals(method)) {
      if (""application/x-www-form-urlencoded"".equals(contentType)) {
        String encodedFormParams = this
            .getXWWWFormUrlencodedParams(formParams);
        response = builder.type(contentType).delete(ClientResponse.class,
            encodedFormParams);
      } else if(body == null) {
        response = builder.delete(ClientResponse.class);
      } else {
        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));
      }
    }
    else {
      throw new ApiException(500, ""unknown method type "" + method);
    }

    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {
      return null;
    }
    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {
      if(response.hasEntity()) {
        return (String) response.getEntity(String.class);
      }
      else {
        return """";
      }
    }
    else {
      String message = ""error"";
      String respBody = null;
      if(response.hasEntity()) {
        try{
          respBody = String.valueOf(response.getEntity(String.class));
          message = respBody;
        }
        catch (RuntimeException e) {
          // e.printStackTrace();
        }
      }
      throw new ApiException(
                response.getClientResponseStatus().getStatusCode(),
                message,
                response.getHeaders(),
                respBody);
    }
  }
"	@param authNames The authentications to apply	@param authNames The authentications to apply	0	1	16	111	730
public ServletBuilder addServlet(Servlet servlet, String urlPattern) { final ServletHolder holder = new NonblockingServletHolder(checkNotNull(servlet)); final ServletBuilder builder = new ServletBuilder(holder, handler); builder.addUrlPattern(checkNotNull(urlPattern)); return builder; }	"    public ServletRegistration.Dynamic addServlet(String name, Servlet servlet) {
        final ServletHolder holder = new NonblockingServletHolder(checkNotNull(servlet));
        holder.setName(name);
        handler.getServletHandler().addServlet(holder);
        return holder.getRegistration();
    }
"	@param servlet the servlet instance	@param name the servlet's name	1	0	7	9	47
"public ChatProtocol onMessage(ChatProtocol message) throws IOException { if (!users.containsKey(message.getAuthor())) { users.put(message.getAuthor(), message.getUuid()); return new ChatProtocol(message.getAuthor(), "" entered room "" + chatroomName, users.keySet(), factory.lookupAll()); } if (message.getMessage().contains(""disconnecting"")) { users.remove(message.getAuthor()); return new ChatProtocol(message.getAuthor(), "" disconnected from room "" + chatroomName, users.keySet(), factory.lookupAll()); } message.setUsers(users.keySet()); logger.info(""{} just send {}"", message.getAuthor(), message.getMessage()); return message; }"	"    public Message onMessage(Message message) throws IOException {

        if (!users.contains(message.getAuthor())) {
            users.add(message.getAuthor());
            return new Message(message.getAuthor(), "" entered room "" + chatroomName);
        }

        logger.info(""{} just send {}"", message.getAuthor(), message.getMessage());
        return message;
    }
"	@param message an instance of  ChatProtocol 	@param message an instance of Message	1	0	8	17	153
public boolean searchText(String regex) { boolean found = searcher.searchText(regex, 0, true); return found; }	"	public boolean searchText(String search) {
		boolean found = searcher.searchText(search, 0, true);
		return found;
	}
"	@param regex the text to search for. The parameter will be interpreted as a regular expression.	@param search the string to be searched. The parameter will be interpreted as a regular expression.	1	0	6	5	24
protected EntityInfo getEntityInfo(EnversService enversService, String entityName) { EntityConfiguration entCfg = enversService.getEntitiesConfigurations().get( entityName ); boolean isRelationAudited = true; if ( entCfg == null ) { // a relation marked as RelationTargetAuditMode.NOT_AUDITED entCfg = enversService.getEntitiesConfigurations().getNotVersionEntityConfiguration( entityName ); isRelationAudited = false; } final Class entityClass = ReflectionTools.loadClass( entCfg.getEntityClassName(), enversService.getClassLoaderService() ); return new EntityInfo( entityClass, entityName, isRelationAudited ); }	"	protected EntityInfo getEntityInfo(AuditConfiguration verCfg, String entityName) {
		EntityConfiguration entCfg = verCfg.getEntCfg().get( entityName );
		boolean isRelationAudited = true;
		if ( entCfg == null ) {
			// a relation marked as RelationTargetAuditMode.NOT_AUDITED
			entCfg = verCfg.getEntCfg().getNotVersionEntityConfiguration( entityName );
			isRelationAudited = false;
		}
		final Class entityClass = ReflectionTools.loadClass( entCfg.getEntityClassName(), verCfg.getClassLoaderService() );
		return new EntityInfo( entityClass, entityName, isRelationAudited );
	}
"	@param enversService The EnversService	@param verCfg Audit configuration.	1	0	9	12	83
public static Iterable<ProviderMetadata<?, ?, ?, ?>> collocatedWith(ProviderMetadata<?, ?, ?, ?> providerMetadata, ApiType type) { return filter(all(), Predicates.and(ProviderPredicates.intersectingIso3166Code(providerMetadata), ProviderPredicates.type(type))); }	"   public static Iterable<ProviderMetadata> collocatedWith(ProviderMetadata providerMetadata,
            TypeToken<? extends Wrapper> contextWrappableAs) {
      return filter(all(), Predicates.and(ProviderPredicates.intersectingIso3166Code(providerMetadata),
               ProviderPredicates.contextWrappableAs(contextWrappableAs)));
   }
"	@param type the type to filter providers by	@param contextWrappableAs the contextWrappableAs to filter providers by	1	0	7	7	52
public RexLiteral makeNullLiteral(RelDataType type) { if (!type.isNullable()) { type = typeFactory.createTypeWithNullability(type, true); } return (RexLiteral) makeCast(type, constantNull()); }	"  public RexNode makeNullLiteral(SqlTypeName typeName) {
    RelDataType type =
        typeFactory.createTypeWithNullability(
            typeFactory.createSqlType(typeName),
            true);
    return makeCast(type, constantNull());
  }
"	@param type Type to cast NULL to	@param typeName Type to cast NULL to	1	0	8	7	41
public TestBodyWithQueryParamsOper body(User body) { reqSpec.setBody(body); return this; }	"        public TestBodyWithQueryParamsOper body(User user) {
            reqSpec.setBody(user);
            return this;
        }
"	@param body (User) (required)	@param user (User) (required)	1	0	5	5	18
public SqlTester getTester() { return new SqlTesterImpl(new AdvisorTesterFactory()); }	"  public Tester getTester(SqlConformance conformance) {
    return new AdvisorTestImpl(conformance);
  }
"	@param list List	@param list List	0	1	6	4	17
"public Client testClassname(Client client) throws RestClientException { Object postBody = client; // verify the required parameter 'client' is set if (client == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'client' when calling testClassname""); } String path = UriComponentsBuilder.fromPath(""/fake_classname_test"").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { ""application/json"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { ""application/json"" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { ""api_key_query"" }; ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {}; return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }"	"    public Client testClassname(Client body) throws RestClientException {
        Object postBody = body;
        
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'body' when calling testClassname"");
        }
        
        String path = UriComponentsBuilder.fromPath(""/fake_classname_test"").build().toUriString();
        
        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();
        final HttpHeaders headerParams = new HttpHeaders();
        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();

        final String[] accepts = { 
            ""application/json""
        };
        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);
        final String[] contentTypes = { 
            ""application/json""
        };
        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);

        String[] authNames = new String[] { ""api_key_query"" };

        ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {};
        return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);
    }
"	@param client client model	@param body client model	1	0	8	29	203
File getBaseDir(File base, File file) { if (base == null) { return file.getParentFile().getAbsoluteFile(); } else { Iterator bases = getParents(base).iterator(); Iterator fileParents = getParents(file.getAbsoluteFile()).iterator(); File result = null; while (bases.hasNext() && fileParents.hasNext()) { File next = (File) bases.next(); if (next.equals(fileParents.next())) { result = next; } else { break; } } return result; } }	"    File getBaseDir(final File file1, final File file2) {
        if (file1 == null || file2 == null) {
            return null;
        }
        final Iterator file1Parents = getParents(file1).iterator();
        final Iterator file2Parents = getParents(file2.getAbsoluteFile()).iterator();
        File result = null;
        while (file1Parents.hasNext() && file2Parents.hasNext()) {
            File next = (File) file1Parents.next();
            if (next.equals(file2Parents.next())) {
                result = next;
            } else {
                break;
            }
        }
        return result;
    }
"	@param base the current base directory, may be null.	@param file1 One of the files, for which the common base directory is being sought, may be null.	1	0	11	20	106
"public TableSchema create(String schemaPrefix, String envelopSchemaName, Table table, ColumnNameFilter filter, ColumnMappers mappers) { if (schemaPrefix == null) { schemaPrefix = """"; } // Build the schemas ... final TableId tableId = table.id(); final String tableIdStr = tableSchemaName(tableId); final String schemaNamePrefix = schemaPrefix + tableIdStr; LOGGER.debug(""Mapping table '{}' to schemas under '{}'"", tableId, schemaNamePrefix); SchemaBuilder valSchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + "".Value"")); SchemaBuilder keySchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + "".Key"")); AtomicBoolean hasPrimaryKey = new AtomicBoolean(false); table.columns().forEach(column -> { if (table.isPrimaryKeyColumn(column.name())) { // The column is part of the primary key, so ALWAYS add it to the PK schema ... addField(keySchemaBuilder, column, null); hasPrimaryKey.set(true); } if (filter == null || filter.matches(tableId.catalog(), tableId.schema(), tableId.table(), column.name())) { // Add the column to the value schema only if the column has not been filtered ... ColumnMapper mapper = mappers == null ? null : mappers.mapperFor(tableId, column); addField(valSchemaBuilder, column, mapper); } }); Schema valSchema = valSchemaBuilder.optional().build(); Schema keySchema = hasPrimaryKey.get() ? keySchemaBuilder.build() : null; if (LOGGER.isDebugEnabled()) { LOGGER.debug(""Mapped primary key for table '{}' to schema: {}"", tableId, SchemaUtil.asDetailedString(keySchema)); LOGGER.debug(""Mapped columns for table '{}' to schema: {}"", tableId, SchemaUtil.asDetailedString(valSchema)); } Envelope envelope = Envelope.defineSchema() .withName(schemaNameAdjuster.adjust(envelopSchemaName)) .withRecord(valSchema) .withSource(sourceInfoSchema) .build(); // Create the generators ... Function<Object[], Object> keyGenerator = createKeyGenerator(keySchema, tableId, table.primaryKeyColumns()); Function<Object[], Struct> valueGenerator = createValueGenerator(valSchema, tableId, table.columns(), filter, mappers); // And the table schema ... return new TableSchema(tableId, keySchema, keyGenerator, envelope, valSchema, valueGenerator); }"	"    public TableSchema create(String schemaPrefix, String envelopSchemaName, Table table, Predicate<ColumnId> filter, ColumnMappers mappers) {
        if (schemaPrefix == null) {
            schemaPrefix = """";
        }
        // Build the schemas ...
        final TableId tableId = table.id();
        final String tableIdStr = tableSchemaName(tableId);
        final String schemaNamePrefix = schemaPrefix + tableIdStr;
        LOGGER.debug(""Mapping table '{}' to schemas under '{}'"", tableId, schemaNamePrefix);
        SchemaBuilder valSchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + "".Value""));
        SchemaBuilder keySchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + "".Key""));
        AtomicBoolean hasPrimaryKey = new AtomicBoolean(false);
        table.columns().forEach(column -> {
            if (table.isPrimaryKeyColumn(column.name())) {
                // The column is part of the primary key, so ALWAYS add it to the PK schema ...
                addField(keySchemaBuilder, column, null);
                hasPrimaryKey.set(true);
            }
            if (filter == null || filter.test(new ColumnId(tableId, column.name()))) {
                // Add the column to the value schema only if the column has not been filtered ...
                ColumnMapper mapper = mappers == null ? null : mappers.mapperFor(tableId, column);
                addField(valSchemaBuilder, column, mapper);
            }
        });
        Schema valSchema = valSchemaBuilder.optional().build();
        Schema keySchema = hasPrimaryKey.get() ? keySchemaBuilder.build() : null;

        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug(""Mapped primary key for table '{}' to schema: {}"", tableId, SchemaUtil.asDetailedString(keySchema));
            LOGGER.debug(""Mapped columns for table '{}' to schema: {}"", tableId, SchemaUtil.asDetailedString(valSchema));
        }

        Envelope envelope = Envelope.defineSchema()
                .withName(schemaNameAdjuster.adjust(envelopSchemaName))
                .withRecord(valSchema)
                .withSource(sourceInfoSchema)
                .build();


        // Create the generators ...
        Function<Object[], Object> keyGenerator = createKeyGenerator(keySchema, tableId, table.primaryKeyColumns());
        Function<Object[], Struct> valueGenerator = createValueGenerator(valSchema, tableId, table.columns(), filter, mappers);

        // And the table schema ...
        return new TableSchema(tableId, keySchema, keyGenerator, envelope, valSchema, valueGenerator);
    }
"	@param mappers the mapping functions for columns; may be null if none of the columns are to be mapped to different values	@param mappers the mapping functions for columns; may be null if none of the columns are to be mapped to different values	0	1	13	48	448
public static List<Integer> getSubListIndex(Object[] tofind, Object[] tokens){ if(tofind.length > tokens.length) return null; List<Integer> allIndices = new ArrayList<Integer>(); boolean matched = false; int index = -1; int lastUnmatchedIndex = 0; for(int i = 0 ; i < tokens.length;){ for(int j = 0; j < tofind.length ;){ if(tofind[j].equals(tokens[i])){ index = i; i++; j++; if(j == tofind.length) { matched = true; break; } }else{ j = 0; i = lastUnmatchedIndex +1; lastUnmatchedIndex = i; index = -1; if(lastUnmatchedIndex == tokens.length) break; } if(i >= tokens.length){ index = -1; break; } } if(i == tokens.length || matched){ if(index >= 0) //index = index - l1.length + 1; allIndices.add(index - tofind.length + 1); matched = false; lastUnmatchedIndex = index; //break; } } //get starting point return allIndices; }	"  public static List<Integer> getSubListIndex(Object[] l1, Object[] l2){
    if(l1.length > l2.length)
      return null;
    List<Integer> allIndices = new ArrayList<Integer>();
    boolean matched = false;
    int index = -1;
    int lastUnmatchedIndex = 0;
    for(int i = 0 ; i < l2.length;){
      for(int j = 0; j < l1.length ;){
        if(l1[j].equals(l2[i])){
          index = i;
          i++;
          j++;
          if(j == l1.length)
          {
            matched = true;
            break;
          }
        }else{
          j = 0;
          i = lastUnmatchedIndex +1;
          lastUnmatchedIndex = i;
          index = -1;
          if(lastUnmatchedIndex == l2.length)
            break;
        }
        if(i >= l2.length){
          index = -1;
          break;
        }
      }
      if(i == l2.length || matched){
        if(index >= 0)
          //index = index - l1.length + 1;
          allIndices.add(index - l1.length + 1);
        matched = false;
        lastUnmatchedIndex = index;

        //break;
      }
    }
    //get starting point

    return allIndices;
  }
"	@param tofind array you want to find in tokens	@param l1 array you want to find in l2	1	0	13	46	211
public DataFetcher getDataFetcher(FieldCoordinates coordinates, GraphQLFieldDefinition fieldDefinition) { return getDataFetcherImpl(coordinates, fieldDefinition, dataFetcherMap, systemDataFetcherMap); }	"    public DataFetcher getDataFetcher(GraphQLFieldsContainer parentType, GraphQLFieldDefinition fieldDefinition) {
        return getDataFetcherImpl(parentType, fieldDefinition, dataFetcherMap, systemDataFetcherMap);
    }
"	@param coordinates the field coordinates	@param parentType the container type	1	0	5	4	24
"public ArrayList<TextView> clickInRecyclerView(int itemIndex, int recyclerViewIndex, int id, boolean longClick, int time) { View viewOnLine = null; final long endTime = SystemClock.uptimeMillis() + Timeout.getSmallTimeout(); if(itemIndex < 0) itemIndex = 0; ArrayList<View> views = new ArrayList<View>(); ViewGroup recyclerView = viewFetcher.getRecyclerView(recyclerViewIndex, Timeout.getSmallTimeout()); if(recyclerView == null){ Assert.fail(""RecyclerView is not found!""); } else{ failIfIndexHigherThenChildCount(recyclerView, itemIndex, endTime); viewOnLine = getViewOnRecyclerItemIndex((ViewGroup) recyclerView, recyclerViewIndex, itemIndex); } if(viewOnLine != null){ views = viewFetcher.getViews(viewOnLine, true); views = RobotiumUtils.removeInvisibleViews(views); if(id == 0){ clickOnScreen(viewOnLine, longClick, time); } else{ clickOnScreen(getView(id, views)); } } return RobotiumUtils.filterViews(TextView.class, views); }"	"	public ArrayList<TextView> clickInRecyclerView(int itemIndex, int recyclerViewIndex, boolean longClick, int time) {
		View viewOnLine = null;
		final long endTime = SystemClock.uptimeMillis() + Timeout.getSmallTimeout();

		if(itemIndex < 0)
			itemIndex = 0;

		ArrayList<View> views = new ArrayList<View>();
		ViewGroup recyclerView = viewFetcher.getRecyclerView(recyclerViewIndex, Timeout.getSmallTimeout());
		
		if(recyclerView == null){
			Assert.fail(""RecyclerView is not found!"");
		}
		else{
			failIfIndexHigherThenChildCount(recyclerView, itemIndex, endTime);
			viewOnLine = getViewOnRecyclerItemIndex((ViewGroup) recyclerView, recyclerViewIndex, itemIndex);
		}
		
		if(viewOnLine != null){
			views = viewFetcher.getViews(viewOnLine, true);
			views = RobotiumUtils.removeInvisibleViews(views);
			clickOnScreen(viewOnLine, longClick, time);
		}
		return RobotiumUtils.filterViews(TextView.class, views);
	}
"	@param itemIndex the item index that should be clicked	@param itemIndex the item index that should be clicked	0	1	10	32	176
public boolean waitForText(String text, int expectedMinimumNumberOfMatches, long timeout, boolean scroll) { final long endTime = System.currentTimeMillis() + timeout; while (true) { final boolean timedOut = System.currentTimeMillis() > endTime; if (timedOut){ return false; } sleeper.sleep(); final boolean foundAnyTextView = searcher.searchFor(TextView.class, text, expectedMinimumNumberOfMatches, scroll); if (foundAnyTextView){ return true; } final boolean foundAnyEditText = searcher.searchFor(EditText.class, text, 1, scroll); if (foundAnyEditText){ return true; } } }	"	public boolean waitForText(String text, int matches, long timeout, boolean scroll) {
        final long endTime = System.currentTimeMillis() + timeout;

		while (true) {
			final boolean timedOut = System.currentTimeMillis() > endTime;
			if (timedOut){
				return false;
			}

			sleeper.sleep();

			final boolean foundAnyTextView = searcher.searchFor(TextView.class, text, matches, scroll);
			if (foundAnyTextView){
				return true;
			}

			final boolean foundAnyEditText = searcher.searchFor(EditText.class, text, 1, scroll);
			if (foundAnyEditText){
				return true;
			}
        }
    }
"	@param expectedMinimumNumberOfMatches the minimum number of matches of text that must be shown.  0 means any number of matches	@param matches the number of matches of text that must be shown. 0 means any number of matches	1	0	9	23	107
"private int getJavadocOffset(TypeDeclaration td){ // TODO: This isn't perfect yet. Class \n \n \n className still breaks it.. :'( List<ASTNode> list= td.modifiers(); list = td.modifiers(); SimpleName sn = (SimpleName) getNode(); int lineNum = getLineNumber(sn); log(""SN ""+sn + "", "" + lineNum); for (ASTNode astNode : list) { if(getLineNumber(astNode) == lineNum) { log(""first node in that line "" + astNode); log(""diff "" + (sn.getStartPosition() - astNode.getStartPosition())); return (astNode.getStartPosition()); } } if(td.getJavadoc() != null){ log(""diff "" + (td.getJavadoc().getStartPosition() + td.getJavadoc().getLength() + 1)); return (td.getJavadoc().getStartPosition() + td.getJavadoc().getLength() + 1); } log(""getJavadocOffset(TypeDeclaration td) ""+sn + "", found nothing. Meh.""); return 0; }"	"  private int getJavadocOffset(FieldDeclaration fd){
    List<ASTNode> list= fd.modifiers();
    SimpleName sn = (SimpleName) getNode();
    
    Type tp = fd.getType();
    int lineNum = getLineNumber(sn);
    log(""SN ""+sn + "", "" + lineNum);
    for (ASTNode astNode : list) {
      if(getLineNumber(astNode) == lineNum)
      {
        log(""first node in that line "" + astNode);
        log(""diff "" + (sn.getStartPosition() - astNode.getStartPosition()));
        return (astNode.getStartPosition());
      }
    }
    if(getLineNumber(fd.getType()) == lineNum)
    {
      log(""first node in that line "" + tp);
      log(""diff "" + (sn.getStartPosition() - tp.getStartPosition()));
      return (tp.getStartPosition());
    }
    
    
    return 0;   
  }
"	@param td	@param fd	1	0	11	26	219
"private boolean hasVerbalAuxiliary(Tree[] kids, Set<String> verbalSet) { if (DEBUG) { System.err.println(""Checking for verbal auxiliary""); } for (Tree kid : kids) { if (DEBUG) { System.err.println("" checking in "" + kid); } if (kid.isPreTerminal()) { Label kidLabel = kid.label(); String tag = null; if (kidLabel instanceof HasTag) { tag = ((HasTag) kidLabel).tag(); } if (tag == null) { tag = kid.value(); } Label wordLabel = kid.firstChild().label(); String word = null; if (wordLabel instanceof HasWord) { word = ((HasWord) wordLabel).word(); } if (word == null) { word = wordLabel.value(); } if (DEBUG) { System.err.println(""Checking "" + kid.value() + "" head is "" + word + '/' + tag); } String lcWord = word.toLowerCase(); if (verbalTags.contains(tag) && verbalSet.contains(lcWord)) { if (DEBUG) { System.err.println(""hasVerbalAuxiliary returns true""); } return true; } } } if (DEBUG) { System.err.println(""hasVerbalAuxiliary returns false""); } return false; }"	"  private boolean hasVerbalAuxiliary(Tree[] kids, HashSet<String> verbalSet) {
    if (DEBUG) {
      System.err.println(""Checking for verbal auxiliary"");
    }
    for (Tree kid : kids) {
      if (DEBUG) {
        System.err.println(""  checking in "" + kid);
      }
      if (kid.isPreTerminal()) {
        Label kidLabel = kid.label();
        String tag = null;
        if (kidLabel instanceof HasTag) {
          tag = ((HasTag) kidLabel).tag();
        }
        if (tag == null) {
          tag = kid.value();
        }
        Label wordLabel = kid.firstChild().label();
        String word = null;
        if (wordLabel instanceof HasWord) {
          word = ((HasWord) wordLabel).word();
        }
        if (word == null) {
          word = wordLabel.value();
        }

        if (DEBUG) {
          System.err.println(""Checking "" + kid.value() + "" head is "" + word + '/' + tag);
        }
        String lcWord = word.toLowerCase();
        if (verbalTags.contains(tag) && verbalSet.contains(lcWord)) {
          if (DEBUG) {
            System.err.println(""hasVerbalAuxiliary returns true"");
          }
          return true;
        }
      }
    }
    if (DEBUG) {
      System.err.println(""hasVerbalAuxiliary returns false"");
    }
    return false;
  }
"	@param verbalSet The set of words	@param verbalSet The set of words	0	1	16	44	255
public Client testClientModel(Client client) throws ApiException { ApiResponse<Client> resp = testClientModelWithHttpInfo(client); return resp.getData(); }	"    public Client testClientModel(Client body) throws ApiException {
        ApiResponse<Client> resp = testClientModelWithHttpInfo(body);
        return resp.getData();
    }
"	@param client client model (required)	@param body client model (required)	1	0	6	5	25
protected SourceInfo update(Long lsn, Long useconds, Long txId) { this.lsn = lsn; this.useconds = useconds; this.txId = txId; return this; }	"    protected SourceInfo update(Long lsn, Long useconds, Integer txId) {
        this.lsn = lsn;
        this.useconds = useconds;
        this.txId = txId;
        return this;
    }
"	@param lsn the position in the server WAL for a particular event; may be null indicating that this information is not available	@param lsn the position in the server WAL for a particular event; may be null indicating that this information is not available	0	1	6	7	30
public Call createUsersWithArrayInputAsync(java.util.List<User> body, ApiCallback<Void> callback) throws ApiException { Call call = createUsersWithArrayInputCall(body); apiClient.executeAsync(call, callback); return call; }	"  public Call createUsersWithArrayInputAsync(List<User> body, ApiCallback<Void> callback) throws ApiException {
    Call call = createUsersWithArrayInputCall(body);
    apiClient.executeAsync(call, callback);
    return call;
  }
"	@param callback The callback to be executed when the API call finishes	@param callback The callback to be executed when the API call finishes	0	1	8	6	36
"public static int toMilliOfDay(Object value, boolean acceptLargeValues) { if (value instanceof Duration) { Duration duration = (Duration) value; if (!acceptLargeValues && (duration.isNegative() || duration.compareTo(ONE_DAY) > 0)) { throw new IllegalArgumentException(""Time values must be between 00:00:00 and 24:00:00 (inclusive): "" + duration); } // int conversion is ok for the range of TIME return (int) ((Duration) value).toMillis(); } // TODO only needed for SQL Server/Oracle, where we don't produce Duration right away; // this should go eventually, as the conversion to LocalTime is superfluous LocalTime time = Conversions.toLocalTime(value); long micros = Math.floorDiv(time.toNanoOfDay(), Conversions.NANOSECONDS_PER_MILLISECOND); assert Math.abs(micros) < Integer.MAX_VALUE; return (int) micros; }"	"    public static int toMilliOfDay(Object value, TemporalAdjuster adjuster) {
        if (value instanceof Duration) {
            // int conversion is ok for the range of TIME
            return (int) ((Duration) value).toMillis();
        }
        LocalTime time = Conversions.toLocalTime(value);
        if (adjuster != null) {
            time = time.with(adjuster);
        }
        long micros = Math.floorDiv(time.toNanoOfDay(), Conversions.NANOSECONDS_PER_MILLISECOND);
        assert Math.abs(micros) < Integer.MAX_VALUE;
        return (int) micros;
    }
"	@param value the duration value; may not be null	@param value the local or SQL date, time, or timestamp value; may not be null	1	0	10	19	178
public static DateTimeComparator getInstance(DateTimeFieldType lowerLimit, DateTimeFieldType upperLimit) { if (lowerLimit == null && upperLimit == null) { return ALL_INSTANCE; } if (lowerLimit == DateTimeFieldType.dayOfYear() && upperLimit == null) { return DATE_INSTANCE; } if (lowerLimit == null && upperLimit == DateTimeFieldType.dayOfYear()) { return TIME_INSTANCE; } return new DateTimeComparator(lowerLimit, upperLimit); }	"    public static DateTimeComparator getInstance(DateTimeField lowerLimit, DateTimeField upperLimit) {
        if (lowerLimit == null && upperLimit == null) {
            return INSTANCE;
        }
        if (lowerLimit != null && upperLimit != null) {
            if (lowerLimit.getDurationField().getUnitMillis() > upperLimit.getDurationField().getUnitMillis()) {
                throw new IllegalArgumentException(""Lower limit greater than upper: "" +
                    lowerLimit.getName() + "" > "" + upperLimit.getName());
            }
        }
        return new DateTimeComparator(lowerLimit, upperLimit);
    }
"	@param lowerLimit inclusive lower limit for fields to be compared, null means no limit	@param lowerLimit inclusive lower limit for fields to be compared, null means no limit	0	1	6	13	70
public boolean searchButton(String regex, int expectedMinimumNumberOfMatches) { boolean found = searcher.searchWithTimeoutFor(Button.class, regex, expectedMinimumNumberOfMatches, true); return found; }	"	public boolean searchButton(String regex, int matches) {
		boolean found = searcher.searchWithTimeoutFor(Button.class, regex, matches, true);
		return found;
	}
"	@param expectedMinimumNumberOfMatches the minimum number of matches expected to be found.  0 matches means that one or more matches are expected to be found	@param matches the number of matches expected to be found. 0 matches means that one or more matches are expected to be found	1	0	7	5	30
public int[] findModified(Object[] old, Object[] current, Object entity, SharedSessionContractImplementor session) throws HibernateException { int[] props = TypeHelper.findModified( entityMetamodel.getProperties(), current, old, propertyColumnUpdateable, hasUninitializedLazyProperties( entity ), session ); if ( props == null ) { return null; } else { logDirtyProperties( props ); return props; } }	"	public int[] findModified(Object[] old, Object[] current, Object entity, SessionImplementor session)
			throws HibernateException {
		int[] props = TypeHelper.findModified(
				entityMetamodel.getProperties(),
				current,
				old,
				propertyColumnUpdateable,
				hasUninitializedLazyProperties( entity ),
				session
		);
		if ( props == null ) {
			return null;
		}
		else {
			logDirtyProperties( props );
			return props;
		}
	}
"	@param old The old state of the entity.	@param old The old state of the entity.	0	1	7	19	73
"public Boolean fakeOuterBooleanSerialize(Boolean body) throws ApiException { Object localVarPostBody = body; // create path and map variables String localVarPath = ""/fake/outer/boolean""; // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { ""*/*"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {}; return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	"  public Boolean fakeOuterBooleanSerialize(Boolean booleanPostBody) throws ApiException {
    Object localVarPostBody = booleanPostBody;
    
    // create path and map variables
    String localVarPath = ""/fake/outer/boolean"";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    final String[] localVarAccepts = {
      ""*/*""
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {};
    return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);
      }
"	@param body Input boolean as post body (optional)	@param booleanPostBody Input boolean as post body (optional)	1	0	8	31	171
public long set(long instant, int era) { Utils.verifyValueBounds(this, era, DateTimeConstants.BCE, DateTimeConstants.CE); int oldEra = get(instant); if (oldEra != era) { int year = iChronology.year().get(instant); return iChronology.year().set(instant, -year); } else { return instant; } }	"    public long set(long millis, int era) {
        super.verifyValueBounds(era, DateTimeConstants.BCE, DateTimeConstants.CE);
            
        int oldEra = get(millis);
        if (oldEra != era) {
            int year = iChronology.year().get(millis);
            return iChronology.year().set(millis, -year);
        } else {
            return millis;
        }
    }
"	@param era the era to update the time to.	@param era the era to update the time to.	0	1	9	12	71
private boolean resolveAccount(Uri uri, ContentValues values) { String accountName = getQueryParameter(uri, RawContacts.ACCOUNT_NAME); String accountType = getQueryParameter(uri, RawContacts.ACCOUNT_TYPE); if (TextUtils.isEmpty(accountName) || TextUtils.isEmpty(accountType)) { accountName = null; accountType = null; } String valueAccountName = values.getAsString(RawContacts.ACCOUNT_NAME); String valueAccountType = values.getAsString(RawContacts.ACCOUNT_TYPE); if (TextUtils.isEmpty(valueAccountName) && TextUtils.isEmpty(valueAccountType)) { values.put(RawContacts.ACCOUNT_NAME, accountName); values.put(RawContacts.ACCOUNT_TYPE, accountType); } else { if (accountName != null && !accountName.equals(valueAccountName)) { return false; } if (accountType != null && !accountType.equals(valueAccountType)) { return false; } accountName = valueAccountName; accountType = valueAccountType; } if (TextUtils.isEmpty(accountName) || TextUtils.isEmpty(accountType)) { mAccount = null; return true; } if (mAccount == null || !mAccount.name.equals(accountName) || !mAccount.type.equals(accountType)) { mAccount = new Account(accountName, accountType); } return true; }	"    private boolean resolveAccount(ContentValues values, Account account) {
        // If either is specified then both must be specified.
        final String accountName = values.getAsString(RawContacts.ACCOUNT_NAME);
        final String accountType = values.getAsString(RawContacts.ACCOUNT_TYPE);
        if (!TextUtils.isEmpty(accountName) || !TextUtils.isEmpty(accountType)) {
            final Account valuesAccount = new Account(accountName, accountType);
            if (account != null && !valuesAccount.equals(account)) {
                return false;
            }
            account = valuesAccount;
        }
        if (account != null) {
            values.put(RawContacts.ACCOUNT_NAME, account.name);
            values.put(RawContacts.ACCOUNT_TYPE, account.type);
        }
        return true;
    }
"	@param values the explicitly provided Account	@param account the explicitly provided Account	1	0	8	43	215
protected Object suspendAndGet(Object key, FlagAdapter opt, boolean suppressTimeout) throws CacheException { Transaction tx = suspend(); try { if (suppressTimeout) return cacheAdapter.getAllowingTimeout(key); else return cacheAdapter.get(key); } finally { resume(tx); } }	"   protected Object suspendAndGet(Object key, Flag opt, boolean suppressTimeout) throws CacheException {
       Transaction tx = suspend();
       try {
           if (suppressTimeout)
               return CacheHelper.getAllowingTimeout(cache, key);
           else
               return CacheHelper.get(cache, key);
       } finally {
           resume(tx);
       }
   }
"	@param suppressTimeout should any TimeoutException be suppressed?	@param suppressTimeout should any TimeoutException be suppressed?	0	1	7	12	53
public Activity getCurrentActivity(int pause) { if(pause > 0){ RobotiumUtils.sleep(pause); inst.waitForIdleSync(); } Boolean found = false; if (activityMonitor != null) { if (activityMonitor.getLastActivity() != null) activity = activityMonitor.getLastActivity(); } for(Activity storedActivity : activityList){ if (storedActivity.getClass().getName().equals( activity.getClass().getName())) found = true; } if (found) return activity; else { activityList.add(activity); return activity; } }	"	public Activity getCurrentActivity(int paus) {
		if(paus > 0){
			RobotiumUtils.sleep(paus);
			inst.waitForIdleSync();
		}
		Boolean found = false;
		if (activityMonitor != null) {
			if (activityMonitor.getLastActivity() != null)
				activity = activityMonitor.getLastActivity();
		}
		for(Activity storedActivity : activityList){
			if (storedActivity.getClass().getName().equals(
					activity.getClass().getName()))
				found = true;
		}
		if (found)
			return activity;
		else {
			activityList.add(activity);
			return activity;
		}
	}
"	@param pause the time to pause in milliseconds	@param paus the time to paus	1	0	9	23	105
public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, Map<String, Object> params) throws IOException { HttpResponse response = uploadFileWithRequiredFileForHttpResponse(petId, requiredFile, params); TypeReference typeRef = new TypeReference<ModelApiResponse>() {}; return apiClient.getObjectMapper().readValue(response.getContent(), typeRef); }	"    public ModelApiResponse uploadFileWithRequiredFile(Long petId, File file, Map<String, Object> params) throws IOException {
        HttpResponse response = uploadFileWithRequiredFileForHttpResponse(petId, file, params);
        TypeReference typeRef = new TypeReference<ModelApiResponse>() {};
        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);
    }
"	@param requiredFile file to upload	@param file file to upload	1	0	8	6	56
public long set(long instant, int year) { Utils.verifyValueBounds (this, year, iChronology.getMinYear(), iChronology.getMaxYear()); int dayOfYear = iChronology.dayOfYear().get(instant); int millisOfDay = iChronology.millisOfDay().get(instant); if (dayOfYear > (31 + 28)) { // after Feb 28 if (isLeap(instant)) { // Old date is Feb 29 or later. if (!iChronology.isLeapYear(year)) { // Moving to a non-leap year, Feb 29 does not exist. dayOfYear--; } } else { // Old date is Mar 01 or later. if (iChronology.isLeapYear(year)) { // Moving to a leap year, account for Feb 29. dayOfYear++; } } } instant = iChronology.getYearMonthDayMillis(year, 1, dayOfYear); instant += millisOfDay; return instant; }	"    public long set(long millis, int year) {
        super.verifyValueBounds(year, iChronology.getMinYear(), iChronology.getMaxYear());

        int dayOfYear = iChronology.dayOfYear().get(millis);
        int millisOfDay = iChronology.millisOfDay().get(millis);

        if (dayOfYear > (31 + 28)) { // after Feb 28
            if (isLeap(millis)) {
                // Old date is Feb 29 or later.
                if (!iChronology.isLeapYear(year)) {
                    // Moving to a non-leap year, Feb 29 does not exist.
                    dayOfYear--;
                }
            } else {
                // Old date is Mar 01 or later.
                if (iChronology.isLeapYear(year)) {
                    // Moving to a leap year, account for Feb 29.
                    dayOfYear++;
                }
            }
        }

        millis = iChronology.getYearMonthDayMillis(year, 1, dayOfYear);
        millis += millisOfDay;

        return millis;
    }
"	@param instant the time instant in millis to update.	@param millis the time instant in millis to update.	1	0	10	29	172
"public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType) throws ApiException { Client client = getClient(); StringBuilder b = new StringBuilder(); for(String key : queryParams.keySet()) { String value = queryParams.get(key); if (value != null){ if(b.toString().length() == 0) b.append(""?""); else b.append(""&""); b.append(escapeString(key)).append(""="").append(escapeString(value)); } } String querystring = b.toString(); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(""GET"".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (""POST"".equals(method)) { if (contentType.startsWith(""application/x-www-form-urlencoded"")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (""PUT"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (""DELETE"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, ""unknown method type "" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return """"; } } else { String message = ""error""; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { // e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }"	"  public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String contentType) throws ApiException {
    Client client = getClient();

    StringBuilder b = new StringBuilder();

    for(String key : queryParams.keySet()) {
      String value = queryParams.get(key);
      if (value != null){
        if(b.toString().length() == 0)
          b.append(""?"");
        else
          b.append(""&"");
        b.append(escapeString(key)).append(""="").append(escapeString(value));
      }
    }
    String querystring = b.toString();

    Builder builder = client.resource(basePath + path + querystring).accept(""application/json"");
    for(String key : headerParams.keySet()) {
      builder = builder.header(key, headerParams.get(key));
    }

    for(String key : defaultHeaderMap.keySet()) {
      if(!headerParams.containsKey(key)) {
        builder = builder.header(key, defaultHeaderMap.get(key));
      }
    }
    ClientResponse response = null;

    if(""GET"".equals(method)) {
      response = (ClientResponse) builder.get(ClientResponse.class);
    }
    else if (""POST"".equals(method)) {
      if (contentType.startsWith(""application/x-www-form-urlencoded"")) {
        String encodedFormParams = this
            .getXWWWFormUrlencodedParams(formParams);
        response = builder.type(contentType).post(ClientResponse.class,
            encodedFormParams);
      } else if (body == null) {
        response = builder.post(ClientResponse.class, null);
      } else if(body instanceof FormDataMultiPart) {
        response = builder.type(contentType).post(ClientResponse.class, body);
      }
      else
        response = builder.type(contentType).post(ClientResponse.class, serialize(body));
    }
    else if (""PUT"".equals(method)) {
      if (""application/x-www-form-urlencoded"".equals(contentType)) {
          String encodedFormParams = this
              .getXWWWFormUrlencodedParams(formParams);
          response = builder.type(contentType).put(ClientResponse.class,
              encodedFormParams);
      } else if(body == null) {
        response = builder.put(ClientResponse.class, serialize(body));
      } else {
          response = builder.type(contentType).put(ClientResponse.class, serialize(body));
      }
    }
    else if (""DELETE"".equals(method)) {
      if (""application/x-www-form-urlencoded"".equals(contentType)) {
        String encodedFormParams = this
            .getXWWWFormUrlencodedParams(formParams);
        response = builder.type(contentType).delete(ClientResponse.class,
            encodedFormParams);
      } else if(body == null) {
        response = builder.delete(ClientResponse.class);
      } else {
        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));
      }
    }
    else {
      throw new ApiException(500, ""unknown method type "" + method);
    }

    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {
      return null;
    }
    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {
      if(response.hasEntity()) {
        return (String) response.getEntity(String.class);
      }
      else {
        return """";
      }
    }
    else {
      String message = ""error"";
      String respBody = null;
      if(response.hasEntity()) {
        try{
          respBody = String.valueOf(response.getEntity(String.class));
          message = respBody;
        }
        catch (RuntimeException e) {
          // e.printStackTrace();
        }
      }
      throw new ApiException(
                response.getClientResponseStatus().getStatusCode(),
                message,
                response.getHeaders(),
                respBody);
    }
  }
"	@param queryParams The query parameters	@param queryParams The query parameters	0	1	16	109	716
public Struct read(Object record, Struct source, Long timestamp) { Struct struct = new Struct(schema); struct.put(FieldName.OPERATION, Operation.READ.code()); struct.put(FieldName.AFTER, record); if (source != null) struct.put(FieldName.SOURCE, source); if (timestamp != null) struct.put(FieldName.TIMESTAMP, timestamp); return struct; }	"    public Struct read(Struct record, Struct source, Long timestamp) {
        Struct struct = new Struct(schema);
        struct.put(FieldName.OPERATION, Operation.READ.code());
        struct.put(FieldName.AFTER, record);
        if (source != null) struct.put(FieldName.SOURCE, source);
        if (timestamp != null) struct.put(FieldName.TIMESTAMP, timestamp);
        return struct;
    }
"	@param record the state of the record as read; may not be null	@param record the state of the record as read; may not be null	0	1	6	9	78
"public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); final String url = buildUrl(path, queryParams); final Request.Builder reqBuilder = new Request.Builder().url(url); processHeaderParams(headerParams, reqBuilder); String contentType = (String) headerParams.get(""Content-Type""); // ensuring a default content type if (contentType == null) contentType = ""application/json""; RequestBody reqBody; if (!HttpMethod.permitsRequestBody(method)) { reqBody = null; } else if (""application/x-www-form-urlencoded"".equals(contentType)) { reqBody = buildRequestBodyFormEncoding(formParams); } else if (""multipart/form-data"".equals(contentType)) { reqBody = buildRequestBodyMultipart(formParams); } else if (body == null) { if (""DELETE"".equals(method)) { // allow calling DELETE without sending a request body reqBody = null; } else { // use an empty request body (for POST, PUT and PATCH) reqBody = RequestBody.create(MediaType.parse(contentType), """"); } } else { reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType)); } Request request = null; if(progressRequestListener != null) { ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, progressRequestListener); request = reqBuilder.method(method, progressRequestBody).build(); } else { request = reqBuilder.method(method, reqBody).build(); } return httpClient.newCall(request); }"	"  public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames) throws ApiException {
    updateParamsForAuth(authNames, queryParams, headerParams);

    final String url = buildUrl(path, queryParams);
    final Request.Builder reqBuilder = new Request.Builder().url(url);
    processHeaderParams(headerParams, reqBuilder);

    String contentType = (String) headerParams.get(""Content-Type"");
    // ensuring a default content type
    if (contentType == null) contentType = ""application/json"";

    RequestBody reqBody;
    if (!HttpMethod.permitsRequestBody(method)) {
      reqBody = null;
    } else if (""application/x-www-form-urlencoded"".equals(contentType)) {
      reqBody = buildRequestBodyFormEncoding(formParams);
    } else if (""multipart/form-data"".equals(contentType)) {
      reqBody = buildRequestBodyMultipart(formParams);
    } else if (body == null) {
      if (""DELETE"".equals(method)) {
        // allow calling DELETE without sending a request body
        reqBody = null;
      } else {
        // use an empty request body (for POST, PUT and PATCH)
        reqBody = RequestBody.create(MediaType.parse(contentType), """");
      }
    } else {
      reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType));
    }

    Request request = reqBuilder.method(method, reqBody).build();
    return httpClient.newCall(request);
  }
"	@param formParams The form parameters	@param formParams The form parameters	0	1	14	42	325
public Order placeOrder(Order order) throws ApiException { return placeOrderWithHttpInfo(order).getData(); }	"  public Order placeOrder(Order body) throws ApiException {
    return placeOrderWithHttpInfo(body).getData();
      }
"	@param order order placed for purchasing the pet (required)	@param body order placed for purchasing the pet (required)	1	0	5	4	20
"private ParquetTableMetadata_v4 getParquetTableMetadata(Path path, FileSystem fs) throws IOException { FileStatus fileStatus = fs.getFileStatus(path); Stopwatch watch = logger.isDebugEnabled() ? Stopwatch.createStarted() : null; List<FileStatus> fileStatuses = new ArrayList<>(); if (fileStatus.isFile()) { fileStatuses.add(fileStatus); } else { // the thing we need!? fileStatuses.addAll(DrillFileSystemUtil.listFiles(fs, path, true)); } if (watch != null) { logger.debug(""Took {} ms to get file statuses"", watch.elapsed(TimeUnit.MILLISECONDS)); watch.reset(); watch.start(); } Map<FileStatus, FileSystem> fileStatusMap = fileStatuses.stream() .collect( java.util.stream.Collectors.toMap( Function.identity(), s -> fs, (oldFs, newFs) -> newFs, LinkedHashMap::new)); ParquetTableMetadata_v4 metadata_v4 = getParquetTableMetadata(fileStatusMap); if (watch != null) { logger.debug(""Took {} ms to read file metadata"", watch.elapsed(TimeUnit.MILLISECONDS)); watch.stop(); } return metadata_v4; }"	"  private ParquetTableMetadata_v4 getParquetTableMetadata(String path, FileSystem fs) throws IOException {
    Path p = new Path(path);
    FileStatus fileStatus = fs.getFileStatus(p);
    Stopwatch watch = logger.isDebugEnabled() ? Stopwatch.createStarted() : null;
    List<FileStatus> fileStatuses = new ArrayList<>();
    if (fileStatus.isFile()) {
      fileStatuses.add(fileStatus);
    } else {
      fileStatuses.addAll(DrillFileSystemUtil.listFiles(fs, p, true));
    }
    if (watch != null) {
      logger.debug(""Took {} ms to get file statuses"", watch.elapsed(TimeUnit.MILLISECONDS));
      watch.reset();
      watch.start();
    }

    Map<FileStatus, FileSystem> fileStatusMap = fileStatuses.stream()
        .collect(
            java.util.stream.Collectors.toMap(
                Function.identity(),
                s -> fs,
                (oldFs, newFs) -> newFs,
                LinkedHashMap::new));

    ParquetTableMetadata_v4 metadata_v4 = getParquetTableMetadata(fileStatusMap);
    if (watch != null) {
      logger.debug(""Took {} ms to read file metadata"", watch.elapsed(TimeUnit.MILLISECONDS));
      watch.stop();
    }
    return metadata_v4;
  }
"	@param path the path of the directory	@param path the path of the directory	0	1	9	32	210
public static RelationTriple fromProto(CoreNLPProtos.RelationTriple proto, Annotation doc, int sentenceIndex) { if (Thread.interrupted()) { throw new RuntimeInterruptedException(); } // Get the spans for the extraction List<CoreLabel> subject = proto.getSubjectTokensList().stream().map(loc -> doc.get(SentencesAnnotation.class).get(loc.getSentenceIndex()).get(TokensAnnotation.class).get(loc.getTokenIndex()) ).collect(Collectors.toList()); List<CoreLabel> relation; if (proto.getRelationTokensCount() == 0) { // If we don't have a real span for the relation, make a dummy word relation = Collections.singletonList(new CoreLabel(new Word(proto.getRelation()))); } else { relation = proto.getRelationTokensList().stream().map(loc -> doc.get(SentencesAnnotation.class).get(loc.getSentenceIndex()).get(TokensAnnotation.class).get(loc.getTokenIndex()) ).collect(Collectors.toList()); } List<CoreLabel> object = proto.getObjectTokensList().stream().map(loc -> doc.get(SentencesAnnotation.class).get(loc.getSentenceIndex()).get(TokensAnnotation.class).get(loc.getTokenIndex()) ).collect(Collectors.toList()); // Create the extraction RelationTriple extraction; double confidence = proto.getConfidence(); if (proto.hasTree()) { SemanticGraph tree = fromProto( proto.getTree(), doc.get(SentencesAnnotation.class).get(sentenceIndex).get(TokensAnnotation.class), doc.get(DocIDAnnotation.class), Optional.of(doc)); extraction = new RelationTriple.WithTree(subject, relation, object, tree, confidence); } else { extraction = new RelationTriple(subject, relation, object, confidence); } // Tweak the extraction if (proto.hasIstmod()) { extraction.istmod(proto.getIstmod()); } if (proto.hasPrefixBe()) { extraction.isPrefixBe(proto.getPrefixBe()); } if (proto.hasSuffixBe()) { extraction.isSuffixBe(proto.getSuffixBe()); } if (proto.hasSuffixOf()) { extraction.isSuffixOf(proto.getSuffixOf()); } // Return return extraction; }	"  public static RelationTriple fromProto(CoreNLPProtos.RelationTriple proto, List<CoreLabel> sentence, String docid) {
    if (Thread.interrupted()) {
      throw new RuntimeInterruptedException();
    }
    // Get the spans for the extraction
    List<CoreLabel> subject = proto.getSubjectTokensList().stream().map(sentence::get).collect(Collectors.toList());
    List<CoreLabel> relation;
    if (proto.getRelationTokensCount() == 0) {  // If we don't have a real span for the relation, make a dummy word
      relation = Collections.singletonList(new CoreLabel(new Word(proto.getRelation())));
    } else {
      relation = proto.getRelationTokensList().stream().map(sentence::get).collect(Collectors.toList());
    }
    List<CoreLabel> object = proto.getObjectTokensList().stream().map(sentence::get).collect(Collectors.toList());

    // Create the extraction
    RelationTriple extraction;
    double confidence = proto.getConfidence();
    if (proto.hasTree()) {
      SemanticGraph tree = fromProto(proto.getTree(), sentence, docid);
      extraction =  new RelationTriple.WithTree(subject, relation, object, tree, confidence);
    } else {
      extraction = new RelationTriple(subject, relation, object, confidence);
    }

    // Tweak the extraction
    if (proto.hasIstmod()) { extraction.istmod(proto.getIstmod()); }
    if (proto.hasPrefixBe()) { extraction.isPrefixBe(proto.getPrefixBe()); }
    if (proto.hasSuffixBe()) { extraction.isSuffixBe(proto.getSuffixBe()); }
    if (proto.hasSuffixOf()) { extraction.isSuffixOf(proto.getSuffixOf()); }

    // Return
    return extraction;
  }
"	@param sentenceIndex The index of the sentence this extraction should be attached to.	@param docid The id of the document we are de-serializing.	1	0	13	44	414
public static ParquetTableMetadataBase readBlockMeta(FileSystem fs, String path, MetadataContext metaContext, ParquetFormatConfig formatConfig) throws IOException { Metadata metadata = new Metadata(fs, formatConfig); metadata.readBlockMeta(path, false, metaContext); return metadata.parquetTableMetadata; }	"  public static ParquetTableMetadataBase readBlockMeta(FileSystem fs, String path, MetadataContext metaContext) throws IOException {
    Metadata metadata = new Metadata(fs);
    metadata.readBlockMeta(path, false, metaContext);
    return metadata.parquetTableMetadata;
  }
"	@param path The path to the metadata file, located in the directory that contains the parquet files	@param path The path to the metadata file, located in the directory that contains the parquet files	0	1	6	6	45
public long addWrapped(long instant, int months) { return set(instant, Utils.getWrappedValue(get(instant), months, MIN, MAX)); }	"    public long addWrapped(long millis, int months) {
        return set(millis, getWrappedValue(get(millis), months, MIN, MAX));
    }
"	@param instant the time instant in millis to update.	@param millis the time instant in millis to update.	1	0	7	4	33
private static boolean shouldDelayIdentityInserts(boolean requiresImmediateIdAccess, EventSource source, EntityPersister persister) { return shouldDelayIdentityInserts( requiresImmediateIdAccess, isPartOfTransaction( source ), source.getHibernateFlushMode(), persister ); }	"	private static boolean shouldDelayIdentityInserts(boolean requiresImmediateIdAccess, EventSource source) {
		return shouldDelayIdentityInserts( requiresImmediateIdAccess, isPartOfTransaction( source ), source.getHibernateFlushMode() );
	}
"	@param source The session which is the source of the current event.	@param source The session which is the source of the current event.	0	1	6	4	34
public Object getCache(PGraphics renderer) { if (cacheMap == null) return null; return cacheMap.get(renderer); }	"  public Object getCache(Object parent) {
    if (cacheMap == null) return null;
    return cacheMap.get(parent);
  }
"	@param renderer The PGraphics renderer associated to the image	@param parent The PGraphics object (or any object, really) associated	1	0	5	5	24
public Single<ModelApiResponse> rxUploadFileWithRequiredFile(Long petId, AsyncFile requiredFile, String additionalMetadata) { return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> { delegate.uploadFileWithRequiredFile(petId, requiredFile, additionalMetadata, fut); })); }	"    public Single<ModelApiResponse> rxUploadFileWithRequiredFile(Long petId, AsyncFile file, String additionalMetadata) {
        return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> {
            delegate.uploadFileWithRequiredFile(petId, file, additionalMetadata, fut);
        }));
    }
"	@param requiredFile file to upload (required)	@param file file to upload (required)	1	0	10	6	46
public boolean searchToggleButton(String regex, int expectedMinimumNumberOfMatches) { boolean found = searcher.searchWithTimeoutFor(ToggleButton.class, regex, expectedMinimumNumberOfMatches, true); return found; }	"	public boolean searchToggleButton(String regex, int matches) {
		boolean found = searcher.searchWithTimeoutFor(ToggleButton.class, regex, matches, true);
		return found;
	}
"	@param regex the text to search for. The parameter will be interpreted as a regular expression.	@param regex the text to search for. The parameter will be interpreted as a regular expression.	0	1	7	5	30
"public JdbcConnection prepareQuery(String[] multiQuery, StatementPreparer[] preparers, BlockingMultiResultSetConsumer resultConsumer) throws SQLException, InterruptedException { final ResultSet[] resultSets = new ResultSet[multiQuery.length]; final PreparedStatement[] preparedStatements = new PreparedStatement[multiQuery.length]; try { for (int i = 0; i < multiQuery.length; i++) { final String query = multiQuery[i]; if (LOGGER.isTraceEnabled()) { LOGGER.trace(""running '{}'"", query); } final PreparedStatement statement = createPreparedStatement(query); preparedStatements[i] = statement; preparers[i].accept(statement); resultSets[i] = statement.executeQuery(); } if (resultConsumer != null) { resultConsumer.accept(resultSets); } } finally { for (ResultSet rs: resultSets) { if (rs != null) { try { rs.close(); } catch (Exception ei) { } } } } return this; }"	"    public JdbcConnection prepareQuery(String[] multiQuery, StatementPreparer preparer, BlockingMultiResultSetConsumer resultConsumer) throws SQLException, InterruptedException {
        final Connection conn = connection();
        final ResultSet[] resultSets = new ResultSet[multiQuery.length];
        final PreparedStatement[] preparedStatements = new PreparedStatement[multiQuery.length];

        try {
            for (int i = 0; i < multiQuery.length; i++) {
                final String query = multiQuery[i];
                if (LOGGER.isTraceEnabled()) {
                    LOGGER.trace(""running '{}'"", query);
                }
                final PreparedStatement statement = createPreparedStatement(query);
                preparedStatements[i] = statement;
                preparer.accept(statement);
                resultSets[i] = statement.executeQuery();
            }
            if (resultConsumer != null) {
                resultConsumer.accept(resultSets);
            }
        }
        finally {
            for (ResultSet rs: resultSets) {
                if (rs != null) {
                    try {
                        rs.close();
                    }
                    catch (Exception ei) {
                    }
                }
            }
        }
        return this;
    }
"	@param preparer the array of functions that supply arguments to the prepared statements; may not be null	@param preparer the function that supplied arguments to the prepared statement; may not be null	1	0	10	33	181
"private List<File> getCandidateFiles(final Path directory) { Preconditions.checkNotNull(directory); final List<File> candidateFiles = new ArrayList<>(); try { Files.walkFileTree(directory, new SimpleFileVisitor<Path>() { @Override public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException { if (directory.equals(dir)) { // The top directory should always be listed return FileVisitResult.CONTINUE; } String directoryName = dir.getFileName().toString(); if (!recursiveDirectorySearch || directoryName.startsWith(""."") || ignorePattern.matcher(directoryName).matches()) { return FileVisitResult.SKIP_SUBTREE; } return FileVisitResult.CONTINUE; } @Override public FileVisitResult visitFile(Path candidate, BasicFileAttributes attrs) throws IOException { String fileName = candidate.getFileName().toString(); if (!fileName.endsWith(completedSuffix) && !fileName.startsWith(""."") && !ignorePattern.matcher(fileName).matches()) { candidateFiles.add(candidate.toFile()); } return FileVisitResult.CONTINUE; } }); } catch (IOException e) { logger.error(""I/O exception occurred while listing directories. "" + ""Files already matched will be returned. "" + directory, e); } return candidateFiles; }"	"  private List<File> getCandidateFiles(File directory) {
    Preconditions.checkNotNull(directory);
    List<File> candidateFiles = new ArrayList<File>();
    if (!directory.isDirectory()) {
      return candidateFiles;
    }

    for (File file : directory.listFiles(filter)) {
      if (file.isDirectory()) {
        candidateFiles.addAll(getCandidateFiles(file));
      } else {
        candidateFiles.add(file);
      }
    }

    return candidateFiles;
  }
"	@param directory the directory to gather files from	@param directory the directory to gather files from	0	1	12	41	233
public List<String> generateCreationCommands(Metadata metadata, boolean createNamespaces, Dialect dialect) { final ArrayList<String> commands = new ArrayList<String>(); doCreation( metadata, createNamespaces, dialect, new Target() { @Override public boolean acceptsImportScriptActions() { return true; } @Override public void prepare() { } @Override public void accept(String action) { commands.add( action ); } @Override public void release() { } } ); return commands; }	"	public List<String> generateCreationCommands(Metadata metadata, boolean createSchemas, Dialect dialect) {
		final ArrayList<String> commands = new ArrayList<String>();
		doCreation(
				metadata,
				createSchemas,
				dialect,
				new Target() {

					@Override
					public boolean acceptsImportScriptActions() {
						return true;
					}

					@Override
					public void prepare() {
					}

					@Override
					public void accept(String action) {
						commands.add( action );
					}

					@Override
					public void release() {
					}
				}
		);
		return commands;
	}
"	@param createNamespaces Should the schema(s)/catalog(s) actually be created as well ( CREATE SCHEMA)?	@param createSchemas Should the schema(s) actually be created as well ( CREATE SCHEMA)?	1	0	9	30	92
protected ArrayList<Timestamp> getTransitions(Timestamp beginning, int[] checks) { ArrayList<Timestamp> list = new ArrayList<>(); Timestamp current = beginning; list.add(current); for (int i = 1; i < checks.length; i++) { current = current.plus(1); int j = checks.length - i - 1; if ((checks[j + 1] == 0 && checks[j] > 0)) list.add(current); if ((checks[j + 1] > 0 && checks[j] == 0)) list.add(current.minus(1)); } if (list.size() % 2 == 1) list.add(current); return list; }	"    protected ArrayList<Long> getTransitions(long beginning, int[] checks)
    {
        long day = DateUtils.millisecondsInOneDay;
        long current = beginning;

        ArrayList<Long> list = new ArrayList<>();
        list.add(current);

        for (int i = 1; i < checks.length; i++)
        {
            current += day;
            int j = checks.length - i - 1;

            if ((checks[j + 1] == 0 && checks[j] > 0)) list.add(current);
            if ((checks[j + 1] > 0 && checks[j] == 0)) list.add(current - day);
        }

        if (list.size() % 2 == 1) list.add(current);

        return list;
    }
"	@param checks the checkmarks, ordered by decresing timestamp	@param checks the checkmarks, ordered by decresing timestamp	0	1	11	20	138
public boolean waitForActivity(Class<? extends Activity> activityClass, int timeout){ final long endTime = SystemClock.uptimeMillis() + timeout; Activity currentActivity = activityUtils.getCurrentActivity(false); while(SystemClock.uptimeMillis() < endTime){ if(currentActivity != null && currentActivity.getClass().equals(activityClass)) return true; currentActivity = activityUtils.getCurrentActivity(); } return false; }	"	public boolean waitForActivity(Class<? extends Activity> clazz, int timeout){
		final long endTime = SystemClock.uptimeMillis() + timeout;
		Activity currentActivity = activityUtils.getCurrentActivity(false);

		while(SystemClock.uptimeMillis() < endTime){
			if(currentActivity != null && currentActivity.getClass().equals(clazz))
				return true;

			currentActivity = activityUtils.getCurrentActivity();
		}
		return false;
	}
"	@param activityClass the class of the  Activity to wait for	"@param clazz the class of the Activity to wait for e.g. ""MyActivity"""	1	0	9	13	71
public boolean waitForDialogToOpen(long timeout, boolean sleepFirst) { final long endTime = SystemClock.uptimeMillis() + timeout; if(sleepFirst) sleeper.sleep(); while (SystemClock.uptimeMillis() < endTime) { if(isDialogOpen()){ return true; } sleeper.sleep(MINISLEEP); } return false; }	"	public boolean waitForDialogToOpen(long timeout) {
		final long endTime = SystemClock.uptimeMillis() + timeout;

		while (SystemClock.uptimeMillis() < endTime) {

			if(isDialogOpen()){
				return true;
			}
		}
		return false;
	}
"	@param timeout the amount of time in milliseconds to wait	@param timeout the amount of time in milliseconds to wait	0	1	8	16	61
public PortletContainer createContainer( String containerName, RequiredContainerServices requiredServices) throws PortletContainerException { return createContainer(containerName, requiredServices, new DefaultOptionalContainerServices()); }	"    public PortletContainer createContainer(String containerName,
                                            PortletContainerServices services)
        throws PortletContainerException {
        return createContainer(containerName, services, new DefaultOptionalServices());
   }
"	@param containerName the name of the portlet container.	@param containerName	1	0	6	10	27
"private HttpSession getMatchingHttpSession(List<HttpCookie> cookies, final HttpSessionTokensSet siteTokens) { // Pre-checks if (sessions.isEmpty()) { return null; } List<HttpSession> matchingSessions = new LinkedList<>(sessions); for (String token : siteTokens.getTokensSet()) { // Get the corresponding cookie from the cookies list HttpCookie matchingCookie = null; for (HttpCookie cookie : cookies) { if (cookie.getName().equals(token)) { matchingCookie = cookie; break; } } // Filter the sessions that do not match the cookie value Iterator<HttpSession> it = matchingSessions.iterator(); while (it.hasNext()) { if (!it.next().matchesToken(token, matchingCookie)) { it.remove(); } } } // Return the matching session if (matchingSessions.size() >= 1) { if (matchingSessions.size() > 1) { log.warn(""Multiple sessions matching the cookies from response for site: "" + getSite() + "". Using first one.""); } return matchingSessions.get(0); } return null; }"	"	private HttpSession getMatchingHttpSession(List<HttpCookie> cookies, final Set<String> tokens) {

		// Pre-checks
		if (sessions.isEmpty()) {
			return null;
		}

		List<HttpSession> matchingSessions = new LinkedList<>(sessions);
		for (String token : tokens) {
			// Get the corresponding cookie from the cookies list
			HttpCookie matchingCookie = null;
			for (HttpCookie cookie : cookies) {
				if (cookie.getName().equals(token)) {
					matchingCookie = cookie;
					break;
				}
			}
			// Filter the sessions that do not match the cookie value
			Iterator<HttpSession> it = matchingSessions.iterator();
			while (it.hasNext()) {
				if (!it.next().matchesToken(token, matchingCookie)) {
					it.remove();
				}
			}
		}

		// Return the matching session
		if (matchingSessions.size() >= 1) {
			if (matchingSessions.size() > 1) {
				log.warn(""Multiple sessions matching the cookies from response for site: "" + getSite()
						+ "". Using first one."");
			}
			return matchingSessions.get(0);
		}
		return null;

	}
"	@param cookies the cookies present in the request header of the message	@param cookies the cookies present in the request header of the message	0	1	11	38	206
public void setInto(ReadWritableTimePeriod duration, Object object) { duration.setTimePeriod((ReadableDuration) object); }	"    public void setInto(ReadWritableDuration duration, Object object) {
        duration.setDuration((ReadableDuration) object);
    }
"	@param object the object to convert, must not be null	@param object the object to convert, must not be null	0	1	6	4	21
"public static CloudEventsMaker create(RecordParser parser, SerializerType contentType, String dataSchemaUriBase) { switch (parser.connectorType()) { case ""mysql"": return new MysqlCloudEventsMaker(parser, contentType, dataSchemaUriBase); case ""postgresql"": return new PostgresCloudEventsMaker(parser, contentType, dataSchemaUriBase); case ""mongodb"": return new MongodbCloudEventsMaker(parser, contentType, dataSchemaUriBase); case ""sqlserver"": return new SqlserverCloudEventsMaker(parser, contentType, dataSchemaUriBase); default: throw new DataException(""No usable CloudEvents converters for connector type \"""" + parser.connectorType() + ""\""""); } }"	"    public static CloudEventsMaker create(RecordParser parser, SerializerType contentType, String schemaUri) {
        switch (parser.connectorType()) {
            case ""mysql"":
                return new MysqlCloudEventsMaker(parser, contentType, schemaUri);
            case ""postgresql"":
                return new PostgresCloudEventsMaker(parser, contentType, schemaUri);
            case ""mongodb"":
                return new MongodbCloudEventsMaker(parser, contentType, schemaUri);
            case ""sqlserver"":
                return new SqlserverCloudEventsMaker(parser, contentType, schemaUri);
            default:
                throw new DataException(""No usable CloudEvents converters for connector type \"""" + parser.connectorType() + ""\"""");
        }
    }
"	@param contentType the data content type of CloudEvents	@param contentType the data content type of CloudEvents	0	1	9	15	118
"protected boolean canImplement(LogicalCalc rel, String relTypeName) { for (RelType relType : relTypes) { if (relType.name.equals(relTypeName)) { return relType.canImplement(rel.getProgram()); } } throw Util.newInternal(""unknown type "" + relTypeName); }"	"  protected boolean canImplement(CalcRel rel, String relTypeName) {
    for (RelType relType : relTypes) {
      if (relType.name.equals(relTypeName)) {
        return relType.canImplement(rel.getProgram());
      }
    }
    throw Util.newInternal(""unknown reltype "" + relTypeName);
  }
"	@param rel Calculation relational expression	@param rel Calculation relational expression	0	1	9	9	54
"public Boolean fakeOuterBooleanSerialize(Boolean booleanPostBody) throws RestClientException { Object postBody = booleanPostBody; String path = UriComponentsBuilder.fromPath(""/fake/outer/boolean"").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { ""*/*"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<Boolean> returnType = new ParameterizedTypeReference<Boolean>() {}; return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }"	"    public Boolean fakeOuterBooleanSerialize(Boolean body) throws RestClientException {
        Object postBody = body;
        
        String path = UriComponentsBuilder.fromPath(""/fake/outer/boolean"").build().toUriString();
        
        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();
        final HttpHeaders headerParams = new HttpHeaders();
        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();

        final String[] accepts = { };
        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);
        final String[] contentTypes = { };
        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);

        String[] authNames = new String[] {  };

        ParameterizedTypeReference<Boolean> returnType = new ParameterizedTypeReference<Boolean>() {};
        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);
    }
"	@param booleanPostBody Input boolean as post body	@param body Input boolean as post body	1	0	8	22	160
public PendingMessageCursor getSubscriberPendingMessageCursor(Broker broker,String clientId, String name, int maxBatchSize, DurableTopicSubscription sub) { StoreDurableSubscriberCursor cursor = new StoreDurableSubscriberCursor(broker,clientId, name, maxBatchSize, sub); cursor.setImmediatePriorityDispatch(isImmediatePriorityDispatch()); return cursor; }	"    public PendingMessageCursor getSubscriberPendingMessageCursor(Broker broker,String clientId, String name, int maxBatchSize, Subscription sub) {
        StoreDurableSubscriberCursor cursor = new StoreDurableSubscriberCursor(broker,clientId, name, maxBatchSize, sub);
        cursor.setImmediatePriorityDispatch(isImmediatePriorityDispatch());
        return cursor;
    }
"	@param maxBatchSize	@param maxBatchSize	0	1	6	6	48
"public void addPet (Pet pet) throws ApiException { Object localVarPostBody = pet; // verify the required parameter 'pet' is set if (pet == null) { throw new ApiException(400, ""Missing the required parameter 'pet' when calling addPet""); } // create path and map variables String localVarPath = ""/pet"".replaceAll(""\\{format\\}"",""json""); // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); // header params Map<String, String> localVarHeaderParams = new HashMap<String, String>(); // form params Map<String, String> localVarFormParams = new HashMap<String, String>(); String[] localVarContentTypes = { }; String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : ""application/json""; if (localVarContentType.startsWith(""multipart/form-data"")) { // file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); localVarPostBody = localVarBuilder.build(); } else { // normal form params } try { String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, ""POST"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType); if(localVarResponse != null){ return ; } else { return ; } } catch (ApiException ex) { throw ex; } }"	"  public void  addPet (Pet body) throws ApiException {
    Object localVarPostBody = body;
    // verify the required parameter 'body' is set
    if (body == null) {
       throw new ApiException(400, ""Missing the required parameter 'body' when calling addPet"");
    }

    // create path and map variables
    String localVarPath = ""/pet"".replaceAll(""\\{format\\}"",""json"");

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    // form params
    Map<String, String> localVarFormParams = new HashMap<String, String>();



    String[] localVarContentTypes = {
      ""application/json"",""application/xml""
    };
    String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : ""application/json"";

    if (localVarContentType.startsWith(""multipart/form-data"")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      localVarPostBody = localVarBuilder.build();
    } else {
      // normal form params
          }

    try {
      String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, ""POST"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType);
      if(localVarResponse != null){
        return ;
      }
      else {
        return ;
      }
    } catch (ApiException ex) {
      throw ex;
    }
  }
"	@param pet Pet object that needs to be added to the store	@param body Pet object that needs to be added to the store	1	0	8	47	247
"public Builder field(UnaryOperator<GraphQLInputObjectField.Builder> builderFunction) { assertNotNull(builderFunction, ""builderFunction should not be null""); GraphQLInputObjectField.Builder builder = GraphQLInputObjectField.newInputObjectField(); builder = builderFunction.apply(builder); return field(builder); }"	"        public Builder field(BuilderFunction<GraphQLInputObjectField.Builder> builderFunction) {
            assertNotNull(builderFunction, ""builderFunction should not be null"");
            GraphQLInputObjectField.Builder builder = GraphQLInputObjectField.newInputObjectField();
            builder = builderFunction.apply(builder);
            return field(builder);
        }
"	@param builderFunction a supplier for the builder impl	@param builderFunction a supplier for the builder impl	0	1	7	7	45
"public ArrayList<TextView> clickInList(int line, int index, boolean longClick, int time) { line--; if(line < 0) line = 0; boolean foundList = waiter.waitForView(ListView.class, index); if (!foundList) Assert.assertTrue(""No ListView with index "" + index + "" is available!"", false); ArrayList<View> views = new ArrayList<View>(); final ListView listView = viewFetcher.getView(ListView.class, null, index); if(listView == null) Assert.assertTrue(""ListView is null!"", false); View view = listView.getChildAt(line); if(view != null){ views = viewFetcher.getViews(view, true); views = RobotiumUtils.removeInvisibleViews(views); clickOnScreen(view, longClick, time); } return RobotiumUtils.filterViews(TextView.class, views); }"	"	public ArrayList<TextView> clickInList(int line, int index) {	
		line--;
		if(line < 0)
			line = 0;

		boolean foundList = waiter.waitForView(ListView.class, index);
		if (!foundList) 
			Assert.assertTrue(""No ListView with index "" + index + "" is available!"", false);

		ArrayList<View> views = new ArrayList<View>();
		final ListView listView = viewFetcher.getView(ListView.class, null, index);
		if(listView == null)
			Assert.assertTrue(""ListView is null!"", false);

		View view = listView.getChildAt(line);
		if(view != null){
			views = viewFetcher.getViews(view, true);
			views = RobotiumUtils.removeInvisibleViews(views);
			clickOnScreen(view);
		}
		return RobotiumUtils.filterViews(TextView.class, views);
	}
"	@param index the index of the list. E.g. Index 1 if two lists are available	@param index the index of the list. E.g. Index 1 if two lists are available	0	1	8	23	160
public Double getNdv(SchemaPath col) { // Stats might not have materialized because of errors. if (!materialized) { return null; } Long ndvCol = ndv.get(col); // Ndv estimation techniques like HLL may over-estimate, hence cap it at rowCount if (ndvCol != null) { return Math.min(ndvCol, rowCount); } return null; }	"  public Double getNdv(String col) {
    // Stats might not have materialized because of errors.
    if (!materialized) {
      return null;
    }
    final String upperCol = col.toUpperCase();
    Long ndvCol = ndv.get(upperCol);
    if (ndvCol == null) {
      ndvCol = ndv.get(SchemaPath.getSimplePath(upperCol).toString());
    }
    // Ndv estimation techniques like HLL may over-estimate, hence cap it at rowCount
    if (ndvCol != null) {
      return Math.min(ndvCol, rowCount);
    }
    return null;
  }
"	@param col - column for which approximate count distinct is desired	@param col - column for which approximate count distinct is desired	0	1	7	13	74
"public String toInstantiationType(Schema schema) { if (ModelUtils.isMapSchema(schema)) { Schema additionalProperties = (Schema) schema.getAdditionalProperties(); String type = additionalProperties.getType(); if (null == type) { LOGGER.error(""No Type defined for Additional Property "" + additionalProperties + ""\n"" // + ""\tIn Property: "" + schema); } String inner = getSchemaType(additionalProperties); return instantiationTypes.get(""map"") + ""<String, "" + inner + "">""; } else if (ModelUtils.isArraySchema(schema)) { ArraySchema arraySchema = (ArraySchema) schema; String inner = getSchemaType(arraySchema.getItems()); return instantiationTypes.get(""array"") + ""<"" + inner + "">""; } else { return null; } }"	"    public String toInstantiationType(Property p) {
        if (p instanceof MapProperty) {
            MapProperty ap = (MapProperty) p;
            Property additionalProperties2 = ap.getAdditionalProperties();
            String type = additionalProperties2.getType();
            if (null == type) {
                LOGGER.error(""No Type defined for Additional Property "" + additionalProperties2 + ""\n"" //
                        + ""\tIn Property: "" + p);
            }
            String inner = getSwaggerType(additionalProperties2);
            return instantiationTypes.get(""map"") + ""<String, "" + inner + "">"";
        } else if (p instanceof ArrayProperty) {
            ArrayProperty ap = (ArrayProperty) p;
            String inner = getSwaggerType(ap.getItems());
            return instantiationTypes.get(""array"") + ""<"" + inner + "">"";
        } else {
            return null;
        }
    }
"	@param schema property schema	@param p Swagger property object	1	0	13	19	151
public long addWrapped(long instant, int months) { return set(instant, Utils.getWrappedValue(get(instant), months, MIN, MAX)); }	"    public long addWrapped(long millis, int months) {
        return set(millis, getWrappedValue(get(millis), months, MIN, MAX));
    }
"	@param months the months to add (can be negative).	@param months the months to add (can be negative).	0	1	7	4	33
public MethodInfo createMethod(MemberID memberID, String[] argNames) { return createMethod(memberID, argNames, null); }	"    public MethodInfo createMethod(Signature signature, String[] argNames) {
        return createMethod(signature, argNames, null);
    }
"	@param memberID the membername and descriptor of the method (classname is ignored).	@param signature the membername and descriptor of the method (classname is ignored).	1	0	5	5	24
public static Predicate<ColumnId> excludeColumns(String columnNames) { return Predicates.excludes(columnNames, ColumnId::toString); }	"    public static Predicate<ColumnId> excludeColumns(String fullyQualifiedTableNames) {
        return Predicates.excludes(fullyQualifiedTableNames, ColumnId::toString);
    }
"	@param columnNames the comma-separated list of column names names to exclude; may be null or empty	@param fullyQualifiedTableNames the comma-separated list of fully-qualified table names to exclude; may be null or empty	1	0	6	4	23
"public boolean putFromLoad(SharedSessionContractImplementor session, Object key, Object value, long txTimestamp, Object version, boolean minimalPutOverride) throws CacheException { if ( !region.checkValid() ) { if ( TRACE_ENABLED ) { log.tracef( ""Region %s not valid"", region.getName() ); } return false; } // In theory, since putForExternalRead is already as minimal as it can // get, we shouldn't be need this check. However, without the check and // without https://issues.jboss.org/browse/ISPN-1986, it's impossible to // know whether the put actually occurred. Knowing this is crucial so // that Hibernate can expose accurate statistics. if ( minimalPutOverride && cache.containsKey( key ) ) { return false; } PutFromLoadValidator.Lock lock = putValidator.acquirePutFromLoadLock(session, key, txTimestamp); if ( lock == null) { if ( TRACE_ENABLED ) { log.tracef( ""Put from load lock not acquired for key %s"", key ); } return false; } try { writeCache.putForExternalRead( key, value ); } finally { putValidator.releasePutFromLoadLock( key, lock); } return true; }"	"	public boolean putFromLoad(SessionImplementor session, Object key, Object value, long txTimestamp, Object version, boolean minimalPutOverride)
			throws CacheException {
		if ( !region.checkValid() ) {
			if ( TRACE_ENABLED ) {
				log.tracef( ""Region %s not valid"", region.getName() );
			}
			return false;
		}

		// In theory, since putForExternalRead is already as minimal as it can
		// get, we shouldn't be need this check. However, without the check and
		// without https://issues.jboss.org/browse/ISPN-1986, it's impossible to
		// know whether the put actually occurred. Knowing this is crucial so
		// that Hibernate can expose accurate statistics.
		if ( minimalPutOverride && cache.containsKey( key ) ) {
			return false;
		}

		PutFromLoadValidator.Lock lock = putValidator.acquirePutFromLoadLock(session, key, txTimestamp);
		if ( lock == null) {
			if ( TRACE_ENABLED ) {
				log.tracef( ""Put from load lock not acquired for key %s"", key );
			}
			return false;
		}

		try {
			writeCache.putForExternalRead( key, value );
		}
		finally {
			putValidator.releasePutFromLoadLock( key, lock);
		}

		return true;
	}
"	@param key The item key	@param key The item key	0	1	9	36	226
"public Collection<Tree> getRelatedNodes(Tree t, Tree root) { if (root.value() == null) { root.setValue(""ROOT""); // todo: cdm: it doesn't seem like this line should be here } Set<Tree> nodeList = new LinkedHashSet<Tree>(); for (TregexPattern p : targetPatterns) { // cdm: I deleted: && nodeList.isEmpty() TregexMatcher m = p.matcher(root); while (m.findAt(t)) { nodeList.add(m.getNode(""target"")); if (DEBUG) { System.err.println(""found "" + this + ""("" + t + "", "" + m.getNode(""target"") + "") using pattern "" + p); for (String nodeName : m.getNodeNames()) { if (nodeName.equals(""target"")) continue; System.err.println("" node "" + nodeName + "": "" + m.getNode(nodeName)); } } } } return nodeList; }"	"  public Collection<TreeGraphNode> getRelatedNodes(TreeGraphNode t, TreeGraphNode root, HeadFinder headFinder) {
    Set<TreeGraphNode> nodeList = new ArraySet<>();
    for (TregexPattern p : targetPatterns) {    // cdm: I deleted: && nodeList.isEmpty()
      // Initialize the TregexMatcher with the HeadFinder so that we
      // can use the same HeadFinder through the entire process of
      // building the dependencies
      TregexMatcher m = p.matcher(root, headFinder);
      while (m.findAt(t)) {
        TreeGraphNode target = (TreeGraphNode) m.getNode(""target"");
        if (target == null) {
          throw new AssertionError(""Expression has no target: "" + p);
        }
        nodeList.add(target);
        if (DEBUG) {
          System.err.println(""found "" + this + ""("" + t + ""-"" + t.headWordNode() + "", "" + m.getNode(""target"") + ""-"" + ((TreeGraphNode) m.getNode(""target"")).headWordNode() + "") using pattern "" + p);
          for (String nodeName : m.getNodeNames()) {
            if (nodeName.equals(""target""))
              continue;
            System.err.println(""  node "" + nodeName + "": "" + m.getNode(nodeName));
          }
        }
      }
    }
    return nodeList;
  }
"	@param t Target for finding governors of t related by this GR	@param t Target for finding dependents of t related by this GR	1	0	18	22	200
public int[] addInField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { int current = values[fieldIndex]; int wrapped = FieldUtils.getWrappedValue (current, valueToAdd, getMinimumValue(instant), getMaximumValue(instant)); return set(instant, fieldIndex, values, wrapped); // adjusts smaller fields }	"    public int[] addInField(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd) {
        int current = values[fieldIndex];
        int wrapped = FieldUtils.getWrappedValue
            (current, valueToAdd, getMinimumValue(instant), getMaximumValue(instant));
        return set(instant, fieldIndex, values, wrapped);  // adjusts smaller fields
    }
"	@param instant the partial instant	@param instant the partial instant	0	1	7	7	66
protected RuntimeException handleAccessDeniedException(AccessDeniedException originalException) { ExceptionToCatchEvent exceptionToCatchEvent = new ExceptionToCatchEvent(originalException); this.beanManager.fireEvent(exceptionToCatchEvent); //the next step won't happen per default since ExceptionHandlerBroadcaster will throw the exception, //because BeforeAccessDeniedExceptionHandler calls #throwOriginal //but allows to suppress it via deactivating BeforeAccessDeniedExceptionHandler //(or a 2nd @BeforeHandles method which overrules the default behavior //(if needed) if (!exceptionToCatchEvent.isHandled()) { throw originalException; } return null; }	"    private boolean handleAccessDeniedException(AccessDeniedException ade) throws AccessDeniedException
    {
        ExceptionToCatchEvent exceptionToCatchEvent = new ExceptionToCatchEvent(ade);

        exceptionToCatchEvent.setOptional(true);

        beanManager.fireEvent(exceptionToCatchEvent);

        if (!exceptionToCatchEvent.isHandled())
        {
            throw ade;
        }

        return false;
    }
"	@param originalException exception thrown by an authorizer	@param ade The previously thrown exception representing a authorization check failure.	1	0	6	18	95
public boolean searchWithTimeoutFor(Class<? extends TextView> viewClass, String regex, int expectedMinimumNumberOfMatches, boolean scroll) { final long endTime = System.currentTimeMillis() + TIMEOUT; while (System.currentTimeMillis() < endTime) { sleeper.sleep(); final boolean foundAnyMatchingView = searchFor(viewClass, regex, expectedMinimumNumberOfMatches, scroll); if (foundAnyMatchingView){ return true; } } return false; }	"	public boolean searchWithTimeoutFor(Class<? extends TextView> viewClass, String regex, int matches, boolean scroll) {
		final long endTime = System.currentTimeMillis() + TIMEOUT;

		while (System.currentTimeMillis() < endTime) {
			sleeper.sleep();
			final boolean foundAnyMatchingView = searchFor(viewClass, regex, matches, scroll);
			if (foundAnyMatchingView){
				return true;
			}
		}

		return false;
	}
"	@param scroll whether scrolling should be performed	@param scroll whether scrolling should be performed	0	1	8	14	72
"public String getTypeName(int code, long length, int precision, int scale) throws HibernateException { String result = typeNames.get( code, length, precision, scale ); if ( result == null ) { throw new HibernateException( ""No type mapping for java.sql.Types code: "" + code + "", length: "" + length ); } return result; }"	"	public String getTypeName(int code, int length, int precision, int scale) throws HibernateException {
		String result = typeNames.get( code, length, precision, scale );
		if ( result == null ) {
			throw new HibernateException(
					""No type mapping for java.sql.Types code: "" +
					code +
					"", length: "" +
					length
			);
		}
		return result;
	}
"	@param code The  java.sql.Types typecode	@param code The java.sql.Types typecode	0	1	10	13	71
"public static long readVLong(DrillBuf buffer, int start, int end) { buffer.readerIndex(start); byte firstByte = buffer.readByte(); int len = decodeVIntSize(firstByte); int availableBytes = (end-start); if (len == 1) { return firstByte; } else if (availableBytes < len) { throw new NumberFormatException(""Expected "" + len + "" bytes but the buffer '"" + DrillStringUtils.toBinaryString(buffer, start, end) + ""' has "" + availableBytes + "" bytes.""); } long longValue = 0; for (int idx = 0; idx < len-1; idx++) { byte byteValue = buffer.readByte(); longValue = longValue << 8; longValue = longValue | (byteValue & 0xFF); } return (isNegativeVInt(firstByte) ? (longValue ^ -1L) : longValue); }"	"    public static long readVLong(ByteBuf buffer, int start, int end) {
      buffer.readerIndex(start);
      byte firstByte = buffer.readByte();
      int len = decodeVIntSize(firstByte);
      int availableBytes = (end-start);
      if (len == 1) {
        return firstByte;
      } else if (availableBytes < len) {
        throw new NumberFormatException(""Expected "" + len + "" bytes but the buffer '""
            + DrillStringUtils.toBinaryString(buffer, start, end) + ""' has  ""
            + availableBytes + "" bytes."");
      }

      long longValue = 0;
      for (int idx = 0; idx < len-1; idx++) {
        byte byteValue = buffer.readByte();
        longValue = longValue << 8;
        longValue = longValue | (byteValue & 0xFF);
      }
      return (isNegativeVInt(firstByte) ? (longValue ^ -1L) : longValue);
    }
"	@param buffer DrillBuf to read from	@param buffer ByteBuf to read from	1	0	14	22	160
"protected FieldValueInfo completeField(ExecutionContext executionContext, ExecutionStrategyParameters parameters, FetchedValue fetchedValue) { Field field = parameters.getField().getSingleField(); GraphQLObjectType parentType = (GraphQLObjectType) parameters.getExecutionStepInfo().getUnwrappedNonNullType(); GraphQLFieldDefinition fieldDef = getFieldDef(executionContext.getGraphQLSchema(), parentType, field); ExecutionStepInfo executionStepInfo = createExecutionStepInfo(executionContext, parameters, fieldDef); Instrumentation instrumentation = executionContext.getInstrumentation(); InstrumentationFieldCompleteParameters instrumentationParams = new InstrumentationFieldCompleteParameters(executionContext, parameters, fieldDef, executionStepInfo, fetchedValue); InstrumentationContext<ExecutionResult> ctxCompleteField = instrumentation.beginFieldComplete( instrumentationParams ); GraphQLCodeRegistry codeRegistry = executionContext.getGraphQLSchema().getCodeRegistry(); Map<String, Object> argumentValues = valuesResolver.getArgumentValues(codeRegistry, fieldDef.getArguments(), field.getArguments(), executionContext.getVariables()); NonNullableFieldValidator nonNullableFieldValidator = new NonNullableFieldValidator(executionContext, executionStepInfo); ExecutionStrategyParameters newParameters = parameters.transform(builder -> builder.executionStepInfo(executionStepInfo) .arguments(argumentValues) .source(fetchedValue.getFetchedValue()) .localContext(fetchedValue.getLocalContext()) .nonNullFieldValidator(nonNullableFieldValidator) ); log.debug(""'{}' completing field '{}'..."", executionContext.getExecutionId(), executionStepInfo.getPath()); FieldValueInfo fieldValueInfo = completeValue(executionContext, newParameters); CompletableFuture<ExecutionResult> executionResultFuture = fieldValueInfo.getFieldValue(); ctxCompleteField.onDispatched(executionResultFuture); executionResultFuture.whenComplete(ctxCompleteField::onCompleted); return fieldValueInfo; }"	"    protected FieldValueInfo completeField(ExecutionContext executionContext, ExecutionStrategyParameters parameters, Object fetchedValue) {
        Field field = parameters.getField().getSingleField();
        GraphQLObjectType parentType = (GraphQLObjectType) parameters.getExecutionStepInfo().getUnwrappedNonNullType();
        GraphQLFieldDefinition fieldDef = getFieldDef(executionContext.getGraphQLSchema(), parentType, field);
        ExecutionStepInfo executionStepInfo = createExecutionStepInfo(executionContext, parameters, fieldDef);

        Instrumentation instrumentation = executionContext.getInstrumentation();
        InstrumentationFieldCompleteParameters instrumentationParams = new InstrumentationFieldCompleteParameters(executionContext, parameters, fieldDef, executionStepInfo, fetchedValue);
        InstrumentationContext<ExecutionResult> ctxCompleteField = instrumentation.beginFieldComplete(
                instrumentationParams
        );

        GraphQLCodeRegistry codeRegistry = executionContext.getGraphQLSchema().getCodeRegistry();
        Map<String, Object> argumentValues = valuesResolver.getArgumentValues(codeRegistry, fieldDef.getArguments(), field.getArguments(), executionContext.getVariables());

        NonNullableFieldValidator nonNullableFieldValidator = new NonNullableFieldValidator(executionContext, executionStepInfo);

        ExecutionStrategyParameters newParameters = parameters.transform(builder ->
                builder.executionStepInfo(executionStepInfo)
                        .arguments(argumentValues)
                        .source(fetchedValue)
                        .nonNullFieldValidator(nonNullableFieldValidator)
        );

        log.debug(""'{}' completing field '{}'..."", executionContext.getExecutionId(), executionStepInfo.getPath());

        FieldValueInfo fieldValueInfo = completeValue(executionContext, newParameters);

        CompletableFuture<ExecutionResult> executionResultFuture = fieldValueInfo.getFieldValue();
        ctxCompleteField.onDispatched(executionResultFuture);
        executionResultFuture.whenComplete(ctxCompleteField::onCompleted);
        return fieldValueInfo;
    }
"	@param fetchedValue the fetched raw value	@param fetchedValue the fetched raw value	0	1	9	35	239
public int[] set(ReadablePartial instant, int fieldIndex, int[] values, String text, Locale locale) { int value = convertText(text, locale); return set(instant, fieldIndex, values, value); }	"    public int[] set(PartialInstant instant, int fieldIndex, int[] values, String text, Locale locale) {
        int value = convertText(text, locale);
        return set(instant, fieldIndex, values, value);
    }
"	@param text the text value to set	@param text the text value to set	0	1	6	5	46
public OuterComposite fakeOuterCompositeSerialize(OuterComposite outerComposite) throws IOException { HttpResponse response = fakeOuterCompositeSerializeForHttpResponse(outerComposite); TypeReference typeRef = new TypeReference<OuterComposite>() {}; return apiClient.getObjectMapper().readValue(response.getContent(), typeRef); }	"    public OuterComposite fakeOuterCompositeSerialize(OuterComposite body) throws IOException {
        HttpResponse response = fakeOuterCompositeSerializeForHttpResponse(body);
        TypeReference typeRef = new TypeReference<OuterComposite>() {};
        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);
    }
"	@param outerComposite Input composite as post body	@param body Input composite as post body	1	0	8	6	43
"public String invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); b.append(""?""); if (queryParams != null){ for (Pair queryParam : queryParams){ if (!queryParam.getName().isEmpty()) { b.append(escapeString(queryParam.getName())); b.append(""=""); b.append(escapeString(queryParam.getValue())); b.append(""&""); } } } String querystring = b.substring(0, b.length() - 1); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(""GET"".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (""POST"".equals(method)) { if (contentType.startsWith(""application/x-www-form-urlencoded"")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (""PUT"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (""DELETE"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, ""unknown method type "" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return """"; } } else { String message = ""error""; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { // e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }"	"  public String invokeAPI(String path, String method, Set<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {
    updateParamsForAuth(authNames, queryParams, headerParams);

    Client client = getClient();

    StringBuilder b = new StringBuilder();
    b.append(""?"");
    if (queryParams != null){
      for (Pair queryParam : queryParams){
        if (!queryParam.getName().isEmpty()) {
          b.append(escapeString(queryParam.getName()));
          b.append(""="");
          b.append(escapeString(queryParam.getValue()));
          b.append(""&"");
        }
      }
    }

    String querystring = b.substring(0, b.length() - 1);

    Builder builder;
    if (accept == null)
      builder = client.resource(basePath + path + querystring).getRequestBuilder();
    else
      builder = client.resource(basePath + path + querystring).accept(accept);

    for(String key : headerParams.keySet()) {
      builder = builder.header(key, headerParams.get(key));
    }
    for(String key : defaultHeaderMap.keySet()) {
      if(!headerParams.containsKey(key)) {
        builder = builder.header(key, defaultHeaderMap.get(key));
      }
    }

    ClientResponse response = null;

    if(""GET"".equals(method)) {
      response = (ClientResponse) builder.get(ClientResponse.class);
    }
    else if (""POST"".equals(method)) {
      if (contentType.startsWith(""application/x-www-form-urlencoded"")) {
        String encodedFormParams = this
            .getXWWWFormUrlencodedParams(formParams);
        response = builder.type(contentType).post(ClientResponse.class,
            encodedFormParams);
      } else if (body == null) {
        response = builder.post(ClientResponse.class, null);
      } else if(body instanceof FormDataMultiPart) {
        response = builder.type(contentType).post(ClientResponse.class, body);
      }
      else
        response = builder.type(contentType).post(ClientResponse.class, serialize(body));
    }
    else if (""PUT"".equals(method)) {
      if (""application/x-www-form-urlencoded"".equals(contentType)) {
          String encodedFormParams = this
              .getXWWWFormUrlencodedParams(formParams);
          response = builder.type(contentType).put(ClientResponse.class,
              encodedFormParams);
      } else if(body == null) {
        response = builder.put(ClientResponse.class, serialize(body));
      } else {
          response = builder.type(contentType).put(ClientResponse.class, serialize(body));
      }
    }
    else if (""DELETE"".equals(method)) {
      if (""application/x-www-form-urlencoded"".equals(contentType)) {
        String encodedFormParams = this
            .getXWWWFormUrlencodedParams(formParams);
        response = builder.type(contentType).delete(ClientResponse.class,
            encodedFormParams);
      } else if(body == null) {
        response = builder.delete(ClientResponse.class);
      } else {
        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));
      }
    }
    else {
      throw new ApiException(500, ""unknown method type "" + method);
    }

    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {
      return null;
    }
    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {
      if(response.hasEntity()) {
        return (String) response.getEntity(String.class);
      }
      else {
        return """";
      }
    }
    else {
      String message = ""error"";
      String respBody = null;
      if(response.hasEntity()) {
        try{
          respBody = String.valueOf(response.getEntity(String.class));
          message = respBody;
        }
        catch (RuntimeException e) {
          // e.printStackTrace();
        }
      }
      throw new ApiException(
                response.getClientResponseStatus().getStatusCode(),
                message,
                response.getHeaders(),
                respBody);
    }
  }
"	"@param method The request method, one of ""GET"", ""POST"", ""PUT"", and ""DELETE"""	"@param method The request method, one of ""GET"", ""POST"", ""PUT"", and ""DELETE"""	0	1	16	113	736
public PMetadata getCache(PGraphics renderer) { return g.getCache(renderer); }	"  public Object getCache(Object parent) {
    return g.getCache(parent);
  }
"	@param renderer The PGraphics renderer associated to the image	@param parent The PGraphics object (or any object, really) associated	1	0	5	4	16
"static EventSource buildEventSource(Context context, CommonTree t) throws FlumeSpecException { ASTNODE type = ASTNODE.valueOf(t.getText()); // convert to enum switch (type) { case SOURCE: { Context ctx = new Context(context); Pair<String, List<String>> idArgs = handleArgs(t, ctx); String sourceType = idArgs.getLeft(); List<String> args = idArgs.getRight(); EventSource src = srcFactory.getSource(ctx, sourceType, args .toArray(new String[0])); if (src == null) { throw new FlumeIdException(""Invalid source: "" + FlumeSpecGen.genEventSource(t)); } return src; } default: throw new FlumeSpecException(""bad parse tree! Expected source but got "" + t.toStringTree()); } }"	"  static EventSource buildEventSource(CommonTree t) throws FlumeSpecException {
    ASTNODE type = ASTNODE.valueOf(t.getText()); // convert to enum
    switch (type) {
    case SOURCE: {
      // TODO thread context through sources
      // Context ctx = new Context(context);
      Context ctx = new Context();
      Pair<String, List<String>> idArgs = handleArgs(t, ctx);
      String sourceType = idArgs.getLeft();
      List<String> args = idArgs.getRight();

      EventSource src = srcFactory.getSource(sourceType, args
          .toArray(new String[0]));
      if (src == null) {
        throw new FlumeIdException(""Invalid source: ""
            + FlumeSpecGen.genEventSource(t));
      }
      return src;
    }
    default:
      throw new FlumeSpecException(""bad parse tree! Expected source but got ""
          + t.toStringTree());
    }
  }
"	@param t	@param t	0	1	12	24	147
"static public IStructuredTextExpert getExpert(String type, StructuredTextEnvironment environment) { IStructuredTextExpert expert; if (environment == null) environment = StructuredTextEnvironment.DEFAULT; synchronized (sharedExperts) { Map experts = (Map) sharedExperts.get(type); if (experts == null) { experts = new HashMap(); // environment -> expert sharedExperts.put(type, experts); } expert = (IStructuredTextExpert) experts.get(environment); if (expert == null) { StructuredTextTypeHandler handler = StructuredTextTypeHandlerFactory.getHandler(type); if (handler == null) throw new IllegalArgumentException(""Invalid type argument""); //$NON-NLS-1$ expert = new StructuredTextImpl(handler, environment, false); experts.put(type, expert); } } return expert; }"	"	static public ISTextExpert getExpert(String type, STextEnvironment environment) {
		ISTextExpert expert;
		if (environment == null)
			environment = STextEnvironment.DEFAULT;
		synchronized (sharedExperts) {
			Map experts = (Map) sharedExperts.get(type);
			if (experts == null) {
				experts = new HashMap(); // environment -> expert
				sharedExperts.put(type, experts);
			}
			expert = (ISTextExpert) experts.get(environment);
			if (expert == null) {
				STextTypeHandler handler = STextTypeHandlerFactory.getHandler(type);
				if (handler == null)
					throw new IllegalArgumentException(""Invalid type argument""); //$NON-NLS-1$
				expert = new STextImpl(handler, environment, false);
				experts.put(type, expert);
			}
		}
		return expert;
	}
"	@param type the identifier for the required type handler. This identifier may be one of those listed in  StructuredTextTypeHandlerFactory or it may be have been registered by a plug-in.	@param type the identifier for the required type handler. This identifier may be one of those listed in STextTypeHandlerFactory or it may be have been registered by a plug-in.	1	0	9	23	140
private ImmutableBitSet factorBitmap(ImmutableBitSet fieldRefBitmap) { ImmutableBitSet.Builder factorRefBitmap = ImmutableBitSet.builder(); for (int field : fieldRefBitmap) { int factor = findRef(field); factorRefBitmap.set(factor); } return factorRefBitmap.build(); }	"  private BitSet factorBitmap(BitSet fieldRefBitmap) {
    BitSet factorRefBitmap = new BitSet(nJoinFactors);
    for (int field : BitSets.toIter(fieldRefBitmap)) {
      int factor = findRef(field);
      factorRefBitmap.set(factor);
    }
    return factorRefBitmap;
  }
"	@param fieldRefBitmap bitmap representing fields referenced	@param fieldRefBitmap bitmap representing fields referenced	0	1	8	9	45
"private Dialect determineDialect(DialectResolutionInfoSource resolutionInfoSource) { if ( resolutionInfoSource == null ) { throw new HibernateException( ""Access to DialectResolutionInfo cannot be null when 'hibernate.dialect' not set"" ); } final DialectResolutionInfo info = resolutionInfoSource.getDialectResolutionInfo(); final Dialect dialect = dialectResolver.resolveDialect( info ); if ( dialect == null ) { throw new HibernateException( ""Unable to determine Dialect to use [name="" + info.getDatabaseName() + "", majorVersion="" + info.getDatabaseMajorVersion() + ""]; user must register resolver or explicitly set 'hibernate.dialect'"" ); } return dialect; }"	"	private Dialect determineDialect(Connection connection) {
		if ( connection == null ) {
			throw new HibernateException( ""Connection cannot be null when 'hibernate.dialect' not set"" );
		}

		try {
			final DatabaseMetaData databaseMetaData = connection.getMetaData();
			final Dialect dialect = dialectResolver.resolveDialect( databaseMetaData );

			if ( dialect == null ) {
				throw new HibernateException(
						""Unable to determine Dialect to use [name="" + databaseMetaData.getDatabaseProductName() +
								"", majorVersion="" + databaseMetaData.getDatabaseMajorVersion() +
								""]; user must register resolver or explicitly set 'hibernate.dialect'""
				);
			}

			return dialect;
		}
		catch ( SQLException sqlException ) {
			throw new HibernateException(
					""Unable to access java.sql.DatabaseMetaData to determine appropriate Dialect to use"",
					sqlException
			);
		}
	}
"	@param resolutionInfoSource Access to DialectResolutionInfo used to resolve the Dialect.	@param connection The configured connection.	1	0	11	19	111
public Response syncSendPacket(Command command, int timeout) throws JMSException { if (isClosed()) { throw new ConnectionClosedException(); } else { if (command.isMessage() && flowControlSleepTime > 0) { try { Thread.sleep(flowControlSleepTime); } catch (InterruptedException e) { } } try { Response response = this.transport.request(command,timeout); if (response.isException()) { ExceptionResponse er = (ExceptionResponse) response; if (er.getException() instanceof JMSException) throw (JMSException) er.getException(); else throw JMSExceptionSupport.create(er.getException()); } return response; } catch (IOException e) { throw JMSExceptionSupport.create(e); } } }	"    public Response syncSendPacket(Command command) throws JMSException {
        if (isClosed()) {
            throw new ConnectionClosedException();
        } else {

            if (command.isMessage() && flowControlSleepTime > 0) {
                try {
                    Thread.sleep(flowControlSleepTime);
                } catch (InterruptedException e) {
                }
            }

            try {
                Response response = this.transport.request(command);
                if (response.isException()) {
                    ExceptionResponse er = (ExceptionResponse) response;
                    if (er.getException() instanceof JMSException)
                        throw (JMSException) er.getException();
                    else
                        throw JMSExceptionSupport.create(er.getException());
                }
                return response;
            } catch (IOException e) {
                throw JMSExceptionSupport.create(e);
            }
        }
    }
"	@param command	@param command	0	1	11	28	136
public PortletContainer createContainer( String containerName, RequiredContainerServices requiredServices) throws PortletContainerException { return createContainer(containerName, requiredServices, new DefaultOptionalContainerServices()); }	"    public PortletContainer createContainer(String containerName,
                                            PortletContainerServices services)
        throws PortletContainerException {
        return createContainer(containerName, services, new DefaultOptionalServices());
   }
"	@param requiredServices the required portlet container services.	@param services	1	0	6	10	27
public static RelNode swap(Join join, boolean swapOuterJoins) { final JoinRelType joinType = join.getJoinType(); if (!swapOuterJoins && joinType != JoinRelType.INNER) { return null; } final RexBuilder rexBuilder = join.getCluster().getRexBuilder(); final RelDataType leftRowType = join.getLeft().getRowType(); final RelDataType rightRowType = join.getRight().getRowType(); final VariableReplacer variableReplacer = new VariableReplacer(rexBuilder, leftRowType, rightRowType); final RexNode oldCondition = join.getCondition(); RexNode condition = variableReplacer.go(oldCondition); // NOTE jvs 14-Mar-2006: We preserve attribute semiJoinDone after the // swap. This way, we will generate one semijoin for the original // join, and one for the swapped join, and no more. This // doesn't prevent us from seeing any new combinations assuming // that the planner tries the desired order (semijoins after swaps). Join newJoin = join.copy(join.getTraitSet(), condition, join.getRight(), join.getLeft(), joinType.swap(), join.isSemiJoinDone()); final List<RexNode> exps = RelOptUtil.createSwappedJoinExprs(newJoin, join, true); return RelOptUtil.createProject( newJoin, exps, join.getRowType().getFieldNames(), true); }	"  public static RelNode swap(JoinRelBase join, boolean swapOuterJoins) {
    final JoinRelType joinType = join.getJoinType();
    if (!swapOuterJoins && joinType != JoinRelType.INNER) {
      return null;
    }
    final RexBuilder rexBuilder = join.getCluster().getRexBuilder();
    final RelDataType leftRowType = join.getLeft().getRowType();
    final RelDataType rightRowType = join.getRight().getRowType();
    final VariableReplacer variableReplacer =
        new VariableReplacer(rexBuilder, leftRowType, rightRowType);
    final RexNode oldCondition = join.getCondition();
    RexNode condition = variableReplacer.go(oldCondition);

    // NOTE jvs 14-Mar-2006: We preserve attribute semiJoinDone after the
    // swap.  This way, we will generate one semijoin for the original
    // join, and one for the swapped join, and no more.  This
    // doesn't prevent us from seeing any new combinations assuming
    // that the planner tries the desired order (semijoins after swaps).
    JoinRelBase newJoin =
        join.copy(join.getTraitSet(), condition, join.getRight(),
            join.getLeft(), joinType.swap(), join.isSemiJoinDone());
    final List<RexNode> exps =
        RelOptUtil.createSwappedJoinExprs(newJoin, join, true);
    return RelOptUtil.createProject(
        newJoin,
        exps,
        join.getRowType().getFieldNames(),
        true);
  }
"	@param join join to be swapped	@param join join to be swapped	0	1	6	30	237
public Activity getCurrentActivity(boolean shouldSleepFirst) { if(shouldSleepFirst){ RobotiumUtils.sleep(); inst.waitForIdleSync(); } Boolean found = false; if (activityMonitor != null) { if (activityMonitor.getLastActivity() != null) activity = activityMonitor.getLastActivity(); } for(Activity storedActivity : activityList){ if (storedActivity.getClass().getName().equals( activity.getClass().getName())) found = true; } if (found) return activity; else { activityList.add(activity); return activity; } }	"	public Activity getCurrentActivity(int pause) {
		if(pause > 0){
			RobotiumUtils.sleep(pause);
			inst.waitForIdleSync();
		}
		Boolean found = false;
		if (activityMonitor != null) {
			if (activityMonitor.getLastActivity() != null)
				activity = activityMonitor.getLastActivity();
		}
		for(Activity storedActivity : activityList){
			if (storedActivity.getClass().getName().equals(
					activity.getClass().getName()))
				found = true;
		}
		if (found)
			return activity;
		else {
			activityList.add(activity);
			return activity;
		}
	}
"	@param shouldSleepFirst whether to sleep a default pause first	@param pause the time to pause in milliseconds	1	0	9	23	103
public Iterator keyIterator() { return new KeyIterator( map.keySet().iterator() ); }	"	public static Iterator keyIterator(Map map) {
		return ( (IdentityMap) map ).keyIterator();
	}
"	@param map The map of entries	@param map The map of entries	0	1	6	4	20
static protected float getFloatWithUnit(PNode element, String attribute) { String val = element.getString(attribute); return (val == null) ? 0 : parseUnitSize(val); }	"  static protected float getFloatWithUnit(XMLElement element, String attribute) {
    String val = element.getString(attribute);
    return (val == null) ? 0 : parseUnitSize(val);
  }
"	@param element what to parse	@param element what to parse	0	1	6	5	34
"private static CorefChain fromProto(CoreNLPProtos.CorefChain proto, Annotation partialDocument) { // Get chain ID int cid = proto.getChainID(); // Get mentions Map<IntPair, Set<CorefChain.CorefMention>> mentions = new HashMap<IntPair, Set<CorefChain.CorefMention>>(); CorefChain.CorefMention representative = null; for (int i = 0; i < proto.getMentionCount(); ++i) { CoreNLPProtos.CorefChain.CorefMention mentionProto = proto.getMention(i); // Create mention StringBuilder mentionSpan = new StringBuilder(); List<CoreLabel> sentenceTokens = partialDocument.get(SentencesAnnotation.class).get(mentionProto.getSentenceIndex()).get(TokensAnnotation.class); for (int k = mentionProto.getStartIndex(); k < mentionProto.getEndIndex(); ++k) { mentionSpan.append("" "").append(sentenceTokens.get(k).word()); } // Set the coref cluster id for the token CorefChain.CorefMention mention = new CorefChain.CorefMention( Dictionaries.MentionType.valueOf(mentionProto.getMentionType()), Dictionaries.Number.valueOf(mentionProto.getNumber()), Dictionaries.Gender.valueOf(mentionProto.getGender()), Dictionaries.Animacy.valueOf(mentionProto.getAnimacy()), mentionProto.getStartIndex() + 1, mentionProto.getEndIndex() + 1, mentionProto.getHeadIndex() + 1, cid, mentionProto.getMentionID(), mentionProto.getSentenceIndex() + 1, new IntTuple(new int[]{ mentionProto.getSentenceIndex() + 1, mentionProto.getPosition() }), mentionSpan.substring(1)); // Register mention IntPair key = new IntPair(mentionProto.getSentenceIndex() - 1, mentionProto.getHeadIndex() - 1); if (!mentions.containsKey(key)) { mentions.put(key, new HashSet<CorefChain.CorefMention>()); } mentions.get(key).add(mention); // Check for representative if (proto.hasRepresentative() && i == proto.getRepresentative()) { representative = mention; } } // Return return new CorefChain(cid, mentions, representative); }"	"  private static CorefChain fromProto(CoreMapProtos.CorefChain proto, Annotation partialDocument) {
    // Get chain ID
    int cid = proto.getChainID();
    // Get mentions
    Map<IntPair, Set<CorefChain.CorefMention>> mentions = new HashMap<IntPair, Set<CorefChain.CorefMention>>();
    CorefChain.CorefMention representative = null;
    for (int i = 0; i < proto.getMentionCount(); ++i) {
      CoreMapProtos.CorefChain.CorefMention mentionProto = proto.getMention(i);
      // Create mention
      StringBuilder mentionSpan = new StringBuilder();
      List<CoreLabel> sentenceTokens = partialDocument.get(SentencesAnnotation.class).get(mentionProto.getSentenceIndex()).get(TokensAnnotation.class);
      for (int k = mentionProto.getStartIndex(); k < mentionProto.getEndIndex(); ++k) {
        mentionSpan.append("" "").append(sentenceTokens.get(k).word());
      }
      sentenceTokens.get(mentionProto.getHeadIndex()).set(CorefClusterIdAnnotation.class, cid);
      CorefChain.CorefMention mention = new CorefChain.CorefMention(
          Dictionaries.MentionType.valueOf(mentionProto.getMentionType()),
          Dictionaries.Number.valueOf(mentionProto.getNumber()),
          Dictionaries.Gender.valueOf(mentionProto.getGender()),
          Dictionaries.Animacy.valueOf(mentionProto.getAnimacy()),
          mentionProto.getStartIndex() + 1,
          mentionProto.getEndIndex() + 1,
          mentionProto.getHeadIndex() + 1,
          cid,
          mentionProto.getMentionID(),
          mentionProto.getSentenceIndex() + 1,
          new IntTuple(new int[]{ mentionProto.getSentenceIndex() + 1, mentionProto.getPosition() }),
          mentionSpan.substring(1));
      // Register mention
      IntPair key = new IntPair(mentionProto.getSentenceIndex() - 1, mentionProto.getHeadIndex() - 1);
      if (!mentions.containsKey(key)) { mentions.put(key, new HashSet<CorefChain.CorefMention>()); }
      mentions.get(key).add(mention);
      // Check for representative
      if (proto.hasRepresentative() && i == proto.getRepresentative()) {
        representative = mention;
      }
    }
    // Return
    return new CorefChain(cid, mentions, representative);
  }
"	@param partialDocument A partial document, which must contain  SentencesAnnotation and  TokensAnnotation in order to fill in the mention span strings.	@param partialDocument A partial document, which must contain SentencesAnnotation and TokensAnnotation in order to fill in the mention span strings.	0	1	13	41	369
public WebDriver frame(final String nameOrIdOrIndex) { try { // 1.) try to find frame in current window ... currentWindow = findFrame(currentWindow, nameOrIdOrIndex); } catch (NoSuchFrameException ignored) { // 2.) try to find frame in top window ... final WebWindow topWindow = currentWindow.getTopWindow(); currentWindow = findFrame(topWindow, nameOrIdOrIndex); } return HtmlUnitDriver.this; }	"    public WebDriver frame(final String name) {
      WebWindow window = currentWindow.getTopWindow();

      // Walk over all parts of the frame identifier, each time looking for a frame
      // with a name or ID matching this part of the identifier (separated by '.').
      String[] frames = name.split(""\\."");
      for (int i = 0; i < frames.length; ++i) {
        final String currentFrameId = frames[i];
        final HtmlPage page = (HtmlPage) window.getEnclosedPage();
        
        if (isNumericFrameIdValid(currentFrameId, page)) {
          window = getWindowByNumericFrameId(currentFrameId, page);
        } else {
          // Numeric frame ID is not valid - could be either because the identifier
          // was numeric and not valid OR the number that was given is actually a frame
          // name, not an index.
          
          boolean nextFrameFound = false;
          for (final FrameWindow frameWindow : page.getFrames()) {
            final String frameName = frameWindow.getName();
            final String frameId = frameWindow.getFrameElement().getId();
            final String remainingFrameId = joinFrom(frames, i, '.');
            if (frameName.equals(remainingFrameId) || frameId.equals(remainingFrameId)) {
              currentWindow = frameWindow;
              return HtmlUnitDriver.this;
            }
            if (frameName.equals(currentFrameId) || frameId.equals(currentFrameId)) {
              window = frameWindow;
              nextFrameFound = true;
            }
          } // End for.
          
          if (!nextFrameFound) {
            throw new NoSuchFrameException(""Cannot find frame: "" + name);
          }
        } // End else

      } // End for
      
      currentWindow = window;
      return HtmlUnitDriver.this;
    }
"	@param nameOrIdOrIndex Frame name, id, (zero-based) index, or a concatenation of frame identifiers that uniquely point to a specific frame.	@param name Frame index, name or a concatenation of frame identifiers that uniquely point to a specific frame.	1	0	8	12	70
"public String toDefaultValue(Schema p) { if (ModelUtils.isBooleanSchema(p)) { if (p.getDefault() != null) { return p.getDefault().toString(); } } else if (ModelUtils.isDateSchema(p)) { // TODO } else if (ModelUtils.isDateTimeSchema(p)) { // TODO } else if (ModelUtils.isNumberSchema(p)) { if (p.getDefault() != null) { return p.getDefault().toString(); } } else if (ModelUtils.isIntegerSchema(p)) { if (p.getDefault() != null) { return p.getDefault().toString(); } } else if (ModelUtils.isStringSchema(p)) { if (p.getDefault() != null) { return ""'"" + p.getDefault() + ""'""; } } return null; }"	"    public String toDefaultValue(Property p) {
        if (p instanceof StringProperty) {
            StringProperty dp = (StringProperty) p;
            if (dp.getDefault() != null) {
                return ""'"" + dp.getDefault() + ""'"";
            }
        } else if (p instanceof BooleanProperty) {
            BooleanProperty dp = (BooleanProperty) p;
            if (dp.getDefault() != null) {
                return dp.getDefault().toString();
            }
        } else if (p instanceof DateProperty) {
            // TODO
        } else if (p instanceof DateTimeProperty) {
            // TODO
        } else if (p instanceof DoubleProperty) {
            DoubleProperty dp = (DoubleProperty) p;
            if (dp.getDefault() != null) {
                return dp.getDefault().toString();
            }
        } else if (p instanceof FloatProperty) {
            FloatProperty dp = (FloatProperty) p;
            if (dp.getDefault() != null) {
                return dp.getDefault().toString();
            }
        } else if (p instanceof IntegerProperty) {
            IntegerProperty dp = (IntegerProperty) p;
            if (dp.getDefault() != null) {
                return dp.getDefault().toString();
            }
        } else if (p instanceof LongProperty) {
            LongProperty dp = (LongProperty) p;
            if (dp.getDefault() != null) {
                return dp.getDefault().toString();
            }
        }

        return null;
    }
"	@param p property schema	@param p Swagger property object	1	0	15	26	168
public JoinSequence createJoinSequence(boolean implicit, AssociationType associationType, String tableAlias, JoinType joinType, String[] columns) { JoinSequence joinSequence = createJoinSequence(); joinSequence.setUseThetaStyle( implicit ); // Implicit joins use theta style (WHERE pk = fk), explicit joins use JOIN (after from) joinSequence.addJoin( associationType, tableAlias, joinType, columns ); return joinSequence; }	"	public JoinSequence createJoinSequence(boolean implicit, AssociationType associationType, String tableAlias, int joinType, String[] columns) {
		JoinSequence joinSequence = createJoinSequence();
		joinSequence.setUseThetaStyle( implicit );	// Implicit joins use theta style (WHERE pk = fk), explicit joins use JOIN (after from)
		joinSequence.addJoin( associationType, tableAlias, joinType, columns );
		return joinSequence;
	}
"	@param columns The columns making up the condition of the join.	@param columns The columns making up the condition of the join.	0	1	5	7	71
"public boolean remove(final BaseDownloadTask willRemoveDownload, final int removeByStatus) { boolean succeed; synchronized (list) { succeed = list.remove(willRemoveDownload); } if (succeed) { //  switch (removeByStatus) { case FileDownloadStatus.warn: willRemoveDownload.getDriver().notifyWarn(); break; case FileDownloadStatus.error: willRemoveDownload.getDriver().notifyError(); break; case FileDownloadStatus.paused: willRemoveDownload.getDriver().notifyPaused(); break; case FileDownloadStatus.completed: Throwable ex = null; try{ willRemoveDownload.getDriver().notifyBlockComplete(); }catch (Throwable e){ ex = e; } if (ex != null) { willRemoveDownload.setStatus(FileDownloadStatus.error); willRemoveDownload.setEx(ex); willRemoveDownload.getDriver().notifyError(); } else { willRemoveDownload.getDriver().notifyCompleted(); } break; } } else { FileDownloadLog.e(this, ""remove error, not exist: %s"", willRemoveDownload); } return succeed; }"	"    public boolean remove(final BaseFileDownloadInternal willRemoveDownload, final int removeByStatus) {
        boolean succeed;
        synchronized (list) {
            succeed = list.remove(willRemoveDownload);
        }

        if (succeed) {
            // 
            switch (removeByStatus) {
                case FileDownloadStatus.warn:
                    willRemoveDownload.getDriver().notifyWarn();
                    break;
                case FileDownloadStatus.error:
                    willRemoveDownload.getDriver().notifyError();
                    break;
                case FileDownloadStatus.paused:
                    willRemoveDownload.getDriver().notifyPaused();
                    break;
                case FileDownloadStatus.completed:
                    Throwable ex = null;
                    try{
                        willRemoveDownload.getDriver().notifyBlockComplete();
                    }catch (Throwable e){
                        ex = e;
                    }

                    if (ex != null) {
                        willRemoveDownload.setStatus(FileDownloadStatus.error);
                        willRemoveDownload.setEx(ex);
                        willRemoveDownload.getDriver().notifyError();
                    } else {
                        willRemoveDownload.getDriver().notifyCompleted();
                    }
                    break;
            }

        } else {
            FileDownloadLog.e(this, ""remove error, not exist: %s"", willRemoveDownload);
        }

        return succeed;
    }
"	@param removeByStatus must remove by status  com.liulishuo.filedownloader.model.FileDownloadStatus#warn  com.liulishuo.filedownloader.model.FileDownloadStatus#paused  com.liulishuo.filedownloader.model.FileDownloadStatus#completed  com.liulishuo.filedownloader.model.FileDownloadStatus#error	@param removeByStatus must remove by status com.liulishuo.filedownloader.model.FileDownloadStatus#warn com.liulishuo.filedownloader.model.FileDownloadStatus#paused com.liulishuo.filedownloader.model.FileDownloadStatus#completed com.liulishuo.filedownloader.model.FileDownloadStatus#error	0	1	11	43	185
public int compareTo(ReadableDuration other) { long thisMillis = this.getMillis(); long otherMillis = other.getMillis(); // cannot do (thisMillis - otherMillis) as it can overflow if (thisMillis < otherMillis) { return -1; } if (thisMillis > otherMillis) { return 1; } return 0; }	"    public int compareTo(Object obj) {
        // Comparable contract means we cannot handle null or other types gracefully
        ReadableDuration thisDuration = (ReadableDuration) this;
        ReadableDuration otherDuration = (ReadableDuration) obj;
        
        long thisMillis = thisDuration.getMillis();
        long otherMillis = otherDuration.getMillis();
        
        // cannot do (thisMillis - otherMillis) as it can overflow
        if (thisMillis < otherMillis) {
            return -1;
        }
        if (thisMillis > otherMillis) {
            return 1;
        }
        return 0;
    }
"	@param other a duration to check against	@param obj a duration to check against	1	0	6	14	60
private SQLResponse execute(String correctedSql, SQLRequest sqlRequest) throws Exception { Connection conn = null; Statement stat = null; ResultSet resultSet = null; Boolean isPushDown = false; List<List<String>> results = Lists.newArrayList(); List<SelectedColumnMeta> columnMetas = Lists.newArrayList(); try { conn = cacheService.getOLAPDataSource(sqlRequest.getProject()).getConnection(); // special case for prepare query. if (BackdoorToggles.getPrepareOnly()) { return getPrepareOnlySqlResponse(correctedSql, conn, isPushDown, results, columnMetas); } stat = conn.createStatement(); processStatementAttr(stat, sqlRequest); resultSet = stat.executeQuery(correctedSql); ResultSetMetaData metaData = resultSet.getMetaData(); int columnCount = metaData.getColumnCount(); // Fill in selected column meta for (int i = 1; i <= columnCount; ++i) { columnMetas.add(new SelectedColumnMeta(metaData.isAutoIncrement(i), metaData.isCaseSensitive(i), metaData.isSearchable(i), metaData.isCurrency(i), metaData.isNullable(i), metaData.isSigned(i), metaData.getColumnDisplaySize(i), metaData.getColumnLabel(i), metaData.getColumnName(i), metaData.getSchemaName(i), metaData.getCatalogName(i), metaData.getTableName(i), metaData.getPrecision(i), metaData.getScale(i), metaData.getColumnType(i), metaData.getColumnTypeName(i), metaData.isReadOnly(i), metaData.isWritable(i), metaData.isDefinitelyWritable(i))); } // fill in results while (resultSet.next()) { List<String> oneRow = Lists.newArrayListWithCapacity(columnCount); for (int i = 0; i < columnCount; i++) { oneRow.add((resultSet.getString(i + 1))); } results.add(oneRow); } } catch (SQLException sqlException) { isPushDown = PushDownUtil.doPushDownQuery(sqlRequest.getProject(), correctedSql, results, columnMetas, sqlException); } finally { close(resultSet, stat, conn); } return getSqlResponse(isPushDown, results, columnMetas); }	"    private SQLResponse execute(String correctedSql, SQLRequest sqlRequest, Connection conn) throws Exception {
        Statement stat = null;
        ResultSet resultSet = null;
        Boolean isPushDown = false;

        List<List<String>> results = Lists.newArrayList();
        List<SelectedColumnMeta> columnMetas = Lists.newArrayList();

        try {

            // special case for prepare query. 
            if (BackdoorToggles.getPrepareOnly()) {
                return getPrepareOnlySqlResponse(correctedSql, conn, isPushDown, results, columnMetas);
            }

            stat = conn.createStatement();
            processStatementAttr(stat, sqlRequest);
            resultSet = stat.executeQuery(correctedSql);

            ResultSetMetaData metaData = resultSet.getMetaData();
            int columnCount = metaData.getColumnCount();

            // Fill in selected column meta
            for (int i = 1; i <= columnCount; ++i) {
                columnMetas.add(new SelectedColumnMeta(metaData.isAutoIncrement(i), metaData.isCaseSensitive(i),
                        metaData.isSearchable(i), metaData.isCurrency(i), metaData.isNullable(i), metaData.isSigned(i),
                        metaData.getColumnDisplaySize(i), metaData.getColumnLabel(i), metaData.getColumnName(i),
                        metaData.getSchemaName(i), metaData.getCatalogName(i), metaData.getTableName(i),
                        metaData.getPrecision(i), metaData.getScale(i), metaData.getColumnType(i),
                        metaData.getColumnTypeName(i), metaData.isReadOnly(i), metaData.isWritable(i),
                        metaData.isDefinitelyWritable(i)));
            }

            // fill in results
            while (resultSet.next()) {
                List<String> oneRow = Lists.newArrayListWithCapacity(columnCount);
                for (int i = 0; i < columnCount; i++) {
                    oneRow.add((resultSet.getString(i + 1)));
                }

                results.add(oneRow);
            }
        } catch (SQLException sqlException) {
            isPushDown = PushDownUtil.doPushDownQuery(sqlRequest.getProject(), correctedSql, conn.getSchema(), results,
                    columnMetas, sqlException);
            if (!isPushDown) {
                throw sqlException;
            }
        } finally {
            close(resultSet, stat, null);//conn is passed in, not my duty to close
        }

        return getSqlResponse(isPushDown, results, columnMetas);
    }
"	@param correctedSql	@param correctedSql	0	1	12	54	376
public static Criterion between(String propertyName, Object low, Object high) { return new BetweenExpression( propertyName, low, high ); }	"	public static Criterion between(String propertyName, Object lo, Object hi) {
		return new BetweenExpression( propertyName, lo, hi );
	}
"	@param low The low value	@param lo The low value	1	0	5	4	27
public int create(Object[] row, Instant ts, int rowNumber, int numberOfRows) throws InterruptedException { return converter.insert(source, row, rowNumber, numberOfRows, includedColumns, ts, consumer); }	"        public int create(Object[] row, long ts, int rowNumber, int numberOfRows) throws InterruptedException {
            return converter.insert(source, row, rowNumber, numberOfRows, includedColumns, ts, consumer);
        }
"	@param numberOfRows the total number of rows to be read; must be 1 or more	@param numberOfRows the total number of rows to be read; must be 1 or more	0	1	5	4	41
public static BooleanOperation predicate(Operator operation, Expression<?>... args) { return new BooleanOperation(operation, args); }	"    public static BooleanOperation predicate(Operator operator, Expression<?>... args) {
        return new BooleanOperation(operator, args);
    }
"	@param args	@param args operation arguments	1	0	5	4	23
"public PushDownJoinConditionRule(RelFactories.FilterFactory filterFactory) { super(RelOptRule.operand(JoinRelBase.class, RelOptRule.any()), ""PushFilterPastJoinRule:no-filter"", true, filterFactory); }"	"    public PushDownJoinConditionRule() {
      super(RelOptRule.operand(JoinRelBase.class, RelOptRule.any()),
          ""PushFilterPastJoinRule:no-filter"",
          true);
    }
"	@param rel the RelNode that the filter will be put on top of	@param rel the RelNode that the filter will be put on top of	0	1	7	6	36
"public BroadcastAction filter(Object originalMessage, Object o) { if (o instanceof String){ String message = (String)o; // Avoid re-broadcasting if (!receivedMessages.remove(message)) { try { jchannel.send(new Message(null, null, message)); } catch (ChannelException e) { logger.warn(""failed to send message"", e); } } return new BroadcastAction(message); } else { return new BroadcastAction(o); } }"	"    public BroadcastAction filter(Object originalMessage, Object message) {
        // Avoid re-broadcasting
        if (!receivedMessages.remove(message)) {
            try {
                jchannel.send(new Message(null, null, new JGroupsBroadcaster.BroadcastMessage(bc.getID(), message)));
            } catch (ChannelException e) {
                logger.warn(""failed to send message"", e);
            }
        }
        return new BroadcastAction(message);
    }
"	@param o the message to broadcast.	@param message the message to broadcast.	1	0	11	17	98
"public String invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); b.append(""?""); if (queryParams != null){ for (Pair queryParam : queryParams){ if (!queryParam.getName().isEmpty()) { b.append(escapeString(queryParam.getName())); b.append(""=""); b.append(escapeString(queryParam.getValue())); b.append(""&""); } } } String querystring = b.substring(0, b.length() - 1); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(""GET"".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (""POST"".equals(method)) { if (contentType.startsWith(""application/x-www-form-urlencoded"")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (""PUT"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (""DELETE"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, ""unknown method type "" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return """"; } } else { String message = ""error""; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { // e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }"	"  public String invokeAPI(String path, String method, Set<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {
    updateParamsForAuth(authNames, queryParams, headerParams);

    Client client = getClient();

    StringBuilder b = new StringBuilder();
    b.append(""?"");
    if (queryParams != null){
      for (Pair queryParam : queryParams){
        if (!queryParam.getName().isEmpty()) {
          b.append(escapeString(queryParam.getName()));
          b.append(""="");
          b.append(escapeString(queryParam.getValue()));
          b.append(""&"");
        }
      }
    }

    String querystring = b.substring(0, b.length() - 1);

    Builder builder;
    if (accept == null)
      builder = client.resource(basePath + path + querystring).getRequestBuilder();
    else
      builder = client.resource(basePath + path + querystring).accept(accept);

    for(String key : headerParams.keySet()) {
      builder = builder.header(key, headerParams.get(key));
    }
    for(String key : defaultHeaderMap.keySet()) {
      if(!headerParams.containsKey(key)) {
        builder = builder.header(key, defaultHeaderMap.get(key));
      }
    }

    ClientResponse response = null;

    if(""GET"".equals(method)) {
      response = (ClientResponse) builder.get(ClientResponse.class);
    }
    else if (""POST"".equals(method)) {
      if (contentType.startsWith(""application/x-www-form-urlencoded"")) {
        String encodedFormParams = this
            .getXWWWFormUrlencodedParams(formParams);
        response = builder.type(contentType).post(ClientResponse.class,
            encodedFormParams);
      } else if (body == null) {
        response = builder.post(ClientResponse.class, null);
      } else if(body instanceof FormDataMultiPart) {
        response = builder.type(contentType).post(ClientResponse.class, body);
      }
      else
        response = builder.type(contentType).post(ClientResponse.class, serialize(body));
    }
    else if (""PUT"".equals(method)) {
      if (""application/x-www-form-urlencoded"".equals(contentType)) {
          String encodedFormParams = this
              .getXWWWFormUrlencodedParams(formParams);
          response = builder.type(contentType).put(ClientResponse.class,
              encodedFormParams);
      } else if(body == null) {
        response = builder.put(ClientResponse.class, serialize(body));
      } else {
          response = builder.type(contentType).put(ClientResponse.class, serialize(body));
      }
    }
    else if (""DELETE"".equals(method)) {
      if (""application/x-www-form-urlencoded"".equals(contentType)) {
        String encodedFormParams = this
            .getXWWWFormUrlencodedParams(formParams);
        response = builder.type(contentType).delete(ClientResponse.class,
            encodedFormParams);
      } else if(body == null) {
        response = builder.delete(ClientResponse.class);
      } else {
        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));
      }
    }
    else {
      throw new ApiException(500, ""unknown method type "" + method);
    }

    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {
      return null;
    }
    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {
      if(response.hasEntity()) {
        return (String) response.getEntity(String.class);
      }
      else {
        return """";
      }
    }
    else {
      String message = ""error"";
      String respBody = null;
      if(response.hasEntity()) {
        try{
          respBody = String.valueOf(response.getEntity(String.class));
          message = respBody;
        }
        catch (RuntimeException e) {
          // e.printStackTrace();
        }
      }
      throw new ApiException(
                response.getClientResponseStatus().getStatusCode(),
                message,
                response.getHeaders(),
                respBody);
    }
  }
"	@param accept The request's Accept header	@param accept The request's Accept header	0	1	16	113	736
public CloseableIterator<Tuple> iterate(Expression<?>... args) { return iterate(queryMixin.createProjection(args)); }	"    public CloseableIterator<T> iterate() {
        try {
            Expression<T> projection = (Expression<T>)queryMixin.getMetadata().getProjection();
            return new IteratorAdapter<T>(queryEngine.list(getMetadata(), iterables, projection).iterator());
        } finally {
            reset();
        }
    }
"	@param alias	@param alias alias for the joint target	1	0	6	4	21
public Tree apply(List<? extends HasWord> lst) { return parse(lst); }	"  public Tree apply(List<? extends HasWord> words) {
    return parse(words);
  }
"	@param in The input Sentence/List/String	@param words The input sentence (a List of words)	1	0	6	4	18
"public Action resumed(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { logger.debug(""(resumed) invoked:\n HttpServletRequest: {}\n HttpServletResponse: {}"", request, response); return action(request, response); }"	"    public Action resumed(HttpServletRequest req, HttpServletResponse res)
            throws IOException, ServletException {
        if (logger.isLoggable(Level.FINE)) {
            logger.fine(""(resumed) invoked:\n HttpServletRequest: "" + req
                    + ""\n HttpServletResponse: "" + res);
        }
        return action(req, res);
    }
"	@param request the  HttpServletRequest	@param req the HttpServletRequest	1	0	5	6	52
"public boolean isNormalized(Litmus litmus, RexBuilder rexBuilder) { final RexProgram normalizedProgram = normalize(rexBuilder, false); String normalized = normalizedProgram.toString(); String string = toString(); if (!normalized.equals(string)) { return litmus.fail(""Program is not normalized:\n"" + ""program: "" + string + ""\n"" + ""normalized: "" + normalized + ""\n""); } return litmus.succeed(); }"	"  public boolean isNormalized(boolean fail, RexBuilder rexBuilder) {
    final RexProgram normalizedProgram =
        RexProgramBuilder.normalize(rexBuilder, this);
    String normalized = normalizedProgram.toString();
    String string = toString();
    if (!normalized.equals(string)) {
      assert !fail
          : ""Program is not normalized:\n""
          + ""program:    "" + string + ""\n""
          + ""normalized: "" + normalized + ""\n"";
      return false;
    }
    return true;
  }
"	@param litmus What to do if an error is detected (program is not in canonical form)	@param fail Whether to throw an assertion error if not in canonical form	1	0	13	12	91
protected SourceInfo update(Long lsn, Long useconds, Long txId) { this.lsn = lsn; this.useconds = useconds; this.txId = txId; return this; }	"    protected SourceInfo update(Long lsn, Long useconds, Integer txId) {
        this.lsn = lsn;
        this.useconds = useconds;
        this.txId = txId;
        return this;
    }
"	@param txId the ID of the transaction that generated the transaction; may be null if this information nis not available	@param txId the ID of the transaction that generated the transaction; may be null if this information nis not available	0	1	6	7	30
private RexNode convertUsing(SqlValidatorNamespace leftNamespace, SqlValidatorNamespace rightNamespace, List<String> nameList) { final List<RexNode> list = Lists.newArrayList(); for (String name : nameList) { List<RexNode> operands = new ArrayList<>(); int offset = 0; for (SqlValidatorNamespace n : ImmutableList.of(leftNamespace, rightNamespace)) { final RelDataType rowType = n.getRowType(); final RelDataTypeField field = catalogReader.field(rowType, name); operands.add(rexBuilder.makeInputRef(field.getType(), offset + field.getIndex())); offset += rowType.getFieldList().size(); } list.add(rexBuilder.makeCall(SqlStdOperatorTable.EQUALS, operands)); } return RexUtil.composeConjunction(rexBuilder, list, false); }	"    private RexNode convertUsing(RelNode leftRel, RelNode rightRel, List<String> nameList) {
        final List<RexNode> list = Lists.newArrayList();
        for (String name : nameList) {
            final RelDataType leftRowType = leftRel.getRowType();
            RelDataTypeField leftField = catalogReader.field(leftRowType, name);
            RexNode left = rexBuilder.makeInputRef(leftField.getType(), leftField.getIndex());
            final RelDataType rightRowType = rightRel.getRowType();
            RelDataTypeField rightField = catalogReader.field(rightRowType, name);
            RexNode right = rexBuilder.makeInputRef(rightField.getType(), leftRowType.getFieldList().size() + rightField.getIndex());
            RexNode equalsCall = rexBuilder.makeCall(SqlStdOperatorTable.EQUALS, left, right);
            list.add(equalsCall);
        }
        return RexUtil.composeConjunction(rexBuilder, list, false);
    }
"	@param rightNamespace Namespace of right input to join	@param rightRel Right input to the join	1	0	11	16	134
private boolean scroll(Direction direction) { int yStart; int yEnd; if (direction == Direction.DOWN) { yStart = (activityUtils.getCurrentActivity().getWindowManager() .getDefaultDisplay().getHeight() - 20); yEnd = ((activityUtils.getCurrentActivity().getWindowManager() .getDefaultDisplay().getHeight() / 2)); } else { yStart = ((activityUtils.getCurrentActivity().getWindowManager() .getDefaultDisplay().getHeight() / 2)); yEnd = (activityUtils.getCurrentActivity().getWindowManager() .getDefaultDisplay().getHeight() - 20); } int x = activityUtils.getCurrentActivity().getWindowManager() .getDefaultDisplay().getWidth() / 2; if (viewFetcher.getCurrentListViews().size() > 0) { return scrollList(0, direction); } else if (viewFetcher.getCurrentScrollViews().size() > 0) { ScrollView scroll = viewFetcher.getCurrentScrollViews().get(0); scrollAmount = scroll.getScrollY(); drag(x, x, yStart, yEnd, 20); if (scrollAmount == scroll.getScrollY()) { scrollAmount = 0; return false; } else return true; } else return false; }	"	private boolean scroll(int direction) {
		int yStart;
		int yEnd;
		if (direction == DOWN) {
			yStart = (activityUtils.getCurrentActivity().getWindowManager()
					.getDefaultDisplay().getHeight() - 20);
			yEnd = ((activityUtils.getCurrentActivity().getWindowManager()
					.getDefaultDisplay().getHeight() / 2));
		} 
		else {
			yStart = ((activityUtils.getCurrentActivity().getWindowManager()
					.getDefaultDisplay().getHeight() / 2));
			yEnd = (activityUtils.getCurrentActivity().getWindowManager()
					.getDefaultDisplay().getHeight() - 20);
		}
		int x = activityUtils.getCurrentActivity().getWindowManager()
				.getDefaultDisplay().getWidth() / 2;

		if (viewFetcher.getCurrentListViews().size() > 0) {
			return scrollList(0, direction);
		} 
		else if (viewFetcher.getCurrentScrollViews().size() > 0) {
			ScrollView scroll = viewFetcher.getCurrentScrollViews().get(0);
			scrollAmount = scroll.getScrollY();
			drag(x, x, yStart, yEnd, 20);
			if (scrollAmount == scroll.getScrollY()) {
				scrollAmount = 0;
				return false;
			} 
			else
				return true;
		} 
		else
			return false;

	}
"	@param direction the direction in which to scroll	@param direction the direction in which to scroll	0	1	10	37	213
"public static RemoteProxy getNewBasicRemoteProxy(String browser, String url, Registry registry) { RegistrationRequest req = RegistrationRequest.build(""-role"", ""webdriver""); req.getCapabilities().clear(); DesiredCapabilities capability = new DesiredCapabilities(); capability.setBrowserName(browser); req.addDesiredCapabilitiy(capability); Map<String, Object> config = new HashMap<String, Object>(); config.put(""url"", url); req.setConfiguration(config); return new RemoteProxy(req, registry); }"	"  public static RemoteProxy getNewBasicRemoteProxy(Map<String, Object> cap, String url, Registry registry) {
    RegistrationRequest req = RegistrationRequest.build(""-role"", ""webdriver"");
    req.getCapabilities().clear();
    req.addDesiredCapabilitiy(cap);
    req.getConfiguration().put(RegistrationRequest.REMOTE_URL, url);
    return new RemoteProxy(req, registry);

  }
"	@param appName	@param cap	1	0	8	16	96
public boolean searchText(String regex, int expectedMinimumNumberOfMatches, boolean scroll) { return searcher.searchWithTimeoutFor(TextView.class, regex, expectedMinimumNumberOfMatches, scroll); }	"	public boolean searchText(String regex, int matches, boolean scroll) {
		return searcher.searchWithTimeoutFor(TextView.class, regex, matches, scroll);
	}
"	@param expectedMinimumNumberOfMatches the minimum number of matches expected to be found.  0 matches means that one or more matches are expected to be found	@param matches the number of matches expected to be found. 0 matches means that one or more matches are expected to be found	1	0	6	4	29
"public OuterComposite fakeOuterCompositeSerialize(OuterComposite outerComposite) throws RestClientException { Object postBody = outerComposite; String path = UriComponentsBuilder.fromPath(""/fake/outer/composite"").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { ""*/*"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<OuterComposite> returnType = new ParameterizedTypeReference<OuterComposite>() {}; return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }"	"    public OuterComposite fakeOuterCompositeSerialize(OuterComposite body) throws RestClientException {
        Object postBody = body;
        
        String path = UriComponentsBuilder.fromPath(""/fake/outer/composite"").build().toUriString();
        
        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();
        final HttpHeaders headerParams = new HttpHeaders();
        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();

        final String[] accepts = { };
        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);
        final String[] contentTypes = { };
        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);

        String[] authNames = new String[] {  };

        ParameterizedTypeReference<OuterComposite> returnType = new ParameterizedTypeReference<OuterComposite>() {};
        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);
    }
"	@param outerComposite Input composite as post body	@param body Input composite as post body	1	0	8	22	160
public static SDOGeometry join(SDOGeometry[] sdoElements) { final SDOGeometry sdoCollection = new SDOGeometry(); if ( sdoElements == null || sdoElements.length == 0 ) { sdoCollection.setGType( new SDOGType( 2, 0, TypeGeometry.COLLECTION ) ); } else { final SDOGeometry firstElement = sdoElements[0]; final int dim = firstElement.getGType().getDimension(); final int lrsDim = firstElement.getGType().getLRSDimension(); sdoCollection.setGType( new SDOGType( dim, lrsDim, TypeGeometry.COLLECTION ) ); int ordinatesOffset = 1; for ( int i = 0; i < sdoElements.length; i++ ) { final ElemInfo element = sdoElements[i].getInfo(); final Double[] ordinates = sdoElements[i].getOrdinates().getOrdinateArray(); if ( element != null && element.getSize() > 0 ) { final int shift = ordinatesOffset - element.getOrdinatesOffset( 0 ); shiftOrdinateOffset( element, shift ); sdoCollection.addElement( element ); sdoCollection.addOrdinates( ordinates ); ordinatesOffset += ordinates.length; } } } return sdoCollection; }	"	public static SDOGeometry join(SDOGeometry[] SDOElements) {
		SDOGeometry SDOCollection = new SDOGeometry();
		if ( SDOElements == null || SDOElements.length == 0 ) {
			SDOCollection.setGType(
					new SDOGType(
							2, 0,
							TypeGeometry.COLLECTION
					)
			);
		}
		else {
			SDOGeometry firstElement = SDOElements[0];
			int dim = firstElement.getGType().getDimension();
			int lrsDim = firstElement.getGType().getLRSDimension();
			SDOCollection.setGType(
					new SDOGType(
							dim, lrsDim,
							TypeGeometry.COLLECTION
					)
			);
			int ordinatesOffset = 1;
			for ( int i = 0; i < SDOElements.length; i++ ) {
				ElemInfo element = SDOElements[i].getInfo();
				Double[] ordinates = SDOElements[i].getOrdinates()
						.getOrdinateArray();
				if ( element != null && element.getSize() > 0 ) {
					int shift = ordinatesOffset
							- element.getOrdinatesOffset( 0 );
					shiftOrdinateOffset( element, shift );
					SDOCollection.addElement( element );
					SDOCollection.addOrdinates( ordinates );
					ordinatesOffset += ordinates.length;
				}
			}
		}
		return SDOCollection;
	}
"	@param sdoElements The SDO_geometries to join into an SDO Geometry Collection	@param SDOElements	1	0	13	26	195
private ServiceReference[] getInitialReferences(boolean trackAllServices, String className, String filterString) throws InvalidSyntaxException { if (trackAllServices) { return context.getAllServiceReferences(className, filterString); } return context.getServiceReferences(className, filterString); }	"	private ServiceReference[] getInitialReferences(boolean trackAllServices,
			String trackClass, String filterString)
			throws InvalidSyntaxException {
		if (trackAllServices) {
			return context.getAllServiceReferences(trackClass, filterString);
		}
		else {
			return context.getServiceReferences(trackClass, filterString);
		}
	}
"	@param className The class name with which the service was registered, or null for all services.	@param trackClass the class name with which the service was registered, or null for all services.	1	0	7	10	43
public int compareTo(ReadableInstant other) { if (this == other) { return 0; } long otherMillis = other.getMillis(); long thisMillis = getMillis(); // cannot do (thisMillis - otherMillis) as can overflow if (thisMillis == otherMillis) { return 0; } if (thisMillis < otherMillis) { return -1; } else { return 1; } }	"    public int compareTo(Object instant) {
        if (this == instant) {
            return 0;
        }
        
        ReadableInstant otherInstant = (ReadableInstant) instant;
        
        long otherMillis = otherInstant.getMillis();
        long thisMillis = getMillis();
        
        // cannot do (thisMillis - otherMillis) as can overflow
        if (thisMillis == otherMillis) {
            return 0;
        }
        if (thisMillis < otherMillis) {
            return -1;
        } else {
            return 1;
        }
    }
"	@param other a readable instant to check against	@param instant a readable instant to check against	1	0	6	19	71
public boolean waitForText(String text, int minimumNumberOfMatches, long timeout, boolean scroll) { return robotiumUtils.waitForText(text, minimumNumberOfMatches, timeout, scroll); }	"	
	public boolean waitForText(String text, int expectedMinimumNumberOfMatches, long timeout, boolean scroll) {
		return robotiumUtils.waitForText(text, expectedMinimumNumberOfMatches, timeout, scroll);
    }
"	@param minimumNumberOfMatches the minimum number of text matches that are expected to be shown.  0 means any number of matches	@param expectedMinimumNumberOfMatches the minimum number of matches of text that must be shown. 0 means any number of matches	1	0	5	6	31
public OuterComposite fakeOuterCompositeSerialize(OuterComposite outerComposite) throws ApiException { return fakeOuterCompositeSerializeWithHttpInfo(outerComposite).getData(); }	"  public OuterComposite fakeOuterCompositeSerialize(OuterComposite body) throws ApiException {
    return fakeOuterCompositeSerializeWithHttpInfo(body).getData();
      }
"	@param outerComposite Input composite as post body (optional)	@param body Input composite as post body (optional)	1	0	5	4	20
"public boolean highlightNode(ASTGenerator astGenerator){ if (!(Node instanceof SimpleName)) { return false; } SimpleName nodeName = (SimpleName) Node; try { //TODO: Redundant code. See ASTGenerator.getJavaSourceCodeline() int javaLineNumber = getLineNumber(nodeName); int pdeOffs[] = astGenerator.errorCheckerService .calculateTabIndexAndLineNumber(javaLineNumber); PlainDocument javaSource = new PlainDocument(); javaSource.insertString(0, astGenerator.errorCheckerService.sourceCode, null); Element lineElement = javaSource.getDefaultRootElement() .getElement(javaLineNumber-1); if(lineElement == null) { Messages.log(lineNumber + "" line element null while highlighting "" + nodeName); return false; } String javaLine = javaSource.getText(lineElement.getStartOffset(), lineElement.getEndOffset() - lineElement.getStartOffset()); astGenerator.editor.getSketch().setCurrentCode(pdeOffs[0]); String pdeLine = astGenerator.editor.getLineText(pdeOffs[1]); String lookingFor = nodeName.toString(); Messages.log(lookingFor + "", "" + nodeName.getStartPosition()); Messages.log(javaLineNumber +"" JL "" + javaLine + "" LSO "" + lineElement.getStartOffset() + "","" + lineElement.getEndOffset()); Messages.log(pdeOffs[1] + "" PL "" + pdeLine); if (!javaLine.contains(lookingFor) || !pdeLine.contains(lookingFor)) { Messages.loge(""Logical error in highLightNode(). Please file a bug report.""); return false; } OffsetMatcher ofm = new OffsetMatcher(pdeLine, javaLine); int highlightStart = ofm.getPdeOffForJavaOff(nodeName.getStartPosition() - lineElement.getStartOffset(), nodeName.getLength()); if (highlightStart == -1) { Messages.loge(""Logical error in highLightNode() during offset matching. "" + ""Please file a bug report.""); return false; } int lso = astGenerator.editor.getTextArea().getLineStartOffset(pdeOffs[1]); highlightStart += lso; astGenerator.editor.setSelection(highlightStart, highlightStart + nodeName.getLength()); /* // First find the name in the java line, and marks its index Pattern toFind = Pattern.compile(""\\b"" + nodeName.toString() + ""\\b""); Matcher matcher = toFind.matcher(javaLine); int count = 0, index = 0; int lsto = lineElement.getStartOffset(); while(matcher.find()){ count++; //log(matcher.start() + lsto); if(lsto + matcher.start() == nodeName.getStartPosition()) break; } log(""count="" + count); index = 0; // find the same name in the pde line by its index and get its offsets matcher = toFind.matcher(pdeLine); while(matcher.find()){ count--; if(count == 0){ log(""Found on pde line lso: "" + matcher.start()); index = matcher.end(); break; } } log(""pde lso "" + (index - lookingFor.length())); int lso = astGenerator.editor.ta.getLineStartOffset(pdeOffs[1]); astGenerator.editor.setSelection(lso + index - lookingFor.length(), lso + index); */ return true; } catch (BadLocationException e) { Messages.loge(""BLE in highLightNode() for "" + nodeName); e.printStackTrace(); } return false; }"	"  public boolean highlightNode(JavaEditor editor){
    if (!(node instanceof SimpleName)) {
      return false;
    }
    SimpleName nodeName = (SimpleName) node;
    try {
      //TODO: Redundant code. See ASTGenerator.getJavaSourceCodeline()
      int javaLineNumber = getLineNumber(nodeName);
      int pdeOffs[] = editor.getErrorChecker().calculateTabIndexAndLineNumber(javaLineNumber);
      PlainDocument javaSource = new PlainDocument();
      javaSource.insertString(0, editor.getErrorChecker().lastCodeCheckResult.sourceCode, null);
      Element lineElement = javaSource.getDefaultRootElement()
          .getElement(javaLineNumber-1);
      if(lineElement == null) {
        Messages.log(lineNumber + "" line element null while highlighting "" + nodeName);
        return false;
      }

      String javaLine = javaSource.getText(lineElement.getStartOffset(),
                                           lineElement.getEndOffset()
                                               - lineElement.getStartOffset());
      editor.getSketch().setCurrentCode(pdeOffs[0]);
      String pdeLine = editor.getLineText(pdeOffs[1]);
      String lookingFor = nodeName.toString();
      Messages.log(lookingFor + "", "" + nodeName.getStartPosition());
      Messages.log(javaLineNumber +"" JL "" + javaLine + "" LSO "" + lineElement.getStartOffset() + "",""
          + lineElement.getEndOffset());
      Messages.log(pdeOffs[1] + "" PL "" + pdeLine);
      if (!javaLine.contains(lookingFor) || !pdeLine.contains(lookingFor)) {
        Messages.loge(""Logical error in highLightNode(). Please file a bug report."");
        return false;
      }

      OffsetMatcher ofm = new OffsetMatcher(pdeLine, javaLine);
      int highlightStart = ofm.getPdeOffForJavaOff(nodeName.getStartPosition()
                                  - lineElement.getStartOffset(),
                              nodeName.getLength());
      if (highlightStart == -1) {
        Messages.loge(""Logical error in highLightNode() during offset matching. "" +
        		""Please file a bug report."");
        return false;
      }
      int lso = editor.getTextArea().getLineStartOffset(pdeOffs[1]);
      highlightStart += lso;
      editor.setSelection(highlightStart, highlightStart
          + nodeName.getLength());
      /*
      // First find the name in the java line, and marks its index
      Pattern toFind = Pattern.compile(""\\b"" + nodeName.toString() + ""\\b"");
      Matcher matcher = toFind.matcher(javaLine);
      int count = 0, index = 0;
      int lsto = lineElement.getStartOffset();
      while(matcher.find()){
        count++;
        //log(matcher.start() + lsto);
        if(lsto + matcher.start() == nodeName.getStartPosition())
          break;
      }
      log(""count="" + count);
      index = 0;
      // find the same name in the pde line by its index and get its offsets
      matcher = toFind.matcher(pdeLine);
      while(matcher.find()){
        count--;
        if(count == 0){
          log(""Found on pde line lso: "" + matcher.start());
          index = matcher.end();
          break;
        }
      }
      log(""pde lso "" + (index - lookingFor.length()));

      int lso = astGenerator.editor.ta.getLineStartOffset(pdeOffs[1]);
      astGenerator.editor.setSelection(lso + index - lookingFor.length(), lso
          + index);
      */
      return true;

    } catch (BadLocationException e) {
      Messages.loge(""BLE in highLightNode() for "" + nodeName);
      e.printStackTrace();
    }
    return false;
  }
"	@param astGenerator	@param editor	1	0	12	86	638
public Single<Order> rxPlaceOrder(Order order) { return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> { delegate.placeOrder(order, fut); })); }	"    public Single<Order> rxPlaceOrder(Order body) {
        return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> {
            delegate.placeOrder(body, fut);
        }));
    }
"	@param order order placed for purchasing the pet (required)	@param body order placed for purchasing the pet (required)	1	0	10	6	36
public Configuration setCacheConcurrencyStrategy(String entityName, String concurrencyStrategy) { setCacheConcurrencyStrategy( entityName, concurrencyStrategy, entityName ); return this; }	"	public Configuration setCacheConcurrencyStrategy(String clazz, String concurrencyStrategy)
			throws MappingException {
		setCacheConcurrencyStrategy( clazz, concurrencyStrategy, clazz );
		return this;
	}
"	@param concurrencyStrategy The cache strategy to use	@param concurrencyStrategy	1	0	5	5	24
"public long getMessageCount(String destinationName) { if (null == brokerService) { throw new IllegalStateException(""BrokerService has not yet been created - was before() called?""); } // TODO: Figure out how to do this for Topics Destination destination = getDestination(destinationName); if (destination == null) { throw new RuntimeException(""Failed to find destination: "" + destinationName); } // return destination.getMessageStore().getMessageCount(); return destination.getDestinationStatistics().getMessages().getCount(); }"	"    public int getMessageCount(String fullDestinationName) throws Exception {
        final int QUEUE_TYPE = 1;
        final int TOPIC_TYPE = 2;

        if (null == brokerService) {
            throw new IllegalStateException(""BrokerService has not yet been created - was before() called?"");
        }

        int destinationType = QUEUE_TYPE;
        String destinationName = fullDestinationName;

        if (fullDestinationName.startsWith(""queue:"")) {
            destinationName = fullDestinationName.substring(fullDestinationName.indexOf(':') + 1);
        } else if (fullDestinationName.startsWith(""topic:"")) {
            destinationType = TOPIC_TYPE;
            destinationName = fullDestinationName.substring(fullDestinationName.indexOf(':') + 1);
        }

        int messageCount = -1;
        boolean foundDestination = false;
        for (Destination destination : brokerService.getBroker().getDestinationMap().values()) {
            String tmpName = destination.getName();
            if (tmpName.equalsIgnoreCase(destinationName)) {
                switch (destinationType) {
                    case QUEUE_TYPE:
                        if (destination instanceof Queue) {
                            messageCount = destination.getMessageStore().getMessageCount();
                            foundDestination = true;
                        }
                        break;
                    case TOPIC_TYPE:
                        if (destination instanceof Topic) {
                            messageCount = destination.getMessageStore().getMessageCount();
                            foundDestination = true;
                        }
                        break;
                    default:
                        // Should never see this
                        log.error(""Type didn't match: {}"", destination.getClass().getName());
                }
            }
            if (foundDestination) {
                break;
            }
        }

        if (!foundDestination) {
            log.warn(""Didn't find destination {} in broker {}"", fullDestinationName, getBrokerName());
        }

        return messageCount;
    }
"	@param destinationName the full name of the JMS Destination	@param fullDestinationName the full name of the JMS Destination	1	0	8	15	101
"public BroadcastAction filter(Object originalMessage, Object message) { // Avoid re-broadcasting if (!receivedMessages.remove(message)) { try { jchannel.send(new Message(null, null, (Serializable)message)); } catch (ChannelException e) { logger.warn(""failed to send message"", e); } } return new BroadcastAction(message); }"	"    public BroadcastAction filter(Object originalMessage, Object o) {
        if (o instanceof String){
            String message = (String)o;
            // Avoid re-broadcasting
            if (!receivedMessages.remove(message)) {
                try {
                    jchannel.send(new Message(null, null, message));
                } catch (ChannelException e) {
                    logger.warn(""failed to send message"", e);
                }
            }
            return new BroadcastAction(message);
        } else {
            return new BroadcastAction(o);
        }
    }
"	@param message the message to broadcast.	@param o the message to broadcast.	1	0	10	12	76
public boolean searchText(String text, int minimumNumberOfMatches) { boolean found = searcher.searchWithTimeoutFor(TextView.class, text, minimumNumberOfMatches, true); return found; }	"	public boolean searchText(String regex, int expectedMinimumNumberOfMatches) {
		boolean found = searcher.searchWithTimeoutFor(TextView.class, regex, expectedMinimumNumberOfMatches, true);
		return found;
	}
"	@param minimumNumberOfMatches the minimum number of matches expected to be found.  0 matches means that one or more matches are expected to be found	@param expectedMinimumNumberOfMatches the minimum number of matches expected to be found. 0 matches means that one or more matches are expected to be found	1	0	7	5	30
public Single<Void> rxUpdateUser(String username, User user) { return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> { delegate.updateUser(username, user, fut); })); }	"    public Single<Void> rxUpdateUser(String username, User body) {
        return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> {
            delegate.updateUser(username, body, fut);
        }));
    }
"	@param user Updated user object (required)	@param body Updated user object (required)	1	0	10	6	41
public long findBestMatchCuboid(long cuboid) { return findBestMatchCuboid1(cuboid); }	"    public long findBestMatchCuboid(long child) {
        long parent = getOnTreeParent(child);
        while (parent > 0) {
            if (cubeDesc.getAllCuboids().contains(parent)) {
                break;
            }
            parent = getOnTreeParent(parent);
        }

        if (parent <= 0) {
            throw new IllegalStateException(""Can't find valid parent for Cuboid "" + child);
        }
        return parent;
    }
"	@param cuboid an on-tree cuboid	@param child an on-tree cuboid	1	0	5	4	15
public boolean isSelected(final ToolItem toolItem) { boolean selectionState = Display.syncExec(new ResultRunnable<Boolean>() { @Override public Boolean run() { return toolItem.getSelection(); } }); return selectionState; }	"	public boolean isSelected(final ToolItem w) {
		boolean selectionState = Display.syncExec(new ResultRunnable<Boolean>() {
			@Override
			public Boolean run() {
					return w.getSelection(); 
			}
		});
		return selectionState;
	}
"	@param toolItem tool item to handle	@param w given widget	1	0	9	11	42
public boolean waitForActivity(Class<? extends Activity> activityClass){ return waiter.waitForActivity(activityClass, TIMEOUT); }	"    public boolean waitForActivity(Class<? extends Activity> clazz){
        return waiter.waitForActivity(clazz, TIMEOUT);
    }
"	@param activityClass the class of the  Activity to wait for	"@param clazz the class of the Activity to wait for e.g. ""MyActivity"""	1	0	6	4	21
public boolean removeFilter(BroadcastFilter filter) { if (filter instanceof BroadcastFilterLifecycle) { ((BroadcastFilterLifecycle) filter).destroy(); } if (filter instanceof PerRequestBroadcastFilter) { perRequestFilters.remove(filter); } return filters.remove(filter); }	"    public boolean removeFilter(BroadcastFilter e) {

        if (e instanceof BroadcastFilterLifecycle) {
            ((BroadcastFilterLifecycle) e).destroy();
        }

        if (e instanceof PerRequestBroadcastFilter) {
            perRequestFilters.remove(e);
        }
        
        return filters.remove(e);
    }
"	@param filter  BroadcastFilter	@param e BroadcastFilter	1	0	7	13	48
@Override public String toString() { return annotations.toString(); }	"@Override
public String toString() {
    List<String> l = new LinkedList<>();
    for (AnnotationMirror a : annotations) {
        DeclaredType annoType = a.getAnnotationType();
        TypeElement elm = (TypeElement) annoType.asElement();
        l.add(elm.getSimpleName().toString());
    }
    String s = l.toString();
    return s.substring(NUM, s.length() - NUM);
}"	@return The string representation as a comma-separated list.	@return The string representation as a comma-separated list of simple annotation names.	1	0	4	4	15
"public AsyncSupport newCometSupport(final Class<? extends AsyncSupport> targetClass) { try { return (AsyncSupport) targetClass.getDeclaredConstructor(new Class[]{AtmosphereConfig.class}) .newInstance(config); } catch (final Exception e) { logger.warn(""Failed to create AsyncSupport class: {}, error: {}"", targetClass, e); return null; // All callers are expected to handle null return value } }"	"    public AsyncSupport newCometSupport(final Class<? extends AsyncSupport> targetClass) {
        try {
            return (AsyncSupport) targetClass.getDeclaredConstructor(new Class[]{AtmosphereConfig.class})
                    .newInstance(config);
        } catch (final Exception e) {
            logger.error(""Failed to create comet support class: {}, error: {}"", targetClass, e);
            logger.error(""Switching to BlockingIO"");

            return new BlockingIOCometSupport(config);
        }
    }
"	@return an instance of the specified class or null if the class cannot be instantiated	@return an instance of the specified class	1	0	10	10	83
public ExecutionInfo getParent() { return parentInfo; }	"    public ExecutionInfo getParent() {
        return parentType;
    }
"	@return the parent type information	@return the parent type information	0	1	4	4	10
public TwitterTokenStream getDefaultTokenStream() { return tokenizationStream; }	"public TokenStream getDefaultTokenStream() {
    return tokenizationStream;
}"	@return {@code TwitterTokenStream} to tokenize the text	@return {@code TokenStream} to tokenize the text	1	0	4	3	10
public static String getHostFromUrl(String url) { String authority = getAuthorityFromUrl(url); int idx = authority.indexOf(STR); if (idx == -NUM) return authority; return authority.substring(NUM, idx); }	"public static String getHostFromUrl(String url) {
    if (url.indexOf(STR) == -NUM)
        return url;
    int slashes = NUM;
    if (url.contains(STR))
        slashes += NUM;
    String[] parts = url.split(STR);
    if (parts.length < slashes)
        return url;
    return parts[slashes];
}"	@return The host, as a string.	@return Host name and port, as a string.	1	0	6	7	43
public static ModuleConfig getModuleConfig(HttpServletRequest request, ServletContext context) { ModuleConfig moduleConfig = (ModuleConfig) request.getAttribute(Globals.MODULE_KEY); if (moduleConfig == null) { moduleConfig = (ModuleConfig) context.getAttribute(Globals.MODULE_KEY); } return moduleConfig; }	"public static ApplicationConfig getModuleConfig(HttpServletRequest request, ServletContext context) {
    ApplicationConfig appConfig = (ApplicationConfig) request.getAttribute(Globals.MODULE_KEY);
    if (appConfig == null) {
        appConfig = (ApplicationConfig) context.getAttribute(Globals.MODULE_KEY);
    }
    return appConfig;
}"	@return the ModuleConfig object	@return the ApplicationConfig object	1	0	9	7	46
public Optional<GraphQLError> add(Definition definition) { // extensions if (definition instanceof ObjectTypeExtensionDefinition) { ObjectTypeExtensionDefinition newEntry = (ObjectTypeExtensionDefinition) definition; return defineExt(objectTypeExtensions, newEntry, ObjectTypeExtensionDefinition::getName); } else if (definition instanceof InterfaceTypeExtensionDefinition) { InterfaceTypeExtensionDefinition newEntry = (InterfaceTypeExtensionDefinition) definition; return defineExt(interfaceTypeExtensions, newEntry, InterfaceTypeExtensionDefinition::getName); } else if (definition instanceof UnionTypeExtensionDefinition) { UnionTypeExtensionDefinition newEntry = (UnionTypeExtensionDefinition) definition; return defineExt(unionTypeExtensions, newEntry, UnionTypeExtensionDefinition::getName); } else if (definition instanceof EnumTypeExtensionDefinition) { EnumTypeExtensionDefinition newEntry = (EnumTypeExtensionDefinition) definition; return defineExt(enumTypeExtensions, newEntry, EnumTypeExtensionDefinition::getName); } else if (definition instanceof ScalarTypeExtensionDefinition) { ScalarTypeExtensionDefinition newEntry = (ScalarTypeExtensionDefinition) definition; return defineExt(scalarTypeExtensions, newEntry, ScalarTypeExtensionDefinition::getName); } else if (definition instanceof InputObjectTypeExtensionDefinition) { InputObjectTypeExtensionDefinition newEntry = (InputObjectTypeExtensionDefinition) definition; return defineExt(inputObjectTypeExtensions, newEntry, InputObjectTypeExtensionDefinition::getName); // // normal } else if (definition instanceof ScalarTypeDefinition) { ScalarTypeDefinition newEntry = (ScalarTypeDefinition) definition; return define(scalarTypes, scalarTypes, newEntry); } else if (definition instanceof TypeDefinition) { TypeDefinition newEntry = (TypeDefinition) definition; return define(types, types, newEntry); } else if (definition instanceof DirectiveDefinition) { DirectiveDefinition newEntry = (DirectiveDefinition) definition; return define(directiveDefinitions, directiveDefinitions, newEntry); } else if (definition instanceof SchemaDefinition) { SchemaDefinition newSchema = (SchemaDefinition) definition; if (schema != null) { return Optional.of(new SchemaRedefinitionError(this.schema, newSchema)); } else { schema = newSchema; } } return Optional.empty(); }	"    public Optional<GraphQLError> add(SDLDefinition definition) {
        // extensions
        if (definition instanceof ObjectTypeExtensionDefinition) {
            ObjectTypeExtensionDefinition newEntry = (ObjectTypeExtensionDefinition) definition;
            return defineExt(typeExtensions, newEntry, ObjectTypeExtensionDefinition::getName);
        } else if (definition instanceof InterfaceTypeExtensionDefinition) {
            InterfaceTypeExtensionDefinition newEntry = (InterfaceTypeExtensionDefinition) definition;
            return defineExt(interfaceTypeExtensions, newEntry, InterfaceTypeExtensionDefinition::getName);
        } else if (definition instanceof UnionTypeExtensionDefinition) {
            UnionTypeExtensionDefinition newEntry = (UnionTypeExtensionDefinition) definition;
            return defineExt(unionTypeExtensions, newEntry, UnionTypeExtensionDefinition::getName);
        } else if (definition instanceof EnumTypeExtensionDefinition) {
            EnumTypeExtensionDefinition newEntry = (EnumTypeExtensionDefinition) definition;
            return defineExt(enumTypeExtensions, newEntry, EnumTypeExtensionDefinition::getName);
        } else if (definition instanceof ScalarTypeExtensionDefinition) {
            ScalarTypeExtensionDefinition newEntry = (ScalarTypeExtensionDefinition) definition;
            return defineExt(scalarTypeExtensions, newEntry, ScalarTypeExtensionDefinition::getName);
        } else if (definition instanceof InputObjectTypeExtensionDefinition) {
            InputObjectTypeExtensionDefinition newEntry = (InputObjectTypeExtensionDefinition) definition;
            return defineExt(inputObjectTypeExtensions, newEntry, InputObjectTypeExtensionDefinition::getName);
            //
            // normal
        } else if (definition instanceof ScalarTypeDefinition) {
            ScalarTypeDefinition newEntry = (ScalarTypeDefinition) definition;
            return define(scalarTypes, scalarTypes, newEntry);
        } else if (definition instanceof TypeDefinition) {
            TypeDefinition newEntry = (TypeDefinition) definition;
            return define(types, types, newEntry);
        } else if (definition instanceof DirectiveDefinition) {
            DirectiveDefinition newEntry = (DirectiveDefinition) definition;
            return define(directiveDefinitions, directiveDefinitions, newEntry);
        } else if (definition instanceof SchemaDefinition) {
            SchemaDefinition newSchema = (SchemaDefinition) definition;
            if (schema != null) {
                return Optional.of(new SchemaRedefinitionError(this.schema, newSchema));
            } else {
                schema = newSchema;
            }
        } else {
            return Assert.assertShouldNeverHappen();
        }
        return Optional.empty();
    }
"	@return an optional error	@return an optional error	0	1	20	42	319
public boolean isButtonOverflowVisible() { return mIsButtonOverflowVisible; }	"public boolean isButtonOverflowVisible() {
    if (mPopupMenu == NO_POPUP_MENU && mCustomOverflowAnimation == null) {
        if (mIsButtonOverflowVisible)
            Log.w(STR, STR);
        return false;
    }
    return mIsButtonOverflowVisible;
}"	@return <code>true</code> if the button is visible	@return <code>true</code> if the button is visible and Popup Menu is assigned.	1	0	4	3	10
"public DateTime withField(DateTimeFieldType fieldType, int value) { if (fieldType == null) { throw new IllegalArgumentException(""Field must not be null""); } long instant = fieldType.getField(getChronology()).set(getMillis(), value); return withMillis(instant); }"	"    public DateTime withField(DateTimeFieldType fieldType, int value) {
        if (fieldType == null) {
            return this;
        }
        long instant = fieldType.getField(getChronology()).set(getMillis(), value);
        return withMillis(instant);
    }
"	@return a copy of this datetime with the field set	@return a copy of this datetime with the field set	0	1	7	8	56
public ICursor getCursor() { return cursor; }	"public Cursor getCursor() {
    return cursor;
}"	@return the {@link ICursor} backing this SquidCursor. If you are on Android and you need to pass this object across process boundaries, and if this SquidCursor was obtained from a SquidDatabase, you can safely cast the object returned by this method to an Android cursor	@return the {@link Cursor} backing this SquidCursor	1	0	4	3	10
public Client testClassname(Client body) throws ApiException { ApiResponse<Client> localVarResp = testClassnameWithHttpInfo(body); return localVarResp.getData(); }	"    public Client testClassname(Client body) throws ApiException {
        ApiResponse<Client> resp = testClassnameWithHttpInfo(body);
        return resp.getData();
    }
"	@return Client	@return Client	0	1	6	5	25
public boolean setTaskCompleted(List<FileDownloadTaskAtom> taskAtomList) { return FileDownloadServiceProxy.getImpl().setTaskCompleted(taskAtomList); }	"    public boolean setTaskCompleted(String url, String path, long totalBytes) {
        return FileDownloadServiceProxy.getImpl().setTaskCompleted(url, path, totalBytes);
    }
"	@return Whether is successful to update all tasks' status to the Filedownloader Engine. If one task atom among them is not match the Rules in  com.liulishuo.filedownloader.services.FileDownloadMgr#obtainCompletedTaskModel(String, String, long) will receive false, and non of them would be updated to DB.	@return Whether is successful to set the task completed. If the path not exist will be false; If the length of the file in path is not equal to totalBytes will be false; If the task with url and path is downloading will be false. Otherwise will be true.	1	0	6	4	20
public static Date fromISODateString(String isoDateString) throws Exception { DateTimeFormatter parser = ISODateTimeFormat.dateTimeParser(); DateTime dateTime = DateTime.parse(isoDateString, parser); return dateTime.toDate(); }	"    public static Date fromISODateString(String isoDateString)
            throws Exception {
        SimpleDateFormat f = new SimpleDateFormat(FORMAT_DATE_ISO, Locale.getDefault());
        Date date;

        f.setTimeZone(TimeZone.getTimeZone(""UTC""));
        try {
            date = f.parse(isoDateString);
            return date;
        } catch (ParseException e) {
        }

        f = new SimpleDateFormat(FORMAT_DATE_ISO_MSEC, Locale.getDefault());
        f.setTimeZone(TimeZone.getTimeZone(""UTC""));
        try {
            date = f.parse(isoDateString);
            return date;
        } catch (ParseException e) {
        }

        f = new SimpleDateFormat(FORMAT_DATE_ISO_MSEC_UTC, Locale.getDefault());
        f.setTimeZone(TimeZone.getTimeZone(""UTC""));
        try {
            date = f.parse(isoDateString);
            return date;
        } catch (ParseException e) {
        }

        throw new ParseException(""Unparseable date: "" + isoDateString, 0);
    }
"	@return the date	@return the date	0	1	6	8	35
public static SqlParser create(String sql, Config config) { SqlAbstractParserImpl parser = config.parserFactory().getParser(new StringReader(sql)); return new SqlParser(sql, parser, config); }	"  public static SqlParser create(String s) {
    return create(SqlParserImpl.FACTORY, s, Quoting.DOUBLE_QUOTE,
        Casing.TO_UPPER, Casing.UNCHANGED);
  }
"	@return A parser	@return A SqlParser object.	1	0	8	7	39
"private ZapTextArea getTxtEncode() { if (txtEncode == null) { txtEncode = new ZapTextArea(); txtEncode.setLineWrap(true); txtEncode.setFont(new java.awt.Font(""Courier New"", java.awt.Font.PLAIN, 12)); txtEncode.addMouseListener(new java.awt.event.MouseAdapter() { public void mousePressed(java.awt.event.MouseEvent e) { if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0) { // right mouse button view.getPopupMenu().show(e.getComponent(), e.getX(), e.getY()); } } }); } return txtEncode; }"	"	private JTextArea getTxtEncode() {
		if (txtEncode == null) {
			txtEncode = new JTextArea();
			txtEncode.setLineWrap(true);
			txtEncode.setFont(new java.awt.Font(""Courier New"", java.awt.Font.PLAIN, 12));
			txtEncode.addMouseListener(new java.awt.event.MouseAdapter() {   
				public void mousePressed(java.awt.event.MouseEvent e) {    
	          		if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0) {  // right mouse button
	            		view.getPopupMenu().show(e.getComponent(), e.getX(), e.getY());
	            	}
				} 

			
			});

		}
		return txtEncode;
	}
"	@return javax.swing.ZapTextArea	@return javax.swing.JTextField	1	0	14	19	120
@Override public Clip getAggregation() { return Clip.of(aggregate); }	"@Override
public List<BulletRecord> getAggregation() {
    return aggregate;
}"	@return a {@link Clip} of the combined records so far. The records have a size that is at most the maximum specified by the {@link Aggregation}.	@return a List of the combined {@link BulletRecord} so far. The List has a size that is at most the maximum specified by the {@link Aggregation}.	1	0	5	4	16
public String toInterfaceName(final String name) { return camelize(interfaceNamePrefix + name + interfaceNameSuffix); }	"    public String toInterfaceName(final String name) {
        return org.openapitools.codegen.utils.StringUtils.camelize(interfaceNamePrefix + name + interfaceNameSuffix);
    }
"	@return capitalized model name	@return capitalized model name	0	1	7	4	20
protected Project getRightChild(RelOptRuleCall call) { return call.rel(2); }	"  protected ProjectRelBase getRightChild(RelOptRuleCall call) {
    return call.rel(2);
  }
"	@return LogicalProject corresponding to the right child	@return ProjectRel corresponding to the right child	1	0	5	4	16
"public boolean isOperatedOn(Object entity) { if ( entity == null ) { throw new NullPointerException( ""null entities are not supported by "" + getClass().getName() ); } return entityToOperatedOnFlagMap.get( entity ); }"	"	public boolean isOperatedOn(Object entity) {
		if ( entity == null ) {
			throw new NullPointerException( ""null entities are not supported by "" + getClass().getName() );
		}
		return ( ( Boolean ) entityToOperatedOnFlagMap.get( entity ) ).booleanValue();
	}
"	@return true if the listener is performing the operation on the specified entity.	@return true if the listener is performing the operation on the specified entity.	0	1	9	7	44
public static long getLongInRange(long minValue, long maxValue) { return (long) (getDoubleInRange(minValue - 0.5, maxValue + 0.5 - (1 / Long.MAX_VALUE)) + 0.5); }	"	public static long getLongInRange(long minValue, long maxValue) {
		return (long) (minValue + Math.random() * (maxValue - minValue) + 0.5);
	}
"	@return A long/Long value between min and max value (included).	@return A long/Long value between min and max value (included).	0	1	9	4	42
public static String getLastBaselineBuild(String date) { if (BUILDS == null) { queryAllVariations(STR); } if (date == null) return LAST_BASELINE_BUILD; String lastBaselineBuild = null; for (int i = NUM; i < BUILDS_LENGTH; i++) { String build = BUILDS[i]; if (build.startsWith(AbstractResults.VERSION_REF)) { String buildDate = build.substring(build.indexOf(STR) + NUM); if (buildDate.compareTo(date) < NUM) { if (lastBaselineBuild == null || build.compareTo(lastBaselineBuild) > NUM) { lastBaselineBuild = build; } } } } return lastBaselineBuild; }	"public static String getLastBaselineBuild() {
    if (BUILDS == null) {
        queryAllVariations(STR);
    }
    return LAST_BASELINE_BUILD;
}"	@return the ID of the last baseline build before the given date or <code>null</code> if none was run before it...	@return the ID of the last baseline build.	1	0	13	20	113
public List<I> joinWithTimeout() { if (timeout < 0) { join(); return new ArrayList<>(); } // Make blocking calls to the last processes that are running if ( ! threadPool.isShutdown()) { try { List<I> leftover = null; int i; for (i = nThreads; i > 0; --i) { if (idleProcessors.poll(timeout, TimeUnit.MILLISECONDS) == null) { leftover = shutdownNow(); break; } } // if the poll hit a timeout, retake the remaining processors // so join() can guarantee the threads are finished if (i > 0) { for ( ; i > leftover.size(); --i) { idleProcessors.take(); } return leftover; } else { threadPool.shutdown(); // Sanity check. The threadpool should be done after iterating over // the processors. threadPool.awaitTermination(10, TimeUnit.SECONDS); } } catch (InterruptedException e) { throw new RuntimeInterruptedException(e); } } return new ArrayList<>(); }	"  public List<I> joinWithTimeout() {
    if (timeout < 0) {
      join();
      return null;
    }
    // Make blocking calls to the last processes that are running
    if ( ! threadPool.isShutdown()) {
      try {
        List<I> leftover = null;
        int i;
        for (i = nThreads; i > 0; --i) {
          if (idleProcessors.poll(timeout, TimeUnit.MILLISECONDS) == null) {
            leftover = shutdownNow();
            break;
          }
        }
        // if the poll hit a timeout, retake the remaining processors
        // so join() can guarantee the threads are finished
        if (i > 0) {
          for ( ; i > leftover.size(); --i) {
            idleProcessors.take();
          }
          return leftover;
        } else {
          threadPool.shutdown();
          // Sanity check. The threadpool should be done after iterating over
          // the processors.
          threadPool.awaitTermination(10, TimeUnit.SECONDS);
        }
      } catch (InterruptedException e) {
        throw new RuntimeInterruptedException(e);
      }
    }
    return null;
  }
"	@return a list of jobs which had never been started if timeout was reached, or an empty list if that did not happen.	@return a list of jobs which had never been started if timeout was reached, or null if that did not happen.	1	0	12	36	201
"private ZapTextArea getTxtDecode() { if (txtDecode == null) { txtDecode = new ZapTextArea(); txtDecode.setLineWrap(true); txtDecode.setFont(new java.awt.Font(""Courier New"", java.awt.Font.PLAIN, 12)); } return txtDecode; }"	"	private JTextArea getTxtDecode() {
		if (txtDecode == null) {
			txtDecode = new JTextArea();
			txtDecode.setLineWrap(true);
			txtDecode.setFont(new java.awt.Font(""Courier New"", java.awt.Font.PLAIN, 12));
		}
		return txtDecode;
	}
"	@return javax.swing.ZapTextArea	@return javax.swing.JTextField	1	0	10	9	51
public static HashMap getXmlRpcWorkflowInstancePage(WorkflowInstancePage page) { HashMap pageHash = new HashMap(); pageHash.put(STR, String.valueOf(page.getTotalPages())); pageHash.put(STR, String.valueOf(page.getPageNum())); pageHash.put(STR, String.valueOf(page.getPageSize())); pageHash.put(STR, getXmlRpcWorkflowInstances(page.getPageWorkflows())); return pageHash; }	"public static Hashtable getXmlRpcWorkflowInstancePage(WorkflowInstancePage page) {
    Hashtable pageHash = new Hashtable();
    pageHash.put(STR, String.valueOf(page.getTotalPages()));
    pageHash.put(STR, String.valueOf(page.getPageNum()));
    pageHash.put(STR, String.valueOf(page.getPageSize()));
    pageHash.put(STR, getXmlRpcWorkflowInstances(page.getPageWorkflows()));
    return pageHash;
}"	@return A {@link HashMap} representation of a {@link WorkflowInstancePage}.	@return A {@link Hashtable} representation of a {@link WorkflowInstancePage}.	1	0	6	8	79
public Button getButton(String text) { return viewFetcher.getView(Button.class, text, false); }	"	public Button getButton(String text)
	{
		return viewFetcher.getView(Button.class, text);
	}
"	@return the  Button that shows the given text	@return the Button that shows the given text	0	1	6	5	21
public List<TestSuite> getSuite() { return this.testSuites; }	"public TestSuite getSuite() {
    return this.testSuite;
}"	@return a linked list with parsed Test Suites. An empty list of no test suites were found.	@return the parsed Test Suite or null if no Test Suite was found.	1	0	5	3	12
public void offer(T item, double incrementCount) { Counter<T> counterNode = counterMap.get(item); if (counterNode == null) { counterNode = new Counter<T>(item, incrementCount); counterMap.put(item, counterNode); counterList.add(counterNode); } else { counterNode.setCount(counterNode.getCount() + incrementCount); } ordered = false; }	"    public boolean offer(T item, double incrementCount) {
        return offerReturnAll(item, incrementCount).getFirst();
    }
"	@return false if item was already in the stream summary, true otherwise	@return false if item was already in the stream summary, true otherwise	0	1	10	12	69
@SuppressWarnings(STR) public static String append(final String url, final Map<String, ?> params) { if (params == null || params.isEmpty()) return url; final StringBuilder result = new StringBuilder(url); int firstColon = url.indexOf(STR); int lastSlash = url.lastIndexOf(STR); if (firstColon + NUM == lastSlash) result.append(STR); result.append(STR); Entry<String, ?> entry; Object value; Iterator<?> iterator = params.entrySet().iterator(); entry = (Entry<String, ?>) iterator.next(); result.append(entry.getKey()); result.append(STR); value = entry.getValue(); if (value != null) result.append(value); while (iterator.hasNext()) { result.append(STR); entry = (Entry<String, ?>) iterator.next(); result.append(entry.getKey()); result.append(STR); value = entry.getValue(); if (value != null) result.append(value); } return result.toString(); }	"@SuppressWarnings(STR)
public static String append(String url, final Map<String, ?> params) {
    if (params == null || params.isEmpty())
        return url;
    StringBuilder result = new StringBuilder();
    if (!url.endsWith(STR))
        url += STR;
    Entry<String, ?> entry;
    Object value;
    Iterator<?> iterator = params.entrySet().iterator();
    entry = (Entry<String, ?>) iterator.next();
    result.append(entry.getKey());
    result.append(STR);
    value = entry.getValue();
    if (value != null)
        result.append(value);
    while (iterator.hasNext()) {
        result.append(STR);
        entry = (Entry<String, ?>) iterator.next();
        result.append(entry.getKey());
        result.append(STR);
        value = entry.getValue();
        if (value != null)
            result.append(value);
    }
    return url + STR + result.toString();
}"	@return URL with appended query params	@return URL with query params	1	0	10	30	212
public static List<CmdLineOptionValidator.Result> validate(CmdLineArgs cmdLineArgs) { Validate.notNull(cmdLineArgs); List<CmdLineOptionValidator.Result> results = Lists.newArrayList(); for (CmdLineOptionInstance optionInst : cmdLineArgs.getSpecifiedOptions()) { results.addAll(CmdLineUtils.validate(optionInst)); } return results; }	"public static Set<CmdLineOptionInstance> validate(CmdLineArgs cmdLineArgs) {
    Validate.notNull(cmdLineArgs);
    HashSet<CmdLineOptionInstance> optionsFailed = new HashSet<CmdLineOptionInstance>();
    for (CmdLineOptionInstance optionInst : cmdLineArgs.getSpecifiedOptions()) {
        if (!CmdLineUtils.validate(optionInst)) {
            optionsFailed.add(optionInst);
        }
    }
    return optionsFailed;
}"	@return The {@link CmdLineOptionValidator.Result}s generated when running {@link CmdLineOptionValidator}s.	@return The {@link CmdLineOptionInstance}s which failed validation.	1	0	8	8	52
public static double logAdd(double lx, double ly) { double max, negDiff; if (lx > ly) { max = lx; negDiff = ly - lx; } else { max = ly; negDiff = lx - ly; } return (max == Double.NEGATIVE_INFINITY || negDiff < -LOGTOLERANCE) ? max : // max + Math.log(1 + Math.exp(negDiff)); }	"  public static double logAdd(double lx, double ly) {
    double max, negDiff;
    if (lx > ly) {
      max = lx;
      negDiff = ly - lx;
    } else {
      max = ly;
      negDiff = lx - ly;
    }
    if (max == Double.NEGATIVE_INFINITY) {
      return max;
    } else if (negDiff < -LOGTOLERANCE) {
      return max;
    } else {
      return max + Math.log(1.0 + Math.exp(negDiff));
    }
  }
"	@return  log(exp(lx) + exp(ly))	@return log(exp(lx) + exp(ly))	0	1	9	13	74
public ModuleJarClassLoader getLoader() { return loader; }	"public ModuleClassLoader getLoader() {
    return loader;
}"	@return ModuleJarClassLoader	@return ModuleClassLoader	1	0	4	3	10
public int getMaxQueryTime() { return maxQueryTime; }	"public long getMaxQueryTime() {
    return maxQueryTime;
}"	@return The maximum query evaluation time, measured in seconds.	@return The maximum query evaluation time, in milliseconds.	1	0	4	3	10
public EDecimal<Double> div(Expr<D> right) { return ODecimal.create(Double.class, Ops.DIV, this, right); }	"    public ENumber<Double> div(Expr<D> right) {
        return ONumber.create(Double.class, Ops.DIV, this, right);
    }
"	@return this / right	@return this / right	0	1	6	4	26
static public boolean isCompatible(Mode mode, StringDict props) { String currentIdentifier = mode.getIdentifier(); StringList compatibleList = parseModeList(props); if (compatibleList.size() == 0) { if (mode.requireExampleCompatibility()) { // for p5js (and maybe Python), examples must specify that they work return false; } // if no Mode specified, assume compatible everywhere return true; } return compatibleList.hasValue(currentIdentifier); }	"  static public boolean isCompatible(Base base, StringDict props) {
    Mode mode = base.getActiveEditor().getMode();
    String currentIdentifier = mode.getIdentifier();
    StringList compatibleList = parseModeList(props);
    if (compatibleList.size() == 0) {
      if (mode.requireExampleCompatibility()) {
        // for p5js (and maybe Python), examples must specify that they work
        return false;
      }
      // if no Mode specified, assume compatible everywhere
      return true;
    }
    for (String c : compatibleList) {
      if (c.equals(currentIdentifier)) {
        return true;
      }
    }
    return false;
  }
"	@return true if compatible with the Mode of the currently active editor	@return true if the example is compatible with the mode of the currently active editor	1	0	8	14	85
public List<SqlTypeName> getTypeNames() { switch (this) { case CHARACTER: return SqlTypeName.charTypes; case BINARY: return SqlTypeName.binaryTypes; case NUMERIC: return SqlTypeName.numericTypes; case DATE: return ImmutableList.of(SqlTypeName.DATE); case TIME: return ImmutableList.of(SqlTypeName.TIME); case TIMESTAMP: return ImmutableList.of(SqlTypeName.TIMESTAMP); case BOOLEAN: return SqlTypeName.booleanTypes; case INTERVAL_YEAR_MONTH: return ImmutableList.of(SqlTypeName.INTERVAL_YEAR_MONTH); case INTERVAL_DAY_TIME: return ImmutableList.of(SqlTypeName.INTERVAL_DAY_TIME); case STRING: return SqlTypeName.stringTypes; case APPROXIMATE_NUMERIC: return SqlTypeName.approxTypes; case EXACT_NUMERIC: return SqlTypeName.exactTypes; case INTEGER: return SqlTypeName.intTypes; case DATETIME: return SqlTypeName.datetimeTypes; case DATETIME_INTERVAL: return SqlTypeName.intervalTypes; case MULTISET: return ImmutableList.of(SqlTypeName.MULTISET); case ARRAY: return ImmutableList.of(SqlTypeName.ARRAY); case MAP: return ImmutableList.of(SqlTypeName.MAP); case NULL: return ImmutableList.of(SqlTypeName.NULL); case ANY: return SqlTypeName.allTypes; case CURSOR: return ImmutableList.of(SqlTypeName.CURSOR); case COLUMN_LIST: return ImmutableList.of(SqlTypeName.COLUMN_LIST); default: throw new IllegalArgumentException(); } }	"  public List<SqlTypeName> getTypeNames() {
    return typeNames;
  }
"	@return collection of  SqlTypeNames included in this family	@return collection of SqlTypeNames included in this family	0	1	7	51	220
"public static String findReg() { if (reg != null) return reg; File systemRoot = findSystemRoot(); File regExe = new File(systemRoot, ""system32/reg.exe""); if (regExe.exists()) { reg = regExe.getAbsolutePath(); return reg; } regExe = new File(""c:\\ntreskit""); if (regExe.exists()) { reg = regExe.getAbsolutePath(); return reg; } regExe = AsyncExecute.whichExec(""reg.exe""); if (regExe != null && regExe.exists()) { reg = regExe.getAbsolutePath(); return reg; } System.err.println(""OS Version: "" + System.getProperty(""os.version"")); throw new RuntimeException(""Couldn't find reg.exe!\n"" + ""Please download it from Microsoft and install it in a standard location.\n"" + ""See here for details: http://wiki.openqa.org/display/SRC/Windows+Registry+Support""); }"	"    public static String findReg() {
        if (reg != null) return reg;
        File systemRoot = findSystemRoot();
        File regExe = new File(systemRoot, ""system32/reg.exe"");
        if (regExe.exists()) {
            reg = regExe.getAbsolutePath();
            return reg;
        }
        System.err.println(""Couldn't find reg! Hope it's on the path..."");
        reg = ""reg"";
        return reg;
    }
"	"@return the exact path to reg.exe, or just the string ""reg"" if it couldn't be found (in which case you can pass that to exec to try to run it from the path)"	"@return the exact path to reg.exe, or just the string ""reg"" if it couldn't be found (in which case you can pass that to exec to try to run it from the path)"	0	1	7	24	199
public static Method findGetMethod(Field field, boolean throwExceptions) throws IllegalArgumentException { Method fieldGetMethod; if (Locale.ENGLISH.equals(Locale.getDefault())) { fieldGetMethod = findMethodFromNames(field, true, throwExceptions, methodFromField(field, STR, null), methodFromField(field, STR, null)); } else { fieldGetMethod = findMethodFromNames(field, true, throwExceptions, methodFromField(field, STR, null), methodFromField(field, STR, Locale.ENGLISH), methodFromField(field, STR, null), methodFromField(field, STR, Locale.ENGLISH)); } if (fieldGetMethod == null) { return null; } if (fieldGetMethod.getReturnType() != field.getType()) { if (throwExceptions) { throw new IllegalArgumentException(STR + fieldGetMethod.getName() + STR + field.getType()); } else { return null; } } return fieldGetMethod; }	"public static Method findGetMethod(Field field, boolean throwExceptions) {
    String methodName = methodFromField(field, STR);
    Method fieldGetMethod;
    try {
        try {
            fieldGetMethod = field.getDeclaringClass().getMethod(methodName);
        } catch (NoSuchMethodException nsme) {
            if (field.getType() == Boolean.class || field.getType() == boolean.class) {
                methodName = methodFromField(field, STR);
                fieldGetMethod = field.getDeclaringClass().getMethod(methodName);
            } else {
                throw nsme;
            }
        }
    } catch (Exception e) {
        if (throwExceptions) {
            throw new IllegalArgumentException(STR + field);
        } else {
            return null;
        }
    }
    if (fieldGetMethod.getReturnType() != field.getType()) {
        if (throwExceptions) {
            throw new IllegalArgumentException(STR + methodName + STR + field.getType());
        } else {
            return null;
        }
    }
    return fieldGetMethod;
}"	@return Get method or null (or throws IllegalArgumentException) if none found.	@return Get method or null if none found.	1	0	12	19	169
private boolean areViewsIdentical(View firstView, View secondView){ if(firstView.getId() != secondView.getId() || !firstView.getClass().isAssignableFrom(secondView.getClass())){ return false; } if (firstView.getParent() != null && firstView.getParent() instanceof View && secondView.getParent() != null && secondView.getParent() instanceof View) { return areViewsIdentical((View) firstView.getParent(), (View) secondView.getParent()); } else { return true; } }	"	private boolean areViewsIdentical(View firstView, View secondView){

		if(firstView.getId() != secondView.getId() || !firstView.getClass().isAssignableFrom(secondView.getClass())){
			return false;
		}

		if(!isSamePlacementInRespectiveTree(firstView, secondView)){
			return false;
		}

		if (firstView.getParent() != null && firstView.getParent() instanceof View && 
				secondView.getParent() != null && secondView.getParent() instanceof View) {

			return areViewsIdentical((View) firstView.getParent(), (View) secondView.getParent());
		} else {
			return true;
		}
	}
"	@return true if views are equal	@return true if views are equal	0	1	8	14	104
public List<InstanceInfo> getInstancesByVirtualHostName(String virtualHostName) { return Optional.ofNullable(this.virtualHostNameAppMap.get(virtualHostName.toUpperCase(Locale.ROOT))) .map(VipIndexSupport::getVipList) .map(AtomicReference::get) .orElseGet(Collections::emptyList); }	"    public List<InstanceInfo> getInstancesByVirtualHostName(String virtualHostName) {
        AtomicReference<List<InstanceInfo>> ref = this.shuffleVirtualHostNameMap
                .get(virtualHostName.toUpperCase(Locale.ROOT));
        if (ref == null || ref.get() == null) {
            return new ArrayList<InstanceInfo>();
        } else {
            return ref.get();
        }
    }
"	@return list of instances.	@return list of instances.	0	1	8	7	48
public Builder host(String host) { this.host = host; return this; }	"public static Builder host(final String host) {
    return builder().host(host);
}"	@return Builder	@return ping host	1	0	6	4	16
"protected static WebcamDriver findDriver(String[] drivers) { if (LOG.isInfoEnabled()) { StringBuffer sb = new StringBuffer(); for (int i = 0; i < drivers.length; i++) { sb.append(drivers[i]).append(i < drivers.length - 1 ? "", "" : """"); } LOG.info(""Searching for one of the webcam drivers ["" + sb.toString() + ""]""); } for (String name : drivers) { Class<?> clazz = null; try { clazz = Class.forName(""com.github.sarxos.webcam.ds."" + name); } catch (ClassNotFoundException e) { continue; } LOG.info(""Webcam driver has been found: "" + name); try { return (WebcamDriver) clazz.newInstance(); } catch (InstantiationException e) { throw new RuntimeException(e); } catch (IllegalAccessException e) { throw new RuntimeException(e); } } LOG.error(""Webcam driver has not been found! Please add one to the classpath!""); throw new WebcamException(""No webcam driver available""); }"	"	protected static WebcamDriver findDriver(String[] drivers) {

		if (LOG.isInfoEnabled()) {
			StringBuffer sb = new StringBuffer();
			for (int i = 0; i < drivers.length; i++) {
				sb.append(drivers[i]).append(i < drivers.length - 1 ? "", "" : """");
			}
			LOG.info(""Searching for one of the webcam drivers ["" + sb.toString() + ""]"");
		}

		for (String name : drivers) {

			String pkgname = ""com.github.sarxos.webcam.ds."" + name;

			WebcamDriver driver = null;
			Class<?>[] classes = WebcamDriverUtils.getClasses(pkgname, true);

			if (LOG.isDebugEnabled()) {
				LOG.debug(""Searching for classes in "" + pkgname + "", found "" + classes.length);
			}

			if (classes.length == 0) {
				continue;
			}

			for (Class<?> clazz : classes) {
				if (WebcamDriver.class.isAssignableFrom(clazz)) {
					try {
						driver = (WebcamDriver) clazz.newInstance();
					} catch (InstantiationException e) {
						throw new RuntimeException(e);
					} catch (IllegalAccessException e) {
						throw new RuntimeException(e);
					}
					break;
				}
			}

			LOG.info(""Webcam driver has been found: "" + name);

			return driver;
		}

		LOG.error(""Webcam driver has not been found! Please add one to the classpath!"");

		throw new WebcamException(""No webcam driver available"");
	}
"	@return Driver if found or throw exception	@return Driver if found or throw exception	0	1	13	36	221
public long getId() { return id; }	"public long getId() {
    return id_category;
}"	@return the id	@return the id_category	1	0	4	3	10
@SuppressWarnings(STR) public ObjectName getExchangeObjectName(String virtualHostName, String exchange) { AllObjects allObject = new AllObjects(_mbsc); allObject.querystring = STR + virtualHostName + STR + exchange + STR; Set<ObjectName> objectNames = allObject.returnObjects(); _test.assertNotNull(STR, objectNames); _test.assertEquals(STR + exchange + STR, NUM, objectNames.size()); ObjectName objectName = objectNames.iterator().next(); _test.getLogger().info(STR + objectName); return objectName; }	"public ObjectName getExchangeObjectName(String virtualHostName, String exchange) {
    AllObjects allObject = new AllObjects(_mbsc);
    allObject.querystring = STR + virtualHostName + STR + exchange + STR;
    Set<ObjectName> objectNames = allObject.returnObjects();
    _test.assertNotNull(STR, objectNames);
    _test.assertEquals(STR + exchange + STR, NUM, objectNames.size());
    return objectNames.iterator().next();
}"	@return the ObjectName for the given Exchange on the VirtualHost	@return the ObjectName for the given exchange on the test VirtualHost.	1	0	9	11	94
"public static boolean checkAlreadyExist(AccountDatabase.AccountName s) { Realm realm = Realm.getDefaultInstance(); // Query in the realm database RealmQuery<AccountDatabase> query = realm.where(AccountDatabase.class); // Checking if string equals to is exist or not query.equalTo(""name"", s.toString()); RealmResults<AccountDatabase> result1 = query.findAll(); // Here checking if count of that values is greater than zero return (result1.size() > 0); }"	"    public static boolean checkAlreadyExist(AccountDatabase.AccountName s) {
        Realm realm = Realm.getDefaultInstance();
        // Query in the realm database
        RealmQuery<AccountDatabase> query = realm.where(AccountDatabase.class);

        // Checking if string equals to is exist or not
        query.equalTo(""name"", s.toString());
        RealmResults<AccountDatabase> result1 = query.findAll();

        // Here checking if count of that values is greater than zero
        return (result1.size() > 0) ? true : false;
    }
"	@return true is existed, false otherwise	@return true is existed, false otherwise	0	1	7	13	89
public Collection<InMemoryJob> getAllJobs() { return new ArrayList<>(jobs.values()); }	"        public Collection<InMemoryJob> getAllJobs() {
            return new ArrayList<InMemoryJob>(jobs.values());
        }
"	@return a Collection containing all the managed jobs for this task.	@return a Collection containing all the managed jobs for this task.	0	1	5	4	18
public static char[] union(char[]... list) { StringBuilder sb = new StringBuilder(); for (char[] characters : list) { for (int i = NUM; i < list.length; i++) { if (!contains(sb, characters[i])) sb.append(list[i]); } } char[] toReturn = new char[sb.length()]; sb.getChars(NUM, sb.length(), toReturn, NUM); Arrays.sort(toReturn); return toReturn; }	"public static char[] union(char[] c1, char[] c2) {
    StringBuilder sb = new StringBuilder();
    for (int i = NUM; i < c1.length; i++) {
        if (!contains(sb, c1[i]))
            sb.append(c1[i]);
    }
    for (int i = NUM; i < c2.length; i++) {
        if (!contains(sb, c2[i]))
            sb.append(c2[i]);
    }
    char[] c3 = new char[sb.length()];
    sb.getChars(NUM, sb.length(), c3, NUM);
    Arrays.sort(c3);
    return c3;
}"	@return the union of the char[]s	@return the char[]	1	0	12	13	107
public ExtensionHandler getExtensionHandler() { return generatorContext.getExtensionHandler(); }	"public ExtensionHandler getExtensionHandler() {
    return extensionHandler;
}"	@return the extension handler used by the DOMTreeManager.	@return the extension handler used by this SVGGraphics2D instance	1	0	4	3	13
"public static ExpectedCondition<Boolean> titleContains(final String title) { return new ExpectedCondition<Boolean>() { private String currentTitle = """"; public Boolean apply(WebDriver driver) { currentTitle = driver.getTitle(); return currentTitle != null && currentTitle.contains(title); } @Override public String toString() { return String.format(""title to contain \""%s\"". Current title: \""%s\"""", title, currentTitle); } }; }"	"  public static ExpectedCondition<Boolean> titleContains(final String title) {
    return new ExpectedCondition<Boolean>() {
      public Boolean apply(WebDriver driver) {
        String currentTitle = driver.getTitle();
        return currentTitle == null ? false : currentTitle.contains(title);
      }

      @Override
      public String toString() {
        return ""title to contain "" + title;
      }
    };
  }
"	@return true when the title matches, false otherwise	@return true when the title matches, false otherwise	0	1	9	16	93
public MetricFilter getFilter() { final StringMatchingStrategy stringMatchingStrategy = getUseRegexFilters() ? REGEX_STRING_MATCHING_STRATEGY : DEFAULT_STRING_MATCHING_STRATEGY; return new MetricFilter() { @Override public boolean matches(final String name, final Metric metric) { // Include the metric if its name is not excluded and its name is included // Where, by default, with no includes setting, all names are included. return !stringMatchingStrategy.containsMatch(getExcludes(), name) && (getIncludes().isEmpty() || stringMatchingStrategy.containsMatch(getIncludes(), name)); } }; }	"    public MetricFilter getFilter() {
        final StringMatchingStrategy stringMatchingStrategy = getUseRegexFilters() ?
                REGEX_STRING_MATCHING_STRATEGY : DEFAULT_STRING_MATCHING_STRATEGY;

        return new MetricFilter() {
            @Override
            public boolean matches(final String name, final Metric metric) {
                boolean useIncl = !getIncludes().isEmpty();
                boolean useExcl = !getExcludes().isEmpty();

                if (useIncl && useExcl) {
                    return stringMatchingStrategy.containsMatch(getIncludes(), name) ||
                            !stringMatchingStrategy.containsMatch(getExcludes(), name);
                }
                else if (useIncl && !useExcl) {
                    return stringMatchingStrategy.containsMatch(getIncludes(), name);
                }
                else if (!useIncl && useExcl) {
                    return !stringMatchingStrategy.containsMatch(getExcludes(), name);
                }
                else {
                    return true;
                }
            }
        };
    }
"	@return the filter for selecting metrics based on the configured excludes/includes.	@return the filter for selecting metrics based on the configured excludes/includes.	0	1	10	15	107
public Object getProperty(String name) { if (name == null || !isPropertySupported(name)) throw new IllegalArgumentException(); return callProperties.get(name); }	"public Object getProperty(String name) {
    if (name != null)
        return callProperties.get(name);
    return null;
}"	@return Object value of the property or null if the property is not set	@return Object value of the property - or null	1	0	6	5	34
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 35: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, yytext()); } case 50: break; case 8: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 51: break; case 19: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 52: break; case 47: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; // try to work around an apparent jflex bug where it // gets a space at the token end by getting // wrong the length of the trailing context. while (yylength() > 0) { char last = yycharat(yylength()-1); if (last == ' ' || last == '\t' || (last >= '\n' && last <= '\r' || last == '\u0085')) { yypushback(1); } else { break; } } if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 53: break; case 15: { return handleQuotes(yytext(), false); } case 54: break; case 32: // lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), false); } case 55: break; case 24: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 56: break; case 30: // lookahead expression with fixed lookahead length yypushback(1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 57: break; case 44: // lookahead expression with fixed lookahead length yypushback(1); { return getNormalizedAmpNext(); } case 58: break; case 31: { return getNormalizedAmpNext(); } case 59: break; case 34: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, yytext()); } case 60: break; case 48: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 4; { return getNext(); } case 61: break; case 40: // lookahead expression with fixed lookahead length yypushback(2); { return getNext(); } case 62: break; case 38: // general lookahead, find correct zzMarkedPos { int zzFState = 13; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 12; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 63: break; case 37: // general lookahead, find correct zzMarkedPos { int zzFState = 11; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 12; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 64: break; case 4: { return getNext(); } case 65: break; case 21: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(); } case 66: break; case 46: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } return getNext(txt, yytext()); } case 67: break; case 23: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, origTxt); } case 68: break; case 6: { if (normalizeOtherBrackets) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 69: break; case 7: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 70: break; case 28: // general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 71: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 72: break; case 43: { yypushback(2) ; return getNext(); } case 73: break; case 25: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 74: break; case 18: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 75: break; case 49: { String txt = yytext(); if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 76: break; case 45: { yypushback(3) ; return getNext(); } case 77: break; case 22: // lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), true); } case 78: break; case 2: { if (normalizeOtherBrackets) { return getNext(openparen, yytext()); } else { return getNext(); } } case 79: break; case 36: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 80: break; case 20: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 81: break; case 17: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 82: break; case 11: { return handleEllipsis(yytext()); } case 83: break; case 33: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 1; { /* invert quote - often but not always right */ return handleQuotes(yytext(), true); } case 84: break; case 13: { return normalizeFractions(yytext()); } case 85: break; case 14: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(); } } case 86: break; case 41: // general lookahead, find correct zzMarkedPos { int zzFState = 9; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 10; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 87: break; case 10: { if (invertible) { prevWordAfter.append(yytext()); } } case 88: break; case 3: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 89: break; case 42: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 90: break; case 12: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 91: break; case 27: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 92: break; case 9: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 93: break; case 29: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 94: break; case 26: { // this one should only match if we're basically at the end of file // since the last one matches two things, even newlines String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 95: break; case 1: { String str = yytext(); int first = str.charAt(0); String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } LOGGER.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: LOGGER.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 96: break; case 39: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 97: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 98: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }"	"  public Object next() throws java.io.IOException {
    int zzInput;
    int zzAction;

    // cached fields:
    int zzCurrentPosL;
    int zzMarkedPosL;
    int zzEndReadL = zzEndRead;
    char [] zzBufferL = zzBuffer;
    char [] zzCMapL = ZZ_CMAP;

    int [] zzTransL = ZZ_TRANS;
    int [] zzRowMapL = ZZ_ROWMAP;
    int [] zzAttrL = ZZ_ATTRIBUTE;

    while (true) {
      zzMarkedPosL = zzMarkedPos;

      yychar+= zzMarkedPosL-zzStartRead;

      zzAction = -1;

      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
  
      zzState = ZZ_LEXSTATE[zzLexicalState];


      zzForAction: {
        while (true) {
    
          if (zzCurrentPosL < zzEndReadL)
            zzInput = zzBufferL[zzCurrentPosL++];
          else if (zzAtEOF) {
            zzInput = YYEOF;
            break zzForAction;
          }
          else {
            // store back cached positions
            zzCurrentPos  = zzCurrentPosL;
            zzMarkedPos   = zzMarkedPosL;
            boolean eof = zzRefill();
            // get translated positions and possibly new buffer
            zzCurrentPosL  = zzCurrentPos;
            zzMarkedPosL   = zzMarkedPos;
            zzBufferL      = zzBuffer;
            zzEndReadL     = zzEndRead;
            if (eof) {
              zzInput = YYEOF;
              break zzForAction;
            }
            else {
              zzInput = zzBufferL[zzCurrentPosL++];
            }
          }
          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
          if (zzNext == -1) break zzForAction;
          zzState = zzNext;

          int zzAttributes = zzAttrL[zzState];
          if ( (zzAttributes & 1) == 1 ) {
            zzAction = zzState;
            zzMarkedPosL = zzCurrentPosL;
            if ( (zzAttributes & 8) == 8 ) break zzForAction;
          }

        }
      }

      // store back cached position
      zzMarkedPos = zzMarkedPosL;

      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
        case 34: 
          { String txt = yytext();
                  if (escapeForwardSlashAsterisk) {
                    txt = delimit(txt, '/');
                  }
                  if (normalizeSpace) {
                    // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                    txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space

                  }
                  return getNext(txt, yytext());
          }
        case 49: break;
        case 8: 
          { if (ptb3Dashes) {
                            return getNext(ptbmdash, yytext()); }
                          else {
                            return getNext();
                          }
          }
        case 50: break;
        case 19: 
          { if (escapeForwardSlashAsterisk) {
                    return getNext(delimit(yytext(), '*'), yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 51: break;
        case 46: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 7;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 8;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { String s;
                          // try to work around an apparent jflex bug where it
                          // gets a space at the token end by getting
                          // wrong the length of the trailing context.
                          while (yylength() > 0) {
                            char last = yycharat(yylength()-1);
                            if (last == ' ' || last == '\t' || (last >= '\n' && last <= '\r' || last == '\u0085')) {
                              yypushback(1);
                            } else {
                              break;
                            }
                          }
                          if (strictTreebank3 && ! ""U.S."".equals(yytext())) {
                            yypushback(1); // return a period for next time
                            s = yytext();
                          } else {
                            s = yytext();
                            yypushback(1); // return a period for next time
                          }
                          return getNext(s, yytext());
          }
        case 52: break;
        case 15: 
          { return handleQuotes(yytext(), false);
          }
        case 53: break;
        case 31: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return handleQuotes(yytext(), false);
          }
        case 54: break;
        case 21: 
          { String txt = yytext();
                  String origText = txt;
                  if (normalizeParentheses) {
                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                  }
                  return getNext(txt, origText);
          }
        case 55: break;
        case 43: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return getNormalizedAmpNext();
          }
        case 56: break;
        case 30: 
          { return getNormalizedAmpNext();
          }
        case 57: break;
        case 33: 
          { String txt = yytext();
                  if (escapeForwardSlashAsterisk) {
                    txt = delimit(txt, '/');
                  }
                  if (normalizeSpace) {
                    // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                    txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                  }
                  return getNext(txt, yytext());
          }
        case 58: break;
        case 47: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 4;
          { return getNext();
          }
        case 59: break;
        case 39: 
          // lookahead expression with fixed lookahead length
          yypushback(2);
          { return getNext();
          }
        case 60: break;
        case 37: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 13;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 12;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { return getNext();
          }
        case 61: break;
        case 36: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 11;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 12;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { return getNext();
          }
        case 62: break;
        case 4: 
          { return getNext();
          }
        case 63: break;
        case 22: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return getNext();
          }
        case 64: break;
        case 45: 
          { String txt = yytext();
                          if (escapeForwardSlashAsterisk) {
                            txt = delimit(txt, '/');
                          }
                          return getNext(txt, yytext());
          }
        case 65: break;
        case 24: 
          { final String origTxt = yytext();
                          String txt = origTxt;
                          if (normalizeSpace) {
                            // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                            txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                          }
                          return getNext(txt, origTxt);
          }
        case 66: break;
        case 6: 
          { if (normalizeOtherBrackets) {
                    return getNext(closeparen, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 67: break;
        case 7: 
          { final String origTxt = yytext();
                          String tmp = removeSoftHyphens(origTxt);
                          if (americanize) {
                            tmp = Americanize.americanize(tmp);
                          }
                          return getNext(tmp, origTxt);
          }
        case 68: break;
        case 28: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 3;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 4;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { final String origTxt = yytext();
                          String tmp = removeSoftHyphens(origTxt);
                          if (americanize) {
                            tmp = Americanize.americanize(tmp);
                          }
                          return getNext(tmp, origTxt);
          }
        case 69: break;
        case 16: 
          { if (normalizeOtherBrackets) {
                    return getNext(closebrace, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 70: break;
        case 42: 
          { yypushback(2) ; return getNext();
          }
        case 71: break;
        case 25: 
          { if (escapeForwardSlashAsterisk) {
                            return getNext(delimit(yytext(), '/'), yytext());
                          } else {
                            return getNext();
                          }
          }
        case 72: break;
        case 18: 
          { if (normalizeParentheses) {
                    return getNext(closeparen, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 73: break;
        case 48: 
          { String txt = yytext();
                          if (normalizeSpace) {
                            // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                            txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                          }
                          if (normalizeParentheses) {
                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                          }
                          return getNext(txt, yytext());
          }
        case 74: break;
        case 44: 
          { yypushback(3) ; return getNext();
          }
        case 75: break;
        case 23: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return handleQuotes(yytext(), true);
          }
        case 76: break;
        case 2: 
          { if (normalizeOtherBrackets) {
                    return getNext(openparen, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 77: break;
        case 35: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 5;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 6;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { final String txt = yytext();
                          return getNext(removeSoftHyphens(txt),
                                         txt);
          }
        case 78: break;
        case 20: 
          { if (normalizeOtherBrackets) {
                    return getNext(openbrace, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 79: break;
        case 17: 
          { if (normalizeParentheses) {
                    return getNext(openparen, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 80: break;
        case 11: 
          { return handleEllipsis(yytext());
          }
        case 81: break;
        case 32: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 1;
          { /* invert quote - often but not always right */
                  return handleQuotes(yytext(), true);
          }
        case 82: break;
        case 13: 
          { return normalizeFractions(yytext());
          }
        case 83: break;
        case 14: 
          { if (normalizeCurrency) {
                            return getNext(normalizeCurrency(yytext()), yytext()); }
                          else {
                            return getNext();
                          }
          }
        case 84: break;
        case 40: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 9;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 10;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { String s;
                          if (strictTreebank3 && ! ""U.S."".equals(yytext())) {
                            yypushback(1); // return a period for next time
                            s = yytext();
                          } else {
                            s = yytext();
                            yypushback(1); // return a period for next time
                          }
                          return getNext(s, yytext());
          }
        case 85: break;
        case 10: 
          { if (invertible) {
                     prevWordAfter.append(yytext());
                  }
          }
        case 86: break;
        case 3: 
          { if (escapeForwardSlashAsterisk) {
                    return getNext(delimit(yytext(), '/'), yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 87: break;
        case 41: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return getNext(removeSoftHyphens(yytext()),
                                               yytext());
          }
        case 88: break;
        case 12: 
          { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {
                    return getNext(ptbmdash, yytext());
                  } else {
                    return getNext();
                  }
          }
        case 89: break;
        case 27: 
          { return getNext(removeSoftHyphens(yytext()), yytext());
          }
        case 90: break;
        case 9: 
          { return getNext(removeSoftHyphens(yytext()),
                                         yytext());
          }
        case 91: break;
        case 29: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return getNext(removeSoftHyphens(yytext()),
                                         yytext());
          }
        case 92: break;
        case 26: 
          { // this one should only match if we're basically at the end of file
                          // since the last one matches two things, even newlines
                          String s;
                          if (strictTreebank3 && ! ""U.S."".equals(yytext())) {
                            yypushback(1); // return a period for next time
                            s = yytext();
                          } else {
                            s = yytext();
                            yypushback(1); // return a period for next time
                          }
                          return getNext(s, yytext());
          }
        case 93: break;
        case 1: 
          { String str = yytext();
          int first = str.charAt(0);
          String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));
          switch (untokenizable) {
            case NONE_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              break;
            case FIRST_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              if ( ! this.seenUntokenizableCharacter) {
                LOGGER.warning(msg);
                this.seenUntokenizableCharacter = true;
              }
              break;
            case ALL_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              LOGGER.warning(msg);
              this.seenUntokenizableCharacter = true;
              break;
            case NONE_KEEP:
              return getNext();
            case FIRST_KEEP:
              if ( ! this.seenUntokenizableCharacter) {
                LOGGER.warning(msg);
                this.seenUntokenizableCharacter = true;
              }
              return getNext();
            case ALL_KEEP:
              LOGGER.warning(msg);
              this.seenUntokenizableCharacter = true;
              return getNext();
          }
          }
        case 94: break;
        case 38: 
          { String txt = yytext();
                          if (escapeForwardSlashAsterisk) {
                            txt = delimit(txt, '/');
                            txt = delimit(txt, '*');
                          }
                          return getNext(txt, yytext());
          }
        case 95: break;
        case 5: 
          { if (tokenizeNLs) {
                      return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns
                  } else if (invertible) {
                      prevWordAfter.append(yytext());
                  }
          }
        case 96: break;
        default: 
          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
            zzAtEOF = true;
              {
                if (invertible) {
            prevWordAfter.append(yytext());
            String str = prevWordAfter.toString();
            prevWordAfter.setLength(0);
            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);
          }
          return null;
              }
          } 
          else {
            zzScanError(ZZ_NO_MATCH);
          }
      }
    }
  }
"	@return the next token	@return the next token	0	1	17	625	3731
"public boolean isChecked(String locator) { return (Boolean) seleneseMethods.get(""isChecked"").apply(driver, locator); }"	"  public boolean isChecked(String locator) {
    return elementFinder.findElement(driver, locator)
        .isSelected();
  }
"	@return true if the checkbox is checked, false otherwise	@return true if the checkbox is checked, false otherwise	0	1	7	4	27
"private ZapMenuItem getMenuHelpAbout() { if (menuHelpAbout == null) { menuHelpAbout = new ZapMenuItem(""menu.help.about""); menuHelpAbout.addActionListener(new java.awt.event.ActionListener() { @Override public void actionPerformed(java.awt.event.ActionEvent e) { AboutDialog dialog = new AboutDialog(View.getSingleton().getMainFrame(), true); dialog.setVisible(true); } }); } return menuHelpAbout; }"	"	private JMenuItem getMenuHelpAbout() {
		if (menuHelpAbout == null) {
			menuHelpAbout = new JMenuItem();
			// ZAP: Rebrand
			menuHelpAbout.setText(Constant.messages.getString(""menu.help.about"")); // ZAP: i18n
			menuHelpAbout.addActionListener(new java.awt.event.ActionListener() { 

				@Override
				public void actionPerformed(java.awt.event.ActionEvent e) {    

					AboutDialog dialog = new AboutDialog(View.getSingleton().getMainFrame(), true);
					dialog.setVisible(true);
					
				}
			});

		}
		return menuHelpAbout;
	}
"	@return javax.swing.ZapMenuItem	@return javax.swing.JMenuItem	1	0	13	15	78
"public HBaseResponse getHTableInfo(String tableName) throws IOException { HBaseResponse hr = htableInfoCache.getIfPresent(tableName); if (null != hr) { return hr; } hr = new HBaseResponse(); if (""hbase"".equals(getConfig().getMetadataUrl().getScheme())) { try { // use reflection to isolate NoClassDef errors when HBase is not available hr = (HBaseResponse) Class.forName(""org.apache.kylin.rest.service.HBaseInfoUtil"")// .getMethod(""getHBaseInfo"", new Class[] { String.class, KylinConfig.class })// .invoke(null, tableName, this.getConfig()); } catch (Throwable e) { throw new IOException(e); } } htableInfoCache.put(tableName, hr); return hr; }"	"    public HBaseResponse getHTableInfo(String tableName) throws IOException, ExecutionException {
        return htableInfoCache.get(tableName);
    }
"	@return The HBaseResponse object contains table size, region count. null if error happens	@return The HBaseResponse object contains table size, region count. null if error happens	0	1	14	22	147
@Override public AsyncAppenderBase<IAccessEvent> build() { return new AsyncAppenderBase<IAccessEvent>() { @Override protected void preprocess(IAccessEvent event) { event.prepareForDeferredProcessing(); } }; }	"@Override
public AsyncAppenderBase<IAccessEvent> build() {
    return new AsyncAppenderBase<IAccessEvent>();
}"	@return the {@link AsyncAppenderFactory}	@return the {@link AsyncAppenderBase}	1	0	7	10	35
public RuntimeWiring build() { return new RuntimeWiring(dataFetchers, defaultDataFetchers, scalars, typeResolvers, registeredDirectiveWiring, directiveWiring, enumValuesProviders, wiringFactory, schemaTransformers, fieldVisibility, codeRegistry); }	"        public RuntimeWiring build() {
            return new RuntimeWiring(dataFetchers, defaultDataFetchers, scalars, typeResolvers, directiveWiring, enumValuesProviders, wiringFactory, schemaTransformers, fieldVisibility, codeRegistry);
        }
"	@return the built runtime wiring	@return the built runtime wiring	0	1	5	4	34
public WireType getWireType() { return queue.wireType(); }	"public WireType getWireType() {
    return wireType;
}"	@return the queue wire type	@return the wireType	1	0	4	3	13
public static DateTimeExpression<Date> currentDate() { return Constants.CURRENT_DATE; }	"    public static DateTimeExpression<Date> currentDate() {
        return CURRENT_DATE;
    }
"	@return current date	@return current date	0	1	5	4	13
@Override public int hashCode() { int hash = NUM; hash = hash * NUM + Double.valueOf(getRank()).hashCode(); hash = hash * NUM + mUrlDevice.hashCode(); hash = hash * NUM + mPwsResult.hashCode(); return hash; }	"public int hashCode() {
    assert false : STR;
    return NUM;
}"	@return hash code	@return 42.	1	0	7	8	52
"public DurationField days() { return UnsupportedDurationField.getInstance(""days""); }"	"    public DurationField days() {
        return UnsupportedDurationField.INSTANCE;
    }
"	@return DurationField or UnsupportedDurationField if unsupported	@return DurationField or UnsupportedDurationField if unsupported	0	1	5	4	16
public Debugger getDebugger() { return debugger; }	"    public Debugger getDebugger() {
        return dbg;
    }
"	@return the debugger controller object	@return the debugger controller object	0	1	4	4	10
private ServiceReference[] getInitialReferences(boolean trackAllServices, String className, String filterString) throws InvalidSyntaxException { if (trackAllServices) { return context.getAllServiceReferences(className, filterString); } return context.getServiceReferences(className, filterString); }	"private ServiceReference[] getInitialReferences(boolean trackAllServices, String trackClass, String filterString) throws InvalidSyntaxException {
    if (trackAllServices) {
        return context.getAllServiceReferences(trackClass, filterString);
    } else {
        return context.getServiceReferences(trackClass, filterString);
    }
}"	@return The list of initial <code>ServiceReference</code>s.	@return the list of initial <code>ServiceReference</code> objects.	1	0	7	6	43
public LockMode getAliasSpecificLockMode(String alias) { if ( aliasSpecificLockModes == null ) { return null; } return (LockMode) aliasSpecificLockModes.get( alias ); }	"	public LockMode getAliasSpecificLockMode(String alias) {
		return (LockMode) aliasSpecificLockModes.get( alias );
	}
"	@return The explicit lock mode for that alias.	@return The explicit lock mode for that alias.	0	1	6	7	29
public String getMatches() { StringBuilder sb = new StringBuilder(); for (int i = NUM, sz = list.getModel().getSize(); i < sz; i++) { Tree t = ((TreeFromFile) list.getModel().getElementAt(i)).getTree(); sb.append(t.pennString()); sb.append(STR); } return sb.toString(); }	"public StringBuffer getMatches() {
    StringBuffer sb = new StringBuffer();
    for (int i = NUM; i < list.getModel().getSize(); i++) {
        Tree t = ((TreeFromFile) list.getModel().getElementAt(i)).getTree();
        sb.append(t.pennString());
        sb.append(STR);
    }
    return sb;
}"	@return String filled with the Penn treebank forms of all trees in the matches panel	@return StringBuffer filled with the penn treebank forms of all trees in the matches panel	1	0	10	9	78
public Double getNdv(SchemaPath col) { // Stats might not have materialized because of errors. if (!materialized) { return null; } Long ndvCol = ndv.get(col); // Ndv estimation techniques like HLL may over-estimate, hence cap it at rowCount if (ndvCol != null) { return (double) Math.min(ndvCol, rowCount); } return null; }	"  public Double getNdv(SchemaPath col) {
    // Stats might not have materialized because of errors.
    if (!materialized) {
      return null;
    }
    Long ndvCol = ndv.get(col);
    // Ndv estimation techniques like HLL may over-estimate, hence cap it at rowCount
    if (ndvCol != null) {
      return Math.min(ndvCol, rowCount);
    }
    return null;
  }
"	@return approximate count distinct of the column, if available. NULL otherwise.	@return approximate count distinct of the column, if available. NULL otherwise.	0	1	8	13	77
"public static Value astFromValue(Object value, GraphQLType type) { if (value == null) { return null; } if (isNonNull(type)) { return handleNonNull(value, (GraphQLNonNull) type); } // Convert JavaScript array to GraphQL list. If the GraphQLType is a list, but // the value is not an array, convert the value using the list's item type. if (isList(type)) { return handleList(value, (GraphQLList) type); } // Populate the fields of the input object by creating ASTs from each value // in the JavaScript object according to the fields in the input type. if (type instanceof GraphQLInputObjectType) { return handleInputObject(value, (GraphQLInputObjectType) type); } if (!(type instanceof GraphQLScalarType || type instanceof GraphQLEnumType)) { throw new AssertException(""Must provide Input Type, cannot use: "" + type.getClass()); } // Since value is an internally represented value, it must be serialized // to an externally represented value before converting into an AST. final Object serialized = serialize(type, value); if (isNullish(serialized)) { return null; } // Others serialize based on their corresponding JavaScript scalar types. if (serialized instanceof Boolean) { return BooleanValue.newBooleanValue().value((Boolean) serialized).build(); } String stringValue = serialized.toString(); // numbers can be Int or Float values. if (serialized instanceof Number) { return handleNumber(stringValue); } if (serialized instanceof String) { // Enum types use Enum literals. if (type instanceof GraphQLEnumType) { return EnumValue.newEnumValue().name(stringValue).build(); } // ID types can use Int literals. if (type == Scalars.GraphQLID && stringValue.matches(""^[0-9]+$"")) { return IntValue.newIntValue().value(new BigInteger(stringValue)).build(); } // String types are just strings but JSON'ised return StringValue.newStringValue().value(stringValue).build(); } throw new AssertException(""'Cannot convert value to AST: "" + serialized); }"	"    public static Value astFromValue(Object value, GraphQLType type) {
        if (value == null) {
            return null;
        }

        if (isNonNull(type)) {
            return handleNonNull(value, (GraphQLNonNull) type);
        }

        // Convert JavaScript array to GraphQL list. If the GraphQLType is a list, but
        // the value is not an array, convert the value using the list's item type.
        if (isList(type)) {
            return handleList(value, (GraphQLList) type);
        }

        // Populate the fields of the input object by creating ASTs from each value
        // in the JavaScript object according to the fields in the input type.
        if (type instanceof GraphQLInputObjectType) {
            return handleInputObject(value, (GraphQLInputObjectType) type);
        }

        if (!(type instanceof GraphQLScalarType || type instanceof GraphQLEnumType)) {
            throw new AssertException(""Must provide Input Type, cannot use: "" + type.getClass());
        }

        // Since value is an internally represented value, it must be serialized
        // to an externally represented value before converting into an AST.
        final Object serialized = serialize(type, value);
        if (isNullish(serialized)) {
            return null;
        }

        // Others serialize based on their corresponding JavaScript scalar types.
        if (serialized instanceof Boolean) {
            return BooleanValue.newBooleanValue().value((Boolean) serialized).build();
        }

        String stringValue = serialized.toString();
        // numbers can be Int or Float values.
        if (serialized instanceof Number) {
            return handleNumber(stringValue);
        }

        if (serialized instanceof String) {
            // Enum types use Enum literals.
            if (type instanceof GraphQLEnumType) {
                return EnumValue.newEnumValue().name(stringValue).build();
            }

            // ID types can use Int literals.
            if (type == Scalars.GraphQLID && stringValue.matches(""^[0-9]+$"")) {
                return IntValue.newIntValue().value(new BigInteger(stringValue)).build();
            }

            // String types are just strings but JSON'ised
            return StringValue.newStringValue().value(jsonStringify(stringValue)).build();
        }

        throw new AssertException(""'Cannot convert value to AST: "" + serialized);
    }
"	@return a graphql language ast  Value	@return a grapql language ast Value	1	0	11	61	422
public static boolean isWebpNativelySupported(ImageFormat webpFormat) { switch (webpFormat) { case WEBP_SIMPLE: // Simple WebPs are supported on Android 4.0+ return Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH; case WEBP_LOSSLESS: case WEBP_EXTENDED: case WEBP_EXTENDED_WITH_ALPHA: return WebpSupportStatus.sIsExtendedWebpSupported; case WEBP_ANIMATED: return false; default: Preconditions.checkArgument(false); return false; } }	"  public static boolean isWebpNativelySupported(ImageFormat webpFormat) {
    switch (webpFormat) {
      case WEBP_SIMPLE: // Simple WebPs are supported on Android 4.0+
        return Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH;
      case WEBP_LOSSLESS:
      case WEBP_EXTENDED:
      case WEBP_EXTENDED_WITH_ALPHA:
        return mIsExtendedWebpSupported;
      case WEBP_ANIMATED:
        return false;
      default:
        Preconditions.checkArgument(false);
        return false;
    }
  }
"	@return true if given type of WebP is supported natively by the framework	@return true if given type of WebP is supported natively by the framework	0	1	7	16	68
public ObjectMapper build(JsonFactory factory) { return configure(new ObjectMapper(factory)); }	"    public ObjectMapper build(JsonFactory factory) {
        final ObjectMapper mapper = new ObjectMapper(factory);

        for (Module module : modules) {
            mapper.registerModule(module);
        }

        for (Map.Entry<MapperFeature, Boolean> entry : mapperFeatures.entrySet()) {
            mapper.configure(entry.getKey(), entry.getValue());
        }

        for (Map.Entry<DeserializationFeature, Boolean> entry : deserializationFeatures.entrySet()) {
            mapper.configure(entry.getKey(), entry.getValue());
        }

        for (Map.Entry<SerializationFeature, Boolean> entry : serializationFeatures.entrySet()) {
            mapper.configure(entry.getKey(), entry.getValue());
        }

        for (Map.Entry<JsonGenerator.Feature, Boolean> entry : generatorFeatures.entrySet()) {
            mapper.getFactory().configure(entry.getKey(), entry.getValue());
        }

        for (Map.Entry<JsonParser.Feature, Boolean> entry : parserFeatures.entrySet()) {
            mapper.getFactory().configure(entry.getKey(), entry.getValue());
        }

        for (Map.Entry<JsonFactory.Feature, Boolean> entry : factoryFeatures.entrySet()) {
            mapper.getFactory().configure(entry.getKey(), entry.getValue());
        }

        if (annotationIntrospector != null) {
            mapper.setAnnotationIntrospector(annotationIntrospector);
        }

        if (dateFormat != null) {
            mapper.setDateFormat(dateFormat);
        }

        if (defaultTyping != null) {
            mapper.setDefaultTyping(defaultTyping);
        }

        if (filters != null) {
            mapper.setFilters(filters);
        }

        if (handlerInstantiator != null) {
            mapper.setHandlerInstantiator(handlerInstantiator);
        }

        if (injectableValues != null) {
            mapper.setInjectableValues(injectableValues);
        }

        if (locale != null) {
            mapper.setLocale(locale);
        }

        if (mixinAnnotations != null) {
            mapper.setMixInAnnotations(mixinAnnotations);
        }

        if (nodeFactory != null) {
            mapper.setNodeFactory(nodeFactory);
        }

        if (propertyNamingStrategy != null) {
            mapper.setPropertyNamingStrategy(propertyNamingStrategy);
        }

        if (serializationInclusion != null) {
            mapper.setSerializationInclusion(serializationInclusion);
        }

        if (serializerFactory != null) {
            mapper.setSerializerFactory(serializerFactory);
        }

        if (serializerProvider != null) {
            mapper.setSerializerProvider(serializerProvider);
        }

        if (subtypeResolver != null) {
            mapper.setSubtypeResolver(subtypeResolver);
        }

        if (timeZone != null) {
            mapper.setTimeZone(timeZone);
        }

        if (typeFactory != null) {
            mapper.setTypeFactory(typeFactory);
        }

        for (Map.Entry<PropertyAccessor, JsonAutoDetect.Visibility> rule : visibilityRules.entrySet()) {
            mapper.setVisibility(rule.getKey(), rule.getValue());
        }

        if (visibilityChecker != null) {
            mapper.setVisibilityChecker(visibilityChecker);
        }


        return mapper;
    }
"	@return a configured  ObjectMapper instance	@return a configured ObjectMapper instance	0	1	6	4	19
public static String addPropertiesToURI(URI uri, Map<String, String> properties) throws Exception { return addPropertiesToURI(uri.toString(), properties); }	"public static String addPropertiesToURI(URI uri, Map<String, String> props) throws Exception {
    return addPropertiesToURI(uri.toString(), props);
}"	@return a new String value that is the original URI with the added bean properties.	@return uri with properties on	1	0	6	3	29
private boolean match(Way w1, Way w2) { if (w1.id == NUM || w2.id == NUM) { if (w1.nodes.size() != w2.nodes.size()) return false; Iterator<Node> it = w1.nodes.iterator(); for (Node n : w2.nodes) if (!match(n, it.next())) return false; return true; } return w1.id == w2.id; }	"private boolean match(Segment ls1, Segment ls2) {
    if (ls1.id == ls2.id && ls1.id != NUM)
        return true;
    if (ls1.incomplete || ls2.incomplete)
        return false;
    return match(ls1.from, ls2.from) && match(ls1.to, ls2.to);
}"	"@return Whether the ways match (in sense of ""be mergable"")."	"@return Whether the segments matches (in sense of ""be mergable"")."	1	0	8	11	84
public CustomFuture<RECEIVE> send(SEND messageToSend, ByteBuf... dataBodies) { final CustomMessage customMessage = CustomMessage.newBuilder() .setMessage(ByteString.copyFrom(send.serializeToSend(messageToSend))) .setType(messageTypeId) .build(); final SyncCustomMessageSender b = new SyncCustomMessageSender(customMessage, dataBodies); manager.runCommand(b); DrillRpcFuture<CustomMessage> innerFuture = b.getFuture(); return new CustomFuture<RECEIVE>(receive, innerFuture); }	"    public CustomFuture<RECEIVE> send(SEND messageToSend, ByteBuf... dataBodies) {
      final CustomMessage customMessage = CustomMessage.newBuilder()
          .setMessage(messageToSend.toByteString())
          .setType(messageTypeId)
          .build();
      final SyncCustomMessageSender b = new SyncCustomMessageSender(customMessage, dataBodies);
      manager.runCommand(b);
      DrillRpcFuture<CustomMessage> innerFuture = b.getFuture();
      return new CustomFuture<RECEIVE>(parser, innerFuture);
    }
"	@return The CustomFuture that can be used to wait for the response.	@return The CustomFuture that can be used to wait for the response.	0	1	9	11	75
public DateTimeFormatterBuilder appendClockhourOfHalfday(final int minDigits) { return appendDecimal(iChronoUTC.clockhourOfHalfday(), minDigits, 2); }	"    public DateTimeFormatterBuilder appendClockhourOfHalfday(final int minDigits) {
        return appendNumeric(iChronoUTC.clockhourOfHalfday(), minDigits, 2);
    }
"	@return this DateTimeFormatterBuilder	@return this DateTimeFormatterBuilder	0	1	5	4	23
public String getHandle() { if (consoleProcess_ == null) { return terminalHandle_; } return consoleProcess_.getProcessInfo().getHandle(); }	"public String getHandle() {
    if (consoleProcess_ == null) {
        return terminalHandle_;
    }
    return consoleProcess_.getProcessInfo().getTerminalHandle();
}"	@return Opaque string handle for this terminal instance, or null if terminal has never been attached to a server ConsoleProcess.	@return Opaque string handle for this terminal instance, or null if terminal has never been attached to a process	1	0	6	6	26
public AggregateCall copy(List<Integer> args, int filterArg) { // ignoring collation is error-prone return copy(args, filterArg, collation); }	"  public AggregateCall copy(List<Integer> args, int filterArg) {
    return new AggregateCall(aggFunction, distinct, approximate, args,
        filterArg, type, name);
  }
"	@return AggregateCall that suits new inputs and GROUP BY columns	@return AggregateCall that suits new inputs and GROUP BY columns	0	1	6	5	31
private Object toTypeAnnotation(JmsDestination destination, boolean useByteValue) { if (destination == null) { return null; } if (useByteValue) { if (destination.isQueue()) { if (destination.isTemporary()) { return TEMP_QUEUE_TYPE; } else { return QUEUE_TYPE; } } else if (destination.isTopic()) { if (destination.isTemporary()) { return TEMP_TOPIC_TYPE; } else { return TOPIC_TYPE; } } } else { if (destination.isQueue()) { if (destination.isTemporary()) { return TEMP_QUEUE_ATTRIBUTES_STRING; } else { return QUEUE_ATTRIBUTES_STRING; } } else if (destination.isTopic()) { if (destination.isTemporary()) { return TEMP_TOPIC_ATTRIBUTES_STRING; } else { return TOPIC_ATTRIBUTES_STRING; } } } return null; }	"private String toTypeAnnotation(JmsDestination destination) {
    if (destination == null) {
        return null;
    }
    if (destination.isQueue()) {
        if (destination.isTemporary()) {
            return TEMP_QUEUE_ATTRIBUTES_STRING;
        } else {
            return QUEUE_ATTRIBUTES_STRING;
        }
    } else if (destination.isTopic()) {
        if (destination.isTemporary()) {
            return TEMP_TOPIC_ATTRIBUTES_STRING;
        } else {
            return TOPIC_ATTRIBUTES_STRING;
        }
    }
    return null;
}"	@return the annotation type value, or null if the supplied destination is null or can't be classified	@return the annotation type string, or null if the supplied destination is null or can't be classified	1	0	11	35	144
public boolean remove(Tag tag) { return mSelectedTopics.remove(tag); }	"public boolean remove(String tagId, String category) {
    return isCategoryValid(category) && mSelectedTopics.remove(tagId);
}"	@return True if the set of filters was modified by this call.	@return boolean Returns a boolean to indicate whether the operation was successful.	1	0	5	3	16
public int getMaximumValue(PartialInstant instant, int[] values) { return getWrappedField().getMaximumValue(instant, values) + 1; }	"    public int getMaximumValue(PartialInstant instant) {
        return getWrappedField().getMaximumValue(instant) + 1;
    }
"	@return the maximum value	@return the maximum value	0	1	7	4	27
public long get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }	"public long get(WithAttributes attributes) {
    return attributes.getAttributes().get(this);
}"	@return the value of this attribute if this attribute is present in the extracted map. Otherwise {@link #getDefaultValue()}	@return the value of this attribute if this attribute is present in the map. Otherwise {@link #getDefaultValue()}	1	0	6	3	19
public ReadWritableInstantFieldProperty dayOfMonth() { return new ReadWritableInstantFieldProperty(this, getChronology().dayOfMonth()); }	"    public MutableDateTimeFieldProperty dayOfMonth() {
        return new MutableDateTimeFieldProperty(this, getChronology().dayOfMonth());
    }
"	@return the day of month property	@return the day of month property	0	1	6	4	21
protected Window getPortletWindow(PortletRequest request, Application application) { PortletMode mode = request.getPortletMode(); Window window = application.getWindow(mode.toString()); if (window != null) { return window; } return application.getMainWindow(); }	"protected Window getPortletWindow(PortletRequest request, Application application) {
    PortletMode mode = request.getPortletMode();
    if (PortletMode.VIEW.equals(mode)) {
        return application.getMainWindow();
    } else {
        Window window = application.getWindow(mode.toString());
        if (window != null) {
            return window;
        }
    }
    return application.getMainWindow();
}"	@return Window to show in the portlet for the given portlet mode	@return Window to show in the portlet	1	0	6	8	47
private List<Long> getRcsRawContactIdFromPhoneNumber(String phoneNumber) { List<Long> contactsIds = new ArrayList<Long>(); String[] projection = { Data.RAW_CONTACT_ID }; String selection = Data.MIMETYPE + STR + Phone.NUMBER + STR; String[] selectionArgs = { MIMETYPE_NUMBER, phoneNumber }; String sortOrder = Data.RAW_CONTACT_ID; Cursor cur = ctx.getContentResolver().query(Data.CONTENT_URI, projection, selection, selectionArgs, sortOrder); if (cur != null) { while (cur.moveToNext()) { long rcsRawContactId = cur.getLong(cur.getColumnIndex(Data.RAW_CONTACT_ID)); contactsIds.add(rcsRawContactId); } cur.close(); } return contactsIds; }	"private long getRcsRawContactIdFromPhoneNumber(String phoneNumber) {
    String[] projection = { Data.RAW_CONTACT_ID };
    String selection = Data.MIMETYPE + STR + Phone.NUMBER + STR;
    String[] selectionArgs = { MIMETYPE_NUMBER, phoneNumber };
    String sortOrder = Data.RAW_CONTACT_ID;
    Cursor cur = ctx.getContentResolver().query(Data.CONTENT_URI, projection, selection, selectionArgs, sortOrder);
    if (cur != null) {
        while (cur.moveToNext()) {
            long rcsRawContactId = cur.getLong(cur.getColumnIndex(Data.RAW_CONTACT_ID));
            cur.close();
            return rcsRawContactId;
        }
        cur.close();
    }
    return INVALID_ID;
}"	@return list of contactIds, empty list if none was found	@return contactId, if not found INVALID_ID is returned	1	0	11	16	119
public static Predicate<Connectivity> hasState(final NetworkInfo.State... states) { return new Predicate<Connectivity>() { @Override public boolean test(@NonNull Connectivity connectivity) throws Exception { for (NetworkInfo.State state : states) { if (connectivity.state() == state) { return true; } } return false; } }; }	"  public static Predicate<Connectivity> hasState(final NetworkInfo.State... states) {
    return new Predicate<Connectivity>() {
      @Override public boolean test(@NonNull Connectivity connectivity) throws Exception {
        for (NetworkInfo.State state : states) {
          if (connectivity.getState() == state) {
            return true;
          }
        }
        return false;
      }
    };
  }
"	@return true if at least one given state occurred	@return true if at least one given state occurred	0	1	11	13	63
public static Function<String, String> osVersion() { return new Function<String, String>() { @Override public String apply(final String description) { OsFamily family = osFamily().apply(description); if (Objects.equal(family, OsFamily.CENTOS)) return parseVersion(description, CENTOS); else if (Objects.equal(family, OsFamily.DEBIAN)) return parseVersion(description, DEBIAN); else if (Objects.equal(family, OsFamily.FEDORA)) return parseVersion(description, FEDORA); else if (Objects.equal(family, OsFamily.RHEL)) return parseVersion(description, RHEL); else if (Objects.equal(family, OsFamily.UBUNTU)) return parseVersion(description, UBUNTU); else if (Objects.equal(family, OsFamily.WINDOWS)) return parseVersion(description, WINDOWS); else if (Objects.equal(family, OsFamily.CLOUD_LINUX)) return parseVersion(description, CLOUD_LINUX); return null; } }; }	"public static Function<ProductItem, String> osVersion() {
    return new Function<ProductItem, String>() {

        @Override
        public String apply(ProductItem productItem) {
            checkNotNull(productItem, STR);
            final String description = productItem.getDescription();
            OsFamily family = osFamily().apply(productItem);
            if (family.equals(OsFamily.CENTOS))
                return parseVersion(description, CENTOS);
            else if (family.equals(OsFamily.DEBIAN))
                return parseVersion(description, DEBIAN);
            else if (family.equals(OsFamily.FEDORA))
                return parseVersion(description, FEDORA);
            else if (family.equals(OsFamily.RHEL))
                return parseVersion(description, RHEL);
            else if (family.equals(OsFamily.UBUNTU))
                return parseVersion(description, UBUNTU);
            else if (family.equals(OsFamily.WINDOWS))
                return parseVersion(description, WINDOWS);
            else if (family.equals(OsFamily.CLOUD_LINUX))
                return parseVersion(description, CLOUD_LINUX);
            else
                throw new NoSuchElementException(STR + productItem);
        }
    };
}"	@return the version or null if the version cannot be determined	@return the version	1	0	15	24	186
public Single<Bitmap> cropAsSingle(final Uri sourceUri) { return Single.fromCallable(new Callable<Bitmap>() { @Override public Bitmap call() throws Exception { if (sourceUri != null) mSourceUri = sourceUri; return cropImage(); } }).doOnSubscribe(new Consumer<Disposable>() { @Override public void accept(@NonNull Disposable disposable) throws Exception { mIsCropping.set(true); } }).doFinally(new Action() { @Override public void run() throws Exception { mIsCropping.set(false); } }); }	"  public Single<Bitmap> cropAsSingle() {
    return Single.fromCallable(new Callable<Bitmap>() {

      @Override public Bitmap call() throws Exception {
        return cropImage();
      }
    }).doOnSubscribe(new Consumer<Disposable>() {
      @Override public void accept(@NonNull Disposable disposable) throws Exception {
        mIsCropping.set(true);
      }
    }).doFinally(new Action() {
      @Override public void run() throws Exception {
        mIsCropping.set(false);
      }
    });
  }
"	@return Single of cropping image	@return Single of cropping image	0	1	10	18	106
"private boolean waitUntilResume(Runnable run, boolean deletePreviousRunnables) { if (mPaused) { Log.i(TAG, ""Deferring update until onResume""); if (deletePreviousRunnables) { while (mBindOnResumeCallbacks.remove(run)) { } } mBindOnResumeCallbacks.add(run); return true; } else { return false; } }"	"    private boolean waitUntilResume(Runnable run) {
        return waitUntilResume(run, false);
    }
"	@return true if we are currently paused. The caller might be able to skip some work in that case since we will come back again.	@return true if we are currently paused. The caller might be able to skip some work	1	0	9	14	62
public int track(IProgressMonitor monitor) throws CoreException, OperationCanceledException { long currentTime = System.currentTimeMillis(); long totalTime = currentTime + timeout; CloudFoundryServerBehaviour behaviour = cloudServer.getBehaviour(); String appName = appModule.getDeployedApplicationName(); printlnToConsole(NLS.bind(Messages.ApplicationInstanceStartingTracker_STARTING_TRACKING, appName), appModule); int state = IServer.STATE_UNKNOWN; while (state != IServer.STATE_STARTED && state != IServer.STATE_STOPPED && currentTime < totalTime) { if (monitor != null && monitor.isCanceled()) { String error = NLS.bind(Messages.ApplicationInstanceStartingTracker_APPLICATION_CHECK_CANCELED, appName); printlnToConsole(error, appModule); throw new OperationCanceledException(error); } CloudApplication cloudApp = behaviour.getCloudApplication(appName, monitor); ApplicationStats applicationStats = behaviour.getApplicationStats(appName, monitor); if (cloudApp == null) { String error = NLS.bind(Messages.ApplicationInstanceStartingTracker_APPLICATION_NOT_EXISTS, appName); printlnToConsole(error, appModule); throw CloudErrorUtil.toCoreException(error); } else { state = CloudFoundryApplicationModule.getCloudState(cloudApp, applicationStats); try { Thread.sleep(WAIT_TIME); } catch (InterruptedException e) { } currentTime = System.currentTimeMillis(); } } String runningStateMessage = state == IServer.STATE_STARTED ? NLS.bind(Messages.ApplicationInstanceStartingTracker_APPLICATION_IS_RUNNING, appName) : NLS.bind(Messages.ApplicationInstanceStartingTracker_APPLICATION_IS_NOT_RUNNING, appName); printlnToConsole(runningStateMessage, appModule); return state; }	"public int track(IProgressMonitor monitor) throws CoreException {
    long currentTime = System.currentTimeMillis();
    long totalTime = currentTime + timeout;
    CloudFoundryApplicationModule appModule = cloudServer.getBehaviour().updateModuleWithAllCloudInfo(appName, monitor);
    printlnToConsole(NLS.bind(Messages.ApplicationInstanceStartingTracker_STARTING_TRACKING, appName), appModule);
    int state = appModule.getState();
    while (state != IServer.STATE_STARTED && state != IServer.STATE_STOPPED && currentTime < totalTime) {
        appModule = cloudServer.getBehaviour().updateModuleWithAllCloudInfo(appName, monitor);
        if (appModule == null || appModule.getApplication() == null) {
            printlnToConsole(NLS.bind(Messages.ApplicationInstanceStartingTracker_APPLICATION_NOT_EXISTS, appName), appModule);
            return IServer.STATE_UNKNOWN;
        }
        if (monitor != null && monitor.isCanceled()) {
            printlnToConsole(NLS.bind(Messages.ApplicationInstanceStartingTracker_APPLICATION_CHECK_CANCELED, appName), appModule);
            return IServer.STATE_UNKNOWN;
        }
        state = appModule.getState();
        try {
            Thread.sleep(WAIT_TIME);
        } catch (InterruptedException e) {
        }
        currentTime = System.currentTimeMillis();
    }
    String runningStateMessage = state == IServer.STATE_STARTED ? NLS.bind(Messages.ApplicationInstanceStartingTracker_APPLICATION_IS_RUNNING, appName) : NLS.bind(Messages.ApplicationInstanceStartingTracker_APPLICATION_IS_NOT_RUNNING, appName);
    printlnToConsole(runningStateMessage, appModule);
    return state;
}"	@return One of the following application running states: {@link IServer#STATE_STARTED}, {@link IServer#STATE_STOPPED}, {@link IServer#STATE_UNKNOWN}	@return One of the following application running states: {@link IServer#STATE_STARTED}, {@link IServer#STATE_STARTING}, {@link IServer#STATE_STOPPED}, {@link IServer#STATE_STOPPING}, {@link IServer#STATE_UNKNOWN}	1	0	10	32	237
protected Object convertNumeric(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return new BigDecimal(0); } BigDecimal decimal = null; if (data instanceof BigDecimal) decimal = (BigDecimal) data; else if (data instanceof Boolean) decimal = new BigDecimal(((Boolean) data).booleanValue() ? 1 : 0); else if (data instanceof Short) decimal = new BigDecimal(((Short) data).intValue()); else if (data instanceof Integer) decimal = new BigDecimal(((Integer) data).intValue()); else if (data instanceof Long) decimal = BigDecimal.valueOf(((Long) data).longValue()); else if (data instanceof Float) decimal = BigDecimal.valueOf(((Float) data).doubleValue()); else if (data instanceof Double) decimal = BigDecimal.valueOf(((Double) data).doubleValue()); else { return handleUnknownData(column, fieldDefn, data); } return decimal; }	"    protected Object convertNumeric(Column column, Field fieldDefn, Object data) {
        if (data == null) return null;
        BigDecimal decimal = null;
        if (data instanceof BigDecimal)
            decimal = (BigDecimal) data;
        else if (data instanceof Boolean)
            decimal = new BigDecimal(((Boolean) data).booleanValue() ? 1 : 0);
        else if (data instanceof Short)
            decimal = new BigDecimal(((Short) data).intValue());
        else if (data instanceof Integer)
            decimal = new BigDecimal(((Integer) data).intValue());
        else if (data instanceof Long)
            decimal = BigDecimal.valueOf(((Long) data).longValue());
        else if (data instanceof Float)
            decimal = BigDecimal.valueOf(((Float) data).doubleValue());
        else if (data instanceof Double)
            decimal = BigDecimal.valueOf(((Double) data).doubleValue());
        else {
            return handleUnknownData(column, fieldDefn, data);
        }
        return decimal;
    }
"	@return the converted value, or null if the conversion could not be made and the column allows nulls	@return the converted value, or null if the conversion could not be made	1	0	14	29	223
public RepositoryMethodMetadata lookupMethod(RepositoryMetadata repositoryMetadata, Method method) { return repositoryMetadata.getMethodsMetadata().get(method); }	"public RepositoryMethodMetadata lookupMethod(Class<?> repoClass, Method method) {
    return lookupComponent(repoClass).getMethodsMetadata().get(method);
}"	@return A {@link RepositoryMethodMetadata}.	@return A {@link RepositoryMethodMetadataInitializer} corresponding to the method parameter.	1	0	6	3	22
"public String toString() { return String.format(""%s:%s:%s%s%s%s"", path, volume.getPath(), accessMode.toString(), secMode != SELContext.none ? "","" + secMode.toString() : """", noCopy != null ? "",nocopy"" : """", propagationMode != PropagationMode.DEFAULT_MODE ? "","" + propagationMode.toString() : """"); }"	"    public String toString() {
        return String.format(""%s:%s:%s%s"",
                path,
                volume.getPath(),
                accessMode.toString(),
                secMode != SELContext.none ? "","" + secMode.toString() : """");
    }
"	@return a string representation of this  Bind	@return a string representation of this Bind	0	1	7	10	87
public synchronized int getState() { if (this.application != null && this.application.getState() == AppState.STOPPED) { return IServer.STATE_STOPPED; } InstanceState instanceState = getRunState(); if (instanceState != null) { switch(instanceState) { case RUNNING: return IServer.STATE_STARTED; case STARTING: return IServer.STATE_STARTING; case DOWN: return IServer.STATE_STOPPED; } } return IServer.STATE_UNKNOWN; }	"public synchronized int getState() {
    if (application != null) {
        AppState state = application.getState();
        switch(state) {
            case STARTED:
                return IServer.STATE_STARTED;
            case UPDATING:
                return IServer.STATE_STARTING;
            case STOPPED:
                return IServer.STATE_STOPPED;
        }
    }
    return IServer.STATE_UNKNOWN;
}"	@return {@link IServer} state of the application based on the application running state in the Cloud	@return {@link IServer} state	1	0	8	17	75
public Receiver getReceiver() { return UnmodifiableProxy.receiverProxy(getEndpoint()); }	"    public Receiver getReceiver() {
        return new UnmodifiableReceiver(getEndpoint());
    }
"	@return an unmodifiable view of the underlying Receiver instance.	@return an unmodifiable view of the underlying Receiver instance.	0	1	5	4	16
public static UserAdapter createUserSpinnerAdapter(UserManager userManager, Context context) { List<UserHandle> userProfiles = userManager.getUserProfiles(); if (userProfiles.size() < NUM) { return null; } UserHandle myUserHandle = new UserHandle(UserHandle.myUserId()); userProfiles.remove(myUserHandle); userProfiles.add(NUM, myUserHandle); return createUserAdapter(userManager, context, userProfiles); }	"public static UserSpinnerAdapter createUserSpinnerAdapter(UserManager userManager, Context context) {
    List<UserHandle> userProfiles = userManager.getUserProfiles();
    if (userProfiles.size() < NUM) {
        return null;
    }
    UserHandle myUserHandle = new UserHandle(UserHandle.myUserId());
    userProfiles.remove(myUserHandle);
    userProfiles.add(NUM, myUserHandle);
    ArrayList<UserDetails> userDetails = new ArrayList<UserDetails>(userProfiles.size());
    final int count = userProfiles.size();
    for (int i = NUM; i < count; i++) {
        userDetails.add(new UserDetails(userProfiles.get(i), userManager, context));
    }
    return new UserSpinnerAdapter(context, userDetails);
}"	@return a {@link UserAdapter} or null if there is only one profile.	@return a {@link UserSpinnerAdapter} or null if there is only one profile.	1	0	6	10	69
public DateTimeFormatterBuilder appendClockhourOfHalfday(int minDigits) { return appendDecimal(DateTimeFieldType.clockhourOfHalfday(), minDigits, 2); }	"    public DateTimeFormatterBuilder appendClockhourOfHalfday(final int minDigits) {
        return appendDecimal(iChronoUTC.clockhourOfHalfday(), minDigits, 2);
    }
"	@return this DateTimeFormatterBuilder	@return this DateTimeFormatterBuilder	0	1	5	4	22
private boolean processResults(boolean returnKeys, boolean update) throws SQLException { if (!resultQueue.isEmpty()) { throw new IllegalStateException(STR); } while (!tds.isEndOfResponse()) { if (!tds.getMoreResults()) { if (tds.isUpdateCount()) { if (update && connection.isLastUpdateCount()) { resultQueue.clear(); } resultQueue.addLast(new Integer(tds.getUpdateCount())); } } else { if (returnKeys) { if (tds.getNextRow()) { genKeyResultSet = new CachedResultSet(this, tds.getColumns(), tds.getRowData()); } } else { if (update && resultQueue.isEmpty()) { throw new SQLException(Messages.get(STR), STR); } resultQueue.add(new JtdsResultSet(this, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY, tds.getColumns())); break; } } } return !resultQueue.isEmpty(); }	"private boolean processResults(boolean returnKeys, boolean update) throws SQLException {
    while (!tds.isEndOfResponse()) {
        if (!tds.getMoreResults()) {
            if (tds.isUpdateCount()) {
                if (update && connection.isLastUpdateCount()) {
                    resultQueue.clear();
                }
                resultQueue.addLast(new Integer(tds.getUpdateCount()));
            }
        } else {
            if (returnKeys) {
                if (tds.getNextRow()) {
                    genKeyResultSet = new CachedResultSet(this, tds.getColumns(), tds.getRowData());
                }
            } else {
                if (update && resultQueue.isEmpty()) {
                    throw new SQLException(Messages.get(STR), STR);
                }
                JtdsResultSet rs = new JtdsResultSet(this, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY, tds.getColumns(), false);
                if (resultQueue.isEmpty()) {
                    currentResult = rs;
                    return true;
                } else {
                    resultQueue.add(rs);
                    return false;
                }
            }
        }
    }
    return false;
}"	@return <code>true</code> if there are any results, <code>false</code> otherwise	@return <false> if the first result is an update count, <true> if it's a <code>ResultSet</code>	1	0	14	28	183
public List<FxType> getDerivedTypes() { return Collections.unmodifiableList(derivedTypes); }	"public List<FxType> getDerivedTypes() {
    return derivedTypes;
}"	@return Iterator of all directly derived types	@return Iterator of all derived types	1	0	5	3	15
protected Object convertBit(Column column, Field fieldDefn, Object data) { return convertValue(column, fieldDefn, data, false, (r) -> { if (data instanceof Boolean) { r.deliver(data); } else if (data instanceof Short) { r.deliver(((Short) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE); } else if (data instanceof Integer) { r.deliver(((Integer) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE); } else if (data instanceof Long) { r.deliver(((Long) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE); } else if (data instanceof BitSet) { BitSet value = (BitSet) data; r.deliver(value.get(0)); } }); }	"    protected Object convertBit(Column column, Field fieldDefn, Object data) {
        if (data == null && !fieldDefn.schema().isOptional()) {
            data = fieldDefn.schema().defaultValue();
        }
        if (data == null) {
            if (column.isOptional()) return null;
            return false;
        }
        if (data instanceof Boolean) return data;
        if (data instanceof Short) return ((Short) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;
        if (data instanceof Integer) return ((Integer) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;
        if (data instanceof Long) return ((Long) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;
        if (data instanceof BitSet) {
            BitSet value = (BitSet) data;
            return value.get(0);
        }
        return handleUnknownData(column, fieldDefn, data);
    }
"	@return the converted value, or null if the conversion could not be made and the column allows nulls	@return the converted value, or null if the conversion could not be made and the column allows nulls	0	1	16	21	164
public String getInitParameter(String name) { try { return framework.getServletConfig().getInitParameter(name); } catch (Throwable ex) { // Don't fail if Tomcat crash on startup with an NPE return null; } }	"    public String getInitParameter(String name) {
        try {
        	String value=framework.getServletConfig().getInitParameter(name);
        	if(value==null && useServletContextParameters) {
        		value=framework.getServletContext().getInitParameter(name);
        	}
        	return value;
        } catch (Throwable ex) {
            // Don't fail if Tomcat crash on startup with an NPE
            return null;
        }
    }
"	@return the list of init params defined in web.xml or application.xml	@return the value for the init parameter if defined	1	0	7	9	46
public int getEstimatedRotation() { if (!isRotating()) { return getRotation(); } double timeSpent = (System.currentTimeMillis() - estimatedRotationStartTime) / NUM; int rotation = estimatedRotationStart + (int) (currentVelocity * timeSpent); if ((estimatedRotationStart < estimatedRotationEnd) != (estimatedRotationStart < rotation)) { rotation = estimatedRotationEnd; } double angle = (double) (rotation) / Settings.getHandlerRotation() * NUM; return (int) (Math.round(angle)) % NUM; }	"public int getEstimatedRotation() {
    if (!isRotating()) {
        return getRotation();
    } else {
        double timeSpent = (System.currentTimeMillis() - startingTime) / NUM;
        int pos = currentStartingPoint + (int) (currentVelocity * timeSpent);
        double angle = (double) (pos) / Settings.getHandlerRotation() * NUM;
        return (int) (Math.round(angle)) % NUM;
    }
}"	@return estimated rotation of where we are at in angles.	@return current Estimated rotation we are at	1	0	8	12	94
public BooleanExpression endsWith(String str) { return endsWith(ConstantImpl.create(str)); }	"    public BooleanExpression endsWith(String str) {
        return endsWith(StringConstant.create(str));
    }
"	@return this.endsWith(str)	@return this.endsWith(str)	0	1	6	4	19
public VisualItem findItem(Point p) { Point2D p2 = (m_itransform == null ? p : m_itransform.transform(p, m_tmpPoint)); synchronized (m_registry) { Iterator items = m_registry.getItemsReversed(); while (items.hasNext()) { VisualItem vi = (VisualItem) items.next(); Renderer r = vi.getRenderer(); if (r != null && r.locatePoint(p2, vi)) { return vi; } } } return null; }	"public GraphItem findItem(Point p) {
    Point2D p2 = (m_itransform == null ? p : m_itransform.transform(p, m_tmpPoint));
    synchronized (m_registry) {
        Iterator items = m_registry.getItemsReversed();
        while (items.hasNext()) {
            GraphItem gi = (GraphItem) items.next();
            Renderer r = gi.getRenderer();
            if (r != null && r.locatePoint(p2, gi)) {
                return gi;
            }
        }
    }
    return null;
}"	@return the VisualItem located at the given point, if any	@return the GraphItem located at the given point, if any	1	0	9	14	88
"static boolean isAllNulls(ColumnStatistics stat, long rowCount) { Preconditions.checkArgument(rowCount >= 0, String.format(""negative rowCount %d is not valid"", rowCount)); return ColumnStatisticsKind.NULLS_COUNT.getFrom(stat) == rowCount; }"	"  static boolean isAllNulls(ColumnStatistics stat, long rowCount) {
    Preconditions.checkArgument(rowCount >= 0, String.format(""negative rowCount %d is not valid"", rowCount));
    return (long) stat.getStatistic(ColumnStatisticsKind.NULLS_COUNT) == rowCount;
  }
"	@return true if all rows are null, false otherwise	@return true if all rows are null, false otherwise	0	1	6	5	44
public Lob build() { return new Lob(this); }	"public Ravioli build() {
    return new Ravioli(this);
}"	@return A {@link Lob}	@return A {@link Ravioli}	1	0	5	3	14
private List<AbstractProject> getProjects() { List<AbstractProject> result = new ArrayList<AbstractProject>(); List<TopLevelItem> topLevelItems = Hudson.getInstance().getItems(); for (TopLevelItem topLevelItem : topLevelItems) { if (topLevelItem instanceof AbstractProject) { AbstractProject abstractProject = (AbstractProject) topLevelItem; if (abstractProject.getPublishersList().get(MonitorPublisher.DESCRIPTOR) != null) { result.add(abstractProject); } } } return result; }	"private List<Project> getProjects() {
    List<Project> result = new ArrayList<Project>();
    List<Project> projects = Hudson.getInstance().getProjects();
    for (Project project : projects) {
        Publisher publisher = project.getPublisher(MonitorPublisher.DESCRIPTOR);
        if (publisher != null) {
            result.add(project);
        }
    }
    return result;
}"	@return list projects that will be displayed	@return list containing Projects.	1	0	11	13	77
public static Color fromObject(@Nonnull final Object object) { int i = object.hashCode(); float h = (i % 360) / 360f; return Color.getHSBColor(h, 1, 1); }	"	public static Color fromObject(@Nonnull final Object object, boolean skipAlpha)
	{
		int i = object.hashCode();
		int r = (i >> 24) & 0xFF;
		int g = (i >> 16) & 0xFF;
		int b = (i >> 8) & 0xFF;
		int a = i & 0xFF;
		return new Color(r, g, b, skipAlpha ? 255 : a);
	}
"	@return color	@return color	0	1	7	7	41
public DateTimeField[] getFields() { DateTimeField[] result = new DateTimeField[getFieldSize()]; for (int i = 0; i < result.length; i++) { result[i] = getField(i); } return result; }	"    public DateTimeField[] getFields() {
        return (DateTimeField[]) iFields.clone();
    }
"	@return the fields supported in an array that may be altered, largest to smallest	@return the fields supported (cloned), largest to smallest	1	0	9	8	49
public static Schema getValueReaderSchema(Configuration conf) { String json = conf.get(CONF_VALUE_READER_SCHEMA); return null == json ? null : new Schema.Parser().parse(json); }	"  public static Schema getValueReaderSchema(Configuration conf) {
    String json = conf.get(CONF_VALUE_READER_SCHEMA);
    return null == json ? null : Schema.parse(json);
  }
"	@return The Avro value reader schema, or null if none was set.	@return The Avro value reader schema, or null if none was set.	0	1	7	5	34
public List<Expr> getArgs() { return new CopyOnWriteArrayList<Expr>(args); }	"public List<Expr> getArgs() {
    return args;
}"	@return A copy of the current argument list.	@return The operator's arguments.	1	0	7	3	16
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; // set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { System.err.printf(""Untokenizable: %s%n"", yytext()); return getNext(true); } case 9: break; case 2: { return getNewline(); } case 10: break; case 3: { } case 11: break; case 4: { return getNext(false); } case 12: break; case 5: { return getNext(true); } case 13: break; case 6: { return getEllipsis(); } case 14: break; case 7: { if (! removeProMarker) return getNext(false); } case 15: break; case 8: { if (removeProMarker) { if ( ! removeSegMarker) { return getNext(""-"", yytext()); } } else { return getNext(false); } } case 16: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }"	"  public Object next() throws java.io.IOException {
    int zzInput;
    int zzAction;

    // cached fields:
    int zzCurrentPosL;
    int zzMarkedPosL;
    int zzEndReadL = zzEndRead;
    char [] zzBufferL = zzBuffer;
    char [] zzCMapL = ZZ_CMAP;

    int [] zzTransL = ZZ_TRANS;
    int [] zzRowMapL = ZZ_ROWMAP;
    int [] zzAttrL = ZZ_ATTRIBUTE;

    while (true) {
      zzMarkedPosL = zzMarkedPos;

      zzAction = -1;

      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
  
      zzState = ZZ_LEXSTATE[zzLexicalState];

      // set up zzAction for empty match case:
      int zzAttributes = zzAttrL[zzState];
      if ( (zzAttributes & 1) == 1 ) {
        zzAction = zzState;
      }


      zzForAction: {
        while (true) {
    
          if (zzCurrentPosL < zzEndReadL)
            zzInput = zzBufferL[zzCurrentPosL++];
          else if (zzAtEOF) {
            zzInput = YYEOF;
            break zzForAction;
          }
          else {
            // store back cached positions
            zzCurrentPos  = zzCurrentPosL;
            zzMarkedPos   = zzMarkedPosL;
            boolean eof = zzRefill();
            // get translated positions and possibly new buffer
            zzCurrentPosL  = zzCurrentPos;
            zzMarkedPosL   = zzMarkedPos;
            zzBufferL      = zzBuffer;
            zzEndReadL     = zzEndRead;
            if (eof) {
              zzInput = YYEOF;
              break zzForAction;
            }
            else {
              zzInput = zzBufferL[zzCurrentPosL++];
            }
          }
          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
          if (zzNext == -1) break zzForAction;
          zzState = zzNext;

          zzAttributes = zzAttrL[zzState];
          if ( (zzAttributes & 1) == 1 ) {
            zzAction = zzState;
            zzMarkedPosL = zzCurrentPosL;
            if ( (zzAttributes & 8) == 8 ) break zzForAction;
          }

        }
      }

      // store back cached position
      zzMarkedPos = zzMarkedPosL;

      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
        case 1: 
          { System.err.printf(""Untokenizable: %s%n"", yytext());
	      return getNext(true);
          }
        case 8: break;
        case 2: 
          { return getNewline();
          }
        case 9: break;
        case 3: 
          { 
          }
        case 10: break;
        case 4: 
          { return getNext(false);
          }
        case 11: break;
        case 5: 
          { return getNext(true);
          }
        case 12: break;
        case 6: 
          { return getEllipsis();
          }
        case 13: break;
        case 7: 
          { if (removeProMarker) {
                if ( ! removeSegMarker) {
                  return getNext(""-"", yytext());
                }
              } else {
                return getNext(false);
              }
          }
        case 14: break;
        default: 
          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
            zzAtEOF = true;
              {
                return null;
              }
          } 
          else {
            zzScanError(ZZ_NO_MATCH);
          }
      }
    }
  }
"	@return the next token	@return the next token	0	1	17	129	503
public static String getColumnName(String elementType) { if (elementType.equals(ELEMENTTYPE_Organization)) return STR; else if (elementType.equals(ELEMENTTYPE_Account)) return I_C_ValidCombination.COLUMNNAME_Account_ID; else if (elementType.equals(ELEMENTTYPE_BPartner)) return I_C_ValidCombination.COLUMNNAME_C_BPartner_ID; else if (elementType.equals(ELEMENTTYPE_Product)) return I_C_ValidCombination.COLUMNNAME_M_Product_ID; else if (elementType.equals(ELEMENTTYPE_Activity)) return I_C_ValidCombination.COLUMNNAME_C_Activity_ID; else if (elementType.equals(ELEMENTTYPE_LocationFrom)) return I_C_ValidCombination.COLUMNNAME_C_LocFrom_ID; else if (elementType.equals(ELEMENTTYPE_LocationTo)) return I_C_ValidCombination.COLUMNNAME_C_LocTo_ID; else if (elementType.equals(ELEMENTTYPE_Campaign)) return I_C_ValidCombination.COLUMNNAME_C_Campaign_ID; else if (elementType.equals(ELEMENTTYPE_OrgTrx)) return I_C_ValidCombination.COLUMNNAME_AD_OrgTrx_ID; else if (elementType.equals(ELEMENTTYPE_Project)) return I_C_ValidCombination.COLUMNNAME_C_Project_ID; else if (elementType.equals(ELEMENTTYPE_SalesRegion)) return I_C_ValidCombination.COLUMNNAME_C_SalesRegion_ID; else if (elementType.equals(ELEMENTTYPE_UserList1)) return I_C_ValidCombination.COLUMNNAME_User1_ID; else if (elementType.equals(ELEMENTTYPE_UserList2)) return I_C_ValidCombination.COLUMNNAME_User2_ID; else if (elementType.equals(ELEMENTTYPE_UserElement1)) return I_C_ValidCombination.COLUMNNAME_UserElement1_ID; else if (elementType.equals(ELEMENTTYPE_UserElement2)) return I_C_ValidCombination.COLUMNNAME_UserElement2_ID; return STR; }	"public static String getColumnName(String elementType) {
    if (elementType.equals(ELEMENTTYPE_Organization))
        return STR;
    else if (elementType.equals(ELEMENTTYPE_Account))
        return STR;
    else if (elementType.equals(ELEMENTTYPE_BPartner))
        return STR;
    else if (elementType.equals(ELEMENTTYPE_Product))
        return STR;
    else if (elementType.equals(ELEMENTTYPE_Activity))
        return STR;
    else if (elementType.equals(ELEMENTTYPE_LocationFrom))
        return STR;
    else if (elementType.equals(ELEMENTTYPE_LocationTo))
        return STR;
    else if (elementType.equals(ELEMENTTYPE_Campaign))
        return STR;
    else if (elementType.equals(ELEMENTTYPE_OrgTrx))
        return STR;
    else if (elementType.equals(ELEMENTTYPE_Project))
        return STR;
    else if (elementType.equals(ELEMENTTYPE_SalesRegion))
        return STR;
    else if (elementType.equals(ELEMENTTYPE_UserList1))
        return STR;
    else if (elementType.equals(ELEMENTTYPE_UserList2))
        return STR;
    else if (elementType.equals(ELEMENTTYPE_UserElement1))
        return STR;
    else if (elementType.equals(ELEMENTTYPE_UserElement2))
        return STR;
    return STR;
}"	"@return column name or """" if not found"	@return column name	1	0	19	33	206
"public static By id(final String id) { if (id == null) throw new IllegalArgumentException(""Cannot find elements with a null id attribute.""); return new ById(id); }"	"    public static By id(final String id) {
      if (id == null)
        throw new IllegalArgumentException(""Cannot find elements with a null id attribute."");

      return new By() {
        @Override
        public List<WebElement> findElements(SearchContext context) {
          if (context instanceof FindsById)
              return ((FindsById) context).findElementsById(id);
          return ((FindsByXPath) context).findElementsByXPath(""*[@id = '"" + id + ""']"");
        }

        @Override
        public WebElement findElement(SearchContext context) {
          if (context instanceof FindsById)
            return ((FindsById) context).findElementById(id);
          return ((FindsByXPath) context).findElementByXPath(""*[@id = '"" + id + ""']"");
        }
       
        @Override
        public String toString() {
          return ""By.id: "" + id;
        }
      };
    }
"	"@return a By which locates elements by the value of the ""id"" attribute."	"@return a By which locates elements by the value of the ""id"" attribute."	0	1	6	7	39
public Collection<TableGrant> getTableGrants(TableIdentifier table) { Collection<TableGrant> result = new HashSet<TableGrant>(); ResultSet rs = null; try { TableIdentifier tbl = table.createCopy(); tbl.adjustCase(this.dbConnection); rs = this.metaData.getTablePrivileges(tbl.getCatalog(), tbl.getSchema(), tbl.getTableName()); while (rs.next()) { String from = rs.getString(NUM); String to = rs.getString(NUM); String what = rs.getString(NUM); boolean grantable = StringUtil.stringToBool(rs.getString(NUM)); TableGrant grant = new TableGrant(to, what, grantable); result.add(grant); } } catch (Exception e) { LogMgr.logError(STR, STR, e); } finally { try { rs.close(); } catch (Throwable th) { } } return result; }	"public DataStore getTableGrants(TableIdentifier table) {
    String[] columns = new String[] { STR, STR, STR, STR, STR };
    int[] colTypes = new int[] { Types.VARCHAR, Types.VARCHAR, Types.VARCHAR, Types.VARCHAR, Types.VARCHAR };
    DataStore result = new DataStore(columns, colTypes);
    ResultSet rs = null;
    try {
        TableIdentifier tbl = table.createCopy();
        tbl.adjustCase(this.dbConnection);
        rs = this.metaData.getTablePrivileges(tbl.getCatalog(), tbl.getSchema(), tbl.getTableName());
        while (rs.next()) {
            int row = result.addRow();
            result.setValue(row, COLUMN_IDX_TABLE_GRANTS_OBJECT_NAME, rs.getString(NUM));
            result.setValue(row, COLUMN_IDX_TABLE_GRANTS_GRANTOR, rs.getString(NUM));
            result.setValue(row, COLUMN_IDX_TABLE_GRANTS_GRANTEE, rs.getString(NUM));
            result.setValue(row, COLUMN_IDX_TABLE_GRANTS_PRIV, rs.getString(NUM));
            result.setValue(row, COLUMN_IDX_TABLE_GRANTS_GRANTABLE, rs.getString(NUM));
        }
    } catch (Exception e) {
        LogMgr.logError(STR, STR, e);
        result.reset();
    } finally {
        try {
            rs.close();
        } catch (Throwable th) {
        }
    }
    return result;
}"	@return a List with TableGrant objects.	@return a DataStore which contains the grant information.	1	0	10	25	162
@VisibleForTesting protected URL createPluginUrl() { try { URL urlForPlugin = new URL(STR + location); gdd.diag(gdd.getLit(STR) + STR + urlForPlugin.toString()); return (urlForPlugin); } catch (MalformedURLException e) { gdd.log.severe(gdd.getLit(STR) + STR + location + STR + e); throw new StopExecutionException(null); } }	"@VisibleForTesting
protected URL createPluginUrl() {
    URL urlForPlugin = null;
    try {
        urlForPlugin = new URL(STR + location);
        gdd.diag(gdd.getLit(STR) + STR + urlForPlugin.toString());
    } catch (MalformedURLException e) {
        gdd.log.severe(gdd.getLit(STR) + STR + location + STR + e);
        throw new StopExecutionException(null);
    }
    return (urlForPlugin);
}"	@return a valid URL, if all went well.	@return a valid URL, if all went well; else null;	1	0	12	11	77
public Method getMethod() { return method; }	"public int getMethod() {
    return method;
}"	@return the request method	@return The integer value of the method	1	0	4	3	10
"public ResponseEntity<ModelApiResponse> uploadFileWithRequiredFileWithHttpInfo(Long petId, File requiredFile, String additionalMetadata) throws RestClientException { Object postBody = null; // verify the required parameter 'petId' is set if (petId == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'petId' when calling uploadFileWithRequiredFile""); } // verify the required parameter 'requiredFile' is set if (requiredFile == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile""); } // create path and map variables final Map<String, Object> uriVariables = new HashMap<String, Object>(); uriVariables.put(""petId"", petId); String path = apiClient.expandPath(""/fake/{petId}/uploadImageWithRequiredFile"", uriVariables); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); if (additionalMetadata != null) formParams.add(""additionalMetadata"", additionalMetadata); if (requiredFile != null) formParams.add(""requiredFile"", new FileSystemResource(requiredFile)); final String[] accepts = { ""application/json"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { ""multipart/form-data"" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { ""petstore_auth"" }; ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {}; return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType); }"	"    public ResponseEntity<ModelApiResponse> uploadFileWithRequiredFileWithHttpInfo(Long petId, File requiredFile, String additionalMetadata) throws RestClientException {
        Object postBody = null;
        
        // verify the required parameter 'petId' is set
        if (petId == null) {
            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'petId' when calling uploadFileWithRequiredFile"");
        }
        
        // verify the required parameter 'requiredFile' is set
        if (requiredFile == null) {
            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile"");
        }
        
        // create path and map variables
        final Map<String, Object> uriVariables = new HashMap<String, Object>();
        uriVariables.put(""petId"", petId);
        String path = apiClient.expandPath(""/fake/{petId}/uploadImageWithRequiredFile"", uriVariables);

        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();
        final HttpHeaders headerParams = new HttpHeaders();
        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();

        if (additionalMetadata != null)
            formParams.add(""additionalMetadata"", additionalMetadata);
        if (requiredFile != null)
            formParams.add(""requiredFile"", new FileSystemResource(requiredFile));

        final String[] accepts = { 
            ""application/json""
        };
        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);
        final String[] contentTypes = { 
            ""multipart/form-data""
        };
        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);

        String[] authNames = new String[] { ""petstore_auth"" };

        ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {};
        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);
    }
"	@return ResponseEntity&lt;ModelApiResponse&gt;	@return ResponseEntity&lt;ModelApiResponse&gt;	0	1	8	43	336
public static Properties extractJndiProperties(Map configurationValues) { return JndiServiceImpl.extractJndiProperties( configurationValues ); }	"	public static Properties extractJndiProperties(Map configurationValues) {
		final Properties jndiProperties = new Properties();

		for ( Map.Entry entry : (Set<Map.Entry>) configurationValues.entrySet() ) {
			if ( !String.class.isInstance( entry.getKey() ) ) {
				continue;
			}
			final String propertyName = (String) entry.getKey();
			final Object propertyValue = entry.getValue();
			if ( propertyName.startsWith( Environment.JNDI_PREFIX ) ) {
				// write the IntialContextFactory class and provider url to the result only if they are
				// non-null; this allows the environmental defaults (if any) to remain in effect
				if ( Environment.JNDI_CLASS.equals( propertyName ) ) {
					if ( propertyValue != null ) {
						jndiProperties.put( Context.INITIAL_CONTEXT_FACTORY, propertyValue );
					}
				}
				else if ( Environment.JNDI_URL.equals( propertyName ) ) {
					if ( propertyValue != null ) {
						jndiProperties.put( Context.PROVIDER_URL, propertyValue );
					}
				}
				else {
					final String passThruPropertyname = propertyName.substring( Environment.JNDI_PREFIX.length() + 1 );
					jndiProperties.put( passThruPropertyname, propertyValue );
				}
			}
		}

		return jndiProperties;
	}
"	@return The extracted JNDI specific properties.	@return The extracted JNDI specific properties.	0	1	5	4	17
public static MRequisitionLine[] forC_OrderLine_ID(Properties ctx, int C_OrderLine_ID, String trxName) { final String whereClause = COLUMNNAME_C_OrderLine_ID + STR; List<MRequisitionLine> list = new Query(ctx, MRequisitionLine.Table_Name, whereClause, trxName).setParameters(new Object[] { C_OrderLine_ID }).list(); return list.toArray(new MRequisitionLine[list.size()]); }	"public static MRequisitionLine forC_OrderLine_ID(Properties ctx, int C_OrderLine_ID, String trxName) {
    final String whereClause = COLUMNNAME_C_OrderLine_ID + STR;
    return new Query(ctx, MRequisitionLine.Table_Name, whereClause, trxName).setParameters(new Object[] { C_OrderLine_ID }).firstOnly();
}"	@return array of Requisition Line(s)	@return Requisition Line	1	0	9	5	68
public short getRed() { return data[getFirst1DIndex()]; }	"public short getRed(final int i) {
    return data[get1DIndex(i)];
}"	@return red value in the first position	@return red value in given position	1	0	6	3	15
private boolean isLockFree(InetSocketAddress address) throws IOException { try { lockSocket.bind(address); return true; } catch (BindException e) { return false; } catch (SocketException e) { return false; } }	"  private boolean isLockFree(InetSocketAddress address) throws IOException {
    try {
      lockSocket.bind(address);
      return true;
    } catch (BindException e) {
      return false;
    }
  }
"	@return true if the lock is locked; false if it is not	@return true if the lock is locked; false if it is not	0	1	6	11	43
public APIResult validate(HttpServletRequest request, String type, Boolean skipDryRun) { try { return validate(request.getInputStream(), type, skipDryRun); } catch (IOException e) { LOG.error(STR, request, e); throw FalconWebException.newException(e, Response.Status.BAD_REQUEST); } }	"public APIResult validate(HttpServletRequest request, String type, Boolean skipDryRun) {
    try {
        EntityType entityType = EntityType.getEnum(type);
        Entity entity = deserializeEntity(request, entityType);
        validate(entity);
        if (entity.getEntityType().isSchedulable()) {
            Set<String> clusters = EntityUtil.getClustersDefinedInColos(entity);
            for (String cluster : clusters) {
                try {
                    getWorkflowEngine().dryRun(entity, cluster, skipDryRun);
                } catch (FalconException e) {
                    throw new FalconException(STR + cluster, e);
                }
            }
        }
        return new APIResult(APIResult.Status.SUCCEEDED, STR + entityType + STR + entity.getName());
    } catch (Throwable e) {
        LOG.error(STR, type, e);
        throw FalconWebException.newException(e, Response.Status.BAD_REQUEST);
    }
}"	@return APIResult -Succeeded or Failed	@return APIResule -Succeeded or Failed	1	0	7	8	59
public DateTime withMinimumValue() { try { return setCopy(getMinimumValue()); } catch (RuntimeException ex) { if (IllegalInstantException.isIllegalInstant(ex)) { // subtracting MILLIS_PER_DAY is not perfect, but will work in almost all situations long afterGap = getChronology().getZone().nextTransition(getMillis() - DateTimeConstants.MILLIS_PER_DAY); return new DateTime(afterGap, getChronology()); } throw ex; } }	"        public DateTime withMinimumValue() {
            return setCopy(getMinimumValue());
        }
"	@return a copy of the DateTime with this field set to its minimum	@return a copy of the DateTime with this field set to its minimum	0	1	12	13	82
public boolean isProfileReadOnly() { return profileReadOnly && !isManagementView() && getProfileName() != null; }	"public boolean isProfileReadOnly() {
    return profileReadOnly && !isManagementView();
}"	@return false if the object is currently assigned to an mbean or if it is not read only or if it is default profile	@return false if the object is currently assigned to an mbean or if it is not read only	1	0	6	3	23
public Float getTopValue() { return topValue; }	"public float getTopValue() {
    return topValue == null ? NUM : topValue.floatValue();
}"	@return The value of the 'top' attribute, null if not set	@return The value of the 'top' CSS-attribute	1	0	4	3	10
public final List<ModuleReference> getDependentModulesRecursively(final ModuleReference ref) throws Exception { return getDependentModulesRecursively(ref, new ArrayList<ModuleReference>()); }	"public synchronized final List<String> getDependentModulesRecursively(final String id) throws Exception {
    final List<String> res = new ArrayList<String>();
    for (final String depModule : getDependentModules(id)) {
        res.add(depModule);
        res.addAll(this.getDependentModulesRecursively(depModule));
    }
    Collections.reverse(res);
    return res;
}"	@return the modules needing <code>ref</code> (excluding it), in uninstallation order (i.e. the first item isn't depended on).	@return the modules needing <code>id</code> (excluding it), in uninstallation order (i.e. the first item isn't depended on).	1	0	8	3	26
"public Pet getPetById (Long petId) throws ApiException { Object postBody = null; // verify the required parameter 'petId' is set if (petId == null) { throw new ApiException(400, ""Missing the required parameter 'petId' when calling getPetById""); } // create path and map variables String path = ""/pet/{petId}"".replaceAll(""\\{format\\}"",""json"") .replaceAll(""\\{"" + ""petId"" + ""\\}"", apiClient.escapeString(petId.toString())); // query params List<Pair> queryParams = new ArrayList<Pair>(); Map<String, String> headerParams = new HashMap<String, String>(); Map<String, Object> formParams = new HashMap<String, Object>(); final String[] accepts = { ""application/json"", ""application/xml"" }; final String accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final String contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { ""petstore_auth"", ""api_key"" }; TypeRef returnType = new TypeRef<Pet>() {}; return apiClient.invokeAPI(path, ""GET"", queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }"	"  public Pet getPetById (Long petId) throws ApiException {
    Object postBody = null;
    
    // verify the required parameter 'petId' is set
    if (petId == null) {
       throw new ApiException(400, ""Missing the required parameter 'petId' when calling getPetById"");
    }
    

    // create path and map variables
    String path = ""/pet/{petId}"".replaceAll(""\\{format\\}"",""json"")
      .replaceAll(""\\{"" + ""petId"" + ""\\}"", apiClient.escapeString(petId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    Map<String, String> headerParams = new HashMap<String, String>();
    Map<String, String> formParams = new HashMap<String, String>();

    

    

    final String[] accepts = {
      ""application/json"", ""application/xml""
    };
    final String accept = apiClient.selectHeaderAccept(accepts);

    final String[] contentTypes = {
      
    };
    final String contentType = apiClient.selectHeaderContentType(contentTypes);

    if(contentType.startsWith(""multipart/form-data"")) {
      boolean hasFields = false;
      FormDataMultiPart mp = new FormDataMultiPart();
      
      if(hasFields)
        postBody = mp;
    }
    else {
      
    }

    try {
      String[] authNames = new String[] { ""api_key"", ""petstore_auth"" };
      String response = apiClient.invokeAPI(path, ""GET"", queryParams, postBody, headerParams, formParams, accept, contentType, authNames);
      if(response != null){
        return (Pet) apiClient.deserialize(response, """", Pet.class);
      }
      else {
        return null;
      }
    } catch (ApiException ex) {
      throw ex;
    }
  }
"	@return Pet	@return Pet	0	1	9	41	253
public View waitForView(View view, int timeout, boolean scroll, boolean checkIsShown){ if(view == null) return null; long endTime = SystemClock.uptimeMillis() + timeout; while (SystemClock.uptimeMillis() < endTime) { final boolean foundAnyMatchingView = searcher.searchFor(view); if(checkIsShown && foundAnyMatchingView && !view.isShown()){ sleeper.sleep(); View identicalView = viewFetcher.getIdenticalView(view); if(identicalView != null && !view.equals(identicalView)){ view = identicalView; } continue; } if (foundAnyMatchingView){ return view; } if(scroll) scroller.scrollDown(); sleeper.sleep(); } return null; }	"	public View waitForView(View view, int timeout, boolean scroll, boolean checkIsShown){

		if(view == null)
			return null;

		long endTime = SystemClock.uptimeMillis() + timeout;

		while (SystemClock.uptimeMillis() < endTime) {
			
			if(checkIsShown && view != null && view.isShown()){
				return view;
			}
			
			final boolean foundAnyMatchingView = searcher.searchFor(view);

			if (foundAnyMatchingView){
				return view;
			}
			
			View identicalView = viewFetcher.getIdenticalView(view);
			if(identicalView != null && !view.equals(identicalView)){
				view = identicalView;
				continue;
			}
		
			if(scroll) 
				scroller.scrollDown();
			
			sleeper.sleep();
		}
		return null;
	}
"	@return  true if view is shown and  false if it is not shown before the timeout	@return true if view is shown and false if it is not shown before the timeout	0	1	11	33	130
public final TwitterTokenStream deserialize(final byte[] data, final CharSequence charSequence) throws IOException { return deserialize(data, NUM, data.length, charSequence); }	"public final TokenStream deserialize(final byte[] data, final CharSequence charSequence) throws IOException {
    return deserialize(data, NUM, data.length, charSequence);
}"	@return a TwitterTokenStream object. Notice that, in order to support lucene-like TwitterTokenStream behavior, this object's reset method must only be used as reset(null) and will reset the TwitterTokenStream to its starting point.	@return a TokenStream object. Notice that, in order to support lucene-like TokenStream behavior, this object's reset method must only be used as reset(null) and will reset the TokenStream to its starting point.	1	0	5	3	32
@Override public boolean equals(Object obj) { if (obj != null && obj.getClass().equals(this.getClass())) { NoteObject that = (NoteObject) obj; if (content == null && that.getContent() != null) return false; if (content != null && !content.equals(that.getContent())) return false; } return true; }	"@Override
public boolean equals(Object obj) {
    if (obj != null && obj.getClass().equals(this.getClass())) {
        NoteObject that = (NoteObject) obj;
        return (this.content.equals(that.getContent()));
    }
    return false;
}"	@return <code>true</code> iff the <code>contents</code> of the two notes are equal.	@return <code>true</code> if <code>content</code> is equal.	1	0	8	11	78
"public AnsiClazzes processCode(String code) { if (code == null || code.length() < 2) return null; if (code.charAt(0) != '\033' && code.charAt(code.length() - 1) != 'm') return null; if (code.length() == 2) { clazzes_.clear(); // CSIm is equivalent to CSI0m, which is 'reset' blockClazzes_.clear(); return null; } int extendedColor = 0; boolean extendedMarkerSeen = false; boolean extendedRGBMarkerSeen = false; int extendedRGBColorsSeen = 0; String[] tokens = code.substring(2, code.length() - 1).split("";""); for (String token : tokens) { int codeVal = StringUtil.parseInt(token, -1); if (codeVal == -1) continue; if (extendedColor > 0) { if (!extendedMarkerSeen && !extendedRGBMarkerSeen) { if (codeVal == EXT_BY_INDEX) { extendedMarkerSeen = true; continue; } else if (codeVal == EXT_BY_RGB) { extendedRGBMarkerSeen = true; extendedRGBColorsSeen = 0; } else { // unknown extended color format; hard to recover so // just reset back to defaults and return clazzes_.clear(); blockClazzes_.clear(); return null; } } else { // We don't support colors specified via RGB, but parse the // sequence then ignore it in case there are supported // sequences after it if (extendedRGBMarkerSeen) { extendedRGBColorsSeen++; if (extendedRGBColorsSeen == 3 /*red, green, blue*/) { extendedColor = 0; extendedRGBMarkerSeen = false; extendedRGBColorsSeen = 0; } } else { if (extendedColor == FOREGROUND_EXT) { if (codeVal >= 0 && codeVal <= 255) { currentColor_.setExtended(codeVal); resetForeground(); clazzes_.add(Color.clazzForColorIndex(codeVal, false /*background*/)); } } else { if (codeVal >= 0 && codeVal <= 255) { currentBgColor_.setExtended(codeVal); resetBackground(); clazzes_.add(Color.clazzForColorIndex(codeVal, true /*background*/)); } } extendedColor = 0; extendedMarkerSeen = false; } } } else if (codeVal == RESET) { inverted_ = false; currentColor_.reset(); currentBgColor_.reset(); clazzes_.clear(); blockClazzes_.clear(); } else if (codeVal == BOLD) { clazzes_.add(BOLD_STYLE); } else if (codeVal == BLURRED) { // NYI clazzes_.add(BLURRED_STYLE); } else if (codeVal == BOLD_BLURRED_OFF) { clazzes_.remove(BOLD_STYLE); // NYI clazzes_.remove(BLURRED_STYLE); } else if (codeVal == ITALIC) { clazzes_.add(ITALIC_STYLE); } else if (codeVal == ITALIC_OFF) { clazzes_.remove(ITALIC_STYLE); } else if (codeVal == UNDERLINE) { clazzes_.add(UNDERLINE_STYLE); } else if (codeVal == UNDERLINE_OFF) { clazzes_.remove(UNDERLINE_STYLE); } else if (codeVal == BLINKSLOW || codeVal == BLINKFAST) { clazzes_.add(BLINK_STYLE); } else if (codeVal == BLINK_OFF) { clazzes_.remove(BLINK_STYLE); } else if (codeVal == INVERSE) { if (!inverted_) { resetForeground(); resetBackground(); Color newFg = invertFgColor(); Color newBg = invertBgColor(); currentColor_ = newFg; currentBgColor_ = newBg; inverted_ = true; } } else if (codeVal == INVERSE_OFF) { if (inverted_) { resetForeground(); resetBackground(); Color newFg = invertFgColor(); Color newBg = invertBgColor(); currentColor_ = newFg; currentBgColor_ = newBg; inverted_ = false; } } else if (codeVal == HIDDEN) { clazzes_.add(HIDDEN_STYLE); } else if (codeVal == HIDDEN_OFF) { clazzes_.remove(HIDDEN_STYLE); } else if (codeVal == STRIKETHROUGH) { clazzes_.add(STRIKETHROUGH_STYLE); } else if (codeVal == STRIKETHROUGH_OFF) { clazzes_.remove(STRIKETHROUGH_STYLE); } else if (Color.isFgColorCode(codeVal)) { currentColor_.setCode(codeVal); resetForeground(); clazzes_.add(clazzForColor(codeVal)); } else if (Color.isBgColorCode(codeVal)) { currentBgColor_ = new Color(false, codeVal); resetBackground(); clazzes_.add(clazzForBgColor(codeVal)); } else if (codeVal == RESET_FOREGROUND) { currentColor_.reset(); resetForeground(); } else if (codeVal == RESET_BACKGROUND) { currentBgColor_.reset(); resetBackground(); } else if (codeVal == FOREGROUND_EXT) { extendedColor = codeVal; extendedMarkerSeen = false; } else if (codeVal == BACKGROUND_EXT) { extendedColor = codeVal; extendedMarkerSeen = false; } else if (codeVal == FONT_NINE) { blockClazzes_.add(FONT_NINE_STYLE); } else if (codeVal == DEFAULT_FONT || (codeVal >= FONT_ONE && codeVal <= FONT_EIGHT)) { blockClazzes_.remove(FONT_NINE_STYLE); } else { // ignore all others } } return getStyles(); }"	"   public String processCode(String code)
   {
      if (code == null || code.length() < 2)
         return null;
      if (code.charAt(0) != '\033' && code.charAt(code.length() - 1) != 'm')
         return null;
      if (code.length() == 2)
      {
         clazzes_.clear(); // CSIm is equivalent to CSI0m, which is 'reset'
         return null;
      }
      
      int extendedColor = 0;
      boolean extendedMarkerSeen = false;
      boolean extendedRGBMarkerSeen = false;
      int extendedRGBColorsSeen = 0;
      
      String[] tokens = code.substring(2, code.length() - 1).split("";"");
      for (String token : tokens)
      {
         int codeVal = StringUtil.parseInt(token,  -1);
         if (codeVal == -1)
            continue;

         if (extendedColor > 0)
         {
            if (!extendedMarkerSeen && !extendedRGBMarkerSeen)
            {
               if (codeVal == EXT_BY_INDEX)
               {
                  extendedMarkerSeen = true;
                  continue;
               }
               else if (codeVal == EXT_BY_RGB)
               {
                  extendedRGBMarkerSeen = true;
                  extendedRGBColorsSeen = 0;
               }
               else
               {
                  // unknown extended color format; hard to recover so
                  // just reset back to defaults and return
                  clazzes_.clear();
                  return null;
               }
            }
            else
            {
               // We don't support colors specified via RGB, but parse the
               // sequence then ignore it in case there are supported 
               // sequences after it
               if (extendedRGBMarkerSeen)
               {
                  extendedRGBColorsSeen++;
                  if (extendedRGBColorsSeen == 3 /*red, green, blue*/)
                  {
                     extendedColor = 0;
                     extendedRGBMarkerSeen = false;
                     extendedRGBColorsSeen = 0;
                  }
               }
               else 
               {
                  if (extendedColor == FOREGROUND_EXT)
                  {
                     if (codeVal >= 0 && codeVal <= 255)
                     {
                        currentColor_.setExtended(codeVal);
                        resetForeground();
                        clazzes_.add(Color.clazzForColorIndex(codeVal, 
                              false /*background*/));
                     }
                  }
                  else
                  {
                     if (codeVal >= 0 && codeVal <= 255)
                     {
                        currentBgColor_.setExtended(codeVal);
                        resetBackground();
                        clazzes_.add(Color.clazzForColorIndex(codeVal, 
                              true /*background*/));
                     }
                  }
                  extendedColor = 0;
                  extendedMarkerSeen = false;
               }
            }
         }
         else if (codeVal == RESET)
         {
            inverted_ = false;
            currentColor_.reset();
            currentBgColor_.reset();
            clazzes_.clear();
         }
         else if (codeVal == BOLD)
         {
            clazzes_.add(BOLD_STYLE);
         }
         else if (codeVal == BLURRED)
         {
            // NYI clazzes_.add(BLURRED_STYLE);
         }
         else if (codeVal == BOLD_BLURRED_OFF)
         {
            clazzes_.remove(BOLD_STYLE);
            // NYI clazzes_.remove(BLURRED_STYLE);
         }
         else if (codeVal == ITALIC)
         {
            clazzes_.add(ITALIC_STYLE);
         }
         else if (codeVal == ITALIC_OFF)
         {
            clazzes_.remove(ITALIC_STYLE);
         }
         else if (codeVal == UNDERLINE)
         {
            clazzes_.add(UNDERLINE_STYLE);
         }
         else if (codeVal == UNDERLINE_OFF)
         {
            clazzes_.remove(UNDERLINE_STYLE);
         }
         else if (codeVal == BLINKSLOW || codeVal == BLINKFAST)
         {
            clazzes_.add(BLINK_STYLE);
         }
         else if (codeVal == BLINK_OFF)
         {
            clazzes_.remove(BLINK_STYLE);
         }
         else if (codeVal == INVERSE)
         {
            if (!inverted_)
            {
               resetForeground();
               resetBackground();
               Color newFg = invertFgColor();
               Color newBg = invertBgColor();
               currentColor_ = newFg;
               currentBgColor_ = newBg;
               inverted_ = true;
            }
         }
         else if (codeVal == INVERSE_OFF)
         {
            if (inverted_)
            {
               resetForeground();
               resetBackground();
               Color newFg = invertFgColor();
               Color newBg = invertBgColor();
               currentColor_ = newFg;
               currentBgColor_ = newBg;
               inverted_ = false;
            }
         }
         else if (codeVal == HIDDEN)
         {
            clazzes_.add(HIDDEN_STYLE);
         }
         else if (codeVal == HIDDEN_OFF)
         {
            clazzes_.remove(HIDDEN_STYLE);
         }
         else if (codeVal == STRIKETHROUGH)
         {
            clazzes_.add(STRIKETHROUGH_STYLE);
         }
         else if (codeVal == STRIKETHROUGH_OFF)
         {
            clazzes_.remove(STRIKETHROUGH_STYLE);
         }
         else if (Color.isFgColorCode(codeVal))
         {
            currentColor_.setCode(codeVal);
            resetForeground();
            clazzes_.add(clazzForColor(codeVal));
         }
         else if (Color.isBgColorCode(codeVal))
         {
            currentBgColor_ = new Color(false, codeVal);
            resetBackground();
            clazzes_.add(clazzForBgColor(codeVal));
         }
         else if (codeVal == RESET_FOREGROUND)
         {
            currentColor_.reset();
            resetForeground();
         }
         else if (codeVal == RESET_BACKGROUND)
         {
            currentBgColor_.reset();
            resetBackground();
         }
         else if (codeVal == FOREGROUND_EXT)
         {
           extendedColor = codeVal;
           extendedMarkerSeen = false;
         }
         else if (codeVal == BACKGROUND_EXT)
         {
           extendedColor = codeVal;
           extendedMarkerSeen = false;
         }
         else
         {
            // ignore all others
         }
      }
      return getStyle();
   }
"	@return AnsiClazzes, containing both span-level and block-level styles	@return Clazzes or null if no color classes were applied	1	0	33	226	895
public float getReal() { return (float) getFirstValue(); }	"public float getReal(final int i) {
    return (float) getFirstValue(i);
}"	@return item in first position	@return item in given position	1	0	5	3	15
public IRunnableWithProgress getOperation() { return operation; }	"public Runnable getOperation() {
    return operation;
}"	@return the {@link IRunnableWithProgress} operation associated with this page that should be run during the wizard's doRunEpilogue() method. This operation should only be executed if in fact the page is visible.	@return the java.lang.Runnable() operation associated with this page that should be run during the wizard's doRunEpilogue() method. This operation should only be executed if in fact the page is visible.	1	0	4	3	10
public int getCurrenButtonsCount() { int number = soloView.getCurrenButtonsCount(); return number; }	"	public int getCurrenButtonsCount() {
		return getCurrentButtons().size();
	}
"	@return the number of buttons in the current activity	@return the number of buttons in the current activity	0	1	5	5	17
public boolean isConnected() { return !disposed.get(); }	"    public boolean isConnected() {
        return !disposed;
    }
"	@return true if the Connection is connected	@return true if the Connection is connected	0	1	4	4	14
public int getTerminalCount() { return activeTerminalToolbarButton_.terminalCount(); }	"public int getTerminalCount() {
    return terminalSessionsPanel_.getWidgetCount();
}"	@return number of terminals in the dropdown	@return number of terminals hosted by the pane	1	0	4	3	13
private ZapTextField getTxtReverseProxyHttpsPort() { if (txtReverseProxyHttpsPort == null) { txtReverseProxyHttpsPort = new ZapTextField(); } return txtReverseProxyHttpsPort; }	"	private JTextField getTxtReverseProxyHttpsPort() {
		if (txtReverseProxyHttpsPort == null) {
			txtReverseProxyHttpsPort = new JTextField();
		}
		return txtReverseProxyHttpsPort;
	}
"	@return javax.swing.ZapTextField	@return javax.swing.JTextField	1	0	8	7	23
@SuppressWarnings(STR) public double getReal() { return (double) getFirstValue(); }	"@SuppressWarnings(STR)
public double getReal(final int i) {
    return (double) getFirstValue(i);
}"	@return item in first position	@return item in given position	1	0	5	4	20
private Timestamp[] getTimeframe() { Timestamp oldest = Timestamp.ZERO.plus(1000000); Timestamp newest = Timestamp.ZERO; for (Habit h : selectedHabits) { if(h.getRepetitions().getOldest() == null || h.getRepetitions().getNewest() == null) continue; Timestamp currOld = h.getRepetitions().getOldest().getTimestamp(); Timestamp currNew = h.getRepetitions().getNewest().getTimestamp(); oldest = currOld.isOlderThan(oldest) ? oldest : currOld; newest = currNew.isNewerThan(newest) ? newest : currNew; } return new Timestamp[]{oldest, newest}; }	"    private long[] getTimeframe()
    {
        long oldest = Long.MAX_VALUE;
        long newest = -1;
        for (Habit h : selectedHabits)
        {
            if(h.getRepetitions().getOldest() == null || h.getRepetitions().getNewest() == null)
                continue;
            long currOld = h.getRepetitions().getOldest().getTimestamp();
            long currNew = h.getRepetitions().getNewest().getTimestamp();
            oldest = currOld > oldest ? oldest : currOld;
            newest = currNew < newest ? newest : currNew;
        }
        return new long[]{oldest, newest};
    }
"	@return the timeframe containing the oldest timestamp and the newest timestamp	@return the timeframe containing the oldest timestamp and the newest timestamp	0	1	9	16	114
private byte[] marshalAggregatorValues(long superstep) { if (superstep == INPUT_SUPERSTEP) { return new byte[NUM]; } ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); DataOutputStream output = new DataOutputStream(outputStream); for (Entry<String, AggregatorWrapper<Writable>> entry : getAggregatorMap().entrySet()) { if (entry.getValue().isChanged()) { try { output.writeUTF(entry.getKey()); entry.getValue().getCurrentAggregatedValue().write(output); } catch (IOException e) { throw new IllegalStateException(STR + STR + entry.getKey(), e); } } } if (LOG.isInfoEnabled()) { LOG.info(STR); } return outputStream.toByteArray(); }	"private JSONArray marshalAggregatorValues(long superstep) {
    JSONArray aggregatorArray = new JSONArray();
    if ((superstep == INPUT_SUPERSTEP) || (aggregatorInUse.size() == NUM)) {
        return aggregatorArray;
    }
    for (String name : aggregatorInUse) {
        try {
            Aggregator<Writable> aggregator = getAggregatorMap().get(name);
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            DataOutput output = new DataOutputStream(outputStream);
            aggregator.getAggregatedValue().write(output);
            JSONObject aggregatorObj = new JSONObject();
            aggregatorObj.put(AGGREGATOR_NAME_KEY, name);
            aggregatorObj.put(AGGREGATOR_CLASS_NAME_KEY, aggregator.getClass().getName());
            aggregatorObj.put(AGGREGATOR_VALUE_KEY, Base64.encodeBytes(outputStream.toByteArray()));
            aggregatorArray.put(aggregatorObj);
            if (LOG.isInfoEnabled()) {
                LOG.info(STR + STR + aggregatorObj + STR + aggregator.getAggregatedValue() + STR);
            }
        } catch (JSONException e) {
            throw new IllegalStateException(STR + STR + name, e);
        } catch (IOException e) {
            throw new IllegalStateException(STR + STR + name, e);
        }
    }
    if (LOG.isInfoEnabled()) {
        LOG.info(STR + STR + aggregatorArray);
    }
    aggregatorInUse.clear();
    return aggregatorArray;
}"	@return Byte array of the aggreagtor values	@return JSON array of the aggreagtor values	1	0	13	21	138
boolean shouldShowSelector() { return ((hasFocus() && !isInTouchMode()) || touchModeDrawsInPressedState()) && ( mBeginClick ) ; }	"    boolean shouldShowSelector() {
        return (hasFocus() && !isInTouchMode()) || touchModeDrawsInPressedState();
    }
"	@return True if the selector should be shown	@return True if the selector should be shown	0	1	7	4	31
public static List<Point> convexHull(List<Point> points) { int[] xs = new int[points.size()]; int[] ys = new int[xs.length]; for (int i = 0; i < xs.length; i++) { Point p = points.get(i); xs[i] = p.getX(); ys[i] = p.getY(); } SimplePolygon poly = convexHull(xs, ys); if (poly == null) { return null; } return poly.toRuneLitePointList(); }	"	public static List<Point> convexHull(List<Point> points)
	{
		if (points.size() < 3)
		{
			return null;
		}

		List<Point> ch = new ArrayList<>();

		// find the left most point
		Point left = findLeftMost(points);

		// current point we are on
		Point current = left;

		do
		{
			ch.add(current);
			assert ch.size() <= points.size() : ""hull has more points than graph"";
			if (ch.size() > points.size())
			{
				// Just to make sure we never somehow get stuck in this loop
				return null;
			}

			// the next point - all points are to the right of the
			// line between current and next
			Point next = null;

			for (Point p : points)
			{
				if (next == null)
				{
					next = p;
					continue;
				}

				long cp = crossProduct(current, p, next);
				if (cp > 0 || (cp == 0 && current.distanceTo(p) > current.distanceTo(next)))
				{
					next = p;
				}
			}

			// Points can be null if they are behind or very close to the camera.
			if (next == null)
			{
				return null;
			}

			current = next;
		}
		while (current != left);

		return ch;
	}
"	@return list containing the points part of the convex hull	@return list containing the points part of the convex hull	0	1	9	20	103
public boolean searchText(String regex, int matches, boolean scroll) { return searcher.searchText(regex, matches, scroll); }	"	public boolean searchText(String search, int matches, boolean scroll) {
		return searcher.searchText(search, matches, scroll);
	}
"	@return  true if regex string is found a given number of times and  false if the regex string is not found	@return true if search string is found a given number of times and false if the search string is not found	1	0	5	4	26
private ConnectionContainer upsertObjects(Environment context) { if (context.ids.isPresent()) { throw new BadRequestException(STR); } if (!context.data.isPresent()) { throw new BadRequestException(STR); } Class<?> entityClass; EntityDictionary dictionary = context.requestScope.getDictionary(); if (context.isRoot()) { entityClass = dictionary.getEntityClass(context.field.getName()); } else { entityClass = dictionary.getParameterizedType(context.parentResource.getResourceClass(), context.field.getName()); } Optional<Entity> parentEntity; if (!context.isRoot()) { parentEntity = Optional.of(new Entity(Optional.empty(), null, context.parentResource.getResourceClass(), context.requestScope)); } else { parentEntity = Optional.empty(); } LinkedHashSet<Entity> entitySet = new LinkedHashSet<>(); for (Map<String, Object> input : context.data.get()) { entitySet.add(new Entity(parentEntity, input, entityClass, context.requestScope)); } for (Entity entity : entitySet) { graphWalker(entity, (e) -> upsertObject(context, e)); } for (Entity entity : entitySet) { graphWalker(entity, this::updateRelationship); if (!context.isRoot()) { context.parentResource.addRelation(context.field.getName(), entity.toPersistentResource()); } } String entityName = dictionary.getJsonAliasFor(entityClass); Set<PersistentResource> resources = entitySet.stream().map(Entity::toPersistentResource).collect(Collectors.toCollection(LinkedHashSet::new)); return new ConnectionContainer(resources, Optional.empty(), entityName); }	"private Set<PersistentResource> upsertObjects(Environment context) {
    if (context.ids.isPresent()) {
        throw new BadRequestException(STR);
    }
    if (!context.data.isPresent()) {
        throw new BadRequestException(STR);
    }
    Class<?> entityClass;
    EntityDictionary dictionary = context.requestScope.getDictionary();
    if (context.isRoot()) {
        entityClass = dictionary.getEntityClass(context.field.getName());
    } else {
        entityClass = dictionary.getParameterizedType(context.parentResource.getResourceClass(), context.field.getName());
    }
    Optional<Entity> parentEntity;
    if (!context.isRoot()) {
        parentEntity = Optional.of(new Entity(Optional.empty(), null, context.parentResource.getResourceClass(), context.requestScope));
    } else {
        parentEntity = Optional.empty();
    }
    LinkedHashSet<Entity> entitySet = new LinkedHashSet<>();
    for (Map<String, Object> input : context.data.get()) {
        entitySet.add(new Entity(parentEntity, input, entityClass, context.requestScope));
    }
    for (Entity entity : entitySet) {
        graphWalker(entity, this::upsertObject);
    }
    for (Entity entity : entitySet) {
        graphWalker(entity, this::updateRelationship);
        if (!context.isRoot()) {
            context.parentResource.addRelation(context.field.getName(), entity.toPersistentResource());
        }
    }
    return entitySet.stream().map(Entity::toPersistentResource).collect(Collectors.toCollection(LinkedHashSet::new));
}"	@return Connection object.	@return list of {@link PersistentResource} objects	1	0	9	37	303
public Field withDefault(BooleanSupplier defaultValueGenerator) { return new Field(name(), displayName(), type(), width, description(), importance(), dependents, defaultValueGenerator::getAsBoolean, validator, recommender); }	"    public Field withDefault(BooleanSupplier defaultValueGenerator) {
        return Field.create(name(), description(), defaultValueGenerator);
    }
"	@return the new field; never null	@return the new field; never null	0	1	6	5	47
"public Client testClientModel(Client body) throws ApiException { Object localVarPostBody = body; // verify the required parameter 'body' is set if (body == null) { throw new ApiException(400, ""Missing the required parameter 'body' when calling testClientModel""); } // create path and map variables String localVarPath = ""/fake""; // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, String> localVarCookieParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { ""application/json"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { ""application/json"" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Client> localVarReturnType = new GenericType<Client>() {}; return apiClient.invokeAPI(localVarPath, ""PATCH"", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	"  public Client testClientModel(Client body) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, ""Missing the required parameter 'body' when calling testClientModel"");
    }
    
    // create path and map variables
    String localVarPath = ""/fake"";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    final String[] localVarAccepts = {
      ""application/json""
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      ""application/json""
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    GenericType<Client> localVarReturnType = new GenericType<Client>() {};
    return apiClient.invokeAPI(localVarPath, ""PATCH"", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);
      }
"	@return Client	@return Client	0	1	8	38	225
public List<ScoredObject<Tree>> getKBestParses(int k) { if (parseSkipped) { return null; } if (bparser != null && parseSucceeded) { //The getKGoodParses seems to be broken, so just return the best parse Tree binaryTree = bparser.getBestParse(); Tree tree = debinarizer.transformTree(binaryTree); if (op.nodePrune) { NodePruner np = new NodePruner(pparser, debinarizer); tree = np.prune(tree); } tree = subcategoryStripper.transformTree(tree); restoreOriginalWords(tree); double score = dparser.getBestScore(); ScoredObject<Tree> so = new ScoredObject<>(tree, score); List<ScoredObject<Tree>> trees = new ArrayList<>(1); trees.add(so); return trees; } else if (pparser != null && pparser.hasParse() && fallbackToPCFG) { return this.getKBestPCFGParses(k); } else if (dparser != null && dparser.hasParse()) { // && fallbackToDG // The dependency parser doesn't support k-best parse extraction, so just // return the best parse Tree tree = this.getBestDependencyParse(true); double score = dparser.getBestScore(); ScoredObject<Tree> so = new ScoredObject<>(tree, score); List<ScoredObject<Tree>> trees = new ArrayList<>(1); trees.add(so); return trees; } else { throw new NoSuchParseException(); } }	"  public List<ScoredObject<Tree>> getKBestParses(int k) {
    if (parseSkipped) {
      return null;
    }
    if (bparser != null && parseSucceeded) {
     return this.getKGoodFactoredParses(k);
    } else if (pparser != null && pparser.hasParse() && fallbackToPCFG) {
      return this.getKBestPCFGParses(k);
    } else if (dparser != null && dparser.hasParse()) { // && fallbackToDG
      // The dependency parser doesn't support k-best parse extraction, so just
      // return the best parse
      Tree tree = this.getBestDependencyParse(true);
      double score = dparser.getBestScore();
      ScoredObject<Tree> so = new ScoredObject<>(tree, score);
      List<ScoredObject<Tree>> trees = new ArrayList<>(1);
      trees.add(so);
      return trees;
    } else {
      throw new NoSuchParseException();
    }
  }
"	@return A list of scored trees	@return A list of scored trees	0	1	12	37	256
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; // set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { // prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); // System.err.println(""At end of text making after: |"" + str + ""|""); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); // System.err.println(""prevWord is |"" + prevWord.get(CoreAnnotations.TextAnnotation.class) + ""|, its after is |"" + // prevWord.get(CoreAnnotations.AfterAnnotation.class) + ""|""); prevWordAfter.setLength(0); } return null; } } else { switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { String str = yytext(); int first = str.codePointAt(0); String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } logger.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: logger.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 73: break; case 2: { return getNext(""<"", yytext()); } case 74: break; case 3: { return getNext(); } case 75: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 76: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns } else if (invertible) { // System.err.println(""Appending newline: |"" + yytext() + ""|""); prevWordAfter.append(yytext()); } } case 77: break; case 6: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 78: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 79: break; case 8: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {QUOTES} (2) to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 80: break; case 9: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {SREDAUX} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 81: break; case 10: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 82: break; case 11: { return getNext("">"", yytext()); } case 83: break; case 12: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 84: break; case 13: { handleHyphenatedNumber(yytext()); if (DEBUG) { logger.info(""Used {NUMBER} to recognize "" + yytext() + "" as "" + removeFromNumber(yytext())); } return getNext(removeFromNumber(yytext()), yytext()); } case 85: break; case 14: { return handleEllipsis(yytext()); } case 86: break; case 15: { // breakByHyphens(yytext()); // this is causing fail of attempted to pushback too much! String tok = yytext(); /* A THING can contain quote like O'Malley */ String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {THING} (2) to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 87: break; case 16: { return normalizeFractions(yytext()); } case 88: break; case 17: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(minimallyNormalizeCurrency(yytext()), yytext()); } } case 89: break; case 18: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 90: break; case 19: { if (normalizeOtherBrackets) { return getNext(""-RSB-"", yytext()); } else { return getNext(); } } case 91: break; case 20: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 92: break; case 21: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 93: break; case 22: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 94: break; case 23: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 95: break; case 24: { if (normalizeOtherBrackets) { return getNext(""-LSB-"", yytext()); } else { return getNext(); } } case 96: break; case 25: { if (invertible) { prevWordAfter.append(yytext()); } } case 97: break; case 26: { return getNext(""\u2022"", yytext()); } case 98: break; case 27: { return getNext(""\u2122"", yytext()); } case 99: break; case 28: // general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 100: break; case 29: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(); } case 101: break; case 30: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {REDAUX} (2nd) to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 102: break; case 31: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {APOWORD} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 103: break; case 32: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); String norm = handleQuotes(tok, true); if (DEBUG) { logger.info(""Used {DBLQUOT} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + true); } return getNext(norm, tok); } case 104: break; case 33: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 105: break; case 34: { breakByHyphens(yytext()); if (DEBUG) { logger.info(""Used {HTHING} to recognize "" + yytext() + "" as "" + removeSoftHyphens(yytext())); } return getNext(removeSoftHyphens(yytext()), yytext()); } case 106: break; case 35: // general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 107: break; case 36: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 108: break; case 37: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 109: break; case 38: { // this one should only match if we're basically at the end of file // since the last one matches two things, even newlines (if not tokenize per line) String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 110: break; case 39: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 111: break; case 40: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { String tok = yytext(); /* invert single quote - often but not always right */ String norm = handleQuotes(tok, true); if (DEBUG) { logger.info(""Used {QUOTES} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + true); } return getNext(norm, tok); } case 112: break; case 41: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {REDAUX} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 113: break; case 42: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 114: break; case 43: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {SREDAUX} (2nd) to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 115: break; case 44: { String txt = yytext(); // if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space... if (strictTreebank3) { int spaceIndex = indexOfSpace(txt); if (spaceIndex >= 0) { yypushback(txt.length() - spaceIndex); return getNext(); } } if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, yytext()); } case 116: break; case 45: { return getNormalizedAmpNext(); } case 117: break; case 46: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, origTxt); } case 118: break; case 47: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space } return getNext(txt, origTxt); } case 119: break; case 48: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 120: break; case 49: { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 121: break; case 50: // general lookahead, find correct zzMarkedPos { int zzFState = 17; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 122: break; case 51: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {SREDAUX} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 123: break; case 52: // lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 124: break; case 53: // general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 125: break; case 54: // general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 22; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 126: break; case 55: // general lookahead, find correct zzMarkedPos { int zzFState = 18; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 19; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 127: break; case 56: // general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 128: break; case 57: // general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 21; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 129: break; case 58: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 130: break; case 59: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); breakByHyphens(tok); tok = yytext(); String norm = removeSoftHyphens(tok); if (DEBUG) { logger.info(""Used {HTHING} (2) to recognize "" + tok + "" as "" + norm); } return getNext(norm, tok); } case 131: break; case 60: { if (splitAssimilations) { yypushback(3) ; return getNext(); } else { return getNext(); } } case 132: break; case 61: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNormalizedAmpNext(); } case 133: break; case 62: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 9; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 134: break; case 63: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { return getNext(); } case 135: break; case 64: // general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 136: break; case 65: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 137: break; case 66: // general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 13; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 138: break; case 67: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } return getNext(txt, yytext()); } case 139: break; case 68: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4); { return getNext(); } case 140: break; case 69: // lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { return getNext(); } case 141: break; case 70: { String txt = yytext(); if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } if (DEBUG) { logger.info(""Used {PHONE} to recognize "" + yytext() + "" as "" + txt); } return getNext(txt, yytext()); } case 142: break; case 71: // general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 25; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 143: break; case 72: // general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 24; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 144: break; default: zzScanError(ZZ_NO_MATCH); } } } }"	"  public Object next() throws java.io.IOException {
    int zzInput;
    int zzAction;

    // cached fields:
    int zzCurrentPosL;
    int zzMarkedPosL;
    int zzEndReadL = zzEndRead;
    char [] zzBufferL = zzBuffer;
    char [] zzCMapL = ZZ_CMAP;

    int [] zzTransL = ZZ_TRANS;
    int [] zzRowMapL = ZZ_ROWMAP;
    int [] zzAttrL = ZZ_ATTRIBUTE;

    while (true) {
      zzMarkedPosL = zzMarkedPos;

      yychar+= zzMarkedPosL-zzStartRead;

      zzAction = -1;

      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
  
      zzState = ZZ_LEXSTATE[zzLexicalState];

      // set up zzAction for empty match case:
      int zzAttributes = zzAttrL[zzState];
      if ( (zzAttributes & 1) == 1 ) {
        zzAction = zzState;
      }


      zzForAction: {
        while (true) {
    
          if (zzCurrentPosL < zzEndReadL) {
            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);
            zzCurrentPosL += Character.charCount(zzInput);
          }
          else if (zzAtEOF) {
            zzInput = YYEOF;
            break zzForAction;
          }
          else {
            // store back cached positions
            zzCurrentPos  = zzCurrentPosL;
            zzMarkedPos   = zzMarkedPosL;
            boolean eof = zzRefill();
            // get translated positions and possibly new buffer
            zzCurrentPosL  = zzCurrentPos;
            zzMarkedPosL   = zzMarkedPos;
            zzBufferL      = zzBuffer;
            zzEndReadL     = zzEndRead;
            if (eof) {
              zzInput = YYEOF;
              break zzForAction;
            }
            else {
              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);
              zzCurrentPosL += Character.charCount(zzInput);
            }
          }
          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
          if (zzNext == -1) break zzForAction;
          zzState = zzNext;

          zzAttributes = zzAttrL[zzState];
          if ( (zzAttributes & 1) == 1 ) {
            zzAction = zzState;
            zzMarkedPosL = zzCurrentPosL;
            if ( (zzAttributes & 8) == 8 ) break zzForAction;
          }

        }
      }

      // store back cached position
      zzMarkedPos = zzMarkedPosL;

      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
        zzAtEOF = true;
              {
                if (invertible) {
            // prevWordAfter.append(yytext());
            String str = prevWordAfter.toString();
            // System.err.println(""At end of text making after: |"" + str + ""|"");
            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);
            // System.err.println(""prevWord is |"" + prevWord.get(CoreAnnotations.TextAnnotation.class) + ""|, its after is |"" +
            //         prevWord.get(CoreAnnotations.AfterAnnotation.class) + ""|"");
            prevWordAfter.setLength(0);
          }
          return null;
              }
      }
      else {
        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
          case 1: 
            { String str = yytext();
          int first = str.codePointAt(0);
          String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));
          switch (untokenizable) {
            case NONE_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              break;
            case FIRST_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              if ( ! this.seenUntokenizableCharacter) {
                logger.warning(msg);
                this.seenUntokenizableCharacter = true;
              }
              break;
            case ALL_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              logger.warning(msg);
              this.seenUntokenizableCharacter = true;
              break;
            case NONE_KEEP:
              return getNext();
            case FIRST_KEEP:
              if ( ! this.seenUntokenizableCharacter) {
                logger.warning(msg);
                this.seenUntokenizableCharacter = true;
              }
              return getNext();
            case ALL_KEEP:
              logger.warning(msg);
              this.seenUntokenizableCharacter = true;
              return getNext();
          }
            }
          case 73: break;
          case 2: 
            { return getNext(""<"", yytext());
            }
          case 74: break;
          case 3: 
            { return getNext();
            }
          case 75: break;
          case 4: 
            { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {
                    return getNext(ptbmdash, yytext());
                  } else {
                    return getNext();
                  }
            }
          case 76: break;
          case 5: 
            { if (tokenizeNLs) {
                      return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns
                  } else if (invertible) {
                    // System.err.println(""Appending newline: |"" + yytext() + ""|"");
                    prevWordAfter.append(yytext());
                  }
            }
          case 77: break;
          case 6: 
            { final String origTxt = yytext();
                          String tmp = removeSoftHyphens(origTxt);
                          if (americanize) {
                            tmp = Americanize.americanize(tmp);
                          }
                          return getNext(tmp, origTxt);
            }
          case 78: break;
          case 7: 
            { if (invertible) {
                     prevWordAfter.append(yytext());
                  }
            }
          case 79: break;
          case 8: 
            { String tok = yytext();
                  String norm = handleQuotes(tok, false);
                  if (DEBUG) { logger.info(""Used {QUOTES} to recognize "" + tok + "" as "" + norm +
                                           ""; probablyLeft="" + false); }
                  return getNext(norm, tok);
            }
          case 80: break;
          case 9: 
            { String tok = yytext();
                          String norm = handleQuotes(tok, false);
                          if (DEBUG) { logger.info(""Used {SREDAUX} to recognize "" + tok + "" as "" + norm +
                                                   ""; probablyLeft="" + false); }
                          return getNext(norm, tok);
            }
          case 81: break;
          case 10: 
            { if (escapeForwardSlashAsterisk) {
                    return getNext(delimit(yytext(), '/'), yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 82: break;
          case 11: 
            { return getNext("">"", yytext());
            }
          case 83: break;
          case 12: 
            { if (ptb3Dashes) {
                            return getNext(ptbmdash, yytext()); }
                          else {
                            return getNext();
                          }
            }
          case 84: break;
          case 13: 
            { handleHyphenatedNumber(yytext());
                          if (DEBUG) { logger.info(""Used {NUMBER} to recognize "" + yytext() + "" as "" + removeFromNumber(yytext())); }
                          return getNext(removeFromNumber(yytext()), yytext());
            }
          case 85: break;
          case 14: 
            { return handleEllipsis(yytext());
            }
          case 86: break;
          case 15: 
            { String tok = yytext();
                  /* A THING can contain quote like O'Malley */
                  String norm = handleQuotes(tok, false);
                  if (DEBUG) { logger.info(""Used {THING} (2) to recognize "" + tok + "" as "" + norm +
                                           ""; probablyLeft="" + false); }
                  return getNext(norm, tok);
            }
          case 87: break;
          case 16: 
            { return normalizeFractions(yytext());
            }
          case 88: break;
          case 17: 
            { if (normalizeCurrency) {
                            return getNext(normalizeCurrency(yytext()), yytext());
                        } else {
                            return getNext(minimallyNormalizeCurrency(yytext()), yytext());
                          }
            }
          case 89: break;
          case 18: 
            { if (normalizeOtherBrackets) {
                    return getNext(closebrace, yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 90: break;
          case 19: 
            { if (normalizeOtherBrackets) {
                    return getNext(""-RSB-"", yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 91: break;
          case 20: 
            { if (normalizeParentheses) {
                    return getNext(openparen, yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 92: break;
          case 21: 
            { if (normalizeParentheses) {
                    return getNext(closeparen, yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 93: break;
          case 22: 
            { if (escapeForwardSlashAsterisk) {
                    return getNext(delimit(yytext(), '*'), yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 94: break;
          case 23: 
            { if (normalizeOtherBrackets) {
                    return getNext(openbrace, yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 95: break;
          case 24: 
            { if (normalizeOtherBrackets) {
                    return getNext(""-LSB-"", yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 96: break;
          case 25: 
            { if (invertible) {
                            prevWordAfter.append(yytext());
                        }
            }
          case 97: break;
          case 26: 
            { return getNext(""\u2022"", yytext());
            }
          case 98: break;
          case 27: 
            { return getNext(""\u2122"", yytext());
            }
          case 99: break;
          case 28: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 15;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 16;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return getNext();
            }
          case 100: break;
          case 29: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { return getNext();
            }
          case 101: break;
          case 30: 
            { String tok = yytext();
                  String norm = handleQuotes(tok, false);
                  if (DEBUG) { logger.info(""Used {REDAUX} (2nd) to recognize "" + tok + "" as "" + norm +
                                           ""; probablyLeft="" + false); }
                  return getNext(norm, tok);
            }
          case 102: break;
          case 31: 
            { String tok = yytext();
                          String norm = handleQuotes(tok, false);
                          if (DEBUG) { logger.info(""Used {APOWORD} to recognize "" + tok + "" as "" + norm +
                                                   ""; probablyLeft="" + false); }
                          return getNext(norm, tok);
            }
          case 103: break;
          case 32: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { String tok = yytext();
                                   String norm = handleQuotes(tok, true);
                                   if (DEBUG) { logger.info(""Used {DBLQUOT} to recognize "" + tok + "" as "" + norm +
                                                            ""; probablyLeft="" + true); }
                                   return getNext(norm, tok);
            }
          case 104: break;
          case 33: 
            { String txt = yytext();
                  String origText = txt;
                  if (normalizeParentheses) {
                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                  }
                  return getNext(txt, origText);
            }
          case 105: break;
          case 34: 
            { breakByHyphens(yytext());
                  if (DEBUG) { logger.info(""Used {HTHING} to recognize "" + yytext() + "" as "" + removeSoftHyphens(yytext())); }
                  return getNext(removeSoftHyphens(yytext()), yytext());
            }
          case 106: break;
          case 35: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 3;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 4;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { final String origTxt = yytext();
                          String tmp = removeSoftHyphens(origTxt);
                          if (americanize) {
                            tmp = Americanize.americanize(tmp);
                          }
                          return getNext(tmp, origTxt);
            }
          case 107: break;
          case 36: 
            { if (escapeForwardSlashAsterisk) {
                            return getNext(delimit(yytext(), '/'), yytext());
                          } else {
                            return getNext();
                          }
            }
          case 108: break;
          case 37: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { return getNext(removeSoftHyphens(yytext()), yytext());
            }
          case 109: break;
          case 38: 
            { // this one should only match if we're basically at the end of file
                          // since the last one matches two things, even newlines (if not tokenize per line)
                          String s;
                          if (strictTreebank3 && ! ""U.S."".equals(yytext())) {
                            yypushback(1); // return a period for next time
                            s = yytext();
                          } else {
                            s = yytext();
                            yypushback(1); // return a period for next time
                          }
                          return getNext(s, yytext());
            }
          case 110: break;
          case 39: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { String txt = yytext();
                  String origText = txt;
                  if (normalizeParentheses) {
                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                  }
                  return getNext(txt, origText);
            }
          case 111: break;
          case 40: 
            // lookahead expression with fixed base length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 1);
            { String tok = yytext();
                               /* invert single quote - often but not always right */
                               String norm = handleQuotes(tok, true);
                               if (DEBUG) { logger.info(""Used single straight quote to recognize "" + tok + "" as "" + norm +
                                                        ""; probablyLeft="" + true); }
                               return getNext(norm, tok);
            }
          case 112: break;
          case 41: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { String tok = yytext();
                          String norm = handleQuotes(tok, false);
                          if (DEBUG) { logger.info(""Used {REDAUX} to recognize "" + tok + "" as "" + norm +
                                                   ""; probablyLeft="" + false); }
                          return getNext(norm, tok);
            }
          case 113: break;
          case 42: 
            { return getNext(removeSoftHyphens(yytext()), yytext());
            }
          case 114: break;
          case 43: 
            { String tok = yytext();
                  String norm = handleQuotes(tok, false);
                  if (DEBUG) { logger.info(""Used {SREDAUX} (2nd) to recognize "" + tok + "" as "" + norm +
                                           ""; probablyLeft="" + false); }
                  return getNext(norm, tok);
            }
          case 115: break;
          case 44: 
            { String txt = yytext();
                  // if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space...
                  if (strictTreebank3) {
                    int spaceIndex = indexOfSpace(txt);
                    if (spaceIndex >= 0) {
                      yypushback(txt.length() - spaceIndex);
                      return getNext();
                    }
                  }
                  if (escapeForwardSlashAsterisk) {
                    txt = delimit(txt, '/');
                  }
                  if (normalizeSpace) {
                    txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                  }
                  return getNext(txt, yytext());
            }
          case 116: break;
          case 45: 
            { return getNormalizedAmpNext();
            }
          case 117: break;
          case 46: 
            { final String origTxt = yytext();
                          String txt = origTxt;
                          if (normalizeSpace) {
                            txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                          }
                          return getNext(txt, origTxt);
            }
          case 118: break;
          case 47: 
            { final String origTxt = yytext();
                          String txt = origTxt;
                          if (normalizeSpace) {
                            txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                          }
                          return getNext(txt, origTxt);
            }
          case 119: break;
          case 48: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 5;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 6;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { final String txt = yytext();
                          return getNext(removeSoftHyphens(txt),
                                         txt);
            }
          case 120: break;
          case 49: 
            { if (splitAssimilations) {
                            yypushback(2) ; return getNext();
                          } else {
                            return getNext();
                          }
            }
          case 121: break;
          case 50: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 17;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 16;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return getNext();
            }
          case 122: break;
          case 51: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { String tok = yytext();
                          String norm = handleQuotes(tok, false);
                          if (DEBUG) { logger.info(""Used {SREDAUX} to recognize "" + tok + "" as "" + norm +
                                                   ""; probablyLeft="" + false); }
                          return getNext(norm, tok);
            }
          case 123: break;
          case 52: 
            // lookahead expression with fixed base length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);
            { if (splitAssimilations) {
                            yypushback(2) ; return getNext();
                          } else {
                            return getNext();
                          }
            }
          case 124: break;
          case 53: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 10;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 11;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return processAbbrev3();
            }
          case 125: break;
          case 54: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 20;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 22;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */
                                    return handleEllipsis(yytext());
            }
          case 126: break;
          case 55: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 18;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 19;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return getNext();
            }
          case 127: break;
          case 56: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 10;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 11;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return processAbbrev3();
            }
          case 128: break;
          case 57: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 20;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 21;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */
                                    return handleEllipsis(yytext());
            }
          case 129: break;
          case 58: 
            { String txt = yytext();
                          if (escapeForwardSlashAsterisk) {
                            txt = delimit(txt, '/');
                            txt = delimit(txt, '*');
                          }
                          return getNext(txt, yytext());
            }
          case 130: break;
          case 59: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { breakByHyphens(yytext());
                  return getNext(removeSoftHyphens(yytext()), yytext());
            }
          case 131: break;
          case 60: 
            { if (splitAssimilations) {
                            yypushback(3) ; return getNext();
                          } else {
                            return getNext();
                          }
            }
          case 132: break;
          case 61: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { return getNormalizedAmpNext();
            }
          case 133: break;
          case 62: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 7;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 9;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return processAcronym();
            }
          case 134: break;
          case 63: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);
            { return getNext();
            }
          case 135: break;
          case 64: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 12;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 14;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return processAbbrev1();
            }
          case 136: break;
          case 65: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 7;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 8;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return processAcronym();
            }
          case 137: break;
          case 66: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 12;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 13;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return processAbbrev1();
            }
          case 138: break;
          case 67: 
            { String txt = yytext();
                          if (escapeForwardSlashAsterisk) {
                            txt = delimit(txt, '/');
                          }
                          return getNext(txt, yytext());
            }
          case 139: break;
          case 68: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4);
            { return getNext();
            }
          case 140: break;
          case 69: 
            // lookahead expression with fixed base length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);
            { return getNext();
            }
          case 141: break;
          case 70: 
            { String txt = yytext();
                          if (normalizeSpace) {
                            txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                          }
                          if (normalizeParentheses) {
                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                          }
                          if (DEBUG) { logger.info(""Used {PHONE} to recognize "" + yytext() + "" as "" + txt); }
                          return getNext(txt, yytext());
            }
          case 142: break;
          case 71: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 23;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 25;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */
                                    return handleEllipsis(yytext());
            }
          case 143: break;
          case 72: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 23;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 24;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */
                                    return handleEllipsis(yytext());
            }
          case 144: break;
          default:
            zzScanError(ZZ_NO_MATCH);
        }
      }
    }
  }
"	@return the next token	@return the next token	0	1	19	1045	7160
protected UserInformationResponse handleUserInfoResponse(OIDCConfiguration oidcContextConfiguration, String accessToken) throws UserInfoException { UserInformationResponse userInfoResponse; userInfoResponse = oidcAgent.getUserInfo(oidcContextConfiguration, accessToken); return userInfoResponse; }	"protected UserInfoResponse handleUserInfoResponse(OIDCConfiguration oidcContextConfiguration, String accessToken) throws UserInfoException {
    UserInfoResponse userInfoResponse;
    userInfoResponse = oidcAgent.getUserInfo(oidcContextConfiguration, accessToken);
    return userInfoResponse;
}"	@return The {@link UserInformationResponse} object.	@return the user info response object	1	0	6	5	29
"public Mono<Client> call123testSpecialTags(Client body) throws RestClientException { Object postBody = body; // verify the required parameter 'body' is set if (body == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'body' when calling call123testSpecialTags""); } String path = UriComponentsBuilder.fromPath(""/another-fake/dummy"").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { ""application/json"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { ""application/json"" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {}; return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType); }"	"    public Mono<Client> call123testSpecialTags(Client body) throws RestClientException {
        Object postBody = body;
        
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'body' when calling call123testSpecialTags"");
        }
        
        String path = UriComponentsBuilder.fromPath(""/another-fake/dummy"").build().toUriString();
        
        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();
        final HttpHeaders headerParams = new HttpHeaders();
        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();

        final String[] accepts = { 
            ""application/json""
        };
        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);
        final String[] contentTypes = { 
            ""application/json""
        };
        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);

        String[] authNames = new String[] {  };

        ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {};
        return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);
    }
"	@return Client	@return Client	0	1	8	30	221
public static Treepath getPreviousSibling(Treepath treepath) throws IllegalArgumentException { if (treepath.getHeight() < NUM) { throw new IllegalArgumentException(STR); } final Tree treeToMove = treepath.getBottom(); final Tree parent = treepath.getTreeAtHeight(NUM); for (int i = parent.getChildCount() - NUM; i > NUM; i--) { final Tree child = parent.getChildAt(i); if (child == treeToMove) { return Treepath.create(treepath.getParent(), parent.getChildAt(i - NUM)); } } throw new IllegalArgumentException(STR); }	"public static Treepath getPreviousSibling(Treepath treepath) {
    if (treepath.getHeight() < NUM) {
        throw new IllegalArgumentException(STR);
    }
    final Tree treeToMove = treepath.getBottom();
    final Tree parent = treepath.getTreeAtHeight(NUM);
    for (int i = parent.getChildCount() - NUM; i > NUM; i--) {
        final Tree child = parent.getChildAt(i);
        if (child == treeToMove) {
            return Treepath.create(treepath.getParent(), parent.getChildAt(i - NUM));
        }
    }
    return null;
}"	@return non-null object.	@return non-null if sibling was found, null otherwise.	1	0	11	14	107
public static MatchFinder anyOf(final MatchFinder... finders) { return new MatchFinder() { @Override public boolean matches(UiElement element) { for (MatchFinder finder : finders) { if (finder.matches(element)) { return true; } } return false; } @Override public String toString() { return STR + Joiner.on(STR).join(finders) + STR; } }; }	"public static ElementMatcher anyOf(final ElementMatcher... matchers) {
    return new ElementMatcher() {

        @Override
        public boolean matches(UiElement element) {
            for (ElementMatcher matcher : matchers) {
                if (matcher.matches(element)) {
                    return true;
                }
            }
            return false;
        }

        @Override
        public String toString() {
            return STR + Joiner.on(STR).join(matchers) + STR;
        }
    };
}"	@return a finder that is the logical disjunction of given finders	@return a matcher that is the logical disjunction of given matchers	1	0	11	19	79
"public Collection<Tree> getRelatedNodes(Tree t, Tree root) { if (root.value() == null) { root.setValue(""ROOT""); // todo: cdm: it doesn't seem like this line should be here } Set<Tree> nodeList = new LinkedHashSet<Tree>(); for (TregexPattern p : targetPatterns) { // cdm: I deleted: && nodeList.isEmpty() TregexMatcher m = p.matcher(root); while (m.findAt(t)) { nodeList.add(m.getNode(""target"")); if (DEBUG) { System.err.println(""found "" + this + ""("" + t + "", "" + m.getNode(""target"") + "") using pattern "" + p); for (String nodeName : m.getNodeNames()) { if (nodeName.equals(""target"")) continue; System.err.println("" node "" + nodeName + "": "" + m.getNode(nodeName)); } } } } return nodeList; }"	"  public Collection<TreeGraphNode> getRelatedNodes(TreeGraphNode t, TreeGraphNode root, HeadFinder headFinder) {
    Set<TreeGraphNode> nodeList = new ArraySet<>();
    for (TregexPattern p : targetPatterns) {    // cdm: I deleted: && nodeList.isEmpty()
      // Initialize the TregexMatcher with the HeadFinder so that we
      // can use the same HeadFinder through the entire process of
      // building the dependencies
      TregexMatcher m = p.matcher(root, headFinder);
      while (m.findAt(t)) {
        TreeGraphNode target = (TreeGraphNode) m.getNode(""target"");
        if (target == null) {
          throw new AssertionError(""Expression has no target: "" + p);
        }
        nodeList.add(target);
        if (DEBUG) {
          System.err.println(""found "" + this + ""("" + t + ""-"" + t.headWordNode() + "", "" + m.getNode(""target"") + ""-"" + ((TreeGraphNode) m.getNode(""target"")).headWordNode() + "") using pattern "" + p);
          for (String nodeName : m.getNodeNames()) {
            if (nodeName.equals(""target""))
              continue;
            System.err.println(""  node "" + nodeName + "": "" + m.getNode(nodeName));
          }
        }
      }
    }
    return nodeList;
  }
"	@return Governor nodes to which t bears this GR	@return A Collection of dependent nodes to which t bears this GR	1	0	18	22	200
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; // set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { String str = yytext(); int first = str.codePointAt(0); String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } logger.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: logger.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 67: break; case 2: { return getNext(""<"", yytext()); } case 68: break; case 3: { return getNext(); } case 69: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 70: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 71: break; case 6: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 72: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 73: break; case 8: { return handleQuotes(yytext(), false); } case 74: break; case 9: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 75: break; case 10: { return getNext("">"", yytext()); } case 76: break; case 11: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 77: break; case 12: { return getNext(removeFromNumber(yytext()), yytext()); } case 78: break; case 13: { return handleEllipsis(yytext()); } case 79: break; case 14: { return normalizeFractions(yytext()); } case 80: break; case 15: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(minimallyNormalizeCurrency(yytext()), yytext()); } } case 81: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 82: break; case 17: { if (normalizeOtherBrackets) { return getNext(""-RSB-"", yytext()); } else { return getNext(); } } case 83: break; case 18: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 84: break; case 19: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 85: break; case 20: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 86: break; case 21: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 87: break; case 22: { if (normalizeOtherBrackets) { return getNext(""-LSB-"", yytext()); } else { return getNext(); } } case 88: break; case 23: { if (invertible) { prevWordAfter.append(yytext()); } } case 89: break; case 24: { return getNext(""\u2022"", yytext()); } case 90: break; case 25: { return getNext(""\u2122"", yytext()); } case 91: break; case 26: // general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 92: break; case 27: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(); } case 93: break; case 28: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return handleQuotes(yytext(), true); } case 94: break; case 29: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 95: break; case 30: { breakByHyphens(yytext()); return getNext(removeSoftHyphens(yytext()), yytext()); } case 96: break; case 31: // general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 97: break; case 32: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 98: break; case 33: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 99: break; case 34: { // this one should only match if we're basically at the end of file // since the last one matches two things, even newlines (if not tokenize per line) String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 100: break; case 35: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 101: break; case 36: // lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 1); { /* invert quote - often but not always right */ return handleQuotes(yytext(), true); } case 102: break; case 37: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return handleQuotes(yytext(), false); } case 103: break; case 38: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 104: break; case 39: { String txt = yytext(); // if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space... if (strictTreebank3) { int spaceIndex = indexOfSpace(txt); if (spaceIndex >= 0) { yypushback(txt.length() - spaceIndex); String newText = yytext(); return getNext(newText, newText); } } if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, txt); } case 105: break; case 40: { return getNormalizedAmpNext(); } case 106: break; case 41: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, origTxt); } case 107: break; case 42: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space } return getNext(txt, origTxt); } case 108: break; case 43: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 109: break; case 44: { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 110: break; case 45: // general lookahead, find correct zzMarkedPos { int zzFState = 17; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 111: break; case 46: // lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 112: break; case 47: // general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 113: break; case 48: // general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 22; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 114: break; case 49: // general lookahead, find correct zzMarkedPos { int zzFState = 18; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 19; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 115: break; case 50: // general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 116: break; case 51: // general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 21; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 117: break; case 52: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 118: break; case 53: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { breakByHyphens(yytext()); return getNext(removeSoftHyphens(yytext()), yytext()); } case 119: break; case 54: { if (splitAssimilations) { yypushback(3) ; return getNext(); } else { return getNext(); } } case 120: break; case 55: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNormalizedAmpNext(); } case 121: break; case 56: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 9; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 122: break; case 57: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { return getNext(); } case 123: break; case 58: // general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 124: break; case 59: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 125: break; case 60: // general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 13; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 126: break; case 61: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } return getNext(txt, yytext()); } case 127: break; case 62: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4); { return getNext(); } case 128: break; case 63: // lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { return getNext(); } case 129: break; case 64: { String txt = yytext(); if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 130: break; case 65: // general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 25; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 131: break; case 66: // general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 24; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 132: break; default: zzScanError(ZZ_NO_MATCH); } } } }"	"  public Object next() throws java.io.IOException {
    int zzInput;
    int zzAction;

    // cached fields:
    int zzCurrentPosL;
    int zzMarkedPosL;
    int zzEndReadL = zzEndRead;
    char [] zzBufferL = zzBuffer;
    char [] zzCMapL = ZZ_CMAP;

    int [] zzTransL = ZZ_TRANS;
    int [] zzRowMapL = ZZ_ROWMAP;
    int [] zzAttrL = ZZ_ATTRIBUTE;

    while (true) {
      zzMarkedPosL = zzMarkedPos;

      yychar+= zzMarkedPosL-zzStartRead;

      zzAction = -1;

      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
  
      zzState = ZZ_LEXSTATE[zzLexicalState];

      // set up zzAction for empty match case:
      int zzAttributes = zzAttrL[zzState];
      if ( (zzAttributes & 1) == 1 ) {
        zzAction = zzState;
      }


      zzForAction: {
        while (true) {
    
          if (zzCurrentPosL < zzEndReadL) {
            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);
            zzCurrentPosL += Character.charCount(zzInput);
          }
          else if (zzAtEOF) {
            zzInput = YYEOF;
            break zzForAction;
          }
          else {
            // store back cached positions
            zzCurrentPos  = zzCurrentPosL;
            zzMarkedPos   = zzMarkedPosL;
            boolean eof = zzRefill();
            // get translated positions and possibly new buffer
            zzCurrentPosL  = zzCurrentPos;
            zzMarkedPosL   = zzMarkedPos;
            zzBufferL      = zzBuffer;
            zzEndReadL     = zzEndRead;
            if (eof) {
              zzInput = YYEOF;
              break zzForAction;
            }
            else {
              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);
              zzCurrentPosL += Character.charCount(zzInput);
            }
          }
          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
          if (zzNext == -1) break zzForAction;
          zzState = zzNext;

          zzAttributes = zzAttrL[zzState];
          if ( (zzAttributes & 1) == 1 ) {
            zzAction = zzState;
            zzMarkedPosL = zzCurrentPosL;
            if ( (zzAttributes & 8) == 8 ) break zzForAction;
          }

        }
      }

      // store back cached position
      zzMarkedPos = zzMarkedPosL;

      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
        zzAtEOF = true;
              {
                if (invertible) {
            prevWordAfter.append(yytext());
            String str = prevWordAfter.toString();
            prevWordAfter.setLength(0);
            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);
          }
          return null;
              }
      }
      else {
        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
          case 1: 
            { String str = yytext();
          int first = str.codePointAt(0);
          String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));
          switch (untokenizable) {
            case NONE_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              break;
            case FIRST_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              if ( ! this.seenUntokenizableCharacter) {
                logger.warning(msg);
                this.seenUntokenizableCharacter = true;
              }
              break;
            case ALL_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              logger.warning(msg);
              this.seenUntokenizableCharacter = true;
              break;
            case NONE_KEEP:
              return getNext();
            case FIRST_KEEP:
              if ( ! this.seenUntokenizableCharacter) {
                logger.warning(msg);
                this.seenUntokenizableCharacter = true;
              }
              return getNext();
            case ALL_KEEP:
              logger.warning(msg);
              this.seenUntokenizableCharacter = true;
              return getNext();
          }
            }
          case 67: break;
          case 2: 
            { return getNext(""<"", yytext());
            }
          case 68: break;
          case 3: 
            { return getNext();
            }
          case 69: break;
          case 4: 
            { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {
                    return getNext(ptbmdash, yytext());
                  } else {
                    return getNext();
                  }
            }
          case 70: break;
          case 5: 
            { if (tokenizeNLs) {
                      return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns
                  } else if (invertible) {
                      prevWordAfter.append(yytext());
                  }
            }
          case 71: break;
          case 6: 
            { final String origTxt = yytext();
                          String tmp = removeSoftHyphens(origTxt);
                          if (americanize) {
                            tmp = Americanize.americanize(tmp);
                          }
                          return getNext(tmp, origTxt);
            }
          case 72: break;
          case 7: 
            { if (invertible) {
                     prevWordAfter.append(yytext());
                  }
            }
          case 73: break;
          case 8: 
            { return handleQuotes(yytext(), false);
            }
          case 74: break;
          case 9: 
            { if (escapeForwardSlashAsterisk) {
                    return getNext(delimit(yytext(), '/'), yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 75: break;
          case 10: 
            { return getNext("">"", yytext());
            }
          case 76: break;
          case 11: 
            { if (ptb3Dashes) {
                            return getNext(ptbmdash, yytext()); }
                          else {
                            return getNext();
                          }
            }
          case 77: break;
          case 12: 
            { return getNext(removeSoftHyphens(yytext()),
                                         yytext());
            }
          case 78: break;
          case 13: 
            { return handleEllipsis(yytext());
            }
          case 79: break;
          case 14: 
            { return normalizeFractions(yytext());
            }
          case 80: break;
          case 15: 
            { if (normalizeCurrency) {
                            return getNext(normalizeCurrency(yytext()), yytext());
			  } else {
                            return getNext(minimallyNormalizeCurrency(yytext()), yytext());
                          }
            }
          case 81: break;
          case 16: 
            { if (normalizeOtherBrackets) {
                    return getNext(closebrace, yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 82: break;
          case 17: 
            { if (normalizeOtherBrackets) {
                    return getNext(""-RSB-"", yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 83: break;
          case 18: 
            { if (normalizeParentheses) {
                    return getNext(openparen, yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 84: break;
          case 19: 
            { if (normalizeParentheses) {
                    return getNext(closeparen, yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 85: break;
          case 20: 
            { if (escapeForwardSlashAsterisk) {
                    return getNext(delimit(yytext(), '*'), yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 86: break;
          case 21: 
            { if (normalizeOtherBrackets) {
                    return getNext(openbrace, yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 87: break;
          case 22: 
            { if (normalizeOtherBrackets) {
                    return getNext(""-LSB-"", yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 88: break;
          case 23: 
            { if (invertible) {
                            prevWordAfter.append(yytext());
                        }
            }
          case 89: break;
          case 24: 
            { return getNext(""\u2022"", yytext());
            }
          case 90: break;
          case 25: 
            { return getNext(""\u2122"", yytext());
            }
          case 91: break;
          case 26: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 15;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 16;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return getNext();
            }
          case 92: break;
          case 27: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { return getNext();
            }
          case 93: break;
          case 28: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { return handleQuotes(yytext(), true);
            }
          case 94: break;
          case 29: 
            { String txt = yytext();
                  String origText = txt;
                  if (normalizeParentheses) {
                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                  }
                  return getNext(txt, origText);
            }
          case 95: break;
          case 30: 
            { breakByHyphens(yytext());
                    return getNext(removeSoftHyphens(yytext()), yytext());
            }
          case 96: break;
          case 31: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 3;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 4;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { final String origTxt = yytext();
                          String tmp = removeSoftHyphens(origTxt);
                          if (americanize) {
                            tmp = Americanize.americanize(tmp);
                          }
                          return getNext(tmp, origTxt);
            }
          case 97: break;
          case 32: 
            { if (escapeForwardSlashAsterisk) {
                            return getNext(delimit(yytext(), '/'), yytext());
                          } else {
                            return getNext();
                          }
            }
          case 98: break;
          case 33: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { return getNext(removeSoftHyphens(yytext()), yytext());
            }
          case 99: break;
          case 34: 
            { // this one should only match if we're basically at the end of file
                          // since the last one matches two things, even newlines (if not tokenize per line)
                          String s;
                          if (strictTreebank3 && ! ""U.S."".equals(yytext())) {
                            yypushback(1); // return a period for next time
                            s = yytext();
                          } else {
                            s = yytext();
                            yypushback(1); // return a period for next time
                          }
                          return getNext(s, yytext());
            }
          case 100: break;
          case 35: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { String txt = yytext();
                  String origText = txt;
                  if (normalizeParentheses) {
                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                  }
                  return getNext(txt, origText);
            }
          case 101: break;
          case 36: 
            // lookahead expression with fixed base length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 1);
            { /* invert quote - often but not always right */
                  return handleQuotes(yytext(), true);
            }
          case 102: break;
          case 37: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { return handleQuotes(yytext(), false);
            }
          case 103: break;
          case 38: 
            { return getNext(removeSoftHyphens(yytext()), yytext());
            }
          case 104: break;
          case 39: 
            { String txt = yytext();
                  // if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space...
                  if (strictTreebank3) {
                    int spaceIndex = indexOfSpace(txt);
                    if (spaceIndex >= 0) {
                      yypushback(txt.length() - spaceIndex);
                      String newText = yytext();
                      return getNext(newText, newText);
                    }
                  }
                  if (escapeForwardSlashAsterisk) {
                    txt = delimit(txt, '/');
                  }
                  if (normalizeSpace) {
                    txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                  }
                  return getNext(txt, txt);
            }
          case 105: break;
          case 40: 
            { return getNormalizedAmpNext();
            }
          case 106: break;
          case 41: 
            { final String origTxt = yytext();
                          String txt = origTxt;
                          if (normalizeSpace) {
                            txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                          }
                          return getNext(txt, origTxt);
            }
          case 107: break;
          case 42: 
            { final String origTxt = yytext();
                          String txt = origTxt;
                          if (normalizeSpace) {
                            txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                          }
                          return getNext(txt, origTxt);
            }
          case 108: break;
          case 43: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 5;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 6;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { final String txt = yytext();
                          return getNext(removeSoftHyphens(txt),
                                         txt);
            }
          case 109: break;
          case 44: 
            { if (splitAssimilations) {
                            yypushback(2) ; return getNext();
                          } else {
                            return getNext();
                          }
            }
          case 110: break;
          case 45: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 17;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 16;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return getNext();
            }
          case 111: break;
          case 46: 
            // lookahead expression with fixed base length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);
            { if (splitAssimilations) {
                            yypushback(2) ; return getNext();
                          } else {
                            return getNext();
                          }
            }
          case 112: break;
          case 47: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 10;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 11;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return processAbbrev3();
            }
          case 113: break;
          case 48: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 20;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 22;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */
                                    return handleEllipsis(yytext());
            }
          case 114: break;
          case 49: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 18;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 19;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return getNext();
            }
          case 115: break;
          case 50: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 10;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 11;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return processAbbrev3();
            }
          case 116: break;
          case 51: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 20;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 21;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */
                                    return handleEllipsis(yytext());
            }
          case 117: break;
          case 52: 
            { String txt = yytext();
                          if (escapeForwardSlashAsterisk) {
                            txt = delimit(txt, '/');
                            txt = delimit(txt, '*');
                          }
                          return getNext(txt, yytext());
            }
          case 118: break;
          case 53: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { breakByHyphens(yytext());
                    return getNext(removeSoftHyphens(yytext()), yytext());
            }
          case 119: break;
          case 54: 
            { if (splitAssimilations) {
                            yypushback(3) ; return getNext();
                          } else {
                            return getNext();
                          }
            }
          case 120: break;
          case 55: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { return getNormalizedAmpNext();
            }
          case 121: break;
          case 56: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 7;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 9;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return processAcronym();
            }
          case 122: break;
          case 57: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);
            { return getNext();
            }
          case 123: break;
          case 58: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 12;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 14;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return processAbbrev1();
            }
          case 124: break;
          case 59: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 7;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 8;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return processAcronym();
            }
          case 125: break;
          case 60: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 12;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 13;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return processAbbrev1();
            }
          case 126: break;
          case 61: 
            { String txt = yytext();
                          if (escapeForwardSlashAsterisk) {
                            txt = delimit(txt, '/');
                          }
                          return getNext(txt, yytext());
            }
          case 127: break;
          case 62: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4);
            { return getNext();
            }
          case 128: break;
          case 63: 
            // lookahead expression with fixed base length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);
            { return getNext();
            }
          case 129: break;
          case 64: 
            { String txt = yytext();
                          if (normalizeSpace) {
                            txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                          }
                          if (normalizeParentheses) {
                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                          }
                          return getNext(txt, yytext());
            }
          case 130: break;
          case 65: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 23;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 25;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */
                                    return handleEllipsis(yytext());
            }
          case 131: break;
          case 66: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 23;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 24;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */
                                    return handleEllipsis(yytext());
            }
          case 132: break;
          default:
            zzScanError(ZZ_NO_MATCH);
        }
      }
    }
  }
"	@return the next token	@return the next token	0	1	19	965	6267
public ArrayList<ScrollView> getCurrentScrollViews() { return getCurrentViews(ScrollView.class); }	"	public ArrayList<ScrollView> getCurrentScrollViews() {
		ArrayList<ScrollView> scrollViews = new ArrayList<ScrollView>();
		ArrayList<View> viewList = getViews();
		for(View view : viewList){
			if (view instanceof android.widget.ScrollView)
				scrollViews.add((ScrollView) view);
		}
		return scrollViews;
	}
"	@return a  List of the  ScrollViews contained in the current  Activity	@return a List of the ScrollViews contained in the current Activity	0	1	6	4	15
public String getName() { return StringUtils.removeEnd(path.getFileName().toString(), VAULT_FILE_EXTENSION); }	"public String getName() {
    String name = path.getFileName().toString();
    if (StringUtils.endsWithIgnoreCase(name, Aes256Cryptor.FOLDER_EXTENSION)) {
        name = name.substring(NUM, name.length() - Aes256Cryptor.FOLDER_EXTENSION.length());
    }
    return name;
}"	@return Directory name without preceeding path components and file extension	@return Directory name without preceeding path components	1	0	6	3	22
public int _offsetToX(int line, int offset) { return super._offsetToX(line, offset) + LEFT_GUTTER; }	"  public int _offsetToX(int line, int offset) {
    return super._offsetToX(line, offset) + getGutterWidth();
  }
"	@return the horizontal position	@return the horizontal position	0	1	6	4	23
private boolean validate(RexNode first, RexNode second) { return first instanceof RexCall && second instanceof RexCall; }	"  private boolean validate(RexNode first, RexNode second) {
    if (first == null || second == null) {
      return false;
    }
    if (!(first instanceof RexCall)
        || !(second instanceof RexCall)) {
      return false;
    }
    return true;
  }
"	@return whether input usage pattern is supported	@return true, if input usage pattern is supported. Otherwise, false.	1	0	6	4	22
public ProjectItem getChild(String text) { String[] childPath = new String[path.length + NUM]; System.arraycopy(path, NUM, childPath, NUM, path.length); childPath[childPath.length - NUM] = text; return project.getProjectItem(childPath); }	"public ProjectItem getChild(String text) {
    String[] childPath = new String[path.length + NUM];
    System.arraycopy(path, NUM, childPath, NUM, path.length);
    childPath[childPath.length - NUM] = text;
    return new ProjectItem(treeViewerHandler.getTreeItem(treeItem, text), project, childPath);
}"	@return project item with the specified <var>text</var>	@return project item with specified text without decorators	1	0	8	6	53
"protected Object convertPoint(Column column, Field fieldDefn, Object data) { return convertValue(column, fieldDefn, data, (Supplier<?>)() -> Point.createValue(fieldDefn.schema(), 0, 0), (r) -> { final Schema schema = fieldDefn.schema(); if (data instanceof PGpoint) { PGpoint pgPoint = (PGpoint) data; r.deliver(Point.createValue(schema, pgPoint.x, pgPoint.y)); } else if (data instanceof String) { String dataString = data.toString(); try { PGpoint pgPoint = new PGpoint(dataString); r.deliver(Point.createValue(schema, pgPoint.x, pgPoint.y)); } catch (SQLException e) { logger.warn(""Error converting the string '{}' to a PGPoint type for the column '{}'"", dataString, column); } } else if (data instanceof PgProto.Point) { r.deliver(Point.createValue(schema, ((PgProto.Point) data).getX(), ((PgProto.Point) data).getY())); } }); }"	"    protected Object convertPoint(Column column, Field fieldDefn, Object data) {
        return convertValue(column, fieldDefn, (Supplier<?>)() -> handleUnknownData(column, fieldDefn, data), Collections.emptyList(), (r) -> {
            final Schema schema = fieldDefn.schema();
            if (data instanceof PGpoint) {
                PGpoint pgPoint = (PGpoint) data;
                r.deliver(Point.createValue(schema, pgPoint.x, pgPoint.y));
            }
            else if (data instanceof String) {
                String dataString = data.toString();
                try {
                    PGpoint pgPoint = new PGpoint(dataString);
                    r.deliver(Point.createValue(schema, pgPoint.x, pgPoint.y));
                } catch (SQLException e) {
                    logger.warn(""Error converting the string '{}' to a PGPoint type for the column '{}'"", dataString, column);
                }
            }
            else if (data instanceof PgProto.Point) {
                r.deliver(Point.createValue(schema, ((PgProto.Point) data).getX(), ((PgProto.Point) data).getY()));
            }
        });
    }
"	@return a value which will be used by Connect to represent the actual point value	@return a value which will be used by Connect to represent the actual point value	0	1	15	22	213
"public String[] getDropSchemaCommand(String schemaName) { return new String[] {""drop schema "" + schemaName}; }"	"	public String getDropSchemaCommand(String schemaName) {
		return ""drop schema "" + schemaName;
	}
"	@return The drop commands	@return The drop command	1	0	7	4	25
public static Hours parseHours(String periodStr) { throw ExceptionUtils.unsupportedInGwt(); // if (periodStr == null) { // return Hours.ZERO; // } // Period p = PARSER.parsePeriod(periodStr); // return Hours.hours(p.getHours()); }	"    public static Hours parseHours(String periodStr) {
        if (periodStr == null) {
            return Hours.ZERO;
        }
        Period p = PARSER.parsePeriod(periodStr);
        return Hours.hours(p.getHours());
    }
"	@return the period in hours	@return the period in hours	0	1	4	9	55
public boolean wasFailed(Artifact configurationId) { for (Iterator it = failed.keySet().iterator(); it.hasNext(); ) { Artifact failID = (Artifact) it.next(); if (configurationId.matches(failID)) { return true; } } return false; }	"public boolean wasFailed(Artifact configurationId) {
    return failed.containsKey(configurationId);
}"	@return true if the specified (or any matching) configuration failed the operation and threw an exception during the lifecycle operation	@return true if the specified configuration failed the operation and threw an exception during the lifecycle operation	1	0	8	9	55
public Table removeTable(TableId tableId) { return lock.write(() -> { changes.add(tableId); return tablesByTableId.remove(tableId); }); }	"    public Table removeTable(TableId tableId) {
        return lock.write(() -> tablesByTableId.remove(tableId));
    }
"	@return the existing table definition that was removed, or null if there was no prior table definition	@return the existing table definition that was removed, or null if there was no prior table definition	0	1	8	7	33
public Collection<TypedDependency> typedDependenciesCollapsed() { return typedDependenciesCollapsed(Extras.NONE); }	"  public Collection<TypedDependency> typedDependenciesCollapsed() {
    return typedDependenciesCollapsed(false);
  }
"	@return A set of collapsed dependencies	@return A set of collapsed dependencies	0	1	5	4	15
@Override public ActivityOptions getActivityLaunchOptions(Launcher launcher, View v) { if (hasControlRemoteAppTransitionPermission()) { try { RemoteAnimationRunnerCompat runner = new LauncherAnimationRunner(mLauncher) { @Override public void onAnimationStart(RemoteAnimationTargetCompat[] targets, Runnable finishedCallback) { postAtFrontOfQueueAsynchronously(v.getHandler(), () -> { final boolean removeTrackingView; LauncherTransitionAnimator animator = composeRecentsLaunchAnimator(v, targets); if (animator != null) { removeTrackingView = false; } else { animator = composeAppLaunchAnimator(v, targets); removeTrackingView = true; } setCurrentAnimator(animator); mAnimator = animator.getAnimatorSet(); mAnimator.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { v.setVisibility(View.VISIBLE); if (removeTrackingView) { ((ViewGroup) mDragLayer.getParent()).removeView(mFloatingView); } mDragLayer.setAlpha(NUM); mDragLayer.setTranslationY(NUM); View appsView = mLauncher.getAppsView(); appsView.setAlpha(NUM); appsView.setTranslationY(NUM); finishedCallback.run(); } }); mAnimator.start(); mAnimator.setCurrentPlayTime(REFRESH_RATE_MS); }); } }; return ActivityOptionsCompat.makeRemoteAnimation(new RemoteAnimationAdapterCompat(runner, NUM, NUM)); } catch (NoClassDefFoundError e) { } } return getDefaultActivityLaunchOptions(launcher, v); }	"@Override
public Bundle getActivityLaunchOptions(Launcher launcher, View v) {
    if (hasControlRemoteAppTransitionPermission()) {
        try {
            RemoteAnimationRunnerCompat runner = new LauncherAnimationRunner(mLauncher) {

                @Override
                public void onAnimationStart(RemoteAnimationTargetCompat[] targets, Runnable finishedCallback) {
                    postAtFrontOfQueueAsynchronously(v.getHandler(), () -> {
                        final boolean removeTrackingView;
                        LauncherTransitionAnimator animator = composeRecentsLaunchAnimator(v, targets);
                        if (animator != null) {
                            removeTrackingView = false;
                        } else {
                            animator = composeAppLaunchAnimator(v, targets);
                            removeTrackingView = true;
                        }
                        setCurrentAnimator(animator);
                        mAnimator = animator.getAnimatorSet();
                        mAnimator.addListener(new AnimatorListenerAdapter() {

                            @Override
                            public void onAnimationEnd(Animator animation) {
                                v.setVisibility(View.VISIBLE);
                                if (removeTrackingView) {
                                    ((ViewGroup) mDragLayer.getParent()).removeView(mFloatingView);
                                }
                                mDragLayer.setAlpha(NUM);
                                mDragLayer.setTranslationY(NUM);
                                View appsView = mLauncher.getAppsView();
                                appsView.setAlpha(NUM);
                                appsView.setTranslationY(NUM);
                                finishedCallback.run();
                            }
                        });
                        mAnimator.start();
                        mAnimator.setCurrentPlayTime(REFRESH_RATE_MS);
                    });
                }
            };
            return ActivityOptionsCompat.makeRemoteAnimation(new RemoteAnimationAdapterCompat(runner, NUM, NUM)).toBundle();
        } catch (NoClassDefFoundError e) {
        }
    }
    return getDefaultActivityLaunchOptions(launcher, v);
}"	@return ActivityOptions with remote animations that controls how the window of the opening targets are displayed.	@return A Bundle with remote animations that controls how the window of the opening targets are displayed.	1	0	21	46	240
"public static ExternalSessionKey fromJsonResponseBody(String responseBody) { try { JsonObject json = new JsonParser().parse(responseBody).getAsJsonObject(); if (json.has(""sessionId"") && !json.get(""sessionId"").isJsonNull()) { return new ExternalSessionKey(json.get(""sessionId"").getAsString()); } // W3C response if (json.has(""value"") && json.get(""value"").isJsonObject()) { JsonObject value = json.getAsJsonObject(""value""); if (value.has(""sessionId"") && !value.get(""sessionId"").isJsonNull()) { return new ExternalSessionKey(value.get(""sessionId"").getAsString()); } } } catch (JsonSyntaxException e) { return null; } return null; }"	"  public static ExternalSessionKey fromJsonResponseBody(String responseBody) {
    try {
      JsonObject json = new JsonParser().parse(responseBody).getAsJsonObject();
      if (json.has(""sessionId"") && !json.get(""sessionId"").isJsonNull()) {
        return new ExternalSessionKey(json.get(""sessionId"").getAsString());
      }

      // W3C response
      if (json.has(""value"") && json.get(""value"").isJsonObject()) {
        JsonObject value = json.getAsJsonObject(""value"");
        if (value.has(""sessionId"") && !value.get(""sessionId"").isJsonNull()) {
          return new ExternalSessionKey(json.get(""sessionId"").getAsString());
        }
      }
    } catch (JsonSyntaxException e) {
      return null;
    }

    return null;
  }
"	@return the extracted ExternalKey, or null if one was not found.	@return the extracted ExternalKey, or null if one was not found.	0	1	11	21	160
public int getStack(int k) { int nStack = getStackSize(); return (k >= 0 && k < nStack) ? stack.get(nStack - 1 - k) : Config.NONEXIST; }	"  public int getStack(int k) {
    int nStack = getStackSize();
    return (k >= 0 && k < nStack) ? stack.get(nStack - 1 - k) : CONST.NONEXIST;
  }
"	@return Sentence index or  Config#NONEXIST if stack doesn't have an element at this index	@return Sentence index or CONST#NONEXIST if stack doesn't have an element at this index	1	0	8	5	38
public Observable<Connectivity> observeNetworkConnectivity(final Context context) { final IntentFilter filter = new IntentFilter(); filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION); return Observable.create(new Observable.OnSubscribe<Connectivity>() { @Override public void call(final Subscriber<? super Connectivity> subscriber) { final BroadcastReceiver receiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { subscriber.onNext(Connectivity.create(context)); } }; context.registerReceiver(receiver, filter); subscriber.add(unsubscribeInUiThread(new Action0() { @Override public void call() { context.unregisterReceiver(receiver); } })); } }).defaultIfEmpty(Connectivity.create()); }	"public Observable<ConnectivityStatus> observeNetworkConnectivity(final Context context) {
    final IntentFilter filter = new IntentFilter();
    filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
    return Observable.create(new Observable.OnSubscribe<ConnectivityStatus>() {

        @Override
        public void call(final Subscriber<? super ConnectivityStatus> subscriber) {
            final BroadcastReceiver receiver = new BroadcastReceiver() {

                @Override
                public void onReceive(Context context, Intent intent) {
                    final ConnectivityStatus newStatus = getConnectivityStatus(context);
                    if (newStatus != status) {
                        status = newStatus;
                        subscriber.onNext(newStatus);
                    }
                }
            };
            context.registerReceiver(receiver, filter);
            subscriber.add(unsubscribeInUiThread(new Action0() {

                @Override
                public void call() {
                    context.unregisterReceiver(receiver);
                }
            }));
        }
    }).defaultIfEmpty(ConnectivityStatus.OFFLINE);
}"	@return RxJava Observable with Connectivity class containing information about network state, type and name	@return RxJava Observable with ConnectivityStatus	1	0	14	25	133
private Object convertToDuration(Column column, String value) { return Duration.between(LocalTime.MIN, LocalTime.from(timeFormat(column.length()).parse(value))); }	"    private Object convertToDuration(Column column, String value) {
        String timeFormat = timeFormat(column.length());
        return Duration.between(LocalTime.MIN, LocalTime.from(DateTimeFormatter.ofPattern(timeFormat).parse(value)));
    }
"	@return the converted value;	@return the converted value;	0	1	8	4	36
public String toString() { if (connString == null) { String wrappedString; try { wrappedString = getRealConnection().toString(); } catch (SQLException e) { wrappedString = STR; } connString = this.getClass().getName() + STR + this.hashCode() + STR + wrappedString; } return connString; }	"public String toString() {
    try {
        return getRealConnection().toString();
    } catch (SQLException e) {
        return STR;
    }
}"	@return unique string representation for this connection	@return unique string representation of the underlying physical connection	1	0	12	12	61
public QueryBuilder newSubQueryBuilder(String entityName, String alias) { return new QueryBuilder( entityName, alias, aliasCounter, paramCounter, sessionFactory ); }	"	public QueryBuilder newSubQueryBuilder(String entityName, String alias) {
		return new QueryBuilder( entityName, alias, aliasCounter, paramCounter );
	}
"	@return A sub-query builder for the given entity, with the given alias. The sub-query can be later used as a value of a parameter.	@return A sub-query builder for the given entity, with the given alias. The sub-query can be later used as a value of a parameter.	0	1	5	4	27
@Processor @OAuthProtected @OAuthInvalidateAccessTokenOn(exception = OAuthTokenExpiredException.class) @Paged public PagingDelegate<CommentReply> listCommentReplies(final String fileId, final String commentId, @Optional @Default(STR) final boolean includeDeleted, @Optional @Default(STR) final int maxResults, final PagingConfiguration pagingConfiguration) throws IOException { return new TokenBasedPagingDelegate<CommentReply>() { @Override protected List<CommentReply> doGetPage() throws IOException { CommentReplyList response = client.replies().list(fileId, commentId).setIncludeDeleted(includeDeleted).setMaxResults(maxResults).setPageToken(this.getPageToken()).execute(); this.setPageToken(response.getNextPageToken()); return CommentReply.valueOf(response.getItems(), CommentReply.class); } }; }	"@Processor
@OAuthProtected
@OAuthInvalidateAccessTokenOn(exception = OAuthTokenExpiredException.class)
@Inject
public List<CommentReply> listCommentReplies(MuleMessage message, String fileId, String commentId, @Optional @Default(STR) boolean includeDeleted, @Optional @Default(STR) int maxResults, @Optional @Default(STR) String pageToken) throws IOException {
    CommentReplyList response = this.client.replies().list(fileId, commentId).setIncludeDeleted(includeDeleted).setMaxResults(maxResults).setPageToken(pageToken).execute();
    PaginationUtils.savePageToken(NEXT_PAGE_TOKEN, response.getNextPageToken(), message);
    return CommentReply.valueOf(response.getItems(), CommentReply.class);
}"	@return a paginated iterator with instances of {@link org.mule.module.google.drive.model.CommentReply}	@return a list with instances of {@link org.mule.module.google.drive.model.org.mule.module.google.drive.model.CommentReply}	1	0	11	15	130
private static boolean isXMLSpaceDefault(DomNode node) { for (; node instanceof DomElement; node = node.getParentNode()) { final String value = ((DomElement) node).getAttribute(STR); if (!value.isEmpty()) { if (STR.equals(value)) { return true; } return false; } } return false; }	"private static Boolean isXMLSpaceDefault(DomNode node) {
    for (; node instanceof DomElement; node = node.getParentNode()) {
        final String value = ((DomElement) node).getAttribute(STR);
        if (!value.isEmpty()) {
            if (STR.equals(value)) {
                return Boolean.TRUE;
            }
            return Boolean.FALSE;
        }
    }
    return null;
}"	"@return whether ""xml:space"" attribute is set to ""default"""	"@return {@link Boolean#TRUE} if ""default"" is set, {@link Boolean#FALSE} for other value, or null if nothing is set."	1	0	10	12	68
public Env getApolloEnv() { return EnvUtils.transformEnv(Foundation.server().getEnvType()); }	"public Env getApolloEnv() {
    Env env = EnvUtils.transformEnv(Foundation.server().getEnvType());
    if (env == null) {
        String path = isOSWindows() ? STR : STR;
        String message = String.format(STR, path);
        logger.error(message);
        throw new ApolloConfigException(message);
    }
    return env;
}"	@return the env, UNKNOWN if env is not set or invalid	@return the env	1	0	6	3	20
public TextView waitForText(String text, int expectedMinimumNumberOfMatches, long timeout, boolean scroll) { return waitForText(TextView.class, text, expectedMinimumNumberOfMatches, timeout, scroll, false, true); }	"	public TextView waitForText(String text, int expectedMinimumNumberOfMatches, long timeout)
	{
		return waitForText(text, expectedMinimumNumberOfMatches, timeout, true);
	}
"	@return  true if text is found and  false if it is not found before the timeout	@return true if text is found and false if it is not found before the timeout	0	1	6	4	37
private String checkSubElementsNullability(Type propertyType, Object value) throws HibernateException { if ( propertyType.isComponentType() ) { return checkComponentNullability( value, (CompositeType) propertyType ); } if ( propertyType.isCollectionType() ) { // persistent collections may have components final CollectionType collectionType = (CollectionType) propertyType; final Type collectionElementType = collectionType.getElementType( session.getFactory() ); if ( collectionElementType.isComponentType() ) { // check for all components values in the collection final CompositeType componentType = (CompositeType) collectionElementType; final Iterator itr = CascadingActions.getLoadedElementsIterator( session, collectionType, value ); while ( itr.hasNext() ) { final Object compositeElement = itr.next(); if ( compositeElement != null ) { return checkComponentNullability( compositeElement, componentType ); } } } } return null; }	"	private String checkSubElementsNullability(Type propertyType, Object value) throws HibernateException {
		// IMPL NOTE : we currently skip checking ""any"" and ""many to any"" mappings.  This is not the best solution.
		//
		// The problem I ran into with performing the checks on ""any"" and ""many to any"" mappings had to do  with
		// cascaded saves of transient associated entities not yet having assigned the identifier (this was
		// specifically in the ""many to any"" case).

		if ( propertyType.isAnyType() ) {
			return null;
		}

		if ( propertyType.isComponentType() ) {
			return checkComponentNullability( value, (CompositeType) propertyType );
		}

		if ( propertyType.isCollectionType() ) {
			//persistent collections may have components
			final CollectionType collectionType = (CollectionType) propertyType;
			final Type collectionElementType = collectionType.getElementType( session.getFactory() );

			if ( collectionElementType.isAnyType() ) {
				return null;
			}

			if ( collectionElementType.isComponentType() ) {
				//check for all components values in the collection
				final CompositeType componentType = (CompositeType) collectionElementType;
				final Iterator itr = CascadingActions.getLoadedElementsIterator( session, collectionType, value );
				while ( itr.hasNext() ) {
					final Object compValue = itr.next();
					if ( compValue != null ) {
						return checkComponentNullability( compValue, componentType );
					}
				}
			}
		}

		return null;
	}
"	@return property path	@return property path	0	1	13	26	146
private int executeSUCommands(String[] commands) throws EShellExecException { int ret = NUM; File rootFolder = new File(mRootOfWorkPath); File workingFolder = new File(rootFolder, TEMP_FOLDER); String workingFolderPath = workingFolder.getAbsolutePath(); if (!workingFolder.exists() && !workingFolder.mkdir()) { throw (new EShellExecException(STR)); } broadcastProgress(NUM, STR + workingFolder.getAbsolutePath()); try { Utils.extractExecutableAsset(this, ANDROID_BOOTMGR, workingFolderPath, true); Utils.extractExecutableAsset(this, ANDROID_LOOP_MOUNT, workingFolderPath, true); Utils.extractExecutableAsset(this, ARCHIVE_MASTER_ASC, workingFolderPath, false); Utils.extractExecutableAsset(this, ARCHIVE_MASTER, workingFolderPath, false); Utils.extractExecutableAsset(this, BUSYBOX, workingFolderPath, true); Utils.extractExecutableAsset(this, GPG, workingFolderPath, true); Utils.extractExecutableAsset(this, TAR, workingFolderPath, true); Utils.extractExecutableAsset(this, UPDATE_SCRIPT, workingFolderPath, true); Utils.extractExecutableAsset(this, U_REBOOT_APP_ASC, workingFolderPath, false); Utils.extractExecutableAsset(this, U_REBOOT_APP, workingFolderPath, false); Utils.extractExecutableAsset(this, UPGRADECHECKER, workingFolderPath, true); } catch (IOException e) { throw (new EShellExecException(STR)); } mWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, STR); try { Process process = Runtime.getRuntime().exec(STR, null, workingFolder); DataOutputStream os = new DataOutputStream(process.getOutputStream()); os.writeBytes(STR); os.writeBytes(STR); os.writeBytes(String.format(STR, workingFolder.getAbsolutePath())); os.writeBytes(String.format(STR, workingFolder.getAbsolutePath())); for (String cmd : commands) { Log.d(TAG, STR + cmd + STR); os.writeBytes(cmd + STR); os.writeBytes(STR); } os.writeBytes(String.format(STR, workingFolder.getAbsolutePath())); os.writeBytes(STR); os.flush(); int read = NUM; byte[] buff = new byte[NUM]; InputStream is = process.getInputStream(); InputStream es = process.getErrorStream(); boolean running = true; boolean scriptExecuted = false; do { while (is.available() > NUM) { read = is.read(buff); if (read <= NUM) { break; } scriptExecuted = true; String seg = new String(buff, NUM, read); Log.i(TAG, STR + seg); broadcastProgress(-NUM, seg); } while (es.available() > NUM) { read = es.read(buff); if (read <= NUM) { break; } scriptExecuted = true; String seg = new String(buff, NUM, read); if (seg.startsWith(STR)) { mTotalSize += PROGRESS_MKSWAP_ADJUSTMENT + PROGRESS_SWAP_CREATION_ADJUSTMENT; } else { mProgress++; if (mTotalSize > NUM && mLastSignalledProgress < (mProgress * NUM / mTotalSize)) { mLastSignalledProgress = (int) (mProgress * NUM / mTotalSize); broadcastProgress(mLastSignalledProgress, null); } } Log.i(TAG, STR + seg); } try { ret = process.exitValue(); Log.d(TAG, STR + ret); if (!scriptExecuted) { throw new EShellExecException(STR); } running = false; } catch (IllegalThreadStateException e) { try { Thread.sleep(NUM); } catch (Exception ex) { } } } while (running); } catch (IOException e) { throw (new EShellExecException(STR + e.getMessage())); } finally { if (mWakeLock != null && mWakeLock.isHeld()) { mWakeLock.release(); } } return ret; }	"private int executeSUCommands(Intent result, String resultExtraText, String[] commands) {
    File rootFolder = new File(mRootOfWorkPath);
    File workingFolder = new File(rootFolder, TEMP_FOLDER);
    if (!workingFolder.exists() && !workingFolder.mkdir()) {
        result.putExtra(resultExtraText, STR);
        return -NUM;
    }
    try {
        Utils.extractExecutableAsset(this, UPDATE_SCRIPT, workingFolder.toString(), true);
        Utils.extractExecutableAsset(this, ANDROID_LOOP_MOUNT, workingFolder.toString(), true);
        Utils.extractExecutableAsset(this, ANDROID_BOOTMGR, workingFolder.toString(), true);
    } catch (IOException e) {
        e.printStackTrace();
        result.putExtra(resultExtraText, STR);
        return -NUM;
    }
    mWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, STR);
    try {
        Process process = Runtime.getRuntime().exec(STR, null, workingFolder);
        DataOutputStream os = new DataOutputStream(process.getOutputStream());
        os.writeBytes(STR);
        for (String c : commands) {
            Log.v(TAG, STR + c);
            os.writeBytes(String.format(STR, workingFolder.getAbsolutePath()));
            os.writeBytes(c);
        }
        os.writeBytes(String.format(STR, workingFolder.getAbsolutePath()));
        os.writeBytes(STR);
        os.flush();
        int read = NUM;
        byte[] buff = new byte[NUM];
        InputStream is = process.getInputStream();
        InputStream es = process.getErrorStream();
        boolean running = true;
        boolean scriptExecuted = false;
        do {
            while (is.available() > NUM) {
                read = is.read(buff);
                if (read <= NUM) {
                    break;
                }
                scriptExecuted = true;
                String seg = new String(buff, NUM, read);
                Log.i(TAG, STR + seg);
                broadcastProgress(-NUM, seg);
            }
            while (es.available() > NUM) {
                read = es.read(buff);
                if (read <= NUM) {
                    break;
                }
                scriptExecuted = true;
                String seg = new String(buff, NUM, read);
                Log.i(TAG, STR + seg);
            }
            try {
                int ret = process.exitValue();
                Log.v(TAG, STR + ret);
                if (ret == NUM || !scriptExecuted) {
                    result.putExtra(resultExtraText, STR);
                    return -NUM;
                } else if (ret != NUM) {
                    result.putExtra(resultExtraText, STR);
                    return -NUM;
                }
                running = false;
            } catch (IllegalThreadStateException e) {
                try {
                    Thread.sleep(NUM);
                } catch (Exception ex) {
                }
            }
        } while (running);
    } catch (IOException e) {
        e.printStackTrace();
        result.putExtra(resultExtraText, STR);
        return -NUM;
    } finally {
        if (mWakeLock != null && mWakeLock.isHeld()) {
            mWakeLock.release();
        }
    }
    return NUM;
}"	@return shell script exit value.	@return 0 for success and -1 for fail	1	0	17	98	691
public ApiResponse<byte[]> petPetIdtestingByteArraytrueGetWithHttpInfo(Long petId) throws ApiException { Call call = petPetIdtestingByteArraytrueGetCall(petId, null, null); Type localVarReturnType = new TypeToken<byte[]>(){}.getType(); return apiClient.execute(call, localVarReturnType); }	"  public ApiResponse<byte[]> petPetIdtestingByteArraytrueGetWithHttpInfo(Long petId) throws ApiException {
    Call call = petPetIdtestingByteArraytrueGetCall(petId, null, null);
    Type returnType = new TypeToken<byte[]>(){}.getType();
    return apiClient.execute(call, returnType);
  }
"	@return ApiResponse	@return ApiResponse	0	1	8	6	49
protected Object convertInteger(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0; } if (data instanceof Integer) return data; if (data instanceof Number) { Number value = (Number) data; return new Integer(value.intValue()); } if (data instanceof Boolean) { return ((Boolean) data).booleanValue() ? INTEGER_TRUE : INTEGER_FALSE; } return handleUnknownData(column, fieldDefn, data); }	"    protected Object convertInteger(Column column, Field fieldDefn, Object data) {
        if (data == null) return null;
        if (data instanceof Integer) return data;
        if (data instanceof Number) {
            Number value = (Number) data;
            return new Integer(value.intValue());
        }
        if (data instanceof Boolean) {
            return ((Boolean) data).booleanValue() ? INTEGER_TRUE : INTEGER_FALSE;
        }
        return handleUnknownData(column, fieldDefn, data);
    }
"	@return the converted value, or null if the conversion could not be made and the column allows nulls	@return the converted value, or null if the conversion could not be made	1	0	8	19	118
public boolean equals(Object obj) { if (this == obj) { return true; } if (obj != null && getClass() == obj.getClass()) { BasicChronology chrono = (BasicChronology) obj; return getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() && getZone().equals(chrono.getZone()); } return false; }	"    public boolean equals(Object obj) {
        return super.equals(obj);
    }
"	@return true if equal	@return true if equal	0	1	9	12	67
public static boolean exceedsMaxCount() { final long maxTestCount = HostConfig.getMaxTestCount(); return (maxTestCount > NUM) && (mTestCount >= maxTestCount); }	"public static boolean exceedsMaxCount() {
    return mTestCount >= MAX_TEST_COUNT;
}"	@return true, if the max count is enabled and exceeded.	@return If reached, return true; else, return false.	1	0	6	4	28
public ArrayList<View> getViews() { try { return ensureArrayListOrNull(viewFetcher.getViews()); } catch (Exception e) { e.printStackTrace(); return null; } }	"	public ArrayList<View> getViews() {
		return ensureArrayListOrNull(viewFetcher.getViews());
	}
"	@return a  List of the  Views located in the current  Activity	@return a List of the Views located in the current Activity	0	1	6	9	35
public final int getPeekHeight() { return mPeekHeightAuto ? PEEK_HEIGHT_AUTO : mPeekHeight; }	"public final int getPeekHeight() {
    return mPeekHeight;
}"	@return The height of the collapsed bottom sheet in pixels, or {@link #PEEK_HEIGHT_AUTO} if the sheet is configured to peek automatically at 16:9 ratio keyline	@return The height of the collapsed bottom sheet.	1	0	5	3	15
public DateTime roundFloorCopy() { DateTime instant = iInstant; return (DateTime)instant.withMillis(iField.roundFloor(instant.getMillis())); }	"    public DateTime roundFloorCopy() {
        DateTime instant = iInstant;
        return (DateTime)instant.toCopy(iField.roundFloor(instant.getMillis()));
    }
"	@return a copy of the DateTime with the field value changed	@return a copy of the DateTime with the field value changed	0	1	7	5	28
public long getMaxFileLength() { return maxFileLength; }	"    public int getMaxFileLength() {
        return maxFileLength;
    }
"	@return the maxFileLength	@return the maxFileLength	0	1	4	4	10
public byte get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }	"public byte get(WithAttributes attributes) {
    return attributes.getAttributes().get(this);
}"	@return the value of this attribute if this attribute is present in the extracted map. Otherwise {@link #getDefaultValue()}	@return the value of this attribute if this attribute is present in the map. Otherwise {@link #getDefaultValue()}	1	0	6	3	19
public static ImportMode getModeValue(String mode) { if (mode == null) return null; mode = mode.trim().toLowerCase(); if (mode.indexOf(STR) == -NUM) { if (STR.equals(mode)) { return ImportMode.insert; } else if (STR.equals(mode)) { return ImportMode.update; } else { return null; } } else { List l = StringUtil.stringToList(mode, STR); String first = (String) l.get(NUM); String second = (String) l.get(NUM); if (STR.equals(first) && STR.equals(second)) { return ImportMode.insertUpdate; } else if (STR.equals(first) && STR.equals(second)) { return ImportMode.updateInsert; } else { return null; } } }	"public static int getModeValue(String mode) {
    if (mode == null)
        return -NUM;
    mode = mode.trim().toLowerCase();
    if (mode.indexOf(STR) == -NUM) {
        if (STR.equals(mode)) {
            return MODE_INSERT;
        } else if (STR.equals(mode)) {
            return MODE_UPDATE;
        } else {
            return -NUM;
        }
    } else {
        List l = StringUtil.stringToList(mode, STR);
        String first = (String) l.get(NUM);
        String second = (String) l.get(NUM);
        if (STR.equals(first) && STR.equals(second)) {
            return MODE_INSERT_UPDATE;
        } else if (STR.equals(first) && STR.equals(second)) {
            return MODE_UPDATE_INSERT;
        } else {
            return -NUM;
        }
    }
}"	@return null if the value is not valid	@return -1 if the value is not valid	1	0	9	25	158
public OutEdges<I, E> unwrap() { if (currentEdge != null) { newEdges.add(currentEdge); currentEdge = null; } while (oldEdgesIterator.hasNext()) { newEdges.add(oldEdgesIterator.next()); } return newEdges; }	"public VertexEdges<I, E> unwrap() {
    if (currentEdge != null) {
        newEdges.add(currentEdge);
        currentEdge = null;
    }
    while (oldEdgesIterator.hasNext()) {
        newEdges.add(oldEdgesIterator.next());
    }
    return newEdges;
}"	@return The new {@link OutEdges} data structure.	@return The new {@link VertexEdges} data structure.	1	0	7	10	48
@Override public Object put(Object value) { return put(null, value); }	"@Override
public Object put(Object value) {
    return put(value, false);
}"	@return {@link #put(String, Object)}	@return {@link #put(String, boolean)}	1	0	5	4	19
"private boolean zzRefill() throws java.io.IOException { /* first: make room (if you can) */ if (zzStartRead > 0) { zzEndRead += zzFinalHighSurrogate; zzFinalHighSurrogate = 0; System.arraycopy(zzBuffer, zzStartRead, zzBuffer, 0, zzEndRead-zzStartRead); /* translate stored positions */ zzEndRead-= zzStartRead; zzCurrentPos-= zzStartRead; zzMarkedPos-= zzStartRead; zzStartRead = 0; } /* is the buffer big enough? */ if (zzCurrentPos >= zzBuffer.length - zzFinalHighSurrogate) { /* if not: blow it up */ char newBuffer[] = new char[zzBuffer.length*2]; System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length); zzBuffer = newBuffer; zzEndRead += zzFinalHighSurrogate; zzFinalHighSurrogate = 0; } /* fill the buffer with new input */ int requested = zzBuffer.length - zzEndRead; int numRead = zzReader.read(zzBuffer, zzEndRead, requested); /* not supposed to occur according to specification of java.io.Reader */ if (numRead == 0) { throw new java.io.IOException(""Reader returned 0 characters. See JFlex examples for workaround.""); } if (numRead > 0) { zzEndRead += numRead; /* If numRead == requested, we might have requested to few chars to encode a full Unicode character. We assume that a Reader would otherwise never return half characters. */ if (numRead == requested) { if (Character.isHighSurrogate(zzBuffer[zzEndRead - 1])) { --zzEndRead; zzFinalHighSurrogate = 1; } } /* potentially more input available */ return false; } /* numRead < 0 ==> end of stream */ return true; }"	"  private boolean zzRefill() throws java.io.IOException {

    /* first: make room (if you can) */
    if (zzStartRead > 0) {
      System.arraycopy(zzBuffer, zzStartRead,
                       zzBuffer, 0,
                       zzEndRead-zzStartRead);

      /* translate stored positions */
      zzEndRead-= zzStartRead;
      zzCurrentPos-= zzStartRead;
      zzMarkedPos-= zzStartRead;
      zzStartRead = 0;
    }

    /* is the buffer big enough? */
    if (zzCurrentPos >= zzBuffer.length) {
      /* if not: blow it up */
      char newBuffer[] = new char[zzCurrentPos*2];
      System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);
      zzBuffer = newBuffer;
    }

    /* finally: fill the buffer with new input */
    int numRead = zzReader.read(zzBuffer, zzEndRead,
                                            zzBuffer.length-zzEndRead);

    if (numRead > 0) {
      zzEndRead+= numRead;
      return false;
    }
    // unlikely but not impossible: read 0 characters, but not at end of stream    
    if (numRead == 0) {
      int c = zzReader.read();
      if (c == -1) {
        return true;
      } else {
        zzBuffer[zzEndRead++] = (char) c;
        return false;
      }     
    }

    // numRead < 0
    return true;
  }
"	@return false, iff there was new input.	@return false, iff there was new input.	0	1	12	54	309
private synchronized static Supplier<Annotator> getOrCreate(String name, Properties props, Supplier<Annotator> annotator) { customAnnotators.register(name, props, Lazy.of(annotator)); return () -> customAnnotators.get(name); }	"  private synchronized static Supplier<Annotator> getOrCreate(AnnotatorFactory factory) {
    return () -> {
      Annotator rtn = customAnnotators.get(factory.signature());
      if (rtn == null) {
        // Create the annotator
        rtn = factory.create();
        // Register the annotator
        customAnnotators.put(factory.signature(), factory.create());
        // Clean up memory if needed
        while (customAnnotators.size() > 10) {
          customAnnotators.keySet().iterator().remove();
        }
      }
      return rtn;
    };
  }
"	@return An annotator as specified by the given name and properties.	@return An annotator created by that factory.	1	0	6	5	43
"public ApiResponse uploadFile (Long petId, String additionalMetadata, File file) throws ApiException { Object postBody = null; // verify the required parameter 'petId' is set if (petId == null) { throw new ApiException(400, ""Missing the required parameter 'petId' when calling uploadFile""); } // create path and map variables String path = ""/pet/{petId}/uploadImage"".replaceAll(""\\{format\\}"",""json"").replaceAll(""\\{"" + ""petId"" + ""\\}"", apiInvoker.escapeString(petId.toString())); // query params List<Pair> queryParams = new ArrayList<Pair>(); // header params Map<String, String> headerParams = new HashMap<String, String>(); // form params Map<String, String> formParams = new HashMap<String, String>(); String[] contentTypes = { ""multipart/form-data"" }; String contentType = contentTypes.length > 0 ? contentTypes[0] : ""application/json""; if (contentType.startsWith(""multipart/form-data"")) { // file uploading MultipartEntityBuilder builder = MultipartEntityBuilder.create(); if (additionalMetadata != null) { builder.addTextBody(""additionalMetadata"", ApiInvoker.parameterToString(additionalMetadata), ApiInvoker.TEXT_PLAIN_UTF8); } if (file != null) { builder.addBinaryBody(""file"", file); } HttpEntity httpEntity = builder.build(); postBody = httpEntity; } else { // normal form params formParams.put(""additionalMetadata"", ApiInvoker.parameterToString(additionalMetadata)); } try { String response = apiInvoker.invokeAPI(basePath, path, ""POST"", queryParams, postBody, headerParams, formParams, contentType); if(response != null){ return (ApiResponse) ApiInvoker.deserialize(response, """", ApiResponse.class); } else { return null; } } catch (ApiException ex) { throw ex; } }"	"  public void  uploadFile (Long petId, String additionalMetadata, File file) throws ApiException {
    Object postBody = null;
    
    // verify the required parameter 'petId' is set
    if (petId == null) {
       throw new ApiException(400, ""Missing the required parameter 'petId' when calling uploadFile"");
    }
    

    // create path and map variables
    String path = ""/pet/{petId}/uploadImage"".replaceAll(""\\{format\\}"",""json"").replaceAll(""\\{"" + ""petId"" + ""\\}"", apiInvoker.escapeString(petId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    

    

    String[] contentTypes = {
      ""multipart/form-data""
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : ""application/json"";

    if (contentType.startsWith(""multipart/form-data"")) {
      // file uploading
      MultipartEntityBuilder builder = MultipartEntityBuilder.create();
      
      if (additionalMetadata != null) {
        builder.addTextBody(""additionalMetadata"", ApiInvoker.parameterToString(additionalMetadata), ApiInvoker.TEXT_PLAIN_UTF8);
      }
      
      if (file != null) {
        builder.addBinaryBody(""file"", file);
      }
      

      HttpEntity httpEntity = builder.build();
      postBody = httpEntity;
    } else {
      // normal form params
      formParams.put(""additionalMetadata"", ApiInvoker.parameterToString(additionalMetadata));
      
      
    }

    try {
      String response = apiInvoker.invokeAPI(basePath, path, ""POST"", queryParams, postBody, headerParams, formParams, contentType);
      if(response != null){
        return ;
      }
      else {
        return ;
      }
    } catch (ApiException ex) {
      throw ex;
    }
  }
"	@return ApiResponse	@return void	1	0	10	63	369
public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) { return appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2); }	"    public DateTimeFormatterBuilder appendDayOfMonth(final int minDigits) {
        return appendDecimal(iChronoUTC.dayOfMonth(), minDigits, 2);
    }
"	@return this DateTimeFormatterBuilder	@return this DateTimeFormatterBuilder	0	1	5	4	22
public Map<String, TopicMetadata> topicMetaData(final String... topicNames) { if (!running.get()) throw new IllegalStateException(STR); final ZkUtils z = getZkUtils(); final Set<String> set = (topicNames == null || topicNames.length == NUM) ? topicNames() : new LinkedHashSet<String>(Arrays.asList(topicNames)); final Set<TopicMetadata> meta = JavaConversions.setAsJavaSet(AdminUtils.fetchTopicMetadataFromZk(JavaConverters.asScalaSetConverter(set).asScala(), z)); final Map<String, TopicMetadata> map = new HashMap<String, TopicMetadata>(meta.size()); for (TopicMetadata tm : meta) { map.put(tm.topic(), tm); } return map; }	"public Set<TopicMetadata> topicMetaData(final String... topicNames) {
    if (!running.get())
        throw new IllegalStateException(STR);
    if (topicNames == null || topicNames.length == NUM)
        return Collections.emptySet();
    final ZkUtils z = getZkUtils();
    final Set<String> set = new LinkedHashSet<String>(Arrays.asList(topicNames));
    return JavaConversions.setAsJavaSet(AdminUtils.fetchTopicMetadataFromZk(JavaConverters.asScalaSetConverter(set).asScala(), z));
}"	@return a map of TopicMetadatas keyed by topic name	@return a set of TopicMetadatas	1	0	9	12	128
public boolean scrollUp(){ return scroller.scroll(Scroller.Direction.UP); }	"	public boolean scrollUp(){
		return scroller.scrollUp();
	}
"	@return  true if more scrolling can be done and  false if it is at the top of the screen	@return true if more scrolling can be done and false if it is at the top of the screen	0	1	5	4	16
public final int querySingleInt(String sqlCmd, int defVal, Connection conn) { return querySingleInt(sqlCmd, null, defVal, conn); }	"public final int querySingleInt(String sqlCmd, int defVal, Connection conn) {
    Object value = querySingleValue(sqlCmd, conn);
    return ObjectUtils.getInteger(value, defVal);
}"	@return the result as a int value	@return the result as a int value, if no result the int value 0	1	0	5	3	28
"private AutoInstallsLayout createWorkspaceLoaderFromAppRestriction(AppWidgetHost widgetHost) { Context ctx = getContext(); UserManager um = (UserManager) ctx.getSystemService(Context.USER_SERVICE); Bundle bundle = um.getApplicationRestrictions(ctx.getPackageName()); if (bundle == null) { return null; } String packageName = bundle.getString(RESTRICTION_PACKAGE_NAME); if (packageName != null) { try { Resources targetResources = ctx.getPackageManager() .getResourcesForApplication(packageName); return AutoInstallsLayout.get(ctx, packageName, targetResources, widgetHost, mOpenHelper); } catch (NameNotFoundException e) { Log.e(TAG, ""Target package for restricted profile not found"", e); return null; } } return null; }"	"    private AutoInstallsLayout createWorkspaceLoaderFromAppRestriction(AppWidgetHost widgetHost) {
        // UserManager.getApplicationRestrictions() requires minSdkVersion >= 18
        if (!Utilities.ATLEAST_JB_MR2) {
            return null;
        }

        Context ctx = getContext();
        UserManager um = (UserManager) ctx.getSystemService(Context.USER_SERVICE);
        Bundle bundle = um.getApplicationRestrictions(ctx.getPackageName());
        if (bundle == null) {
            return null;
        }

        String packageName = bundle.getString(RESTRICTION_PACKAGE_NAME);
        if (packageName != null) {
            try {
                Resources targetResources = ctx.getPackageManager()
                        .getResourcesForApplication(packageName);
                return AutoInstallsLayout.get(ctx, packageName, targetResources,
                        widgetHost, mOpenHelper);
            } catch (NameNotFoundException e) {
                Log.e(TAG, ""Target package for restricted profile not found"", e);
                return null;
            }
        }
        return null;
    }
"	@return the loader if the restrictions are set and the resource exists; null otherwise.	@return the loader if the restrictions are set and the resource exists; null otherwise.	0	1	10	23	124
public static ModuleConfig getModuleConfig(PageContext pageContext) { ModuleConfig moduleConfig = (ModuleConfig) pageContext.getRequest().getAttribute(Globals.MODULE_KEY); if (moduleConfig == null) { moduleConfig = (ModuleConfig) pageContext.getServletContext().getAttribute(Globals.MODULE_KEY); } return moduleConfig; }	"public static ApplicationConfig getModuleConfig(PageContext pageContext) {
    ApplicationConfig appConfig = (ApplicationConfig) pageContext.getRequest().getAttribute(Globals.MODULE_KEY);
    if (appConfig == null) {
        appConfig = (ApplicationConfig) pageContext.getServletContext().getAttribute(Globals.MODULE_KEY);
    }
    return appConfig;
}"	@return the ModuleConfig object	@return the ApplicationConfig object	1	0	10	7	49
private static String getPackageIdForApk(FilePath apkPath) throws IOException, InterruptedException { return apkPath.act(new FilePath.FileCallable<String>() { public String invoke(File f, VirtualChannel channel) throws IOException, InterruptedException { return getApkMetadata(f).getPackageName(); } }); }	"private static String getPackageIdForApk(AbstractBuild<?, ?> build, Launcher launcher, PrintStream logger, AndroidSdk androidSdk, FilePath apkPath) throws IOException, InterruptedException {
    ByteArrayOutputStream aaptOutput = new ByteArrayOutputStream();
    String args = String.format(STR, apkPath.getName());
    Utils.runAndroidTool(launcher, aaptOutput, logger, androidSdk, Tool.AAPT, args, apkPath.getParent());
    String packageId = null;
    String aaptResult = aaptOutput.toString();
    if (aaptResult.length() > NUM) {
        Matcher matcher = Pattern.compile(STR).matcher(aaptResult);
        if (matcher.find()) {
            packageId = matcher.group(NUM);
        }
    }
    return packageId;
}"	@return The package ID for the given APK.	@return The package ID for the given APK, or {@code null} if it could not be determined.	1	0	9	8	53
Folder getOpenFolder() { CellLayout currentScreen = (CellLayout) getChildAt(mCurrentScreen); int count = currentScreen.getChildCount(); for (int i = 0; i < count; i++) { View child = currentScreen.getChildAt(i); CellLayout.LayoutParams lp = (CellLayout.LayoutParams) child.getLayoutParams(); if (lp.cellHSpan == 4 && lp.cellVSpan == 4 && child instanceof Folder) { return (Folder) child; } } return null; }	"    Folder getOpenFolder() {
        CellLayout currentPage = (CellLayout) getChildAt(mCurrentPage);
        int count = currentPage.getChildCount();
        for (int i = 0; i < count; i++) {
            View child = currentPage.getChildAt(i);
            if (child instanceof Folder) {
                Folder folder = (Folder) child;
                if (folder.getInfo().opened)
                    return folder;
            }
        }
        return null;
    }
"	@return The open folder on the current screen, or null if there is none	@return The open folder on the current screen, or null if there is none	0	1	9	13	85
"public Collection<Tree> getRelatedNodes(Tree t, Tree root) { if (root.value() == null) { root.setValue(""ROOT""); // todo: cdm: it doesn't seem like this line should be here } Set<Tree> nodeList = new LinkedHashSet<Tree>(); for (TregexPattern p : targetPatterns) { // cdm: I deleted: && nodeList.isEmpty() TregexMatcher m = p.matcher(root); while (m.findAt(t)) { nodeList.add(m.getNode(""target"")); //System.out.println(""found "" + this + ""("" + t + "", "" + m.getNode(""target"") + "") using pattern "" + p); } } return nodeList; }"	"  public Collection<TreeGraphNode> getRelatedNodes(TreeGraphNode t, TreeGraphNode root, HeadFinder headFinder) {
    Set<TreeGraphNode> nodeList = new ArraySet<TreeGraphNode>();
    for (TregexPattern p : targetPatterns) {    // cdm: I deleted: && nodeList.isEmpty()
      // Initialize the TregexMatcher with the HeadFinder so that we
      // can use the same HeadFinder through the entire process of
      // building the dependencies
      TregexMatcher m = p.matcher(root, headFinder);
      while (m.findAt(t)) {
        TreeGraphNode target = (TreeGraphNode) m.getNode(""target"");
        if (target == null) {
          throw new AssertionError(""Expression has no target: "" + p);
        }
        nodeList.add(target);
        if (DEBUG) {
          System.err.println(""found "" + this + ""("" + t + ""-"" + t.headWordNode() + "", "" + m.getNode(""target"") + ""-"" + ((TreeGraphNode) m.getNode(""target"")).headWordNode() + "") using pattern "" + p);
          for (String nodeName : m.getNodeNames()) {
            if (nodeName.equals(""target""))
              continue;
            System.err.println(""  node "" + nodeName + "": "" + m.getNode(nodeName));
          }
        }
      }
    }
    return nodeList;
  }
"	@return Governor nodes to which t bears this GR	@return A Collection of dependent nodes to which t bears this GR	1	0	10	15	151
public double getExtraDouble(String key) throws JSONException { return mExtraData.getDouble(key); }	"public double getExtraDouble(String key) {
    return mExtraData.optDouble(key);
}"	@return The stored value.	@return The stored value or null if it doesn't exist in specified form.	1	0	5	3	18
public static DateTimeFormatter hourMinute() { return Constants.hm; }	"    public static DateTimeFormatter hourMinute() {
        if (hm == null) {
            hm = new DateTimeFormatterBuilder()
                .append(hourElement())
                .append(minuteElement())
                .toFormatter();
        }
        return hm;
    }
"	@return a formatter for HH:mm	@return a formatter for HH:mm	0	1	4	4	12
"public Builder builder(RelNode rel, Clause... clauses) { final Clause maxClause = maxClause(); boolean needNew = false; // If old and new clause are equal and belong to below set, // then new SELECT wrap is not required Set<Clause> nonWrapSet = ImmutableSet.of(Clause.SELECT); for (Clause clause : clauses) { if (maxClause.ordinal() > clause.ordinal() || (maxClause == clause && !nonWrapSet.contains(clause))) { needNew = true; } } if (rel instanceof Aggregate && !dialect.supportsNestedAggregations() && hasNestedAggregations((Aggregate) rel)) { needNew = true; } SqlSelect select; Expressions.FluentList<Clause> clauseList = Expressions.list(); if (needNew) { select = subSelect(); } else { select = asSelect(); clauseList.addAll(this.clauses); } clauseList.appendAll(clauses); final Context newContext; final SqlNodeList selectList = select.getSelectList(); if (selectList != null) { newContext = new Context(dialect, selectList.size()) { public SqlNode field(int ordinal) { final SqlNode selectItem = selectList.get(ordinal); switch (selectItem.getKind()) { case AS: return ((SqlCall) selectItem).operand(0); } return selectItem; } @Override public SqlNode orderField(int ordinal) { // If the field expression is an unqualified column identifier // and matches a different alias, use an ordinal. // For example, given // SELECT deptno AS empno, empno AS x FROM emp ORDER BY emp.empno // we generate // SELECT deptno AS empno, empno AS x FROM emp ORDER BY 2 // ""ORDER BY empno"" would give incorrect result; // ""ORDER BY x"" is acceptable but is not preferred. final SqlNode node = field(ordinal); if (node instanceof SqlIdentifier && ((SqlIdentifier) node).isSimple()) { final String name = ((SqlIdentifier) node).getSimple(); for (Ord<SqlNode> selectItem : Ord.zip(selectList)) { if (selectItem.i != ordinal) { final String alias = SqlValidatorUtil.getAlias(selectItem.e, -1); if (name.equalsIgnoreCase(alias)) { return SqlLiteral.createExactNumeric( Integer.toString(ordinal + 1), SqlParserPos.ZERO); } } } } return node; } }; } else { boolean qualified = !dialect.hasImplicitTableAlias() || aliases.size() > 1; // basically, we did a subSelect() since needNew is set and neededAlias is not null // now, we need to make sure that we need to update the alias context. // if our aliases map has a single element: <neededAlias, rowType>, // then we don't need to rewrite the alias but otherwise, it should be updated. if (needNew && neededAlias != null && (aliases.size() != 1 || !aliases.containsKey(neededAlias))) { final Map<String, RelDataType> newAliases = ImmutableMap.of(neededAlias, rel.getInput(0).getRowType()); newContext = aliasContext(newAliases, qualified); } else { newContext = aliasContext(aliases, qualified); } } return new Builder(rel, clauseList, select, newContext, needNew ? null : aliases); }"	"    public Builder builder(RelNode rel, Clause... clauses) {
      final Clause maxClause = maxClause();
      boolean needNew = false;
      // If old and new clause are equal and belong to below set,
      // then new SELECT wrap is not required
      Set<Clause> nonWrapSet = ImmutableSet.of(Clause.SELECT);
      for (Clause clause : clauses) {
        if (maxClause.ordinal() > clause.ordinal()
            || (maxClause == clause && !nonWrapSet.contains(clause))) {
          needNew = true;
        }
      }
      if (rel instanceof Aggregate
          && !dialect.supportsNestedAggregations()
          && hasNestedAggregations((Aggregate) rel)) {
        needNew = true;
      }

      SqlSelect select;
      Expressions.FluentList<Clause> clauseList = Expressions.list();
      if (needNew) {
        select = subSelect();
      } else {
        select = asSelect();
        clauseList.addAll(this.clauses);
      }
      clauseList.appendAll(clauses);
      Context newContext;
      final SqlNodeList selectList = select.getSelectList();
      if (selectList != null) {
        newContext = new Context(dialect, selectList.size()) {
          public SqlNode field(int ordinal) {
            final SqlNode selectItem = selectList.get(ordinal);
            switch (selectItem.getKind()) {
            case AS:
              return ((SqlCall) selectItem).operand(0);
            }
            return selectItem;
          }
        };
      } else {
        boolean qualified =
            !dialect.hasImplicitTableAlias() || aliases.size() > 1;
        // basically, we did a subSelect() since needNew is set and neededAlias is not null
        // now, we need to make sure that we need to update the alias context.
        // if our aliases map has a single element:  <neededAlias, rowType>,
        // then we don't need to rewrite the alias but otherwise, it should be updated.
        if (needNew
                && neededAlias != null
                && (aliases.size() != 1 || !aliases.containsKey(neededAlias))) {
          final Map<String, RelDataType> newAliases =
              ImmutableMap.of(neededAlias, rel.getInput(0).getRowType());
          newContext = aliasContext(newAliases, qualified);
        } else {
          newContext = aliasContext(aliases, qualified);
        }
      }
      return new Builder(rel, clauseList, select, newContext,
          needNew ? null : aliases);
    }
"	@return A builder	@return A builder	0	1	21	88	626
public static List<String> uniquify(List<String> nameList) { return uniquify(nameList, EXPR_SUGGESTER); }	"    public static List<String> uniquify(List<String> nameList)
    {
        Set<String> used = new LinkedHashSet<String>();
        int changeCount = 0;
        for (int i = 0; i < nameList.size(); i++) {
            String name = nameList.get(i);
            String uniqueName = uniquify(name, used);
            if (!uniqueName.equals(name)) {
                ++changeCount;
            }
        }
        return changeCount == 0
           ? nameList
           : new ArrayList<String>(used);
    }
"	@return List of unique strings	@return List of unique strings	0	1	6	4	20
"public static File locateInProject(String path) { File dir = new File(""."").getAbsoluteFile(); while (dir != null) { File needle = new File(dir, path); if (needle.exists()) { return needle; } dir = dir.getParentFile(); } throw new WebDriverException(new FileNotFoundException( ""Could not find "" + path + "" in the project"")); }"	"  public static File locateInProject(String path) {
    // It'll be one of these. Probably
    String[] locations = {
      ""../"",  // IDEA
      ""."",     // Eclipse
    };

    for (String location : locations) {
      File file = new File(location, path);
      if (file.exists()) {
        return file;
      }
    }

    throw new WebDriverException(new FileNotFoundException(
        ""Could not find "" + path + "" in the project""));
  }
"	@return file being sought, if it exists	@return file being saught, if it exists	1	0	8	14	81
public Score toScore() { SQLiteHabitList habitList = SQLiteHabitList.getInstance(); Habit h = habitList.getById(habit.getId()); return new Score(timestamp, score); }	"    public Score toScore()
    {
        SQLiteHabitList habitList = SQLiteHabitList.getInstance();
        Habit h = habitList.getById(habit.getId());
        return new Score(h, timestamp, score);
    }
"	@return a  Score with this record's data	@return a Score with this record's data	0	1	6	7	34
public int getItemPrice(int itemID) { if (itemID == ItemID.COINS_995) { return 1; } if (itemID == ItemID.PLATINUM_TOKEN) { return 1000; } UntradeableItemMapping p = UntradeableItemMapping.map(ItemVariationMapping.map(itemID)); if (p != null) { return getItemPrice(p.getPriceID()) * p.getQuantity(); } int price = 0; for (int mappedID : ItemMapping.map(itemID)) { ItemPrice ip = itemPrices.get(mappedID); if (ip != null) { price += ip.getPrice(); } } return price; }	"	public int getItemPrice(int itemID)
	{
		if (itemID == ItemID.COINS_995)
		{
			return 1;
		}
		if (itemID == ItemID.PLATINUM_TOKEN)
		{
			return 1000;
		}

		int price = 0;
		for (int mappedID : ItemMapping.map(itemID))
		{
			ItemPrice ip = itemPrices.get(mappedID);
			if (ip != null)
			{
				price += ip.getPrice();
			}
		}

		return price;
	}
"	@return item price	@return item price	0	1	9	30	108
@Override public Map<String, DatatypeValidator> getBuiltInTypes() { final HashMap<String, DatatypeValidator> toReturn = new HashMap<>(fBuiltInTypes); toReturn.putAll(XML11BUILTINTYPES); return toReturn; }	"public Hashtable getBuiltInTypes() {
    Hashtable toReturn = (Hashtable) fBuiltInTypes.clone();
    Enumeration xml11Keys = fXML11BuiltInTypes.keys();
    while (xml11Keys.hasMoreElements()) {
        Object key = xml11Keys.nextElement();
        toReturn.put(key, fXML11BuiltInTypes.get(key));
    }
    return toReturn;
}"	@return a Map which contains all datatypes	@return a hashtable which contains all datatypes	1	0	6	6	33
public static ClusterFixtureBuilder bareBuilder(BaseDirTestWatcher dirTestWatcher) { return new ClusterFixtureBuilder(dirTestWatcher); }	"  public static ClusterFixtureBuilder bareBuilder() {
    return new ClusterFixtureBuilder();
  }
"	@return a fixture builder with no default properties set	@return a fixture builder with no default properties set	0	1	5	4	17
private boolean isReplaceableHotseatItem(Favorite favorite) { return favorite.container == Favorites.CONTAINER_HOTSEAT && favorite.intent != null && (favorite.itemType == Favorites.ITEM_TYPE_APPLICATION || favorite.itemType == Favorites.ITEM_TYPE_SHORTCUT || favorite.itemType == Favorites.ITEM_TYPE_DEEP_SHORTCUT); }	"    private boolean isReplaceableHotseatItem(Favorite favorite) {
        return favorite.container == Favorites.CONTAINER_HOTSEAT
                && favorite.intent != null
                && (favorite.itemType == Favorites.ITEM_TYPE_APPLICATION
                || favorite.itemType == Favorites.ITEM_TYPE_SHORTCUT);
    }
"	@return true if its an hotseat item, that can be replaced during restore. TODO: Extend check for folders in hotseat.	@return true if its an hotseat item, that can be replaced during restore. TODO: Extend check for folders in hotseat.	0	1	8	8	41
public static FromContext getInstance(String fromString) { if (NAME.getFromString().equalsIgnoreCase(fromString)) return NAME; else if (ALIAS.getFromString().equalsIgnoreCase(fromString)) return ALIAS; else if (METADATA.getFromString().equalsIgnoreCase(fromString)) return METADATA; else if (BEANINFO.getFromString().equalsIgnoreCase(fromString)) return BEANINFO; else if (SCOPE.getFromString().equalsIgnoreCase(fromString)) return SCOPE; else if (ID.getFromString().equalsIgnoreCase(fromString)) return ID; else return new DynamicFromContext(fromString); }	"public static FromContext getInstance(String optionString) {
    if (NAME.getFromString().equalsIgnoreCase(optionString))
        return NAME;
    else if (METADATA.getFromString().equalsIgnoreCase(optionString))
        return METADATA;
    else if (SCOPE.getFromString().equalsIgnoreCase(optionString))
        return SCOPE;
    else if (ID.getFromString().equalsIgnoreCase(optionString))
        return ID;
    else
        return new DynamicFromContext(optionString);
}"	@return FromContext instance	@return InjectionOption instance	1	0	11	16	107
"public String[] getAllWindowIds() { return getAttributeFromAllWindows(""id""); }"	"  public String[] getAllWindowIds() {
    throw new UnsupportedOperationException(""getAllWindowIds"");
  }
"	@return the IDs of all windows that the browser knows about.	@return the IDs of all windows that the browser knows about.	0	1	5	4	17
"public String getTypeDeclaration(Schema p) { String schemaType = getSchemaType(p); if (schemaType != null) { schemaType = schemaType.replace(""-"", ""_""); } if (ModelUtils.isArraySchema(p)) { ArraySchema ap = (ArraySchema) p; Schema inner = ap.getItems(); return getTypeDeclaration(inner) + ""_Vectors.Vector""; } if (ModelUtils.isMapSchema(p)) { Schema inner = (Schema) p.getAdditionalProperties(); String name = getTypeDeclaration(inner) + ""_Map""; if (name.startsWith(""Swagger."")) { return name; } else { return ""Swagger."" + name; } } if (typeMapping.containsKey(schemaType)) { return typeMapping.get(schemaType); } // LOGGER.info(""Swagger type "" + schemaType); if (languageSpecificPrimitives.contains(schemaType)) { return schemaType; } String modelType = toModelName(schemaType).replace(""-"", ""_""); if (ModelUtils.isStringSchema(p) || ModelUtils.isFileSchema(p) || languageSpecificPrimitives.contains(modelType)) { return modelType; } return modelPackage + "".Models."" + modelType; }"	"    public String getTypeDeclaration(Schema p) {
        String schemaType = getSchemaType(p);

        if (schemaType != null) {
            schemaType = schemaType.replace(""-"", ""_"");
        }

        if (ModelUtils.isArraySchema(p)) {
            ArraySchema ap = (ArraySchema) p;
            Schema inner = ap.getItems();
            return getTypeDeclaration(inner) + ""_Vectors.Vector"";
        }
        if (ModelUtils.isMapSchema(p)) {
            Schema inner = (Schema) p.getAdditionalProperties();
            String name = getTypeDeclaration(inner) + ""_Map"";
            if (name.startsWith(""Swagger."")) {
                return name;
            } else {
                return ""Swagger."" + name;
            }
        }
        // TODO need to revise/test the logic below to check ""required""
        if (typeMapping.containsKey(schemaType)) {
            if (p.getRequired() != null && p.getRequired().contains(p.getName())) {
                return typeMapping.get(schemaType);
            } else {
                return nullableTypeMapping.get(schemaType);
            }
        }
        //  LOGGER.info(""Swagger type "" + schemaType);
        if (languageSpecificPrimitives.contains(schemaType)) {
            return schemaType;
        }
        String modelType = toModelName(schemaType).replace(""-"", ""_"");
        if (ModelUtils.isStringSchema(p) || ModelUtils.isFileSchema(p)
                || languageSpecificPrimitives.contains(modelType)) {
            return modelType;
        }

        return modelPackage + "".Models."" + modelType;
    }
"	@return a string value used as the `dataType` field for model templates, `returnType` for api templates	@return a string value used as the `dataType` field for model templates, `returnType` for api templates	0	1	9	37	224
public DateTimeFormatterBuilder appendDayOfYear(int minDigits) { return appendDecimal(DateTimeFieldType.dayOfYear(), minDigits, 3); }	"    public DateTimeFormatterBuilder appendDayOfYear(final int minDigits) {
        return appendDecimal(iChronoUTC.dayOfYear(), minDigits, 3);
    }
"	@return this DateTimeFormatterBuilder	@return this DateTimeFormatterBuilder	0	1	5	4	22
"public List<Pet> findPetsByTags (List<String> tags) throws ApiException { Object postBody = null; // create path and map variables String path = ""/pet/findByTags"".replaceAll(""\\{format\\}"",""json""); // query params List<Pair> queryParams = new ArrayList<Pair>(); Map<String, String> headerParams = new HashMap<String, String>(); Map<String, Object> formParams = new HashMap<String, Object>(); queryParams.addAll(apiClient.parameterToPairs(""multi"", ""tags"", tags)); final String[] accepts = { ""application/json"", ""application/xml"" }; final String accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final String contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { ""petstore_auth"" }; TypeRef returnType = new TypeRef<List<Pet>>() {}; return apiClient.invokeAPI(path, ""GET"", queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }"	"  public List<Pet> findPetsByTags (List<String> tags) throws ApiException {
    Object postBody = null;
    

    // create path and map variables
    String path = ""/pet/findByTags"".replaceAll(""\\{format\\}"",""json"");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    Map<String, String> headerParams = new HashMap<String, String>();
    Map<String, String> formParams = new HashMap<String, String>();

    
    queryParams.addAll(apiClient.parameterToPairs(""multi"", ""tags"", tags));
    

    

    final String[] accepts = {
      ""application/json"", ""application/xml""
    };
    final String accept = apiClient.selectHeaderAccept(accepts);

    final String[] contentTypes = {
      
    };
    final String contentType = apiClient.selectHeaderContentType(contentTypes);

    if(contentType.startsWith(""multipart/form-data"")) {
      boolean hasFields = false;
      FormDataMultiPart mp = new FormDataMultiPart();
      
      if(hasFields)
        postBody = mp;
    }
    else {
      
    }

    try {
      String[] authNames = new String[] { ""petstore_auth"" };
      String response = apiClient.invokeAPI(path, ""GET"", queryParams, postBody, headerParams, formParams, accept, contentType, authNames);
      if(response != null){
        return (List<Pet>) apiClient.deserialize(response, ""array"", Pet.class);
      }
      else {
        return null;
      }
    } catch (ApiException ex) {
      throw ex;
    }
  }
"	@return List	@return List	0	1	10	37	203
public boolean start() { if (isReleased()) throw new IllegalStateException(STR); return nativeStart(); }	"public boolean start() {
    if (!isReleased())
        return nativeStart();
    else
        return false;
}"	@return true the service is started	@return true the serive is started	1	0	6	5	25
static public GenericServiceConnection<AcronymCall> newAcronymCallConnection() { return new GenericServiceConnection(AcronymCall.class); }	"    static public GenericServiceConnection<AcronymCall> newAcronymCallConnection() {
        return new GenericServiceConnection<AcronymCall>
            (new GenericServiceConnection.InterfaceFactory<AcronymCall>() {
                public AcronymCall asInterface(IBinder service) {
                    return AcronymCall.Stub.asInterface(service);
                }
            });
    }
"	@return the GenericServiceConnection to use.	@return the GenericServiceConnection to use.	0	1	6	4	17
public List<Alert> getAlerts() { if(alerts!=null) return this.alerts; else return Collections.emptyList(); }	"   public List<Alert> getAlerts() {
	   if(alerts!=null)
		   return this.alerts;
	   else
		   return new ArrayList<Alert>();
   }
"	@return the alerts	@return the alerts	0	1	6	7	25
public boolean[] getSlew() { boolean[] data = new boolean[NUM]; String answer = this.getData(STR, STR, STR); data[NUM] = (!answer.equals(STR)); answer = this.getData(STR, STR, STR); data[NUM] = (!answer.equals(STR)); answer = this.getData(STR, STR, STR); data[NUM] = (!answer.equals(STR)); return data; }	"public boolean getSlew() {
    return false;
}"	@return true if Fast Slew is on, false if not. In order (x,y,z).	@return true if Fast Slew is on, false if not	1	0	7	10	95
public ApiResponse<ModelApiResponse> uploadFileWithHttpInfo(Long petId, String additionalMetadata, File file) throws ApiException { Call call = uploadFileCall(petId, additionalMetadata, file, null, null); Type localVarReturnType = new TypeToken<ModelApiResponse>(){}.getType(); return apiClient.execute(call, localVarReturnType); }	"  public ApiResponse<ApiResponse> uploadFileWithHttpInfo(Long petId, String additionalMetadata, File file) throws ApiException {
    Call call = uploadFileCall(petId, additionalMetadata, file, null, null);
    Type localVarReturnType = new TypeToken<ApiResponse>(){}.getType();
    return apiClient.execute(call, localVarReturnType);
  }
"	@return ApiResponse	@return ApiResponse	0	1	8	6	55
public String getValue(String locator) { return elementFinder.findElement(driver, locator) .getValue(); }	"  public String getValue(String locator) {
    return findElement(locator).getValue();
  }
"	"@return the element value, or ""on/off"" for checkbox/radio elements"	"@return the element value, or ""on/off"" for checkbox/radio elements"	0	1	5	5	21
static public IStructuredTextExpert getStatefulExpert(String type, StructuredTextEnvironment environment) { StructuredTextTypeHandler handler = StructuredTextTypeHandlerFactory.getHandler(type); if (handler == null) throw new IllegalArgumentException(STR); return getStatefulExpert(handler, environment); }	"static public ISTextExpert getStatefulExpert(String type, STextEnvironment environment) {
    STextTypeHandler handler = STextTypeHandlerFactory.getHandler(type);
    if (handler == null)
        throw new IllegalArgumentException(STR);
    return getStatefulExpert(handler, environment);
}"	@return the IStructuredTextExpert instance.	@return the ISTextExpert instance.	1	0	6	6	41
"public String getTypeDeclaration(Schema p) { String openAPIType = getSchemaType(p); if (ModelUtils.isArraySchema(p)) { ArraySchema ap = (ArraySchema) p; Schema inner = ap.getItems(); return getSchemaType(p) + ""<"" + getTypeDeclaration(inner) + "">""; } if (ModelUtils.isMapSchema(p)) { Schema inner = (Schema) p.getAdditionalProperties(); return getSchemaType(p) + ""<std::string, "" + getTypeDeclaration(inner) + "">""; } else if (ModelUtils.isByteArraySchema(p)) { return ""std::string""; } if (ModelUtils.isStringSchema(p) || ModelUtils.isDateSchema(p) || ModelUtils.isDateTimeSchema(p) || ModelUtils.isFileSchema(p) || languageSpecificPrimitives.contains(openAPIType)) { return toModelName(openAPIType); } return openAPIType; }"	"    public String getTypeDeclaration(Schema p) {
        String openAPIType = getSchemaType(p);

        if (ModelUtils.isArraySchema(p)) {
            ArraySchema ap = (ArraySchema) p;
            Schema inner = ap.getItems();
            return getSchemaType(p) + ""<"" + getTypeDeclaration(inner) + "">"";
        }
        if (ModelUtils.isMapSchema(p)) {
            Schema inner = (Schema) p.getAdditionalProperties();
            return getSchemaType(p) + ""<std::string, "" + getTypeDeclaration(inner) + "">"";
        }
        if (ModelUtils.isStringSchema(p)
                || ModelUtils.isDateSchema(p)
                || ModelUtils.isDateTimeSchema(p) || ModelUtils.isFileSchema(p)
                || languageSpecificPrimitives.contains(openAPIType)) {
            return toModelName(openAPIType);
        }

        return openAPIType;
    }
"	@return a string value used as the `dataType` field for model templates, `returnType` for api templates	@return a string value used as the `dataType` field for model templates, `returnType` for api templates	0	1	10	25	165
public String getAuthorizationUrl(String state, Map<String, String> additionalParams, PKCE pkce) { return createAuthorizationUrlBuilder() .state(state) .additionalParams(additionalParams) .pkce(pkce) .build(); }	"    public String getAuthorizationUrl(Map<String, String> additionalParams) {
        return getAuthorizationUrl(null, additionalParams);
    }
"	@return url	@return the URL where you should redirect your users	1	0	6	8	38
protected Collection<I> orphanedItems(Collection<I> orphaned, TaskListener listener) throws IOException, InterruptedException { return getOrphanedItemStrategy().orphanedItems(this, orphaned, listener); }	"protected Collection<I> orphanedItems(Collection<I> orphaned, TaskListener listener) throws IOException, InterruptedException {
    return orphaned;
}"	@return any subset of {@code orphaned}, representing those children which ought to be removed from the folder now; items not listed will be left alone for the time being	@return any subset of {@code orphaned}, representing those children which ought to be removed from the folder now (by default, all of them); items not listed will be left alone for the time being	1	0	6	3	31
public YearMonthDay addCopy(int valueToAdd) { int[] newValues = iYearMonthDay.getValues(); newValues = getField().add(iYearMonthDay, iFieldIndex, newValues, valueToAdd); return new YearMonthDay(iYearMonthDay, newValues); }	"        public YearMonthDay addCopy(int valueToAdd) {
            int[] newValues = iInstant.getValues();
            getField().add(iInstant, iFieldIndex, newValues, valueToAdd);
            return new YearMonthDay(iInstant, newValues);
        }
"	@return a copy of the YearMonthDay with the field value changed	@return a copy of the YearMonthDay with the field value changed	0	1	7	6	42
@ManagedAttribute(description = STR) public long getNewPeriodCount() { return newPeriodCount.longValue(); }	"public LongAdder getNewPeriodCount() {
    return newPeriodCount;
}"	@return the total number of created periods	@return the newPeriodCount	1	0	5	4	19
"public Applications getApplications(String serviceUrl) { try { EurekaHttpResponse<Applications> response = clientConfig.getRegistryRefreshSingleVipAddress() == null ? eurekaTransport.queryClient.getApplications() : eurekaTransport.queryClient.getVip(clientConfig.getRegistryRefreshSingleVipAddress()); if (response.getStatusCode() == 200) { logger.debug(PREFIX + appPathIdentifier + "" - refresh status: "" + response.getStatusCode()); return response.getEntity(); } logger.error(PREFIX + appPathIdentifier + "" - was unable to refresh its cache! status = "" + response.getStatusCode()); } catch (Throwable th) { logger.error(PREFIX + appPathIdentifier + "" - was unable to refresh its cache! status = "" + th.getMessage(), th); } return null; }"	"    public Applications getApplications(String serviceUrl) {
        if (shouldUseExperimentalTransportForQuery()) {
            try {
                EurekaHttpResponse<Applications> response = clientConfig.getRegistryRefreshSingleVipAddress() == null
                        ? eurekaTransport.queryClient.getApplications()
                        : eurekaTransport.queryClient.getVip(clientConfig.getRegistryRefreshSingleVipAddress());
                if (response.getStatusCode() == 200) {
                    logger.debug(PREFIX + appPathIdentifier + "" -  refresh status: "" + response.getStatusCode());
                    return response.getEntity();
                }
                logger.error(PREFIX + appPathIdentifier + "" - was unable to refresh its cache! status = "" + response.getStatusCode());
            } catch (Throwable th) {
                logger.error(PREFIX + appPathIdentifier + "" - was unable to refresh its cache! status = "" + th.getMessage(), th);
            }
        } else {
            ClientResponse response = null;
            try {
                response = makeRemoteCall(Action.Refresh);
                Applications apps = response.getEntity(Applications.class);
                logger.debug(PREFIX + appPathIdentifier + "" -  refresh status: "" + response.getStatus());
                return apps;
            } catch (Throwable th) {
                logger.error(PREFIX + appPathIdentifier + "" - was unable to refresh its cache! status = "" + th.getMessage(), th);
            } finally {
                closeResponse(response);
            }
        }
        return null;
    }
"	@return - The registry information containing all applications.	@return - The registry information containing all applications.	0	1	11	16	135
"public Service<Vault> createLockAllService(Collection<Vault> vaults, boolean forced) { Iterator<Vault> iter = ImmutableList.copyOf(vaults).iterator(); ScheduledService<Vault> service = new ScheduledService<>() { @Override protected Task<Vault> createTask() { assert Platform.isFxApplicationThread(); if (iter.hasNext()) { return new LockVaultTask(iter.next(), forced); } else { cancel(); return new IllegalStateTask(""This task should never be executed.""); } } }; service.setExecutor(executorService); return service; }"	"	public Service<Void> createLockAllService(Collection<Vault> vaults, boolean forced) {
		Iterator<Vault> iter = vaults.iterator();
		ScheduledService<Void> service = new ScheduledService<>() {

			@Override
			protected Task<Void> createTask() {
				assert Platform.isFxApplicationThread();
				if (iter.hasNext()) {
					return createLockTask(iter.next(), forced);
				} else {
					// This should be unreachable code, since iter is only accessed on the FX App Thread.
					// But if quitting the application takes longer for any reason, this service should shut down properly
					reset();
					return createNoopTask();
				}
			}
		};
		service.setExecutor(executorService);
		return service;
	}
"	@return Service that tries to lock all given vaults and cancels itself automatically when done	@return Service that tries to lock all given vaults	1	0	11	19	103
public synchronized IConfigurationElement[] getContainerConfigurations(String containerid, String[] containerPaths) { if (contributions == null) processProxyContributionExtensionPoint(); return (IConfigurationElement[]) contributions.containerPathContributions.getContributors(containerid, containerPaths); }	"public synchronized IConfigurationElement[] getContainerConfigurations(String containerid) {
    if (containerToContributions == null)
        processProxyContributionExtensionPoint();
    return (IConfigurationElement[]) containerToContributions.get(containerid);
}"	@return Array of configuration elements.	@return Array of configuration elements or <code>null</code> if this container has no contributions.	1	0	6	5	41
public static CacheEntity parseCacheHeaders(Headers responseHeaders, byte[] responseBody) { CacheEntity cacheEntity = new CacheEntity(); cacheEntity.setData(responseBody); cacheEntity.setLocalExpire(getLocalExpires(responseHeaders)); cacheEntity.setResponseHeaders(responseHeaders); return cacheEntity; }	"    public static CacheEntity parseCacheHeaders(Headers responseHeaders, byte[] responseBody, boolean forceCache) {
        String cacheControl = responseHeaders.getCacheControl();
        if (!forceCache && cacheControl != null && (cacheControl.contains(""no-cache"") || cacheControl.contains(""no-store"")))
            return null;
        long localExpire = getLocalExpires(responseHeaders);
        CacheEntity cacheEntity = new CacheEntity();
        cacheEntity.setData(responseBody);
        cacheEntity.setLocalExpire(localExpire);
        cacheEntity.setResponseHeaders(responseHeaders);
        return cacheEntity;
    }
"	@return CacheStore entity.	@return Cache entity.	1	0	6	8	46
public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) { return appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits); }	"    public DateTimeFormatterBuilder appendYear(final int minDigits, final int maxDigits) {
        return appendSignedDecimal(iChronoUTC.year(), minDigits, maxDigits);
    }
"	@return this DateTimeFormatterBuilder	@return this DateTimeFormatterBuilder	0	1	5	4	25
protected Object convertTimeToMicrosPastMidnight(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0L; // return epoch } try { return MicroTime.toMicroOfDay(data); } catch (IllegalArgumentException e) { return handleUnknownData(column, fieldDefn, data); } }	"    protected Object convertTimeToMicrosPastMidnight(Column column, Field fieldDefn, Object data) {
        if ( data == null ) return null;
        try {
            return MicroTime.toMicroOfDay(data);
        } catch (IllegalArgumentException e) {
            return handleUnknownData(column, fieldDefn, data);
        }
    }
"	@return the converted value, or null if the conversion could not be made and the column allows nulls	@return the converted value, or null if the conversion could not be made	1	0	8	15	82
public static ChainFinder chain(Finder first, Finder second) { return new ChainFinder(first, second); }	"public static ChainMatcher chain(Matcher first, Matcher second) {
    return new ChainMatcher(first, second);
}"	@return a finder that uses the UiElement returned by first Finder as context for the second Finder	@return a matcher that uses the UiElement returned by first Matcher as context for the second Matcher	1	0	5	3	22
"protected Tree determineNonTrivialHead(Tree t, Tree parent) { String motherCat = tlp.basicCategory(t.label().value()); if (DEBUG) { System.err.println(""At "" + motherCat + "", my parent is "" + parent); } // do VPs with auxiliary as special case if ((motherCat.equals(""VP"") || motherCat.equals(""SQ"") || motherCat.equals(""SINV""))) { Tree[] kids = t.children(); // try to find if there is an auxiliary verb if (DEBUG) { System.err.println(""Semantic head finder: at VP""); System.err.println(""Class is "" + t.getClass().getName()); t.pennPrint(System.err); //System.err.println(""hasVerbalAuxiliary = "" + hasVerbalAuxiliary(kids, verbalAuxiliaries)); } // looks for auxiliaries if (hasVerbalAuxiliary(kids, verbalAuxiliaries) || hasPassiveProgressiveAuxiliary(kids, passiveAuxiliaries)) { // String[] how = new String[] {""left"", ""VP"", ""ADJP"", ""NP""}; // Including NP etc seems okay for copular sentences but is // problematic for other auxiliaries, like 'he has an answer' // But maybe doing ADJP is fine! String[] how = { ""left"", ""VP"", ""ADJP"" }; Tree pti = traverseLocate(kids, how, false); if (DEBUG) { System.err.println(""Determined head (case 1) for "" + t.value() + "" is: "" + pti); } if (pti != null) { return pti; } else { // System.err.println(""------""); // System.err.println(""SemanticHeadFinder failed to reassign head for""); // t.pennPrint(System.err); // System.err.println(""------""); } } // looks for copular verbs if (hasVerbalAuxiliary(kids, copulars) && ! isExistential(t, parent) && ! isWHQ(t, parent)) { String[] how; if (motherCat.equals(""SQ"")) { how = new String[]{""right"", ""VP"", ""ADJP"", ""NP"", ""WHADJP"", ""WHNP""}; } else { how = new String[]{""left"", ""VP"", ""ADJP"", ""NP"", ""WHADJP"", ""WHNP""}; } Tree pti = traverseLocate(kids, how, false); // don't allow a temporal to become head if (pti != null && pti.label() != null && pti.label().value().contains(""-TMP"")) { pti = null; } // In SQ, only allow an NP to become head if there is another one to the left (then it's probably predicative) if (motherCat.equals(""SQ"") && pti != null && pti.label() != null && pti.label().value().startsWith(""NP"")) { boolean foundAnotherNp = false; for (Tree kid : kids) { if (kid == pti) { break; } else if (kid.label() != null && kid.label().value().startsWith(""NP"")) { foundAnotherNp = true; break; } } if ( ! foundAnotherNp) { pti = null; } } if (DEBUG) { System.err.println(""Determined head (case 2) for "" + t.value() + "" is: "" + pti); } if (pti != null) { return pti; } else { if (DEBUG) { System.err.println(""------""); System.err.println(""SemanticHeadFinder failed to reassign head for""); t.pennPrint(System.err); System.err.println(""------""); } } } } Tree hd = super.determineNonTrivialHead(t, parent); // Heuristically repair punctuation heads Tree[] hdChildren = hd.children(); if (hdChildren != null && hdChildren.length > 0 && hdChildren[0].isLeaf()) { if (tlp.isPunctuationWord(hdChildren[0].label().value())) { Tree[] tChildren = t.children(); if (DEBUG) { System.err.printf(""head is punct: %s\n"", hdChildren[0].label()); } for (int i = tChildren.length - 1; i >= 0; i--) { if (!tlp.isPunctuationWord(tChildren[i].children()[0].label().value())) { hd = tChildren[i]; if (DEBUG) { System.err.printf(""New head: %s %s"", hd.label(), hd.children()[0].label()); } break; } } } } if (DEBUG) { System.err.println(""Determined head (case 3) for "" + t.value() + "" is: "" + hd); } return hd; }"	"  protected Tree determineNonTrivialHead(Tree t, Tree parent) {
    String motherCat = tlp.basicCategory(t.label().value());

    if (DEBUG) {
      System.err.println(""At "" + motherCat + "", my parent is "" + parent);
    }

    // Some conj expressions seem to make more sense with the ""not"" or
    // other key words as the head.  For example, ""and not"" means
    // something completely different than ""and"".  Furthermore,
    // downstream code was written assuming ""not"" would be the head...
    if (motherCat.equals(""CONJP"")) {
      for (TregexPattern pattern : headOfConjpTregex) {
        TregexMatcher matcher = pattern.matcher(t);
        if (matcher.matchesAt(t)) {
          return matcher.getNode(""head"");
        }
      }
      // if none of the above patterns match, use the standard method
    }

    if (motherCat.equals(""SBARQ"") || motherCat.equals(""SINV"")) {
      if (!makeCopulaHead) {
        for (TregexPattern pattern : headOfCopulaTregex) {
          TregexMatcher matcher = pattern.matcher(t);
          if (matcher.matchesAt(t)) {
            return matcher.getNode(""head"");
          }
        }
      }
      // if none of the above patterns match, use the standard method
    }

    // do VPs with auxiliary as special case
    if ((motherCat.equals(""VP"") || motherCat.equals(""SQ"") || motherCat.equals(""SINV""))) {
      Tree[] kids = t.children();
      // try to find if there is an auxiliary verb

      if (DEBUG) {
        System.err.println(""Semantic head finder: at VP"");
        System.err.println(""Class is "" + t.getClass().getName());
        t.pennPrint(System.err);
        //System.err.println(""hasVerbalAuxiliary = "" + hasVerbalAuxiliary(kids, verbalAuxiliaries));
      }

      // looks for auxiliaries
      Tree[] tmpFilteredChildren = null;
      if (hasVerbalAuxiliary(kids, verbalAuxiliaries, true) || hasPassiveProgressiveAuxiliary(kids)) {
        // String[] how = new String[] {""left"", ""VP"", ""ADJP"", ""NP""};
        // Including NP etc seems okay for copular sentences but is
        // problematic for other auxiliaries, like 'he has an answer'
        String[] how ;
        if (hasVerbalAuxiliary(kids, copulars, true)) {
          // Only allow ADJP in copular constructions
          // In constructions like ""It gets cold"", ""get"" should be the head
          how = new String[]{ ""left"", ""VP"", ""ADJP"" };
        } else {
          how = new String[]{ ""left"", ""VP"" };
        }

        if (tmpFilteredChildren == null) {
          tmpFilteredChildren = ArrayUtils.filter(kids, REMOVE_TMP_AND_ADV);
        }
        Tree pti = traverseLocate(tmpFilteredChildren, how, false);
        if (DEBUG) {
          System.err.println(""Determined head (case 1) for "" + t.value() + "" is: "" + pti);
        }
        if (pti != null) {
          return pti;
        // } else {
          // System.err.println(""------"");
          // System.err.println(""SemanticHeadFinder failed to reassign head for"");
          // t.pennPrint(System.err);
          // System.err.println(""------"");
        }
      }

      // looks for copular verbs
      if (hasVerbalAuxiliary(kids, copulars, false) && ! isExistential(t, parent) && ! isWHQ(t, parent)) {
        String[] how;
        if (motherCat.equals(""SQ"")) {
          how = new String[]{""right"", ""VP"", ""ADJP"", ""NP"", ""WHADJP"", ""WHNP""};
        } else {
          how = new String[]{""left"", ""VP"", ""ADJP"", ""NP"", ""WHADJP"", ""WHNP""};
        }
        // Avoid undesirable heads by filtering them from the list of potential children
        if (tmpFilteredChildren == null) {
          tmpFilteredChildren = ArrayUtils.filter(kids, REMOVE_TMP_AND_ADV);
        }
        Tree pti = traverseLocate(tmpFilteredChildren, how, false);
        // In SQ, only allow an NP to become head if there is another one to the left (then it's probably predicative)
        if (motherCat.equals(""SQ"") && pti != null && pti.label() != null && pti.label().value().startsWith(""NP"")) {
            boolean foundAnotherNp = false;
            for (Tree kid : kids) {
              if (kid == pti) {
                break;
              } else if (kid.label() != null && kid.label().value().startsWith(""NP"")) {
                foundAnotherNp = true;
                break;
              }
            }
          if ( ! foundAnotherNp) {
            pti = null;
          }
        }

        if (DEBUG) {
          System.err.println(""Determined head (case 2) for "" + t.value() + "" is: "" + pti);
        }
        if (pti != null) {
          return pti;
        } else {
          if (DEBUG) {
            System.err.println(""------"");
            System.err.println(""SemanticHeadFinder failed to reassign head for"");
            t.pennPrint(System.err);
            System.err.println(""------"");
          }
        }
      }
    }

    Tree hd = super.determineNonTrivialHead(t, parent);

    /* ----
    // This should now be handled at the AbstractCollinsHeadFinder level, so see if we can comment this out
    // Heuristically repair punctuation heads
    Tree[] hdChildren = hd.children();
    if (hdChildren != null && hdChildren.length > 0 &&
        hdChildren[0].isLeaf()) {
      if (tlp.isPunctuationWord(hdChildren[0].label().value())) {
         Tree[] tChildren = t.children();
         if (DEBUG) {
           System.err.printf(""head is punct: %s\n"", hdChildren[0].label());
         }
         for (int i = tChildren.length - 1; i >= 0; i--) {
           if (!tlp.isPunctuationWord(tChildren[i].children()[0].label().value())) {
             hd = tChildren[i];
             if (DEBUG) {
               System.err.printf(""New head of %s is %s%n"", hd.label(), hd.children()[0].label());
             }
             break;
           }
         }
      }
    }
    */

    if (DEBUG) {
      System.err.println(""Determined head (case 3) for "" + t.value() + "" is: "" + hd);
    }
    return hd;
  }
"	@return The parse tree that is the head	@return The parse tree that is the head	0	1	17	114	1034
public final int getValue(long timestamp) { compute(timestamp, timestamp); Score s = getComputedByTimestamp(timestamp); if (s == null) throw new IllegalStateException(); return s.getValue(); }	"public int getValue(long timestamp) {
    computeAll();
    String[] args = { habit.getId().toString(), Long.toString(timestamp) };
    return SQLiteUtils.intQuery(STR, args);
}"	@return score value for that day	@return score for that day	1	0	6	7	41
public JsonWriter value(String value) throws IOException { if (value == null) { return nullValue(); } if (promoteNameToValue) { return name(value); } writeDeferredName(); beforeValue(false); string(value); pathIndices[stackSize - 1]++; return this; }	"  public JsonWriter value(String value) throws IOException {
    if (value == null) {
      return nullValue();
    }
    writeDeferredName();
    beforeValue(false);
    string(value);
    pathIndices[stackSize - 1]++;
    return this;
  }
"	@return this writer.	@return this writer.	0	1	7	14	61
public static int[] getViewToHeaderPosition(JTextArea view, int start, int end) { validateView(view); validateStartEnd(start, end); if (!isValidStartEndForLength(start, end, view.getDocument().getLength())) { return INVALID_POSITION; } return getViewToHeaderPositionImpl(view, start, end); }	"    public static int[] getViewToHeaderPosition(JTextArea view, int start, int end) {
        validateView(view);
        validateStartEnd(start, end, view.getDocument().getLength());
        return getViewToHeaderPositionImpl(view, start, end);
    }
"	@return the positions offset for the header, or  #INVALID_POSITION if the  start or  end is greater than the length of the  view	@return the positions offset for the header	1	0	6	11	63
"public String toEnumVarName(String value, String datatype) { String modified; if (value.length() == 0) { modified = ""EMPTY""; } else { modified = value; modified = sanitizeKotlinSpecificNames(modified); } switch (getEnumPropertyNaming()) { case original: // NOTE: This is provided as a last-case allowance, but will still result in reserved words being escaped. modified = value; break; case camelCase: // NOTE: Removes hyphens and underscores modified = camelize(modified, true); break; case PascalCase: // NOTE: Removes hyphens and underscores String result = camelize(modified); modified = titleCase(result); break; case snake_case: // NOTE: Removes hyphens modified = underscore(modified); break; case UPPERCASE: modified = modified.toUpperCase(); break; } if (reservedWords.contains(modified)) { return escapeReservedWord(modified); } return modified; }"	"    public String toEnumVarName(String value, String datatype) {
        String modified;
        if (value.length() == 0) {
            modified = ""EMPTY"";
        } else {
            modified = value;

            for (Map.Entry<String, String> specialCharacters : specialCharReplacements.entrySet()) {
                // Underscore is the only special character we'll allow
                if (!specialCharacters.getKey().equals(""_"")) {
                    modified = modified.replaceAll(""\\Q"" + specialCharacters.getKey() + ""\\E"", specialCharacters.getValue());
                }
            }

            // Fallback, replace unknowns with underscore.
            modified = modified.replaceAll(""\\W+"", ""_"");
            if (modified.matches(""\\d.*"")) {
                modified = ""_"" + modified;
            }

            // _, __, and ___ are reserved in Kotlin. Treat all names with only underscores consistently, regardless of count.
            if (modified.matches(""^_*$"")) {
                modified = modified.replaceAll(""\\Q_\\E"", ""Underscore"");
            }
        }

        switch (getEnumPropertyNaming()) {
            case original:
                // NOTE: This is provided as a last-case allowance, but will still result in reserved words being escaped.
                modified =  value;
                break;
            case camelCase:
                // NOTE: Removes hyphens and underscores
                modified =  camelize(modified, true);
                break;
            case PascalCase:
                // NOTE: Removes hyphens and underscores
                String result = camelize(modified);
                modified =  result.substring(0, 1).toUpperCase() + result.substring(1);
                break;
            case snake_case:
                // NOTE: Removes hyphens
                modified = underscore(modified);
                break;
            case UPPERCASE:
                modified = modified.toUpperCase();
                break;
        }

        if (reservedWords.contains(modified)) {
            // TODO: Allow enum escaping as an option (e.g. backticks vs append/prepend underscore vs match model property escaping).
            return String.format(""`%s`"", modified);
        }

        return modified;
    }
"	@return the sanitized variable name for enum	@return the sanitized variable name for enum	0	1	8	39	175
"private ZapTextArea getTxtOutput() { if (txtOutput == null) { txtOutput = new ZapTextArea(); txtOutput.setEditable(false); txtOutput.setLineWrap(true); txtOutput.setFont(new java.awt.Font(""Dialog"", java.awt.Font.PLAIN, 12)); txtOutput.setName(""""); txtOutput.addMouseListener(new java.awt.event.MouseAdapter() { public void mousePressed(java.awt.event.MouseEvent e) { if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0) { // right mouse button View.getSingleton().getPopupMenu().show(e.getComponent(), e.getX(), e.getY()); } } }); } return txtOutput; }"	"	private JTextArea getTxtOutput() {
		if (txtOutput == null) {
			txtOutput = new JTextArea();
			txtOutput.setEditable(false);
			txtOutput.setLineWrap(true);
			txtOutput.setFont(new java.awt.Font(""Dialog"", java.awt.Font.PLAIN, 12));
			txtOutput.setName("""");
			txtOutput.addMouseListener(new java.awt.event.MouseAdapter() { 
				public void mousePressed(java.awt.event.MouseEvent e) {    
				    if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0) {  // right mouse button
				        View.getSingleton().getPopupMenu().show(e.getComponent(), e.getX(), e.getY());
				    }	
				}
			});
		}
		return txtOutput;
	}
"	@return javax.swing.ZapTextArea	@return javax.swing.JTextArea	1	0	14	18	135
public static boolean uninstallAddOnFiles(AddOn addOn, AddOnUninstallationProgressCallback callback) { return uninstallAddOnFiles(addOn, callback, null); }	"    public static boolean uninstallAddOnFiles(AddOn addOn, AddOnUninstallationProgressCallback callback) {
        Validate.notNull(addOn, ""Parameter addOn must not be null."");
        validateCallbackNotNull(callback);

        List<String> fileNames = addOn.getFiles();
        if (fileNames == null || fileNames.isEmpty()) {
            return true;
        }

        callback.filesWillBeRemoved(fileNames.size());
        boolean uninstalledWithoutErrors = true;
        for (String name : fileNames) {
            if (name == null) {
                continue;
            }
            logger.debug(""Uninstall file: "" + name);
            File file = new File(Constant.getZapHome(), name);
            try {
                File parent = file.getParentFile();
                if (file.exists() && !file.delete()) {
                    logger.error(""Failed to delete: "" + file.getAbsolutePath());
                    uninstalledWithoutErrors = false;
                }
                callback.fileRemoved();
                if (parent.isDirectory() && parent.list().length == 0) {
                    logger.debug(""Deleting: "" + parent.getAbsolutePath());
                    if (!parent.delete()) {
                        // Ignore - check for <= 2 as on *nix '.' and '..' are returned
                        logger.debug(""Failed to delete: "" + parent.getAbsolutePath());
                    }
                }
                deleteEmptyDirsCreatedForAddOnFiles(file);
            } catch (Exception e) {
                logger.error(""Failed to uninstall file "" + file.getAbsolutePath(), e);
            }
        }

        Control.getSingleton().getExtensionLoader().addonFilesRemoved();

        return uninstalledWithoutErrors;
    }
"	@return  true if no error occurred while removing the files,  false otherwise.	@return true if not error occurred while remove the files, false otherwise.	1	0	5	4	23
public Expression getKey() { return key; }	"public StringLiteral getKey() {
    return key;
}"	@return the expression computing the key with which the value will be associated	@return the key with which the value will be associated	1	0	4	3	10
@SuppressWarnings(STR) public V getInstance() { if (instance == null && element.getAttribute(STR) != null) { try { instance = (V) element.createExecutableExtension(STR); } catch (Exception e) { IStatus status = new Status(IStatus.ERROR, Activator.PLUGIN_ID, NLS.bind(TcfPluginMessages.Extension_error_invalidExtensionPoint, element.getDeclaringExtension().getUniqueIdentifier()), e); Activator.getDefault().getLog().log(status); } } return instance; }	"@SuppressWarnings(STR)
public V getInstance() {
    if (fInstance == null) {
        IConfigurationElement element = getConfigurationElement();
        assert element != null;
        if (element != null && element.getAttribute(STR) != null) {
            try {
                fInstance = (V) element.createExecutableExtension(STR);
            } catch (Exception e) {
                IStatus status = new Status(IStatus.ERROR, Activator.PLUGIN_ID, NLS.bind(TcfPluginMessages.Extension_error_invalidExtensionPoint, element.getDeclaringExtension().getUniqueIdentifier()), e);
                Activator.getDefault().getLog().log(status);
            }
        }
    }
    return fInstance;
}"	@return The extension class instance. Might be <code>null</code> if the instantiation fails.	@return The extension class instance. Might be <code>null</code> if the instanciation fails.	1	0	12	12	92
"public static String toString(byte[] bytes, int base) { char[] chars; int j = 0; switch (base) { case 2: chars = new char[bytes.length * 8]; for (byte b : bytes) { chars[j++] = digits[(b & 0x80) >> 7]; chars[j++] = digits[(b & 0x40) >> 6]; chars[j++] = digits[(b & 0x20) >> 5]; chars[j++] = digits[(b & 0x10) >> 4]; chars[j++] = digits[(b & 0x08) >> 3]; chars[j++] = digits[(b & 0x04) >> 2]; chars[j++] = digits[(b & 0x02) >> 1]; chars[j++] = digits[b & 0x01]; } break; case 16: chars = new char[bytes.length * 2]; for (byte b : bytes) { chars[j++] = digits[(b & 0xF0) >> 4]; chars[j++] = digits[b & 0x0F]; } break; default: throw new IllegalArgumentException(""bad base "" + base); } return new String(chars, 0, j); }"	"  public static String toString(byte[] bytes) {
    char[] chars = new char[bytes.length * 2];
    for (int i = 0, j = 0; i < bytes.length; i++) {
      byte b = bytes[i];
      chars[j++] = digits[(b & 0xF0) >> 4];
      chars[j++] = digits[b & 0x0F];
    }
    return new String(chars);
  }
"	@return String	@return String	0	1	13	30	257
public String getSymbol() { return this.symbol != null ? this.symbol.getIdentifier() : null; }	"public TacticalSymbol getSymbol() {
    return this.symbol;
}"	@return The identifier of a symbol drawn at the center of the range fan. May be null.	@return The symbol drawn at the center of the range fan. May be null.	1	0	7	3	21
List<ContextPanelFactory> getContextPanelFactories() { return unmodifiableList(contextPanelFactories); }	"    List<ContextPanelFactory> getContextPanelFactories() {
        if (contextPanelFactories == null) {
            return Collections.emptyList();
        }
        return Collections.unmodifiableList(contextPanelFactories);
    }
"	@return an unmodifiable  List containing the added  ContextPanelFactorys, never  null.	@return an unmodifiable List containing the added ContextPanelFactorys, never null.	0	1	5	4	13
@Override public boolean equals(Object other) { if (this == other) { return true; } if (other instanceof PwPair) { PwPair otherPwPair = (PwPair) other; return getRank() == otherPwPair.getRank() && mUrlDevice.equals(otherPwPair.mUrlDevice) && mPwsResult.equals(otherPwPair.mPwsResult); } return false; }	"public boolean equals(Object other) {
    if (other instanceof PwPair) {
        PwPair otherPwPair = (PwPair) other;
        return getRank() == otherPwPair.getRank();
    }
    return false;
}"	@return true if the PwPairs are equal.	@return true if the ranks are equal.	1	0	9	11	64
public NumberExpression<Integer> locate(Expression<String> str, NumberExpression<Integer> start) { return NumberOperation.create(Integer.class, Ops.StringOps.LOCATE2, str, mixin, start); }	"    public NumberExpression<Integer> locate(Expression<String> str, NumberExpression<Integer> start) {
        return NumberOperation.create(Integer.class, Ops.StringOps.LOCATE2, str, this, start);
    }
"	@return locate(str, this, start)	@return locate(str, this, start)	0	1	6	4	33
@NonNull protected List<Action> retrieveActions(@NonNull SCMSourceEvent event, @NonNull TaskListener listener) throws IOException, InterruptedException { return Collections.emptyList(); }	"@NonNull
protected Map<Class<? extends Action>, Action> retrieveActions(@NonNull TaskListener listener) throws IOException, InterruptedException {
    return Collections.emptyMap();
}"	@return the list of {@link Action} instances to persist.	@return the map of {@link Action} instances to persist, keyed by the class of action. Keys with {@code null} values indicate actions that should be removed if present.	1	0	5	4	29
public static W3CWidget getWidget(String metadata, String shindig) throws Exception { JSONObject gadget = null; JSONObject response = new JSONObject(metadata); JSONArray gadgets = response.getJSONArray(STR); if (gadgets.length() == NUM) return null; gadget = gadgets.getJSONObject(NUM); return new GadgetAdapter(gadget, shindig); }	"public static Widget getWidget(String metadata, String shindig) throws Exception {
    JSONObject gadget = null;
    Widget widget = null;
    JSONObject response = new JSONObject(metadata);
    JSONArray gadgets = response.getJSONArray(STR);
    if (gadgets.length() > NUM) {
        gadget = gadgets.getJSONObject(NUM);
        if (gadget.has(STR))
            throw new Exception(STR);
        widget = new Widget();
        String title = STR;
        int height = NUM;
        int width = NUM;
        String author = STR;
        String description = STR;
        String icon = DEFAULT_ICON;
        if (!gadget.has(STR))
            throw new Exception(STR);
        if (gadget.getString(STR) == null || gadget.getString(STR).equals(STR))
            throw new Exception(STR);
        try {
            @SuppressWarnings(STR)
            URL url = new URL(gadget.getString(STR));
        } catch (Exception e) {
            throw new Exception(STR);
        }
        widget.setGuid(gadget.getString(STR));
        StartFile sf = new StartFile();
        sf.setWidget(widget);
        sf.setUrl(shindig + STR + gadget.getString(STR) + STR);
        if (gadget.has(STR))
            if (gadget.getInt(STR) != NUM)
                height = gadget.getInt(STR);
        if (gadget.has(STR))
            if (gadget.getInt(STR) != NUM)
                width = gadget.getInt(STR);
        if (gadget.has(STR)) {
            if (gadget.getString(STR) != null) {
                if (!(gadget.getString(STR).trim()).equals(STR)) {
                    author = gadget.getString(STR);
                }
            }
        }
        if (gadget.has(STR)) {
            if (gadget.getString(STR) != null) {
                if (!(gadget.getString(STR).trim()).equals(STR)) {
                    title = gadget.getString(STR);
                }
            }
        }
        if (gadget.has(STR)) {
            if (gadget.getString(STR) != null) {
                if (!(gadget.getString(STR).trim()).equals(STR)) {
                    title = gadget.getString(STR);
                }
            }
        }
        if (gadget.has(STR)) {
            if (gadget.getString(STR) != null) {
                if (!(gadget.getString(STR).trim()).equals(STR)) {
                    title = gadget.getString(STR);
                }
            }
        }
        if (gadget.has(STR)) {
            if (gadget.getString(STR) != null) {
                if (!(gadget.getString(STR).trim()).equals(STR)) {
                    icon = gadget.getString(STR);
                }
            }
        }
        widget.setMaximize(false);
        widget.setHeight(height);
        widget.setWidth(width);
        Name name = new Name();
        name.setWidget(widget);
        name.setName(title);
        Description desc = new Description();
        desc.setWidget(widget);
        desc.setContent(description);
        WidgetIcon wicon = new WidgetIcon();
        wicon.setSrc(icon);
        wicon.setWidget(widget);
        widget.setWidgetAuthor(author);
        widget.save();
        sf.save();
        name.save();
        wicon.save();
        desc.save();
    }
    return widget;
}"	@return a W3CWidget instance	@return a Widget instance	1	0	6	9	62
static public IStructuredTextExpert getStatefulExpert(StructuredTextTypeHandler handler, StructuredTextEnvironment environment) { if (environment == null) environment = StructuredTextEnvironment.DEFAULT; return new StructuredTextImpl(handler, environment, true); }	"static public ISTextExpert getStatefulExpert(STextTypeHandler handler, STextEnvironment environment) {
    if (environment == null)
        environment = STextEnvironment.DEFAULT;
    return new STextImpl(handler, environment, true);
}"	@return the IStructuredTextExpert instance.	@return the ISTextExpert instance.	1	0	6	5	33
"public boolean isJsonMime(String mime) { String jsonMime = ""(?i)^(application/json|[^;/ \t]+/[^;/ \t]+[+]json)[ \t]*(;.*)?$""; return mime != null && (mime.matches(jsonMime) || mime.equals(""*/*"")); }"	"  public boolean isJsonMime(String mime) {
    String jsonMime = ""(?i)^(application/json|[^;/ \t]+/[^;/ \t]+[+]json)[ \t]*(;.*)?$"";
    return mime != null && (mime.matches(jsonMime) || mime.equalsIgnoreCase(""application/json-patch+json""));
  }
"	@return True if the MIME type is JSON	@return True if the MIME type is JSON	0	1	7	5	82
public ErrorLevel getLevel() { return level; }	"public VirErrorLevel getLevel() {
    return level;
}"	@return a ErrorLevel	@return a VirErrorLevel	1	0	4	3	10
@Override public AbstractObjectParser executeSQL() throws Exception { if (isTable == false) { sqlReponse = new JSONObject(sqlRequest); } else { try { sqlReponse = onSQLExecute(); } catch (Exception e) { Log.e(TAG, STR); if (e instanceof NotExistException) { sqlReponse = null; } else { throw e; } } if (drop) { sqlReponse = null; } } return this; }	"@Override
public AbstractObjectParser executeSQL() throws Exception {
    return executeSQL(NUM, NUM, NUM);
}"	@return this	@return {@link #executeSQL(int, int, int)}	1	0	11	21	80
public ArrayList<ErrorMsg> getWarnings() { return _parser.getWarnings(); }	"public Vector getWarnings() {
    return _parser.getWarnings();
}"	@return A List containing all compile error messages	@return A Vector containing all compile error messages	1	0	5	3	14
"public static DateTimeZone getInstance(String id) throws IllegalArgumentException { if (id == null) { return getDefault(); } if (id.equals(""UTC"")) { return DateTimeZone.UTC; } DateTimeZone zone = cProvider.getZone(id); if (zone != null) { return zone; } if (id.startsWith(""+"") || id.startsWith(""-"")) { int offset = -(int) offsetFormatter().parseMillis(id); if (offset == 0L) { return DateTimeZone.UTC; } else { id = offsetFormatter().print(0, UTC, offset); return fixedOffsetZone(id, offset); } } throw new IllegalArgumentException(""The datetime zone id is not recognised: "" + id); }"	"    public static DateTimeZone getInstance(String id) throws IllegalArgumentException {
        if (id == null) {
            return getDefault();
        }
        if (id.equals(""UTC"")) {
            return DateTimeZone.UTC;
        }
        DateTimeZone zone = cProvider.getZone(id);
        if (zone != null) {
            return zone;
        }
        if (id.startsWith(""+"") || id.startsWith(""-"")) {
            int offset = -(int) offsetFormatter().parseMillis(id);
            if (offset == 0L) {
                return DateTimeZone.UTC;
            } else {
                id = offsetFormatter().print(0, UTC, offset);
                return new FixedDateTimeZone(id, null, offset, offset);
            }
        }
        throw new IllegalArgumentException(""The datetime zone id is not recognised: "" + id);
    }
"	@return the DateTimeZone object for the ID	@return the DateTimeZone object for the ID	0	1	11	23	147
private static ObjectName asObjectName(Object componentKey) throws MalformedObjectNameException { if (componentKey == null) { throw new NullPointerException(STR); } if (componentKey instanceof ObjectName) { return (ObjectName) componentKey; } if (componentKey instanceof Class) { Class clazz = (Class) componentKey; return new ObjectName(STR + clazz.getName()); } else { String text = componentKey.toString(); if (text.indexOf(STR) == -NUM) { text = STR + text; } return new ObjectName(text); } }	"public static ObjectName asObjectName(Object key) throws MalformedObjectNameException {
    if (key == null) {
        throw new NullPointerException(STR);
    }
    if (key instanceof ObjectName) {
        return (ObjectName) key;
    }
    if (key instanceof Class) {
        Class clazz = (Class) key;
        return new ObjectName(STR + clazz.getName());
    } else {
        String text = key.toString();
        if (text.indexOf(STR) == -NUM) {
            text = STR + text;
        }
        return new ObjectName(text);
    }
}"	@return an ObjectName based on the given componentKey	@return an ObjectName based on the given key	1	0	10	18	101
public double valueSum() { // We want the exp(log-sum-exp), for stability // This rearranges to exp(a)*(sum-exp) double max = 0.0; for (int[] assignment : this) { double v = getAssignmentLogValue(assignment); if (v > max) { max = v; } } double sumExp = 0.0; for (int[] assignment : this) { sumExp += Math.exp(getAssignmentLogValue(assignment) - max); } return sumExp * Math.exp(max); }	"    public double valueSum() {

        // We want the exp(log-sum-exp), for stability
        // This rearranges to exp(a)*(sum-exp)

        double max = 0.0;
        for (int[] assignment : this) {
            double v = getAssignmentLogValue(assignment);
            if (v > max) {
                max = v;
            }
        }

        double sumExp = 0.0;
        for (int[] assignment : this) {
            sumExp += FastMath.exp(getAssignmentLogValue(assignment) - max);
        }

        return sumExp * FastMath.exp(max);
    }
"	@return the sum of all values for all assignments to the TableFactor	@return the sum of all values for all assignments to the TableFactor	0	1	10	21	109
public static <T, N extends TreeNode<T>> String toString(final N inputNode, final Function<N, String> toString) { final StringBuilder builder = new StringBuilder(); depthFirst(inputNode, new TreeVisitor<N>() { final Set<Integer> depths = Sets.newHashSet(); @SuppressWarnings(STR) @Override public void onNode(final int depth, final N node) { if (!isRoot(node) && !isLeaf(node) && !isLastChild(node)) { this.depths.add(depth); } else { this.depths.remove(depth); } builder.append(indent(depth)); final String nodeString = toString.apply(node); builder.append(STR).append(nodeString).append(Strings2.NEW_LINE); } private String indent(final int depth) { final StringBuilder b = new StringBuilder(); for (int i = NUM; i < depth; i++) { if (this.depths.contains(Integer.valueOf(i))) { b.append(STR); } else { b.append(STR); } } return b.toString(); } }); return builder.toString(); }	"public static <T, N extends TreeNode<T>> String toString(final N node) {
    final Function<N, String> function = new Function<N, String>() {

        @Override
        public String apply(final N arg0) {
            return arg0.toString();
        }
    };
    return toString(node, function);
}"	@return a string representation of the tree	@return the node as a string	1	0	13	33	224
public ArrayList filterContent(String key) { return this.of.filter(key); }	"public ArrayList filterContent(String prefix) {
    if (STR.equals(prefix)) {
        this.filteredItemsBuffer = new ArrayList(getItemIds());
        return this.filteredItemsBuffer;
    } else if (items != null) {
        this.filteredItemsBuffer = new ArrayList();
        for (Iterator iter = items.getItemIds().iterator(); iter.hasNext(); ) {
            Object id = iter.next();
            Item item = getItem(id);
            String test = STR;
            if (getItemCaptionMode() == ITEM_CAPTION_MODE_PROPERTY)
                test = item.getItemProperty(getItemCaptionPropertyId()).getValue().toString().trim();
            else
                test = String.valueOf(id);
            if (test.toLowerCase().startsWith(prefix)) {
                this.filteredItemsBuffer.add(id);
            }
        }
    }
    return this.filteredItemsBuffer;
}"	@return All item ids filtered by given key.	@return All item ids filtered by given prefix.	1	0	6	3	17
@Override public boolean equals(Object obj) { if (!(obj instanceof NSNumber)) return false; NSNumber n = (NSNumber) obj; return type == n.type && longValue == n.longValue && doubleValue == n.doubleValue && boolValue == n.boolValue; }	"@Override
public boolean equals(Object obj) {
    return obj.getClass().equals(NSNumber.class) && obj.hashCode() == hashCode();
}"	@return Whether the objects are equal in terms of numeric value and type.	@return Whether the objects are equal in terms of numeric value.	1	0	8	7	50
"public String escapeReservedWord(String name) { if(this.reservedWords().contains(name)) { name = ""_"" + name; } return name; }"	"    public String escapeReservedWord(String name) {           
        if(this.reservedWordsMappings().containsKey(name)) {
            return this.reservedWordsMappings().get(name);
        }
        return ""_"" + name;
    }
"	@return the escaped term	@return the escaped term	0	1	8	7	32
public final long querySingleLong(String sqlCmd, long defVal, Connection conn) { return querySingleLong(sqlCmd, null, defVal, conn); }	"public final long querySingleLong(String sqlCmd, long defVal, Connection conn) {
    Object value = querySingleValue(sqlCmd, conn);
    return ((value != null) ? Long.parseLong(value.toString()) : defVal);
}"	@return the result as a long value	@return the result as a long value, if no result the long value 0	1	0	5	3	28
protected Object convertTimestampToEpochMillis(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0L; // return epoch } try { return Timestamp.toEpochMillis(data); } catch (IllegalArgumentException e) { return handleUnknownData(column, fieldDefn, data); } }	"    protected Object convertTimestampToEpochMillis(Column column, Field fieldDefn, Object data) {
        if ( data == null ) return null;
        try {
            return Timestamp.toEpochMillis(data);
        } catch (IllegalArgumentException e) {
            return handleUnknownData(column, fieldDefn, data);
        }
    }
"	@return the converted value, or null if the conversion could not be made and the column allows nulls	@return the converted value, or null if the conversion could not be made	1	0	8	15	82
public InstrumentationExecutionParameters withNewState(InstrumentationState instrumentationState) { return new InstrumentationExecutionParameters(this.getExecutionInput(), this.schema, instrumentationState); }	"    public InstrumentationExecutionParameters withNewState(InstrumentationState instrumentationState) {
        return new InstrumentationExecutionParameters(this.getExecutionInput(), instrumentationState);
    }
"	@return a new parameters object with the new state	@return a new parameters object with the new state	0	1	6	4	24
public T sum() { return sum; }	"public long sum() {
    return sum;
}"	@return total of values seen	@return long total of values seen	1	0	4	3	10
public String getJpaVersion() { return jpaVersion; }	"public JpaVersion getJpaVersion() {
    return jpaVersion;
}"	@return possible object is {@link String }	@return possible object is {@link JpaVersion }	1	0	4	3	10
protected RecordCommitter buildRecordCommitter(OffsetStorageWriter offsetWriter, SourceTask task, Duration commitTimeout) { return new RecordCommitter() { @Override public synchronized void markProcessed(SourceRecord record) throws InterruptedException { task.commitRecord(record); recordsSinceLastCommit += 1; offsetWriter.offset(record.sourcePartition(), record.sourceOffset()); } @Override public synchronized void markBatchFinished() { maybeFlush(offsetWriter, offsetCommitPolicy, commitTimeout, task); } }; }	"    protected RecordCommitter buildRecordCommitter(OffsetStorageWriter offsetWriter, SourceTask task, Duration commitTimeout) {
        Object lock = this;
        return new RecordCommitter() {
            @Override
            public void markProcessed(SourceRecord record) throws InterruptedException {
                synchronized (lock) {
                    task.commitRecord(record);
                    recordsSinceLastCommit += 1;
                    offsetWriter.offset(record.sourcePartition(), record.sourceOffset());
                }
            }

            @Override
            public void markBatchFinished() {
                synchronized (lock) {
                    maybeFlush(offsetWriter, offsetCommitPolicy, commitTimeout, task);
                }
            }
        };
    }
"	@return the new recordCommitter to be used for a given batch	@return the new recordCommitter to be used for a given batch	0	1	8	16	82
InputStream openSourceFile(String path) throws IOException { if (path.startsWith(STR)) { String rest = path.substring(STR.length()); File fileInGenDir = new File(getGenDir(), rest); if (!fileInGenDir.isFile()) { return null; } return new BufferedInputStream(new FileInputStream(fileInGenDir)); } else { URL resource = recompiler.getResourceLoader().getResource(path); if (resource == null) { return null; } return resource.openStream(); } }	"InputStream openSourceFile(String resourceName) throws IOException {
    URL resource = recompiler.getResourceLoader().getResource(resourceName);
    return resource == null ? null : resource.openStream();
}"	@return bytes in the file, or null if there's no such source file.	@return a stream for reading the resource, or null if not found.	1	0	9	16	97
protected Object convertTimeToMicrosPastMidnight(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0L; // return epoch } try { return MicroTime.toMicroOfDay(data, adjuster); } catch (IllegalArgumentException e) { return handleUnknownData(column, fieldDefn, data); } }	"    protected Object convertTimeToMicrosPastMidnight(Column column, Field fieldDefn, Object data) {
        if (data == null) {
            data = fieldDefn.schema().defaultValue();
        }
        if (data == null) {
            if (column.isOptional()) return null;
            return 0L; // return epoch
        }
        try {
            return MicroTime.toMicroOfDay(data);
        } catch (IllegalArgumentException e) {
            return handleUnknownData(column, fieldDefn, data);
        }
    }
"	@return the converted value, or null if the conversion could not be made and the column allows nulls	@return the converted value, or null if the conversion could not be made and the column allows nulls	0	1	8	15	84
public Map<String, TopicConfig> getTopicConfigs() { return Collections.unmodifiableMap(topicConfigs); }	"public Map<String, TopicConfig> getTopicConfigs() {
    return Collections.unmodifiableMap(mapTopicConfigs);
}"	@return the topicConfigs	@return the mapTopicConfigs	1	0	5	3	17
"private static Pattern buildShallowIndexPattern(String pattern, boolean wordBoundary) { return Pattern.compile( ""("" + ( wordBoundary ? ""\\b"" : """" ) + pattern + ( wordBoundary ? ""\\b"" : """" ) + "")(?![^\\(|\\[]*(\\)|\\]))"", Pattern.CASE_INSENSITIVE ); }"	"	private static Pattern buildShallowIndexPattern(String pattern, boolean wordBoundardy) {
		return Pattern.compile(
				""("" +
				( wordBoundardy ? ""\\b"" : """" ) +
				pattern +
				"")(?![^\\(|\\[]*(\\)|\\]))"",
				Pattern.CASE_INSENSITIVE
		);
	}
"	@return Compiled  Pattern.	@return Compiled Pattern.	0	1	10	11	81
public Node getFirstNode() { return m_node1; }	"public NodeItem getFirstNode() {
    return m_node1;
}"	@return the first (source) VisualItem	@return the first (source) GraphItem	1	0	4	3	10
public GrammaticalStructureFactory grammaticalStructureFactory(Predicate<String> puncFilter) { if (generateOriginalDependencies) { return new EnglishGrammaticalStructureFactory(puncFilter); } else { return new UniversalEnglishGrammaticalStructureFactory(puncFilter); } }	"  public GrammaticalStructureFactory grammaticalStructureFactory(Predicate<String> puncFilter) {
    return new EnglishGrammaticalStructureFactory(puncFilter);
  }
"	@return A GrammaticalStructure suitable for this language/treebank.	@return A GrammaticalStructure suitable for this language/treebank.	0	1	7	8	33
public static YourKitContext startProfile(boolean enableStackTelemetry, boolean enableCPUProfilling, boolean enableAllocationRecording) { Controller controller; try { controller = new Controller(); } catch (Exception e) { LOG.info(STR, e); return null; } try { if (enableStackTelemetry) { controller.enableStackTelemetry(); LOG.info(STR); } } catch (Exception e) { LOG.info(STR, e); } try { if (enableCPUProfilling) { controller.startCPUProfiling(ProfilingModes.CPU_SAMPLING, Controller.DEFAULT_FILTERS, Controller.DEFAULT_WALLTIME_SPEC); LOG.info(STR); } } catch (Exception e) { LOG.info(STR, e); } try { if (enableAllocationRecording) { controller.startAllocationRecording(true, ALLOCATION_RECORDING_INTERVAL, false, -NUM, true, false); LOG.info(STR); } } catch (Exception e) { LOG.info(STR, e); } return new YourKitContext(controller); }	"public static YourKitContext startProfile(GiraphConfiguration conf) {
    Controller controller = null;
    try {
        controller = new Controller();
        controller.enableStackTelemetry();
        controller.startCPUProfiling(ProfilingModes.CPU_SAMPLING, Controller.DEFAULT_FILTERS);
        LOG.debug(STR);
    } catch (Exception e) {
        LOG.debug(STR, e);
    }
    return new YourKitContext(controller);
}"	@return profiler context, or null if controller cannot be created	@return profiler context	1	0	8	34	178
"public ConcurrentSecondLevelCacheStatisticsImpl getSecondLevelCacheStatistics(String regionName) { ConcurrentSecondLevelCacheStatisticsImpl stat = secondLevelCacheStatistics.get( regionName ); if ( stat == null ) { if ( sessionFactory == null ) { return null; } final EntityRegionAccessStrategy entityRegionAccess = sessionFactory.getCache().getEntityRegionAccess( regionName ); final CollectionRegionAccessStrategy collectionRegionAccess = sessionFactory.getCache().getCollectionRegionAccess( regionName ); if ( entityRegionAccess == null && collectionRegionAccess == null ) { final QueryCache queryCache = sessionFactory.getCache().getQueryCache( regionName ); if ( queryCache == null ) { return null; } final Region region = queryCache.getRegion(); if ( region == null ) { throw new IllegalArgumentException( ""Could not resolve region name ["" + regionName + ""]"" ); } stat = new ConcurrentSecondLevelCacheStatisticsImpl( region, null, null ); } else { final Region region = entityRegionAccess != null ? entityRegionAccess.getRegion() : collectionRegionAccess.getRegion(); stat = new ConcurrentSecondLevelCacheStatisticsImpl( region, entityRegionAccess, collectionRegionAccess ); } ConcurrentSecondLevelCacheStatisticsImpl previous; if ( ( previous = secondLevelCacheStatistics.putIfAbsent( regionName, stat ) ) != null ) { stat = previous; } } return stat; }"	"	public ConcurrentSecondLevelCacheStatisticsImpl getSecondLevelCacheStatistics(String regionName) {
		ConcurrentSecondLevelCacheStatisticsImpl stat = secondLevelCacheStatistics.get( regionName );
		if ( stat == null ) {
			if ( sessionFactory == null ) {
				return null;
			}

			final EntityRegionAccessStrategy entityRegionAccess = sessionFactory.getCache().getEntityRegionAccess( regionName );
			final CollectionRegionAccessStrategy collectionRegionAccess = sessionFactory.getCache().getCollectionRegionAccess( regionName );

			if ( entityRegionAccess == null && collectionRegionAccess == null ) {
				final Region region = sessionFactory.getCache().getQueryCache( regionName ).getRegion();
				if ( region == null ) {
					throw new IllegalArgumentException( ""Could not resolve region name ["" + regionName + ""]"" );
				}
				stat = new ConcurrentSecondLevelCacheStatisticsImpl( region, null, null );
			}
			else {

				final Region region = entityRegionAccess != null
						? entityRegionAccess.getRegion()
						: collectionRegionAccess.getRegion();

				stat = new ConcurrentSecondLevelCacheStatisticsImpl(
						region,
						entityRegionAccess,
						collectionRegionAccess
				);
			}

			ConcurrentSecondLevelCacheStatisticsImpl previous;
			if ( ( previous = secondLevelCacheStatistics.putIfAbsent( regionName, stat ) ) != null ) {
				stat = previous;
			}
		}

		return stat;
	}
"	@return SecondLevelCacheStatistics or null if the second level cache is not enabled	@return SecondLevelCacheStatistics	1	0	13	43	194
private static ArrayList<Uri> getTreeUris(Context context) { ArrayList<Uri> uris = new ArrayList<Uri>(); Uri uri1 = getSharedPreferenceUri(context, R.string.preference_internal_uri_extsdcard_photos); if (uri1 != null) uris.add(uri1); return uris; }	"  private static Uri[] getTreeUris(Context context) {
	List<Uri> uris = new ArrayList<Uri>();

	Uri uri1 = getSharedPreferenceUri(context, R.string.preference_internal_uri_extsdcard_photos);
	if (uri1 != null) {
	  uris.add(uri1);
	}

	/*
	Uri uri2 = getSharedPreferenceUri(R.string.key_internal_uri_extsdcard_input);
	if (uri2 != null) {
	  uris.add(uri2);
	}
	*/
	return uris.toArray(new Uri[uris.size()]);
  }
"	@return The tree URIs.	@return The tree URIs.	0	1	8	9	46
public long getLastAccessedTime() { return (lastAccessedTime == NUM) ? getCreationTime() : lastAccessedTime; }	"public long getLastAccessedTime() {
    if (lastAccessedTime == NUM)
        return nativegetcreationtime();
    else
        return lastAccessedTime;
}"	@return the session's last access time in milliseconds since the epoch	@return the session's accessing time in milli seconds since 12.00 PM, January 1st, 1970	1	0	6	3	19
public Object get(long timeout, String key) throws TimeoutException { SynchronizationObject<CachedData[]> sync = setupGet(key); waitForNotNull(timeout, sync); CachedData[] rvContainer = sync.get(); assert rvContainer.length == NUM; Object rv = null; if (rvContainer[NUM] != null) { rv = transcoder.decode(rvContainer[NUM]); } return rv; }	"public Map<String, Object> get(String... keys) {
    final Map<String, Object> rv = new ConcurrentHashMap<String, Object>();
    final AtomicInteger requests = new AtomicInteger();
    final SynchronizationObject<AtomicInteger> sync = new SynchronizationObject<AtomicInteger>(requests);
    GetOperation.Callback cb = new GetOperation.Callback() {

        public void getComplete() {
            requests.decrementAndGet();
            sync.set(requests);
        }

        public void gotData(String k, int flags, byte[] data) {
            rv.put(k, transcoder.decode(new CachedData(flags, data)));
        }
    };
    Map<Integer, Collection<String>> chunks = new HashMap<Integer, Collection<String>>();
    for (String key : keys) {
        int which = getServerForKey(key);
        Collection<String> ks = chunks.get(which);
        if (ks == null) {
            ks = new ArrayList<String>();
            chunks.put(which, ks);
        }
        ks.add(key);
    }
    for (Map.Entry<Integer, Collection<String>> me : chunks.entrySet()) {
        requests.incrementAndGet();
        addOp(me.getKey(), new GetOperation(me.getValue(), cb));
    }
    try {
        sync.waitUntilTrue(new SynchronizationObject.Predicate<AtomicInteger>() {

            public boolean evaluate(AtomicInteger val) {
                return val.get() == NUM;
            }
        }, Long.MAX_VALUE, TimeUnit.SECONDS);
    } catch (InterruptedException e) {
        throw new RuntimeException(STR, e);
    } catch (TimeoutException e) {
        throw new RuntimeException(STR, e);
    }
    return rv;
}"	@return the result from the cache (null if there is none)	@return a map of the values (for each value that exists)	1	0	10	11	73
"protected Object convertDateToEpochDays(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0; // return epoch } try { return Date.toEpochDay(data); } catch (IllegalArgumentException e) { logger.warn(""Unexpected JDBC DATE value for field {} with schema {}: class={}, value={}"", fieldDefn.name(), fieldDefn.schema(), data.getClass(), data); return handleUnknownData(column, fieldDefn, data); } }"	"    protected Object convertDateToEpochDays(Column column, Field fieldDefn, Object data) {
        if (data == null) return null;
        try {
            return Date.toEpochDay(data);
        } catch (IllegalArgumentException e) {
            logger.warn(""Unexpected JDBC DATE value for field {} with schema {}: class={}, value={}"", fieldDefn.name(),
                        fieldDefn.schema(), data.getClass(), data);
            return null;
        }
    }
"	@return the converted value, or null if the conversion could not be made and the column allows nulls	@return the converted value, or null if the conversion could not be made	1	0	8	17	126
public Insets getBorderInsets(Component c) { return getBorderInsets(c, null); }	"public Insets getBorderInsets(Component c, Insets insets) {
    if (this.insets != null) {
        if (insets == null) {
            insets = new Insets(this.insets.top, this.insets.left, this.insets.bottom, this.insets.right);
        } else {
            insets.top = this.insets.top;
            insets.bottom = this.insets.bottom;
            insets.left = this.insets.left;
            insets.right = this.insets.right;
        }
    } else if (insets == null) {
        insets = new Insets(NUM, NUM, NUM, NUM);
    } else {
        insets.top = insets.bottom = insets.left = insets.right = NUM;
    }
    if (c instanceof JComponent) {
        Region region = Region.getRegion((JComponent) c);
        Insets margin = null;
        if ((region == Region.ARROW_BUTTON || region == Region.BUTTON || region == Region.CHECK_BOX || region == Region.CHECK_BOX_MENU_ITEM || region == Region.MENU || region == Region.MENU_ITEM || region == Region.RADIO_BUTTON || region == Region.RADIO_BUTTON_MENU_ITEM || region == Region.TOGGLE_BUTTON) && (c instanceof AbstractButton)) {
            margin = ((AbstractButton) c).getMargin();
        } else if ((region == Region.EDITOR_PANE || region == Region.FORMATTED_TEXT_FIELD || region == Region.PASSWORD_FIELD || region == Region.TEXT_AREA || region == Region.TEXT_FIELD || region == Region.TEXT_PANE) && (c instanceof JTextComponent)) {
            margin = ((JTextComponent) c).getMargin();
        } else if (region == Region.TOOL_BAR && (c instanceof JToolBar)) {
            margin = ((JToolBar) c).getMargin();
        } else if (region == Region.MENU_BAR && (c instanceof JMenuBar)) {
            margin = ((JMenuBar) c).getMargin();
        }
        if (margin != null) {
            insets.top += margin.top;
            insets.bottom += margin.bottom;
            insets.left += margin.left;
            insets.right += margin.right;
        }
    }
    return insets;
}"	@return the new <code>Insets</code> object initialized to 0	@return the <code>insets</code> object	1	0	5	3	17
public Role[] getRoles() { Item[] items = super.getItems(); Role[] roles = new Role[items.length]; for (int i = NUM; i < roles.length; i++) { roles[i] = (Role) items[i]; } return roles; }	"public Iterator getRoles() {
    return super.getItems();
}"	@return an array of roles.	@return an <code>Iterator</code>	1	0	10	8	60
private boolean testContentType(final IFile file, String contentTypeId, boolean isKindOfUsed) { final String expectedValue = contentTypeId.trim(); IContentType actualContentType = null; try { IContentDescription contentDescription = file.getContentDescription(); if (contentDescription != null) { actualContentType = contentDescription.getContentType(); } } catch (CoreException e) { Policy.log(IStatus.ERROR, STR, e); } if (actualContentType != null) { if (isKindOfUsed) { return actualContentType.isKindOf(Platform.getContentTypeManager().getContentType(expectedValue)); } return expectedValue.equals(actualContentType.getId()); } return false; }	"private boolean testContentType(final IFile file, String contentTypeId) {
    final String expectedValue = contentTypeId.trim();
    String actualValue = null;
    try {
        IContentDescription contentDescription = file.getContentDescription();
        if (contentDescription != null) {
            IContentType contentType = contentDescription.getContentType();
            actualValue = contentType.getId();
        }
    } catch (CoreException e) {
        Policy.log(IStatus.ERROR, STR, e);
    }
    return expectedValue.equals(actualValue);
}"	@return <code>true</code>, if the best matching content type for <code>file</code> <ul> <li>has an identifier that matches <code>contentTypeId</code> and <code>isKindOfUsed</code> is <code>false</code>, or</li> <li>is a kind of <code>contentTypeId</code> and <code>isKindOfUsed</code> is <code>true</code>.</li> </ul> Otherwise it returns <code>false</code>.	@return <code>true</code> iff the best matching content type has an identifier that matches <code>contentTypeId</code>; <code>false</code> otherwise.	1	0	11	19	111
"private EntityMetamodel getDeclarerEntityMetamodel(AbstractIdentifiableType<?> ownerType) { final Type.PersistenceType persistenceType = ownerType.getPersistenceType(); if ( persistenceType == Type.PersistenceType.ENTITY ) { return context.getSessionFactory() .getMetamodel() .entityPersister( ownerType.getTypeName() ) .getEntityMetamodel(); } else if ( persistenceType == Type.PersistenceType.MAPPED_SUPERCLASS ) { PersistentClass persistentClass = context.getPersistentClassHostingProperties( (MappedSuperclassTypeImpl<?>) ownerType ); return context.getSessionFactory() .getMetamodel() .entityPersister( persistentClass.getClassName() ) .getEntityMetamodel(); } else { throw new AssertionFailure( ""Cannot get the metamodel for PersistenceType: "" + persistenceType ); } }"	"	private EntityMetamodel getDeclarerEntityMetamodel(AbstractIdentifiableType<?> ownerType) {
		final Type.PersistenceType persistenceType = ownerType.getPersistenceType();
		if ( persistenceType == Type.PersistenceType.ENTITY ) {
			return context.getSessionFactory()
					.getEntityPersister( ownerType.getTypeName() )
					.getEntityMetamodel();
		}
		else if ( persistenceType == Type.PersistenceType.MAPPED_SUPERCLASS ) {
			PersistentClass persistentClass =
					context.getPersistentClassHostingProperties( (MappedSuperclassTypeImpl<?>) ownerType );
			return context.getSessionFactory()
					.getEntityPersister( persistentClass.getClassName() )
					.getEntityMetamodel();
		}
		else {
			throw new AssertionFailure( ""Cannot get the metamodel for PersistenceType: "" + persistenceType );
		}
	}
"	@return The built attribute descriptor	@return The built attribute descriptor	0	1	11	21	108
public BooleanExpression startsWith(Expression<String> str) { return BooleanOperation.create(Ops.STARTS_WITH, mixin, str); }	"    public BooleanExpression startsWith(Expression<String> str) {
        return BooleanOperation.create(Ops.STARTS_WITH, this, str);
    }
"	@return this.startsWith(str)	@return this.startsWith(str)	0	1	6	4	22
public String preprocess(String buildPath) throws RunnerException { return preprocess(buildPath, new PdePreprocessor()); }	"  public String preprocess(String buildPath) throws RunnerException {
    // make sure the user didn't hide the sketch folder
    ensureExistence();

    String[] codeFolderPackages = null;
    classPath = buildPath;

    // figure out the contents of the code folder to see if there
    // are files that need to be added to the imports
    if (codeFolder.exists()) {
      libraryPath = codeFolder.getAbsolutePath();

      // get a list of .jar files in the ""code"" folder
      // (class files in subfolders should also be picked up)
      String codeFolderClassPath =
        Compiler.contentsToClassPath(codeFolder);
      // append the jar files in the code folder to the class path
      classPath += File.pathSeparator + codeFolderClassPath;
      // get list of packages found in those jars
      codeFolderPackages =
        Compiler.packageListFromClassPath(codeFolderClassPath);

    } else {
      libraryPath = """";
    }

    // 1. concatenate all .pde files to the 'main' pde
    //    store line number for starting point of each code bit

    // Unfortunately, the header has to be written on a single line, because
    // there's no way to determine how long it will be until the code has
    // already been preprocessed. The header will vary in length based on
    // the programming mode (STATIC, ACTIVE, or JAVA), which is determined
    // by the preprocessor. So the preprocOffset for the primary class remains
    // zero, even though it'd be nice to have a legitimate offset, and be able
    // to remove the 'pretty' boolean for preproc.write().

    StringBuffer bigCode = new StringBuffer();
    int bigCount = 0;
    for (SketchCode sc : code) {
      if (sc.isExtension(""pde"")) {
        sc.setPreprocOffset(bigCount);
        bigCode.append(sc.getProgram());
        bigCode.append('\n');
        bigCount += sc.getLineCount();
//        if (sc != code[0]) {
//          sc.setPreprocName(null);  // don't compile me
//        }
      }
    }

    /*
    String program = code[0].getProgram();
    StringBuffer bigCode = new StringBuffer(program);
    int bigCount = code[0].getLineCount();
    bigCode.append('\n');

    for (int i = 1; i < codeCount; i++) {
      if (code[i].isExtension(""pde"")) {
        code[i].setPreprocOffset(bigCount);
        bigCode.append(code[i].getProgram());
        bigCode.append('\n');
        bigCount += code[i].getLineCount();
        code[i].setPreprocName(null);  // don't compile me
      }
    }
    */

    // Note that the headerOffset isn't applied until compile and run, because
    // it only applies to the code after it's been written to the .java file.
    int headerOffset = 0;
    PdePreprocessor preprocessor = new PdePreprocessor();
    try {
      headerOffset = preprocessor.writePrefix(bigCode.toString(),
                                              buildPath,
                                              name,
                                              codeFolderPackages);
    } catch (FileNotFoundException fnfe) {
      fnfe.printStackTrace();
      String msg = ""Build folder disappeared or could not be written"";
      throw new RunnerException(msg);
    }

    // 2. run preproc on that code using the sugg class name
    //    to create a single .java file and write to buildpath

    String primaryClassName = null;

    try {
      // if (i != 0) preproc will fail if a pde file is not
      // java mode, since that's required
      String className = preprocessor.write();

      if (className == null) {
        throw new RunnerException(""Could not find main class"");
        // this situation might be perfectly fine,
        // (i.e. if the file is empty)
        //System.out.println(""No class found in "" + code[i].name);
        //System.out.println(""(any code in that file will be ignored)"");
        //System.out.println();

//      } else {
//        code[0].setPreprocName(className + "".java"");
      }

      // store this for the compiler and the runtime
      primaryClassName = className;

    } catch (antlr.RecognitionException re) {
      // re also returns a column that we're not bothering with for now

      // first assume that it's the main file
      int errorFile = 0;
      int errorLine = re.getLine() - 1;

      // then search through for anyone else whose preprocName is null,
      // since they've also been combined into the main pde.
      for (int i = 1; i < codeCount; i++) {
        if (code[i].isExtension(""pde"") &&
            (code[i].getPreprocOffset() < errorLine)) {
          // keep looping until the errorLine is past the offset
          errorFile = i;
        }
      }
      errorLine -= code[errorFile].getPreprocOffset();

//      System.out.println(""i found this guy snooping around.."");
//      System.out.println(""whatcha want me to do with 'im boss?"");
//      System.out.println(errorLine + "" "" + errorFile + "" "" + code[errorFile].getPreprocOffset());

      String msg = re.getMessage();

      if (msg.equals(""expecting RCURLY, found 'null'"")) {
        // This can be a problem since the error is sometimes listed as a line
        // that's actually past the number of lines. For instance, it might
        // report ""line 15"" of a 14 line program. Added code to highlightLine()
        // inside Editor to deal with this situation (since that code is also
        // useful for other similar situations).
        throw new RunnerException(""Found one too many { characters "" +
                                  ""without a } to match it."",
                                  errorFile, errorLine, re.getColumn());
      }

      if (msg.indexOf(""expecting RBRACK"") != -1) {
        System.err.println(msg);
        throw new RunnerException(""Syntax error, "" +
                                  ""maybe a missing ] character?"",
                                  errorFile, errorLine, re.getColumn());
      }

      if (msg.indexOf(""expecting SEMI"") != -1) {
        System.err.println(msg);
        throw new RunnerException(""Syntax error, "" +
                                  ""maybe a missing semicolon?"",
                                  errorFile, errorLine, re.getColumn());
      }

      if (msg.indexOf(""expecting RPAREN"") != -1) {
        System.err.println(msg);
        throw new RunnerException(""Syntax error, "" +
                                  ""maybe a missing right parenthesis?"",
                                  errorFile, errorLine, re.getColumn());
      }

      if (msg.indexOf(""preproc.web_colors"") != -1) {
        throw new RunnerException(""A web color (such as #ffcc00) "" +
                                  ""must be six digits."",
                                  errorFile, errorLine, re.getColumn(), false);
      }

      //System.out.println(""msg is "" + msg);
      throw new RunnerException(msg, errorFile,
                                errorLine, re.getColumn());

    } catch (antlr.TokenStreamRecognitionException tsre) {
      // while this seems to store line and column internally,
      // there doesn't seem to be a method to grab it..
      // so instead it's done using a regexp

//      System.err.println(""and then she tells me "" + tsre.toString());
      // TODO not tested since removing ORO matcher.. ^ could be a problem
      String mess = ""^line (\\d+):(\\d+):\\s"";

      String[] matches = PApplet.match(tsre.toString(), mess);
      if (matches != null) {
        int errorLine = Integer.parseInt(matches[1]) - 1;
        int errorColumn = Integer.parseInt(matches[2]);

        int errorFile = 0;
        for (int i = 1; i < codeCount; i++) {
          if (code[i].isExtension(""pde"") &&
              (code[i].getPreprocOffset() < errorLine)) {
            errorFile = i;
          }
        }
        errorLine -= code[errorFile].getPreprocOffset();

        throw new RunnerException(tsre.getMessage(),
                                  errorFile, errorLine, errorColumn);

      } else {
        // this is bad, defaults to the main class.. hrm.
        String msg = tsre.toString();
        throw new RunnerException(msg, 0, -1, -1);
      }

    } catch (RunnerException pe) {
      // RunnerExceptions are caught here and re-thrown, so that they don't
      // get lost in the more general ""Exception"" handler below.
      throw pe;

    } catch (Exception ex) {
      // TODO better method for handling this?
      System.err.println(""Uncaught exception type:"" + ex.getClass());
      ex.printStackTrace();
      throw new RunnerException(ex.toString());
    }

    // grab the imports from the code just preproc'd

    importedLibraries = new ArrayList<File>();
    for (String item : preprocessor.getExtraImports()) {
      // remove things up to the last dot
      int dot = item.lastIndexOf('.');
      // http://dev.processing.org/bugs/show_bug.cgi?id=1145
      String entry = (dot == -1) ? item : item.substring(0, dot);
      File libFolder = (File) Base.importToLibraryTable.get(entry);

      if (libFolder != null) {
        importedLibraries.add(libFolder);
        classPath += Compiler.contentsToClassPath(libFolder);
        libraryPath += File.pathSeparator + libFolder.getAbsolutePath();
      }
    }

    // Finally, add the regular Java CLASSPATH
    String javaClassPath = System.getProperty(""java.class.path"");
    // Remove quotes if any.. An annoying (and frequent) Windows problem
    if (javaClassPath.startsWith(""\"""") && javaClassPath.endsWith(""\"""")) {
      javaClassPath = javaClassPath.substring(1, javaClassPath.length() - 1);
    }
    classPath += File.pathSeparator + javaClassPath;


    // 3. then loop over the code[] and save each .java file

    for (SketchCode sc : code) {
      if (sc.isExtension(""java"")) {
        // no pre-processing services necessary for java files
        // just write the the contents of 'program' to a .java file
        // into the build directory. uses byte stream and reader/writer
        // shtuff so that unicode bunk is properly handled
        String filename = sc.getFileName(); //code[i].name + "".java"";
        try {
          Base.saveFile(sc.getProgram(), new File(buildPath, filename));
        } catch (IOException e) {
          e.printStackTrace();
          throw new RunnerException(""Problem moving "" + filename +
                                    "" to the build folder"");
        }
//        sc.setPreprocName(filename);

      } else if (sc.isExtension(""pde"")) {
        // The compiler and runner will need this to have a proper offset
        sc.addPreprocOffset(headerOffset);
      }
    }
    return primaryClassName;
  }
"	@return null if compilation failed, main class name if not	@return null if compilation failed, main class name if not	0	1	6	4	22
"public boolean isValid(Litmus litmus) { return super.isValid(litmus) && litmus.check(Util.isDistinct(getRowType().getFieldNames()), ""distinct field names: {}"", getRowType()); }"	"  public boolean isValid(Litmus litmus) {
    return super.isValid(litmus)
        && litmus.check(Util.isDistinct(getRowType().getFieldNames()), getRowType());
  }
"	@return Row type of the aggregate	@return Row type of the aggregate	0	1	8	6	45
"public String getHelp() { return ""Generates a Go server library using OpenAPI-Generator. By default, "" + ""it will also generate service classes -- which you can disable with the `-Dnoservice` environment variable.""; }"	"    public String getHelp() {
        return ""Generates a Go server library using the swagger-tools project.  By default, "" +
                ""it will also generate service classes--which you can disable with the `-Dnoservice` environment variable."";
    }
"	@return A string value for the help message	@return A string value for the help message	0	1	5	5	44
public PortletContainer createContainer(String containerName, RequiredContainerServices requiredServices) throws PortletContainerException { return createContainer(containerName, requiredServices, new DefaultOptionalContainerServices()); }	"public PortletContainer createContainer(String containerName, PortletContainerServices services) throws PortletContainerException {
    return createContainer(containerName, services, new DefaultOptionalServices());
}"	@return newly created PortletContainer instance.	@return newly created PortletContainer	1	0	6	3	27
public ReporterData getSingleData(Xref idc) { List<ReporterData> dlist = data.get(idc); if (dlist != null && dlist.size() > NUM) return dlist.get(NUM); return null; }	"public Data getSingleData(Xref idc) {
    List<Data> dlist = data.get(idc);
    if (dlist != null && dlist.size() > NUM)
        return dlist.get(NUM);
    return null;
}"	@return a {@link ReporterData} instance that contains the cached data	@return a {@link Data} instance that contains the cached data	1	0	6	6	41
"public static String getLibraryPathPropertyName() { Platform current = Platform.getCurrent(); if (current.is(WINDOWS)) { return ""PATH""; } else if (current.is(MAC)) { return ""DYLD_LIBRARY_PATH""; } else { return ""LD_LIBRARY_PATH""; } }"	"  public static String getLibraryPathPropertyName() {
    switch (Platform.getCurrent()) {
      case MAC:
        return ""DYLD_LIBRARY_PATH"";

      case WINDOWS:
      case VISTA:
      case XP:
        return ""PATH"";

      default:
        return ""LD_LIBRARY_PATH"";
    }
  }
"	@return The platform specific env property name which contains the library path.	@return The platform specific env property name which contains the library path.	0	1	7	14	54
public Maps getMaps() { setApiKey(METHOD_GET, SEGMENT_MAPS); return fromString(client.get(SEGMENT_MAPS), Maps.class); }	"public Maps getMaps() {
    setApiKey(METHOD_GET, SEGMENT_MAPS);
    String response = client.get(SEGMENT_MAPS);
    Maps mapsJson = fromString(response, Maps.class);
    return mapsJson;
}"	@return Maps as	@return A list containing all the maps	1	0	6	4	27
public Field getSingleField() { return singleField; }	"    public Field getSingleField() {
        return fields.get(0);
    }
"	@return the fist of the merged Fields	@return the fist of the merged Fields	0	1	4	4	10
static List<String> parseCategories(String categoryStr) { List<String> outgoing = new ArrayList<String>(); if (categoryStr != null) { String[] listing = PApplet.trim(PApplet.split(categoryStr, ',')); for (String category : listing) { if (validCategories.contains(category)) { category = translateCategory(category); outgoing.add(category); } } } if (outgoing.size() == 0) { return defaultCategory(); } return outgoing; }	"  static StringList parseCategories(StringDict properties) {
    StringList outgoing = new StringList();

    String categoryStr = properties.get(CATEGORIES_PROPERTY);
    if (categoryStr == null) {
      categoryStr = properties.get(""category"");  // try the old way
    }
    if (categoryStr != null) {
      String[] listing = PApplet.trim(PApplet.split(categoryStr, ','));
      for (String category : listing) {
        if (validCategories.contains(category)) {
          category = translateCategory(category);
          outgoing.append(category);
        }
      }
    }
    if (outgoing.size() == 0) {
      return unknownCategory();
    }
    return outgoing;
  }
"	"@return the list of categories that this contribution is part of (e.g. ""Typography / Geometry""). ""Unknown"" if the category null."	"@return the list of categories that this contribution is part of (e.g. ""Typography / Geometry""). ""Unknown"" if the category null."	0	1	12	18	94
public static Project createThellierProject(File file) { return createProject(file, THELLIER); }	"public static Project createThellierProject(File file) {
    return createProject(file, Type.THELLIER);
}"	@return the created project, or null if file was not writable or it already existed.	@return the created project, or null if file was not writable.	1	0	5	3	18
public DateTime roundHalfCeilingCopy() { DateTime instant = iInstant; return (DateTime)instant.withMillis(iField.roundHalfCeiling(instant.getMillis())); }	"    public DateTime roundHalfCeilingCopy() {
        DateTime instant = iInstant;
        return (DateTime)instant.toCopy(iField.roundHalfCeiling(instant.getMillis()));
    }
"	@return a copy of the DateTime with the field value changed	@return a copy of the DateTime with the field value changed	0	1	7	5	28
public Charset getEncoding() { return _charset; }	"public String getEncoding() {
    return _charset;
}"	@return The encoding used to send outgoing messages. Never null	@return The encoding used to send outgoing messages, or null if not set.	1	0	4	3	10
public BirthDate getDob() { return dob; }	"public String getDob() {
    return dob;
}"	@return the date of birth different providers may use different formats	@return String the date of birth different providers may use different formats	1	0	4	3	10
"private GridHubConfiguration getHubConfiguration() throws Exception { String hubApi = ""http://"" + registrationRequest.getConfiguration().getHubHost() + "":"" + registrationRequest.getConfiguration().getHubPort() + ""/grid/api/hub""; URL api = new URL(hubApi); HttpClient client = httpClientFactory.createClient(api); String url = api.toExternalForm(); HttpRequest request = new HttpRequest(GET, url); HttpResponse response = client.execute(request); try (Reader reader = new StringReader(response.getContentString()); JsonInput jsonInput = new Json().newInput(reader)) { return StandaloneConfiguration.loadFromJson(jsonInput, GridHubConfiguration.class); } }"	"  private GridHubConfiguration getHubConfiguration() throws Exception {
    String hubApi =
      ""http://"" + registrationRequest.getConfiguration().getHubHost() + "":""
      + registrationRequest.getConfiguration().getHubPort() + ""/grid/api/hub"";

    URL api = new URL(hubApi);
    HttpClient client = httpClientFactory.createClient(api);
    String url = api.toExternalForm();
    HttpRequest request = new HttpRequest(GET, url);

    HttpResponse response = client.execute(request);
    return GridHubConfiguration.loadFromJSON(extractObject(response));
  }
"	@return json object of the current hub configuration	@return json object of the current hub configuration	0	1	10	17	124
"public Boolean fakeOuterBooleanSerialize(Boolean body) throws ApiException { Object localVarPostBody = body; // create path and map variables String localVarPath = ""/fake/outer/boolean""; // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {}; return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	"  public Boolean fakeOuterBooleanSerialize(Boolean body) throws ApiException {
    Object localVarPostBody = body;
    
    // create path and map variables
    String localVarPath = ""/fake/outer/boolean"";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    final String[] localVarAccepts = {
      
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {};
    return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);
      }
"	@return Boolean	@return Boolean	0	1	8	31	166
protected Serializable loadFromDatasource(final ResolveNaturalIdEvent event) { final Serializable pk = event.getEntityPersister().loadEntityIdByNaturalId( event.getOrderedNaturalIdValues(), event.getLockOptions(), event.getSession() ); event.getSession().getPersistenceContext().cacheNaturalIdResolution( event.getEntityPersister(), pk, event.getOrderedNaturalIdValues() ); return pk; }	"	protected Serializable loadFromDatasource(final ResolveNaturalIdEvent event) {
		return event.getEntityPersister().loadEntityIdByNaturalId(
				event.getNaturalIdValues(),
				event.getLockOptions(),
				event.getSession()
		);
	}
"	@return The object loaded from the datasource, or null if not found.	@return The object loaded from the datasource, or null if not found.	0	1	7	14	60
protected String readAnnouncement(File file) throws MojoExecutionException { InputStreamReader reader = null; FileInputStream inputStream = null; try { inputStream = new FileInputStream(file); if (StringUtils.isEmpty(templateEncoding)) { templateEncoding = ReaderFactory.FILE_ENCODING; getLog().warn(STR + templateEncoding + STR); } reader = new InputStreamReader(inputStream, templateEncoding); return IOUtil.toString(reader); } catch (FileNotFoundException fnfe) { throw new MojoExecutionException(STR + file); } catch (UnsupportedEncodingException uee) { throw new MojoExecutionException(STR + templateEncoding + STR); } catch (IOException ioe) { throw new MojoExecutionException(STR, ioe); } finally { IOUtil.close(inputStream); IOUtil.close(reader); } }	"protected FileReader readAnnouncement(File file) throws MojoExecutionException {
    FileReader fileReader;
    try {
        fileReader = new FileReader(file);
    } catch (FileNotFoundException fnfe) {
        throw new MojoExecutionException(STR + file);
    }
    return fileReader;
}"	@return Return the announcement text	@return fileReader Return the FileReader	1	0	11	22	136
"public String toDefaultValue(Schema p) { if (ModelUtils.isBooleanSchema(p)) { if (p.getDefault() != null) { return p.getDefault().toString(); } } else if (ModelUtils.isDateSchema(p)) { if (p.getDefault() != null) { return ""\"""" + p.getDefault().toString() + ""\""""; } } else if (ModelUtils.isDateTimeSchema(p)) { if (p.getDefault() != null) { return ""\"""" + p.getDefault().toString() + ""\""""; } } else if (ModelUtils.isNumberSchema(p)) { if (p.getDefault() != null) { if (ModelUtils.isFloatSchema(p)) { // float return p.getDefault().toString() + ""F""; } else if (ModelUtils.isDoubleSchema(p)) { // double return p.getDefault().toString() + ""D""; } else { // decimal return p.getDefault().toString() + ""M""; } } } else if (ModelUtils.isIntegerSchema(p)) { if (p.getDefault() != null) { return p.getDefault().toString(); } } else if (ModelUtils.isStringSchema(p)) { if (p.getDefault() != null) { String _default = (String) p.getDefault(); if (p.getEnum() == null) { return ""\"""" + _default + ""\""""; } else { // convert to enum var name later in postProcessModels return _default; } } } return null; }"	"    public String toDefaultValue(Schema p) {
        if (ModelUtils.isBooleanSchema(p)) {
            if (p.getDefault() != null) {
                return p.getDefault().toString();
            }
        } else if (ModelUtils.isDateSchema(p)) {
            if (p.getDefault() != null) {
                return ""\"""" + p.getDefault().toString() + ""\"""";
            }
        } else if (ModelUtils.isDateTimeSchema(p)) {
            if (p.getDefault() != null) {
                return ""\"""" + p.getDefault().toString() + ""\"""";
            }
        } else if (ModelUtils.isNumberSchema(p)) {
            if (p.getDefault() != null) {
                if (ModelUtils.isFloatSchema(p)) { // float
                    return p.getDefault().toString() + ""F"";
                } else if (ModelUtils.isDoubleSchema(p)) { // double
                    return p.getDefault().toString() + ""D"";
                } else {
                    return p.getDefault().toString();
                }
            }
        } else if (ModelUtils.isIntegerSchema(p)) {
            if (p.getDefault() != null) {
                return p.getDefault().toString();
            }
        } else if (ModelUtils.isStringSchema(p)) {
            if (p.getDefault() != null) {
                String _default = (String) p.getDefault();
                if (p.getEnum() == null) {
                    return ""\"""" + _default + ""\"""";
                } else {
                    // convert to enum var name later in postProcessModels
                    return _default;
                }
            }
        }

        return null;
    }
"	@return string presentation of the default value of the property	@return string presentation of the default value of the property	0	1	17	42	320
@Transactional(readOnly = true) @Override public int getCount(final List<BatchInstanceStatus> batchInstStatusList, final List<BatchPriority> batchPriorities, final boolean isCurrUsrNotReq, final String currentUser, final Set<String> userRoles, EphesoftUser ephesoftUser) { return batchInstanceDao.getCount(batchInstStatusList, batchPriorities, isCurrUsrNotReq, userRoles, currentUser, ephesoftUser); }	"@Transactional(readOnly = true)
@Override
public int getCount(final List<BatchInstanceStatus> batchInstStatusList, final List<BatchPriority> batchPriorities, final boolean isCurrUsrNotReq, final String currentUser, final Set<String> currentRole) {
    return batchInstanceDao.getCount(batchInstStatusList, batchPriorities, isCurrUsrNotReq, currentRole, currentUser);
}"	@return int, the count satisfying the above requirements	@return the count satisfying the above requirements	1	0	6	5	57
public long getExtraLong(String key) throws JSONException { return mExtraData.getLong(key); }	"public double getExtraLong(String key) {
    return mExtraData.optLong(key);
}"	@return The stored value.	@return The stored value or null if it doesn't exist in specified form.	1	0	5	3	18
"public int getSkillExperience(Skill skill) { int[] experiences = getSkillExperiences(); if (skill == Skill.OVERALL) { logger.debug(""getSkillExperience called for {}!"", skill); return (int) getOverallExperience(); } int idx = skill.ordinal(); // I'm not certain exactly how needed this is, but if the Skill enum is updated in the future // to hold something else that's not reported it'll save us from an ArrayIndexOutOfBoundsException. if (idx >= experiences.length) { return -1; } return experiences[idx]; }"	"	public int getSkillExperience(Skill skill)
	{
		int[] experiences = getSkillExperiences();

		if (skill == Skill.OVERALL)
		{
			int totalExperience = 0;

			for (int experience : experiences)
			{
				totalExperience += experience;
			}

			return totalExperience;
		}

		int idx = skill.ordinal();

		// I'm not certain exactly how needed this is, but if the Skill enum is updated in the future
		// to hold something else that's not reported it'll save us from an ArrayIndexOutOfBoundsException.
		if (idx >= experiences.length)
		{
			return -1;
		}

		return experiences[idx];
	}
"	@return the local player's current experience in the specified  Skill, or -1 if the  Skill isn't valid	@return the local player's current experience in the specified Skill, or -1 if the Skill isn't valid	0	1	7	22	115
public static QName getXSIType(Parameter param) { if (param.getMIMEType() != null) { return getMIMETypeQName(param.getMIMEType()); } QName xmlType = null; TypeEntry te = param.getType(); if (te != null && te instanceof Element && te.getRefType() != null) { te = te.getRefType(); } if (te != null && te instanceof CollectionType && te.getRefType() != null) { te = te.getRefType(); } if (te != null) { xmlType = te.getQName(); } return xmlType; }	"public static QName getXSIType(TypeEntry te) {
    QName xmlType = null;
    if (te != null && te instanceof Element && te.getRefType() != null) {
        te = te.getRefType();
    }
    if (te != null && te instanceof CollectionType && te.getRefType() != null) {
        te = te.getRefType();
    }
    if (te != null) {
        xmlType = te.getQName();
    }
    return xmlType;
}"	@return the QName of the parameter's type	@return the QName of the type	1	0	7	17	112
public Iterable<Double> getRadii() { if (this.radii != null) return this.radii; return Collections.emptyList(); }	"public Iterable<Double> getRadii() {
    return this.radii;
}"	@return List of radii, in meters. This method never returns null. If there are no rings this returns an empty list.	@return List of radii, in meters. If there are no rings this returns an empty list.	1	0	6	5	25
"public Client build() { if ((environment == null) && (executorService == null) && (objectMapper == null)) { throw new IllegalStateException(""Must have either an environment or both "" + ""an executor service and an object mapper""); } if (environment == null) { return build(executorService, objectMapper); } return build(environment.getLifecycleEnvironment() .managedExecutorService(""jersey-client-%d"", configuration.getMinThreads(), configuration.getMaxThreads(), 60, TimeUnit.SECONDS), environment.getObjectMapperFactory().build()); }"	"    public Client build() {
        if ((environment == null) && (executorService == null) && (objectMapper == null)) {
            throw new IllegalStateException(""Must have either an environment or both "" +
                                                    ""an executor service and an object mapper"");
        }

        if (environment == null) {
            return build(executorService, objectMapper);
        }

        return build(environment.managedExecutorService(""jersey-client-%d"",
                                                        configuration.getMinThreads(),
                                                        configuration.getMaxThreads(),
                                                        60,
                                                        TimeUnit.SECONDS),
                     environment.getObjectMapperFactory().build());
    }
"	@return a fully-configured  Client	@return a fully-configured Client	0	1	8	19	111
public Date getCreateDate() { return this.createDate; }	"public java.util.Date getCreateDate() {
    return this.createDate;
}"	@return {@link Date} 	@return java.util.Date	1	0	5	3	11
public NVP<Long, Double> reset(final long newStartMs, final long newCount) { final long[] priorWindow = TIME_WINDOW_UPDATER.getAndSet(this, windowRangeFromMs(newStartMs, windowWidth)); final long priorCount = count; count = newCount; return new NVP<Long, Double>(priorWindow[NUM], calcRate(priorCount, windowWidth)); }	"public long reset() {
    final long priorCount = count;
    count = NUM;
    return priorCount;
}"	@return An NVP of the the prior window end time and the effective count per second	@return the prior count	1	0	7	6	63
public boolean get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }	"public boolean get(WithAttributes attributes) {
    return attributes.getAttributes().get(this);
}"	@return the value of this attribute if this attribute is present in the extracted map. Otherwise {@link #getDefaultValue()}	@return the value of this attribute if this attribute is present in the map. Otherwise {@link #getDefaultValue()}	1	0	6	3	19
public Label newLabelFromString(String labelStr) { int first = labelStr.indexOf(divider); int second = labelStr.lastIndexOf(divider); if (first == second) { return new WordLemmaTag(labelStr.substring(0, first), Morphology.lemmaStatic(labelStr.substring(0, first), labelStr.substring(first + 1)), labelStr.substring(first + 1)); } else if (first >= 0) { return new WordLemmaTag(labelStr.substring(0, first), labelStr.substring(first + 1, second), labelStr.substring(second + 1)); } else { return new WordLemmaTag(labelStr); } }	"  public Label newLabelFromString(String labelStr) {
    int first = labelStr.indexOf(divider);
    int second = labelStr.lastIndexOf(divider);
    if (first == second) {
      return new WordLemmaTag(labelStr.substring(0, first), Morphology.stemStatic(labelStr.substring(0, first), labelStr.substring(first + 1)).word(), labelStr.substring(first + 1));
    } else if (first >= 0) {
      return new WordLemmaTag(labelStr.substring(0, first), labelStr.substring(first + 1, second), labelStr.substring(second + 1));
    } else {
      return new WordLemmaTag(labelStr);
    }
  }
"	@return The new WordLemmaTag	@return The new WordLemmaTag	0	1	10	12	122
public ConcurrentHashMap<String, String> getSubToSuperMap() { return subToSuperMap; }	"public HashMap<String, String> getSubToSuperMap() {
    return subToSuperMap;
}"	@return ConcurrentHashMap of {@link ProductType} ids mapped to their parent id	@return HashMap of {@link ProductType} ids mapped to their parent id	1	0	5	3	13
public MColor getColor() { if (m_vo.AD_Color_ID == NUM) return null; MColor mc = new MColor(m_vo.ctx, m_vo.AD_Color_ID, null); return mc; }	"public CompiereColor getColor() {
    if (m_vo.AD_Color_ID == NUM)
        return null;
    MColor mc = new MColor(m_vo.ctx, m_vo.AD_Color_ID, null);
    return mc.getAdempiereColor();
}"	@return MColor or null	@return AdempiereColor or null	1	0	6	6	33
public synchronized VisualItem getItem(String itemClass, Entity entity, boolean create) { ItemEntry entry = (ItemEntry) m_entryMap.get(itemClass); if (entry != null) { VisualItem item = (VisualItem) entry.itemMap.get(entity); if (!create) { return item; } else if (item == null) { item = m_ifactory.getItem(itemClass); item.init(this, itemClass, entity); addItem(entry, entity, item); } if (item instanceof NodeItem) ((NodeItem) item).removeAllNeighbors(); item.setDirty(NUM); item.setVisible(true); return item; } else { throw new IllegalArgumentException(STR + STR); } }	"public synchronized GraphItem getItem(String itemClass, Entity entity, boolean create) {
    ItemEntry entry = (ItemEntry) m_entryMap.get(itemClass);
    if (entry != null) {
        GraphItem item = (GraphItem) entry.itemMap.get(entity);
        if (!create) {
            return item;
        } else if (item == null) {
            item = m_ifactory.getItem(itemClass);
            item.init(this, itemClass, entity);
            addItem(entry, entity, item);
        }
        if (item instanceof NodeItem)
            ((NodeItem) item).removeAllNeighbors();
        item.setDirty(NUM);
        item.setVisible(true);
        return item;
    } else {
        throw new IllegalArgumentException(STR + STR);
    }
}"	@return the requested VisualItem, or null if the VisualItem wasn't found and the create parameter is false.	@return the requested GraphItem, or null if the GraphItem wasn't found and the create parameter is false.	1	0	11	20	134
private File[] getDirectoryHistory() { File[] dirhist = Settings.instance().getDirectoryHistory(); if (dirhist == null || dirhist.length == NUM) return new File[] { new File(STR).getAbsoluteFile() }; else return dirhist; }	"private String[] getDirectoryHistory() {
    return new String[] { directory.getAbsolutePath(), STR, STR, STR, STR };
}"	@return current directory history, or if empty, only current directory (as File[0]).	@return current directory history.	1	0	8	7	51
public final Map<String, String> validateSubDocuments() { final OOXML ooxml = this.getFormatVersion().getXML(); if (!ooxml.canValidate()) return null; final Map<String, String> res = new HashMap<String, String>(); for (final String s : subdocNames) { if (this.getEntries().contains(s)) { final String valid = ooxml.getValidator(this.getDocument(s)).isValid(); if (valid != null) res.put(s, valid); } } return res; }	"public final Map<String, String> validateSubDocuments() {
    final OOXML ooxml = OOXML.get(getVersion());
    final Map<String, String> res = new HashMap<String, String>();
    for (final String s : subdocNames) {
        if (this.getEntries().contains(s)) {
            final String valid = ooxml.getValidator(this.getDocument(s)).isValid();
            if (valid != null)
                res.put(s, valid);
        }
    }
    return res;
}"	@return all problems indexed by subdocuments names, i.e. empty if all OK, <code>null</code> if validation couldn't occur.	@return all problems indexed by subdocuments names, ie empty if all ok.	1	0	12	14	103
public Actions moveByOffset(int xOffset, int yOffset) { if (isBuildingActions()) { action.addAction(new MoveToOffsetAction(jsonMouse, null, xOffset, yOffset)); } return tick( defaultMouse.createPointerMove(Duration.ofMillis(200), Origin.pointer(), xOffset, yOffset)); }	"  public Actions moveByOffset(int xOffset, int yOffset) {
    if (isBuildingActions()) {
      action.addAction(new MoveToOffsetAction(jsonMouse, null, xOffset, yOffset));
    }

    return tick(
        defaultMouse.createPointerMove(Duration.ofMillis(200), null, xOffset, yOffset));
  }
"	@return A self reference.	@return A self reference.	0	1	8	9	59
protected PingResult parse(int exitValue, List<String> outLines, List<String> errLines) { PingResult info = new PingResult(); Pattern roundTripTimePat = Pattern.compile(RTT_REG_EX); Pattern transmitReceivePat = Pattern.compile(TRANSMITTED_RECEIVED_REG_EX); Pattern noRouteToHostPat = Pattern.compile(NO_ROUTE_TO_HOST_REG_EX); Pattern unknownHostPat = Pattern.compile(UNKNOWN_HOST_REG_EX); info.setHost(getHost()); switch(exitValue) { case NUM: for (String line : outLines) { Matcher matcher = roundTripTimePat.matcher(line); if (matcher.find()) { info.setRTTMin(Double.parseDouble(matcher.group(NUM))); info.setRTTAvg(Double.parseDouble(matcher.group(NUM))); info.setRTTMax(Double.parseDouble(matcher.group(NUM))); info.setRTTMDev(Double.parseDouble(matcher.group(NUM))); } } for (String line : outLines) { Matcher matcher = transmitReceivePat.matcher(line); if (matcher.find()) { info.setTransmitted(Integer.parseInt(matcher.group(NUM))); info.setReceived(Integer.parseInt(matcher.group(NUM))); } } if (info.getReceived() == NUM) { info.setStatus(ServiceStatus.FAIL); } else { info.setStatus(ServiceStatus.SUCCESS); } break; case NUM: case NUM: case NUM: for (String line : outLines) { Matcher matcher = transmitReceivePat.matcher(line); if (matcher.find()) { info.setTransmitted(Integer.parseInt(matcher.group(NUM))); info.setReceived(Integer.parseInt(matcher.group(NUM))); } } for (String line : errLines) { Matcher matcher = unknownHostPat.matcher(line); if (matcher.find()) { info.setMessage(matcher.group(NUM)); } } info.setStatus(ServiceStatus.FAIL); break; default: assert false : STR; } return info; }	"protected PingInfo parse(int exitValue, List<String> outLines, List<String> errLines) {
    PingInfo info = new PingInfo();
    Pattern roundTripTimePat = Pattern.compile(RTT_REG_EX);
    Pattern transmitReceivePat = Pattern.compile(TRANSMITTED_RECEIVED_REG_EX);
    Pattern noRouteToHostPat = Pattern.compile(NO_ROUTE_TO_HOST_REG_EX);
    Pattern unknownHostPat = Pattern.compile(UNKNOWN_HOST_REG_EX);
    info.setHost(getHost());
    switch(exitValue) {
        case NUM:
            for (String line : outLines) {
                Matcher matcher = roundTripTimePat.matcher(line);
                if (matcher.find()) {
                    info.setRTTMin(Double.parseDouble(matcher.group(NUM)));
                    info.setRTTAvg(Double.parseDouble(matcher.group(NUM)));
                    info.setRTTMax(Double.parseDouble(matcher.group(NUM)));
                    info.setRTTMDev(Double.parseDouble(matcher.group(NUM)));
                }
            }
            for (String line : outLines) {
                Matcher matcher = transmitReceivePat.matcher(line);
                if (matcher.find()) {
                    info.setTransmitted(Integer.parseInt(matcher.group(NUM)));
                    info.setReceived(Integer.parseInt(matcher.group(NUM)));
                }
            }
            if (info.getReceived() == NUM) {
                info.setStatus(ServiceStatus.FAIL);
            } else {
                info.setStatus(ServiceStatus.SUCCESS);
            }
            break;
        case NUM:
        case NUM:
        case NUM:
            for (String line : outLines) {
                Matcher matcher = transmitReceivePat.matcher(line);
                if (matcher.find()) {
                    info.setTransmitted(Integer.parseInt(matcher.group(NUM)));
                    info.setReceived(Integer.parseInt(matcher.group(NUM)));
                }
            }
            for (String line : errLines) {
                Matcher matcher = unknownHostPat.matcher(line);
                if (matcher.find()) {
                    info.setMessage(matcher.group(NUM));
                }
            }
            info.setStatus(ServiceStatus.FAIL);
            break;
        default:
            assert false : STR;
    }
    return info;
}"	@return {@link PingResult}	@return {@link PingInfo}	1	0	13	54	356
public static int[] getHeaderToViewPosition(JTextArea view, String header, int start, int end) { validateView(view); validateHeader(header); validateStartEnd(start, end); if (!isValidStartEndForLength(start, end, header.length())) { return INVALID_POSITION; } int excessChars = 0; int pos = 0; while ((pos = header.indexOf(HttpHeader.CRLF, pos)) != -1 && pos < start) { pos += 2; ++excessChars; } int len = view.getDocument().getLength(); int finalStartPos = start - excessChars; if (finalStartPos > len) { return INVALID_POSITION; } if (pos != -1) { while ((pos = header.indexOf(HttpHeader.CRLF, pos)) != -1 && pos < end) { pos += 2; ++excessChars; } } int finalEndPos = end - excessChars; if (finalEndPos > len) { return INVALID_POSITION; } return new int[] { finalStartPos, finalEndPos }; }	"    public static int[] getHeaderToViewPosition(JTextArea view, String header, int start, int end) {
        validateView(view);
        validateHeader(header);
        validateStartEnd(start, end, header.length());

        int excessChars = 0;

        int pos = 0;
        while ((pos = header.indexOf(HttpHeader.CRLF, pos)) != -1 && pos < start) {
            pos += 2;
            ++excessChars;
        }

        int len = view.getDocument().getLength();
        int finalStartPos = start - excessChars;
        if (finalStartPos > len) {
            return INVALID_POSITION;
        }

        if (pos != -1) {
            while ((pos = header.indexOf(HttpHeader.CRLF, pos)) != -1 && pos < end) {
                pos += 2;
                ++excessChars;
            }
        }

        int finalEndPos = end - excessChars;
        if (finalEndPos > len) {
            return INVALID_POSITION;
        }

        return new int[] { finalStartPos, finalEndPos };
    }
"	@return the positions offset for the  view, or  #INVALID_POSITION if the  start,  end or offset positions are greater than  view's length.	@return the positions offset for the view, or #INVALID_POSITION if the offset positions are greater than view's length.	1	0	10	38	190
"public static Binding parse(String serialized) throws IllegalArgumentException { try { if (serialized.isEmpty()) { return new Binding(); } String[] parts = serialized.split("":""); switch (parts.length) { case 2: { return new Binding(parts[0], Integer.valueOf(parts[1])); } case 1: { return parts[0].contains(""."") ? new Binding(parts[0]) : new Binding(Integer.valueOf(parts[0])); } default: { throw new IllegalArgumentException(); } } } catch (Exception e) { throw new IllegalArgumentException(""Error parsing Binding '"" + serialized + ""'""); } }"	"        public static Binding parse(String serialized) throws IllegalArgumentException {
            try {
                String[] parts = serialized.split("":"");
                switch (parts.length) {
                case 2: {
                    return new Binding(parts[0], Integer.valueOf(parts[1]));
                }
                case 1: {
                    return new Binding(Integer.valueOf(parts[0]));
                }
                default: {
                    throw new IllegalArgumentException();
                }
                }
            } catch (Exception e) {
                throw new IllegalArgumentException(""Error parsing Binding '""
                        + serialized + ""'"");
            }
        }
"	@return a  Binding matching the specification	@return a Binding matching the specification	0	1	13	25	146
private boolean isShareable() { return getRequestScope().getDictionary().isSharable(obj.getClass()); }	"private boolean isShareable() {
    return getRequestScope().getDictionary().getAnnotation(obj.getClass(), Shareable.class) != null;
}"	@return true if this persistent resource's entity is sharable.	@return true if this persistent resource's entity has the @Shareable annotation	1	0	6	3	22
public long getConnectAttemptTimeout() { return wireFormat.getConnectAttemptTimeout(); }	"    public long getConnectAttemptTimeout() {
        return connectAttemptTimeout;
    }
"	@return the timeout value used to fail a connection if no CONNECT frame read.	@return the timeout value used to fail a connection if no CONNECT frame read.	0	1	4	4	13
public static boolean startsWithPattern(final byte[] byteArray, final byte[] pattern) { return hasPatternAt(byteArray, pattern, 0); }	"  public static boolean startsWithPattern(final byte[] byteArray, final byte[] pattern) {
    Preconditions.checkNotNull(byteArray);
    Preconditions.checkNotNull(pattern);
    if (pattern.length > byteArray.length) {
      return false;
    }

    for (int i = 0; i < pattern.length; ++i) {
      if (byteArray[i] != pattern[i]) {
        return false;
      }
    }

    return true;
  }
"	@return true if byteArray starts with pattern	@return true if byteArray starts with pattern	0	1	5	4	29
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 6: { return getEllipsis(); } case 8: break; case 4: { return getNext(false); } case 9: break; case 7: { if ( ! removeProMarker) { return getNext(false); } } case 10: break; case 2: { return getNewline(); } case 11: break; case 5: { return getNext(true); } case 12: break; case 3: { } case 13: break; case 1: { System.err.printf(""Untokenizable: %s%n"", yytext()); return getNext(true); } case 14: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }"	"  public Object next() throws java.io.IOException {
    int zzInput;
    int zzAction;

    // cached fields:
    int zzCurrentPosL;
    int zzMarkedPosL;
    int zzEndReadL = zzEndRead;
    char [] zzBufferL = zzBuffer;
    char [] zzCMapL = ZZ_CMAP;

    int [] zzTransL = ZZ_TRANS;
    int [] zzRowMapL = ZZ_ROWMAP;
    int [] zzAttrL = ZZ_ATTRIBUTE;

    while (true) {
      zzMarkedPosL = zzMarkedPos;

      zzAction = -1;

      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
  
      zzState = ZZ_LEXSTATE[zzLexicalState];

      // set up zzAction for empty match case:
      int zzAttributes = zzAttrL[zzState];
      if ( (zzAttributes & 1) == 1 ) {
        zzAction = zzState;
      }


      zzForAction: {
        while (true) {
    
          if (zzCurrentPosL < zzEndReadL)
            zzInput = zzBufferL[zzCurrentPosL++];
          else if (zzAtEOF) {
            zzInput = YYEOF;
            break zzForAction;
          }
          else {
            // store back cached positions
            zzCurrentPos  = zzCurrentPosL;
            zzMarkedPos   = zzMarkedPosL;
            boolean eof = zzRefill();
            // get translated positions and possibly new buffer
            zzCurrentPosL  = zzCurrentPos;
            zzMarkedPosL   = zzMarkedPos;
            zzBufferL      = zzBuffer;
            zzEndReadL     = zzEndRead;
            if (eof) {
              zzInput = YYEOF;
              break zzForAction;
            }
            else {
              zzInput = zzBufferL[zzCurrentPosL++];
            }
          }
          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
          if (zzNext == -1) break zzForAction;
          zzState = zzNext;

          zzAttributes = zzAttrL[zzState];
          if ( (zzAttributes & 1) == 1 ) {
            zzAction = zzState;
            zzMarkedPosL = zzCurrentPosL;
            if ( (zzAttributes & 8) == 8 ) break zzForAction;
          }

        }
      }

      // store back cached position
      zzMarkedPos = zzMarkedPosL;

      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
        case 1: 
          { System.err.printf(""Untokenizable: %s%n"", yytext());
	      return getNext(true);
          }
        case 9: break;
        case 2: 
          { if (tokenizeNLs) {
                return getNext(NEWLINE_TOKEN, yytext());
              }
          }
        case 10: break;
        case 3: 
          { 
          }
        case 11: break;
        case 4: 
          { return getNext(false);
          }
        case 12: break;
        case 5: 
          { return getNext(true);
          }
        case 13: break;
        case 6: 
          { return getEllipsis();
          }
        case 14: break;
        case 7: 
          { if (! removeProMarker) return getNext(false);
          }
        case 15: break;
        case 8: 
          { if (removeProMarker) {
                if ( ! removeSegMarker) {
                  return getNext(""-"", yytext());
                }
              } else {
                return getNext(false);
              }
          }
        case 16: break;
        default: 
          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
            zzAtEOF = true;
              {
                return null;
              }
          } 
          else {
            zzScanError(ZZ_NO_MATCH);
          }
      }
    }
  }
"	@return the next token	@return the next token	0	1	17	115	431
public SortedMap<String, String> getOriginTabContentsAsStrings(final Origin selectedColumn) { openTab(Tab.ORIGIN); return mapTableCellsKeyValue(String.class, getVisibleTableRows(true, false), selectedColumn.column); }	"public SortedMap<String, String> getOriginTabContentsAsStrings() {
    openTab(Tab.ORIGIN);
    return mapTableCellsKeyValue(String.class, getVisibleTableRows(true, true), NUM);
}"	@return a map of the specified two columns. (first column => selectedColumn)	@return a map of the first two columns. (first column => second column)	1	0	6	4	36
public int hashCode() { // must be to fulfil ReadableInstant contract return ((int) (getMillis() ^ (getMillis() >>> 32))) + (getChronology().hashCode()); }	"    public int hashCode() {
        // must be to fulfil ReadableInstant contract
        return
            ((int) (getMillis() ^ (getMillis() >>> 32))) +
            (getChronology() == null ? 0 : getChronology().hashCode());
    }
"	@return a suitable hash code	@return a suitable hash code	0	1	8	7	43
"private Bitmap getWidgetPreview(AppWidgetProviderInfo info) { final PackageManager packageManager = mPackageManager; String packageName = info.provider.getPackageName(); Drawable drawable = null; if (info.previewImage != 0) { drawable = packageManager.getDrawable(packageName, info.previewImage, null); if (drawable == null) { Log.w(TAG, ""Can't load icon drawable 0x"" + Integer.toHexString(info.icon) + "" for provider: "" + info.provider); } } // If we don't have a preview image, create a default one if (drawable == null) { Resources resources = mLauncher.getResources(); // Create a new bitmap to hold the widget preview int width = (int) (Math.max(mMinWidgetPreviewDim, Math.min(mMaxWidgetPreviewDim, info.minWidth)) * sScaleFactor); int height = (int) (Math.max(mMinWidgetPreviewDim, Math.min(mMaxWidgetPreviewDim, info.minHeight)) * sScaleFactor); final Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888); final Drawable background = resources.getDrawable(R.drawable.default_widget_preview); renderDrawableToBitmap(background, bitmap, 0, 0, width, height, 1.0f, 1.0f); // Draw the icon flush left try { Drawable icon = null; if (info.icon > 0) { icon = packageManager.getDrawable(packageName, info.icon, null); } if (icon == null) { icon = resources.getDrawable(R.drawable.ic_launcher_application); } final int iconSize = mMinWidgetPreviewDim / 2; final int offset = iconSize / 4; renderDrawableToBitmap(icon, null, offset, offset, iconSize, iconSize, 1.0f, 1.0f); } catch (Resources.NotFoundException e) { // if we can't find the icon, then just don't draw it } return bitmap; } else { // Scale down the preview if necessary final float imageWidth = drawable.getIntrinsicWidth(); final float imageHeight = drawable.getIntrinsicHeight(); final float aspect = (float) imageWidth / imageHeight; final int scaledWidth = (int) (Math.max(mMinWidgetPreviewDim, Math.min(mMaxWidgetPreviewDim, imageWidth)) * sScaleFactor); final int scaledHeight = (int) (Math.max(mMinWidgetPreviewDim, Math.min(mMaxWidgetPreviewDim, imageHeight)) * sScaleFactor); int width; int height; if (aspect >= 1.0f) { width = scaledWidth; height = (int) (((float) scaledWidth / imageWidth) * imageHeight); } else { height = scaledHeight; width = (int) (((float) scaledHeight / imageHeight) * imageWidth); } final Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888); renderDrawableToBitmap(drawable, bitmap, 0, 0, width, height, 1.0f, 1.0f); return bitmap; } }"	"    private FastBitmapDrawable getWidgetPreview(AppWidgetProviderInfo info) {
        final PackageManager packageManager = mPackageManager;
        String packageName = info.provider.getPackageName();
        Drawable drawable = null;
        FastBitmapDrawable newDrawable = null;
        if (info.previewImage != 0) {
            drawable = packageManager.getDrawable(packageName, info.previewImage, null);
            if (drawable == null) {
                Log.w(TAG, ""Can't load icon drawable 0x"" + Integer.toHexString(info.icon)
                        + "" for provider: "" + info.provider);
            }
        }

        // If we don't have a preview image, create a default one
        final int minDim = mWorkspaceWidgetLayout.estimateCellWidth(1);
        final int maxDim = mWorkspaceWidgetLayout.estimateCellWidth(3);
        if (drawable == null) {
            Resources resources = mLauncher.getResources();

            // Create a new bitmap to hold the widget preview
            int width = (int) (Math.max(minDim, Math.min(maxDim, info.minWidth)) * sScaleFactor);
            int height = (int) (Math.max(minDim, Math.min(maxDim, info.minHeight)) * sScaleFactor);
            final Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888);
            final Drawable background = resources.getDrawable(R.drawable.default_widget_preview);
            renderDrawableToBitmap(background, bitmap, 0, 0, width, height, 1.0f, 1.0f);

            // Draw the icon flush left
            try {
                Drawable icon = null;
                if (info.icon > 0) {
                    icon = packageManager.getDrawable(packageName, info.icon, null);
                }
                if (icon == null) {
                    icon = resources.getDrawable(R.drawable.ic_launcher_application);
                }

                final int iconSize = minDim / 2;
                final int offset = iconSize / 4;
                renderDrawableToBitmap(icon, null, offset, offset, iconSize, iconSize, 1.0f, 1.0f);
            } catch (Resources.NotFoundException e) {
                // if we can't find the icon, then just don't draw it
            }

            newDrawable = new FastBitmapDrawable(bitmap);
        } else {
            // Scale down the preview if necessary
            final float imageWidth = drawable.getIntrinsicWidth();
            final float imageHeight = drawable.getIntrinsicHeight();
            final float aspect = (float) imageWidth / imageHeight;
            final int scaledWidth =
                (int) (Math.max(minDim, Math.min(maxDim, imageWidth)) * sScaleFactor);
            final int scaledHeight =
                (int) (Math.max(minDim, Math.min(maxDim, imageHeight)) * sScaleFactor);
            int width;
            int height;
            if (aspect >= 1.0f) {
                width = scaledWidth;
                height = (int) (((float) scaledWidth / imageWidth) * imageHeight);
            } else {
                height = scaledHeight;
                width = (int) (((float) scaledHeight / imageHeight) * imageWidth);
            }

            final Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888);
            renderDrawableToBitmap(drawable, bitmap, 0, 0, width, height, 1.0f, 1.0f);

            newDrawable = new FastBitmapDrawable(bitmap);
        }
        newDrawable.setBounds(0, 0, newDrawable.getIntrinsicWidth(),
                newDrawable.getIntrinsicHeight());
        return newDrawable;
    }
"	@return the Bitmap that will be wrapped in a FastBitmapDrawable and used and sized in the ImageView to represent the widget	@return the drawable that will be used and sized in the ImageView to represent the widget	1	0	13	69	515
public YearMonthDay setCopy(int value) { int[] newValues = iYearMonthDay.getValues(); newValues = getField().set(iYearMonthDay, iFieldIndex, newValues, value); return new YearMonthDay(iYearMonthDay, newValues); }	"        public YearMonthDay setCopy(int value) {
            int[] newValues = iInstant.getValues();
            getField().set(iInstant, iFieldIndex, newValues, value);
            return new YearMonthDay(iInstant, newValues);
        }
"	@return a copy of the YearMonthDay with the field value changed	@return a copy of the YearMonthDay with the field value changed	0	1	7	6	42
static public IStructuredTextExpert getStatefulExpert(String type) { return getStatefulExpert(type, StructuredTextEnvironment.DEFAULT); }	"static public ISTextExpert getStatefulExpert(String type) {
    return getStatefulExpert(type, STextEnvironment.DEFAULT);
}"	@return the IStructuredTextExpert instance.	@return the ISTextExpert instance.	1	0	5	3	19
"public ResponseEntity<Void> addPetWithHttpInfo(Pet body) throws RestClientException { Object postBody = body; // verify the required parameter 'body' is set if (body == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'body' when calling addPet""); } String path = apiClient.expandPath(""/pet"", Collections.<String, Object>emptyMap()); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { ""application/json"", ""application/xml"" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { ""petstore_auth"" }; ParameterizedTypeReference<Void> returnType = new ParameterizedTypeReference<Void>() {}; return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType); }"	"    public ResponseEntity<Void> addPetWithHttpInfo(Pet body) throws RestClientException {
        Object postBody = body;
        
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'body' when calling addPet"");
        }
        
        String path = apiClient.expandPath(""/pet"", Collections.<String, Object>emptyMap());

        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();
        final HttpHeaders headerParams = new HttpHeaders();
        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();

        final String[] accepts = { };
        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);
        final String[] contentTypes = { 
            ""application/json"", ""application/xml""
        };
        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);

        String[] authNames = new String[] { ""petstore_auth"" };

        ParameterizedTypeReference<Void> returnType = new ParameterizedTypeReference<Void>() {};
        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);
    }
"	@return ResponseEntity&lt;Void&gt;	@return ResponseEntity&lt;Void&gt;	0	1	8	28	223
public User getOwner() { return owner; }	"public Person getOwner() {
    return owner;
}"	@return Valid {@link User}	@return Valid {@link Person}	1	0	4	3	10
"static Object wrapArgumentForScriptExecution(Object argument) { JSONObject wrappedArgument = new JSONObject(); try { if (argument instanceof String) { wrappedArgument.put(""type"", ""STRING""); wrappedArgument.put(""value"", argument); } else if (argument instanceof Boolean) { wrappedArgument.put(""type"", ""BOOLEAN""); wrappedArgument.put(""value"", argument); } else if (argument instanceof Number) { wrappedArgument.put(""type"", ""NUMBER""); wrappedArgument.put(""value"", argument); } else if (argument instanceof ChromeWebElement) { wrappedArgument.put(""type"", ""ELEMENT""); wrappedArgument.put(""value"", ((ChromeWebElement)argument).getElementId()); } else if (argument instanceof Collection<?>) { JSONArray array = new JSONArray(); for (Object o : (Collection<?>)argument) { array.put(wrapArgumentForScriptExecution(o)); } return array; } else { throw new IllegalArgumentException(""Could not wrap up "" + ""javascript parameter "" + argument + ""(class: "" + argument.getClass() + "")""); } } catch (JSONException e) { throw new WebDriverException(e); } return wrappedArgument; }"	"    static JSONObject wrapArgumentForScriptExecution(Object argument) {
      JSONObject wrappedArgument = new JSONObject();
      try {
        if (argument instanceof String) {
          wrappedArgument.put(""type"", ""STRING"");
          wrappedArgument.put(""value"", argument);
        } else if (argument instanceof Boolean) {
          wrappedArgument.put(""type"", ""BOOLEAN"");
          wrappedArgument.put(""value"", argument);
        } else if (argument instanceof Number) {
          wrappedArgument.put(""type"", ""NUMBER"");
          wrappedArgument.put(""value"", argument);
        } else if (argument instanceof ChromeWebElement) {
          wrappedArgument.put(""type"", ""ELEMENT"");
          wrappedArgument.put(""value"", ((ChromeWebElement)argument).getElementId());
        } else {
          throw new IllegalArgumentException(""Could not wrap up "" +
                ""javascript parameter "" + argument +
                ""(class: "" + argument.getClass() + "")"");
        }
      } catch (JSONException e) {
        throw new WebDriverException(e);
      }
      return wrappedArgument;
    }
"	@return wrapped up value TODO(danielwh): See if JSONObject and JSONArray have a useful common superclass	@return wrapped up value	1	0	17	32	246
"private IterOutcome produceOutputBatch() { boolean isLeftProcessed = false; // Try to fully pack the outgoing container while (!isOutgoingBatchFull()) { final int previousOutputCount = outputIndex; // invoke the runtime generated method to emit records in the output batch for each leftJoinIndex crossJoinAndOutputRecords(); // We have produced some records in outgoing container, hence there must be a match found for left record if (outputIndex > previousOutputCount) { // Need this extra flag since there can be left join case where for current leftJoinIndex it receives a right // batch with data, then an empty batch and again another empty batch with EMIT outcome. If we just use // outputIndex then we will loose the information that few rows for leftJoinIndex is already produced using // first right batch matchedRecordFound = true; } // One right batch might span across multiple output batch. So rightIndex will be moving sum of all the // output records for this record batch until it's fully consumed. // // Also it can be so that one output batch can contain records from 2 different right batch hence the // rightJoinIndex should move by number of records in output batch for current right batch only. rightJoinIndex += outputIndex - previousOutputCount; final boolean isRightProcessed = rightJoinIndex == -1 || rightJoinIndex >= right.getRecordCount(); // Check if above join to produce output was based on empty right batch or // it resulted in right side batch to be fully consumed. In this scenario only if rightUpstream // is EMIT then increase the leftJoinIndex. // Otherwise it means for the given right batch there is still some record left to be processed. if (isRightProcessed) { if (rightUpstream == EMIT) { if (!matchedRecordFound && JoinRelType.LEFT == popConfig.getJoinType()) { // copy left side in case of LEFT join emitLeft(leftJoinIndex, outputIndex, 1); ++outputIndex; } ++leftJoinIndex; // Reset matchedRecord for next left index record matchedRecordFound = false; } // Release vectors of right batch. This will happen for both rightUpstream = EMIT/OK VectorAccessibleUtilities.clear(right); rightJoinIndex = -1; } // Check if previous left record was last one, then set leftJoinIndex to -1 isLeftProcessed = leftJoinIndex >= left.getRecordCount(); if (isLeftProcessed) { leftJoinIndex = -1; VectorAccessibleUtilities.clear(left); } // Check if output batch still has some space if (!isOutgoingBatchFull()) { // Check if left side still has records or not if (isLeftProcessed) { // The current left batch was with EMIT/OK_NEW_SCHEMA outcome, then return output to downstream layer before // getting next batch if (leftUpstream == EMIT || leftUpstream == OK_NEW_SCHEMA) { break; } else { logger.debug(""Output batch still has some space left, getting new batches from left and right""); // Get both left batch and the right batch and make sure indexes are properly set leftUpstream = processLeftBatch(); // output batch is not empty and we have new left batch with OK_NEW_SCHEMA or terminal outcome if (processLeftBatchInFuture) { logger.debug(""Received left batch with outcome {} such that we have to return the current outgoing "" + ""batch and process the new batch in subsequent next call"", leftUpstream); // We should return the current output batch with OK outcome and don't reset the leftUpstream finalizeOutputContainer(); return OK; } // If left batch received a terminal outcome then don't call right batch if (isTerminalOutcome(leftUpstream)) { finalizeOutputContainer(); return leftUpstream; } // If we have received the left batch with EMIT outcome and is empty then we should return previous output // batch with EMIT outcome if ((leftUpstream == EMIT || leftUpstream == OK_NEW_SCHEMA) && left.getRecordCount() == 0) { isLeftProcessed = true; break; } // Update the batch memory manager to use new left incoming batch updateMemoryManager(LEFT_INDEX); } } // If we are here it means one of the below: // 1) Either previous left batch was not fully processed and it came with OK outcome. There is still some space // left in outgoing batch so let's get next right batch. // 2) OR previous left & right batch was fully processed and it came with OK outcome. There is space in outgoing // batch. Now we have got new left batch with OK outcome. Let's get next right batch // 3) OR previous left & right batch was fully processed and left came with OK outcome. Outgoing batch is // empty since all right batches were empty for all left rows. Now we got another non-empty left batch with // OK_NEW_SCHEMA. rightUpstream = processRightBatch(); if (rightUpstream == OK_NEW_SCHEMA) { leftUpstream = (leftUpstream != EMIT) ? OK : leftUpstream; rightUpstream = OK; finalizeOutputContainer(); return OK_NEW_SCHEMA; } if (isTerminalOutcome(rightUpstream)) { finalizeOutputContainer(); return rightUpstream; } // Update the batch memory manager to use new right incoming batch updateMemoryManager(RIGHT_INDEX); // If OK_NEW_SCHEMA is seen only on non empty left batch but not on right batch, then we should setup schema in // output container based on new left schema and old right schema. If schema change failed then return STOP // downstream if (leftUpstream == OK_NEW_SCHEMA && isLeftProcessed) { if (!handleSchemaChange()) { return STOP; } // Since schema has change so we have new empty vectors in output container hence allocateMemory for them allocateVectors(); } } } // output batch is full to its max capacity finalizeOutputContainer(); // Check if output batch was full and left was fully consumed or not. Since if left is not consumed entirely // but output batch is full, then if the left batch came with EMIT outcome we should send this output batch along // with OK outcome not with EMIT. Whereas if output is full and left is also fully consumed then we should send // EMIT outcome. if (leftUpstream == EMIT && isLeftProcessed) { logger.debug(""Sending current output batch with EMIT outcome since left is received with EMIT and is fully "" + ""consumed in output batch""); return EMIT; } if (leftUpstream == OK_NEW_SCHEMA) { // return output batch with OK_NEW_SCHEMA and reset the state to OK logger.debug(""Sending current output batch with OK_NEW_SCHEMA and resetting the left outcome to OK for next set"" + "" of batches""); leftUpstream = OK; return OK_NEW_SCHEMA; } return OK; }"	"  private IterOutcome produceOutputBatch() {

    boolean isLeftProcessed = false;

    // Try to fully pack the outgoing container
    while (!isOutgoingBatchFull()) {
      final int previousOutputCount = outputIndex;
      // invoke the runtime generated method to emit records in the output batch for each leftJoinIndex
      crossJoinAndOutputRecords();

      // We have produced some records in outgoing container, hence there must be a match found for left record
      if (outputIndex > previousOutputCount) {
        // Need this extra flag since there can be left join case where for current leftJoinIndex it receives a right
        // batch with data, then an empty batch and again another empty batch with EMIT outcome. If we just use
        // outputIndex then we will loose the information that few rows for leftJoinIndex is already produced using
        // first right batch
        matchedRecordFound = true;
      }

      // One right batch might span across multiple output batch. So rightIndex will be moving sum of all the
      // output records for this record batch until it's fully consumed.
      //
      // Also it can be so that one output batch can contain records from 2 different right batch hence the
      // rightJoinIndex should move by number of records in output batch for current right batch only.
      rightJoinIndex += outputIndex - previousOutputCount;
      final boolean isRightProcessed = rightJoinIndex == -1 || rightJoinIndex >= right.getRecordCount();

      // Check if above join to produce output was based on empty right batch or
      // it resulted in right side batch to be fully consumed. In this scenario only if rightUpstream
      // is EMIT then increase the leftJoinIndex.
      // Otherwise it means for the given right batch there is still some record left to be processed.
      if (isRightProcessed) {
        if (rightUpstream == EMIT) {
          if (!matchedRecordFound && JoinRelType.LEFT == popConfig.getJoinType()) {
            // copy left side in case of LEFT join
            emitLeft(leftJoinIndex, outputIndex, 1);
            ++outputIndex;
          }
          ++leftJoinIndex;
          // Reset matchedRecord for next left index record
          matchedRecordFound = false;
        }

        // Release vectors of right batch. This will happen for both rightUpstream = EMIT/OK
        VectorAccessibleUtilities.clear(right);
        rightJoinIndex = -1;
      }

      // Check if previous left record was last one, then set leftJoinIndex to -1
      isLeftProcessed = leftJoinIndex >= left.getRecordCount();
      if (isLeftProcessed) {
        leftJoinIndex = -1;
        VectorAccessibleUtilities.clear(left);
      }

      // Check if output batch still has some space
      if (!isOutgoingBatchFull()) {
        // Check if left side still has records or not
        if (isLeftProcessed) {
          // The current left batch was with EMIT/OK_NEW_SCHEMA outcome, then return output to downstream layer before
          // getting next batch
          if (leftUpstream == EMIT || leftUpstream == OK_NEW_SCHEMA) {
            break;
          } else {
            logger.debug(""Output batch still has some space left, getting new batches from left and right"");
            // Get both left batch and the right batch and make sure indexes are properly set
            leftUpstream = processLeftBatch();

            if (processLeftBatchInFuture) {
              logger.debug(""Received left batch with outcome {} such that we have to return the current outgoing "" +
                ""batch and process the new batch in subsequent next call"", leftUpstream);
              // We should return the current output batch with OK outcome and don't reset the leftUpstream
              finalizeOutputContainer();
              return OK;
            }

            // If left batch received a terminal outcome then don't call right batch
            if (isTerminalOutcome(leftUpstream)) {
              finalizeOutputContainer();
              return leftUpstream;
            }

            // If we have received the left batch with EMIT outcome and is empty then we should return previous output
            // batch with EMIT outcome
            if (leftUpstream == EMIT && left.getRecordCount() == 0) {
              isLeftProcessed = true;
              break;
            }

            // Update the batch memory manager to use new left incoming batch
            updateMemoryManager(LEFT_INDEX);
          }
        }

        // If we are here it means one of the below:
        // 1) Either previous left batch was not fully processed and it came with OK outcome. There is still some space
        // left in outgoing batch so let's get next right batch.
        // 2) OR previous left & right batch was fully processed and it came with OK outcome. There is space in outgoing
        // batch. Now we have got new left batch with OK outcome. Let's get next right batch
        //
        // It will not hit OK_NEW_SCHEMA since left side have not seen that outcome
        rightUpstream = processRightBatch();
        Preconditions.checkState(rightUpstream != OK_NEW_SCHEMA, ""Unexpected schema change in right branch"");

        if (isTerminalOutcome(rightUpstream)) {
          finalizeOutputContainer();
          return rightUpstream;
        }

        // Update the batch memory manager to use new right incoming batch
        updateMemoryManager(RIGHT_INDEX);
      }
    } // output batch is full to its max capacity

    finalizeOutputContainer();

    // Check if output batch was full and left was fully consumed or not. Since if left is not consumed entirely
    // but output batch is full, then if the left batch came with EMIT outcome we should send this output batch along
    // with OK outcome not with EMIT. Whereas if output is full and left is also fully consumed then we should send
    // EMIT outcome.
    if (leftUpstream == EMIT && isLeftProcessed) {
      logger.debug(""Sending current output batch with EMIT outcome since left is received with EMIT and is fully "" +
        ""consumed in output batch"");
      return EMIT;
    }

    if (leftUpstream == OK_NEW_SCHEMA) {
      // return output batch with OK_NEW_SCHEMA and reset the state to OK
      logger.debug(""Sending current output batch with OK_NEW_SCHEMA and resetting the left outcome to OK for next set"" +
        "" of batches"");
      leftUpstream = OK;
      return OK_NEW_SCHEMA;
    }
    return OK;
  }
"	@return - IterOutcome to be send along with output batch to downstream operator	@return - IterOutcome to be send along with output batch to downstream operator	0	1	16	154	1239
public static AbstractSchema getTemporaryWorkspace(SchemaPlus defaultSchema, DrillConfig config) { String temporarySchema = config.getString(ExecConstants.DEFAULT_TEMPORARY_WORKSPACE); List<String> temporarySchemaPath = Lists.newArrayList(temporarySchema); SchemaPlus schema = findSchema(defaultSchema, temporarySchemaPath); return schema == null ? null : unwrapAsDrillSchemaInstance(schema); }	"public static AbstractSchema getTemporaryWorkspace(SchemaPlus defaultSchema, DrillConfig config) {
    List<String> temporarySchemaPath = Lists.newArrayList(config.getString(ExecConstants.DEFAULT_TEMPORARY_WORKSPACE));
    AbstractSchema temporarySchema = resolveToMutableDrillSchema(defaultSchema, temporarySchemaPath);
    if (!(temporarySchema instanceof WorkspaceSchemaFactory.WorkspaceSchema)) {
        DrillRuntimeException.format(STR + STR, temporarySchemaPath);
    }
    return temporarySchema;
}"	@return default temporary workspace, null if workspace was not found	@return default temporary workspace	1	0	6	6	51
"public void uploadFile (Long petId, String additionalMetadata, File file) throws TimeoutException, ExecutionException, InterruptedException, ApiException { Object postBody = null; // verify the required parameter 'petId' is set if (petId == null) { VolleyError error = new VolleyError(""Missing the required parameter 'petId' when calling uploadFile"", new ApiException(400, ""Missing the required parameter 'petId' when calling uploadFile"")); } // create path and map variables String path = ""/pet/{petId}/uploadImage"".replaceAll(""\\{format\\}"",""json"").replaceAll(""\\{"" + ""petId"" + ""\\}"", apiInvoker.escapeString(petId.toString())); // query params List<Pair> queryParams = new ArrayList<Pair>(); // header params Map<String, String> headerParams = new HashMap<String, String>(); // form params Map<String, String> formParams = new HashMap<String, String>(); String[] contentTypes = { ""multipart/form-data"" }; String contentType = contentTypes.length > 0 ? contentTypes[0] : ""application/json""; if (contentType.startsWith(""multipart/form-data"")) { // file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); if (additionalMetadata != null) { localVarBuilder.addTextBody(""additionalMetadata"", ApiInvoker.parameterToString(additionalMetadata), ApiInvoker.TEXT_PLAIN_UTF8); } if (file != null) { localVarBuilder.addBinaryBody(""file"", file); } HttpEntity httpEntity = localVarBuilder.build(); postBody = httpEntity; } else { // normal form params formParams.put(""additionalMetadata"", ApiInvoker.parameterToString(additionalMetadata)); } String[] authNames = new String[] { ""petstore_auth"" }; try { String localVarResponse = apiInvoker.invokeAPI (basePath, path, ""POST"", queryParams, postBody, headerParams, formParams, contentType, authNames); if (localVarResponse != null) { return ; } else { return ; } } catch (ApiException ex) { throw ex; } catch (InterruptedException ex) { throw ex; } catch (ExecutionException ex) { if (ex.getCause() instanceof VolleyError) { VolleyError volleyError = (VolleyError)ex.getCause(); if (volleyError.networkResponse != null) { throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage()); } } throw ex; } catch (TimeoutException ex) { throw ex; } }"	"  public ApiResponse uploadFile (Long petId, String additionalMetadata, File file) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'petId' is set
    if (petId == null) {
      VolleyError error = new VolleyError(""Missing the required parameter 'petId' when calling uploadFile"",
        new ApiException(400, ""Missing the required parameter 'petId' when calling uploadFile""));
    }

    // create path and map variables
    String path = ""/pet/{petId}/uploadImage"".replaceAll(""\\{"" + ""petId"" + ""\\}"", apiInvoker.escapeString(petId.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
      ""multipart/form-data""
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : ""application/json"";

    if (contentType.startsWith(""multipart/form-data"")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      if (additionalMetadata != null) {
        localVarBuilder.addTextBody(""additionalMetadata"", ApiInvoker.parameterToString(additionalMetadata), ApiInvoker.TEXT_PLAIN_UTF8);
      }
      if (file != null) {
        localVarBuilder.addBinaryBody(""file"", file);
      }
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
      formParams.put(""additionalMetadata"", ApiInvoker.parameterToString(additionalMetadata));
    }

    String[] authNames = new String[] { ""petstore_auth"" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, ""POST"", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (ApiResponse) ApiInvoker.deserialize(localVarResponse, """", ApiResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }
"	@return void	@return ApiResponse	1	0	11	64	468
"private String getASGAccount(String asgName) { Applications apps = PeerAwareInstanceRegistry.getInstance().getApplications(false); for (Application app : apps.getRegisteredApplications()) { for (InstanceInfo instanceInfo : app.getInstances()) { String thisAsgName = instanceInfo.getASGName(); if (thisAsgName != null && thisAsgName.equals(asgName)) { String localAccountId = getAccountId(instanceInfo, null); if (localAccountId != null) { return localAccountId; } } } } logger.info(""Couldn't get the ASG account for {}, using the default accountId instead"", asgName); return accountId; }"	"    private String getASGAccount(String asgName) {
        Applications apps = PeerAwareInstanceRegistryImpl.getInstance().getApplications(false);

        for (Application app : apps.getRegisteredApplications()) {
            for (InstanceInfo instanceInfo : app.getInstances()) {
                String thisAsgName = instanceInfo.getASGName();
                if (thisAsgName != null && thisAsgName.equals(asgName)) {
                    String accountId = ((AmazonInfo) instanceInfo.getDataCenterInfo()).get(MetaDataKey.accountId);
                    if (accountId != null) {
                        return accountId;
                    }
                }
            }
        }

        logger.warn(""Couldn't get the ASG account for {}, using the default accountId instead"", asgName);
        return accountId;
    }
"	@return the account id	@return the account id	0	1	12	19	114
public boolean isSelected(final ToolItem toolItem) { boolean selectionState = Display.syncExec(new ResultRunnable<Boolean>() { @Override public Boolean run() { return toolItem.getSelection(); } }); return selectionState; }	"public boolean isSelected(final ToolItem w) {
    boolean selectionState = Display.syncExec(new ResultRunnable<Boolean>() {

        @Override
        public Boolean run() {
            return w.getSelection();
        }
    });
    return selectionState;
}"	@return true if specified tool item is selected, false otherwise	@return returns widget label text	1	0	9	10	42
private ZapTextField getTxtProxyChainRealm() { if (txtProxyChainRealm == null) { txtProxyChainRealm = new ZapTextField(); } return txtProxyChainRealm; }	"	private JTextField getTxtProxyChainRealm() {
		if (txtProxyChainRealm == null) {
			txtProxyChainRealm = new JTextField();
		}
		return txtProxyChainRealm;
	}
"	@return javax.swing.ZapTextField	@return javax.swing.JTextField	1	0	8	7	23
long getFieldValue(ReadablePeriod period) { PeriodType type; if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) { type = null; // Don't need to check if supported. } else { type = period.getPeriodType(); } int value; switch (iFieldType) { default: return Long.MAX_VALUE; case 1: if (type != null && type.years().isSupported() == false) { return Long.MAX_VALUE; } value = period.getYears(); break; case 2: if (type != null && type.months().isSupported() == false) { return Long.MAX_VALUE; } value = period.getMonths(); break; case 3: if (type != null && type.weeks().isSupported() == false) { return Long.MAX_VALUE; } value = period.getWeeks(); break; case 4: if (type != null && type.days().isSupported() == false) { return Long.MAX_VALUE; } value = period.getDays(); break; case 5: if (type != null && type.hours().isSupported() == false) { return Long.MAX_VALUE; } value = period.getHours(); break; case 6: if (type != null && type.minutes().isSupported() == false) { return Long.MAX_VALUE; } value = period.getMinutes(); break; case 7: if (type != null && type.seconds().isSupported() == false) { return Long.MAX_VALUE; } value = period.getSeconds(); break; case 8: if (type != null && type.millis().isSupported() == false) { return Long.MAX_VALUE; } value = period.getMillis(); break; case 9: // drop through case 10: if (type != null && type.seconds().isSupported() == false && type.millis().isSupported() == false) { return Long.MAX_VALUE; } value = period.getSeconds() * DateTimeConstants.MILLIS_PER_SECOND + period.getMillis(); break; } if (value == 0 && iPrintZeroSetting == PRINT_ZERO_RARELY) { return Long.MAX_VALUE; } return value; }	"        long getFieldValue(ReadablePeriod period) {
            PeriodType type;
            if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) {
                type = null; // Don't need to check if supported.
            } else {
                type = period.getPeriodType();
            }

            int value;

            switch (iFieldType) {
            default:
                return -1;
            case 1:
                if (type != null && type.years().isSupported() == false) {
                    return -1;
                }
                value = period.getYears();
                break;
            case 2:
                if (type != null && type.months().isSupported() == false) {
                    return -1;
                }
                value = period.getMonths();
                break;
            case 3:
                if (type != null && type.weeks().isSupported() == false) {
                    return -1;
                }
                value = period.getWeeks();
                break;
            case 4:
                if (type != null && type.days().isSupported() == false) {
                    return -1;
                }
                value = period.getDays();
                break;
            case 5:
                if (type != null && type.hours().isSupported() == false) {
                    return -1;
                }
                value = period.getHours();
                break;
            case 6:
                if (type != null && type.minutes().isSupported() == false) {
                    return -1;
                }
                value = period.getMinutes();
                break;
            case 7:
                if (type != null && type.seconds().isSupported() == false) {
                    return -1;
                }
                value = period.getSeconds();
                break;
            case 8:
                if (type != null && type.millis().isSupported() == false) {
                    return -1;
                }
                value = period.getMillis();
                break;
            }

            if (value == 0 && iPrintZeroSetting == PRINT_ZERO_RARELY) {
                return -1;
            }

            return value & 0xffffffffL;
        }
"	@return Long.MAX_VALUE if nothing to print, otherwise value	@return negative value if nothing to print, otherwise lower 32 bits is signed int value.	1	0	10	77	395
public boolean isNull(RexNode expr) { switch (expr.getKind()) { case LITERAL: return ((RexLiteral) expr).getValue2() == null; case LOCAL_REF: RexLocalRef inputRef = (RexLocalRef) expr; return isNull(exprs.get(inputRef.index)); case CAST: return isNull(((RexCall) expr).operands.get(0)); default: return false; } }	"    public boolean isNull(RexNode expr)
    {
        if (RexLiteral.isNullLiteral(expr)) {
            return true;
        }
        if (expr instanceof RexLocalRef) {
            RexLocalRef inputRef = (RexLocalRef) expr;
            return isNull(exprs.get(inputRef.index));
        }
        if (expr.getKind() == SqlKind.CAST) {
            return isNull(((RexCall) expr).operands.get(0));
        }
        return false;
    }
"	@return Whether expression always evaluates to null	@return Whether expression always evaluates to null	0	1	8	15	78
public final Image[] getPendingImages() { return pendingImages != null ? Arrays.copyOf(pendingImages, pendingImages.length) : new Image[NUM]; }	"public final Image[] getPendingImages() {
    return pendingImages != null ? Arrays.copyOf(pendingImages, pendingImages.length) : null;
}"	@return A image list.	@return A image list or <code>null</code>.	1	0	6	3	30
"private int externalToInternalRow(int extRow) { if (extRow < -mActiveTranscriptRows || extRow > mScreenRows) { String errorMessage = ""externalToInternalRow ""+ extRow + "" "" + mScreenRows + "" "" + mActiveTranscriptRows; Log.e(TAG, errorMessage); throw new IllegalArgumentException(errorMessage); } if (extRow >= 0) { return (mScreenFirstRow + extRow) % mTotalRows; } else { if (-extRow > mScreenFirstRow) { return mTotalRows + mScreenFirstRow + extRow; } else { return mScreenFirstRow + extRow; } } }"	"    private int externalToInternalRow(int extRow) {
        if (extRow < -mActiveTranscriptRows || extRow > mScreenRows) {
            String errorMessage = ""externalToInternalRow ""+ extRow +
                "" "" + mScreenRows + "" "" + mActiveTranscriptRows;
            Log.e(TAG, errorMessage);
            throw new IllegalArgumentException(errorMessage);
        }

        if (extRow >= 0) {
            return extRow;
        } else {
            if (mNextTranscriptRow >= -extRow) {
                return mScreenRows + mNextTranscriptRow + extRow;
            } else {
                return mScreenRows + mActiveTranscriptRows + mNextTranscriptRow + extRow;
            }
        }
    }
"	@return The row corresponding to the input argument in the private coordinate system.	@return The row corresponding to the input argument in the private coordinate system.	0	1	12	19	96
public static Type<?> valueOf(String name) { return ModTheMod.getGame().getTypeManager().getType(name); }	"public static Type valueOf(String name) {
    return null;
}"	@return The {@link Type} corresponding with the given name.	@return The {@link Type}.	1	0	6	3	24
synchronized public Value put(Transaction tx, Key key, Value value) throws IOException { Value oldValue = null; if (lastGetNodeCache != null) { if(lastGetEntryCache.getKey().equals(key)) { oldValue = lastGetEntryCache.setValue(value); lastGetEntryCache.setValue(value); lastGetNodeCache.storeUpdate(tx); return oldValue; } // This searches from the last location of a call to get for the element to replace // all the way to the end of the ListIndex. Iterator<Map.Entry<Key, Value>> iterator = lastGetNodeCache.iterator(tx); while (iterator.hasNext()) { Map.Entry<Key, Value> entry = iterator.next(); if (entry.getKey().equals(key)) { oldValue = entry.setValue(value); ((ListIterator) iterator).getCurrent().storeUpdate(tx); return oldValue; } } } // Not found because the cache wasn't set or its not at the end of the list so we // start from the beginning and go to the cached location or the end, then we do // an add if its not found. Iterator<Map.Entry<Key, Value>> iterator = iterator(tx); while (iterator.hasNext() && ((ListIterator) iterator).getCurrent() != lastGetNodeCache) { Map.Entry<Key, Value> entry = iterator.next(); if (entry.getKey().equals(key)) { oldValue = entry.setValue(value); ((ListIterator) iterator).getCurrent().storeUpdate(tx); return oldValue; } } // Not found so add it last. return add(tx, key, value); }	"    synchronized public Value put(Transaction tx, Key key, Value value) throws IOException {
        return add(tx, key, value);
    }
"	@return the old value contained in the list if one exists or null.	@return null	1	0	12	43	313
protected CoreLabel fromProto(CoreNLPProtos.Token proto) { CoreLabel word = new CoreLabel(); // Required fields word.setWord(proto.getWord()); // Optional fields if (proto.hasPos()) { word.setTag(proto.getPos()); } if (proto.hasValue()) { word.setValue(proto.getValue()); } if (proto.hasCategory()) { word.setCategory(proto.getCategory()); } if (proto.hasBefore()) { word.setBefore(proto.getBefore()); } if (proto.hasAfter()) { word.setAfter(proto.getAfter()); } if (proto.hasOriginalText()) { word.setOriginalText(proto.getOriginalText()); } if (proto.hasNer()) { word.setNER(proto.getNer()); } if (proto.hasLemma()) { word.setLemma(proto.getLemma()); } if (proto.hasBeginChar()) { word.setBeginPosition(proto.getBeginChar()); } if (proto.hasEndChar()) { word.setEndPosition(proto.getEndChar()); } if (proto.hasSpeaker()) { word.set(SpeakerAnnotation.class, proto.getSpeaker()); } if (proto.hasUtterance()) { word.set(UtteranceAnnotation.class, proto.getUtterance()); } if (proto.hasBeginIndex()) { word.set(BeginIndexAnnotation.class, proto.getBeginIndex()); } if (proto.hasEndIndex()) { word.set(EndIndexAnnotation.class, proto.getEndIndex()); } if (proto.hasTokenBeginIndex()) { word.set(TokenBeginAnnotation.class, proto.getTokenBeginIndex()); } if (proto.hasTokenEndIndex()) { word.set(TokenEndAnnotation.class, proto.getTokenEndIndex()); } if (proto.hasNormalizedNER()) { word.set(NormalizedNamedEntityTagAnnotation.class, proto.getNormalizedNER()); } if (proto.hasTimexValue()) { word.set(TimexAnnotation.class, fromProto(proto.getTimexValue())); } if (proto.hasHasXmlContext() && proto.getHasXmlContext()) { word.set(XmlContextAnnotation.class, proto.getXmlContextList()); } if (proto.hasCorefClusterID()) { word.set(CorefClusterIdAnnotation.class, proto.getCorefClusterID()); } if (proto.hasAnswer()) { word.set(AnswerAnnotation.class, proto.getAnswer()); } // Non-default annotators if (proto.hasGender()) { word.set(GenderAnnotation.class, proto.getGender()); } if (proto.hasTrueCase()) { word.set(TrueCaseAnnotation.class, proto.getTrueCase()); } if (proto.hasTrueCaseText()) { word.set(TrueCaseTextAnnotation.class, proto.getTrueCaseText()); } // Return return word; }	"  protected CoreMap fromProto(CoreNLPProtos.Sentence proto) {
    CoreMap sentence = new ArrayCoreMap();
    // Required fields
    sentence.set(TokenBeginAnnotation.class, proto.getTokenOffsetBegin());
    sentence.set(TokenEndAnnotation.class, proto.getTokenOffsetEnd());
    // Optional fields
    if (proto.hasSentenceIndex()) { sentence.set(SentenceIndexAnnotation.class, proto.getSentenceIndex()); }
    if (proto.hasCharacterOffsetBegin()) { sentence.set(CharacterOffsetBeginAnnotation.class, proto.getCharacterOffsetBegin()); }
    if (proto.hasCharacterOffsetEnd()) { sentence.set(CharacterOffsetEndAnnotation.class, proto.getCharacterOffsetEnd()); }
    if (proto.hasParseTree()) { sentence.set(TreeAnnotation.class, fromProto(proto.getParseTree())); }
    // Non-default fields
    if (proto.hasHasRelationAnnotations() && proto.getHasRelationAnnotations()) {
      // set entities
      List<EntityMention> entities = new ArrayList<EntityMention>();
      for (CoreNLPProtos.Entity entity : proto.getEntityList()) { entities.add(fromProto(entity, sentence)); }
      sentence.set(EntityMentionsAnnotation.class, entities);
      // set relations
      List<RelationMention> relations = new ArrayList<RelationMention>();
      for (CoreNLPProtos.Relation relation : proto.getRelationList()) { relations.add(fromProto(relation, sentence)); }
      sentence.set(RelationMentionsAnnotation.class, relations);
    }
    // Return
    return sentence;
  }
"	@return A CoreLabel, missing the fields that are not stored in the CoreLabel protobuf.	@return A CoreMap, representing a sentence as stored in the protocol buffer (and therefore missing some fields)	1	0	8	34	529
"public String getTypeDeclaration(Schema p) { if (ModelUtils.isArraySchema(p)) { ArraySchema ap = (ArraySchema) p; Schema inner = ap.getItems(); return ""["" + getTypeDeclaration(inner) + ""]""; } else if (ModelUtils.isMapSchema(p)) { Schema inner = (Schema) p.getAdditionalProperties(); return ""%{optional(String.t) => "" + getTypeDeclaration(inner) + ""}""; } else if (ModelUtils.isPasswordSchema(p)) { return ""String.t""; } else if (ModelUtils.isEmailSchema(p)) { return ""String.t""; } else if (ModelUtils.isByteArraySchema(p)) { return ""binary()""; } else if (ModelUtils.isUUIDSchema(p)) { return ""String.t""; } else if (ModelUtils.isDateSchema(p)) { return ""Date.t""; } else if (ModelUtils.isDateTimeSchema(p)) { return ""DateTime.t""; } else if (ModelUtils.isObjectSchema(p)) { // How to map it? return super.getTypeDeclaration(p); } else if (ModelUtils.isIntegerSchema(p)) { return ""integer()""; } else if (ModelUtils.isNumberSchema(p)) { return ""float()""; } else if (ModelUtils.isBinarySchema(p)) { return ""binary()""; } else if (ModelUtils.isBooleanSchema(p)) { return ""boolean()""; } else if (!StringUtils.isEmpty(p.get$ref())) { // model // How to map it? return super.getTypeDeclaration(p); } else if (ModelUtils.isFileSchema(p)) { return ""String.t""; } else if (ModelUtils.isStringSchema(p)) { return ""String.t""; } return super.getTypeDeclaration(p); }"	"    public String getTypeDeclaration(Property p) {
        // SubClasses of AbstractProperty
        //
        // ArrayProperty
        // MapProperty
        // PasswordProperty
        // StringProperty
        //     EmailProperty
        //     ByteArrayProperty
        // DateProperty
        // UUIDProperty
        // DateTimeProperty
        // ObjectProperty
        // AbstractNumericProperty
        //     BaseIntegerProperty
        //         IntegerProperty
        //         LongProperty
        //     DecimalProperty
        //         DoubleProperty
        //         FloatProperty
        // BinaryProperty
        // BooleanProperty
        // RefProperty
        // FileProperty
        if (p instanceof ArrayProperty) {
            ArrayProperty ap = (ArrayProperty) p;
            Property inner = ap.getItems();
            return ""["" + getTypeDeclaration(inner) + ""]"";
        } else if (p instanceof MapProperty) {
            MapProperty mp = (MapProperty) p;
            Property inner = mp.getAdditionalProperties();
            return ""%{optional(String.t) => "" + getTypeDeclaration(inner) + ""}"";
        } else if (p instanceof PasswordProperty) {
            return ""String.t"";
        } else if (p instanceof EmailProperty) {
            return ""String.t"";
        } else if (p instanceof ByteArrayProperty) {
            return ""binary()"";
        } else if (p instanceof StringProperty) {
            return ""String.t"";
        } else if (p instanceof DateProperty) {
            return ""Date.t"";
        } else if (p instanceof UUIDProperty) {
            return ""String.t"";
        } else if (p instanceof DateTimeProperty) {
            return ""DateTime.t"";
        } else if (p instanceof ObjectProperty) {
            // How to map it?
            return super.getTypeDeclaration(p);
        } else if (p instanceof IntegerProperty) {
            return ""integer()"";
        } else if (p instanceof LongProperty) {
            return ""integer()"";
        } else if (p instanceof BaseIntegerProperty) {
            return ""integer()"";
        } else if (p instanceof DoubleProperty) {
            return ""float()"";
        } else if (p instanceof FloatProperty) {
            return ""float()"";
        } else if (p instanceof DecimalProperty) {
            return ""float()"";
        } else if (p instanceof AbstractNumericProperty) {
            return ""number()"";
        } else if (p instanceof BinaryProperty) {
            return ""binary()"";
        } else if (p instanceof BooleanProperty) {
            return ""boolean()"";
        } else if (p instanceof RefProperty) {
            // How to map it?
            return super.getTypeDeclaration(p);
        } else if (p instanceof FileProperty) {
            return ""String.t"";
        }
        return super.getTypeDeclaration(p);
    }
"	@return a string value used as the `dataType` field for model templates, `returnType` for api templates	@return a string value used as the `dataType` field for model templates, `returnType` for api templates	0	1	21	42	363
protected Point getPositionInScreen(View view) { if (getParent() == null) { return new Point(); } ViewGroup parent; try { parent = (ViewGroup) view.getParent(); } catch (Exception e) { return new Point(); } if (parent == null) { return new Point(); } Point point = getPositionInScreen(parent); point.offset((int) view.getX(), (int) view.getY()); return point; }	"protected PointF getPositionInScreen(View view) {
    if (getParent() == null) {
        return new PointF();
    }
    ViewGroup parent;
    try {
        parent = (ViewGroup) view.getParent();
    } catch (Exception e) {
        return new PointF();
    }
    if (parent == null) {
        return new PointF();
    }
    PointF point = getPositionInScreen(parent);
    point.offset(view.getX(), view.getY());
    return point;
}"	@return Point determining position of the passed in view inside all of its ViewParents.	@return PointF determining position of the passed in view inside all of its ViewParents.	1	0	7	17	95
public static EntityMode parse(String entityMode) { if ( entityMode == null ) { return POJO; } if ( MAP.externalName.equalsIgnoreCase( entityMode ) ) { return MAP; } return valueOf( entityMode.toUpperCase( Locale.ENGLISH ) ); }	"	public static EntityMode parse(String entityMode) {
		if ( entityMode == null ) {
			return POJO;
		}
		entityMode = entityMode.toUpperCase();
		if ( DYNAMIC_MAP_NAME.equals( entityMode ) ) {
			return MAP;
		}
		return valueOf( entityMode );
	}
"	@return The appropriate entity mode;  null for incoming  entityMode param is treated by returning  #POJO.	@return The appropriate entity mode; null for incoming entityMode param is treated by returning #POJO.	0	1	6	10	45
"public static String getFullUrl(HttpServletRequest request) { if (request.getQueryString() == null) { return request.getRequestURI(); } return request.getRequestURI() + ""?"" + request.getQueryString(); }"	"    public static String getFullUrl(HttpServletRequest request) {
        final StringBuilder url = new StringBuilder(100).append(request.getRequestURI());
        if (request.getQueryString() != null) {
            url.append('?').append(request.getQueryString());
        }
        return url.toString();
    }
"	@return the full URL, including the query string	@return the full URL, including the query string	0	1	6	9	41
private CollectionPersister getPersister(SharedSessionContractImplementor session) { return getPersister( session.getFactory() ); }	"	private CollectionPersister getPersister(SharedSessionContractImplementor session) {
		return session.getFactory().getMetamodel().collectionPersister( role );
	}
"	@return The underlying collection persister	@return The underlying collection persister	0	1	5	4	18
"public ResponseEntity<Void> updatePetWithHttpInfo(Pet body) throws RestClientException { Object postBody = body; // verify the required parameter 'body' is set if (body == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'body' when calling updatePet""); } String path = apiClient.expandPath(""/pet"", Collections.<String, Object>emptyMap()); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { ""application/json"", ""application/xml"" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { ""petstore_auth"" }; ParameterizedTypeReference<Void> returnType = new ParameterizedTypeReference<Void>() {}; return apiClient.invokeAPI(path, HttpMethod.PUT, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType); }"	"    public ResponseEntity<Void> updatePetWithHttpInfo(Pet body) throws RestClientException {
        Object postBody = body;
        
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'body' when calling updatePet"");
        }
        
        String path = apiClient.expandPath(""/pet"", Collections.<String, Object>emptyMap());

        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();
        final HttpHeaders headerParams = new HttpHeaders();
        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();

        final String[] accepts = { };
        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);
        final String[] contentTypes = { 
            ""application/json"", ""application/xml""
        };
        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);

        String[] authNames = new String[] { ""petstore_auth"" };

        ParameterizedTypeReference<Void> returnType = new ParameterizedTypeReference<Void>() {};
        return apiClient.invokeAPI(path, HttpMethod.PUT, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);
    }
"	@return ResponseEntity&lt;Void&gt;	@return ResponseEntity&lt;Void&gt;	0	1	8	28	223
@JsonIgnore @SuppressWarnings(STR) @Nullable public <T extends Credentials> Credentials getLoginDetails(Class<T> loginDetailsClass) { return Maps.uniqueIndex(this.credentials, new Function<Credentials, Class<Credentials>>() { @Override public Class<Credentials> apply(@Nullable Credentials credentials) { if (credentials != null) { return (Class<Credentials>) credentials.getClass(); } return null; } }).get(loginDetailsClass); }	"@JsonIgnore
@SuppressWarnings(STR)
@Nullable
public <T extends LoginDetails> LoginDetails getLoginDetails(Class<T> loginDetailsClass) {
    return Maps.uniqueIndex(this.loginDetails, new Function<LoginDetails, Class<LoginDetails>>() {

        @Override
        public Class<LoginDetails> apply(@Nullable LoginDetails loginDetails) {
            if (loginDetails != null) {
                return (Class<LoginDetails>) loginDetails.getClass();
            }
            return null;
        }
    }).get(loginDetailsClass);
}"	@return Credentials instance corresponding to the given Credentials class. Null if no such id found.	@return LoginDetails instance corresponding to the given LoginDetails class. Null if no such id found.	1	0	13	15	80
public static String encodeValue(Value value) { if (value instanceof BNode) { return ((BNode) value).getID(); } return NTriplesUtil.toNTriplesString(value); }	"public static String encodeValue(Value value) {
    return NTriplesUtil.toNTriplesString(value);
}"	@return The protocol-serialized representation of the supplied value, or {@link #NULL_PARAM_VALUE} if the supplied value was <tt>null</tt>.	@return The N-Triples representation of the supplied value, or {@link #NULL_PARAM_VALUE} if the supplied value was <tt>null</tt>.	1	0	7	6	36
protected Writer openTestLog() throws Exception { File testClassDir = new File( getTestlogRoot(), ReflectUtil.getUnqualifiedClassName(getClass())); testClassDir.mkdirs(); File testLogFile = new File( testClassDir, testCaseName); return new OutputStreamWriter( openTestLogOutputStream(testLogFile), StandardCharsets.UTF_8); }	"  protected Writer openTestLog() throws Exception {
    File testClassDir =
        new File(
            getTestlogRoot(),
            ReflectUtil.getUnqualifiedClassName(getClass()));
    testClassDir.mkdirs();
    File testLogFile =
        new File(
            testClassDir,
            testCaseName);
    return new OutputStreamWriter(openTestLogOutputStream(testLogFile));
  }
"	@return Writer for log file, which caller should use as a destination for test output to be diffed	@return Writer for log file, which caller should use as a destination for test output to be diffed	0	1	7	14	55
"public static int[] getViewToHeaderBodyPosition(JTextArea view, String header, int start, int end) { validateView(view); validateHeader(header); validateStartEnd(start, end); if (!isValidStartEndForLength(start, end, view.getDocument().getLength())) { return INVALID_POSITION; } int excessChars = 0; int pos = 0; while ((pos = header.indexOf(""\r\n"", pos)) != -1) { pos += 2; ++excessChars; } if (start + excessChars < header.length()) { int[] position = getViewToHeaderPositionImpl(view, start, end); if (position[1] > header.length()) { position[1] = header.length(); } return position; } int finalStartPos = start + excessChars - header.length(); int finalEndPos = end + excessChars - header.length(); return new int[] { finalStartPos, finalEndPos, 0 }; }"	"    public static int[] getViewToHeaderBodyPosition(JTextArea view, String header, int start, int end) {
        validateView(view);
        validateHeader(header);
        validateStartEnd(start, end, view.getDocument().getLength());

        int excessChars = 0;
        int pos = 0;
        while ((pos = header.indexOf(""\r\n"", pos)) != -1) {
            pos += 2;
            ++excessChars;
        }

        if (start + excessChars < header.length()) {
            int[] position = getViewToHeaderPositionImpl(view, start, end);
            if (position[1] > header.length()) {
                position[1] = header.length();
            }
            return position;
        }

        int finalStartPos = start + excessChars - header.length();
        int finalEndPos = end + excessChars - header.length();
        return new int[] { finalStartPos, finalEndPos, 0 };
    }
"	@return the positions offset for the header or, 3 positions, for after the body (the third position is just to indicate that it's the body, the value is meaningless), or  #INVALID_POSITION if the  start or  end is greater than the length of the  view	@return the positions offset for the header or, 3 positions, for after the body (the third position is just to indicate that it's the body, the value is meaningless)	1	0	11	29	185
"static HintStrategyTable createHintStrategies(HintStrategyTable.Builder builder) { return builder .hintStrategy(""no_hash_join"", HintPredicates.JOIN) .hintStrategy(""time_zone"", HintPredicates.SET_VAR) .hintStrategy(""REPARTITION"", HintPredicates.SET_VAR) .hintStrategy(""index"", HintPredicates.TABLE_SCAN) .hintStrategy(""properties"", HintPredicates.TABLE_SCAN) .hintStrategy( ""resource"", HintPredicates.or( HintPredicates.PROJECT, HintPredicates.AGGREGATE, HintPredicates.CALC)) .hintStrategy(""AGG_STRATEGY"", HintStrategyTable.strategyBuilder(HintPredicates.AGGREGATE) .optionChecker( (hint, errorHandler) -> errorHandler.check( hint.listOptions.size() == 1 && (hint.listOptions.get(0).equalsIgnoreCase(""ONE_PHASE"") || hint.listOptions.get(0).equalsIgnoreCase(""TWO_PHASE"")), ""Hint {} only allows single option, "" + ""allowed options: [ONE_PHASE, TWO_PHASE]"", hint.hintName)).build()) .hintStrategy(""use_hash_join"", HintPredicates.and(HintPredicates.JOIN, joinWithFixedTableName())) .hintStrategy(""use_merge_join"", HintStrategyTable.strategyBuilder( HintPredicates.and(HintPredicates.JOIN, joinWithFixedTableName())) .excludedRules(EnumerableRules.ENUMERABLE_JOIN_RULE).build()) .build(); }"	"    static HintStrategyTable createHintStrategies(HintStrategyTable.Builder builder) {
      return builder
        .hintStrategy(""no_hash_join"", HintStrategies.JOIN)
        .hintStrategy(""time_zone"", HintStrategies.SET_VAR)
        .hintStrategy(""REPARTITION"", HintStrategies.SET_VAR)
        .hintStrategy(""index"", HintStrategies.TABLE_SCAN)
        .hintStrategy(""properties"", HintStrategies.TABLE_SCAN)
        .hintStrategy(
            ""resource"", HintStrategies.or(
            HintStrategies.PROJECT, HintStrategies.AGGREGATE, HintStrategies.CALC))
        .hintStrategy(""AGG_STRATEGY"",
            HintStrategyTable.entryBuilder(HintStrategies.AGGREGATE)
                .optionChecker(
                    (hint, errorHandler) -> errorHandler.check(
                    hint.listOptions.size() == 1
                        && (hint.listOptions.get(0).equalsIgnoreCase(""ONE_PHASE"")
                        || hint.listOptions.get(0).equalsIgnoreCase(""TWO_PHASE"")),
                    ""Hint {} only allows single option, ""
                        + ""allowed options: [ONE_PHASE, TWO_PHASE]"",
                    hint.hintName)).build())
        .hintStrategy(""use_hash_join"",
          HintStrategies.and(HintStrategies.JOIN, joinWithFixedTableName()))
        .hintStrategy(""use_merge_join"",
            HintStrategyTable.entryBuilder(
                HintStrategies.and(HintStrategies.JOIN, joinWithFixedTableName()))
                .excludedRules(EnumerableRules.ENUMERABLE_JOIN_RULE).build())
        .build();
    }
"	@return HintStrategyTable instance	@return HintStrategyTable instance	0	1	14	29	216
@NonNull protected SCMProbe createProbe(@NonNull final SCMHead head, @CheckForNull final SCMRevision revision) throws IOException { throw new AbstractMethodError(); }	"@CheckForNull
protected SCMProbe createProbe(@NonNull final SCMHead head, @CheckForNull final SCMRevision revision) throws IOException {
    return null;
}"	@return the {@link SCMSourceCriteria.Probe}.	@return the {@link SCMSourceCriteria.Probe} or {@code null} if this source cannot be probed.	1	0	5	4	28
public static float convertDpToPixel(float dp, Context context) { float scale = context.getResources().getDisplayMetrics().density; return dp * scale + 0.5f; }	"    public static float convertDpToPixel(float dp, Context context){
        Resources resources = context.getResources();
        DisplayMetrics metrics = resources.getDisplayMetrics();
        float px = dp * ((float)metrics.densityDpi / DisplayMetrics.DENSITY_DEFAULT);
        return px;
    }
"	@return A float value to represent px equivalent to dp depending on device density	@return A float value to represent px equivalent to dp depending on device density	0	1	6	5	32
public static int getOrientation(InputStream is) { try { int length = moveToAPP1EXIF(is); if (length == 0) { return ExifInterface.ORIENTATION_UNDEFINED; } return TiffUtil.readOrientationFromTIFF(is, length); } catch (IOException ioe) { return ExifInterface.ORIENTATION_UNDEFINED; } }	"  public static int getOrientation(InputStream is) {
    try {
      int length = moveToAPP1EXIF(is);
      if (length == 0) {
        return 0; // unknown orientation
      }
      return TiffUtil.readOrientationFromTIFF(is, length);
    } catch (IOException ioe) {
      return 0;
    }
  }
"	@return orientation: 1/8/3/6. Returns  android.media.ExifInterface#ORIENTATION_UNDEFINED if there is no valid orientation information.	@return orientation: 1/8/3/6. Returns 0 if there is no valid orientation information.	1	0	7	12	51
public EAttribute getChange_State() { return (EAttribute) changeEClass.getEStructuralFeatures().get(NUM); }	"public EReference getChange_State() {
    return (EReference) changeEClass.getEStructuralFeatures().get(NUM);
}"	@return the meta object for the attribute '<em>State</em>'.	@return the meta object for the containment reference '<em>State</em>'.	1	0	7	3	20
public Vector<QueueItem> getQueue() { return queue; }	"    public Vector getQueue() {
        return queue;
    }
"	@return Returns the queue.	@return Returns the queue.	0	1	5	4	11
public static By partialLinkText(final String partialLinkText) { return new ByPartialLinkText(partialLinkText); }	"public static By partialLinkText(final String linkText) {
    if (linkText == null)
        throw new IllegalArgumentException(STR);
    return new ByPartialLinkText(linkText);
}"	@return a By which locates A elements that contain the given link text	@return A By which locates A elements that contain the given text.	1	0	5	3	18
"public ArrayList<TextView> clickLongInList(int line, int index){ if(config.commandLogging){ Log.d(config.commandLoggingTag, ""clickLongInList(""+line+"", ""+index+"")""); } return clicker.clickInList(line, index, 0, true, 0); }"	"	public ArrayList<TextView> clickLongInList(int line, int index){
		if(config.commandLogging){
			Log.d(config.commandLoggingTag, ""clickLongInList(""+line+"", ""+index+"")"");
		}
		
		return clicker.clickInList(line, index, true, 0);
	}
"	@return an  ArrayList of the  TextView objects located in the list line	@return an ArrayList of the TextView objects located in the list line	0	1	11	8	59
"private boolean scrollScrollView(final ScrollView view, int direction){ if(view == null){ Log.e(TAG, ""ScrollView was null""); return false; } int height = view.getHeight(); height--; int scrollTo = -1; if (direction == DOWN) { scrollTo = height; } else if (direction == UP) { scrollTo = -height; } int originalY = view.getScrollY(); final int scrollAmount = scrollTo; inst.runOnMainSync(new Runnable(){ public void run(){ view.scrollBy(0, scrollAmount); } }); if (originalY == view.getScrollY()) { return false; } else{ return true; } }"	"	private boolean scrollScrollView(int direction, ArrayList<ScrollView> scrollViews){
		final ScrollView scroll = viewFetcher.getView(ScrollView.class, scrollViews);
		int scrollAmount = 0;
		
		if(scroll != null){
			int height = scroll.getHeight();
			height--;
			int scrollTo = 0;

			if (direction == DOWN) {
				scrollTo = (height);
			}

			else if (direction == UP) {
				scrollTo = (-height);
			}
			scrollAmount = scroll.getScrollY();
			scrollScrollViewTo(scroll,0, scrollTo);
			if (scrollAmount == scroll.getScrollY()) {
				return false;
			}
			else{
				return true;
			}
		}
		return false;
	}
"	@return  true if scrolling occurred, false if it did not	@return true if more scrolling can be done	1	0	9	38	130
static StringList parseImports(StringDict properties) { StringList outgoing = new StringList(); String importStr = properties.get(IMPORTS_PROPERTY); if (importStr != null) { String[] importList = PApplet.trim(PApplet.split(importStr, ',')); for (String importName : importList) { if (!importName.isEmpty()) { outgoing.append(importName); } } } return (outgoing.size() > 0) ? outgoing : null; }	"  static List<String> parseImports(String importStr) {
    List<String> outgoing = new ArrayList<String>();

    if (importStr != null) {
      String[] importList = PApplet.trim(PApplet.split(importStr, ','));
      for (String importName : importList) {
        outgoing.add(importName);
      }
    }
    return (outgoing.size() > 0) ? outgoing : null;
  }
"	@return null if no entries found	@return the list of imports that this contribution (library) contains.	1	0	11	15	88
"public Order placeOrder (Order body) throws ApiException { Object localVarPostBody = body; // create path and map variables String localVarPath = ""/store/order"".replaceAll(""\\{format\\}"",""json""); // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); // header params Map<String, String> localVarHeaderParams = new HashMap<String, String>(); // form params Map<String, String> localVarFormParams = new HashMap<String, String>(); String[] localVarContentTypes = { }; String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : ""application/json""; if (localVarContentType.startsWith(""multipart/form-data"")) { // file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); localVarPostBody = localVarBuilder.build(); } else { // normal form params } try { String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, ""POST"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType); if(localVarResponse != null){ return (Order) ApiInvoker.deserialize(localVarResponse, """", Order.class); } else { return null; } } catch (ApiException ex) { throw ex; } }"	"  public Order  placeOrder (Order body) throws ApiException {
    Object postBody = body;
    

    // create path and map variables
    String path = ""/store/order"".replaceAll(""\\{format\\}"",""json"");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    

    

    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : ""application/json"";

    if (contentType.startsWith(""multipart/form-data"")) {
      // file uploading
      MultipartEntityBuilder builder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = builder.build();
      postBody = httpEntity;
    } else {
      // normal form params
      
    }

    try {
      String response = apiInvoker.invokeAPI(basePath, path, ""POST"", queryParams, postBody, headerParams, formParams, contentType);
      if(response != null){
        return (Order) ApiInvoker.deserialize(response, """", Order.class);
      }
      else {
        return null;
      }
    } catch (ApiException ex) {
      throw ex;
    }
  }
"	@return Order	@return Order	0	1	10	47	226
public GremlinPipeline<S, Vertex> V() { return this.add(new VerticesPipe()); }	"public T V() {
    return this.add(new VerticesPipe());
}"	@return the extended Pipeline	@return the extended FluentPipeline	1	0	7	3	20
public Options includeScalarTypes(boolean flag) { return new Options(this.includeIntrospectionTypes, flag, this.includeExtendedScalars, this.includeSchemaDefinition, this.includeDirectives, this.useAstDefinitions, this.descriptionsAsHashComments, this.comparatorRegistry); }	"        public Options includeScalarTypes(boolean flag) {
            return new Options(this.includeIntrospectionTypes, flag, this.includeExtendedScalars, this.includeSchemaDefinition, this.includeDirectives, this.useAstDefinitions, this.comparatorRegistry);
        }
"	@return options	@return options	0	1	6	4	37
public boolean isTa() { return curEdit_STR_Value.length() > TA_LENGTH || curEdit_STR_Value.indexOf(STR) > NUM; }	"public boolean isTa() {
    return curEdit_STR_Value.length() > TA_LENGTH;
}"	@return <code>true</code> if the edit-value is longer then <code>TA_LENGTH</code> chars or has a line break	@return <code>true</code> if the edit-value is longer then <code>TA_LENGTH</code> chars	1	0	7	3	22
"private Node parseTo(Set<Class<? extends TokenNode>> stopSet, TokenNode forWhat) { ImmutableList.Builder<Node> nodeList = ImmutableList.builder(); while (true) { Node currentNode = currentNode(); if (stopSet.contains(currentNode.getClass())) { break; } if (currentNode instanceof EofNode) { throw new ParseException( ""Reached end of file while parsing "" + forWhat.name(), forWhat.resourceName, forWhat.lineNumber); } Node parsed; if (currentNode instanceof TokenNode) { parsed = parseTokenNode(); } else { parsed = currentNode; nextNode(); } nodeList.add(parsed); } return Node.cons(forWhat.resourceName, forWhat.lineNumber, nodeList.build()); }"	"  private Node parseTo(Set<Class<? extends TokenNode>> stopSet, TokenNode forWhat) {
    ImmutableList.Builder<Node> nodeList = ImmutableList.builder();
    while (true) {
      Node currentNode = currentNode();
      if (stopSet.contains(currentNode.getClass())) {
        break;
      }
      if (currentNode instanceof EofNode) {
        throw new ParseException(
            ""Reached end of file while parsing "" + forWhat.name(), forWhat.lineNumber);
      }
      Node parsed;
      if (currentNode instanceof TokenNode) {
        parsed = parseTokenNode();
      } else {
        parsed = currentNode;
        nextNode();
      }
      nodeList.add(parsed);
    }
    return Node.cons(forWhat.lineNumber, nodeList.build());
  }
"	@return a Node that is the concatenation of the parsed subtrees	@return a Node that is the concatenation of the parsed subtrees	0	1	10	25	133
protected Chronology getChronology() { return iInstant.getChronology(); }	"public Chronology getChronology() {
    return iChronology;
}"	@return the chronology	@return the Chronology that the date is using	1	0	4	3	13
public CardViewWrapper getCardView() { return mCardView; }	"    public CommonCardView getCardView() {
        return mCardView;
    }
"	@return the complete View component	@return the complete View component	0	1	4	4	10
public double getRotY() { return Math.toDegrees(mOrientation.getRotationY()); }	"public double getRotY() {
    return mOrientation.getRotationY();
}"	@return double The yaw Euler angle in degrees.	@return double The yaw Euler angle.	1	0	5	3	17
public boolean isEmpty(){ return size <= 0; }	"    public boolean isEmpty(){
        return batchList.isEmpty();
    }
"	@return true if there are no pending messages	@return true if there are no pending messages	0	1	5	4	11
@Deprecated public static String getUserAgent() { return instance(); }	"public static String getUserAgent() {
    String webUserAgent = null;
    try {
        Class<?> sysResCls = Class.forName(STR);
        Field webUserAgentField = sysResCls.getDeclaredField(STR);
        Integer resId = (Integer) webUserAgentField.get(null);
        webUserAgent = NoHttp.getContext().getString(resId);
    } catch (Exception e) {
    }
    if (TextUtils.isEmpty(webUserAgent)) {
        webUserAgent = STR;
    }
    Locale locale = Locale.getDefault();
    StringBuffer buffer = new StringBuffer();
    final String version = Build.VERSION.RELEASE;
    if (version.length() > NUM) {
        buffer.append(version);
    } else {
        buffer.append(STR);
    }
    buffer.append(STR);
    final String language = locale.getLanguage();
    if (language != null) {
        buffer.append(language.toLowerCase(locale));
        final String country = locale.getCountry();
        if (!TextUtils.isEmpty(country)) {
            buffer.append(STR);
            buffer.append(country.toLowerCase(locale));
        }
    } else {
        buffer.append(STR);
    }
    if (STR.equals(Build.VERSION.CODENAME)) {
        final String model = Build.MODEL;
        if (model.length() > NUM) {
            buffer.append(STR);
            buffer.append(model);
        }
    }
    final String id = Build.ID;
    if (id.length() > NUM) {
        buffer.append(STR);
        buffer.append(id);
    }
    return String.format(webUserAgent, buffer, STR);
}"	@return String.	@return UA.	1	0	4	4	15
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; // set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { String str = yytext(); int first = str.charAt(0); String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } LOGGER.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: LOGGER.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 35: break; case 2: { if (normalizeOtherBrackets) { return getNext(openparen, yytext()); } else { return getNext(); } } case 36: break; case 3: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 37: break; case 4: { return getNext(); } case 38: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 39: break; case 6: { if (normalizeOtherBrackets) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 40: break; case 7: { final String origTxt = yytext(); return getNext (asciiQuotes(origTxt), origTxt); } case 41: break; case 8: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 42: break; case 9: { if (invertible) { prevWordAfter.append(yytext()); } } case 43: break; case 10: { return handleEllipsis(yytext()); } case 44: break; case 11: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { String origTxt = yytext(); return getNext(asciiDash(origTxt), origTxt); } } case 45: break; case 12: { return normalizeFractions(yytext()); } case 46: break; case 13: { final String origTxt = yytext(); return getNext(asciiQuotes(origTxt), origTxt); } case 47: break; case 14: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 48: break; case 15: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 49: break; case 16: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 50: break; case 17: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 51: break; case 18: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 52: break; case 19: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(); } case 53: break; case 20: { final String origTxt = yytext(); return getNext(origTxt, origTxt, CONTR_ANNOTATION); } case 54: break; case 21: { final String origTxt = yytext(); return getNext(origTxt, origTxt, VB_PRON_ANNOTATION); } case 55: break; case 22: // general lookahead, find correct zzMarkedPos { int zzFState = 1; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 2; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 56: break; case 23: { if (!noSGML) { return getNext(); } } case 57: break; case 24: { final String origTxt = yytext(); return getNext(asciiQuotes(asciiDash(origTxt)), origTxt, COMPOUND_ANNOTATION); } case 58: break; case 25: { // this one should only match if we're basically at the end of file // since the last one matches two things, even newlines String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 59: break; case 26: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 60: break; case 27: { final String origTxt = yytext(); return getNext(asciiQuotes(asciiDash(origTxt)), origTxt); } case 61: break; case 28: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 62: break; case 29: { return getNormalizedAmpNext(); } case 63: break; case 30: // lookahead expression with fixed lookahead length yypushback(2); { return getNext(); } case 64: break; case 31: // general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 65: break; case 32: { yypushback(3) ; return getNext(); } case 66: break; case 33: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } return getNext(txt, yytext()); } case 67: break; case 34: { String txt = yytext(); if (normalizeParentheses) { txt = txt.replaceAll(""\\("", openparen); txt = txt.replaceAll(""\\)"", closeparen); } return getNext(txt, yytext()); } case 68: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }"	"  public Object next() throws java.io.IOException {
    int zzInput;
    int zzAction;

    // cached fields:
    int zzCurrentPosL;
    int zzMarkedPosL;
    int zzEndReadL = zzEndRead;
    char [] zzBufferL = zzBuffer;
    char [] zzCMapL = ZZ_CMAP;

    int [] zzTransL = ZZ_TRANS;
    int [] zzRowMapL = ZZ_ROWMAP;
    int [] zzAttrL = ZZ_ATTRIBUTE;

    while (true) {
      zzMarkedPosL = zzMarkedPos;

      yychar+= zzMarkedPosL-zzStartRead;

      zzAction = -1;

      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
  
      zzState = ZZ_LEXSTATE[zzLexicalState];

      // set up zzAction for empty match case:
      int zzAttributes = zzAttrL[zzState];
      if ( (zzAttributes & 1) == 1 ) {
        zzAction = zzState;
      }


      zzForAction: {
        while (true) {
    
          if (zzCurrentPosL < zzEndReadL)
            zzInput = zzBufferL[zzCurrentPosL++];
          else if (zzAtEOF) {
            zzInput = YYEOF;
            break zzForAction;
          }
          else {
            // store back cached positions
            zzCurrentPos  = zzCurrentPosL;
            zzMarkedPos   = zzMarkedPosL;
            boolean eof = zzRefill();
            // get translated positions and possibly new buffer
            zzCurrentPosL  = zzCurrentPos;
            zzMarkedPosL   = zzMarkedPos;
            zzBufferL      = zzBuffer;
            zzEndReadL     = zzEndRead;
            if (eof) {
              zzInput = YYEOF;
              break zzForAction;
            }
            else {
              zzInput = zzBufferL[zzCurrentPosL++];
            }
          }
          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
          if (zzNext == -1) break zzForAction;
          zzState = zzNext;

          zzAttributes = zzAttrL[zzState];
          if ( (zzAttributes & 1) == 1 ) {
            zzAction = zzState;
            zzMarkedPosL = zzCurrentPosL;
            if ( (zzAttributes & 8) == 8 ) break zzForAction;
          }

        }
      }

      // store back cached position
      zzMarkedPos = zzMarkedPosL;

      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
        case 1: 
          { String str = yytext();
          int first = str.charAt(0);
          String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));
          switch (untokenizable) {
            case NONE_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              break;
            case FIRST_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              if ( ! this.seenUntokenizableCharacter) {
                LOGGER.warning(msg);
                this.seenUntokenizableCharacter = true;
              }
              break;
            case ALL_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              LOGGER.warning(msg);
              this.seenUntokenizableCharacter = true;
              break;
            case NONE_KEEP:
              return getNext();
            case FIRST_KEEP:
              if ( ! this.seenUntokenizableCharacter) {
                LOGGER.warning(msg);
                this.seenUntokenizableCharacter = true;
              }
              return getNext();
            case ALL_KEEP:
              LOGGER.warning(msg);
              this.seenUntokenizableCharacter = true;
              return getNext();
          }
          }
        case 33: break;
        case 2: 
          { if (normalizeOtherBrackets) {
                    return getNext(openparen, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 34: break;
        case 3: 
          { if (escapeForwardSlashAsterisk) {
                    return getNext(delimit(yytext(), '/'), yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 35: break;
        case 4: 
          { return getNext();
          }
        case 36: break;
        case 5: 
          { if (tokenizeNLs) {
                      return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns
                  } else if (invertible) {
                      prevWordAfter.append(yytext());
                  }
          }
        case 37: break;
        case 6: 
          { if (normalizeOtherBrackets) {
                    return getNext(closeparen, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 38: break;
        case 7: 
          { if (ptb3Dashes) {
                            return getNext(ptbmdash, yytext()); }
                          else {
                            return getNext();
                          }
          }
        case 39: break;
        case 8: 
          { if (invertible) {
                     prevWordAfter.append(yytext());
                  }
          }
        case 40: break;
        case 9: 
          { return handleEllipsis(yytext());
          }
        case 41: break;
        case 10: 
          { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {
	            return getNext(ptbmdash, yytext());
                  } else {
		    String origTxt = yytext();
                    return getNext(asciiDash(origTxt), origTxt);
		  }
          }
        case 42: break;
        case 11: 
          { return normalizeFractions(yytext());
          }
        case 43: break;
        case 12: 
          { final String origTxt = yytext();
                          return getNext(asciiQuotes(origTxt), origTxt);
          }
        case 44: break;
        case 13: 
          { if (normalizeOtherBrackets) {
                    return getNext(closebrace, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 45: break;
        case 14: 
          { if (normalizeParentheses) {
                    return getNext(openparen, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 46: break;
        case 15: 
          { if (normalizeParentheses) {
                    return getNext(closeparen, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 47: break;
        case 16: 
          { if (escapeForwardSlashAsterisk) {
                    return getNext(delimit(yytext(), '*'), yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 48: break;
        case 17: 
          { if (normalizeOtherBrackets) {
                    return getNext(openbrace, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 49: break;
        case 18: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return getNext();
          }
        case 50: break;
        case 19: 
          { final String origTxt = yytext();
			  return getNext(origTxt, origTxt, CONTR_ANNOTATION);
          }
        case 51: break;
        case 20: 
          { final String origTxt = yytext();
                          return getNext(origTxt, origTxt, VB_PRON_ANNOTATION);
          }
        case 52: break;
        case 21: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 1;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
            while (zzFPos <= zzMarkedPos) {
              zzFinL[zzFPos++] = false;
            }

            zzFState = 2;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { return getNext();
          }
        case 53: break;
        case 22: 
          { if (!noSGML) {
                            return getNext();
			  }
          }
        case 54: break;
        case 23: 
          { final String origTxt = yytext();
                          return getNext(asciiDash(origTxt), origTxt, COMPOUND_ANNOTATION);
          }
        case 55: break;
        case 24: 
          { // this one should only match if we're basically at the end of file
			  // since the last one matches two things, even newlines
                          String s;
                          if (strictTreebank3 && ! ""U.S."".equals(yytext())) {
                            yypushback(1); // return a period for next time
                            s = yytext();
                          } else {
                            s = yytext();
                            yypushback(1); // return a period for next time
                          }
	                  return getNext(s, yytext());
          }
        case 56: break;
        case 25: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 5;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
            while (zzFPos <= zzMarkedPos) {
              zzFinL[zzFPos++] = false;
            }

            zzFState = 6;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { return getNext();
          }
        case 57: break;
        case 26: 
          { String txt = yytext();
                          if (escapeForwardSlashAsterisk) {
                            txt = delimit(txt, '/');
                            txt = delimit(txt, '*');
                          }
                          return getNext(txt, yytext());
          }
        case 58: break;
        case 27: 
          { return getNormalizedAmpNext();
          }
        case 59: break;
        case 28: 
          // lookahead expression with fixed lookahead length
          yypushback(2);
          { return getNext();
          }
        case 60: break;
        case 29: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 3;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
            while (zzFPos <= zzMarkedPos) {
              zzFinL[zzFPos++] = false;
            }

            zzFState = 4;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { String s;
                          if (strictTreebank3 && ! ""U.S."".equals(yytext())) {
                            yypushback(1); // return a period for next time
                            s = yytext();
                          } else {
                            s = yytext();
                            yypushback(1); // return a period for next time
                          }
	                  return getNext(s, yytext());
          }
        case 61: break;
        case 30: 
          { yypushback(3) ; return getNext();
          }
        case 62: break;
        case 31: 
          { String txt = yytext();
                          if (escapeForwardSlashAsterisk) {
                            txt = delimit(txt, '/');
                          }
                          return getNext(txt, yytext());
          }
        case 63: break;
        case 32: 
          { String txt = yytext();
			  if (normalizeParentheses) {
			    txt = txt.replaceAll(""\\("", openparen);
			    txt = txt.replaceAll(""\\)"", closeparen);
			  }
			  return getNext(txt, yytext());
          }
        case 64: break;
        default: 
          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
            zzAtEOF = true;
              {
                if (invertible) {
            prevWordAfter.append(yytext());
            String str = prevWordAfter.toString();
            prevWordAfter.setLength(0);
            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);
          }
          return null;
              }
          } 
          else {
            zzScanError(ZZ_NO_MATCH);
          }
      }
    }
  }
"	@return the next token	@return the next token	0	1	17	431	2315
public int get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }	"public int get(WithAttributes attributes) {
    return attributes.getAttributes().get(this);
}"	@return the value of this attribute if this attribute is present in the extracted map. Otherwise {@link #getDefaultValue()}	@return the value of this attribute if this attribute is present in the map. Otherwise {@link #getDefaultValue()}	1	0	6	3	19
"public DateTimeFormatterBuilder appendText(DateTimeFieldType fieldType) { if (fieldType == null) { throw new IllegalArgumentException(""Field type must not be null""); } return append0(new TextField(fieldType, iLocale, false)); }"	"    public DateTimeFormatterBuilder appendText(DateTimeFieldType fieldType) {
        if (fieldType == null) {
            throw new IllegalArgumentException(""Field type must not be null"");
        }
        DateTimeField field = fieldType.getField(iChronoUTC);
        return append0(new TextField(iChrono, field, iLocale, false));
    }
"	@return this DateTimeFormatterBuilder	@return this DateTimeFormatterBuilder	0	1	7	7	44
"protected Transport createTransport() throws JMSException { try { URI connectBrokerUL = brokerURL; String scheme = brokerURL.getScheme(); if (scheme == null) { throw new IOException(""Transport not scheme specified: ["" + brokerURL + ""]""); } if (scheme.equals(""auto"")) { connectBrokerUL = new URI(brokerURL.toString().replace(""auto"", ""tcp"")); } else if (scheme.equals(""auto+ssl"")) { connectBrokerUL = new URI(brokerURL.toString().replace(""auto+ssl"", ""ssl"")); } else if (scheme.equals(""auto+nio"")) { connectBrokerUL = new URI(brokerURL.toString().replace(""auto+nio"", ""nio"")); } else if (scheme.equals(""auto+nio+ssl"")) { connectBrokerUL = new URI(brokerURL.toString().replace(""auto+nio+ssl"", ""nio+ssl"")); } return TransportFactory.connect(connectBrokerUL); } catch (Exception e) { throw JMSExceptionSupport.create(""Could not create Transport. Reason: "" + e, e); } }"	"    protected Transport createTransport() throws JMSException {
        try {
            return TransportFactory.connect(brokerURL);
        } catch (Exception e) {
            throw JMSExceptionSupport.create(""Could not create Transport. Reason: "" + e, e);
        }
    }
"	@return The newly created Transport.	@return The newly created Transport.	0	1	14	23	231
public static boolean canEdit(Permissions perms, Permissions user2Perms) { if (isAdmin(perms)) return true; if (isAdmin(user2Perms)) return false; return getManagementLevel(perms) > getManagementLevel(user2Perms); }	"public static boolean canEdit(User manager, User toEdit) {
    if (isAdmin(manager))
        return true;
    if (isAdmin(toEdit))
        return false;
    return getManagementLevel(manager) > getManagementLevel(toEdit);
}"	@return Whether the user with the first given permissions can modify the user with the second	@return Whether the first user can modify the second	1	0	6	7	43
public DateTimeField minuteOfHour() { return UnsupportedDateTimeField.getInstance(DateTimeFieldType.minuteOfHour(), minutes()); }	"    public DateTimeField minuteOfHour() {
        return UnsupportedDateTimeField.getInstance(""minuteOfHour"", minutes());
    }
"	@return DateTimeField or UnsupportedDateTimeField if unsupported	@return DateTimeField or UnsupportedDateTimeField if unsupported	0	1	5	4	21
"private ZapTextArea getTxtPattern() { if (txtPattern == null) { txtPattern = new ZapTextArea(); txtPattern.setLineWrap(true); txtPattern.setFont(new java.awt.Font(""Courier New"", java.awt.Font.PLAIN, 12)); txtPattern.addMouseListener(new java.awt.event.MouseAdapter() { public void mousePressed(java.awt.event.MouseEvent e) { if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0) { // right // mouse // button view.getPopupMenu().show(e.getComponent(), e.getX(), e.getY()); } } }); } return txtPattern; }"	"    private JTextArea getTxtPattern() {
        if (txtPattern == null) {
            txtPattern = new JTextArea();
            txtPattern.setLineWrap(true);
            txtPattern.setFont(new java.awt.Font(""Courier New"",
                    java.awt.Font.PLAIN, 12));
            txtPattern.addMouseListener(new java.awt.event.MouseAdapter() {
                public void mousePressed(java.awt.event.MouseEvent e) {
                    if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0) { // right
                                                                             // mouse
                                                                             // button
                        view.getPopupMenu().show(e.getComponent(), e.getX(),
                                e.getY());
                    }
                }

            });

        }
        return txtPattern;
    }
"	@return javax.swing.ZapTextArea	@return javax.swing.JTextField	1	0	14	22	124
public int getMaxLineLength() { return maxLineLength; }	"public int getMaxLineLength() {
    return InputThread.MAX_LINE_LENGTH;
}"	@return The maximum line length (default 512)	@return The maximum line length (currently fixed at 512)	1	0	4	3	10
public long getDifferenceAsLong(ReadableInstant instant) { if (instant == null) { return getField().getDifferenceAsLong(getReadableInstant().getMillis(), DateTimeUtils.currentTimeMillis()); } return getField().getDifferenceAsLong(getReadableInstant().getMillis(), instant.getMillis()); }	"    public long getDifferenceAsLong(ReadableInstant instant) {
        if (instant == null) {
            throw new IllegalArgumentException(""The instant must not be null"");
        }
        return getField().getDifferenceAsLong(getReadableInstant().getMillis(), instant.getMillis());
    }
"	@return the difference in the units of this field	@return the difference in the units of this field	0	1	9	7	54
public RecordsForCollection forCollection(CollectionId collectionId) { return recordMakerByCollectionId.computeIfAbsent(collectionId, id -> { String topicName = topicSelector.topicNameFor(collectionId); return new RecordsForCollection(collectionId, source, topicName, schemaNameAdjuster, valueTransformer, recorder, emitTombstonesOnDelete); }); }	"    public RecordsForCollection forCollection(CollectionId collectionId) {
        return recordMakerByCollectionId.computeIfAbsent(collectionId, id -> {
            String topicName = topicSelector.getTopic(collectionId);
            return new RecordsForCollection(collectionId, source, topicName, schemaNameAdjuster, valueTransformer, recorder, emitTombstonesOnDelete);
        });
    }
"	@return the table-specific record maker; may be null if the table is not included in the connector	@return the table-specific record maker; may be null if the table is not included in the connector	0	1	9	7	48
public int distanceTo(WorldPoint other) { return distanceTo(new WorldArea(other, NUM, NUM)); }	"public int distanceTo(WorldArea other) {
    if (this.getPlane() != other.getPlane()) {
        return Integer.MAX_VALUE;
    }
    Point distances = getAxisDistances(other);
    return Math.max(distances.getX(), distances.getY());
}"	@return the distance, or {@link Integer#MAX_VALUE} if the planes differ	@return Returns the distance	1	0	6	3	23
static boolean implementsMethod(TypeElement clazz, MethodSpec method, Types typeUtils) { ExecutableElement methodOnClass = getMethodOnClass(clazz, method, typeUtils); if (methodOnClass == null) { return false; } Element implementingClass = methodOnClass.getEnclosingElement(); if (implementingClass.getSimpleName().toString().equals(STR)) { return false; } Set<Modifier> modifiers = methodOnClass.getModifiers(); return !modifiers.contains(Modifier.ABSTRACT); }	"static boolean implementsMethod(TypeElement clazz, MethodSpec method, Types typeUtils) {
    ExecutableElement methodOnClass = getMethodOnClass(clazz, method, typeUtils);
    if (methodOnClass == null) {
        return false;
    }
    Set<Modifier> modifiers = methodOnClass.getModifiers();
    return !modifiers.contains(Modifier.ABSTRACT);
}"	@return True if the clazz (or one of its superclasses except for Object) implements the given method. Returns false if the method doesn't exist anywhere in the class hierarchy or it is abstract.	@return True if the clazz (or one of its superclasses) implements the given method. Returns false if the method doesn't exist anywhere in the class hierarchy or it is abstract.	1	0	6	12	79
public static LdapContext createPathContext(LdapContext authorityContext, String[] pathTokens) throws NamingException { for (int i = NUM; i < (pathTokens.length); i++) { String subContext = CN + STR + pathTokens[i]; authorityContext = (LdapContext) createSubContext(authorityContext, subContext, null); } return authorityContext; }	"public static LdapContext createPathContext(LdapContext ldapContext, String[] pathTokens) throws NamingException {
    for (int i = NUM; i < (pathTokens.length); i++) {
        String subContext = CN + STR + pathTokens[i];
        ldapContext = (LdapContext) createSubContext(ldapContext, subContext, null);
    }
    return ldapContext;
}"	@return the ldap context	@return the dir context	1	0	10	7	62
private boolean isSpillNeeded(int incomingSize) { // Can't spill if less than two batches else the merge // can't make progress. if (bufferedBatches.size() < 2) { return false; } // Must spill if we are below the spill point (the amount of memory // needed to do the minimal spill.) return allocator.getAllocatedMemory() + incomingSize >= bufferMemoryPool; }	"  private boolean isSpillNeeded(int incomingSize) {

    // Can't spill if less than two batches else the merge
    // can't make progress.

    if (bufferedBatches.size() < 2) {
      return false; }

    // Must spill if we are below the spill point (the amount of memory
    // needed to do the minimal spill.)

    if (allocator.getAllocatedMemory() + incomingSize >= bufferMemoryPool) {
      return true; }

    // For test purposes, configuration may have set a limit on the number of
    // batches in memory. Spill if we exceed this limit. (By default the number
    // of in-memory batches is unlimited.)

    return bufferedBatches.size() > bufferedBatchLimit;
  }
"	@return true if spilling is needed, false otherwise	@return true if spilling is needed, false otherwise	0	1	6	14	77
public Double getRowCount(RelNode rel) { for (;;) { try { Double result = rowCountHandler.getRowCount(rel, this); return RelMdUtil.validateResult(result); } catch (JaninoRelMetadataProvider.NoHandler e) { rowCountHandler = revise(e.relClass, BuiltInMetadata.RowCount.DEF); } } }	"  public Double getRowCount(RelNode rel) {
    for (;;) {
      try {
        Double result = rowCountHandler.getRowCount(rel, this);
        return validateResult(result);
      } catch (JaninoRelMetadataProvider.NoHandler e) {
        rowCountHandler = revise(e.relClass, BuiltInMetadata.RowCount.DEF);
      }
    }
  }
"	@return estimated row count, or null if no reliable estimate can be determined	@return estimated row count, or null if no reliable estimate can be determined	0	1	10	11	55
private static Analytics initializeAnalytics() throws Exception { // Authorization. Credential credential = authorize(); // Set up and return Google Analytics API client. return new Analytics.Builder(HTTP_TRANSPORT, JSON_FACTORY, credential) .setApplicationName(APPLICATION_NAME) .setHttpRequestInitializer(credential) .build(); }	"  private static Analytics initializeAnalytics() throws Exception  {
    // Authorization.
    Credential credential = authorize();

    // Set up and return Google Analytics API client.
    return new Analytics.Builder(HTTP_TRANSPORT, JSON_FACTORY, credential)
        .setApplicationName(""Google-Analytics-Management-API-Sample"")
        .setHttpRequestInitializer(credential)
        .build();
  }
"	@return An initialized Analytics service object.	@return An initialized Analytics service object.	0	1	6	11	52
@Deprecated public ImmutableGraph executeSparqlQuery(ConstructQuery query, Graph defaultGraph) { return (ImmutableGraph) executeSparqlQuery((Query) query, defaultGraph); }	"@Deprecated
public Graph executeSparqlQuery(ConstructQuery query, TripleCollection defaultGraph) {
    return (Graph) executeSparqlQuery((Query) query, defaultGraph);
}"	@return the resulting ImmutableGraph	@return the resulting Graph	1	0	7	4	28
"public BigDecimal fakeOuterNumberSerialize(BigDecimal body) throws ApiException { Object localVarPostBody = body; // create path and map variables String localVarPath = ""/fake/outer/number""; // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, String> localVarCookieParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { ""*/*"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<BigDecimal> localVarReturnType = new GenericType<BigDecimal>() {}; return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	"  public BigDecimal fakeOuterNumberSerialize(BigDecimal body) throws ApiException {
    Object localVarPostBody = body;
    
    // create path and map variables
    String localVarPath = ""/fake/outer/number"";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    final String[] localVarAccepts = {
      ""*/*""
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    GenericType<BigDecimal> localVarReturnType = new GenericType<BigDecimal>() {};
    return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);
      }
"	@return BigDecimal	@return BigDecimal	0	1	8	33	186
public static ProcessHandle removeWorkflowExecutionHandle(String modelCode) { LOGGER.trace(STR, modelCode); ProcessHandle handle = workflowExecutionHandles.remove(modelCode); LOGGER.trace(STR, modelCode, handle); return handle; }	"public static ProcessHandle removeWorkflowExecutionHandle(String modelCode) {
    return workflowExecutionHandles.remove(modelCode);
}"	@return the removed handle	@return the removed handle if it was present before the invocation of this method, null otherwise	1	0	6	6	39
protected static Serializable deserializeTimestampV2(int meta, ByteArrayInputStream inputStream) throws IOException { long epochSecond = bigEndianLong(inputStream.read(4), 0, 4); int nanoSeconds = deserializeFractionalSecondsInNanos(meta, inputStream); LocalDateTime localDateTime = LocalDateTime.ofEpochSecond(epochSecond, nanoSeconds, ZoneOffset.UTC); return ZonedDateTime.of(localDateTime, ZoneId.systemDefault()); }	"    protected static Serializable deserializeTimestampV2(int meta, ByteArrayInputStream inputStream) throws IOException {
        long epochSecond = bigEndianLong(inputStream.read(4), 0, 4);
        int nanoSeconds = deserializeFractionalSecondsInNanos(meta, inputStream);
        LocalDateTime localDateTime = LocalDateTime.ofEpochSecond(epochSecond, nanoSeconds, ZoneOffset.UTC);
        return OffsetDateTime.of(localDateTime, LOCAL_TIMEZONE_OFFSET);
    }
"	@return the  OffsetDateTime object	@return the OffsetDateTime object	0	1	7	7	64
"protected Object convertString(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return """"; } return data.toString(); }"	"    protected Object convertString(Column column, Field fieldDefn, Object data) {
        return data == null ? null : data.toString();
    }
"	@return the converted value, or null if the conversion could not be made and the column allows nulls	@return the converted value, or null if the conversion could not be made	1	0	8	11	58
public List parsePage(String urlString) { String status = STR; try { URL currentURL = new java.net.URL(urlString); HttpURLConnection httpCon = (HttpURLConnection) currentURL.openConnection(); httpCon.setRequestProperty(STR, STR); httpCon.connect(); if (httpCon.getResponseCode() == HttpURLConnection.HTTP_OK) { String contentType = httpCon.getContentType(); if (contentType.indexOf(STR) != -NUM) { return handleHTML(httpCon); } else if (contentType.indexOf(STR) != -NUM) { handlePDF(httpCon); } else { status = STR + contentType; } } else { status = STR; } httpCon.disconnect(); } catch (java.net.MalformedURLException mue) { status = mue.toString(); } catch (java.net.UnknownHostException uh) { status = uh.toString(); } catch (java.io.IOException ioe) { status = ioe.toString(); } catch (Exception e) { status = e.toString(); } return null; }	"public java.util.List parsePage(String urlString) {
    String status = STR;
    try {
        URL currentURL = new java.net.URL(urlString);
        String currentURLPath = urlString.substring(NUM, urlString.lastIndexOf(STR));
        HttpURLConnection httpCon = (HttpURLConnection) currentURL.openConnection();
        httpCon.setRequestProperty(STR, STR);
        httpCon.connect();
        long lastModified = httpCon.getLastModified();
        if (httpCon.getResponseCode() == HttpURLConnection.HTTP_OK) {
            String contentType = httpCon.getContentType();
            if (contentType.indexOf(STR) != -NUM) {
                return handleHTML(httpCon);
            } else if (contentType.indexOf(STR) != -NUM) {
                handlePDF(httpCon);
            } else {
                status = STR + contentType;
            }
        } else {
            status = STR;
        }
        httpCon.disconnect();
    } catch (java.net.MalformedURLException mue) {
        status = mue.toString();
    } catch (java.net.UnknownHostException uh) {
        status = uh.toString();
    } catch (java.io.IOException ioe) {
        status = ioe.toString();
    } catch (Exception e) {
        status = e.toString();
    }
    return null;
}"	@return ok if the parse succeeded, or an error message if it did not FIXME why does this return null?	@return ok, 404	1	0	12	31	185
static String getType1Message(final String host, final String domain) { // For compatibility reason do not include domain and host in type 1 message //return new Type1Message(domain, host).getResponse(); return TYPE_1_MESSAGE; }	"    String getType1Message(final String host, final String domain) throws AuthenticationException {
        return new Type1Message(domain, host).getResponse();
    }
"	@return String the message to add to the HTTP request header.	@return String the message to add to the HTTP request header.	0	1	4	6	46
public List<RelDataType> collectOperandTypes() { return new AbstractList<RelDataType>() { public RelDataType get(int index) { return getOperandType(index); } public int size() { return getOperandCount(); } }; }	"public RelDataType[] collectOperandTypes() {
    RelDataType[] ret = new RelDataType[getOperandCount()];
    for (int i = NUM; i < ret.length; i++) {
        ret[i] = getOperandType(i);
    }
    return ret;
}"	@return collected list	@return collected array	1	0	8	12	44
protected long getTimeout(Session session) { return session.getTimeout(); }	"protected int getTimeout(Session session) {
    return getGlobalSessionTimeout();
}"	@return the time in milliseconds the specified session may remain idle before expiring.	@return the time in seconds the specified session may remain idle before expiring.	1	0	4	3	15
public boolean equals(Object obj) { if (this == obj) { return true; } if (obj instanceof GJChronology) { GJChronology chrono = (GJChronology) obj; return iCutoverMillis == chrono.iCutoverMillis && getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() && getZone().equals(chrono.getZone()); } return false; }	"    public boolean equals(Object obj) {
        return super.equals(obj);
    }
"	@return true if equal	@return true if equal	0	1	9	13	63
protected IsolationLevel getTransactionIsolation() { return this.transactionIsolationLevel; }	"protected TransactionIsolation getTransactionIsolation() {
    return this.transactionIsolationLevel;
}"	@return the current {@link IsolationLevel} level. If no transaction is active, this may be <code>null</code>.	@return the current {@link TransactionIsolation} level. If no transaction is active, this may be <code>null</code>.	1	0	5	3	11
public WebDriver frame(final String nameOrIdOrIndex) { try { // 1.) try to find frame in current window ... currentWindow = findFrame(currentWindow, nameOrIdOrIndex); } catch (NoSuchFrameException ignored) { // 2.) try to find frame in top window ... final WebWindow topWindow = currentWindow.getTopWindow(); currentWindow = findFrame(topWindow, nameOrIdOrIndex); } return HtmlUnitDriver.this; }	"    public WebDriver frame(final String name) {
      WebWindow window = currentWindow.getTopWindow();

      // Walk over all parts of the frame identifier, each time looking for a frame
      // with a name or ID matching this part of the identifier (separated by '.').
      String[] frames = name.split(""\\."");
      for (int i = 0; i < frames.length; ++i) {
        final String currentFrameId = frames[i];
        final HtmlPage page = (HtmlPage) window.getEnclosedPage();
        
        if (isNumericFrameIdValid(currentFrameId, page)) {
          window = getWindowByNumericFrameId(currentFrameId, page);
        } else {
          // Numeric frame ID is not valid - could be either because the identifier
          // was numeric and not valid OR the number that was given is actually a frame
          // name, not an index.
          
          boolean nextFrameFound = false;
          for (final FrameWindow frameWindow : page.getFrames()) {
            final String frameName = frameWindow.getName();
            final String frameId = frameWindow.getFrameElement().getId();
            final String remainingFrameId = joinFrom(frames, i, '.');
            if (frameName.equals(remainingFrameId) || frameId.equals(remainingFrameId)) {
              currentWindow = frameWindow;
              return HtmlUnitDriver.this;
            }
            if (frameName.equals(currentFrameId) || frameId.equals(currentFrameId)) {
              window = frameWindow;
              nextFrameFound = true;
            }
          } // End for.
          
          if (!nextFrameFound) {
            throw new NoSuchFrameException(""Cannot find frame: "" + name);
          }
        } // End else

      } // End for
      
      currentWindow = window;
      return HtmlUnitDriver.this;
    }
"	@return This instance.	@returns This instance.	1	0	8	12	70
public Map getFields() { return m_fields; }	"public HashMap getFields() {
    return m_fields;
}"	@return the field map [field_name, type].	@return the field hashmap [field_name, type].	1	0	4	3	10
public boolean parseRepositoryXml() throws MojoExecutionException { File fout = new File(m_repositoryXml); if (!fout.exists()) { Document doc = m_documentBuilder.newDocument(); Date d = new Date(); d.setTime(System.currentTimeMillis()); Element root = doc.createElement(STR); root.setAttribute(STR, m_format.format(d)); root.setAttribute(STR, STR); try { writeToFile(m_repositoryXml, root); } catch (MojoExecutionException e) { e.printStackTrace(); throw new MojoExecutionException(STR); } } m_repositoryDoc = parseFile(m_repositoryXml, m_documentBuilder); return (null != m_repositoryDoc); }	"private int parseRepositoryXml() throws MojoExecutionException {
    File fout = new File(m_repositoryXml);
    if (!fout.exists()) {
        Document doc = m_documentBuilder.newDocument();
        Date d = new Date();
        d.setTime(System.currentTimeMillis());
        Element root = doc.createElement(STR);
        root.setAttribute(STR, m_format.format(d));
        root.setAttribute(STR, STR);
        try {
            writeToFile(m_repositoryXml, root);
        } catch (MojoExecutionException e) {
            e.printStackTrace();
            throw new MojoExecutionException(STR);
        }
    }
    m_repositoryDoc = parseFile(m_repositoryXml, m_documentBuilder);
    if (m_repositoryDoc == null) {
        return -NUM;
    }
    return NUM;
}"	@return true if the repository file was parsed, otherwise false	@return 0 if the bundle is already in the descriptor, else -1	1	0	9	19	122
public int read(Object[] row, long ts, int rowNumber, int numberOfRows) throws InterruptedException { return converter.read(source, row, rowNumber, numberOfRows, includedColumns, ts, consumer); }	"        public int read(Object[] row, long ts, int rowNumber) throws InterruptedException {
            return converter.read(source, row, rowNumber, includedColumns, ts, consumer);
        }
"	@return the number of records produced; will be 0 or more	@return the number of records produced; will be 0 or more	0	1	5	4	41
public Client testClassname(Client client) throws ApiException { return testClassnameWithHttpInfo(client).getData(); }	"  public Client testClassname(Client body) throws ApiException {
    return testClassnameWithHttpInfo(body).getData();
      }
"	@return Client	@return Client	0	1	5	4	20
public Client testSpecialTags(Client body) throws ApiException { return testSpecialTagsWithHttpInfo(body).getData(); }	"  public Client testSpecialTags(Client body) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, ""Missing the required parameter 'body' when calling testSpecialTags"");
    }
    
    // create path and map variables
    String localVarPath = ""/another-fake/dummy"";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    final String[] localVarAccepts = {
      ""application/json""
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      ""application/json""
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    GenericType<Client> localVarReturnType = new GenericType<Client>() {};
    return apiClient.invokeAPI(localVarPath, ""PATCH"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);
      }
"	@return Client	@return Client	0	1	5	4	20
private ComponentAdapter prepDEF_lifecycleManagerSupport(MutablePicoContainer picoContainer) { picoContainer.addComponent(RecordingLifecycle.One.class); PoolingComponentAdapter poolingComponentAdapter = new PoolingComponentAdapter(new ConstructorInjectionComponentAdapter(RecordingLifecycle.Recorder.class, RecordingLifecycle.Two.class)); return picoContainer.addAdapter(poolingComponentAdapter).lastCA(); }	"private ComponentAdapter prepDEF_lifecycleManagerSupport(MutablePicoContainer picoContainer) {
    picoContainer.component(RecordingLifecycle.One.class);
    PoolingComponentAdapter poolingComponentAdapter = new PoolingComponentAdapter(new ConstructorInjectionComponentAdapter(RecordingLifecycle.Recorder.class, RecordingLifecycle.Two.class));
    return picoContainer.adapter(poolingComponentAdapter).lastCA();
}"	@return the addAdapter to test	@return the adapter to test	1	0	8	5	45
"public static ErrorInfo handler(final RuntimeException exception) { if (exception instanceof AbstractPlatformResourceNotFoundException) { final PlatformResourceNotFoundExceptionMapper mapper = new PlatformResourceNotFoundExceptionMapper(); final String errorBody = jsonHelper .toJson(mapper.toResponse((AbstractPlatformResourceNotFoundException) exception).getEntity()); return new ErrorInfo(404, 1001, errorBody); } else if (exception instanceof UnsupportedParameterException) { final UnsupportedParameterExceptionMapper mapper = new UnsupportedParameterExceptionMapper(); final String errorBody = jsonHelper.toJson(mapper.toResponse((UnsupportedParameterException) exception).getEntity()); return new ErrorInfo(400, 2001, errorBody); } else if (exception instanceof PlatformApiDataValidationException) { final PlatformApiDataValidationExceptionMapper mapper = new PlatformApiDataValidationExceptionMapper(); final String errorBody = jsonHelper.toJson(mapper.toResponse((PlatformApiDataValidationException) exception).getEntity()); return new ErrorInfo(400, 2002, errorBody); } else if (exception instanceof PlatformDataIntegrityException) { final PlatformDataIntegrityExceptionMapper mapper = new PlatformDataIntegrityExceptionMapper(); final String errorBody = jsonHelper.toJson(mapper.toResponse((PlatformDataIntegrityException) exception).getEntity()); return new ErrorInfo(403, 3001, errorBody); } else if (exception instanceof LinkedAccountRequiredException) { final PlatformDomainRuleExceptionMapper mapper = new PlatformDomainRuleExceptionMapper(); final String errorBody = jsonHelper.toJson(mapper.toResponse((LinkedAccountRequiredException) exception).getEntity()); return new ErrorInfo(403, 3002, errorBody); } else if (exception instanceof MultiDisbursementDataRequiredException) { final PlatformDomainRuleExceptionMapper mapper = new PlatformDomainRuleExceptionMapper(); final String errorBody = jsonHelper.toJson(mapper.toResponse((MultiDisbursementDataRequiredException) exception).getEntity()); return new ErrorInfo(403, 3003, errorBody); } else if (exception instanceof TransactionException) { return new ErrorInfo(400, 4001, ""{\""Exception\"": "" + exception.getMessage()+""}""); } else if (exception instanceof PlatformInternalServerException) { final PlatformInternalServerExceptionMapper mapper = new PlatformInternalServerExceptionMapper(); final String errorBody = jsonHelper.toJson(mapper.toResponse((PlatformInternalServerException) exception).getEntity()); return new ErrorInfo(500, 5001, errorBody); }else if(exception instanceof NonTransientDataAccessException) { return new ErrorInfo(400, 4001, ""{\""Exception\"": "" + exception.getMessage()+""}""); } return new ErrorInfo(500, 9999, ""{\""Exception\"": "" + exception.toString() + ""}""); }"	"    public static ErrorInfo handler(final RuntimeException exception) {

        if (exception instanceof AbstractPlatformResourceNotFoundException) {

            final PlatformResourceNotFoundExceptionMapper mapper = new PlatformResourceNotFoundExceptionMapper();
            final String errorBody = jsonHelper
                    .toJson(mapper.toResponse((AbstractPlatformResourceNotFoundException) exception).getEntity());

            return new ErrorInfo(404, 1001, errorBody);

        } else if (exception instanceof UnsupportedParameterException) {

            final UnsupportedParameterExceptionMapper mapper = new UnsupportedParameterExceptionMapper();
            final String errorBody = jsonHelper.toJson(mapper.toResponse((UnsupportedParameterException) exception).getEntity());

            return new ErrorInfo(400, 2001, errorBody);

        } else if (exception instanceof PlatformApiDataValidationException) {

            final PlatformApiDataValidationExceptionMapper mapper = new PlatformApiDataValidationExceptionMapper();
            final String errorBody = jsonHelper.toJson(mapper.toResponse((PlatformApiDataValidationException) exception).getEntity());

            return new ErrorInfo(400, 2002, errorBody);

        } else if (exception instanceof PlatformDataIntegrityException) {

            final PlatformDataIntegrityExceptionMapper mapper = new PlatformDataIntegrityExceptionMapper();
            final String errorBody = jsonHelper.toJson(mapper.toResponse((PlatformDataIntegrityException) exception).getEntity());

            return new ErrorInfo(403, 3001, errorBody);

        } else if (exception instanceof LinkedAccountRequiredException) {

            final PlatformDomainRuleExceptionMapper mapper = new PlatformDomainRuleExceptionMapper();
            final String errorBody = jsonHelper.toJson(mapper.toResponse((LinkedAccountRequiredException) exception).getEntity());

            return new ErrorInfo(403, 3002, errorBody);
            
        } else if (exception instanceof MultiDisbursementDataRequiredException) {

            final PlatformDomainRuleExceptionMapper mapper = new PlatformDomainRuleExceptionMapper();
            final String errorBody = jsonHelper.toJson(mapper.toResponse((MultiDisbursementDataRequiredException) exception).getEntity());

            return new ErrorInfo(403, 3003, errorBody);
            
        } else if (exception instanceof TransactionException) {
            return new ErrorInfo(400, 4001, ""{\""Exception\"": "" + exception.getMessage()+""}"");

        } else if (exception instanceof PlatformInternalServerException) {

            final PlatformInternalServerExceptionMapper mapper = new PlatformInternalServerExceptionMapper();
            final String errorBody = jsonHelper.toJson(mapper.toResponse((PlatformInternalServerException) exception).getEntity());

            return new ErrorInfo(500, 5001, errorBody);
        }

        return new ErrorInfo(500, 9999, ""{\""Exception\"": "" + exception.toString() + ""}"");
    }
"	@return ErrorInfo	@return ErrorInfo	0	1	17	61	441
public Integer[] getVersions() { return vers; }	"public Integer[] getVersions() {
    return versions.keySet().toArray(new Integer[versions.keySet().size()]);
}"	@return array for all available versions (sorted)	@return iterator for all available versions	1	0	4	3	12
"public String getTypeDeclaration(Property p) { if (p instanceof ArrayProperty) { ArrayProperty ap = (ArrayProperty) p; Property inner = ap.getItems(); return ""["" + getTypeDeclaration(inner) + ""]""; } else if (p instanceof MapProperty) { MapProperty mp = (MapProperty) p; Property inner = mp.getAdditionalProperties(); return ""Map.Map String "" + getTypeDeclaration(inner); } return fixModelChars(super.getTypeDeclaration(p)); }"	"    public String getTypeDeclaration(Property p) {
        if (p instanceof ArrayProperty) {
            ArrayProperty ap = (ArrayProperty) p;
            Property inner = ap.getItems();
            return ""["" + getTypeDeclaration(inner) + ""]"";
        } else if (p instanceof MapProperty) {
            MapProperty mp = (MapProperty) p;
            Property inner = mp.getAdditionalProperties();
            return ""Map.Map String "" + getTypeDeclaration(inner);
        }
        return super.getTypeDeclaration(p);
    }
"	@return a string value used as the `dataType` field for model templates, `returnType` for api templates	@return a string value used as the `dataType` field for model templates, `returnType` for api templates	0	1	9	13	90
"public String getMatches() { StringBuilder sb = new StringBuilder(); for(int i = 0, sz = list.getModel().getSize(); i < sz; i++) { Tree t = ((TreeFromFile) list.getModel().getElementAt(i)).getTree(); sb.append(t.pennString()); sb.append(""\n\n""); } return sb.toString(); }"	"  public StringBuffer getMatches() {
    StringBuffer sb = new StringBuffer();
    for(int i = 0; i < list.getModel().getSize(); i++) {
      Tree t = ((TreeFromFile) list.getModel().getElementAt(i)).getTree();
      sb.append(t.pennString());
      sb.append(""\n\n"");
    }
    return sb;
  }
"	@return String filled with the Penn treebank forms of all trees in the matches panel	@return StringBuffer filled with the penn treebank forms of all trees in the matches panel	1	0	10	10	83
public Object getCache(PGraphics renderer) { if (cacheMap == null) return null; return cacheMap.get(renderer); }	"  public Object getCache(Object parent) {
    if (cacheMap == null) return null;
    return cacheMap.get(parent);
  }
"	@return metadata stored for the specified renderer	@return data stored for the specified parent	1	0	5	5	24
public <RX extends RxInvokerProvider> Client buildRx(String name, Class<RX> invokerType) { return build(name).register(invokerType); }	"public <RX extends RxInvoker> RxClient<RX> buildRx(String name, Class<RX> invokerType) {
    return Rx.from(build(name), invokerType, executorService);
}"	@return a fully-configured {@link Client}	@return a fully-configured {@link RxClient}	1	0	6	3	26
"public JSONArray getJSONArray(String key) { Object object = this.get(key); if (object == null) { return null; } if (object instanceof JSONArray) { return (JSONArray)object; } throw new RuntimeException(""JSONObject["" + quote(key) + ""] is not a JSONArray.""); }"	"  public JSONArray getJSONArray(String key) {
    Object object = this.get(key);
    if (object instanceof JSONArray) {
      return (JSONArray)object;
    }
    throw new RuntimeException(""JSONObject["" + quote(key) + ""] is not a JSONArray."");
  }
"	@return A JSONArray which is the value, or null if not present	@return A JSONArray which is the value.	1	0	8	11	64
"public AST handleIdentifierError(Token token, RecognitionException ex) throws RecognitionException, TokenStreamException { // If the token can tell us if it could be an identifier... if ( token instanceof HqlToken ) { HqlToken hqlToken = ( HqlToken ) token; // ... and the token could be an identifer and the error is // a mismatched token error ... if ( hqlToken.isPossibleID() && ( ex instanceof MismatchedTokenException ) ) { MismatchedTokenException mte = ( MismatchedTokenException ) ex; // ... and the expected token type was an identifier, then: if ( mte.expecting == HqlTokenTypes.IDENT ) { // Use the token as an identifier. reportWarning( ""Keyword '"" + token.getText() + ""' is being interpreted as an identifier due to: "" + mte.getMessage() ); // Add the token to the AST. ASTPair currentAST = new ASTPair(); token.setType( HqlTokenTypes.WEIRD_IDENT ); astFactory.addASTChild( currentAST, astFactory.create( token ) ); consume(); return currentAST.root; } } // if } // if // Otherwise, handle the error normally. return super.handleIdentifierError( token, ex ); }"	"    public AST handleIdentifierError(Token token, RecognitionException ex) throws RecognitionException, TokenStreamException {
		// If the token can tell us if it could be an identifier...
		if ( token instanceof HqlToken ) {
			HqlToken hqlToken = ( HqlToken ) token;
			// ... and the token could be an identifer and the error is
			// a mismatched token error ...
			if ( hqlToken.isPossibleID() && ( ex instanceof MismatchedTokenException ) ) {
				MismatchedTokenException mte = ( MismatchedTokenException ) ex;
				// ... and the expected token type was an identifier, then:
				if ( mte.expecting == HqlTokenTypes.IDENT ) {
					// Use the token as an identifier.
					reportWarning( ""Keyword  '""
							+ token.getText()
							+ ""' is being interpreted as an identifier due to: "" + mte.getMessage() );
					// Add the token to the AST.
					ASTPair currentAST = new ASTPair();
					token.setType( HqlTokenTypes.WEIRD_IDENT );
					astFactory.addASTChild( currentAST, astFactory.create( token ) );
					consume();
					AST identifierAST = currentAST.root;
					return identifierAST;
				}
			} // if
		} // if
		// Otherwise, handle the error normally.
		return super.handleIdentifierError( token, ex );
	}
"	@return AST - The new AST.	@return AST - The new AST.	0	1	14	27	213
public Type getPhysical() { return physical; }	"public Class<P> getPhysical() {
    return physical;
}"	@return the physical type used by the runtime	@return the physical class used by the runtime	1	0	4	3	10
public LoggingConfiguration getLoggingConfiguration() { return loggingConfiguration; }	"    public LoggingConfiguration getLoggingConfiguration() {
        return logging;
    }
"	@return logging-specific configuration parameters	@return logging-specific configuration parameters	0	1	4	4	10
public VirtualFile getParent() throws IOException { VirtualFileHandler parent = getHandler().getParent(); if (parent != null) return parent.getVirtualFile(); return null; }	"public VirtualFile getParent() throws IOException {
    VirtualFileHandler parent = getHandler().getParent();
    return parent.getVirtualFile();
}"	@return the parent or null if there is no parent	@return the parent	1	0	6	6	33
private String terminalToShowWhenClosing(String handle) { int terminalClosing = terminals_.indexOfTerminal(handle); if (terminalClosing > 0) return terminals_.terminalHandleAtIndex(terminalClosing - 1); else if (terminalClosing + 1 < terminals_.terminalCount()) return terminals_.terminalHandleAtIndex(terminalClosing + 1); else return null; }	"   private int terminalToShowWhenClosing(int terminalClosing)
   {
      if (terminalClosing > 0)
         return terminalClosing - 1;
      else if (terminalClosing + 1 < getTerminalCount())
         return terminalClosing + 1;
      else
         return -1;
   }
"	@return handle of terminal to show next, or null if none to show	@return index of terminal to show next, or -1 if none available	1	0	8	11	55
public static Consumer<List> elasticsearchChecker(final String... strings) { return actual -> { Object[] actualArray = actual == null || actual.isEmpty() ? null : ((List) actual.get(NUM)).toArray(); CalciteAssert.assertArrayEqual(STR, strings, actualArray); }; }	"public static Function<List, Void> elasticsearchChecker(final String... strings) {
    return new Function<List, Void>() {

        @Nullable
        @Override
        public Void apply(@Nullable List actual) {
            Object[] actualArray = actual == null || actual.isEmpty() ? null : ((List) actual.get(NUM)).toArray();
            CalciteAssert.assertArrayEqual(STR, strings, actualArray);
            return null;
        }
    };
}"	@return function to perform the check	@return validation function	1	0	10	6	57
public PersistentClass getClassMapping(String entityName) { return classes.get( entityName ); }	"	public PersistentClass getClassMapping(String entityName) {
		return (PersistentClass) classes.get( entityName );
	}
"	@return the entity mapping information	@return the entity mapping information	0	1	5	4	16
private <T> T processResponse(final ClientResponse clientResponse, final Type responseType) { final String response = readResponseFromClientResponse(clientResponse); if (clientResponse.getStatus() == NUM) { return null; } else if (clientResponse.getStatus() >= NUM) { throw new HandshakeAPIException(response); } try { return parseJson(response, responseType); } catch (final IOException e) { throw new RuntimeException(e); } }	"private <T> T processResponse(final ClientResponse clientResponse, final Type responseType) {
    final String response = readResponseFromClientResponse(clientResponse);
    if (clientResponse.getStatus() >= NUM) {
        throw new HandshakeAPIException(response);
    }
    try {
        return parseJson(response, responseType);
    } catch (final IOException e) {
        throw new RuntimeException(e);
    }
}"	@return the response, null if not found, or an Exception if something bad happened	@return the response, or an Exception if something bad happened	1	0	8	13	80
public static Months parseMonths(String periodStr) { throw ExceptionUtils.unsupportedInGwt(); // if (periodStr == null) { // return Months.ZERO; // } // Period p = PARSER.parsePeriod(periodStr); // return Months.months(p.getMonths()); }	"    public static Months parseMonths(String periodStr) {
        if (periodStr == null) {
            return Months.ZERO;
        }
        Period p = PARSER.parsePeriod(periodStr);
        return Months.months(p.getMonths());
    }
"	@return the period in months	@return the period in months	0	1	4	9	55
public ListWithTotal<User> getFriends(long id, int from, int to, friendsTypes type) throws IOException, JSONException { List<User> friends = new LinkedList<User>(); URL url = new URL(STR + type.name() + STR + from + STR + to + STR + id + STR + sid); String jsonText = getTextFromUrl(url); System.out.println(jsonText); JSONArray fr; long count = -NUM; if (type == friendsTypes.friends_new) { JSONObject object = new JSONObject(jsonText); count = object.getLong(STR); fr = object.getJSONArray(STR); } else { fr = new JSONArray(jsonText); } for (int i = NUM; i < fr.length(); i++) { JSONArray userInfo = (JSONArray) fr.get(i); friends.add(new User(userInfo, this)); } return new ListWithTotal<User>(friends, count); }	"public List<User> getFriends(long id, int from, int to, friendsTypes type) throws IOException, JSONException {
    List<User> friends = new LinkedList<User>();
    URL url = new URL(STR + type.name() + STR + from + STR + to + STR + id + STR + sid);
    String jsonText = getTextFromUrl(url);
    JSONArray fr;
    if (type == friendsTypes.friends) {
        fr = new JSONArray(jsonText);
    } else {
        fr = new JSONObject(jsonText).getJSONArray(STR);
    }
    for (int i = NUM; i < fr.length(); i++) {
        JSONArray userInfo = (JSONArray) fr.get(i);
        friends.add(new User(userInfo, this));
    }
    return friends;
}"	@return friend list for a user	@return the last element in this list	1	0	15	20	174
public Call123testSpecialTagsOper reqSpec(Consumer<RequestSpecBuilder> consumer) { consumer.accept(reqSpec); return this; }	"        public TestSpecialTagsOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }
"	@return operation	@return operation	0	1	6	5	19
public ResultSet executeQuery(String sql) throws SQLException { if (type == ResultSet.TYPE_FORWARD_ONLY && concurrency == ResultSet.CONCUR_READ_ONLY) { ResultSet rs = internalExecuteQuery(sql); if (rs != null) return rs; else throw new SQLException(STR); } else return new freetds.CursorResultSet(this, sql); }	"public ResultSet executeQuery(String sql) throws SQLException {
    if (type == ResultSet.TYPE_FORWARD_ONLY && concurrency == ResultSet.CONCUR_READ_ONLY) {
        return internalExecuteQuery(getTds(sql), sql);
    } else {
        return new freetds.CursorResultSet(this, sql);
    }
}"	@return a <code>ResultSet</code> that contains the data produced by the query; never <code>null</code>	@return a ResulSet that contains the data produced by the query	1	0	8	10	59
public String findInContent(String content) { // First check for a simple exact occurrence for (BoyerMooreMatcher matcher : strings) { if (matcher.findInContent(content) >= 0) return matcher.getPattern(); } // Then check for a regex occurrence Matcher matcher; for (Pattern pattern : patterns) { matcher = pattern.matcher(content); if (matcher.find()) { return matcher.group(); } } // No match found return null return null; }	"    public String findInContent(String content) {
        
        // First check for a simple exact occurrence
        for (String str : strings) {
            if (content.contains(str))
                return str;
        }
        
        // Then check for a regex occurrence
        Matcher matcher;
        for (Pattern pattern : patterns) {
            matcher = pattern.matcher(content);
            if (matcher.find()) {
                return matcher.group();
            }
        }
        
        // No match found return null
        return null;
    }
"	@return the found occurrence or null if no match has been done	@return the found occurrence or null if no match has been done	0	1	8	21	94
public static FactorTable getFactorTable(double[][] weights, int[][] data, Index[] labelIndices, int numClasses) { CliquePotentialFunction cliquePotentialFunc = new LinearCliquePotentialFunction(weights); return getFactorTable(data, labelIndices, numClasses, cliquePotentialFunc); }	"  static FactorTable getFactorTable(double[][] weights, int[][] data, List<Index<CRFLabel>> labelIndices, int numClasses) {
    CliquePotentialFunction cliquePotentialFunc = new LinearCliquePotentialFunction(weights);
    return getFactorTable(data, labelIndices, numClasses, cliquePotentialFunc, null);
  }
"	@return a new CRFCliqueTree for the weights on the data	@return a new CRFCliqueTree for the weights on the data	0	1	6	5	49
public BlankNodeOrIri convertNonLiteral(Node node) { if (node == null) { throw new IllegalArgumentException(STR); } if (node.isBlank()) { return convertJenaNode2TriaBlankNode(node); } if (node.isURI()) { return convertJenaUri2UriRef(node); } throw new RuntimeException(STR + node + STR); }	"public NonLiteral convertNonLiteral(Node node) {
    if (node == null) {
        throw new IllegalArgumentException(STR);
    }
    if (node.isBlank()) {
        return convertJenaNode2TriaBlankNode(node);
    }
    if (node.isURI()) {
        return convertJenaUri2UriRef(node);
    }
    throw new RuntimeException(STR + node + STR);
}"	@return BlankNode if it is a Blank Node otherwise a Iri	@return BNode if it is a Blank Node otherwise a UriRef	1	0	7	12	64
protected ComponentTemplate getMetaData(final Object entry) { return (ComponentTemplate) entry; }	"protected ComponentMetaData getMetaData(final Object entry) {
    return (ComponentMetaData) entry;
}"	@return the ComponentTemplate	@return the ComponentMetaData	1	0	5	3	16
public static final TwitterTokenStream of(TwitterTokenStream... streams) { return new TokenStreamAggregator(streams); }	"public static final TokenStream of(TokenStream... streams) {
    return new TokenStreamAggregator(streams);
}"	@return an aggregated TwitterTokenStream	@return an aggregated TokenStream	1	0	5	3	18
public DateTimeFormatterBuilder appendDayOfYear(final int minDigits) { return appendDecimal(iChronoUTC.dayOfYear(), minDigits, 3); }	"    public DateTimeFormatterBuilder appendDayOfYear(final int minDigits) {
        return appendNumeric(iChronoUTC.dayOfYear(), minDigits, 3);
    }
"	@return this DateTimeFormatterBuilder	@return this DateTimeFormatterBuilder	0	1	5	4	23
private String buildRemoveVideoSdpProposal() { if (logger.isActivated()) { logger.debug(STR); } try { String ntpTime = SipUtils.constructNTPtime(System.currentTimeMillis()); String ipAddress = getDialogPath().getSipStack().getLocalIpAddress(); getAudioPlayer().getLocalRtpPort(); String audioSdp = AudioSdpBuilder.buildSdpOffer(getAudioPlayer().getSupportedAudioCodecs(), getAudioPlayer().getLocalRtpPort()); return STR + SipUtils.CRLF + STR + ntpTime + STR + ntpTime + STR + SdpUtils.formatAddressType(ipAddress) + SipUtils.CRLF + STR + SipUtils.CRLF + STR + SdpUtils.formatAddressType(ipAddress) + SipUtils.CRLF + STR + SipUtils.CRLF + audioSdp + STR + SipUtils.CRLF; } catch (RemoteException e) { if (logger.isActivated()) { logger.error(STR, e); } handleError(new IPCallError(IPCallError.UNEXPECTED_EXCEPTION, e.getMessage())); return null; } }	"private String buildRemoveVideoSdpProposal() {
    if (logger.isActivated()) {
        logger.info(STR);
    }
    String sdp = STR;
    String ntpTime = SipUtils.constructNTPtime(System.currentTimeMillis());
    String ipAddress = getDialogPath().getSipStack().getLocalIpAddress();
    try {
        logger.warn(STR);
        getAudioPlayer().getLocalRtpPort();
        String audioSdp = AudioSdpBuilder.buildSdp(getAudioPlayer().getSupportedAudioCodecs(), getAudioPlayer().getLocalRtpPort());
        sdp = STR + SipUtils.CRLF + STR + ntpTime + STR + ntpTime + STR + SdpUtils.formatAddressType(ipAddress) + SipUtils.CRLF + STR + SipUtils.CRLF + STR + SdpUtils.formatAddressType(ipAddress) + SipUtils.CRLF + STR + SipUtils.CRLF + audioSdp + STR + SipUtils.CRLF;
    } catch (RemoteException e) {
        if (logger.isActivated()) {
            logger.error(STR, e);
        }
        handleError(new IPCallError(IPCallError.UNEXPECTED_EXCEPTION, e.getMessage()));
    }
    return sdp;
}"	@return SDP content or null in case of error	@return sdp content	1	0	23	18	170
public File getGeneratedOutput() throws CurnException { return null; }	"public InputStream getGeneratedOutput() throws CurnException {
    return null;
}"	@return null, unconditionally	@return an open input stream, or null if no suitable output was produced	1	0	4	3	12
protected BroadcasterConfig createBroadcasterConfig(AtmosphereConfig config){ return new BroadcasterConfig(config.framework().broadcasterFilters, config); }	"    protected BroadcasterConfig createBroadcasterConfig(AtmosphereConfig config){
        return new BroadcasterConfig(AtmosphereServlet.broadcasterFilters, config);
    }
"	@return an instance of  BroadcasterConfig	@return an instance of BroadcasterConfig	0	1	6	4	22
"public static ParquetFilterPredicate buildParquetFilterPredicate(LogicalExpression expr, final Set<LogicalExpression> constantBoundaries, UdfUtilities udfUtilities) { LogicalExpression logicalExpression = expr.accept(new ParquetFilterBuilder(udfUtilities), constantBoundaries); if (logicalExpression instanceof ParquetFilterPredicate) { return (ParquetFilterPredicate) logicalExpression; } logger.debug(""Logical expression {} was not qualified for filter push down"", logicalExpression); return null; }"	"  public static LogicalExpression buildParquetFilterPredicate(LogicalExpression expr, final Set<LogicalExpression> constantBoundaries, UdfUtilities udfUtilities) {
    return expr.accept(new ParquetFilterBuilder(udfUtilities), constantBoundaries);
  }
"	@return parquet filter predicate	@return logical expression	1	0	7	9	69
private void collectFields(FieldCollectorParameters parameters, SelectionSet selectionSet, List<String> visitedFragments, Map<String, List<Field>> fields) { for (Selection selection : selectionSet.getSelections()) { if (selection instanceof Field) { collectField(parameters, fields, (Field) selection); } else if (selection instanceof InlineFragment) { collectInlineFragment(parameters, visitedFragments, fields, (InlineFragment) selection); } else if (selection instanceof FragmentSpread) { collectFragmentSpread(parameters, visitedFragments, fields, (FragmentSpread) selection); } } }	"    public MergedSelectionSet collectFields(FieldCollectorParameters parameters, SelectionSet selectionSet) {
        Map<String, MergedFields> subFields = new LinkedHashMap<>();
        List<String> visitedFragments = new ArrayList<>();
        this.collectFields(parameters, selectionSet, visitedFragments, subFields);
        return newMergedSelectionSet().subFields(subFields).build();
    }
"	@return a map of the sub field selections	@return a map of the sub field selections	0	1	12	13	101
public BooleanExpression and(@Nullable Predicate right) { right = (Predicate) ExpressionUtils.extract(right); if (right != null) { return Expressions.booleanOperation(Ops.AND, mixin, right); } else { return this; } }	"public BooleanExpression and(@Nullable Predicate right) {
    right = (Predicate) ExpressionUtils.extract(right);
    if (right != null) {
        return BooleanOperation.create(Ops.AND, mixin, right);
    } else {
        return this;
    }
}"	@return {@code this &amp;&amp; right}	@return {@code this && right}	1	0	7	8	47
public Builder hasArg() { return hasArg(true); }	"public boolean hasArg() {
    return numberOfArgs > NUM || numberOfArgs == UNLIMITED_VALUES;
}"	@return this builder, to allow method chaining	@return boolean flag indicating if an argument is required	1	0	5	3	13
"protected void checkFont() { Font awtFont = textFont.getFont(); if (awtFont == null) { // always need a native font or reference to it throw new RuntimeException(""Use createFont() instead of loadFont() "" + ""when drawing text using the PDF library.""); } else if (textMode != SHAPE) { if (textFont.isStream()) { throw new RuntimeException(""Use textMode(SHAPE) with when loading "" + "".ttf and .otf files with createFont().""); } else if (mapper.getAliases().get(textFont.getName()) == null) { //System.out.println(""alias for "" + name + "" = "" + mapper.getAliases().get(name)); System.err.println(""Use PGraphicsPDF.listFonts() to get a list of "" + ""fonts that can be used with PDF.""); throw new RuntimeException(""The font "" + textFont.getName() + "" "" + ""cannot be used with PDF Export.""); } } }"	"  protected boolean checkFont(String name) {
    //System.out.println(""alias for "" + name + "" = "" + mapper.getAliases().get(name));
    return mapper.getAliases().get(name) != null;
  }
"	@return true if it's ok	@return true if it's ok	0	1	14	19	205
public boolean shouldAllowAccess() { boolean allowAccess = false; if (this.peerInstancesTransferEmptyOnStartup) { if (System.currentTimeMillis() > this.startupTime + eurekaServerConfig.getWaitTimeInMsWhenSyncEmpty()) { allowAccess = true; } else { allowAccess = false; } } for (RemoteRegionRegistry remoteRegionRegistry: this.remoteRegionRegistryList) { if (!remoteRegionRegistry.isReadyForServingData()) { return false; } } return allowAccess; }	"    public boolean shouldAllowAccess() {
        if (this.peerInstancesTransferEmptyOnStartup) {
            if (System.currentTimeMillis() > this.startupTime
                    + eurekaServerConfig.getWaitTimeInMsWhenSyncEmpty()) {
                return true;
            } else {
                return false;
            }
        }
        return true;
    }
"	@return false - if the instances count from a replica transfer returned zero and if the wait time has not elapsed, o otherwise returns true	@return false - if the instances count from a replica transfer returned zero and if the wait time has not elapsed, o otherwise returns true	0	1	9	18	69
private static boolean isConnected(NetType netType, NetworkInfo networkInfo) { switch(netType) { case Any: return networkInfo != null && isConnected(networkInfo); case Wifi: return networkInfo != null && networkInfo.getType() == ConnectivityManager.TYPE_WIFI && isConnected(networkInfo); case Mobile: return networkInfo != null && networkInfo.getType() == ConnectivityManager.TYPE_MOBILE && isConnected(networkInfo); } return false; }	"public static boolean isConnected(NetType netType, NetworkInfo networkInfo) {
    if (netType == NetType.Any && networkInfo != null && isConnected(networkInfo))
        return true;
    else if (netType == NetType.Wifi && networkInfo != null && networkInfo.getType() == ConnectivityManager.TYPE_WIFI && isConnected(networkInfo))
        return true;
    else if (netType == NetType.Mobile && networkInfo != null && networkInfo.getType() == ConnectivityManager.TYPE_MOBILE && isConnected(networkInfo))
        return true;
    return false;
}"	@return Connection state return true, otherwise it returns false.	@return ConnectionResult state return true, otherwise it returns false.	1	0	9	11	80
private static CoreMap fromProto(CoreNLPProtos.Sentence proto) { CoreMap sentence = new ArrayCoreMap(); // Required fields sentence.set(TokenBeginAnnotation.class, proto.getTokenOffsetBegin()); sentence.set(TokenEndAnnotation.class, proto.getTokenOffsetEnd()); // Optional fields if (proto.hasSentenceIndex()) { sentence.set(SentenceIndexAnnotation.class, proto.getSentenceIndex()); } if (proto.hasCharacterOffsetBegin()) { sentence.set(CharacterOffsetBeginAnnotation.class, proto.getCharacterOffsetBegin()); } if (proto.hasCharacterOffsetEnd()) { sentence.set(CharacterOffsetEndAnnotation.class, proto.getCharacterOffsetEnd()); } if (proto.hasParseTree()) { sentence.set(TreeAnnotation.class, fromProto(proto.getParseTree())); } // Non-default fields if (proto.hasHasRelationAnnotations() && proto.getHasRelationAnnotations()) { // set entities List<EntityMention> entities = new ArrayList<EntityMention>(); for (CoreNLPProtos.Entity entity : proto.getEntityList()) { entities.add(fromProto(entity, sentence)); } sentence.set(EntityMentionsAnnotation.class, entities); // set relations List<RelationMention> relations = new ArrayList<RelationMention>(); for (CoreNLPProtos.Relation relation : proto.getRelationList()) { relations.add(fromProto(relation, sentence)); } sentence.set(RelationMentionsAnnotation.class, relations); } // Return return sentence; }	"  protected CoreLabel fromProto(CoreNLPProtos.Token proto) {
    CoreLabel word = new CoreLabel();
    // Required fields
    word.setWord(proto.getWord());
    // Optional fields
    if (proto.hasPos()) { word.setTag(proto.getPos()); }
    if (proto.hasValue()) { word.setValue(proto.getValue()); }
    if (proto.hasCategory()) { word.setCategory(proto.getCategory()); }
    if (proto.hasBefore()) { word.setBefore(proto.getBefore()); }
    if (proto.hasAfter()) { word.setAfter(proto.getAfter()); }
    if (proto.hasOriginalText()) { word.setOriginalText(proto.getOriginalText()); }
    if (proto.hasNer()) { word.setNER(proto.getNer()); }
    if (proto.hasLemma()) { word.setLemma(proto.getLemma()); }
    if (proto.hasBeginChar()) { word.setBeginPosition(proto.getBeginChar()); }
    if (proto.hasEndChar()) { word.setEndPosition(proto.getEndChar()); }
    if (proto.hasSpeaker()) { word.set(SpeakerAnnotation.class, proto.getSpeaker()); }
    if (proto.hasUtterance()) { word.set(UtteranceAnnotation.class, proto.getUtterance()); }
    if (proto.hasBeginIndex()) { word.set(BeginIndexAnnotation.class, proto.getBeginIndex()); }
    if (proto.hasEndIndex()) { word.set(EndIndexAnnotation.class, proto.getEndIndex()); }
    if (proto.hasTokenBeginIndex()) { word.set(TokenBeginAnnotation.class, proto.getTokenBeginIndex()); }
    if (proto.hasTokenEndIndex()) { word.set(TokenEndAnnotation.class, proto.getTokenEndIndex()); }
    if (proto.hasNormalizedNER()) { word.set(NormalizedNamedEntityTagAnnotation.class, proto.getNormalizedNER()); }
    if (proto.hasTimexValue()) { word.set(TimexAnnotation.class, fromProto(proto.getTimexValue())); }
    if (proto.hasHasXmlContext() && proto.getHasXmlContext()) { word.set(XmlContextAnnotation.class, proto.getXmlContextList()); }
    if (proto.hasCorefClusterID()) { word.set(CorefClusterIdAnnotation.class, proto.getCorefClusterID()); }
    if (proto.hasAnswer()) { word.set(AnswerAnnotation.class, proto.getAnswer()); }
    // Non-default annotators
    if (proto.hasGender()) { word.set(GenderAnnotation.class, proto.getGender()); }
    if (proto.hasTrueCase()) { word.set(TrueCaseAnnotation.class, proto.getTrueCase()); }
    if (proto.hasTrueCaseText()) { word.set(TrueCaseTextAnnotation.class, proto.getTrueCaseText()); }
    // Return
    return word;
  }
"	@return A CoreMap, representing a sentence as stored in the protocol buffer (and therefore missing some fields)	@return A CoreLabel, missing the fields that are not stored in the CoreLabel protobuf.	1	0	10	25	256
private TableExportButton<JXTable> getExportButton() { if (exportButton == null) { exportButton = new TableExportButton<>(getHttpSessionsTable()); } return exportButton; }	"	private TableExportButton getExportButton() {
		if (exportButton == null) {
			exportButton = new TableExportButton(getHttpSessionsTable());
		}
		return exportButton;
	}
"	@return javax.swing.JPanel	@return javax.swing.JPanel	0	1	8	7	27
public DocumentCollection getMetadataByName(String name, String[] docs) throws RepositoryAccessException { String[] names = { name }; return this.getDocCollection(names, docs); }	"public java.util.Map<String, String[]> getMetadataByName(String name, String[] docs) throws RepositoryAccessException {
    HashMap<String, String[]> vals = new HashMap<String, String[]>();
    HashSet<String> activeFields = new HashSet<String>();
    HashSet<String> lazyFields = new HashSet<String>();
    activeFields.add(LUCENE_DOCID_FIELD);
    lazyFields.add(name);
    SetBasedFieldSelector fsel = new SetBasedFieldSelector(activeFields, lazyFields);
    IndexReader lreader;
    try {
        lreader = this.getIndexReader();
        int last = lreader.maxDoc();
        Document d;
        String docID;
        for (int i = NUM; i < last; ++i) {
            if (!lreader.isDeleted(i)) {
                d = lreader.document(i, fsel);
                docID = d.get(LUCENE_DOCID_FIELD);
                for (String did : docs) if (did.equals(docID))
                    vals.put(docID, d.getValues(name));
            }
        }
        lreader.close();
    } catch (java.io.IOException ioe) {
        throw new RepositoryAccessException(STR + ioe.getMessage());
    }
    return vals;
}"	@return DocumentCollection with entries for docs, each with a Metadatum for name.	@return Map of documentID->String['val1','val2'...]	1	0	6	4	33
@RequestMapping(value = STR, method = { RequestMethod.POST }) @ResponseBody public CubeRequest saveCubeDesc(@RequestBody CubeRequest cubeRequest) { MetadataManager metaManager = MetadataManager.getInstance(cubeService.getConfig()); DataModelDesc modelDesc = deserializeDataModelDesc(cubeRequest); if (modelDesc == null) { return errorRequest(cubeRequest, STR); } if (StringUtils.isEmpty(modelDesc.getName())) { return errorRequest(cubeRequest, STR); } try { DataModelDesc existingModel = metaManager.getDataModelDesc(modelDesc.getName()); if (existingModel == null) { metaManager.createDataModelDesc(modelDesc); } else { modelDesc.setLastModified(existingModel.getLastModified()); metaManager.updateDataModelDesc(modelDesc); } } catch (IOException e) { logger.error(STR + e.getLocalizedMessage(), e); throw new InternalErrorException(STR + e.getLocalizedMessage()); } CubeDesc desc = deserializeCubeDesc(cubeRequest); if (desc == null) { return cubeRequest; } if (StringUtils.isEmpty(desc.getName())) { logger.info(STR); return errorRequest(cubeRequest, STR); } try { desc.setUuid(UUID.randomUUID().toString()); String projectName = (null == cubeRequest.getProject()) ? ProjectInstance.DEFAULT_PROJECT_NAME : cubeRequest.getProject(); CubeInstance createdCube = cubeService.createCubeAndDesc(desc.getName(), projectName, desc); accessService.init(createdCube, AclPermission.ADMINISTRATION); ProjectInstance project = cubeService.getProjectManager().getProject(projectName); accessService.inherit(createdCube, project); } catch (Exception e) { logger.error(STR, e); throw new InternalErrorException(e.getLocalizedMessage(), e); } cubeRequest.setUuid(desc.getUuid()); cubeRequest.setSuccessful(true); return cubeRequest; }	"@RequestMapping(value = STR, method = { RequestMethod.POST })
@ResponseBody
public CubeRequest saveCubeDesc(@RequestBody CubeRequest cubeRequest) {
    MetadataManager metaManager = MetadataManager.getInstance(KylinConfig.getInstanceFromEnv());
    DataModelDesc modelDesc = deserializeDataModelDesc(cubeRequest);
    if (modelDesc == null || StringUtils.isEmpty(modelDesc.getName())) {
        return cubeRequest;
    }
    try {
        DataModelDesc existingModel = metaManager.getDataModelDesc(modelDesc.getName());
        if (existingModel == null) {
            metaManager.createDataModelDesc(modelDesc);
        } else {
            modelDesc.setLastModified(existingModel.getLastModified());
            metaManager.updateDataModelDesc(modelDesc);
        }
    } catch (IOException e) {
        logger.error(STR + e.getLocalizedMessage(), e);
        throw new InternalErrorException(STR + e.getLocalizedMessage());
    }
    CubeDesc desc = deserializeCubeDesc(cubeRequest);
    if (desc == null) {
        return cubeRequest;
    }
    String name = CubeService.getCubeNameFromDesc(desc.getName());
    if (StringUtils.isEmpty(name)) {
        logger.info(STR);
        throw new BadRequestException(STR);
    }
    try {
        desc.setUuid(UUID.randomUUID().toString());
        String projectName = (null == cubeRequest.getProject()) ? ProjectInstance.DEFAULT_PROJECT_NAME : cubeRequest.getProject();
        cubeService.createCubeAndDesc(name, projectName, desc);
    } catch (Exception e) {
        logger.error(STR, e);
        throw new InternalErrorException(e.getLocalizedMessage(), e);
    }
    cubeRequest.setUuid(desc.getUuid());
    cubeRequest.setSuccessful(true);
    return cubeRequest;
}"	@return cubeRequest cube change request	@return Table metadata array	1	0	8	46	321
"public boolean start(final FileDownloadListener listener, final boolean isSerial) { if (listener == null) { FileDownloadLog.w(this, ""Tasks with the listener can't start, because the listener "" + ""provided is null: [null, %B]"", isSerial); return false; } return isSerial ? startSerialTasks(listener) : startParallelTasks(listener); }"	"    public boolean start(final FileDownloadListener listener, final boolean isSerial) {

        if (listener == null) {
            FileDownloadLog.w(this, ""Tasks with the listener can't start, because the listener "" +
                    ""provided is null: [null, %B]"", isSerial);
            return false;
        }

        final List<BaseDownloadTask> list = FileDownloadList.getImpl().copy(listener);

        if (FileDownloadMonitor.isValid()) {
            FileDownloadMonitor.getMonitor().onRequestStart(list.size(), isSerial, listener);
        }

        if (FileDownloadLog.NEED_LOG) {
            FileDownloadLog.v(this, ""start list size[%d] listener[%s] isSerial[%B]"", list.size(),
                    listener, isSerial);
        }

        if (null == list || list.isEmpty()) {
            FileDownloadLog.w(this, ""Tasks with the listener can't start, because can't find any "" +
                    ""task with the provided listener: [%s, %B]"", listener, isSerial);
            return false;
        }

        if (isSerial) {
            // serial
            final Handler serialHandler = createSerialHandler(list);
            Message msg = serialHandler.obtainMessage();
            msg.what = WHAT_SERIAL_NEXT;
            msg.arg1 = 0;
            serialHandler.sendMessage(msg);
            synchronized (RUNNING_SERIAL_MAP) {
                RUNNING_SERIAL_MAP.put(listener, serialHandler);
            }
        } else {
            // parallel
            for (final BaseDownloadTask downloadTask : list) {
                downloadTask.start();
            }
        }

        return true;
    }
"	@return Whether start tasks successfully.	@return Whether start tasks successfully.	0	1	8	12	73
"public WebDriver augment(WebDriver driver) { // TODO(simon): We should really add a ""SelfDescribing"" interface for this if (!(driver instanceof RemoteWebDriver)) { return driver; } Map<String, ?> capabilities = ((RemoteWebDriver) driver).getCapabilities().asMap(); CompoundHandler handler = new CompoundHandler((RemoteWebDriver) driver); for (Map.Entry<String, ?> capablityName : capabilities.entrySet()) { AugmenterProvider augmenter = augmentors.get(capablityName.getKey()); if (augmenter == null) { continue; } Object value = capablityName.getValue(); if (value instanceof Boolean && !((Boolean) value).booleanValue()) { continue; } handler.addCapabilityHander(augmenter.getDescribedInterface(), augmenter.getImplementation(value)); } if (handler.isNeedingApplication()) { // Gather the existing interfaces Set<Class<?>> interfaces = new HashSet<Class<?>>(); interfaces.addAll(handler.getInterfaces()); interfaces.addAll(getInterfacesFrom(driver.getClass())); Enhancer enhancer = new Enhancer(); enhancer.setInterfaces(interfaces.toArray(new Class<?>[interfaces.size()])); enhancer.setCallback(handler); enhancer.setSuperclass(driver.getClass()); RemoteWebDriver remote = (RemoteWebDriver) enhancer.create(); remote.setCommandExecutor(((RemoteWebDriver) driver).getCommandExecutor()); remote.setElementConverter(((RemoteWebDriver) driver).getElementConverter()); return remote; } return driver; }"	"  public WebDriver augment(WebDriver driver) {
    // TODO(simon): We should really add a ""SelfDescribing"" interface for this
    if (!(driver instanceof RemoteWebDriver)) {
      return driver;
    }

    Map<String, ?> capabilities = ((RemoteWebDriver) driver).getCapabilities().asMap();

    CompoundHandler handler = new CompoundHandler((RemoteWebDriver) driver);

    for (Map.Entry<String, ?> capablityName : capabilities.entrySet()) {
      AugmenterProvider augmenter = augmentors.get(capablityName.getKey());
      if (augmenter == null) {
        continue;
      }

      Object value = capablityName.getValue();
      if (value instanceof Boolean && !((Boolean) value).booleanValue()) {
        continue;
      }

      handler.addCapabilityHander(augmenter.getDescribedInterface(),
          augmenter.getImplementation(value));
    }

    if (handler.isNeedingApplication()) {
      // Gather the existing interfaces
      Set<Class<?>> interfaces = new HashSet<Class<?>>();
      interfaces.addAll(handler.getInterfaces());
      interfaces.addAll(getInterfacesFrom(driver.getClass()));

      return (WebDriver) Proxy.newProxyInstance(getClass().getClassLoader(),
          interfaces.toArray(new Class<?>[interfaces.size()]), handler);
    }

    return driver;
  }
"	@return A class implementing the described interfaces.	@return A class implementing the described interfaces.	0	1	11	45	281
"public String fakeOuterStringSerialize(String body) throws ApiException { Object localVarPostBody = body; // create path and map variables String localVarPath = ""/fake/outer/string""; // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<String> localVarReturnType = new GenericType<String>() {}; return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	"  public String fakeOuterStringSerialize(String body) throws ApiException {
    Object localVarPostBody = body;
    
    // create path and map variables
    String localVarPath = ""/fake/outer/string"";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    final String[] localVarAccepts = {
      
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    GenericType<String> localVarReturnType = new GenericType<String>() {};
    return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);
      }
"	@return String	@return String	0	1	8	31	166
private Color invertFgColor() { if (currentBgColor_.defaultColor()) { if (!inverted_) clazzes_.add(INVERSE_FG_STYLE); return new Color(); } else if (currentBgColor_.isExtended()) { clazzes_.add(Color.clazzForColorIndex(currentBgColor_.code(), false)); return new Color(true, currentBgColor_.code()); } else if (currentBgColor_.code() >= BACKGROUND_MIN && currentBgColor_.code() <= BACKGROUND_MAX) { int newFg = currentBgColor_.code() - (BACKGROUND_MIN - FOREGROUND_MIN); clazzes_.add(FOREGROUND_STYLE + Integer.toString(newFg - FOREGROUND_MIN)); return new Color(false, newFg); } else { int newFg = currentBgColor_.code() - (BACKGROUND_INTENSE_MIN - FOREGROUND_INTENSE_MIN); clazzes_.add(FOREGROUND_STYLE + Integer.toString(newFg + NUM - FOREGROUND_INTENSE_MIN)); return new Color(false, newFg); } }	"private int invertFgColor() {
    if (currentBgColor_.defaultColor()) {
        if (!inverted_)
            clazzes_.add(INVERSE_FG_STYLE);
        return Color.DEFAULT_COLOR;
    } else if (currentBgColor_.code() >= BACKGROUND_MIN && currentBgColor_.code() <= BACKGROUND_MAX) {
        int newFg = currentBgColor_.code() - (BACKGROUND_MIN - FOREGROUND_MIN);
        clazzes_.add(FOREGROUND_STYLE + Integer.toString(newFg - FOREGROUND_MIN));
        return newFg;
    } else {
        int newFg = currentBgColor_.code() - (BACKGROUND_INTENSE_MIN - FOREGROUND_INTENSE_MIN);
        clazzes_.add(FOREGROUND_STYLE + Integer.toString(newFg + NUM - FOREGROUND_INTENSE_MIN));
        return newFg;
    }
}"	@return new foreground color based on the background color	@return new foreground color based on the supplied background color	1	0	13	18	165
public final double getValue(long timestamp) { compute(timestamp, timestamp); Score s = getComputedByTimestamp(timestamp); if (s == null) throw new IllegalStateException(); return s.getValue(); }	"public int getValue(long timestamp) {
    computeAll();
    String[] args = { habit.getId().toString(), Long.toString(timestamp) };
    return SQLiteUtils.intQuery(STR, args);
}"	@return score value for that day	@return score for that day	1	0	6	7	41
public Builder withSpnego(String principal, String realm) { return this.withSpnego(principal, realm, null); }	"    public Builder withSpnego(String principal, String realm) {
      this.authenticationType = AuthenticationType.SPNEGO;
      this.kerberosPrincipal = Objects.requireNonNull(principal);
      this.kerberosRealm = Objects.requireNonNull(realm);
      return this;
    }
"	@return this	@return this	0	1	6	4	23
public MergedSelectionSet collectFields(FieldCollectorParameters parameters, SelectionSet selectionSet) { Map<String, MergedFields> subFields = new LinkedHashMap<>(); List<String> visitedFragments = new ArrayList<>(); this.collectFields(parameters, selectionSet, visitedFragments, subFields); return newMergedSelectionSet().subFields(subFields).build(); }	"    private void collectFields(FieldCollectorParameters parameters, SelectionSet selectionSet, List<String> visitedFragments, Map<String, MergedFields> fields) {

        for (Selection selection : selectionSet.getSelections()) {
            if (selection instanceof Field) {
                collectField(parameters, fields, (Field) selection);
            } else if (selection instanceof InlineFragment) {
                collectInlineFragment(parameters, visitedFragments, fields, (InlineFragment) selection);
            } else if (selection instanceof FragmentSpread) {
                collectFragmentSpread(parameters, visitedFragments, fields, (FragmentSpread) selection);
            }
        }
    }
"	@return a map of the sub field selections	@return a map of the sub field selections	0	1	6	7	54
public Player asPlayer() { return Bukkit.getPlayer(raw); }	"public Player asPlayer() {
    return Bukkit.getPlayer(arg);
}"	@return The player by the name of the raw raw - null if (s)he isn't online	@return The player by the name of the raw arg - null if (s)he isn't online	1	0	5	3	14
"static TopicSelector<TableId> defaultSelector(String prefix, String heartbeatPrefix) { return TopicSelector.defaultSelector(prefix, heartbeatPrefix, ""."", (t, pref, delimiter) -> String.join(delimiter, pref, t.catalog(), t.table())); }"	"    static MySqlTopicSelector defaultSelector(String prefix, String heartbeatPrefix) {
        return defaultSelector(prefix, heartbeatPrefix, ""."");
    }
"	@return the topic selector; never null	@return the topic selector; never null	0	1	7	5	51
public String loginUser(String username, String password) throws RestClientException { return loginUserWithHttpInfo(username, password).getBody(); }	"    public String loginUser(String username, String password) throws RestClientException {
        Object postBody = null;
        
        // verify the required parameter 'username' is set
        if (username == null) {
            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'username' when calling loginUser"");
        }
        
        // verify the required parameter 'password' is set
        if (password == null) {
            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'password' when calling loginUser"");
        }
        
        String path = apiClient.expandPath(""/user/login"", Collections.<String, Object>emptyMap());

        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();
        final HttpHeaders headerParams = new HttpHeaders();
        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();

        queryParams.putAll(apiClient.parameterToMultiValueMap(null, ""username"", username));
        queryParams.putAll(apiClient.parameterToMultiValueMap(null, ""password"", password));

        final String[] accepts = { 
            ""application/xml"", ""application/json""
        };
        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);
        final String[] contentTypes = { };
        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);

        String[] authNames = new String[] {  };

        ParameterizedTypeReference<String> returnType = new ParameterizedTypeReference<String>() {};
        return apiClient.invokeAPI(path, HttpMethod.GET, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);
    }
"	@return String	@return String	0	1	5	4	25
"private ZapTextArea getTxtProxyChainSkipName() { if (txtProxyChainSkipName == null) { txtProxyChainSkipName = new ZapTextArea(); txtProxyChainSkipName.setFont(new java.awt.Font(""Dialog"", java.awt.Font.PLAIN, 11)); txtProxyChainSkipName.setMinimumSize(new java.awt.Dimension(0,32)); txtProxyChainSkipName.setRows(2); } return txtProxyChainSkipName; }"	"	private JTextArea getTxtProxyChainSkipName() {
		if (txtProxyChainSkipName == null) {
			txtProxyChainSkipName = new JTextArea();
			txtProxyChainSkipName.setFont(new java.awt.Font(""Dialog"", java.awt.Font.PLAIN, 11));
			txtProxyChainSkipName.setMinimumSize(new java.awt.Dimension(0,32));
			txtProxyChainSkipName.setRows(2);
		}
		return txtProxyChainSkipName;
	}
"	@return javax.swing.ZapTextArea	@return javax.swing.JTextArea	1	0	10	10	64
public static SchemaBuilder builder() { return SchemaBuilder.int32() .name(SCHEMA_NAME) .version(1); }	"    public static SchemaBuilder builder() {
        return SchemaBuilder.int64()
                            .name(SCHEMA_NAME)
                            .version(1);
    }
"	@return the schema builder	@return the schema builder	0	1	6	6	22
public Collection getDistancesMap(Group run, String year) { IWContext iwc = IWContext.getInstance(); Map disMap = new LinkedHashMap(); Collection distances = null; Collection type = new ArrayList(); type.add(IWMarathonConstants.GROUP_TYPE_RUN_DISTANCE); Iterator yearsIter = getYears(run).iterator(); while (yearsIter.hasNext()) { Group y = (Group) yearsIter.next(); if (y.getName().equals(year)) { try { distances = getGroupBiz(iwc).getChildGroupsRecursiveResultFiltered(y, type, true); } catch (Exception e) { distances = null; } } } return distances; }	"public Map getDistancesMap(Group run, String year) {
    IWContext iwc = IWContext.getInstance();
    Map disMap = new LinkedHashMap();
    Collection distances = null;
    Collection type = new ArrayList();
    type.add(IWMarathonConstants.GROUP_TYPE_RUN_DISTANCE);
    Iterator yearsIter = getYears(run).iterator();
    while (yearsIter.hasNext()) {
        Group y = (Group) yearsIter.next();
        if (y.getName().equals(year)) {
            try {
                distances = getGroupBiz(iwc).getChildGroupsRecursiveResultFiltered(y, type, true);
            } catch (Exception e) {
                distances = null;
            }
        } else {
            distances = null;
        }
    }
    if (distances != null) {
        Iterator disIter = distances.iterator();
        while (disIter.hasNext()) {
            Group dis = (Group) disIter.next();
            disMap.put(dis.getPrimaryKey().toString(), dis.getName());
        }
    }
    return disMap;
}"	@return Collection of all distances for a specific run on a specific year	@return Map of all distances for a specific run on a specific year	1	0	12	19	116
public static String getShortClassName(Object o) { String name = o.getClass().getName(); int index = name.lastIndexOf('.'); if (index >= 0) { name = name.substring(index + 1); } return name; }	"  public static String getShortClassName(Object o) {
    if (o == null) {
      return ""null"";
    }
    String name = o.getClass().getName();
    int index = name.lastIndexOf('.');
    if (index >= 0) {
      name = name.substring(index + 1);
    }
    return name;
  }
"	@return The name of the class minus a package name, for example ArrayList	@return The name of the class minus a package name, for example ArrayList	0	1	9	9	48
private boolean isSameText() { ArrayList<TextView> textViewList = soloView.getCurrentTextViews(null); int size = textViewList.size(); int constant = 0; if (size > 2) constant = 2; else constant = size; if (checkTextView != null && !checkTextView.getText().equals( textViewList.get(size - constant).getText())) { checkTextView = textViewList.get(size - constant); return false; } else if (checkTextView == null) { checkTextView = textViewList.get(size - constant); return false; } else return true; }	"	private boolean isSameText() {
		ArrayList<TextView> textViewList = soloView.getCurrentTextViews(null);
		int size = textViewList.size();
		int constant = 0;
		if (size > 2)
			constant = 2;
		else
			constant = size;
		
		if (checkTextView != null
				&& !checkTextView.getText().equals(
						soloView.getCurrentTextViews(null).get(
								soloView.getCurrentTextViews(null).size()
										- constant).getText())) {
			checkTextView = textViewList.get(size - constant);
			return true;
		} else if (checkTextView == null) {
			checkTextView = textViewList.get(size - constant);
			return true;
		}
		else
			return false;
	}
"	@return true if it is the same text and false if it is not	@return true if no more scrolling can be done	1	0	10	22	103
public org.apache.poi.ss.usermodel.Workbook transformXLS(InputStream is, Map beanParams) throws ParsePropertyException, InvalidFormatException { org.apache.poi.ss.usermodel.Workbook hssfWorkbook = null; try { hssfWorkbook = WorkbookFactory.create(is); transformWorkbook(hssfWorkbook, beanParams); } catch (IOException e) { e.printStackTrace(); } return hssfWorkbook; }	"public HSSFWorkbook transformXLS(InputStream is, Map beanParams) throws ParsePropertyException {
    HSSFWorkbook hssfWorkbook = null;
    try {
        POIFSFileSystem fs = new POIFSFileSystem(is);
        hssfWorkbook = new HSSFWorkbook(fs);
        transformWorkbook(hssfWorkbook, beanParams);
    } catch (IOException e) {
        e.printStackTrace();
    }
    return hssfWorkbook;
}"	@return new {@link org.apache.poi.ss.usermodel.Workbook} generated by inserting beans into corresponding excel template	@return new {@link HSSFWorkbook} generated by inserting beans into corresponding excel template	1	0	9	10	62
public Boolean asBoolean() { return Boolean.valueOf(arg); }	"public boolean asBoolean() {
    return Boolean.parseBoolean(arg);
}"	@return This ChatSection's value parsed as a boolean. Note that if the value of the ChatSection isn't a valid boolean, false is returned	@return This ChatSection's value parsed as a boolean. If the value of the ChatSection isn't a valid boolean, false is returned	1	0	5	3	14
private static FunctionExprNode createLikeFunctionExprNode(String fieldName, LikeFilter likeFilter) { if (likeFilter == null) { return null; } return new FunctionExprNode(LIKE_FUNCTION, likeFilter.hasEscape() ? ImmutableList.of( new FieldExprNode(fieldName), new ConstantExprNode(likeFilter.getPattern()), new ConstantExprNode(likeFilter.getEscape())) : ImmutableList.of( new FieldExprNode(fieldName), new ConstantExprNode(likeFilter.getPattern())) ); }	"  private static FunctionExprNode createLikeFunctionExprNode(String fieldName, LikeFilter likeFilter) {
    if (likeFilter == null) {
      return null;
    }

    return new FunctionExprNode(LIKE_FUNCTION,
        likeFilter.hasEscape() ?
            ImmutableList.of(
                new FieldExprNode(fieldName),
                new ConstantExprNode(likeFilter.getRegex()),
                new ConstantExprNode(likeFilter.getEscape())) :
            ImmutableList.of(
                new FieldExprNode(fieldName),
                new ConstantExprNode(likeFilter.getRegex()))
    );
  }
"	@return  FunctionExprNode for given arguments. Null if the likeFilter is null.	@return FunctionExprNode for given arguments. Null if the likeFilter is null.	0	1	8	17	82
private boolean isAncestorOf(Object object1, Object object2) { if (object2 == null) return false; Object parent = getParent(object2); if (parent == object1) return true; return isAncestorOf(object1, parent); }	"private boolean isAncestorOf(Object node, Object target) {
    if (target == null)
        return false;
    Object parent = getParent(target);
    if (parent == node)
        return true;
    return isAncestorOf(node, parent);
}"	@return true if the first object is the ancestor of the second object2.	@return true if the node is an ancestor of the target node.	1	0	6	8	43
public SessionFactory getSessionFactory() { return daoTest.getSessionFactory(); }	"    public SessionFactory getSessionFactory() {
        return sessionFactory;
    }
"	@return  SessionFactory with an open session.	@return SessionFactory with an open session.	0	1	4	4	13
private ObjectNode getSelectedRegionJson(Cluster cluster, String selectedRegionFullPath) { PulseLogWriter LOGGER = PulseLogWriter.getLogger(); Long totalHeapSize = cluster.getTotalHeapSize(); Long totalDiskUsage = cluster.getTotalBytesOnDisk(); Cluster.Region reg = cluster.getClusterRegion(selectedRegionFullPath); if (reg != null) { ObjectNode regionJSON = mapper.createObjectNode(); regionJSON.put(STR, reg.getName()); regionJSON.put(STR, reg.getFullPath()); regionJSON.put(STR, totalHeapSize); regionJSON.put(STR, reg.getSystemRegionEntryCount()); regionJSON.put(STR, reg.getMemberCount()); final String regionType = reg.getRegionType(); regionJSON.put(STR, regionType); regionJSON.put(STR, reg.getGetsRate()); regionJSON.put(STR, reg.getPutsRate()); regionJSON.put(STR, reg.getLruEvictionRate()); DecimalFormat df2 = new DecimalFormat(PulseConstants.DECIMAL_FORMAT_PATTERN); Cluster.Member[] clusterMembersList = cluster.getMembers(); List<Cluster.Member> clusterMembersL = new ArrayList<Cluster.Member>(); for (String memberName : reg.getMemberName()) { for (Cluster.Member member : clusterMembersList) { String name = member.getName(); name = name.replace(STR, STR); String id = member.getId(); id = id.replace(STR, STR); if ((memberName.equals(id)) || (memberName.equals(name))) { clusterMembersL.add(member); } } } Collections.sort(clusterMembersL, memberCurrentHeapUsageComparator); ArrayNode memberArray = mapper.createArrayNode(); for (Cluster.Member member : clusterMembersL) { ObjectNode regionMember = mapper.createObjectNode(); regionMember.put(STR, member.getId()); regionMember.put(STR, member.getName()); regionMember.put(STR, member.getHost()); long usedHeapSize = cluster.getUsedHeapSize(); long currentHeap = member.getCurrentHeapSize(); if (usedHeapSize > NUM) { float heapUsage = ((float) currentHeap / (float) usedHeapSize) * NUM; regionMember.put(STR, Double.valueOf(df2.format(heapUsage))); } else { regionMember.put(STR, NUM); } Float currentCPUUsage = member.getCpuUsage(); regionMember.put(STR, Float.valueOf(df2.format(currentCPUUsage))); regionMember.put(STR, member.getCurrentHeapSize()); regionMember.put(STR, member.isManager()); regionMember.put(STR, TimeUtils.convertTimeSecondsToHMS(member.getUptime())); regionMember.put(STR, member.getLoadAverage()); regionMember.put(STR, member.getTotalFileDescriptorOpen()); regionMember.put(STR, member.getNumThreads()); if (PulseController.getPulseProductSupport().equalsIgnoreCase(PulseConstants.PRODUCT_NAME_SQLFIRE)) { regionMember.put(STR, member.getNumSqlfireClients()); } else { regionMember.put(STR, member.getMemberClientsHMap().size()); } regionMember.put(STR, member.getQueueBacklog()); memberArray.add(regionMember); } regionJSON.put(STR, memberArray); regionJSON.put(STR, reg.getSystemRegionEntryCount()); regionJSON.put(STR, reg.getPersistentEnabled() ? PulseService.VALUE_ON : PulseService.VALUE_OFF); regionJSON.put(STR, reg.isEnableOffHeapMemory() ? PulseService.VALUE_ON : PulseService.VALUE_OFF); if (regionType.startsWith(STR)) { regionJSON.put(STR, reg.isHdfsWriteOnly() ? PulseService.VALUE_ON : PulseService.VALUE_OFF); } else { regionJSON.put(STR, PulseService.VALUE_NA); } String regCompCodec = reg.getCompressionCodec(); if (StringUtils.isNotNullNotEmptyNotWhiteSpace(regCompCodec)) { regionJSON.put(STR, reg.getCompressionCodec()); } else { regionJSON.put(STR, PulseService.VALUE_NA); } if (PulseConstants.PRODUCT_NAME_SQLFIRE.equalsIgnoreCase(PulseController.getPulseProductSupport())) { regionJSON.put(STR, StringUtils.getTableNameFromRegionName(reg.getFullPath())); } else { regionJSON.put(STR, reg.getFullPath()); } regionJSON.put(STR, mapper.valueToTree(reg.getRegionStatisticTrend(Cluster.Region.REGION_STAT_GETS_PER_SEC_TREND))); regionJSON.put(STR, mapper.valueToTree(reg.getRegionStatisticTrend(Cluster.Region.REGION_STAT_PUTS_PER_SEC_TREND))); regionJSON.put(STR, mapper.valueToTree(reg.getRegionStatisticTrend(Cluster.Region.REGION_STAT_DISK_READS_PER_SEC_TREND))); regionJSON.put(STR, mapper.valueToTree(reg.getRegionStatisticTrend(Cluster.Region.REGION_STAT_DISK_WRITES_PER_SEC_TREND))); regionJSON.put(STR, reg.getEmptyNode()); Long entrySize = reg.getEntrySize(); DecimalFormat form = new DecimalFormat(PulseConstants.DECIMAL_FORMAT_PATTERN_2); String entrySizeInMB = form.format(entrySize / (NUM * NUM)); if (entrySize < NUM) { regionJSON.put(this.ENTRY_SIZE, PulseService.VALUE_NA); } else { regionJSON.put(this.ENTRY_SIZE, entrySizeInMB); } regionJSON.put(STR, reg.getDiskUsage()); regionJSON.put(STR, reg.getWanEnabled()); regionJSON.put(STR, totalDiskUsage); regionJSON.put(STR, entrySizeInMB); LOGGER.fine(STR + regionJSON); return regionJSON; } else { ObjectNode responseJSON = mapper.createObjectNode(); responseJSON.put(STR, STR + selectedRegionFullPath + STR); return responseJSON; } }	"private JSONObject getSelectedRegionJson(Cluster cluster, String selectedRegionFullPath) throws JSONException {
    PulseLogWriter LOGGER = PulseLogWriter.getLogger();
    Long totalHeapSize = cluster.getTotalHeapSize();
    Long totalDiskUsage = cluster.getTotalBytesOnDisk();
    Cluster.Region reg = cluster.getClusterRegion(selectedRegionFullPath);
    if (reg != null) {
        JSONObject regionJSON = new JSONObject();
        regionJSON.put(STR, reg.getName());
        regionJSON.put(STR, reg.getFullPath());
        regionJSON.put(STR, totalHeapSize);
        regionJSON.put(STR, reg.getSystemRegionEntryCount());
        regionJSON.put(STR, reg.getMemberCount());
        final String regionType = reg.getRegionType();
        regionJSON.put(STR, regionType);
        regionJSON.put(STR, reg.getGetsRate());
        regionJSON.put(STR, reg.getPutsRate());
        regionJSON.put(STR, reg.getLruEvictionRate());
        DecimalFormat df2 = new DecimalFormat(PulseConstants.DECIMAL_FORMAT_PATTERN);
        Cluster.Member[] clusterMembersList = cluster.getMembers();
        List<Cluster.Member> clusterMembersL = new ArrayList<Cluster.Member>();
        for (String memberName : reg.getMemberName()) {
            for (Cluster.Member member : clusterMembersList) {
                String name = member.getName();
                name = name.replace(STR, STR);
                String id = member.getId();
                id = id.replace(STR, STR);
                if ((memberName.equals(id)) || (memberName.equals(name))) {
                    clusterMembersL.add(member);
                }
            }
        }
        Collections.sort(clusterMembersL, memberCurrentHeapUsageComparator);
        JSONArray memberArray = new JSONArray();
        for (Cluster.Member member : clusterMembersL) {
            JSONObject regionMember = new JSONObject();
            regionMember.put(STR, member.getId());
            regionMember.put(STR, member.getName());
            regionMember.put(STR, member.getHost());
            long usedHeapSize = cluster.getUsedHeapSize();
            long currentHeap = member.getCurrentHeapSize();
            if (usedHeapSize > NUM) {
                float heapUsage = ((float) currentHeap / (float) usedHeapSize) * NUM;
                regionMember.put(STR, Double.valueOf(df2.format(heapUsage)));
            } else {
                regionMember.put(STR, NUM);
            }
            Float currentCPUUsage = member.getCpuUsage();
            regionMember.put(STR, Float.valueOf(df2.format(currentCPUUsage)));
            regionMember.put(STR, member.getCurrentHeapSize());
            regionMember.put(STR, member.isManager());
            regionMember.put(STR, TimeUtils.convertTimeSecondsToHMS(member.getUptime()));
            regionMember.put(STR, member.getLoadAverage());
            regionMember.put(STR, member.getTotalFileDescriptorOpen());
            regionMember.put(STR, member.getNumThreads());
            if (PulseController.getPulseProductSupport().equalsIgnoreCase(PulseConstants.PRODUCT_NAME_SQLFIRE)) {
                regionMember.put(STR, member.getNumSqlfireClients());
            } else {
                regionMember.put(STR, member.getMemberClientsHMap().size());
            }
            regionMember.put(STR, member.getQueueBacklog());
            memberArray.put(regionMember);
        }
        regionJSON.put(STR, memberArray);
        regionJSON.put(STR, reg.getSystemRegionEntryCount());
        Boolean persistent = reg.getPersistentEnabled();
        if (persistent) {
            regionJSON.put(STR, PulseService.VALUE_ON);
        } else {
            regionJSON.put(STR, PulseService.VALUE_OFF);
        }
        Boolean isEnableOffHeapMemory = reg.isEnableOffHeapMemory();
        if (isEnableOffHeapMemory) {
            regionJSON.put(STR, PulseService.VALUE_ON);
        } else {
            regionJSON.put(STR, PulseService.VALUE_OFF);
        }
        Boolean isHDFSWriteOnly = reg.isHdfsWriteOnly();
        if (regionType.startsWith(STR)) {
            if (isHDFSWriteOnly) {
                regionJSON.put(STR, PulseService.VALUE_ON);
            } else {
                regionJSON.put(STR, PulseService.VALUE_OFF);
            }
        } else {
            regionJSON.put(STR, PulseService.VALUE_NA);
        }
        String regCompCodec = reg.getCompressionCodec();
        if (StringUtils.isNotNullNotEmptyNotWhiteSpace(regCompCodec)) {
            regionJSON.put(STR, reg.getCompressionCodec());
        } else {
            regionJSON.put(STR, PulseService.VALUE_NA);
        }
        if (PulseConstants.PRODUCT_NAME_SQLFIRE.equalsIgnoreCase(PulseController.getPulseProductSupport())) {
            regionJSON.put(STR, StringUtils.getTableNameFromRegionName(reg.getFullPath()));
        } else {
            regionJSON.put(STR, reg.getFullPath());
        }
        regionJSON.put(STR, new JSONArray(reg.getRegionStatisticTrend(Cluster.Region.REGION_STAT_GETS_PER_SEC_TREND)));
        regionJSON.put(STR, new JSONArray(reg.getRegionStatisticTrend(Cluster.Region.REGION_STAT_PUTS_PER_SEC_TREND)));
        regionJSON.put(STR, new JSONArray(reg.getRegionStatisticTrend(Cluster.Region.REGION_STAT_DISK_READS_PER_SEC_TREND)));
        regionJSON.put(STR, new JSONArray(reg.getRegionStatisticTrend(Cluster.Region.REGION_STAT_DISK_WRITES_PER_SEC_TREND)));
        regionJSON.put(STR, reg.getEmptyNode());
        Long entrySize = reg.getEntrySize();
        DecimalFormat form = new DecimalFormat(PulseConstants.DECIMAL_FORMAT_PATTERN_2);
        String entrySizeInMB = form.format(entrySize / (NUM * NUM));
        if (entrySize < NUM) {
            regionJSON.put(this.ENTRY_SIZE, PulseService.VALUE_NA);
        } else {
            regionJSON.put(this.ENTRY_SIZE, entrySizeInMB);
        }
        regionJSON.put(STR, reg.getDiskUsage());
        regionJSON.put(STR, reg.getWanEnabled());
        regionJSON.put(STR, totalDiskUsage);
        regionJSON.put(STR, entrySizeInMB);
        LOGGER.fine(STR + regionJSON);
        return regionJSON;
    } else {
        JSONObject responseJSON = new JSONObject();
        responseJSON.put(STR, STR + selectedRegionFullPath + STR);
        return responseJSON;
    }
}"	@return ObjectNode Array List	@return JSONObject Array List	1	0	14	107	941
"private boolean optimize(Visitor optimizer, boolean performInline) { int optimizeCount = 0; final UseCounter useCounter = new UseCounter(); for (Statement statement : statements) { if (statement instanceof DeclarationStatement && performInline) { DeclarationStatement decl = (DeclarationStatement) statement; useCounter.map.put(decl.parameter, new Slot()); } // We are added only counters up to current statement. // It is fine to count usages as the latter declarations cannot be used // in more recent statements. if (!useCounter.map.isEmpty()) { statement.accept(useCounter); } } final Map<ParameterExpression, Expression> subMap = new IdentityHashMap<ParameterExpression, Expression>( useCounter.map.size()); final SubstituteVariableVisitor visitor = new SubstituteVariableVisitor( subMap); final ArrayList<Statement> oldStatements = new ArrayList<Statement>( statements); statements.clear(); for (Statement oldStatement : oldStatements) { if (oldStatement instanceof DeclarationStatement) { DeclarationStatement statement = (DeclarationStatement) oldStatement; final Slot slot = useCounter.map.get(statement.parameter); int count = slot == null ? 100 : slot.count; if (count > 1 && isSafeForReuse(statement) && isSimpleExpression(statement.initializer)) { // Inline simple final constants count = 1; } if (statement.parameter.name.startsWith(""_"")) { // Don't inline variables whose name begins with ""_"". This // is a hacky way to prevent inlining. E.g. // final int _count = collection.size(); // foo(collection); // return collection.size() - _count; count = 100; } if (statement.initializer instanceof NewExpression && ((NewExpression) statement.initializer).memberDeclarations != null) { // Don't inline anonymous inner classes. Janino gets // confused referencing variables from deeply nested // anonymous classes. count = 100; } Expression normalized = normalizeDeclaration(statement); expressionForReuse.remove(normalized); switch (count) { case 0: // Only declared, never used. Throw away declaration. break; case 1: // declared, used once. inline it. subMap.put(statement.parameter, normalized); break; default: Statement beforeOptimize = oldStatement; if (!subMap.isEmpty()) { oldStatement = oldStatement.accept(visitor); // remap } oldStatement = oldStatement.accept(optimizer); if (beforeOptimize != oldStatement) { ++optimizeCount; } if (oldStatement != OptimizeVisitor.EMPTY_STATEMENT) { if (oldStatement instanceof DeclarationStatement) { addExpresisonForReuse((DeclarationStatement) oldStatement); } statements.add(oldStatement); } break; } } else { Statement beforeOptimize = oldStatement; if (!subMap.isEmpty()) { oldStatement = oldStatement.accept(visitor); // remap } oldStatement = oldStatement.accept(optimizer); if (beforeOptimize != oldStatement) { ++optimizeCount; } if (oldStatement != OptimizeVisitor.EMPTY_STATEMENT) { statements.add(oldStatement); } } } return optimizeCount > 0; }"	"  private boolean optimize(Visitor optimizer, boolean performInline) {
    boolean optimized = false;
    final UseCounter useCounter = new UseCounter();
    for (Statement statement : statements) {
      if (statement instanceof DeclarationStatement && performInline) {
        DeclarationStatement decl = (DeclarationStatement) statement;
        useCounter.map.put(decl.parameter, new Slot());
      }
      // We are added only counters up to current statement.
      // It is fine to count usages as the latter declarations cannot be used
      // in more recent statements.
      if (!useCounter.map.isEmpty()) {
        statement.accept(useCounter);
      }
    }
    final Map<ParameterExpression, Expression> subMap =
        new IdentityHashMap<ParameterExpression, Expression>(
            useCounter.map.size());
    final SubstituteVariableVisitor visitor = new SubstituteVariableVisitor(
        subMap);
    final ArrayList<Statement> oldStatements = new ArrayList<Statement>(
        statements);
    statements.clear();

    for (Statement oldStatement : oldStatements) {
      if (oldStatement instanceof DeclarationStatement) {
        DeclarationStatement statement = (DeclarationStatement) oldStatement;
        final Slot slot = useCounter.map.get(statement.parameter);
        int count = slot == null ? 100 : slot.count;
        if (count > 1 && isSafeForReuse(statement)
            && isSimpleExpression(statement.initializer)) {
          // Inline simple final constants
          count = 1;
        }
        if (statement.parameter.name.startsWith(""_"")) {
          // Don't inline variables whose name begins with ""_"". This
          // is a hacky way to prevent inlining. E.g.
          //   final int _count = collection.size();
          //   foo(collection);
          //   return collection.size() - _count;
          count = 100;
        }
        if (statement.initializer instanceof NewExpression
            && ((NewExpression) statement.initializer).memberDeclarations
                != null) {
          // Don't inline anonymous inner classes. Janino gets
          // confused referencing variables from deeply nested
          // anonymous classes.
          count = 100;
        }
        Expression normalized = normalizeDeclaration(statement);
        expressionForReuse.remove(normalized);
        switch (count) {
        case 0:
          // Only declared, never used. Throw away declaration.
          break;
        case 1:
          // declared, used once. inline it.
          subMap.put(statement.parameter, normalized);
          break;
        default:
          Statement beforeOptimize = oldStatement;
          if (!subMap.isEmpty()) {
            oldStatement = oldStatement.accept(visitor); // remap
          }
          oldStatement = oldStatement.accept(optimizer);
          optimized |= beforeOptimize != oldStatement;
          if (oldStatement != OptimizeVisitor.EMPTY_STATEMENT) {
            if (oldStatement instanceof DeclarationStatement) {
              addExpresisonForReuse((DeclarationStatement) oldStatement);
            }
            statements.add(oldStatement);
          }
          break;
        }
      } else {
        Statement beforeOptimize = oldStatement;
        if (!subMap.isEmpty()) {
          oldStatement = oldStatement.accept(visitor); // remap
        }
        oldStatement = oldStatement.accept(optimizer);
        optimized |= beforeOptimize != oldStatement;
        if (oldStatement != OptimizeVisitor.EMPTY_STATEMENT) {
          statements.add(oldStatement);
        }
      }
    }
    return optimized;
  }
"	@return whether any optimizations were made	@return if any optimizations were made or not	1	0	16	94	547
public Session createSession(boolean transacted,int acknowledgeMode) throws JMSException{ checkClosedOrFailed(); ensureConnectionInfoSent(); boolean doSessionAsync=alwaysSessionAsync||sessions.size()>0||transacted ||acknowledgeMode==Session.CLIENT_ACKNOWLEDGE; return new ActiveMQSession(this,getNextSessionId(),(transacted?Session.SESSION_TRANSACTED :(acknowledgeMode==Session.SESSION_TRANSACTED?Session.AUTO_ACKNOWLEDGE:acknowledgeMode)), asyncDispatch,alwaysSessionAsync); }	"    public Session createSession(boolean transacted, int acknowledgeMode) throws JMSException {
        checkClosedOrFailed();
        ensureConnectionInfoSent();
        return new ActiveMQSession(this, getNextSessionId(), (transacted ? Session.SESSION_TRANSACTED
                : (acknowledgeMode == Session.SESSION_TRANSACTED ? Session.AUTO_ACKNOWLEDGE : acknowledgeMode)), asyncDispatch);
    }
"	@return a newly created session	@return a newly created session	0	1	9	10	74
"public static ExternalSessionKey fromJsonResponseBody(String responseBody) { try { JsonObject json = new JsonParser().parse(responseBody).getAsJsonObject(); if (!json.has(""sessionId"") || json.get(""sessionId"").isJsonNull()) { return null; } return new ExternalSessionKey(json.get(""sessionId"").getAsString()); } catch (JsonSyntaxException e) { return null; } }"	"  public static ExternalSessionKey fromJsonResponseBody(String responseBody) {
    try {
      JSONObject json = new JSONObject(responseBody);
      if (!json.has(""sessionId"") || json.isNull(""sessionId"")) {
        return null;
      }
      return new ExternalSessionKey(json.getString(""sessionId""));
    } catch (JSONException e) {
      return null;
    }
  }
"	@return the extracted ExternalKey, or null if one was not found.	@return the extracted ExternalKey, or null if one was not found.	0	1	8	12	81
public int getSessionState() { return ServerApiUtils.getSessionState(session); }	"public int getSessionState() {
    return session.getSessionState();
}"	@return State (see class SessionState)	@return State (-1: not started, 0: pending, 1: canceled, 2: established, 3: terminated)	1	0	5	3	14
public boolean equals(Object o) { if (this == o) { return true; } if (!(o instanceof FiltersAggregation)) { return false; } FiltersAggregation rhs = (FiltersAggregation) o; return new EqualsBuilder() .append(getCountList(), rhs.getCountList()) .append(getCounts(), rhs.getCounts()) .isEquals(); }	"    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (!(o instanceof FiltersAggregation)) {
            return false;
        }

        FiltersAggregation that = (FiltersAggregation) o;

        if (!countList.equals(that.countList)) {
            return false;
        }
        if (!counts.equals(that.counts)) {
            return false;
        }

        return true;
    }
"	@return A map filter names to associated counts	@return A map filter names to associated counts	0	1	6	15	71
public CloseableHttpClient build(String name) { final InstrumentedHttpClientConnectionManager manager = createConnectionManager(registry, name); return createClient(org.apache.http.impl.client.HttpClientBuilder.create(), manager, name); }	"public HttpClient build(String name) {
    final BasicHttpParams params = createHttpParams(name);
    final InstrumentedClientConnManager manager = createConnectionManager(registry, name);
    final InstrumentedHttpClient client = new InstrumentedHttpClient(metricRegistry, manager, params, name);
    setStrategiesForClient(client);
    return client;
}"	@return an {@link CloseableHttpClient}	@return an {@link HttpClient}	1	0	6	4	37
public boolean isCancelRequested() { return atomicBoolean.get(); }	"  public boolean isCancelRequested() {
    return cancelRequested;
  }
"	@return whether a cancellation has been requested	@return whether a cancellation has been requested	0	1	4	4	13
public QName getPortTypeName() { return portTypeName == null ? new QName(STR) : portTypeName; }	"public QName getPortTypeName() {
    return portName == null ? new QName(STR) : portName;
}"	@return QName Fully qualified name of the port type	@return QName Fully qualified name of the port	1	0	6	3	19
"public List<Pet> findPetsByStatus(List<String> status) throws ApiException { Object localVarPostBody = null; // verify the required parameter 'status' is set if (status == null) { throw new ApiException(400, ""Missing the required parameter 'status' when calling findPetsByStatus""); } // create path and map variables String localVarPath = ""/pet/findByStatus"".replaceAll(""\\{format\\}"",""json""); // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, String> localVarCookieParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); localVarQueryParams.addAll(apiClient.parameterToPairs(""csv"", ""status"", status)); final String[] localVarAccepts = { ""application/xml"", ""application/json"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { ""petstore_auth"" }; GenericType<List<Pet>> localVarReturnType = new GenericType<List<Pet>>() {}; return apiClient.invokeAPI(localVarPath, ""GET"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	"  public List<Pet> findPetsByStatus(List<String> status) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'status' is set
    if (status == null) {
      throw new ApiException(400, ""Missing the required parameter 'status' when calling findPetsByStatus"");
    }
    
    // create path and map variables
    String localVarPath = ""/pet/findByStatus"".replaceAll(""\\{format\\}"",""json"");

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPairs(""csv"", ""status"", status));

    
    
    final String[] localVarAccepts = {
      ""application/xml"", ""application/json""
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { ""petstore_auth"" };

    GenericType<List<Pet>> localVarReturnType = new GenericType<List<Pet>>() {};
    return apiClient.invokeAPI(localVarPath, ""GET"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);
      }
"	@return a  List	@return a List	0	1	10	38	258
"public List<String> dependencyPathBetween(int start, int end, Optional<Function<Sentence, List<String>>> selector) { // Get paths from a node to the root of the sentence LinkedList<Integer> rootToStart = new LinkedList<>(); LinkedList<Integer> rootToEnd = new LinkedList<>(); int startAncestor = start; List<Optional<Integer>> governors = sentence.governors(); Set<Integer> seenVertices = new HashSet<>(); while (startAncestor >= 0 && governors.get(startAncestor).isPresent()) { if (seenVertices.contains(startAncestor)) { // Found loopiness -- revert to BFS return loopyDependencyPathBetween(start, end, selector); } seenVertices.add(startAncestor); rootToStart.addFirst(startAncestor); startAncestor = governors.get(startAncestor).get(); } if (startAncestor == -1) { rootToStart.addFirst(-1); } int endAncestor = end; seenVertices.clear(); while (endAncestor >= 0 && governors.get(endAncestor).isPresent()) { if (seenVertices.contains(endAncestor)) { // Found loopiness -- revert to BFS return loopyDependencyPathBetween(start, end, selector); } seenVertices.add(endAncestor); rootToEnd.addFirst(endAncestor); endAncestor = governors.get(endAncestor).get(); } if (endAncestor == -1) { rootToEnd.addFirst(-1); } // Get least common node int leastCommonNodeIndex = (rootToStart.size() == 0 || rootToEnd.size() == 0 || !rootToStart.get(0).equals(rootToEnd.get(0))) ? -1 : 0; for (int i = 1; i < Math.min(rootToStart.size(), rootToEnd.size()); ++i) { if (rootToStart.get(i).equals(rootToEnd.get(i))) { leastCommonNodeIndex = i; } } // Construct the path if (leastCommonNodeIndex < 0) { return Collections.emptyList(); } List<String> path = new ArrayList<>(); Optional<List<String>> words = selector.map(x -> x.apply(sentence)); for (int i = rootToStart.size() - 1; i > leastCommonNodeIndex; --i) { final int index = i; words.ifPresent(x -> path.add(x.get(rootToStart.get(index)))); path.add(""<-"" + sentence.incomingDependencyLabel(rootToStart.get(i)).orElse(""dep"") + ""-""); } if (words.isPresent()) { path.add(words.get().get(rootToStart.get(leastCommonNodeIndex))); } for (int i = leastCommonNodeIndex + 1; i < rootToEnd.size(); ++i) { final int index = i; path.add(""-"" + sentence.incomingDependencyLabel(rootToEnd.get(i)).orElse(""dep"") + ""->""); words.ifPresent(x -> path.add(x.get(rootToEnd.get(index)))); } return path; }"	"  public List<String> dependencyPathBetween(int start, int end, Function<Sentence, List<String>> selector) {
    // Get paths from a node to the root of the sentence
    LinkedList<Integer> rootToStart = new LinkedList<>();
    LinkedList<Integer> rootToEnd = new LinkedList<>();
    int startAncestor = start;
    List<Optional<Integer>> governors = sentence.governors();
    Set<Integer> seenVertices = new HashSet<>();
    while (startAncestor >= 0 && governors.get(startAncestor).isPresent()) {
      if (seenVertices.contains(startAncestor)) {
        return Collections.EMPTY_LIST;
      }
      seenVertices.add(startAncestor);
      rootToStart.addFirst(startAncestor);
      startAncestor = governors.get(startAncestor).get();
    }
    if (startAncestor == -1) {
      rootToStart.addFirst(-1);
    }
    int endAncestor = end;
    seenVertices.clear();
    while (endAncestor >= 0 && governors.get(endAncestor).isPresent()) {
      if (seenVertices.contains(endAncestor)) {
        return Collections.EMPTY_LIST;
      }
      seenVertices.add(endAncestor);
      rootToEnd.addFirst(endAncestor);
      endAncestor = governors.get(endAncestor).get();
    }
    if (endAncestor == -1) {
      rootToEnd.addFirst(-1);
    }

    // Get least common node
    int leastCommonNodeIndex = (rootToStart.size() == 0 || rootToEnd.size() == 0 || !rootToStart.get(0).equals(rootToEnd.get(0))) ? -1 : 0;
    for (int i = 1; i < Math.min(rootToStart.size(), rootToEnd.size()); ++i) {
      if (rootToStart.get(i).equals(rootToEnd.get(i))) {
        leastCommonNodeIndex = i;
      }
    }

    // Construct the path
    if (leastCommonNodeIndex < 0) {
      return Collections.EMPTY_LIST;
    }
    List<String> path = new ArrayList<>();
    for (int i = rootToStart.size() - 1; i > leastCommonNodeIndex; --i) {
      path.add(selector.apply(sentence).get(rootToStart.get(i)));
      path.add(""<-"" + sentence.incomingDependencyLabel(rootToStart.get(i)).orElse(""dep"") + ""-"");
    }
    path.add(selector.apply(sentence).get(rootToStart.get(leastCommonNodeIndex)));
    for (int i = leastCommonNodeIndex + 1; i < rootToEnd.size(); ++i) {
      path.add(""-"" + sentence.incomingDependencyLabel(rootToEnd.get(i)).orElse(""dep"") + ""->"");
      path.add(selector.apply(sentence).get(rootToEnd.get(i)));
    }
    return path;
  }
"	@return A list encoding the dependency path between the vertices, suitable for inclusion as features.	@return The most common element of the given property in the sentence.	1	0	11	64	555
protected Object convertTimeToMillisPastMidnightAsDate(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0L; // return epoch } try { return new java.util.Date(Time.toMilliOfDay(data)); } catch (IllegalArgumentException e) { return handleUnknownData(column, fieldDefn, data); } }	"    protected Object convertTimeToMillisPastMidnightAsDate(Column column, Field fieldDefn, Object data) {
        if ( data == null ) return null;
        try {
            return new java.util.Date(Time.toMilliOfDay(data));
        } catch (IllegalArgumentException e) {
            return handleUnknownData(column, fieldDefn, data);
        }
    }
"	@return the converted value, or null if the conversion could not be made and the column allows nulls	@return the converted value, or null if the conversion could not be made	1	0	8	15	88
"public static String encodeObject( java.io.Serializable serializableObject, int options ) throws java.io.IOException { if( serializableObject == null ){ throw new NullPointerException( ""Cannot serialize a null object."" ); } // end if: null // Streams java.io.ByteArrayOutputStream baos = null; java.io.OutputStream b64os = null; java.util.zip.GZIPOutputStream gzos = null; java.io.ObjectOutputStream oos = null; try { // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream baos = new java.io.ByteArrayOutputStream(); b64os = new Base64.OutputStream( baos, ENCODE | options ); if( (options & GZIP) != 0 ){ // Gzip gzos = new java.util.zip.GZIPOutputStream(b64os); oos = new java.io.ObjectOutputStream( gzos ); } else { // Not gzipped oos = new java.io.ObjectOutputStream( b64os ); } oos.writeObject( serializableObject ); } // end try catch( java.io.IOException e ) { // Catch it and then throw it immediately so that // the finally{} block is called for cleanup. throw e; } // end catch finally { try{ oos.close(); } catch( Exception e ){} try{ gzos.close(); } catch( Exception e ){} try{ b64os.close(); } catch( Exception e ){} try{ baos.close(); } catch( Exception e ){} } // end finally // Return value according to relevant encoding. try { return new String( baos.toByteArray(), PREFERRED_ENCODING ); } // end try catch (java.io.UnsupportedEncodingException uue){ // Fall back to some Java default return new String( baos.toByteArray(), StandardCharsets.UTF_8 ); } // end catch } // end encode"	"  public static String encodeObject( java.io.Serializable serializableObject, int options )
      throws java.io.IOException {

    if( serializableObject == null ){
      throw new NullPointerException( ""Cannot serialize a null object."" );
    }   // end if: null

    // Streams
    java.io.ByteArrayOutputStream  baos  = null;
    java.io.OutputStream           b64os = null;
    java.util.zip.GZIPOutputStream gzos  = null;
    java.io.ObjectOutputStream     oos   = null;


    try {
      // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream
      baos  = new java.io.ByteArrayOutputStream();
      b64os = new Base64.OutputStream( baos, ENCODE | options );
      if( (options & GZIP) != 0 ){
        // Gzip
        gzos = new java.util.zip.GZIPOutputStream(b64os);
        oos = new java.io.ObjectOutputStream( gzos );
      } else {
        // Not gzipped
        oos = new java.io.ObjectOutputStream( b64os );
      }
      oos.writeObject( serializableObject );
    }   // end try
    catch( java.io.IOException e ) {
      // Catch it and then throw it immediately so that
      // the finally{} block is called for cleanup.
      throw e;
    }   // end catch
    finally {
      try{ oos.close();   } catch( Exception e ){}
      try{ gzos.close();  } catch( Exception e ){}
      try{ b64os.close(); } catch( Exception e ){}
      try{ baos.close();  } catch( Exception e ){}
    }   // end finally

    // Return value according to relevant encoding.
    try {
      return new String( baos.toByteArray(), PREFERRED_ENCODING );
    }   // end try
    catch (java.io.UnsupportedEncodingException uue){
      // Fall back to some Java default
      return new String( baos.toByteArray() );
    }   // end catch

  }   // end encode
"	@return The Base64-encoded object	@return The Base64-encoded object	0	1	12	51	337
protected Object convertRowId(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return ByteBuffer.wrap(new byte[0]); } if (data instanceof java.sql.RowId) { java.sql.RowId row = (java.sql.RowId) data; return ByteBuffer.wrap(row.getBytes()); } return handleUnknownData(column, fieldDefn, data); }	"    protected Object convertRowId(Column column, Field fieldDefn, Object data) {
        if (data == null) return null;
        if (data instanceof java.sql.RowId) {
            java.sql.RowId row = (java.sql.RowId) data;
            return ByteBuffer.wrap(row.getBytes());
        }
        return handleUnknownData(column, fieldDefn, data);
    }
"	@return the converted value, or null if the conversion could not be made and the column allows nulls	@return the converted value, or null if the conversion could not be made	1	0	10	15	100
"public String toString() { long millis = getMillis(); StringBuffer buf = new StringBuffer(); buf.append(""PT""); FormatUtils.appendUnpaddedInteger(buf, millis / 1000); long part = Math.abs(millis % 1000); if (part > 0) { buf.append('.'); FormatUtils.appendPaddedInteger(buf, part, 3); } buf.append('S'); return buf.toString(); }"	"    public String toString() {
        return ISOPeriodFormat.getInstance().standard().print(toPeriod());
    }
"	@return the value as an ISO8601 string	@return the value as an ISO8601 string	0	1	7	14	86
public boolean isBoolean() { return raw.equals(STR) || raw.equals(STR); }	"public boolean isBoolean() {
    return arg.equals(STR) || arg.equals(STR);
}"	@return Whether this ChatSection's value can be parsed as a boolean	@return Whether this ChatSection's argument can be parsed as a boolean	1	0	6	3	21
public static <X> BinaryVisitor<X, PrintStream> println() { return new PrintLine<X>(); }	"public static <X> BinaryPredicate<X, PrintStream> println() {
    return new PrintLine<X>();
}"	@return a {@link BinaryVisitor} that will call {@code println(x)} on the {@link java.io.PrintStream} {@code y}	@return a {@link BinaryPredicate} that will call {@code println(x)} on the {@link java.io.PrintStream} {@code y}	1	0	7	3	19
@Override public Class<? extends Service> getInterface() { return PauseTransitService.class; }	"@Override
public Class<? extends Service> getInterface() {
    return BundlePauseStartService.class;
}"	@return {@link PauseTransitService}.	@return {@link BundlePauseStartService}.	1	0	5	4	16
public static EventProcessingFailureHandlingMode parse(String value) { if (value == null) { return null; } value = value.trim(); for (EventProcessingFailureHandlingMode option : EventProcessingFailureHandlingMode.values()) { if (option.getValue().equalsIgnoreCase(value)) { return option; } } return null; }	"        public static Version parse(String value, String defaultValue) {
            Version mode = parse(value);
            if (mode == null && defaultValue != null) {
                mode = parse(defaultValue);
            }
            return mode;
        }
"	@return the matching option, or null if no match is found	@return the matching option, or null if no match is found and the non-null default is invalid	1	0	8	16	57
"public Response processBrokerInfo(BrokerInfo info) { if (info.isSlaveBroker()) { //stream messages from this broker (the master) to //the slave MutableBrokerFilter parent = (MutableBrokerFilter) broker.getAdaptor(MutableBrokerFilter.class); masterBroker = new MasterBroker(parent, transport); masterBroker.startProcessing(); log.info(""Slave Broker "" + info.getBrokerName() + "" is attached""); } // We only expect to get one broker info command per connection if( this.brokerInfo!=null ) { log.warn(""Unexpected extra broker info command received: ""+info); } this.brokerInfo = info; broker.addBroker(this, info); return null; }"	"    public Response processBrokerInfo(BrokerInfo info) {
        if (info.isSlaveBroker()) {
            //stream messages from this broker (the master) to 
            //the slave
            MutableBrokerFilter parent = (MutableBrokerFilter) broker.getAdaptor(MutableBrokerFilter.class);
            masterBroker = new MasterBroker(parent, transport);
            masterBroker.startProcessing();
            log.info(""Slave Broker "" + info.getBrokerName() + "" is attached"");
        }
        return super.processBrokerInfo(info);
    }
"	@return true if the Connection needs to stop	@return true if the Connection needs to stop	0	1	10	20	132
public boolean getExtraBoolean(String key) throws JSONException { return mExtraData.getBoolean(key); }	"public boolean getExtraBoolean(String key) {
    return mExtraData.optBoolean(key);
}"	@return The stored value.	@return The stored value or null if it doesn't exist in specified form.	1	0	5	3	18
"public Tree transformTree(Tree t) { if (VERBOSE) { System.err.println(""Input to CoordinationTransformer: "" + t); } Tree tx = tn.transformTree(t); if (VERBOSE) { System.err.println(""After DependencyTreeTransformer: "" + tx); } if (tx == null) { return tx; } Tree tt = UCPtransform(tx); if (VERBOSE) { System.err.println(""After UCPTransformer: "" + tt); } Tree ttt = CCtransform(tt); if (VERBOSE) { System.err.println(""After CCTransformer: "" + ttt); } Tree tttt = qp.transformTree(ttt); if (VERBOSE) { System.err.println(""After QPTreeTransformer: "" + tttt); } Tree flatSQ = SQflatten(tttt); if (VERBOSE) { System.err.println(""After SQ flattening: "" + flatSQ); } Tree fixedDates = dates.transformTree(flatSQ); if (VERBOSE) { System.err.println(""After DateTreeTransformer: "" + fixedDates); } Tree removedXX = removeXOverX(fixedDates); if (VERBOSE) { System.err.println(""After removeXoverX: "" + removedXX); } Tree conjp = combineConjp(removedXX); if (VERBOSE) { System.err.println(""After combineConjp: "" + conjp); } Tree movedRB = moveRB(conjp); if (VERBOSE) { System.err.println(""After moveRB: "" + movedRB); } Tree changedSbar = changeSbarToPP(movedRB); if (VERBOSE) { System.err.println(""After changeSbarToPP: "" + movedRB); } Tree nowThat = rearrangeNowThat(changedSbar); if (VERBOSE) { System.err.println(""After rearrangeNowThat: "" + nowThat); } return nowThat; }"	"  public Tree transformTree(Tree t) {
    if (VERBOSE) {
      System.err.println(""Input to CoordinationTransformer: "" + t);
    }
    Tree tx = tn.transformTree(t);
    if (VERBOSE) {
      System.err.println(""After DependencyTreeTransformer:  "" + tx);
    }
    if (tx == null) {
      return tx;
    }
    Tree tt = UCPtransform(tx);
    if (VERBOSE) {
      System.err.println(""After UCPTransformer:             "" + tt);
    }
    Tree ttt = CCtransform(tt);
    if (VERBOSE) {
      System.err.println(""After CCTransformer:              "" + ttt);
    }
    Tree tttt = qp.transformTree(ttt);
    if (VERBOSE) {
      System.err.println(""After QPTreeTransformer:          "" + tttt);
    }
    Tree flatSQ = SQflatten(tttt);
    if (VERBOSE) {
      System.err.println(""After SQ flattening:              "" + flatSQ);
    }
    Tree fixedDates = dates.transformTree(flatSQ);
    if (VERBOSE) {
      System.err.println(""After DateTreeTransformer:        "" + fixedDates);
    }
    Tree removedXX = removeXOverX(fixedDates);
    if (VERBOSE) {
      System.err.println(""After removeXoverX:               "" + removedXX);
    }
    Tree conjp = combineConjp(removedXX);
    if (VERBOSE) {
      System.err.println(""After combineConjp:               "" + conjp);
    }
    Tree movedRB = moveRB(conjp);
    if (VERBOSE) {
      System.err.println(""After moveRB:                     "" + movedRB);
    }
    Tree changedSbar = changeSbarToPP(movedRB);
    if (VERBOSE) {
      System.err.println(""After changeSbarToPP:             "" + movedRB);
    }
    return changedSbar;
  }
"	@return t transformed	@return t transformed	0	1	8	54	332
public Iterable<DocumentRequest> getDocumentRequests() { return documentRequests; }	"public Iterable<DocumentRequest> getDocumentRequests() {
    throw new UnsupportedOperationException(STR);
}"	@return a non-null object iterating over no nulls, containing at least one element.	@return a non-null object iterating over no nulls.	1	0	5	3	11
public Complex getComplex() { return get(); }	"public Complex getComplex(final int i) {
    return get(i);
}"	@return item in first position	@return item in given position	1	0	4	3	12
public long getColumnValueCount(SchemaPath column) { ColumnStatistics<?> columnStats = getTableMetadata().getColumnStatistics(column); ColumnStatistics<?> nonInterestingColStats = columnStats == null ? getNonInterestingColumnsMetadata().getColumnStatistics(column) : null; long tableRowCount; if (columnStats != null) { tableRowCount = TableStatisticsKind.ROW_COUNT.getValue(getTableMetadata()); } else if (nonInterestingColStats != null) { tableRowCount = TableStatisticsKind.ROW_COUNT.getValue(getNonInterestingColumnsMetadata()); columnStats = nonInterestingColStats; } else if (hasNestedStatsForColumn(column, getTableMetadata()) || hasNestedStatsForColumn(column, getNonInterestingColumnsMetadata())) { // When statistics for nested field exists, this is complex column which is present in table. // But its nested fields statistics can't be used to extract tableRowCount for this column. // So NO_COLUMN_STATS returned here to avoid problems described in DRILL-7491. return Statistic.NO_COLUMN_STATS; } else { return 0; // returns 0 if the column doesn't exist in the table. } Long nulls = ColumnStatisticsKind.NULLS_COUNT.getFrom(columnStats); if (nulls == null || Statistic.NO_COLUMN_STATS == nulls || Statistic.NO_COLUMN_STATS == tableRowCount) { return Statistic.NO_COLUMN_STATS; } else { return tableRowCount - nulls; } }	"  public long getColumnValueCount(SchemaPath column) {
    long tableRowCount, colNulls;
    Long nulls;
    ColumnStatistics<?> columnStats = getTableMetadata().getColumnStatistics(column);
    ColumnStatistics<?> nonInterestingColStats = null;
    if (columnStats == null) {
      nonInterestingColStats = getNonInterestingColumnsMetadata().getColumnStatistics(column);
    }

    if (columnStats != null) {
      tableRowCount = TableStatisticsKind.ROW_COUNT.getValue(getTableMetadata());
    } else if (nonInterestingColStats != null) {
      tableRowCount = TableStatisticsKind.ROW_COUNT.getValue(getNonInterestingColumnsMetadata());
    } else {
      return 0; // returns 0 if the column doesn't exist in the table.
    }

    columnStats = columnStats != null ? columnStats : nonInterestingColStats;
    nulls = ColumnStatisticsKind.NULLS_COUNT.getFrom(columnStats);
    colNulls = nulls != null ? nulls : Statistic.NO_COLUMN_STATS;

    return Statistic.NO_COLUMN_STATS == tableRowCount
            || Statistic.NO_COLUMN_STATS == colNulls
            ? Statistic.NO_COLUMN_STATS : tableRowCount - colNulls;
  }
"	@return column value count	@return column value count	0	1	9	29	215
"public Client build(String name) { if ((environment == null) && (executorService == null) && (objectMapper == null)) { throw new IllegalStateException(""Must have either an environment or both "" + ""an executor service and an object mapper""); } if (environment == null) { return build(executorService, objectMapper, validator, name); } return build(environment.getLifecycleEnvironment() .executorService(""jersey-client-"" + name + ""-%d"") .minThreads(configuration.getMinThreads()) .maxThreads(configuration.getMaxThreads()) .build(), environment.getObjectMapper(), environment.getValidator(), name); }"	"    public Client build(String name) {
        if ((environment == null) && (executorService == null) && (objectMapper == null)) {
            throw new IllegalStateException(""Must have either an environment or both "" +
                                                    ""an executor service and an object mapper"");
        }

        if (environment == null) {
            return build(executorService, objectMapper, validator, name);
        }

        return build(environment.getLifecycleEnvironment()
                                .managedExecutorService(""jersey-client-%d"",
                                                        configuration.getMinThreads(),
                                                        configuration.getMaxThreads(),
                                                        60,
                                                        TimeUnit.SECONDS),
                     environment.getObjectMapper(),
                     environment.getValidator(),
                     name);
    }
"	@return a fully-configured  Client	@return a fully-configured Client	0	1	9	20	129
public EString substring(int beginIndex, int endIndex) { return OString.create(Ops.SUBSTR_2ARGS, this, ENumber.create(beginIndex), ENumber.create(endIndex)); }	"    public EString substring(int beginIndex, int endIndex) {
        return new OString(Ops.SUBSTR_2ARGS, this, ENumber.create(beginIndex), ENumber.create(endIndex));
    }
"	@return this.substring(beginIndex, endIndex)	@return this.substring(beginIndex, endIndex)	0	1	6	4	34
public Order placeOrder(Order order) throws ApiException { return placeOrderWithHttpInfo(order).getData(); }	"  public Order placeOrder(Order body) throws ApiException {
    return placeOrderWithHttpInfo(body).getData();
      }
"	@return Order	@return Order	0	1	5	4	20
public String getKDCList(String realm) throws KrbException { if (realm == null) { realm = getDefaultRealm(); } Exception cause = null; String kdcs = getDefault(STR, realm); if (kdcs == null) { kdcs = java.security.AccessController.doPrivileged(new java.security.PrivilegedAction<String>() { @Override public String run() { String osname = System.getProperty(STR); if (osname.startsWith(STR)) { String logonServer = System.getenv(STR); if (logonServer != null && logonServer.startsWith(STR)) { logonServer = logonServer.substring(NUM); } return logonServer; } return null; } }); } if (kdcs == null) { KrbException ke = new KrbException(STR); if (cause != null) { ke.initCause(cause); } throw ke; } return kdcs; }	"public String getKDCList(String realm) {
    if (realm == null) {
        realm = getDefaultRealm();
    }
    String kdcs = getDefault(STR, realm);
    if (kdcs == null) {
        return null;
    }
    return kdcs;
}"	@return the list of KDCs separated by a space, always non null	@return the list of KDCs	1	0	17	32	158
public Integer getHttpDaemonPort() { return port; }	"public int getHttpDaemonPort() {
    return port;
}"	@return an integer with a value greater than 0, or null if undefined.	@return a value greater than 0.	1	0	4	3	10
"public Index parseAndUpdateIndex(Set<String> mappingFileNames, Index annotationIndex) { ClassLoaderService classLoaderService = meta.getServiceRegistry().getService( ClassLoaderService.class ); Set<InputStream> mappingStreams = new HashSet<InputStream>(); for ( String fileName : mappingFileNames ) { EntityMappings entityMappings; try { entityMappings = XmlHelper.unmarshallXml( fileName, ORM2_MAPPING_XSD, EntityMappings.class, classLoaderService ).getRoot(); } catch ( JAXBException orm2Exception ) { // if we cannot parse against orm_2_0.xsd we try orm_1_0.xsd for backwards compatibility try { entityMappings = XmlHelper.unmarshallXml( fileName, ORM1_MAPPING_XSD, EntityMappings.class, classLoaderService ).getRoot(); } catch ( JAXBException orm1Exception ) { throw new AnnotationException( ""Unable to parse xml configuration."", orm1Exception ); } } entityMappings.toString(); } return null; }"	"	public Index parseAndUpdateIndex(List<JaxbRoot<XMLEntityMappings>> mappings, Index annotationIndex) {
		List<XMLEntityMappings> list = new ArrayList<XMLEntityMappings>( mappings.size() );
		for ( JaxbRoot<XMLEntityMappings> jaxbRoot : mappings ) {
			list.add( jaxbRoot.getRoot() );
		}
		return new EntityMappingsMocker(
				list, annotationIndex, meta.getServiceRegistry()
		).mockNewIndex();
	}
"	@return a new updated annotation index, enhancing and modifying the existing ones according to the jpa xml rules	@return a new updated annotation index, enhancing and modifying the existing ones according to the jpa xml rules	0	1	12	29	139
public boolean isMirrored() { if (!fMirroringEnabled) return false; Object property = getProperty(MIRRORED); return property instanceof Boolean && (Boolean) property; }	"public boolean isMirrored() {
    Object property = getProperty(MIRRORED);
    return property instanceof Boolean && (Boolean) property;
}"	@return true if the compare viewer is mirrored. By default the Compare viewer is not mirrored.	@return true if the left and right side of the viewer are mirrored. Default is false.	1	0	6	6	33
"static boolean implementsMethod(TypeElement clazz, MethodSpec method, Types typeUtils) { ExecutableElement methodOnClass = getMethodOnClass(clazz, method, typeUtils); if (methodOnClass == null) { return false; } Element implementingClass = methodOnClass.getEnclosingElement(); if (implementingClass.getSimpleName().toString().equals(""Object"")) { // Don't count default implementations on Object class return false; } Set<Modifier> modifiers = methodOnClass.getModifiers(); return !modifiers.contains(Modifier.ABSTRACT); }"	"  static boolean implementsMethod(TypeElement clazz, MethodSpec method, Types typeUtils) {
    ExecutableElement methodOnClass = getMethodOnClass(clazz, method, typeUtils);

    if (methodOnClass == null) {
      return false;
    }

    Set<Modifier> modifiers = methodOnClass.getModifiers();
    return !modifiers.contains(Modifier.ABSTRACT);
  }
"	@return True if the clazz (or one of its superclasses except for Object) implements the given method. Returns false if the method doesn't exist anywhere in the class hierarchy or it is abstract.	@return True if the clazz (or one of its superclasses) implements the given method. Returns false if the method doesn't exist anywhere in the class hierarchy or it is abstract.	1	0	6	16	92
long insertOpenCell(double latitude, double longitude, int mcc, int mnc, int lac, int cellID, int avgSigStr, int range, int samples, int isGPSexact, String RAT) { ContentValues cellIDValues = new ContentValues(); cellIDValues.put(STR, latitude); cellIDValues.put(STR, longitude); cellIDValues.put(STR, mcc); cellIDValues.put(STR, mnc); cellIDValues.put(STR, lac); cellIDValues.put(STR, cellID); cellIDValues.put(STR, avgSigStr); cellIDValues.put(STR, range); cellIDValues.put(STR, samples); cellIDValues.put(STR, isGPSexact); cellIDValues.put(STR, RAT); if (openCellExists(cellID)) { Log.v(TAG, mTAG + STR + cellID); return NUM; } else { return mDb.insert(OPENCELLID_TABLE, null, cellIDValues); } }	"long insertOpenCell(double latitude, double longitude, int mcc, int mnc, int lac, int cellID, int avgSigStr, int range, int samples, int isGPSexact, String RAT) {
    ContentValues cellIDValues = new ContentValues();
    cellIDValues.put(STR, latitude);
    cellIDValues.put(STR, longitude);
    cellIDValues.put(STR, mcc);
    cellIDValues.put(STR, mnc);
    cellIDValues.put(STR, lac);
    cellIDValues.put(STR, cellID);
    cellIDValues.put(STR, avgSigStr);
    cellIDValues.put(STR, range);
    cellIDValues.put(STR, samples);
    cellIDValues.put(STR, isGPSexact);
    cellIDValues.put(STR, RAT);
    if (openCellExists(cellID)) {
        Log.v(TAG, STR + cellID);
        return NUM;
    } else {
        return mDb.insert(OPENCELLID_TABLE, null, cellIDValues);
    }
}"	@return row id or -1 if error	@return row id or -1 if error TODO: Is this where CSV data is populating the opencellid table?	1	0	9	20	171
public Long getCountOfTheWords(String studySetName) { return (Long) EM.createQuery(STR).setParameter(STR, studySetName).getSingleResult(); }	"public Long getCountOfTheWords() {
    return (Long) EM.createQuery(STR).getSingleResult();
}"	@return current number of words for study from respective study set	@return current number of words for study	1	0	7	3	28
public String loginUser(String username, String password) throws ApiException { return loginUserWithHttpInfo(username, password).getData(); }	"  public String loginUser(String username, String password) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'username' is set
    if (username == null) {
      throw new ApiException(400, ""Missing the required parameter 'username' when calling loginUser"");
    }
    
    // verify the required parameter 'password' is set
    if (password == null) {
      throw new ApiException(400, ""Missing the required parameter 'password' when calling loginUser"");
    }
    
    // create path and map variables
    String localVarPath = ""/user/login"";

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPairs("""", ""username"", username));
    localVarQueryParams.addAll(apiClient.parameterToPairs("""", ""password"", password));

    
    
    final String[] localVarAccepts = {
      ""application/xml"", ""application/json""
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    GenericType<String> localVarReturnType = new GenericType<String>() {};
    return apiClient.invokeAPI(localVarPath, ""GET"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);
      }
"	@return String	@return String	0	1	5	4	25
public BuildResult getPreviousResult() { ResultAction<? extends BuildResult> action = getPreviousAction(); if (action != null) { return action.getResult(); } throw new NoSuchElementException(STR); }	"public BuildResult getPreviousResult() {
    return getPreviousAction().getResult();
}"	@return the previous build result	@return the action of the previous build, or <code>null</code> if no such build exists	1	0	6	7	37
public String getConnectedServer(AccessToken accessToken, String node) { AgentMgtDao agentMgtDao = new AgentMgtDao(); return agentMgtDao.getConnectedServer(accessToken.getId(), node); }	"public String getConnectedServer(AccessToken accessToken) {
    AgentMgtDao agentMgtDao = new AgentMgtDao();
    return agentMgtDao.getConnectedServer(accessToken.getId());
}"	@returnConnected Server Hostname / IP	@return Connected Node	1	0	6	4	31
public static String export() { RequestLog current = RLOG.get(); record(new Durations(current.aggregateDurations())); record(new Threads(current.threadIds)); return LogFormatterProvider.getInstance().format(current.info); }	"public static String export() {
    RequestLog current = RLOG.get();
    record(new Durations(current.aggregateDurations()));
    record(new Threads(current.threadIds));
    try {
        return current.mapper.writeValueAsString(current.info);
    } catch (JsonProcessingException jpe) {
        String msg = String.format(STR, current.logId);
        LOG.warn(msg, jpe);
        return msg;
    }
}"	@return log object as a formatted string	@return log object as a JSON formatted string	1	0	6	6	48
public Boolean apply(WebDriver webDriver) { return elements.stream().allMatch(ExpectedConditions::isInvisible); }	"      public Boolean apply(WebDriver webDriver) {
        for (WebElement element : elements) {
          try {
            if (element.isDisplayed()) {
              return false;
            }
          } catch (StaleElementReferenceException ignored) {
            // We can assume a stale element isn't displayed.
          }
        }
        return true;
      }
"	@return Boolean true when all elements are not visible anymore	@return Boolean true when all elements are not visible anymore	0	1	7	4	22
private static Gobbling gobble(Treepath<SyntacticTree> gobbleStart, int indentation) { Preconditions.checkArgument(gobbleStart.getTreeAtEnd().isOneOf(_PLACEHOLDER_)); Treepath<SyntacticTree> start = gobbleStart; do { if (TreepathTools.hasNextSibling(start)) { final Treepath<SyntacticTree> next = TreepathTools.getNextSibling(start); if (isRawItem(next)) { final Treepath<SyntacticTree> minusNext = TreepathTools.removeNextSibling(start); return new Gobbling(minusNext, makeEmbeddedListItem(next), indentation); } else { final SyntacticTree nextTree = next.getTreeAtEnd(); if (nextTree.isOneOf(WHITESPACE_, LINE_BREAK_)) { start = TreepathTools.removeNextSibling(start); if (nextTree.isOneOf(WHITESPACE_)) { indentation = getWhitespaceLength(next); } continue; } } } return new Gobbling(start); } while (true); }	"private static Gobbling gobble(Treepath<SyntacticTree> gobbleStart) {
    if (null == gobbleStart) {
        return null;
    }
    Preconditions.checkArgument(gobbleStart.getTreeAtEnd().isOneOf(_PLACEHOLDER_));
    gobbleStart = TreepathTools.getNextSibling(gobbleStart);
    do {
        if (isRawItem(gobbleStart)) {
            if (TreepathTools.hasNextSibling(gobbleStart)) {
                final Treepath<SyntacticTree> nextStart = TreepathTools.getNextSibling(gobbleStart);
                final Treepath<SyntacticTree> nextStartMinusPrevious = TreepathTools.removePreviousSibling(nextStart);
                return new Gobbling(nextStartMinusPrevious, makeEmbeddedListItem(gobbleStart), true);
            } else {
                final Treepath<SyntacticTree> minusPrevious = TreepathTools.removeEnd(gobbleStart);
                return new Gobbling(minusPrevious, makeEmbeddedListItem(gobbleStart), false);
            }
        } else if (gobbleStart.getTreeAtEnd().isOneOf(WHITESPACE_, LINE_BREAK_)) {
            if (TreepathTools.hasNextSibling(gobbleStart)) {
                gobbleStart = TreepathTools.getNextSibling(gobbleStart);
            }
        } else {
            return null;
        }
    } while (true);
}"	@return a {@code Gobbling} object containing the result of the gobble.	@return null if {@code gobbleStart} was null, or a {@code Gobbling} object containing the result of the gobble. {@code Gobbling#treepathMinusGobbled} still refers to the _PLACEHOLDER_ but some separators and one raw item have been removed. {@code Gobbling#gobbledTree} is the result of the gobbling	1	0	16	23	148
public String getId() { if (sid != null && !sid.isEmpty() && !sid.equals(SID_DEFAULT_VAL)) { return sid; } else if (dataCenterInfo instanceof UniqueIdentifier) { return ((UniqueIdentifier) dataCenterInfo).getId(); } else { return hostName; } }	"    public String getId() {
        if (instanceId != null && !instanceId.isEmpty()) {
            return instanceId;
        } else if (dataCenterInfo instanceof UniqueIdentifier) {
            return ((UniqueIdentifier) dataCenterInfo).getId();
        } else {
            return hostName;
        }
    }
"	@return the unique id.	@return the unique id.	0	1	8	10	59
Node getAssignedValue() { return (parent.getType() == Token.FUNCTION) ? parent : NodeUtil.getAssignedValue(getNameNode()); }	"Node getAssignedValue() {
    return NodeUtil.getAssignedValue(getNameNode());
}"	@return For an assignment, variable declaration, or function declaration return the assigned value, otherwise null.	@return For an assignment or variable declaration return the assigned value, otherwise null.	1	0	6	3	26
public int get(DateTimeFieldType type) { return getValue(indexOfSupported(type)); }	"    public int get(DateTimeFieldType type) {
        for (int i = 0, isize = size(); i < isize; i++) {
            if (getFieldType(i) == type) {
                return getValue(i);
            }
        }
        throw new IllegalArgumentException(""Field '"" + type + ""' is not supported"");
    }
"	@return the value of that field	@return the value of that field	0	1	6	4	18
public AnimationBuilder animateScaleAndCenter(float scale, PointF sCenter) { if (!isImageReady()) { return null; } return new AnimationBuilder(scale, sCenter); }	"public ScaleAnimationBuilder animateScaleAndCenter(float scale, PointF sCenter) {
    if (!isImageReady()) {
        return null;
    }
    return new ScaleAnimationBuilder(scale, sCenter);
}"	@return {@link AnimationBuilder} instance. Call {@link com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView.AnimationBuilder#start()} to start the anim.	@return {@link ScaleAnimationBuilder} instance. Call {@link com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView.ScaleAnimationBuilder#start()} to start the anim.	1	0	6	6	33
private ASN1Object toASN1Object(X509Certificate cert) throws CertificateEncodingException { try { return new ASN1InputStream(cert.getEncoded()).readObject(); } catch (Exception e) { throw new CertificateEncodingException(STR + e.toString()); } }	"private DERObject toASN1Object(X509Certificate cert) throws CertificateEncodingException {
    try {
        return new ASN1InputStream(cert.getEncoded()).readObject();
    } catch (Exception e) {
        throw new CertificateEncodingException(STR + e.toString());
    }
}"	@return the ASN1Object	@return the DERObject	1	0	8	7	46
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 38: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, yytext()); } case 55: break; case 43: // general lookahead, find correct zzMarkedPos { int zzFState = 9; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 10; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { // try to work around an apparent jflex bug where it // gets a space at the token end by getting // wrong the length of the trailing context. while (yylength() > 0) { char last = yycharat(yylength()-1); if (last == ' ' || last == '\t' || (last >= '\n' && last <= '\r' || last == '\u0085')) { yypushback(1); } else { break; } } return getNext(); } case 56: break; case 11: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 57: break; case 19: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 58: break; case 8: { return handleQuotes(yytext(), false); } case 59: break; case 35: // lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), false); } case 60: break; case 27: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 61: break; case 33: // lookahead expression with fixed lookahead length yypushback(1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 62: break; case 49: // lookahead expression with fixed lookahead length yypushback(1); { return getNormalizedAmpNext(); } case 63: break; case 36: { return getNormalizedAmpNext(); } case 64: break; case 23: { if (invertible) { prevWordAfter.append(yytext()); } } case 65: break; case 37: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, yytext()); } case 66: break; case 53: // lookahead expression with fixed lookahead length yypushback(4); { return getNext(); } case 67: break; case 46: // lookahead expression with fixed lookahead length yypushback(2); { return getNext(); } case 68: break; case 42: // general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 69: break; case 41: // general lookahead, find correct zzMarkedPos { int zzFState = 16; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 17; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 70: break; case 40: // general lookahead, find correct zzMarkedPos { int zzFState = 13; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 71: break; case 3: { return getNext(); } case 72: break; case 24: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(); } case 73: break; case 51: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } return getNext(txt, yytext()); } case 74: break; case 26: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, origTxt); } case 75: break; case 6: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 76: break; case 29: // general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 77: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 78: break; case 2: { return getNext(""<"", yytext()); } case 79: break; case 48: { yypushback(2) ; return getNext(); } case 80: break; case 30: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 81: break; case 18: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 82: break; case 54: { String txt = yytext(); if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 83: break; case 50: { yypushback(3) ; return getNext(); } case 84: break; case 25: // lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), true); } case 85: break; case 39: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 86: break; case 21: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 87: break; case 17: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 88: break; case 13: { return handleEllipsis(yytext()); } case 89: break; case 34: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 1; { /* invert quote - often but not always right */ return handleQuotes(yytext(), true); } case 90: break; case 14: { return normalizeFractions(yytext()); } case 91: break; case 15: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(); } } case 92: break; case 47: // general lookahead, find correct zzMarkedPos { int zzFState = 11; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 12; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 93: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 94: break; case 9: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 95: break; case 45: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 96: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 97: break; case 28: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 98: break; case 20: { if (normalizeOtherBrackets) { return getNext(""-RSB-"", yytext()); } else { return getNext(); } } case 99: break; case 12: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 100: break; case 31: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 101: break; case 10: { return getNext("">"", yytext()); } case 102: break; case 32: { // this one should only match if we're basically at the end of file // since the last one matches two things, even newlines String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 103: break; case 22: { if (normalizeOtherBrackets) { return getNext(""-LSB-"", yytext()); } else { return getNext(); } } case 104: break; case 52: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { // try to work around an apparent jflex bug where it // gets a space at the token end by getting // wrong the length of the trailing context. while (yylength() > 0) { char last = yycharat(yylength()-1); if (last == ' ' || last == '\t' || (last >= '\n' && last <= '\r' || last == '\u0085')) { yypushback(1); } else { break; } } String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 105: break; case 1: { String str = yytext(); int first = str.charAt(0); String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } LOGGER.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: LOGGER.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 106: break; case 44: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 107: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 108: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }"	"  public Object next() throws java.io.IOException {
    int zzInput;
    int zzAction;

    // cached fields:
    int zzCurrentPosL;
    int zzMarkedPosL;
    int zzEndReadL = zzEndRead;
    char [] zzBufferL = zzBuffer;
    char [] zzCMapL = ZZ_CMAP;

    int [] zzTransL = ZZ_TRANS;
    int [] zzRowMapL = ZZ_ROWMAP;
    int [] zzAttrL = ZZ_ATTRIBUTE;

    while (true) {
      zzMarkedPosL = zzMarkedPos;

      yychar+= zzMarkedPosL-zzStartRead;

      zzAction = -1;

      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
  
      zzState = ZZ_LEXSTATE[zzLexicalState];


      zzForAction: {
        while (true) {
    
          if (zzCurrentPosL < zzEndReadL)
            zzInput = zzBufferL[zzCurrentPosL++];
          else if (zzAtEOF) {
            zzInput = YYEOF;
            break zzForAction;
          }
          else {
            // store back cached positions
            zzCurrentPos  = zzCurrentPosL;
            zzMarkedPos   = zzMarkedPosL;
            boolean eof = zzRefill();
            // get translated positions and possibly new buffer
            zzCurrentPosL  = zzCurrentPos;
            zzMarkedPosL   = zzMarkedPos;
            zzBufferL      = zzBuffer;
            zzEndReadL     = zzEndRead;
            if (eof) {
              zzInput = YYEOF;
              break zzForAction;
            }
            else {
              zzInput = zzBufferL[zzCurrentPosL++];
            }
          }
          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
          if (zzNext == -1) break zzForAction;
          zzState = zzNext;

          int zzAttributes = zzAttrL[zzState];
          if ( (zzAttributes & 1) == 1 ) {
            zzAction = zzState;
            zzMarkedPosL = zzCurrentPosL;
            if ( (zzAttributes & 8) == 8 ) break zzForAction;
          }

        }
      }

      // store back cached position
      zzMarkedPos = zzMarkedPosL;

      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
        case 38: 
          { String txt = yytext();
                  if (escapeForwardSlashAsterisk) {
                    txt = delimit(txt, '/');
                  }
                  if (normalizeSpace) {
                    // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                    txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space

                  }
                  return getNext(txt, yytext());
          }
        case 55: break;
        case 43: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 9;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 10;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { // try to work around an apparent jflex bug where it
                          // gets a space at the token end by getting
                          // wrong the length of the trailing context.
                          while (yylength() > 0) {
                            char last = yycharat(yylength()-1);
                            if (last == ' ' || last == '\t' || (last >= '\n' && last <= '\r' || last == '\u0085')) {
                              yypushback(1);
                            } else {
                              break;
                            }
                          }
			  return getNext();
          }
        case 56: break;
        case 11: 
          { if (ptb3Dashes) {
                            return getNext(ptbmdash, yytext()); }
                          else {
                            return getNext();
                          }
          }
        case 57: break;
        case 19: 
          { if (escapeForwardSlashAsterisk) {
                    return getNext(delimit(yytext(), '*'), yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 58: break;
        case 8: 
          { return handleQuotes(yytext(), false);
          }
        case 59: break;
        case 35: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return handleQuotes(yytext(), false);
          }
        case 60: break;
        case 27: 
          { String txt = yytext();
                  String origText = txt;
                  if (normalizeParentheses) {
                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                  }
                  return getNext(txt, origText);
          }
        case 61: break;
        case 33: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { String txt = yytext();
                  String origText = txt;
                  if (normalizeParentheses) {
                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                  }
                  return getNext(txt, origText);
          }
        case 62: break;
        case 48: 
          { if (splitAssimilations) {
                            yypushback(2) ; return getNext();
                          } else {
                            return getNext();
                          }
          }
        case 63: break;
        case 49: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return getNormalizedAmpNext();
          }
        case 64: break;
        case 36: 
          { return getNormalizedAmpNext();
          }
        case 65: break;
        case 23: 
          { if (invertible) {
                            prevWordAfter.append(yytext());
                        }
          }
        case 66: break;
        case 37: 
          { String txt = yytext();
                  if (escapeForwardSlashAsterisk) {
                    txt = delimit(txt, '/');
                  }
                  if (normalizeSpace) {
                    // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                    txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                  }
                  return getNext(txt, yytext());
          }
        case 67: break;
        case 53: 
          // lookahead expression with fixed lookahead length
          yypushback(4);
          { return getNext();
          }
        case 68: break;
        case 46: 
          // lookahead expression with fixed lookahead length
          yypushback(2);
          { return getNext();
          }
        case 69: break;
        case 42: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 15;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 14;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { return getNext();
          }
        case 70: break;
        case 41: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 16;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 17;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { return getNext();
          }
        case 71: break;
        case 40: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 13;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 14;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { return getNext();
          }
        case 72: break;
        case 3: 
          { return getNext();
          }
        case 73: break;
        case 24: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return getNext();
          }
        case 74: break;
        case 51: 
          { String txt = yytext();
                          if (escapeForwardSlashAsterisk) {
                            txt = delimit(txt, '/');
                          }
                          return getNext(txt, yytext());
          }
        case 75: break;
        case 26: 
          { final String origTxt = yytext();
                          String txt = origTxt;
                          if (normalizeSpace) {
                            // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                            txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                          }
                          return getNext(txt, origTxt);
          }
        case 76: break;
        case 6: 
          { final String origTxt = yytext();
                          String tmp = removeSoftHyphens(origTxt);
                          if (americanize) {
                            tmp = Americanize.americanize(tmp);
                          }
                          return getNext(tmp, origTxt);
          }
        case 77: break;
        case 29: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 3;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 4;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { final String origTxt = yytext();
                          String tmp = removeSoftHyphens(origTxt);
                          if (americanize) {
                            tmp = Americanize.americanize(tmp);
                          }
                          return getNext(tmp, origTxt);
          }
        case 78: break;
        case 16: 
          { if (normalizeOtherBrackets) {
                    return getNext(closebrace, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 79: break;
        case 2: 
          { return getNext(""<"", yytext());
          }
        case 80: break;
        case 30: 
          { if (escapeForwardSlashAsterisk) {
                            return getNext(delimit(yytext(), '/'), yytext());
                          } else {
                            return getNext();
                          }
          }
        case 81: break;
        case 18: 
          { if (normalizeParentheses) {
                    return getNext(closeparen, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 82: break;
        case 54: 
          { String txt = yytext();
                          if (normalizeSpace) {
                            // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                            txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                          }
                          if (normalizeParentheses) {
                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                          }
                          return getNext(txt, yytext());
          }
        case 83: break;
        case 25: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return handleQuotes(yytext(), true);
          }
        case 84: break;
        case 39: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 5;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 6;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { final String txt = yytext();
                          return getNext(removeSoftHyphens(txt),
                                         txt);
          }
        case 85: break;
        case 21: 
          { if (normalizeOtherBrackets) {
                    return getNext(openbrace, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 86: break;
        case 50: 
          { if (splitAssimilations) {
                            yypushback(3) ; return getNext();
                          } else {
                            return getNext();
                          }
          }
        case 87: break;
        case 17: 
          { if (normalizeParentheses) {
                    return getNext(openparen, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 88: break;
        case 13: 
          { return handleEllipsis(yytext());
          }
        case 89: break;
        case 34: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 1;
          { /* invert quote - often but not always right */
                  return handleQuotes(yytext(), true);
          }
        case 90: break;
        case 14: 
          { return normalizeFractions(yytext());
          }
        case 91: break;
        case 15: 
          { if (normalizeCurrency) {
                            return getNext(normalizeCurrency(yytext()), yytext()); }
                          else {
                            return getNext();
                          }
          }
        case 92: break;
        case 47: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 11;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 12;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { String s;
                          if (strictTreebank3 && ! ""U.S."".equals(yytext())) {
                            yypushback(1); // return a period for next time
                            s = yytext();
                          } else {
                            s = yytext();
                            yypushback(1); // return a period for next time
                          }
                          return getNext(s, yytext());
          }
        case 93: break;
        case 7: 
          { if (invertible) {
                     prevWordAfter.append(yytext());
                  }
          }
        case 94: break;
        case 9: 
          { if (escapeForwardSlashAsterisk) {
                    return getNext(delimit(yytext(), '/'), yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 95: break;
        case 45: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return getNext(removeSoftHyphens(yytext()),
                                               yytext());
          }
        case 96: break;
        case 4: 
          { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {
                    return getNext(ptbmdash, yytext());
                  } else {
                    return getNext();
                  }
          }
        case 97: break;
        case 28: 
          { return getNext(removeSoftHyphens(yytext()), yytext());
          }
        case 98: break;
        case 20: 
          { if (normalizeOtherBrackets) {
                    return getNext(""-RSB-"", yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 99: break;
        case 12: 
          { return getNext(removeSoftHyphens(yytext()),
                                         yytext());
          }
        case 100: break;
        case 31: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return getNext(removeSoftHyphens(yytext()),
                                         yytext());
          }
        case 101: break;
        case 10: 
          { return getNext("">"", yytext());
          }
        case 102: break;
        case 32: 
          { // this one should only match if we're basically at the end of file
                          // since the last one matches two things, even newlines
                          String s;
                          if (strictTreebank3 && ! ""U.S."".equals(yytext())) {
                            yypushback(1); // return a period for next time
                            s = yytext();
                          } else {
                            s = yytext();
                            yypushback(1); // return a period for next time
                          }
                          return getNext(s, yytext());
          }
        case 103: break;
        case 22: 
          { if (normalizeOtherBrackets) {
                    return getNext(""-LSB-"", yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 104: break;
        case 52: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 7;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 8;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { // try to work around an apparent jflex bug where it
                          // gets a space at the token end by getting
                          // wrong the length of the trailing context.
                          while (yylength() > 0) {
                            char last = yycharat(yylength()-1);
                            if (last == ' ' || last == '\t' || (last >= '\n' && last <= '\r' || last == '\u0085')) {
                              yypushback(1);
                            } else {
                              break;
                            }
                          }
                          String s;
                          if (strictTreebank3 && ! ""U.S."".equals(yytext())) {
                            yypushback(1); // return a period for next time
                            s = yytext();
                          } else {
                            s = yytext();
                            yypushback(1); // return a period for next time
                          }
                          return getNext(s, yytext());
          }
        case 105: break;
        case 1: 
          { String str = yytext();
          int first = str.charAt(0);
          String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));
          switch (untokenizable) {
            case NONE_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              break;
            case FIRST_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              if ( ! this.seenUntokenizableCharacter) {
                LOGGER.warning(msg);
                this.seenUntokenizableCharacter = true;
              }
              break;
            case ALL_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              LOGGER.warning(msg);
              this.seenUntokenizableCharacter = true;
              break;
            case NONE_KEEP:
              return getNext();
            case FIRST_KEEP:
              if ( ! this.seenUntokenizableCharacter) {
                LOGGER.warning(msg);
                this.seenUntokenizableCharacter = true;
              }
              return getNext();
            case ALL_KEEP:
              LOGGER.warning(msg);
              this.seenUntokenizableCharacter = true;
              return getNext();
          }
          }
        case 106: break;
        case 44: 
          { String txt = yytext();
                          if (escapeForwardSlashAsterisk) {
                            txt = delimit(txt, '/');
                            txt = delimit(txt, '*');
                          }
                          return getNext(txt, yytext());
          }
        case 107: break;
        case 5: 
          { if (tokenizeNLs) {
                      return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns
                  } else if (invertible) {
                      prevWordAfter.append(yytext());
                  }
          }
        case 108: break;
        default: 
          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
            zzAtEOF = true;
              {
                if (invertible) {
            prevWordAfter.append(yytext());
            String str = prevWordAfter.toString();
            prevWordAfter.setLength(0);
            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);
          }
          return null;
              }
          } 
          else {
            zzScanError(ZZ_NO_MATCH);
          }
      }
    }
  }
"	@return the next token	@return the next token	0	1	17	698	4291
public static DateTimeFormatter basicOrdinalDateTime() { return Constants.bodt; }	"    public static DateTimeFormatter basicOrdinalDateTime() {
        if (bodt == null) {
            bodt = new DateTimeFormatterBuilder()
                .append(basicOrdinalDate())
                .append(basicTTime())
                .toFormatter();
        }
        return bodt;
    }
"	@return a formatter for yyyyDDD'T'HHmmss.SSSZ	@return a formatter for yyyyDDD'T'HHmmss.SSSZ	0	1	4	4	12
public static Result createGemFireErrorResult(String message) { return createErrorResult(ERRORCODE_GEODE_ERROR, STR + message); }	"public static Result createGemFireErrorResult(String message) {
    return createErrorResult(ERRORCODE_GEMFIRE_ERROR, STR + message);
}"	@return Result for error in Geode while executing command.	@return Result for error in GemFire while executing command.	1	0	6	3	20
public static byte[] sha3omit12(byte[] input) { byte[] hash = sha3(input); byte[] address = copyOfRange(hash, NUM, hash.length); address[NUM] = Wallet.getAddressPreFixByte(); return address; }	"public static byte[] sha3omit12(byte[] input) {
    byte[] hash = sha3(input);
    return copyOfRange(hash, NUM, hash.length);
}"	@return - add_pre_fix + 20 right bytes of the hash keccak of the data	@return - 20 right bytes of the hash keccak of the data	1	0	7	6	49
public BooleanExpression endsWith(Expression<String> str) { return BooleanOperation.create(Ops.ENDS_WITH, mixin, str); }	"    public BooleanExpression endsWith(Expression<String> str) {
        return BooleanOperation.create(Ops.ENDS_WITH, this, str);
    }
"	@return this.endsWith(str)	@return this.endsWith(str)	0	1	6	4	22
@Action(value = STR) public String execute() throws Exception { LOG.info(STR + id); SocialAuthManager manager; if (userSession.get(STR) != null) { manager = (SocialAuthManager) userSession.get(STR); if (STR.equals(mode)) { manager.disconnectProvider(id); return STR; } } else { InputStream in = SocialAuthenticationAction.class.getClassLoader().getResourceAsStream(STR); SocialAuthConfig conf = SocialAuthConfig.getDefault(); conf.load(in); manager = new SocialAuthManager(); manager.setSocialAuthConfig(conf); userSession.put(STR, manager); } String returnToUrl = RequestUtils.getServletPath(request); System.out.println(returnToUrl); returnToUrl = UrlHelper.buildUrl(STR, request, response, null, null, true, true, true); url = manager.getAuthenticationUrl(id, returnToUrl); LOG.info(STR + url); if (url != null) { return STR; } return STR; }	"@Override
public ActionForward execute(final ActionMapping mapping, final ActionForm form, final HttpServletRequest request, final HttpServletResponse response) throws Exception {
    AuthForm authForm = (AuthForm) form;
    String id = authForm.getId();
    SocialAuthManager manager;
    if (authForm.getSocialAuthManager() != null) {
        manager = authForm.getSocialAuthManager();
        if (STR.equals(request.getParameter(STR))) {
            manager.disconnectProvider(id);
            return mapping.findForward(STR);
        }
    } else {
        InputStream in = SocialAuthenticationAction.class.getClassLoader().getResourceAsStream(STR);
        SocialAuthConfig conf = SocialAuthConfig.getDefault();
        conf.load(in);
        manager = new SocialAuthManager();
        manager.setSocialAuthConfig(conf);
        authForm.setSocialAuthManager(manager);
    }
    String returnToUrl = RequestUtils.absoluteURL(request, STR).toString();
    String url = manager.getAuthenticationUrl(id, returnToUrl);
    LOG.info(STR + url);
    if (url != null) {
        ActionForward fwd = new ActionForward(STR, url, true);
        return fwd;
    }
    return mapping.findForward(STR);
}"	@return String where the action should flow	@return ActionForward where the action should flow	1	0	9	28	182
"public Connection manualDisconnect() { if ( ! isLogicallyConnected() ) { throw new IllegalStateException( ""cannot manually disconnect because not logically connected."" ); } batcher.closeStatements(); return connection.manualDisconnect(); }"	"	public Connection manualDisconnect() {
		return cleanup();
	}
"	@return The connection mantained here at time of disconnect. Null if there was no connection cached internally.	@return The connection mantained here at time of disconnect. Null if there was no connection cached internally.	0	1	7	8	42
@Processor @OAuthProtected @OAuthInvalidateAccessTokenOn(exception = OAuthTokenExpiredException.class) @Paged public PagingDelegate<CalendarList> getCalendarList(@Optional @Default(STR) final boolean showHidden, final PagingConfiguration pagingConfiguration) throws IOException { return new TokenBasedPagingDelegate<CalendarList>() { @Override public List<CalendarList> doGetPage() throws IOException { com.google.api.services.calendar.Calendar.CalendarList.List calendars = client.calendarList().list(); com.google.api.services.calendar.model.CalendarList list = calendars.setMaxResults(pagingConfiguration.getFetchSize()).setPageToken(this.getPageToken()).setShowHidden(showHidden).execute(); setPageToken(list.getNextPageToken()); return CalendarList.valueOf(list.getItems(), CalendarList.class); } }; }	"@Processor
@Inject
@OAuthProtected
@OAuthInvalidateAccessTokenOn(exception = OAuthTokenExpiredException.class)
public List<CalendarList> getCalendarList(MuleMessage message, @Optional @Default(STR) int maxResults, @Optional String pageToken, @Optional @Default(STR) boolean showHidden) throws IOException {
    com.google.api.services.calendar.Calendar.CalendarList.List calendars = this.client.calendarList().list();
    com.google.api.services.calendar.model.CalendarList list = calendars.setMaxResults(maxResults).setPageToken(pageToken).setShowHidden(showHidden).execute();
    this.saveNextPageToken(list, message);
    return CalendarList.valueOf(list.getItems(), CalendarList.class);
}"	@return a paginated iterator with instances of {@link org.mule.module.google.calendar.model.CalendarList}	@return a list with instances of {@link org.mule.module.google.calendar.model.CalendarList}	1	0	14	16	127
public final DBCompareColExpr in(Collection<?> values) { if (values == null || values.isEmpty()) return cmp(DBCmpType.EQUAL, null); return cmp(DBCmpType.IN, values); }	"public DBCompareColExpr in(Object value) {
    return cmp(DBCmpType.IN, listToArray(value));
}"	"@return a DBCompareColExpr for the ""in"" operator"	@return the new DBCompareColExpr object	1	0	6	5	40
@Processor public Customer getCustomer(final String resourceUri) { return getClientProvider().getClient(Customer.class).getByResourceUri(resourceUri); }	"@Processor
public Customer getCustomer(final String id) {
    return getClientProvider().getClient(Customer.class).getById(id);
}"	@return the customer with the given resourceUri, or null if it doesn't exist	@return the customer with the given id, or null if it doesn't exist	1	0	7	4	26
public long set(long instant, int month) { Utils.verifyValueBounds(this, month, MIN, MAX); // int thisYear = iChronology.year().get(instant); // int thisDom = iChronology.getDayOfMonth(instant, thisYear); int maxDom = iChronology.getDaysInYearMonth(thisYear, month); if (thisDom > maxDom) { // Quietly force DOM to nearest sane value. thisDom = maxDom; } // Return newly calculated millis value return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) + iChronology.millisOfDay().get(instant); }	"    public long set(long millis, int month) {
        super.verifyValueBounds(month, MIN, MAX);
        //
        int thisYear = iChronology.year().get(millis);
        //
        int thisDom = iChronology.getDayOfMonth(millis, thisYear);
        int maxDom = iChronology.getDaysInYearMonth(thisYear, month);
        if (thisDom > maxDom) {
            // Quietly force DOM to nearest sane value.
            thisDom = maxDom;
        }
        // Return newly calculated millis value
        return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +
            iChronology.millisOfDay().get(millis);
    }
"	@return the updated time instant.	@return the updated time instant.	0	1	7	16	105
"public static String getSqlTypeName(final MajorType type) { if (type.getMode() == DataMode.REPEATED || type.getMinorType() == MinorType.LIST) { return ""ARRAY""; } switch (type.getMinorType()) { // Standard SQL atomic data types: case BIT: return ""BOOLEAN""; case SMALLINT: return ""SMALLINT""; case INT: return ""INTEGER""; case BIGINT: return ""BIGINT""; case FLOAT4: return ""FLOAT""; case FLOAT8: return ""DOUBLE""; case DECIMAL9: case DECIMAL18: case DECIMAL28DENSE: case DECIMAL28SPARSE: case DECIMAL38DENSE: case DECIMAL38SPARSE: return ""DECIMAL""; case VARCHAR: return ""CHARACTER VARYING""; case FIXEDCHAR: return ""CHARACTER""; case VAR16CHAR: return ""NATIONAL CHARACTER VARYING""; case FIXED16CHAR: return ""NATIONAL CHARACTER""; case VARBINARY: return ""BINARY VARYING""; case FIXEDBINARY: return ""BINARY""; case DATE: return ""DATE""; case TIME: return ""TIME""; case TIMETZ: return ""TIME WITH TIME ZONE""; case TIMESTAMP: return ""TIMESTAMP""; case TIMESTAMPTZ: return ""TIMESTAMP WITH TIME ZONE""; case INTERVALYEAR: return ""INTERVAL YEAR TO MONTH""; case INTERVALDAY: return ""INTERVAL DAY TO SECOND""; // Non-standard SQL atomic data types: case INTERVAL: return ""INTERVAL""; case MONEY: return ""DECIMAL""; case TINYINT: return ""TINYINT""; // Composite types and other types that are not atomic types (SQL standard // or not) except ARRAY types (handled above): case MAP: return ""MAP""; case LATE: return ""ANY""; case NULL: return ""NULL""; case UNION: return ""UNION""; case GENERIC_OBJECT: return ""JAVA_OBJECT""; // Internal types not actually used at level of SQL types(?): case UINT1: return ""TINYINT""; case UINT2: return ""SMALLINT""; case UINT4: return ""INTEGER""; case UINT8: return ""BIGINT""; default: throw new AssertionError( ""Unexpected/unhandled MinorType value "" + type.getMinorType() ); } }"	"  public static String getSqlTypeName(final MajorType type) {
    if (type.getMode() == DataMode.REPEATED || type.getMinorType() == MinorType.LIST) {
      return ""ARRAY"";
    }

    switch (type.getMinorType()) {

      // Standard SQL atomic data types:

      case BIT:             return ""BOOLEAN"";

      case SMALLINT:        return ""SMALLINT"";
      case INT:             return ""INTEGER"";
      case BIGINT:          return ""BIGINT"";

      case FLOAT4:          return ""FLOAT"";
      case FLOAT8:          return ""DOUBLE"";

      case DECIMAL9:
      case DECIMAL18:
      case DECIMAL28DENSE:
      case DECIMAL28SPARSE:
      case DECIMAL38DENSE:
      case DECIMAL38SPARSE: return ""DECIMAL"";

      case VARCHAR:         return ""CHARACTER VARYING"";
      case FIXEDCHAR:       return ""CHARACTER"";

      case VAR16CHAR:       return ""NATIONAL CHARACTER VARYING"";
      case FIXED16CHAR:     return ""NATIONAL CHARACTER"";

      case VARBINARY:       return ""BINARY VARYING"";
      case FIXEDBINARY:     return ""BINARY"";

      case DATE:            return ""DATE"";
      case TIME:            return ""TIME"";
      case TIMETZ:          return ""TIME WITH TIME ZONE"";
      case TIMESTAMP:       return ""TIMESTAMP"";
      case TIMESTAMPTZ:     return ""TIMESTAMP WITH TIME ZONE"";

      case INTERVALYEAR:    return ""INTERVAL YEAR TO MONTH"";
      case INTERVALDAY:     return ""INTERVAL DAY TO SECOND"";

      // Non-standard SQL atomic data types:

      case INTERVAL:        return ""INTERVAL"";
      case MONEY:           return ""DECIMAL"";
      case TINYINT:         return ""TINYINT"";

      // Composite types and other types that are not atomic types (SQL standard
      // or not) except ARRAY types (handled above):

      case MAP:             return ""MAP"";
      case LATE:            return ""ANY"";
      case NULL:            return ""NULL"";
      case UNION:           return ""UNION"";

      // Internal types not actually used at level of SQL types(?):

      case UINT1:          return ""TINYINT"";
      case UINT2:          return ""SMALLINT"";
      case UINT4:          return ""INTEGER"";
      case UINT8:          return ""BIGINT"";

      default:
        throw new AssertionError(
            ""Unexpected/unhandled MinorType value "" + type.getMinorType() );
    }
  }
"	@return canonical keyword sequence for SQL data type (leading keywords in corresponding  ; what  INFORMATION_SCHEMA.COLUMNS.TYPE_NAME would list)	@return canonical keyword sequence for SQL data type (leading keywords in corresponding ; what INFORMATION_SCHEMA.COLUMNS.TYPE_NAME would list)	0	1	8	71	414
boolean recordRead(int bufferIndex, Node<K, V> node) { final AtomicLong counter = readBufferWriteCount()[bufferIndex]; final long writeCount = counter.get(); final int index = (int) (writeCount & READ_BUFFER_INDEX_MASK); AtomicReference<Node<K, V>> slot = readBuffers()[bufferIndex][index]; if (slot.get() != null) { return false; } else if (slot.compareAndSet(null, node)) { counter.lazySet(writeCount + NUM); } return true; }	"long recordRead(int bufferIndex, Node<K, V> node) {
    final AtomicLong counter = readBufferWriteCount()[bufferIndex];
    final long writeCount = counter.get();
    counter.lazySet(writeCount + NUM);
    final int index = (int) (writeCount & READ_BUFFER_INDEX_MASK);
    readBuffers()[bufferIndex][index].lazySet(node);
    return writeCount;
}"	@return if draining the read buffer can be delayed	@return the number of writes on the chosen read buffer	1	0	9	12	98
public boolean hasOptions() { return !options.isEmpty(); }	"    public boolean hasOptions() {
      return options.size() > 0;
    }
"	@return true if any options are set in this instance.	@return true if any options are set in this instance.	0	1	4	4	14
public static RelNode createFilter(RelNode child, RexNode condition) { return createFilter(child, condition, RelFactories.DEFAULT_FILTER_FACTORY); }	"  public static RelNode createFilter(RelNode child, RexNode condition) {
    return new FilterRel(child.getCluster(), child, condition);
  }
"	@return Relational expression	@return Relational expression	0	1	5	4	24
public ImmutableDFA buildDFA() { if (_cachedInstance == null) { if (initialState != null) { _cachedInstance = new ImmutableDFA(); _cachedInstance.transitions = new HashMap<State, Map<Object, State>>(transitions); _cachedInstance.initialState = initialState; } } return _cachedInstance; }	"public ImmutableDFA buildDFA() {
    ImmutableDFA instance = null;
    if (initialState != null) {
        instance = new ImmutableDFA();
        instance.transitions = new HashMap<State, Map<Object, State>>(transitions);
        instance.initialState = initialState;
    }
    return instance;
}"	@return an instance of ImmutableDFA; null if no valid ImmutableDFA can be created.	@return an instance of ImmutableDFA; null if the builder haven't got enough data to create a valid ImmutableDFA instance.	1	0	14	10	49
public String createSessionId(final String sessionId, final String memcachedId) { if (memcachedId == null) { return sessionId; } final int idx = sessionId.indexOf(STR); if (idx < NUM) { return sessionId + STR + memcachedId; } else { return sessionId.substring(NUM, idx) + STR + memcachedId + sessionId.substring(idx); } }	"public String createSessionId(final String sessionId, final String memcachedId) {
    final int idx = sessionId.indexOf(STR);
    if (idx < NUM) {
        return sessionId + STR + memcachedId;
    } else {
        return sessionId.substring(NUM, idx) + STR + memcachedId + sessionId.substring(idx);
    }
}"	@return the sessionId which now contains the memcachedId if one was provided, otherwise the sessionId unmodified.	@return the sessionId which now contains the memcachedId.	1	0	10	11	69
"private boolean reconcileAndLogDifference(Applications delta, String reconcileHashCode) throws Throwable { logger.warn(""The Reconcile hashcodes do not match, client : {}, server : {}. Getting the full registry"", reconcileHashCode, delta.getAppsHashCode()); long currentGeneration = fetchRegistryGeneration.get(); Applications serverApps = this.fetchRemoteRegistry(false); if (serverApps == null) { logger.error(""The application is null for some reason. Not storing this information""); return false; } if (fetchRegistryGeneration.compareAndSet(currentGeneration, currentGeneration + 1)) { applications.set(serverApps); applicationsDelta.set(serverApps); logger.warn(""The Reconcile hashcodes after complete sync up, client : {}, server : {}."", getApplications().getReconcileHashCode(), delta.getAppsHashCode()); return true; }else { logger.warn(""Not setting the applications map as another thread has advanced the update generation""); return true; // still return true } }"	"    private boolean reconcileAndLogDifference(Applications delta, String reconcileHashCode) throws Throwable {
        logger.warn(""The Reconcile hashcodes do not match, client : {}, server : {}. Getting the full registry"",
                reconcileHashCode, delta.getAppsHashCode());

        Applications serverApps = this.fetchRemoteRegistry(false);
        applications.set(serverApps);
        applicationsDelta.set(serverApps);
        logger.warn(""The Reconcile hashcodes after complete sync up, client : {}, server : {}."",
                getApplications().getReconcileHashCode(),
                delta.getAppsHashCode());
        return true;
    }
"	@return - response	@return - response	0	1	8	25	187
public Set<String> tagSet() { return new HashSet<>(index.objectsList()); }	"  public Set<String> tagSet() {
    return new HashSet<String>(index.objectsList());
  }
"	@return The Set of tags used by this tagger	@return The Set of tags used by this tagger	0	1	5	4	18
public Maps getPostMaps(String id) { return get(id, SEGMENT_MAPS, Maps.class); }	"public MapsJson getPostMaps(String id) {
    return get(id, SEGMENT_MAPS, MapsJson.class);
}"	@return The {@link com.crowdmap.java.sdk.json.Maps} response for the specific post	@return The {@link com.crowdmap.java.sdk.json.MapsJson} response for the specific post	1	0	6	3	20
"private String buildQuery2(String expression) { // ""values (1 < 5)"" // becomes // ""select p0 < p1 from (values (1, 5)) as t(p0, p1)"" SqlNode x; final String sql = ""values ("" + expression + "")""; try { x = parseQuery(sql); } catch (SqlParseException e) { throw new RuntimeException(e); } final Collection<SqlNode> literalSet = new LinkedHashSet<SqlNode>(); x.accept( new SqlShuttle() { private final List<SqlOperator> ops = ImmutableList.<SqlOperator>of( SqlStdOperatorTable.literalChainOperator, SqlStdOperatorTable.localTimeFunc, SqlStdOperatorTable.localTimestampFunc, SqlStdOperatorTable.currentTimeFunc, SqlStdOperatorTable.currentTimestampFunc); @Override public SqlNode visit(SqlLiteral literal) { if (!isNull(literal) && literal.getTypeName() != SqlTypeName.SYMBOL) { literalSet.add(literal); } return literal; } @Override public SqlNode visit(SqlCall call) { final SqlOperator operator = call.getOperator(); if (operator == SqlStdOperatorTable.castFunc && isNull(call.getOperandList().get(0))) { literalSet.add(call); return call; } else if (ops.contains(operator)) { // ""Argument to function 'LOCALTIME' must be a // literal"" return call; } else { return super.visit(call); } } private boolean isNull(SqlNode sqlNode) { return sqlNode instanceof SqlLiteral && ((SqlLiteral) sqlNode).getTypeName() == SqlTypeName.NULL; } }); final List<SqlNode> nodes = new ArrayList<SqlNode>(literalSet); Collections.sort( nodes, new Comparator<SqlNode>() { public int compare(SqlNode o1, SqlNode o2) { final SqlParserPos pos0 = o1.getParserPosition(); final SqlParserPos pos1 = o2.getParserPosition(); int c = -Utilities.compare( pos0.getLineNum(), pos1.getLineNum()); if (c != 0) { return c; } return -Utilities.compare( pos0.getColumnNum(), pos1.getColumnNum()); } }); String sql2 = sql; final List<Pair<String, String>> values = new ArrayList<Pair<String, String>>(); int p = 0; for (SqlNode literal : nodes) { final SqlParserPos pos = literal.getParserPosition(); final int start = SqlParserUtil.lineColToIndex( sql, pos.getLineNum(), pos.getColumnNum()); final int end = SqlParserUtil.lineColToIndex( sql, pos.getEndLineNum(), pos.getEndColumnNum()) + 1; String param = ""p"" + (p++); values.add(Pair.of(sql2.substring(start, end), param)); sql2 = sql2.substring(0, start) + param + sql2.substring(end); } if (values.isEmpty()) { values.add(Pair.of(""1"", ""p0"")); } return ""select "" + sql2.substring(""values ("".length(), sql2.length() - 1) + "" from (values ("" + Util.commaList(Pair.left(values)) + "")) as t("" + Util.commaList(Pair.right(values)) + "")""; }"	"        private String buildQuery2(String expression)
        {
            // ""values (1 < 5)""
            // becomes
            // ""select p0 < p1 from (values (1, 5)) as t(p0, p1)""
            SqlNode x;
            final String sql = ""values ("" + expression + "")"";
            try {
                x = parseQuery(sql);
            } catch (SqlParseException e) {
                throw new RuntimeException(e);
            }
            final Collection<SqlNode> literalSet = new LinkedHashSet<SqlNode>();
            x.accept(
                new SqlShuttle() {
                    private final List<SqlOperator> ops =
                        ImmutableList.<SqlOperator>of(
                            SqlStdOperatorTable.literalChainOperator,
                            SqlStdOperatorTable.localTimeFunc,
                            SqlStdOperatorTable.localTimestampFunc,
                            SqlStdOperatorTable.currentTimeFunc,
                            SqlStdOperatorTable.currentTimestampFunc);

                    @Override
                    public SqlNode visit(SqlLiteral literal) {
                        if (!isNull(literal)
                            && literal.getTypeName() != SqlTypeName.SYMBOL)
                        {
                            literalSet.add(literal);
                        }
                        return literal;
                    }

                    @Override
                    public SqlNode visit(SqlCall call) {
                        final SqlOperator operator = call.getOperator();
                        if (operator == SqlStdOperatorTable.castFunc
                            && isNull(call.getOperandList().get(0)))
                        {
                            literalSet.add(call);
                            return call;
                        } else if (ops.contains(operator)) {
                            // ""Argument to function 'LOCALTIME' must be a
                            // literal""
                            return call;
                        } else {
                            return super.visit(call);
                        }
                    }

                    private boolean isNull(SqlNode sqlNode) {
                        return sqlNode instanceof SqlLiteral
                            && ((SqlLiteral) sqlNode).getTypeName()
                               == SqlTypeName.NULL;
                    }
                });
            final List<SqlNode> nodes = new ArrayList<SqlNode>(literalSet);
            Collections.sort(
                nodes,
                new Comparator<SqlNode>() {
                    public int compare(SqlNode o1, SqlNode o2) {
                        final SqlParserPos pos0 = o1.getParserPosition();
                        final SqlParserPos pos1 = o2.getParserPosition();
                        int c = -Integer.compare(
                            pos0.getLineNum(), pos1.getLineNum());
                        if (c != 0) {
                            return c;
                        }
                        return -Integer.compare(
                            pos0.getColumnNum(), pos1.getColumnNum());
                    }
                });
            String sql2 = sql;
            final List<Pair<String, String>> values =
                new ArrayList<Pair<String, String>>();
            int p = 0;
            for (SqlNode literal : nodes) {
                final SqlParserPos pos = literal.getParserPosition();
                final int start =
                    SqlParserUtil.lineColToIndex(
                        sql, pos.getLineNum(), pos.getColumnNum());
                final int end =
                    SqlParserUtil.lineColToIndex(
                        sql,
                        pos.getEndLineNum(),
                        pos.getEndColumnNum()) + 1;
                String param = ""p"" + (p++);
                values.add(Pair.of(sql2.substring(start, end), param));
                sql2 = sql2.substring(0, start)
                    + param
                    + sql2.substring(end);
            }
            if (values.isEmpty()) {
                values.add(Pair.of(""1"", ""p0""));
            }
            return ""select ""
                   + sql2.substring(""values ("".length(), sql2.length() - 1)
                   + "" from (values (""
                   + Util.commaList(Pair.left(values))
                   + "")) as t(""
                   + Util.commaList(Pair.right(values))
                   + "")"";
        }
"	@return Query that evaluates a scalar expression	@return Query that evaluates a scalar expression	0	1	12	104	598
public ParameterList getQueryStringParams() { try { ParameterList result = new ParameterList(); String queryString = new URL(url).getQuery(); result.addQuerystring(queryString); result.addAll(querystringParams); return result; } catch (MalformedURLException mue) { throw new OAuthException(STR, mue); } }	"public Map<String, String> getQueryStringParams() {
    try {
        Map<String, String> params = new HashMap<String, String>();
        String queryString = new URL(url).getQuery();
        params.putAll(MapUtils.queryStringToMap(queryString));
        params.putAll(this.querystringParams);
        return params;
    } catch (MalformedURLException mue) {
        throw new OAuthException(STR, mue);
    }
}"	@return a {@link ParameterList} containing the query string parameters.	@return a map containing the query string parameters	1	0	7	11	59
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; // set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { String str = yytext(); int first = str.charAt(0); String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } logger.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: logger.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 67: break; case 2: { return getNext(""<"", yytext()); } case 68: break; case 3: { return getNext(); } case 69: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 70: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 71: break; case 6: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 72: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 73: break; case 8: { return handleQuotes(yytext(), false); } case 74: break; case 9: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 75: break; case 10: { return getNext("">"", yytext()); } case 76: break; case 11: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 77: break; case 12: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 78: break; case 13: { return handleEllipsis(yytext()); } case 79: break; case 14: { return normalizeFractions(yytext()); } case 80: break; case 15: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(); } } case 81: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 82: break; case 17: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 83: break; case 18: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 84: break; case 19: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 85: break; case 20: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 86: break; case 21: { if (normalizeOtherBrackets) { return getNext(""-RSB-"", yytext()); } else { return getNext(); } } case 87: break; case 22: { if (normalizeOtherBrackets) { return getNext(""-LSB-"", yytext()); } else { return getNext(); } } case 88: break; case 23: { if (invertible) { prevWordAfter.append(yytext()); } } case 89: break; case 24: { return getNext(""\u2022"", yytext()); } case 90: break; case 25: { return getNext(""\u2122"", yytext()); } case 91: break; case 26: // general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 92: break; case 27: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(); } case 93: break; case 28: // lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), true); } case 94: break; case 29: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 95: break; case 30: { breakByHyphens(yytext()); return getNext(removeSoftHyphens(yytext()), yytext()); } case 96: break; case 31: // general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 97: break; case 32: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 98: break; case 33: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 99: break; case 34: { // this one should only match if we're basically at the end of file // since the last one matches two things, even newlines (if not tokenize per line) String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 100: break; case 35: // lookahead expression with fixed lookahead length yypushback(1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 101: break; case 36: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 1; { /* invert quote - often but not always right */ return handleQuotes(yytext(), true); } case 102: break; case 37: // lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), false); } case 103: break; case 38: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 104: break; case 39: { String txt = yytext(); // if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space... if (strictTreebank3) { int spaceIndex = indexOfSpace(txt); if (spaceIndex >= 0) { yypushback(txt.length() - spaceIndex); String newText = yytext(); return getNext(newText, newText); } } if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, txt); } case 105: break; case 40: { return getNormalizedAmpNext(); } case 106: break; case 41: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, origTxt); } case 107: break; case 42: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space } return getNext(txt, origTxt); } case 108: break; case 43: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 109: break; case 44: { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 110: break; case 45: // general lookahead, find correct zzMarkedPos { int zzFState = 17; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 111: break; case 46: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 3; { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 112: break; case 47: // general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 113: break; case 48: // general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 22; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 114: break; case 49: // general lookahead, find correct zzMarkedPos { int zzFState = 18; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 19; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 115: break; case 50: // general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 116: break; case 51: // general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 21; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 117: break; case 52: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 118: break; case 53: // lookahead expression with fixed lookahead length yypushback(1); { breakByHyphens(yytext()); return getNext(removeSoftHyphens(yytext()), yytext()); } case 119: break; case 54: { if (splitAssimilations) { yypushback(3) ; return getNext(); } else { return getNext(); } } case 120: break; case 55: // lookahead expression with fixed lookahead length yypushback(1); { return getNormalizedAmpNext(); } case 121: break; case 56: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 9; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 122: break; case 57: // lookahead expression with fixed lookahead length yypushback(2); { return getNext(); } case 123: break; case 58: // general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 124: break; case 59: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 125: break; case 60: // general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 13; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 126: break; case 61: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } return getNext(txt, yytext()); } case 127: break; case 62: // lookahead expression with fixed lookahead length yypushback(4); { return getNext(); } case 128: break; case 63: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 3; { return getNext(); } case 129: break; case 64: { String txt = yytext(); if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 130: break; case 65: // general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 25; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 131: break; case 66: // general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 24; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 132: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }"	"  public Object next() throws java.io.IOException {
    int zzInput;
    int zzAction;

    // cached fields:
    int zzCurrentPosL;
    int zzMarkedPosL;
    int zzEndReadL = zzEndRead;
    char [] zzBufferL = zzBuffer;
    char [] zzCMapL = ZZ_CMAP;

    int [] zzTransL = ZZ_TRANS;
    int [] zzRowMapL = ZZ_ROWMAP;
    int [] zzAttrL = ZZ_ATTRIBUTE;

    while (true) {
      zzMarkedPosL = zzMarkedPos;

      yychar+= zzMarkedPosL-zzStartRead;

      zzAction = -1;

      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
  
      zzState = ZZ_LEXSTATE[zzLexicalState];

      // set up zzAction for empty match case:
      int zzAttributes = zzAttrL[zzState];
      if ( (zzAttributes & 1) == 1 ) {
        zzAction = zzState;
      }


      zzForAction: {
        while (true) {
    
          if (zzCurrentPosL < zzEndReadL) {
            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);
            zzCurrentPosL += Character.charCount(zzInput);
          }
          else if (zzAtEOF) {
            zzInput = YYEOF;
            break zzForAction;
          }
          else {
            // store back cached positions
            zzCurrentPos  = zzCurrentPosL;
            zzMarkedPos   = zzMarkedPosL;
            boolean eof = zzRefill();
            // get translated positions and possibly new buffer
            zzCurrentPosL  = zzCurrentPos;
            zzMarkedPosL   = zzMarkedPos;
            zzBufferL      = zzBuffer;
            zzEndReadL     = zzEndRead;
            if (eof) {
              zzInput = YYEOF;
              break zzForAction;
            }
            else {
              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);
              zzCurrentPosL += Character.charCount(zzInput);
            }
          }
          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
          if (zzNext == -1) break zzForAction;
          zzState = zzNext;

          zzAttributes = zzAttrL[zzState];
          if ( (zzAttributes & 1) == 1 ) {
            zzAction = zzState;
            zzMarkedPosL = zzCurrentPosL;
            if ( (zzAttributes & 8) == 8 ) break zzForAction;
          }

        }
      }

      // store back cached position
      zzMarkedPos = zzMarkedPosL;

      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
        zzAtEOF = true;
              {
                if (invertible) {
            prevWordAfter.append(yytext());
            String str = prevWordAfter.toString();
            prevWordAfter.setLength(0);
            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);
          }
          return null;
              }
      }
      else {
        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
          case 1: 
            { String str = yytext();
          int first = str.codePointAt(0);
          String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));
          switch (untokenizable) {
            case NONE_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              break;
            case FIRST_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              if ( ! this.seenUntokenizableCharacter) {
                logger.warning(msg);
                this.seenUntokenizableCharacter = true;
              }
              break;
            case ALL_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              logger.warning(msg);
              this.seenUntokenizableCharacter = true;
              break;
            case NONE_KEEP:
              return getNext();
            case FIRST_KEEP:
              if ( ! this.seenUntokenizableCharacter) {
                logger.warning(msg);
                this.seenUntokenizableCharacter = true;
              }
              return getNext();
            case ALL_KEEP:
              logger.warning(msg);
              this.seenUntokenizableCharacter = true;
              return getNext();
          }
            }
          case 67: break;
          case 2: 
            { return getNext(""<"", yytext());
            }
          case 68: break;
          case 3: 
            { return getNext();
            }
          case 69: break;
          case 4: 
            { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {
                    return getNext(ptbmdash, yytext());
                  } else {
                    return getNext();
                  }
            }
          case 70: break;
          case 5: 
            { if (tokenizeNLs) {
                      return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns
                  } else if (invertible) {
                      prevWordAfter.append(yytext());
                  }
            }
          case 71: break;
          case 6: 
            { final String origTxt = yytext();
                          String tmp = removeSoftHyphens(origTxt);
                          if (americanize) {
                            tmp = Americanize.americanize(tmp);
                          }
                          return getNext(tmp, origTxt);
            }
          case 72: break;
          case 7: 
            { if (invertible) {
                     prevWordAfter.append(yytext());
                  }
            }
          case 73: break;
          case 8: 
            { return handleQuotes(yytext(), false);
            }
          case 74: break;
          case 9: 
            { if (escapeForwardSlashAsterisk) {
                    return getNext(delimit(yytext(), '/'), yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 75: break;
          case 10: 
            { return getNext("">"", yytext());
            }
          case 76: break;
          case 11: 
            { if (ptb3Dashes) {
                            return getNext(ptbmdash, yytext()); }
                          else {
                            return getNext();
                          }
            }
          case 77: break;
          case 12: 
            { return getNext(removeFromNumber(yytext()), yytext());
            }
          case 78: break;
          case 13: 
            { return handleEllipsis(yytext());
            }
          case 79: break;
          case 14: 
            { return normalizeFractions(yytext());
            }
          case 80: break;
          case 15: 
            { if (normalizeCurrency) {
                            return getNext(normalizeCurrency(yytext()), yytext());
                        } else {
                            return getNext(minimallyNormalizeCurrency(yytext()), yytext());
                          }
            }
          case 81: break;
          case 16: 
            { if (normalizeOtherBrackets) {
                    return getNext(closebrace, yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 82: break;
          case 17: 
            { if (normalizeOtherBrackets) {
                    return getNext(""-RSB-"", yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 83: break;
          case 18: 
            { if (normalizeParentheses) {
                    return getNext(openparen, yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 84: break;
          case 19: 
            { if (normalizeParentheses) {
                    return getNext(closeparen, yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 85: break;
          case 20: 
            { if (escapeForwardSlashAsterisk) {
                    return getNext(delimit(yytext(), '*'), yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 86: break;
          case 21: 
            { if (normalizeOtherBrackets) {
                    return getNext(openbrace, yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 87: break;
          case 22: 
            { if (normalizeOtherBrackets) {
                    return getNext(""-LSB-"", yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 88: break;
          case 23: 
            { if (invertible) {
                            prevWordAfter.append(yytext());
                        }
            }
          case 89: break;
          case 24: 
            { return getNext(""\u2022"", yytext());
            }
          case 90: break;
          case 25: 
            { return getNext(""\u2122"", yytext());
            }
          case 91: break;
          case 26: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 15;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 16;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return getNext();
            }
          case 92: break;
          case 27: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { return getNext();
            }
          case 93: break;
          case 28: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { return handleQuotes(yytext(), true);
            }
          case 94: break;
          case 29: 
            { String txt = yytext();
                  String origText = txt;
                  if (normalizeParentheses) {
                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                  }
                  return getNext(txt, origText);
            }
          case 95: break;
          case 30: 
            { breakByHyphens(yytext());
                    return getNext(removeSoftHyphens(yytext()), yytext());
            }
          case 96: break;
          case 31: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 3;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 4;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { final String origTxt = yytext();
                          String tmp = removeSoftHyphens(origTxt);
                          if (americanize) {
                            tmp = Americanize.americanize(tmp);
                          }
                          return getNext(tmp, origTxt);
            }
          case 97: break;
          case 32: 
            { if (escapeForwardSlashAsterisk) {
                            return getNext(delimit(yytext(), '/'), yytext());
                          } else {
                            return getNext();
                          }
            }
          case 98: break;
          case 33: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { return getNext(removeSoftHyphens(yytext()), yytext());
            }
          case 99: break;
          case 34: 
            { // this one should only match if we're basically at the end of file
                          // since the last one matches two things, even newlines (if not tokenize per line)
                          String s;
                          if (strictTreebank3 && ! ""U.S."".equals(yytext())) {
                            yypushback(1); // return a period for next time
                            s = yytext();
                          } else {
                            s = yytext();
                            yypushback(1); // return a period for next time
                          }
                          return getNext(s, yytext());
            }
          case 100: break;
          case 35: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { String txt = yytext();
                  String origText = txt;
                  if (normalizeParentheses) {
                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                  }
                  return getNext(txt, origText);
            }
          case 101: break;
          case 36: 
            // lookahead expression with fixed base length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 1);
            { /* invert quote - often but not always right */
                  return handleQuotes(yytext(), true);
            }
          case 102: break;
          case 37: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { return handleQuotes(yytext(), false);
            }
          case 103: break;
          case 38: 
            { return getNext(removeSoftHyphens(yytext()), yytext());
            }
          case 104: break;
          case 39: 
            { String txt = yytext();
                  // if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space...
                  if (strictTreebank3) {
                    int spaceIndex = indexOfSpace(txt);
                    if (spaceIndex >= 0) {
                      yypushback(txt.length() - spaceIndex);
                      String newText = yytext();
                      return getNext(newText, newText);
                    }
                  }
                  if (escapeForwardSlashAsterisk) {
                    txt = delimit(txt, '/');
                  }
                  if (normalizeSpace) {
                    txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                  }
                  return getNext(txt, txt);
            }
          case 105: break;
          case 40: 
            { return getNormalizedAmpNext();
            }
          case 106: break;
          case 41: 
            { final String origTxt = yytext();
                          String txt = origTxt;
                          if (normalizeSpace) {
                            txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                          }
                          return getNext(txt, origTxt);
            }
          case 107: break;
          case 42: 
            { final String origTxt = yytext();
                          String txt = origTxt;
                          if (normalizeSpace) {
                            txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                          }
                          return getNext(txt, origTxt);
            }
          case 108: break;
          case 43: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 5;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 6;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { final String txt = yytext();
                          return getNext(removeSoftHyphens(txt),
                                         txt);
            }
          case 109: break;
          case 44: 
            { if (splitAssimilations) {
                            yypushback(2) ; return getNext();
                          } else {
                            return getNext();
                          }
            }
          case 110: break;
          case 45: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 17;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 16;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return getNext();
            }
          case 111: break;
          case 46: 
            // lookahead expression with fixed base length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);
            { if (splitAssimilations) {
                            yypushback(2) ; return getNext();
                          } else {
                            return getNext();
                          }
            }
          case 112: break;
          case 47: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 10;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 11;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return processAbbrev3();
            }
          case 113: break;
          case 48: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 20;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 22;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */
                                    return handleEllipsis(yytext());
            }
          case 114: break;
          case 49: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 18;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 19;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return getNext();
            }
          case 115: break;
          case 50: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 10;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 11;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return processAbbrev3();
            }
          case 116: break;
          case 51: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 20;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 21;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */
                                    return handleEllipsis(yytext());
            }
          case 117: break;
          case 52: 
            { String txt = yytext();
                          if (escapeForwardSlashAsterisk) {
                            txt = delimit(txt, '/');
                            txt = delimit(txt, '*');
                          }
                          return getNext(txt, yytext());
            }
          case 118: break;
          case 53: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { breakByHyphens(yytext());
                    return getNext(removeSoftHyphens(yytext()), yytext());
            }
          case 119: break;
          case 54: 
            { if (splitAssimilations) {
                            yypushback(3) ; return getNext();
                          } else {
                            return getNext();
                          }
            }
          case 120: break;
          case 55: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { return getNormalizedAmpNext();
            }
          case 121: break;
          case 56: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 7;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 9;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return processAcronym();
            }
          case 122: break;
          case 57: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);
            { return getNext();
            }
          case 123: break;
          case 58: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 12;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 14;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return processAbbrev1();
            }
          case 124: break;
          case 59: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 7;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 8;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return processAcronym();
            }
          case 125: break;
          case 60: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 12;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 13;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return processAbbrev1();
            }
          case 126: break;
          case 61: 
            { String txt = yytext();
                          if (escapeForwardSlashAsterisk) {
                            txt = delimit(txt, '/');
                          }
                          return getNext(txt, yytext());
            }
          case 127: break;
          case 62: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4);
            { return getNext();
            }
          case 128: break;
          case 63: 
            // lookahead expression with fixed base length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);
            { return getNext();
            }
          case 129: break;
          case 64: 
            { String txt = yytext();
                          if (normalizeSpace) {
                            txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                          }
                          if (normalizeParentheses) {
                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                          }
                          return getNext(txt, yytext());
            }
          case 130: break;
          case 65: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 23;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 25;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */
                                    return handleEllipsis(yytext());
            }
          case 131: break;
          case 66: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 23;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 24;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */
                                    return handleEllipsis(yytext());
            }
          case 132: break;
          default:
            zzScanError(ZZ_NO_MATCH);
        }
      }
    }
  }
"	@return the next token	@return the next token	0	1	17	921	5750
@RequestMapping(value = STR, method = { RequestMethod.PUT }) @ResponseBody public CubeRequest updateCubeDesc(@RequestBody CubeRequest cubeRequest) throws JsonProcessingException { CubeDesc desc = deserializeCubeDesc(cubeRequest); if (desc == null) { return cubeRequest; } final String cubeName = cubeRequest.getCubeName(); if (StringUtils.isEmpty(cubeName)) { return errorRequest(cubeRequest, STR); } MetadataManager metadataManager = MetadataManager.getInstance(cubeService.getConfig()); DataModelDesc modelDesc = null; DataModelDesc oldModelDesc = null; if (StringUtils.isNotEmpty(cubeRequest.getModelDescData())) { modelDesc = deserializeDataModelDesc(cubeRequest); if (modelDesc == null) { return cubeRequest; } final String modeName = modelDesc.getName(); if (!StringUtils.equals(desc.getModelName(), modeName)) { return errorRequest(cubeRequest, STR + desc.getModelName() + STR + modeName); } oldModelDesc = metadataManager.getDataModelDesc(modeName); if (oldModelDesc == null) { return errorRequest(cubeRequest, STR + modeName + STR); } } if (!cubeService.isCubeDescEditable(desc)) { String error = STR + desc.getName().toUpperCase() + STR; return errorRequest(cubeRequest, error); } boolean updateModelSuccess = false, updateCubeSuccess = false; try { if (modelDesc != null) { metadataManager.updateDataModelDesc(modelDesc); updateModelSuccess = true; } CubeInstance cube = cubeService.getCubeManager().getCube(cubeName); String projectName = (null == cubeRequest.getProject()) ? ProjectInstance.DEFAULT_PROJECT_NAME : cubeRequest.getProject(); desc = cubeService.updateCubeAndDesc(cube, desc, projectName); ProjectManager projectManager = cubeService.getProjectManager(); if (!cubeService.isCubeInProject(projectName, cube)) { String owner = SecurityContextHolder.getContext().getAuthentication().getName(); ProjectInstance newProject = projectManager.moveRealizationToProject(RealizationType.CUBE, cube.getName(), projectName, owner); accessService.inherit(cube, newProject); } if (desc.getError().isEmpty()) { cubeRequest.setSuccessful(true); updateCubeSuccess = true; } else { logger.warn(STR + desc.getName() + STR + desc.getError()); errorRequest(cubeRequest, omitMessage(desc.getError())); } } catch (AccessDeniedException accessDeniedException) { throw new ForbiddenException(STR); } catch (Exception e) { logger.error(STR + e.getLocalizedMessage(), e); throw new InternalErrorException(STR + e.getLocalizedMessage()); } finally { if (updateModelSuccess == true && updateCubeSuccess == false) { try { oldModelDesc.setLastModified(modelDesc.getLastModified()); metadataManager.updateDataModelDesc(oldModelDesc); } catch (IOException e) { logger.error(STR + e.getLocalizedMessage(), e); throw new InternalErrorException(STR + e.getLocalizedMessage()); } } } String descData = JsonUtil.writeValueAsIndentString(desc); cubeRequest.setCubeDescData(descData); return cubeRequest; }	"@RequestMapping(value = STR, method = { RequestMethod.PUT })
@ResponseBody
public CubeRequest updateCubeDesc(@RequestBody CubeRequest cubeRequest) throws JsonProcessingException {
    CubeDesc desc = deserializeCubeDesc(cubeRequest);
    if (desc == null) {
        return cubeRequest;
    }
    final String cubeName = desc.getName();
    if (StringUtils.isEmpty(cubeName)) {
        return errorRequest(cubeRequest, STR);
    }
    MetadataManager metadataManager = MetadataManager.getInstance(KylinConfig.getInstanceFromEnv());
    DataModelDesc modelDesc = null;
    if (StringUtils.isNotEmpty(cubeRequest.getModelDescData())) {
        modelDesc = deserializeDataModelDesc(cubeRequest);
        if (modelDesc == null) {
            return cubeRequest;
        }
        final String modeName = modelDesc.getName();
        if (!StringUtils.equals(desc.getModelName(), modeName)) {
            return errorRequest(cubeRequest, STR + desc.getModelName() + STR + modeName);
        }
        DataModelDesc oldModelDesc = metadataManager.getDataModelDesc(modeName);
        if (oldModelDesc == null) {
            return errorRequest(cubeRequest, STR + modeName + STR);
        }
        if (!modelDesc.compatibleWith(oldModelDesc)) {
            return errorRequest(cubeRequest, STR);
        }
    }
    if (!cubeService.isCubeDescEditable(desc)) {
        String error = STR + desc.getName().toUpperCase() + STR;
        return errorRequest(cubeRequest, error);
    }
    try {
        if (modelDesc != null)
            metadataManager.updateDataModelDesc(modelDesc);
        CubeInstance cube = cubeService.getCubeManager().getCube(cubeName);
        String projectName = (null == cubeRequest.getProject()) ? ProjectInstance.DEFAULT_PROJECT_NAME : cubeRequest.getProject();
        desc = cubeService.updateCubeAndDesc(cube, desc, projectName);
    } catch (AccessDeniedException accessDeniedException) {
        throw new ForbiddenException(STR);
    } catch (Exception e) {
        logger.error(STR + e.getLocalizedMessage(), e);
        throw new InternalErrorException(STR + e.getLocalizedMessage());
    }
    if (desc.getError().isEmpty()) {
        cubeRequest.setSuccessful(true);
    } else {
        logger.warn(STR + desc.getName() + STR + desc.getError());
        errorRequest(cubeRequest, omitMessage(desc.getError()));
    }
    String descData = JsonUtil.writeValueAsIndentString(desc);
    cubeRequest.setCubeDescData(descData);
    return cubeRequest;
}"	@return cubeRequest cube change request	@return Table metadata array	1	0	12	74	526
public Date getTimeStamp() { return timeStamp; }	"public String getTimeStamp() {
    return timeStamp;
}"	@return a date instance representing the timestamp	"@return a string of the format ""Thu Oct 18 20:21:13 2001"""	1	0	4	3	10
public short getGreen() { return data[getFirst1DIndex() + NUM]; }	"public short getGreen(final int i) {
    return data[get1DIndex(i) + NUM];
}"	@return green value in the first position	@return green value in given position	1	0	7	3	17
public DateTime roundHalfCeilingCopy() { DateTime instant = iInstant; return instant.withMillis(iField.roundHalfCeiling(instant.getMillis())); }	"    public DateTime roundHalfCeilingCopy() {
        DateTime instant = iInstant;
        return (DateTime)instant.withMillis(iField.roundHalfCeiling(instant.getMillis()));
    }
"	@return a copy of the DateTime with the field value changed	@return a copy of the DateTime with the field value changed	0	1	6	5	25
private static final Cost isReferenceCompatible(IType cv1Target, IType cv2Source) throws DOMException { final int inheritanceDist = isReferenceRelated(cv1Target, cv2Source); if (inheritanceDist < NUM) return null; final int cmp = compareQualifications(cv1Target, cv2Source); if (cmp < NUM) return null; Cost cost = new Cost(cv2Source, cv1Target); cost.qualification = cmp > NUM ? Cost.CONVERSION_RANK : Cost.IDENTITY_RANK; cost.conversion = inheritanceDist; return cost; }	"private static final boolean isReferenceCompatible(IType cv1t1, IType cv2t2) throws DOMException {
    if (isReferenceRelated(cv1t1, cv2t2)) {
        Integer cmp = compareQualifications(cv1t1, cv2t2);
        return cmp != null && cmp >= NUM;
    }
    return false;
}"	@return The cost for converting or <code>null</code> if <code>cv1t1</code> is not reference-compatible with <code>cv2t2</code>	@return whether <code>cv1t1</code> is reference-compatible with <code>cv2t2</code>	1	0	7	12	80
public Sentence caseless() { return new Sentence(this.docFn, impl.build(), Document.CASELESS_PROPS); }	"  public Sentence caseless() {
    this.defaultProps = Document.CASELESS_PROPS;
    return this;
  }
"	@return A new sentence with the default properties swapped out.	@return This same sentence, but with the default properties swapped out.	1	0	6	4	23
"static List<File> getLogs(File logDir) { List<File> result = Lists.newArrayList(); File[] files = logDir.listFiles(); if(files == null) { if(!logDir.isDirectory()) { String msg = ""Path "" + logDir + "" is not a directory: ""; msg += ""File = "" + logDir.isFile() + "", ""; msg += ""Exists = "" + logDir.exists() + "", ""; msg += ""Writable = "" + logDir.canWrite(); throw new IllegalStateException(msg); } return result; } for (File file : files) { String name = file.getName(); if (pattern.matcher(name).matches()) { result.add(file); } } return result; }"	"  static List<File> getLogs(File logDir) {
    List<File> result = Lists.newArrayList();
    for (File file : logDir.listFiles()) {
      String name = file.getName();
      if (pattern.matcher(name).matches()) {
        result.add(file);
      }
    }
    return result;
  }
"	@return List of data files within logDir	@return List of data files within logDir	0	1	11	22	149
public VContextMenu getContextMenu() { if (contextMenu == null) { contextMenu = new VContextMenu(); DOM.setElementProperty(contextMenu.getElement(), STR, STR); } return contextMenu; }	"public IContextMenu getContextMenu() {
    if (contextMenu == null) {
        contextMenu = new IContextMenu();
        DOM.setElementProperty(contextMenu.getElement(), STR, STR);
    }
    return contextMenu;
}"	@return VContextMenu object	@return IContextMenu object	1	0	8	7	36
public AvroCollector getCollector(String namedOutput, Reporter reporter) throws IOException { return getCollector(namedOutput, null, reporter,namedOutput,null); }	"  public AvroCollector getCollector(String namedOutput, Reporter reporter)
    throws IOException {
    return getCollector(namedOutput, null, reporter);
  }
"	@return the output collector for the given named output	@return the output collector for the given named output	0	1	5	5	28
protected Set<String> populateWhat(Set<String> what) throws Exception { checkOption(what); if (what.contains(WHAT_HELP)) throw new Exception(STR + whatHelp()); if (!what.contains(WHAT_CLIENT) && !what.contains(WHAT_SERVER) && !what.contains(WHAT_BOTH)) { what.add(WHAT_BOTH); what.add(WHAT_CLIENT); what.add(WHAT_SERVER); } else if (what.contains(WHAT_BOTH)) { what.add(WHAT_CLIENT); what.add(WHAT_SERVER); } else if (what.contains(WHAT_CLIENT) && what.contains(WHAT_SERVER)) { what.add(WHAT_BOTH); } Assertion.check((what.contains(WHAT_CLIENT) && !what.contains(WHAT_SERVER) && !what.contains(WHAT_BOTH)) || (!what.contains(WHAT_CLIENT) && what.contains(WHAT_SERVER) && !what.contains(WHAT_BOTH)) || (what.contains(WHAT_CLIENT) && what.contains(WHAT_SERVER) && what.contains(WHAT_BOTH)), STR); if (!what.contains(WHAT_ALL) && !what.contains(WHAT_NONE) && !what.contains(WHAT_INTF) && !what.contains(WHAT_MAIN) && !what.contains(WHAT_IMPL)) { what.add(WHAT_INTF); } if (what.contains(WHAT_ALL)) { what.add(WHAT_INTF); what.add(WHAT_MAIN); what.add(WHAT_IMPL); what.remove(WHAT_ALL); what.remove(WHAT_NONE); } if (what.contains(WHAT_NONE)) { what.remove(WHAT_INTF); what.remove(WHAT_MAIN); what.remove(WHAT_IMPL); what.remove(WHAT_NONE); } return what; }	"protected Set<String> populateWhat(Set<String> what) {
    if (!checkOption(what)) {
        return null;
    }
    if (what.contains(WHAT_ALL)) {
        what.add(WHAT_IMPL);
        what.add(WHAT_MAIN);
        what.add(WHAT_HELPER);
    }
    if (!what.contains(WHAT_CLIENT) && !what.contains(WHAT_SERVER) && !what.contains(WHAT_BOTH)) {
        what.add(WHAT_BOTH);
    }
    if (what.contains(WHAT_BOTH)) {
        what.add(WHAT_CLIENT);
        what.add(WHAT_SERVER);
    }
    if (what.contains(WHAT_NONE)) {
        what.clear();
    }
    return what;
}"	@return what modified to account for interaction of options.	@return what modified to account for all, both, and none options.	1	0	10	33	333
"public HttpMessage getHttpMessage() throws HttpMalformedHeaderException, DatabaseException { if (httpMessage != null) { return httpMessage; } // fetch complete message RecordHistory history = staticTableHistory.read(historyId); if (history == null) { throw new HttpMalformedHeaderException(""No history reference for id "" + historyId + "" type="" + historyType); } // ZAP: Init HttpMessage HistoryReference field history.getHttpMessage().setHistoryRef(this); return history.getHttpMessage(); }"	"	public HttpMessage getHttpMessage() throws HttpMalformedHeaderException, DatabaseException {
		// fetch complete message
		RecordHistory history = staticTableHistory.read(historyId);
		if (history == null) {
			throw new HttpMalformedHeaderException(""No history reference for id "" + historyId + "" type="" + historyType);
		}
		// ZAP: Init HttpMessage HistoryReference field
		history.getHttpMessage().setHistoryRef(this);
		return history.getHttpMessage();
	}
"	@return the http message	@return the http message	0	1	10	15	86
protected Object convertBit(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return false; } if (data instanceof Boolean) return data; if (data instanceof Short) return ((Short) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE; if (data instanceof Integer) return ((Integer) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE; if (data instanceof Long) return ((Long) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE; return handleUnknownData(column, fieldDefn, data); }	"    protected Object convertBit(Column column, Field fieldDefn, Object data) {
        if (data == null) return null;
        if (data instanceof Boolean) return data;
        if (data instanceof Short) return ((Short) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;
        if (data instanceof Integer) return ((Integer) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;
        if (data instanceof Long) return ((Long) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;
        return handleUnknownData(column, fieldDefn, data);
    }
"	@return the converted value, or null if the conversion could not be made and the column allows nulls	@return the converted value, or null if the conversion could not be made	1	0	8	15	142
"public int get(DateTimeField field) { for (int i = 0, isize = getFieldSize(); i < isize; i++) { if (getField(i) == field) { return getValue(i); } } throw new IllegalArgumentException(""Field '"" + field + ""' is not supported""); }"	"    public int get(DateTimeField field) {
        for (int i = 0; i < iFields.length; i++) {
            if (iFields[i] == field) {
                return iValues[i];
            }
        }
        throw new IllegalArgumentException(""Field '"" + field + ""' is not supported"");
    }
"	@return the value of that field	@return the value of that field	0	1	9	9	64
@NonNull public static InstantRunVerifierStatus verifyMethod(MethodNode method) { VerifierMethodVisitor mv = new VerifierMethodVisitor(method); method.accept(mv); return mv.incompatibleChange.or(InstantRunVerifierStatus.COMPATIBLE); }	"@Nullable
public static IncompatibleChange verifyMethod(MethodNode method) {
    VerifierMethodVisitor mv = new VerifierMethodVisitor(method);
    method.accept(mv);
    return mv.incompatibleChange.orNull();
}"	@return a {@link InstantRunVerifierStatus} instance or null if the method is not making any blacklisted calls.	@return a {@link IncompatibleChange} instance or null if the method is not making any blacklisted calls.	1	0	6	6	35
"private String getTargetEntity(List<? extends AnnotationMirror> annotations) { String fullyQualifiedTargetEntityName = null; for ( AnnotationMirror mirror : annotations ) { if ( TypeUtils.isAnnotationMirrorOfType( mirror, ElementCollection.class ) ) { fullyQualifiedTargetEntityName = getFullyQualifiedClassNameOfTargetEntity( mirror, ""targetClass"" ); } else if ( TypeUtils.isAnnotationMirrorOfType( mirror, OneToMany.class ) || TypeUtils.isAnnotationMirrorOfType( mirror, ManyToMany.class ) || TypeUtils.isAnnotationMirrorOfType( mirror, ManyToOne.class ) || TypeUtils.isAnnotationMirrorOfType( mirror, OneToOne.class ) ) { fullyQualifiedTargetEntityName = getFullyQualifiedClassNameOfTargetEntity( mirror, ""targetEntity"" ); } } return fullyQualifiedTargetEntityName; }"	"	private String getTargetEntity(List<? extends AnnotationMirror> annotations) {

		for ( AnnotationMirror mirror : annotations ) {
			if ( TypeUtils.isAnnotationMirrorOfType( mirror, ElementCollection.class )
					|| TypeUtils.isAnnotationMirrorOfType( mirror, OneToMany.class )
					|| TypeUtils.isAnnotationMirrorOfType( mirror, ManyToMany.class )
					|| TypeUtils.isAnnotationMirrorOfType( mirror, ManyToOne.class )
					|| TypeUtils.isAnnotationMirrorOfType( mirror, OneToOne.class ) ) {
				final String targetEntity = getTargetEntity( mirror );
				if ( targetEntity != null ) {
					return targetEntity;
				}
			}
		}
		return null;
	}
"	@return target entity class name as string or  null if no targetEntity is here or if equals to void	@return target entity class name as string or null if no targetEntity is here or if equals to void	0	1	12	17	105
"public static long toNanoOfDay(Object value, boolean acceptLargeValues) { if (value instanceof Duration) { Duration duration = (Duration) value; if (!acceptLargeValues && (duration.isNegative() || duration.compareTo(ONE_DAY) > 0)) { throw new IllegalArgumentException(""Time values must be between 00:00:00 and 24:00:00 (inclusive): "" + duration); } return ((Duration) value).toNanos(); } // TODO only needed for SQL Server/Oracle, where we don't produce Duration right away; // this should go eventually, as the conversion to LocalTime is superfluous LocalTime time = Conversions.toLocalTime(value); return time.toNanoOfDay(); }"	"    public static long toNanoOfDay(Object value, TemporalAdjuster adjuster) {
        LocalTime time = Conversions.toLocalTime(value);
        if (adjuster !=null) {
            time = time.with(adjuster);
        }
        return time.toNanoOfDay();
    }
"	@return the milliseconds past midnight	@return the nanoseconds past midnight	1	0	10	16	141
public BigDecimal fakeOuterNumberSerialize(BigDecimal body) throws ApiException { ApiResponse<BigDecimal> localVarResp = fakeOuterNumberSerializeWithHttpInfo(body); return localVarResp.getData(); }	"    public BigDecimal fakeOuterNumberSerialize(BigDecimal body) throws ApiException {
        ApiResponse<BigDecimal> resp = fakeOuterNumberSerializeWithHttpInfo(body);
        return resp.getData();
    }
"	@return BigDecimal	@return BigDecimal	0	1	6	5	25
private static final int isReferenceRelated(IType cv1Target, IType cv2Source) throws DOMException { IType t = SemanticUtil.getNestedType(cv1Target, TYPEDEFS | REFERENCES); IType s = SemanticUtil.getNestedType(cv2Source, TYPEDEFS | REFERENCES); if (t instanceof IPointerType && s instanceof IPointerType) { t = ((IPointerType) t).getType(); s = ((IPointerType) s).getType(); } else { t = t instanceof IQualifierType ? ((IQualifierType) t).getType() : t; s = s instanceof IQualifierType ? ((IQualifierType) s).getType() : s; if (t instanceof ICPPClassType && s instanceof ICPPClassType) { return calculateInheritanceDepth(CPPSemantics.MAX_INHERITANCE_DEPTH, s, t); } } if (t == s || (t != null && s != null && t.isSameType(s))) { return NUM; } return -NUM; }	"private static final boolean isReferenceRelated(IType cv1t1, IType cv2t2) throws DOMException {
    IType t1 = SemanticUtil.getUltimateTypeUptoPointers(cv1t1);
    IType t2 = SemanticUtil.getUltimateTypeUptoPointers(cv2t2);
    if (t1 instanceof IPointerType && t2 instanceof IPointerType) {
        IType ptt1 = ((IPointerType) t1).getType();
        IType ptt2 = ((IPointerType) t2).getType();
        return ptt1 != null && ptt2 != null ? ptt1.isSameType(ptt2) : ptt1 == ptt2;
    }
    t1 = t1 instanceof IQualifierType ? ((IQualifierType) t1).getType() : t1;
    t2 = t2 instanceof IQualifierType ? ((IQualifierType) t2).getType() : t2;
    if (t1 instanceof ICPPClassType && t2 instanceof ICPPClassType) {
        return calculateInheritanceDepth(CPPSemantics.MAX_INHERITANCE_DEPTH, t2, t1) >= NUM;
    }
    return t1 != null && t2 != null ? t1.isSameType(t2) : t1 == t2;
}"	@return inheritance distance, or -1, if <code>cv1t1</code> is not reference-related to <code>cv2t2</code>	@return whether <code>cv1t1</code> is reference-related to <code>cv2t2</code>	1	0	9	18	169
private boolean searchForButton(String regex, int matches) { return searchFor(Button.class, regex, matches); }	"	private boolean searchForButton(String regex, int matches) {
		sleeper.sleep();
		inst.waitForIdleSync();
		Pattern p = Pattern.compile(regex);
		Matcher matcher;
		ArrayList<Button> buttonList = viewFetcher.getCurrentViews(Button.class);
		if(matches == 0)
			matches = 1;
		for(Button button : buttonList){
			matcher = p.matcher(button.getText().toString());
			if(matcher.find()){
				countMatches++;
			}
			if (countMatches == matches) {
				countMatches = 0;
				return true;
			}
		}

		if (scroller.scroll(Scroller.Direction.DOWN))
		{
			return searchForButton(regex, matches);
		} else {
			if (countMatches > 0)
				Log.d(LOG_TAG, "" There are only "" + countMatches + "" matches of "" + regex);
			countMatches = 0;
			return false;
		}

	}
"	@return true if a button with the given text is found a given number of times and false if it is not found	@return true if a button with the given text is found a given number of times and false if it is not found	0	1	6	4	23
"public static String[] list() { if (NativeInterface.isSimulated()) { // as on the Raspberry Pi return new String[]{ ""spidev0.0"", ""spidev0.1"" }; } ArrayList<String> devs = new ArrayList<String>(); File dir = new File(""/dev""); File[] files = dir.listFiles(); if (files != null) { for (File file : files) { if (file.getName().startsWith(""spidev"")) { devs.add(file.getName()); } } } // listFiles() does not guarantee ordering String[] tmp = devs.toArray(new String[devs.size()]); Arrays.sort(tmp); return tmp; }"	"  public static String[] list() {
    ArrayList<String> devs = new ArrayList<String>();
    File dir = new File(""/dev"");
    File[] files = dir.listFiles();
    if (files != null) {
      for (File file : files) {
        if (file.getName().startsWith(""spidev"")) {
          devs.add(file.getName());
        }
      }
    }
    // listFiles() does not guarantee ordering
    String[] tmp = devs.toArray(new String[devs.size()]);
    Arrays.sort(tmp);
    return tmp;
  }
"	@return String array	@return String array	0	1	11	22	148
static Drawable maybeApplyLeafRounding(@Nullable Drawable drawable, @Nullable RoundingParams roundingParams, Resources resources) { if (drawable == null || roundingParams == null || roundingParams.getRoundingMethod() != RoundingParams.RoundingMethod.BITMAP_ONLY) { return drawable; } if (drawable instanceof ForwardingDrawable) { DrawableParent parent = findDrawableParentForLeaf((ForwardingDrawable) drawable); Drawable child = parent.setDrawable(sEmptyDrawable); child = applyLeafRounding(child, roundingParams, resources); parent.setDrawable(child); return drawable; } else { return applyLeafRounding(drawable, roundingParams, resources); } }	"static Drawable maybeApplyLeafRounding(@Nullable Drawable drawable, @Nullable RoundingParams roundingParams, Resources resources) {
    if (drawable == null || roundingParams == null || roundingParams.getRoundingMethod() != RoundingParams.RoundingMethod.BITMAP_ONLY) {
        return drawable;
    }
    if (drawable instanceof BitmapDrawable || drawable instanceof ColorDrawable) {
        return applyLeafRounding(drawable, roundingParams, resources);
    } else {
        Drawable parent = drawable;
        Drawable child = parent.getCurrent();
        while (child != null && parent != child) {
            if (parent instanceof ForwardingDrawable && (child instanceof BitmapDrawable || child instanceof ColorDrawable)) {
                ((ForwardingDrawable) parent).setDrawable(sEmptyDrawable);
                child = applyLeafRounding(child, roundingParams, resources);
                ((ForwardingDrawable) parent).setDrawable(child);
                break;
            }
            parent = child;
            child = parent.getCurrent();
        }
    }
    return drawable;
}"	@return the rounded drawable, or the original drawable if the rounding didn't take place or it took place on a drawable's child	@return the wrapping rounded drawable, or the original drawable if the wrapping didn't take place or it took place on a drawable's child	1	0	9	14	101
private Object readResolve() { if (iChronology == null) { return new LocalDate(iLocalMillis, ISOChronology.getInstanceUTC()); } if (DateTimeZone.UTC.equals(iChronology.getZone()) == false) { return new LocalDate(iLocalMillis, iChronology.withUTC()); } return this; }	"    private Object readResolve() {
        if (DateTimeZone.UTC.equals(iChronology.getZone()) == false) {
            return new LocalDate(iLocalMillis, iChronology.withUTC());
        }
        return this;
    }
"	@return the resolved object, not null	@return the resolved object, not null	0	1	7	10	56
public static boolean isTextBasedContentType(String contentType) { return contentType != null && (contentType.startsWith(STR) || contentType.startsWith(STR)); }	"public static boolean isTextBasedContentType(String contentType) {
    return contentType.startsWith(STR) || contentType.startsWith(STR);
}"	@return whether it is not {@code null} and text-based	@return whether it is text	1	0	7	3	31
public DateTimeField yearOfCentury() { return UnsupportedDateTimeField.getInstance(DateTimeFieldType.yearOfCentury(), years()); }	"    public DateTimeField yearOfCentury() {
        return UnsupportedDateTimeField.getInstance(""yearOfCentury"", years());
    }
"	@return DateTimeField or UnsupportedDateTimeField if unsupported	@return DateTimeField or UnsupportedDateTimeField if unsupported	0	1	5	4	21
public static VersionProperty buildVersionProperty(SimpleAttributeBinding property, boolean lazyAvailable) { String mappedUnsavedValue = ( (KeyValue) property.getValue() ).getNullValue(); VersionValue unsavedValue = UnsavedValueFactory.getUnsavedVersionValue( mappedUnsavedValue, getGetter( property ), ( VersionType ) property.getHibernateTypeDescriptor().getExplicitType(), getConstructor( property.getEntityBinding() ) ); boolean lazy = lazyAvailable && property.isLazy(); return new VersionProperty( property.getAttribute().getName(), null, property.getHibernateTypeDescriptor().getExplicitType(), lazy, property.isInsertable(), property.isUpdatable(), property.getGeneration() == PropertyGeneration.INSERT || property.getGeneration() == PropertyGeneration.ALWAYS, property.getGeneration() == PropertyGeneration.ALWAYS, property.isNullable(), property.isUpdatable() && !lazy, property.isOptimisticLockable(), // TODO: get cascadeStyle from property when HHH-6355 is fixed; for now, assume NONE //property.getCascadeStyle(), CascadeStyle.NONE, unsavedValue ); }	"	public static VersionProperty buildVersionProperty(SimpleAttributeBinding property, boolean lazyAvailable) {
		String mappedUnsavedValue = ( (KeyValue) property.getValue() ).getNullValue();

		VersionValue unsavedValue = UnsavedValueFactory.getUnsavedVersionValue(
				mappedUnsavedValue,
				getGetter( property ),
				( VersionType ) property.getHibernateTypeDescriptor().getExplicitType(),
				getConstructor( property.getEntityBinding() )
		);

		boolean lazy = lazyAvailable && property.isLazy();

		return new VersionProperty(
		        property.getAttribute().getName(),
		        property.getNodeName(),
		        property.getHibernateTypeDescriptor().getExplicitType(),
		        lazy,
				property.isInsertable(),
				property.isUpdatable(),
		        property.getGeneration() == PropertyGeneration.INSERT || property.getGeneration() == PropertyGeneration.ALWAYS,
				property.getGeneration() == PropertyGeneration.ALWAYS,
				property.isNullable(),
				property.isUpdatable() && !lazy,
				property.isOptimisticLockable(),
				// TODO: get cascadeStyle from property when HHH-6355 is fixed; for now, assume NONE
				//property.getCascadeStyle(),
				CascadeStyle.NONE,
		        unsavedValue
			);
	}
"	@return The appropriate VersionProperty definition.	@return The appropriate VersionProperty definition.	0	1	8	31	178
public IBuildConfiguration[] getBuildConfigurations(IProject project, boolean makeCopy) { IBuildConfiguration[] configs = cachedBuildConfigs; if (configs != null && !project.equals(configs[NUM].getProject())) configs = null; if (configs == null) { if (configNames.length == NUM) configs = new IBuildConfiguration[] { new BuildConfiguration(project) }; else { configs = new IBuildConfiguration[configNames.length]; for (int i = NUM; i < configs.length; i++) configs[i] = new BuildConfiguration(project, configNames[i]); } cachedBuildConfigs = configs; } return makeCopy ? (IBuildConfiguration[]) configs.clone() : configs; }	"public IBuildConfiguration[] getBuildConfigurations(boolean makeCopy) {
    if (buildConfigs.length == NUM)
        return EMPTY_BUILD_CONFIGS;
    return makeCopy ? (IBuildConfiguration[]) buildConfigs.clone() : buildConfigs;
}"	@return the project configurations	@return the project configurations of an empty array if none exist.	1	0	13	15	127
public Dimension getViewSize() { return device.getSize(); }	"	public Dimension getViewSize() {
		if (viewSize == null) {
			return getLargestVideoFormat().getSize();
		}
		return viewSize;
	}
"	@return Webcam view size (picture size) in pixels.	@return Webcam view size (picture size) in pixels.	0	1	4	4	13
protected ReactGateway createReactGateway() { return new ReactGateway(this, isDebug(), this::createReactNativeHost); }	"	protected ReactGateway createReactGateway() {
	    return new ReactGateway(this, isDebug(), createReactNativeHost());
    }
"	@return a singleton  ReactGateway	@return a singleton ReactGateway	0	1	6	4	23
static MongoDatabasePolicy create() { final MongoClient client; if (MongoAssertions.useMongo()) { client = new MongoClient(); } else if (MongoAssertions.useFongo()) { client = new Fongo(MongoDatabasePolicy.class.getSimpleName()).getMongo(); } else { throw new UnsupportedOperationException(STR); } return new MongoDatabasePolicy(client); }	"static MongoDatabaseRule create() {
    final MongoClient client;
    if (MongoAssertions.useMongo()) {
        client = new MongoClient();
    } else if (MongoAssertions.useFongo()) {
        client = new Fongo(MongoDatabaseRule.class.getSimpleName()).getMongo();
    } else {
        throw new UnsupportedOperationException(STR);
    }
    return new MongoDatabaseRule(client);
}"	@return new instance of the policy to be used by unit tests	@return new instance of the rule to be used by unit tests	1	0	10	11	67
public boolean matches(Method method, Class targetClass) { return ((method.getAnnotation(PermissionRequired.class) != null) || (method.getAnnotation(RolesRequired.class) != null)); }	"public boolean matches(Method method, Class targetClass) {
    return ((method.getAnnotation(Implies.class) != null) || (method.getAnnotation(HasRole.class) != null));
}"	@return <tt>true</tt> if the method has a JSecurity <tt>RolesRequired</tt> or <tt>PermissionRequired</tt> annotation, false otherwise.	@return <tt>true</tt> if the method has a JSecurity <tt>HasRole</tt> or <tt>Implies</tt> annotation, false otherwise.	1	0	8	3	38
"public static String[] decodeArray(String encoded) { if (encoded.isEmpty()) return EMPTY_STRING_ARRAY; char[] chars = encoded.trim().toCharArray(); //--Parse the String // (state) char quoteCloseChar = (char) 0; List<String> terms = new ArrayList<>(); StringBuilder current = new StringBuilder(); //(start/stop overhead) int start = 0; int end = chars.length; if(chars[0] == '('){ start += 1; end -= 1; if(chars[end] != ')') throw new IllegalArgumentException(""Unclosed paren in encoded array: "" + encoded); } if(chars[0] == '['){ start += 1; end -= 1; if(chars[end] != ']') throw new IllegalArgumentException(""Unclosed bracket in encoded array: "" + encoded); } if(chars[0] == '{'){ start += 1; end -= 1; if(chars[end] != '}') throw new IllegalArgumentException(""Unclosed bracket in encoded array: "" + encoded); } // (finite state automaton) for (int i=start; i<end; i++) { if (chars[i] == '\r') { // Ignore funny windows carriage return continue; } else if (quoteCloseChar != 0) { //(case: in quotes) if(chars[i] == quoteCloseChar){ quoteCloseChar = (char) 0; }else{ current.append(chars[i]); } } else if(chars[i] == '\\'){ //(case: escaped character) if(i == chars.length - 1) throw new IllegalArgumentException(""Last character of encoded array is escape character: "" + encoded); current.append(chars[i+1]); i += 1; } else { //(case: normal) if (chars[i] == '""') { quoteCloseChar = '""'; } else if(chars[i] == '\'') { quoteCloseChar = '\''; } else if(chars[i] == ',' || chars[i] == ';' || chars[i] == ' ' || chars[i] == '\t' || chars[i] == '\n') { //break if (current.length() > 0) { terms.add(current.toString().trim()); } current = new StringBuilder(); } else { current.append(chars[i]); } } } //--Return if (current.length() > 0) { terms.add(current.toString().trim()); } return terms.toArray(EMPTY_STRING_ARRAY); }"	"  public static String[] decodeArray(String encoded){
    if (encoded.isEmpty()) return EMPTY_STRING_ARRAY;
    char[] chars = encoded.trim().toCharArray();

    //--Parse the String
    //(state)
    char quoteCloseChar = (char) 0;
    List<StringBuilder> terms = new LinkedList<>();
    StringBuilder current = new StringBuilder();
    //(start/stop overhead)
    int start = 0; int end = chars.length;
    if(chars[0] == '('){ start += 1; end -= 1; if(chars[end] != ')') throw new IllegalArgumentException(""Unclosed paren in encoded array: "" + encoded); }
    if(chars[0] == '['){ start += 1; end -= 1; if(chars[end] != ']') throw new IllegalArgumentException(""Unclosed bracket in encoded array: "" + encoded); }
    if(chars[0] == '{'){ start += 1; end -= 1; if(chars[end] != '}') throw new IllegalArgumentException(""Unclosed bracket in encoded array: "" + encoded); }
    //(finite state automata)
    for(int i=start; i<end; i++){
      if (chars[i] == '\r') {
        // Ignore funny windows carriage return
        continue;
      } else if(chars[i] == '\\'){
        //(case: escaped character)
        if(i == chars.length - 1) throw new IllegalArgumentException(""Last character of encoded pair is escape character: "" + encoded);
        current.append(chars[i+1]);
        i += 1;
      } else if(quoteCloseChar != 0){
        //(case: in quotes)
        if(chars[i] == quoteCloseChar){
          quoteCloseChar = (char) 0;
        }else{
          current.append(chars[i]);
        }
      }else{
        //(case: normal)
        if(chars[i] == '""'){
          quoteCloseChar = '""';
        } else if(chars[i] == '\''){
          quoteCloseChar = '\'';
        } else if(chars[i] == ',' || chars[i] == ';' || chars[i] == ' ' || chars[i] == '\t' || chars[i] == '\n'){
          //break
          if (current.length() > 0) {
            terms.add(current);
          }
          current = new StringBuilder();
        }else{
          current.append(chars[i]);
        }
      }
    }

    //--Return
    if(current.length() > 0) terms.add(current);
    String[] rtn = new String[terms.size()];
    int i=0;
    for(StringBuilder b : terms){
      rtn[i] = b.toString().trim();
      i += 1;
    }
    return rtn;
  }
"	@return A String array corresponding to the encoded array	@return A String array corresponding to the encoded array	0	1	19	56	553
@Processor @OAuthProtected @OAuthInvalidateAccessTokenOn(exception = OAuthTokenExpiredException.class) @Paged public PagingDelegate<TaskList> getTaskLists(final PagingConfiguration pagingConfiguration) throws IOException { return new TokenBasedPagingDelegate<TaskList>() { @Override protected List<TaskList> doGetPage() throws IOException { TaskLists list = client.tasklists().list().setMaxResults(new Long(pagingConfiguration.getFetchSize())).setPageToken(this.getPageToken()).execute(); this.setPageToken(list.getNextPageToken()); return TaskList.valueOf(list.getItems(), TaskList.class); } }; }	"@Processor
@OAuthProtected
@OAuthInvalidateAccessTokenOn(exception = OAuthTokenExpiredException.class)
@Inject
public List<TaskList> getTaskLists(MuleMessage message, @Optional @Default(STR) long maxResults, @Optional String pageToken) throws IOException {
    TaskLists list = this.client.tasklists().list().setMaxResults(maxResults).setPageToken(pageToken).execute();
    PaginationUtils.savePageToken(NEXT_PAGE_TOKEN, list.getNextPageToken(), message);
    return TaskList.valueOf(list.getItems(), TaskList.class);
}"	@return an auto paginated iterator with instances of {@link org.mule.module.google.task.model.TaskList}	@return a list with instances of {@link org.mule.module.google.task.model.TaskList}	1	0	11	15	100
public GremlinPipeline<S, Vertex> outV() { return this.add(new OutVertexPipe()); }	"public T outV() {
    return this.add(new OutVertexPipe());
}"	@return the extended Pipeline	@return the extended FluentPipeline	1	0	7	3	20
public static TypeRuntimeWiring newTypeWiring(String typeName, UnaryOperator<Builder> builderFunction) { return builderFunction.apply(newTypeWiring(typeName)).build(); }	"    public static TypeRuntimeWiring newTypeWiring(UnaryOperator<Builder> builderFunction) {
        return builderFunction.apply(newTypeWiring()).build();
    }
"	@return the same builder back please	@return the same builder back please	0	1	6	4	27
private Set<Alert> getAlertNodes() { if (!isMultiSelect()) { return extAlert.getAlertPanel().getSelectedAlert(); } return extAlert.getAlertPanel().getSelectedAlerts(); }	"    private Set<Alert> getAlertNodes() {
        TreePath[] paths = this.extAlert.getAlertPanel().getTreeAlert().getSelectionPaths();
        if (paths == null || paths.length == 0) {
            return Collections.emptySet();
        }

        HashSet<Alert> alertNodes = new HashSet<Alert>();
        if (!isMultiSelect()) {
            DefaultMutableTreeNode alertNode = (DefaultMutableTreeNode) paths[0].getLastPathComponent();
            alertNodes.add((Alert) alertNode.getUserObject());
            return alertNodes;
        }

        for(int i = 0; i < paths.length; i++ ) {
            DefaultMutableTreeNode alertNode = (DefaultMutableTreeNode)paths[i].getLastPathComponent();
            if(alertNode.getChildCount() == 0) {
                alertNodes.add((Alert)alertNode.getUserObject());
                continue;
            }
            for(int j = 0; j < alertNode.getChildCount(); j++ ) {
                DefaultMutableTreeNode node = (DefaultMutableTreeNode)alertNode.getChildAt(j);
                alertNodes.add((Alert)node.getUserObject());
            }
        }
        return alertNodes;
    }
"	@return  true if the menu item supports multiple selected alerts,  false otherwise.	@return true if the menu item supports multiple selected alerts, false otherwise.	0	1	7	7	35
"public String getCookie() { StringBuilder builder = new StringBuilder(); for (Cookie c : driver.manage().getCookies()) { builder.append(c.toString()); builder.append(""; ""); } return builder.toString(); }"	"  public String getCookie() {
    return (String) executeScript(""return document.cookie;"");
  }
"	@return all cookies of the current page under test	@return all cookies of the current page under test	0	1	7	9	52
public static Method findSetMethod(Field field, boolean throwExceptions) throws IllegalArgumentException { Method fieldSetMethod; if (Locale.ENGLISH.equals(Locale.getDefault())) { fieldSetMethod = findMethodFromNames(field, false, throwExceptions, methodFromField(field, STR, null)); } else { fieldSetMethod = findMethodFromNames(field, false, throwExceptions, methodFromField(field, STR, null), methodFromField(field, STR, Locale.ENGLISH)); } if (fieldSetMethod == null) { return null; } if (fieldSetMethod.getReturnType() != void.class) { if (throwExceptions) { throw new IllegalArgumentException(STR + fieldSetMethod.getName() + STR + fieldSetMethod.getReturnType() + STR); } else { return null; } } return fieldSetMethod; }	"public static Method findSetMethod(Field field, boolean throwExceptions) {
    String methodName = methodFromField(field, STR);
    Method fieldSetMethod;
    try {
        fieldSetMethod = field.getDeclaringClass().getMethod(methodName, field.getType());
    } catch (Exception e) {
        if (throwExceptions) {
            throw new IllegalArgumentException(STR + field);
        } else {
            return null;
        }
    }
    if (fieldSetMethod.getReturnType() != void.class) {
        if (throwExceptions) {
            throw new IllegalArgumentException(STR + methodName + STR + fieldSetMethod.getReturnType() + STR);
        } else {
            return null;
        }
    }
    return fieldSetMethod;
}"	@return Set method or null (or throws IllegalArgumentException) if none found.	@return Set method or null if none found.	1	0	13	19	141
public static BooleanTemplate booleanTemplate(Template template, ImmutableList<?> args) { return new BooleanTemplate(template, args); }	"    public static BooleanTemplate booleanTemplate(Template template, ImmutableList<?> args) {
        return new BooleanTemplate(template, ImmutableList.copyOf(args));
    }
"	@return template expression	@return template expression	0	1	5	4	23
public int getExtraInt(String key) throws JSONException { return mExtraData.getInt(key); }	"public double getExtraInt(String key) {
    return mExtraData.optInt(key);
}"	@return The stored value.	@return The stored value or null if it doesn't exist in specified form.	1	0	5	3	18
@Restricted(DoNotUse.class) @Deprecated @NonNull public List<? extends Action> getAllActions() { return Collections.emptyList(); }	"@NonNull
@Exported(name = STR)
public List<? extends Action> getAllActions() {
    List<Action> actions = new ArrayList<Action>();
    for (TransientActionFactory<?> taf : ExtensionList.lookup(TransientActionFactory.class)) {
        if (taf.type().isInstance(this)) {
            try {
                actions.addAll(createFor(taf));
            } catch (Exception e) {
                LOGGER.log(Level.SEVERE, STR + taf + STR + this, e);
            }
        }
    }
    return Collections.unmodifiableList(actions);
}"	@return an empty list	@return a list of all actions associated with this branch (by default, an unmodifiable list searching {@link TransientActionFactory}s)	1	0	5	6	26
"public boolean isEditable(String locator) { return (Boolean) seleneseMethods.get(""isEditable"").apply(driver, locator); }"	"  public boolean isEditable(String locator) {
    WebElement element = elementFinder.findElement(driver, locator);
    String tagName = element.getTagName().toLowerCase();
    boolean acceptableTagName = ""input"".equals(tagName) || ""select"".equals(tagName);
    String readonly = """";
    if (""input"".equals(tagName)) {
      readonly = element.getAttribute(""readonly"");
      if (readonly == null) readonly = """";
    }

    return element.isEnabled() && acceptableTagName && """".equals(readonly);
  }
"	@return true if the input element is editable, false otherwise	@return true if the input element is editable, false otherwise	0	1	7	4	27
public ImmutableGraph parse(InputStream serializedGraph, String formatIdentifier) throws UnsupportedFormatException { return parse(serializedGraph, formatIdentifier, null); }	"public Graph parse(InputStream serializedGraph, String formatIdentifier) throws UnsupportedFormatException {
    return parse(serializedGraph, formatIdentifier, null);
}"	@return the ImmutableGraph read from the stream	@return the graph read from the stream	1	0	5	3	24
protected MedicationMedicalRecordBodyType mapBody(final EHREXTRACT ehrExtract, final int compositionIndex) { final COMPOSITION composition = ehrExtract.getAllCompositions().get(compositionIndex); Map<String, String> ehr13606values = retrieveValues(composition, compositionIndex); return buildBody(ehr13606values); }	"protected MedicationMedicalRecordBodyType mapBody(final EHREXTRACT ehrExtract, final int compositionIndex) {
    final COMPOSITION composition = ehrExtract.getAllCompositions().get(compositionIndex);
    final MedicationMedicalRecordBodyType bodyType = new MedicationMedicalRecordBodyType();
    AdditionalPatientInformationType apit = new AdditionalPatientInformationType();
    apit.setDateOfBirth(STR);
    CVType gender = new CVType();
    gender.setCode(STR);
    gender.setCodeSystem(STR);
    gender.setDisplayName(STR);
    gender.setOriginalText(STR);
    apit.setGender(gender);
    bodyType.setAdditionalPatientInformation(apit);
    MedicationPrescriptionType mpt = new MedicationPrescriptionType();
    mpt.setDispensationAuthorization(new DispensationAuthorizationType());
    mpt.setEndOfTreatment(STR);
    mpt.setEndOfTreatmentReason(new CVType());
    mpt.setEvaluator(new HealthcareProfessionalType());
    mpt.setPrecedingPrescriptionId(new IIType());
    mpt.setPrescriber(new HealthcareProfessionalType());
    mpt.setPrescriptionChainId(new IIType());
    mpt.setPrescriptionId(new IIType());
    mpt.setPrescriptionStatus(new CVType());
    mpt.setSelfMedication(false);
    mpt.setStartOfFirstTreatment(STR);
    mpt.setSucceedingPrescriptionId(new IIType());
    mpt.setTypeOfPrescription(TypeOfPrescriptionEnum.INSTTNING);
    bodyType.setMedicationPrescription(mpt);
    for (final CONTENT content : composition.getContent()) {
        for (final ITEM item : ((ENTRY) content).getItems()) {
            log.debug(item.getMeaning().getCode() + STR + item.getMeaning().getDisplayName().getValue() + STR + (item instanceof ELEMENT ? STR : STR));
            switch(item.getMeaning().getCode()) {
                case STR:
                    mpt.setStartOfTreatment(STR);
                    log.debug(item.getMeaning().getCode() + STR + item.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) item));
                    break;
                case STR:
                    mpt.setPrescriptionNote(STR);
                    log.debug(item.getMeaning().getCode() + STR + item.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) item));
                    break;
                case STR:
                    mpt.setEvaluationTime(STR);
                    log.debug(item.getMeaning().getCode() + STR + item.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) item));
                    break;
                case STR:
                    mpt.setTreatmentPurpose(STR);
                    log.debug(item.getMeaning().getCode() + STR + item.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) item));
                    break;
                case STR:
                    log.debug(item.getMeaning().getCode() + STR + item.getMeaning().getDisplayName().getValue());
                    CLUSTER c = (CLUSTER) item;
                    List<ITEM> parts = c.getParts();
                    for (ITEM part : parts) {
                        log.debug(part.getMeaning().getCode());
                        if (STR.equals(part.getMeaning().getCode())) {
                            c = (CLUSTER) part;
                            List<ITEM> dosparts = c.getParts();
                            for (ITEM dospart : dosparts) {
                                log.debug(dospart.getMeaning().getCode() + STR + dospart.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) dospart));
                            }
                        }
                    }
                    break;
                case STR:
                    log.debug(item.getMeaning().getCode() + STR + item.getMeaning().getDisplayName().getValue());
                    c = (CLUSTER) item;
                    parts = c.getParts();
                    for (ITEM part : parts) {
                        log.debug(part.getMeaning().getCode());
                        switch(item.getMeaning().getCode()) {
                            case STR:
                                log.debug(part.getMeaning().getCode() + STR + part.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) part));
                                break;
                            case STR:
                                log.debug(part.getMeaning().getCode() + STR + part.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) part));
                                break;
                            case STR:
                                log.debug(part.getMeaning().getCode() + STR + part.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) part));
                                break;
                            case STR:
                                log.debug(part.getMeaning().getCode() + STR + part.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) part));
                                break;
                        }
                    }
                    break;
                case STR:
                    mpt.setStartOfTreatment(STR);
                    break;
                case STR:
                    log.debug(item.getMeaning().getCode() + STR + item.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) item));
                    break;
                case STR:
                    log.debug(item.getMeaning().getCode() + STR + item.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) item));
                    break;
                case STR:
                    log.debug(item.getMeaning().getCode() + STR + item.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) item));
                    break;
                case STR:
                    log.debug(item.getMeaning().getCode() + STR + item.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) item));
                    break;
                case STR:
                    log.debug(item.getMeaning().getCode() + STR + item.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) item));
                    break;
            }
        }
    }
    return bodyType;
}"	@return a new MedicationMedicalRecord	@return the target body information.	1	0	7	5	44
public TreeGraphNode headWordNode() { TreeGraphNode hwn = safeCast(label.get(TreeCoreAnnotations.HeadWordAnnotation.class)); if (hwn == null || (hwn.treeGraph() != null && !(hwn.treeGraph().equals(this.treeGraph())))) { return null; } return hwn; }	"  public TreeGraphNode headWordNode() {
    return headWordNode;
   }
"	@return the node containing the head word for this node	@return the node containing the head word for this node	0	1	8	8	59
public static Integer toEpochDay(Object value) { if ( value == null ) return null; return (int)Conversions.toLocalDate(value).toEpochDay(); }	"    public static Long toEpochDay(Object value) {
        if ( value == null ) return null;
        return Conversions.toLocalDate(value).toEpochDay();
    }
"	@return the number of days past epoch	@return the microseconds past midnight	1	0	6	5	31
public boolean isRunning() { lock.lock(); try { if (process == null) { return false; } process.exitValue(); return false; } catch (IllegalThreadStateException e) { return true; } finally { lock.unlock(); } }	"  public boolean isRunning() {
    lock.lock();
    try {
      if (process == null) {
        return false;
      }
      process.exitValue();
      return true;
    } catch (IllegalThreadStateException e) {
      return false;
    } finally {
      lock.unlock();
    }
  }
"	@return Whether the chromedriver child process is still running.	@return Whether the chromedriver child process is still running.	0	1	7	15	51
public FailoverListComposite getFailoverList() { return failoverList != null ? failoverList : new FailoverListComposite(new ArrayList<ServerEntry>()); }	"public FailoverListComposite getFailoverList() {
    return failoverList;
}"	@return the FailoverListComposite assigned to it by the server (will not be <code>null</code> but may be empty)	@return the FailoverListComposite assigned to it by the server	1	0	9	3	24
public static ClassLoader getProxyClassLoader() { return WrappedClob.class.getClassLoader(); }	"	public static ClassLoader getProxyClassLoader() {
		ClassLoader cl = ClassLoaderHelper.getContextClassLoader();
		if ( cl == null ) {
			cl = WrappedClob.class.getClassLoader();
		}
		return cl;
	}
"	@return The class loader appropriate for proxy construction.	@return The class loader appropriate for proxy construction.	0	1	5	4	15
"private Sheet getSheet() { int sheetIndex = 0; if (!readerConfig.sheetName.isEmpty()) { sheetIndex = workbook.getSheetIndex(readerConfig.sheetName); } //If the sheet name is not valid, throw user exception if (sheetIndex == -1) { throw UserException .validationError() .message(""Could not open sheet "" + readerConfig.sheetName) .build(logger); } else { return workbook.getSheetAt(sheetIndex); } }"	"  private XSSFSheet getSheet() {
    int sheetIndex = 0;
    if (!readerConfig.sheetName.isEmpty()) {
      sheetIndex = workbook.getSheetIndex(readerConfig.sheetName);
    }

    //If the sheet name is not valid, throw user exception
    if (sheetIndex == -1) {
      throw UserException
        .validationError()
        .message(""Could not open sheet "" + readerConfig.sheetName)
        .build(logger);
    } else {
      return workbook.getSheetAt(sheetIndex);
    }
  }
"	@return Sheet The selected sheet	@return XSSFSheet The selected sheet	1	0	9	17	83
"public String toDefaultValueWithParam(String name, Property p) { return "" = data."" + name + "";""; }"	"    public String toDefaultValueWithParam(String name, Property p) {
        if (p instanceof StringProperty) {
            return "" = data."" + name + "";"";
        } else if (p instanceof BooleanProperty) {
            return "" = data."" + name + "";"";
        } else if (p instanceof DateProperty) {
            return "" = data."" + name + "";"";
        } else if (p instanceof DateTimeProperty) {
            return "" = data."" + name + "";"";
        } else if (p instanceof DoubleProperty) {
            DoubleProperty dp = (DoubleProperty) p;
            if (dp.getDefault() != null) {
                return dp.getDefault().toString();
            }
            return "" = data."" + name + "";"";
        } else if (p instanceof FloatProperty) {
            FloatProperty dp = (FloatProperty) p;
            if (dp.getDefault() != null) {
                return dp.getDefault().toString();
            }
            return "" = data."" + name + "";"";
        } else if (p instanceof IntegerProperty) {
            IntegerProperty dp = (IntegerProperty) p;
            if (dp.getDefault() != null) {
                return dp.getDefault().toString();
            }
            return "" = data."" + name + "";"";
        } else if (p instanceof LongProperty) {
            LongProperty dp = (LongProperty) p;
            if (dp.getDefault() != null) {
                return dp.getDefault().toString();
            }
            return "" = data."" + name + "";"";
        } else {
            return "" = data."" + name + "";"";
        }
    }
"	@return string presentation of the default value of the property	@return string presentation of the default value of the property	0	1	6	4	23
public static long toMicroOfDay(Object value) { LocalTime time = Conversions.toLocalTime(value); return Math.floorDiv(time.toNanoOfDay(), Conversions.NANOSECONDS_PER_MICROSECOND); }	"    public static int toMicroOfDay(Object value) {
        LocalTime time = Conversions.toLocalTime(value);
        long micros = Math.floorDiv(time.toNanoOfDay(), Conversions.NANOSECONDS_PER_MICROSECOND);
        assert Math.abs(micros) < Integer.MAX_VALUE;
        return (int)micros;
    }
"	@return the microseconds past midnight	@return the microseconds past midnight	0	1	6	5	31
public String getSubject() { SubjectHeader subject = (SubjectHeader) getStackMessage().getHeader(SubjectHeader.NAME); if (subject != null) { return subject.getSubject(); } else { return STR; } }	"public String getSubject() {
    SubjectHeader subject = (SubjectHeader) getStackMessage().getHeader(SubjectHeader.NAME);
    if (subject != null) {
        return subject.getSubject();
    } else {
        return null;
    }
}"	@return Subject or empty	@return Subject or null if there is no subject	1	0	8	8	41
public long getResponseContentLength() { String contentLengthString = responseHeaders.getFirst(Headers.CONTENT_LENGTH); if (contentLengthString == null) { return -NUM; } return Long.parseLong(contentLengthString); }	"public Long getResponseContentLength() {
    String contentLengthString = responseHeaders.getFirst(Headers.CONTENT_LENGTH);
    if (contentLengthString == null) {
        return null;
    }
    return Long.parseLong(contentLengthString);
}"	@return The content length of the response, or <code>-1</code> if it has not been set	@return The content length of the response, or <code>null</code> if it has not been set	1	0	6	7	34
public String fixIdentifierCaseSensitve(String identifier) { try { List<String> databases = listDatabasesWithCache(); for (String database : databases) { if (identifier.equalsIgnoreCase(database)) { return database; } } List<String> tables = listTables(); for (String table : tables) { if (identifier.equalsIgnoreCase(table)) { return table; } } List<String> columns = listColumns(); for (String column : columns) { if (identifier.equalsIgnoreCase(column)) { return column; } } } catch (Exception e) { throw new IllegalStateException(e); } return identifier; }	"    public String fixIdentifierCaseSensitve(String identifier) {
        try {
            List<String> databases = listDatabasesWithCache();
            for (String db : databases) {
                if (db.equalsIgnoreCase(identifier)) {
                    return db;
                }
                List<String> tables = listTablesWithCache(db);
                for (String table : tables) {
                    if (table.equalsIgnoreCase(identifier)) {
                        return table;
                    }
                    List<String> cols = listColumnsWithCache(db, table);
                    for (String col : cols) {
                        if (col.equalsIgnoreCase(identifier)) {
                            return col;
                        }
                    }
                }
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        return identifier;
    }
"	@return identifier with case sensitive	@return identifier with case sensitive	0	1	9	26	116
"public String getSelectedIndex(String selectLocator) { return (String) seleneseMethods.get(""getSelectedIndex"").apply(driver, selectLocator); }"	"  public String getSelectedIndex(String selectLocator) {
    List<WebElement> options = getOptions(selectLocator);

    for (int i = 0; i < options.size(); i++) {
      WebElement option = options.get(i);
      if (option.isSelected())
        return String.valueOf(i);
    }

    throw new SeleniumException(""No option is selected: "" + selectLocator);
  }
"	@return the selected option index in the specified select drop-down	@return the selected option index in the specified select drop-down	0	1	7	4	27
"public static LocalDate fromCalendarFields(Calendar calendar) { if (calendar == null) { throw new IllegalArgumentException(""The calendar must not be null""); } int era = calendar.get(Calendar.ERA); int yearOfEra = calendar.get(Calendar.YEAR); return new LocalDate( (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra), calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH) ); }"	"    public static LocalDate fromCalendarFields(Calendar calendar) {
        if (calendar == null) {
            throw new IllegalArgumentException(""The calendar must not be null"");
        }
        return new LocalDate(
            calendar.get(Calendar.YEAR),
            calendar.get(Calendar.MONTH) + 1,
            calendar.get(Calendar.DAY_OF_MONTH)
        );
    }
"	@return the created local date, not null	@return the created LocalDate	1	0	7	13	82
public int appendRow(VectorContainer srcContainer, int srcIndex) { for (int vectorIndex = 0; vectorIndex < wrappers.size(); vectorIndex++) { ValueVector destVector = wrappers.get(vectorIndex).getValueVector(); ValueVector srcVector = srcContainer.wrappers.get(vectorIndex).getValueVector(); destVector.copyEntry(recordCount, srcVector, srcIndex); } return incRecordCount(); }	"    public int appendRow(VectorContainer srcContainer, int srcIndex) {
      for (int vectorIndex = 0; vectorIndex < wrappers.size(); vectorIndex++) {
        ValueVector destVector = wrappers.get(vectorIndex).getValueVector();
        ValueVector srcVector = srcContainer.wrappers.get(vectorIndex).getValueVector();
        destVector.copyEntry(recordCount, srcVector, srcIndex);
      }
      int pos = recordCount++;
      initialized = true;
      return pos;
    }
"	@return Position one above where the row was appended	@return Position where the row was appended	1	0	8	9	68
public TwitterTokenStream duplicate() { DuplicatedTokenStream duplicate = new DuplicatedTokenStream(inputStream); duplicatedStreams.add(duplicate); return duplicate; }	"public TokenStream duplicate() {
    DuplicatedTokenStream duplicate = new DuplicatedTokenStream(inputStream);
    duplicatedStreams.add(duplicate);
    return duplicate;
}"	@return a duplicated TwitterTokenStream	@return a duplicated TokenStream	1	0	6	5	24
public boolean equals(Object obj) { return this == obj || (obj instanceof Pair) && Objects.equals(this.left, ((Pair) obj).left) && Objects.equals(this.right, ((Pair) obj).right); }	"  public boolean equals(Object obj) {
    return this == obj
        || (obj instanceof Pair)
        && Objects.equal(this.left, ((Pair) obj).left)
        && com.google.common.base.Objects.equal(this.right, ((Pair) obj).right);
  }
"	@return A Pair	@return A Pair	0	1	9	7	52
public List<GmailMessage> getPriorityMessages(boolean unreadOnly) { try { final List<GmailMessage> priorityMessages = new ArrayList<GmailMessage>(); final Store store = openGmailStore(); Folder folder = getFolder(ImapGmailLabel.IMPORTANT.getName(), store); folder.open(Folder.READ_ONLY); for (final Message msg : folder.search(new FlagTerm(new Flags(Flags.Flag.SEEN), !unreadOnly))) { priorityMessages.add(new JavaMailGmailMessage(msg)); } return priorityMessages; } catch (final Exception e) { throw new GmailException(STR, e); } }	"public List<GmailMessage> getPriorityMessages() {
    try {
        final List<GmailMessage> unreadPriority = new ArrayList<GmailMessage>();
        final Store store = openGmailStore();
        Folder folder = getFolder(ImapGmailLabel.IMPORTANT.getName(), store);
        folder.open(Folder.READ_ONLY);
        for (final Message msg : folder.search(new FlagTerm(new Flags(Flags.Flag.SEEN), false))) {
            unreadPriority.add(new JavaMailGmailMessage(msg));
        }
        return unreadPriority;
    } catch (final Exception e) {
        throw new GmailException(STR, e);
    }
}"	@return List of unread/read priority messages	@return List of unread priority messages	1	0	9	14	107
private boolean hasSingleValue(ColumnStatistics columnStatistics, long rowCount) { return columnStatistics != null && isSingleVal(columnStatistics, rowCount); }	"  private boolean hasSingleValue(ColumnMetadata columnChunkMetaData, long rowCount) {
    return (columnChunkMetaData != null) && (columnChunkMetaData.hasSingleValue(rowCount));
  }
"	@return true if column has single value	@return true if column has single value	0	1	6	4	25
public static boolean isSameType(MajorType type1, MajorType type2) { return isSameTypeAndMode(type1, type2) && type1.getScale() == type2.getScale() && type1.getPrecision() == type2.getPrecision(); }	"  public static boolean isSameType(MajorType type1, MajorType type2) {
    return type1.getMinorType() == type2.getMinorType() &&
           type1.getMode() == type2.getMode() &&
           type1.getScale() == type2.getScale() &&
           type1.getPrecision() == type2.getPrecision();
  }
"	@return true if the two types have the same minor type, mode, precision and scale	@return true if the two types are are the same minor type, mode, precision and scale	1	0	7	6	41
protected MediaType mediaType() { return MediaType.APPLICATION_JSON_TYPE; }	"    protected MediaType mediaType() {
        return MediaType.TEXT_PLAIN_TYPE;
    }
"	@return the media type of the error message entity	@return the media type of the error message entity	0	1	4	4	11
public SimpleConfiguration getAppConfiguration() { return subset(APP_PREFIX); }	"public Configuration getAppConfiguration() {
    return subset(APP_PREFIX);
}"	@return A subset of this configuration using the prefix {@value #APP_PREFIX}. Any change made to subset will be reflected in this configuration, but with the prefix added. This method is useful for setting application configuration before initialization. For reading application configuration after initialization, see {@link FluoClient#getAppConfiguration()}	@return A {@link SubsetConfiguration} using the prefix {@value #APP_PREFIX}. Any change made to subset will be reflected in this configuration, but with the prefix added. This method is useful for setting application configuration before initialization. For reading application configuration after initialization, see {@link FluoClient#getAppConfiguration()}	1	0	5	3	13
"public static PeriodFormatter alternateWithWeeks() { if (cAlternateWithWeeks == null) { cAlternateWithWeeks = new PeriodFormatterBuilder() .appendLiteral(""P"") .printZeroAlways() .minimumPrintedDigits(4) .appendYears() .minimumPrintedDigits(2) .appendPrefix(""W"") .appendWeeks() .appendDays() .appendSeparatorIfFieldsAfter(""T"") .appendHours() .appendMinutes() .appendSecondsWithOptionalMillis() .toFormatter(); } return cAlternateWithWeeks; }"	"    public PeriodFormatter alternateWithWeeks() {
        if (iAlternateWithWeeks == null) {
            iAlternateWithWeeks = new PeriodFormatterBuilder()
                .appendLiteral(""P"")
                .printZeroAlways()
                .minimumPrintedDigits(4)
                .appendYears()
                .minimumPrintedDigits(2)
                .appendPrefix(""W"")
                .appendWeeks()
                .appendDays()
                .appendSeparatorIfFieldsAfter(""T"")
                .appendHours()
                .appendMinutes()
                .appendSecondsWithOptionalMillis()
                .toFormatter();
        }
        return iAlternateWithWeeks;
    }
"	@return the formatter	@return the formatter	0	1	9	20	74
public List<X_AD_ReplicationDocument> getReplicationDocuments() { final String whereClause = I_AD_ReplicationDocument.COLUMNNAME_AD_ReplicationStrategy_ID + STR; return new Query(getCtx(), I_AD_ReplicationDocument.Table_Name, whereClause, get_TrxName()).setClient_ID().setParameters(getAD_ReplicationStrategy_ID()).setOnlyActiveRecords(true).setApplyAccessFilter(false).list(); }	"public Collection<X_AD_ReplicationDocument> getReplicationDocuments() {
    String whereClause = STR;
    return new Query(getCtx(), X_AD_ReplicationDocument.Table_Name, whereClause, get_TrxName()).setClient_ID().setParameters(getAD_ReplicationStrategy_ID()).setOnlyActiveRecords(true).setApplyAccessFilter(false).list();
}"	@return the list the X_AD_ReplicationDocument	@return the collection the X_AD_ReplicationDocument	1	0	6	4	54
public String getMinimumJavaVersion() { return minimumJavaVersion; }	"public String getMinimumJavaVersion() {
    if (dependencies == null) {
        return STR;
    }
    return dependencies.getJavaVersion();
}"	@return the Java version, or {@code null} if no minimum.	@return the minimum Java version required to run this add-on or an empty {@code String} if no minimum version	1	0	4	3	10
public static HashMap getXmlRpcWorkflowInstance(WorkflowInstance wInst) { HashMap workflowInstance = new HashMap(); workflowInstance.put(STR, wInst.getCurrentTaskId()); workflowInstance.put(STR, wInst.getStatus()); workflowInstance.put(STR, wInst.getId()); workflowInstance.put(STR, getXmlRpcWorkflow(wInst.getWorkflow())); workflowInstance.put(STR, wInst.getStartDateTimeIsoStr() != null ? wInst.getStartDateTimeIsoStr() : STR); workflowInstance.put(STR, wInst.getEndDateTimeIsoStr() != null ? wInst.getEndDateTimeIsoStr() : STR); workflowInstance.put(STR, wInst.getCurrentTaskStartDateTimeIsoStr() != null ? wInst.getCurrentTaskStartDateTimeIsoStr() : STR); workflowInstance.put(STR, wInst.getCurrentTaskEndDateTimeIsoStr() != null ? wInst.getCurrentTaskEndDateTimeIsoStr() : STR); workflowInstance.put(STR, wInst.getSharedContext() != null ? wInst.getSharedContext().getMap() : new HashMap()); workflowInstance.put(STR, wInst.getPriority() != null ? String.valueOf(wInst.getPriority().getValue()) : String.valueOf(Priority.getDefault().getValue())); return workflowInstance; }	"public static Hashtable getXmlRpcWorkflowInstance(WorkflowInstance wInst) {
    Hashtable workflowInstance = new Hashtable();
    workflowInstance.put(STR, wInst.getCurrentTaskId());
    workflowInstance.put(STR, wInst.getStatus());
    workflowInstance.put(STR, wInst.getId());
    workflowInstance.put(STR, getXmlRpcWorkflow(wInst.getWorkflow()));
    workflowInstance.put(STR, wInst.getStartDateTimeIsoStr() != null ? wInst.getStartDateTimeIsoStr() : STR);
    workflowInstance.put(STR, wInst.getEndDateTimeIsoStr() != null ? wInst.getEndDateTimeIsoStr() : STR);
    workflowInstance.put(STR, wInst.getCurrentTaskStartDateTimeIsoStr() != null ? wInst.getCurrentTaskStartDateTimeIsoStr() : STR);
    workflowInstance.put(STR, wInst.getCurrentTaskEndDateTimeIsoStr() != null ? wInst.getCurrentTaskEndDateTimeIsoStr() : STR);
    workflowInstance.put(STR, wInst.getSharedContext() != null ? wInst.getSharedContext().getMap() : new Hashtable());
    workflowInstance.put(STR, wInst.getPriority() != null ? String.valueOf(wInst.getPriority().getValue()) : String.valueOf(Priority.getDefault().getValue()));
    return workflowInstance;
}"	@return A {@link HashMap} representation of a {@link WorkflowInstance}.	@return A {@link Hashtable} representation of a {@link WorkflowInstance}.	1	0	8	14	210
private Way getWayForNode(Node n) { Way way = null; for (Way w : Main.ds.ways) { int i = w.nodes.indexOf(n); if (i == -NUM) continue; if (i == NUM || i == w.nodes.size() - NUM) { if (way != null) return null; way = w; } } return way; }	"private Way getWayForNode(Node n) {
    Way way = null;
    for (Way w : Main.ds.ways) {
        for (Segment s : w.segments) {
            if (s.from == n || s.to == n) {
                if (way != null)
                    return null;
                if (s.from == s.to)
                    return null;
                way = w;
            }
        }
    }
    return way;
}"	@return If the node is the end of exactly one way, return this. <code>null</code> otherwise.	@return If the node is part of exactly one way, return this. <code>null</code> otherwise.	1	0	9	14	73
public static String quote(String name) { if ( name == null || name.length() == 0 || isQuoted( name ) ) { return name; } else { return new StringBuffer( name.length() + 2 ).append('`').append( name ).append( '`' ).toString(); } }	"	public static String quote(String name) {
		if ( name == null || name.length() == 0 || isQuoted( name ) ) {
			return name;
		}
		else {
			return new StringBuilder( name.length() + 2 ).append('`').append( name ).append( '`' ).toString();
		}
	}
"	@return The quoted version.	@return The quoted version.	0	1	8	9	65
List<String> getTempFiles() { List<String> tempFiles = new ArrayList<String>(); for (Entry<ManagedFile, FilePath> entry : file2Path.entrySet()) { boolean noTargetGiven = StringUtils.isBlank(entry.getKey().targetLocation); if (noTargetGiven) { tempFiles.add(entry.getValue().getRemote()); } } return tempFiles; }	"public List<FilePath> getTempFiles() {
    List<FilePath> tempFiles = new ArrayList<FilePath>();
    for (Entry<ManagedFile, FilePath> entry : file2Path.entrySet()) {
        boolean noTargetGiven = StringUtils.isBlank(entry.getKey().targetLocation);
        if (noTargetGiven) {
            tempFiles.add(entry.getValue());
        }
    }
    return tempFiles;
}"	@return a list of paths to the temp files (remotes)	@return a list of temp files	1	0	10	10	64
public RexNode apply(Integer i) { return rexBuilder.makeCall( SqlStdOperatorTable.EQUALS, leftKeys[i], bb.convertExpression( call.getOperands()[i])); }	"                      public RexNode apply(Integer i) {
                        return rexBuilder.makeCall(
                            SqlStdOperatorTable.equalsOperator,
                            leftKeys[i],
                            bb.convertExpression(
                                call.getOperands()[i]));
                      }
"	@return converted expression	@return converted expression	0	1	8	8	34
"protected boolean authenticate(ContainerRequestContext requestContext, C credentials, String scheme) { try { if (credentials == null) { return false; } final Optional<P> principal = authenticator.authenticate(credentials); if (!principal.isPresent()) { return false; } requestContext.setSecurityContext(new SecurityContext() { @Override public Principal getUserPrincipal() { return principal.get(); } @Override public boolean isUserInRole(String role) { return authorizer.authorize(principal.get(), role); } @Override public boolean isSecure() { return requestContext.getSecurityContext().isSecure(); } @Override public String getAuthenticationScheme() { return scheme; } }); return true; } catch (AuthenticationException e) { logger.warn(""Error authenticating credentials"", e); throw new InternalServerErrorException(); } }"	"    protected boolean authenticate(ContainerRequestContext requestContext, C credentials, String scheme) {
        try {
            if (credentials == null) {
                return false;
            }

            final Optional<P> principal = authenticator.authenticate(credentials);
            if (!principal.isPresent()) {
                return false;
            }

            final SecurityContext securityContext = requestContext.getSecurityContext();
            final boolean secure = securityContext != null && securityContext.isSecure();
            
            requestContext.setSecurityContext(new SecurityContext() {
                @Override
                public Principal getUserPrincipal() {
                    return principal.get();
                }

                @Override
                public boolean isUserInRole(String role) {
                    return authorizer.authorize(principal.get(), role);
                }

                @Override
                public boolean isSecure() {
                    return secure;
                }

                @Override
                public String getAuthenticationScheme() {
                    return scheme;
                }
            });
            return true;
        } catch (AuthenticationException e) {
            logger.warn(""Error authenticating credentials"", e);
            throw new InternalServerErrorException();
        }
    }
"	@return  true, if the request is authenticated, otherwise  false	@return true, if the request is authenticated, otherwise false	0	1	10	39	158
@NonNull protected List<Action> retrieveActions(@NonNull SCMRevision revision, @NonNull SCMHeadEvent event, @NonNull TaskListener listener) throws IOException, InterruptedException { return Collections.emptyList(); }	"@NonNull
protected Map<Class<? extends Action>, Action> retrieveActions(@NonNull SCMRevision revision, @NonNull TaskListener listener) throws IOException, InterruptedException {
    return Collections.emptyMap();
}"	@return the list of {@link Action} instances to persist.	@return the map of {@link Action} instances to persist, keyed by the class of action. Keys with {@code null} values indicate actions that should be removed if present.	1	0	5	4	34
public ApiResponse<Void> updatePetWithFormWithHttpInfo(Long petId, String name, String status) throws ApiException { okhttp3.Call localVarCall = updatePetWithFormValidateBeforeCall(petId, name, status, null, null); return localVarApiClient.execute(localVarCall); }	"    public ApiResponse<Void> updatePetWithFormWithHttpInfo(Long petId, String name, String status) throws ApiException {
        okhttp3.Call call = updatePetWithFormValidateBeforeCall(petId, name, status, null, null);
        return apiClient.execute(call);
    }
"	@return ApiResponse&lt;Void&gt;	@return ApiResponse&lt;Void&gt;	0	1	6	5	41
public static MatchFinder allOf(final MatchFinder... finders) { return new MatchFinder() { @Override public boolean matches(UiElement element) { for (MatchFinder finder : finders) { if (!finder.matches(element)) { return false; } } return true; } @Override public String toString() { return STR + Joiner.on(STR).join(finders) + STR; } }; }	"public static ElementMatcher allOf(final ElementMatcher... matchers) {
    return new ElementMatcher() {

        @Override
        public boolean matches(UiElement element) {
            for (ElementMatcher matcher : matchers) {
                if (!matcher.matches(element)) {
                    return false;
                }
            }
            return true;
        }

        @Override
        public String toString() {
            return STR + Joiner.on(STR).join(matchers) + STR;
        }
    };
}"	@return a finder that is the logical conjunction of given finders	@return a matcher that is the logical conjunction of given matchers	1	0	11	19	80
private int updateRedundancy() { int numBucketHosts = getNumInitializedBuckets(); if (!isClosed()) { redundancyTracker.updateStatistics(numBucketHosts); } return numBucketHosts; }	"private int updateRedundancy() {
    int desiredRedundancy = this.pRegion.getRedundantCopies();
    int numBucketHosts = getNumInitializedBuckets();
    if (isClosed()) {
        return numBucketHosts;
    }
    int actualRedundancy = numBucketHosts - NUM;
    this.redundancy = actualRedundancy;
    if (this.redundancySatisfied && numBucketHosts > NUM && actualRedundancy < desiredRedundancy) {
        incLowRedundancyBucketCount(NUM);
        this.redundancySatisfied = false;
    } else if (!this.redundancySatisfied && numBucketHosts > NUM && actualRedundancy >= desiredRedundancy) {
        incLowRedundancyBucketCount(-NUM);
        this.redundancySatisfied = true;
        this.redundancyEverSatisfied = true;
    }
    return numBucketHosts;
}"	@return number of current bucket hosts	@return current number of hosts for this bucket	1	0	7	7	31
public AnimationBuilder animateScale(float scale) { if (!isImageReady()) { return null; } return new AnimationBuilder(scale); }	"public ScaleAnimationBuilder animateScale(float scale) {
    if (!isImageReady()) {
        return null;
    }
    return new ScaleAnimationBuilder(scale);
}"	@return {@link AnimationBuilder} instance. Call {@link com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView.AnimationBuilder#start()} to start the anim.	@return {@link ScaleAnimationBuilder} instance. Call {@link com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView.ScaleAnimationBuilder#start()} to start the anim.	1	0	6	6	28
public ApiResponse<Client> testClassnameWithHttpInfo(Client body) throws ApiException { okhttp3.Call localVarCall = testClassnameValidateBeforeCall(body, null, null); Type localVarReturnType = new TypeToken<Client>(){}.getType(); return localVarApiClient.execute(localVarCall, localVarReturnType); }	"    public ApiResponse<Client> testClassnameWithHttpInfo(Client body) throws ApiException {
        okhttp3.Call call = testClassnameValidateBeforeCall(body, null, null);
        Type localVarReturnType = new TypeToken<Client>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }
"	@return ApiResponse&lt;Client&gt;	@return ApiResponse&lt;Client&gt;	0	1	8	6	46
public Node getSecondNode() { return m_node2; }	"public NodeItem getSecondNode() {
    return m_node2;
}"	@return the second (target) VisualItem	@return the second (target) GraphItem	1	0	4	3	10
"public static String getProgramFilesPath() { return getEnvVarPath(""ProgramFiles"", ""C:\\Program Files""); }"	"  public static String getProgramFilesPath() {
    loadEnvironment();
    String pf = getEnvVarIgnoreCase(""ProgramFiles"");
    if (pf != null) {
      File ProgramFiles = new File(pf);
      if (ProgramFiles.exists()) {
        return ProgramFiles.getAbsolutePath();
      }
    }
    return new File(""C:\\Program Files"").getAbsolutePath();
  }
"	@return the path to the Windows Program Files	@return the path to the Windows Program Files	0	1	5	4	25
@SuppressWarnings(STR) public static Triple<Treebank, Treebank, Treebank> getAnnotatedBinaryTreebankFromTreebank(Treebank trainTreebank, Treebank secondaryTreebank, Treebank tuneTreebank, Options op) { TreebankLangParserParams tlpParams = op.tlpParams; TreebankLanguagePack tlp = tlpParams.treebankLanguagePack(); if (op.testOptions.verbose) { PrintWriter pwErr = tlpParams.pw(System.err); pwErr.print(STR); pwErr.println(trainTreebank.textualSummary(tlp)); if (secondaryTreebank != null) { pwErr.print(STR); pwErr.println(secondaryTreebank.textualSummary(tlp)); } } System.err.print(STR); TreeAnnotatorAndBinarizer binarizer = buildTrainBinarizer(op); CompositeTreeTransformer trainTransformer = buildTrainTransformer(op, binarizer); Treebank wholeTreebank; if (secondaryTreebank == null) { wholeTreebank = trainTreebank; } else { wholeTreebank = new CompositeTreebank(trainTreebank, secondaryTreebank); } if (op.trainOptions.selectiveSplit) { op.trainOptions.splitters = ParentAnnotationStats.getSplitCategories(wholeTreebank, op.trainOptions.tagSelectiveSplit, NUM, op.trainOptions.selectiveSplitCutOff, op.trainOptions.tagSelectiveSplitCutOff, tlp); removeDeleteSplittersFromSplitters(tlp, op); if (op.testOptions.verbose) { List<String> list = new ArrayList<String>(op.trainOptions.splitters); Collections.sort(list); System.err.println(STR + list); } } if (op.trainOptions.selectivePostSplit) { TreeTransformer myTransformer = new TreeAnnotator(tlpParams.headFinder(), tlpParams, op); wholeTreebank = wholeTreebank.transform(myTransformer); op.trainOptions.postSplitters = ParentAnnotationStats.getSplitCategories(wholeTreebank, true, NUM, op.trainOptions.selectivePostSplitCutOff, op.trainOptions.tagSelectivePostSplitCutOff, tlp); if (op.testOptions.verbose) { System.err.println(STR + op.trainOptions.postSplitters); } } if (op.trainOptions.hSelSplit) { int ptt = op.trainOptions.printTreeTransformations; op.trainOptions.printTreeTransformations = NUM; binarizer.setDoSelectiveSplit(false); for (Tree tree : wholeTreebank) { trainTransformer.transformTree(tree); } binarizer.setDoSelectiveSplit(true); op.trainOptions.printTreeTransformations = ptt; } trainTreebank = trainTreebank.transform(trainTransformer); if (secondaryTreebank != null) { secondaryTreebank = secondaryTreebank.transform(trainTransformer); } if (op.trainOptions.printAnnotatedStateCounts) { binarizer.printStateCounts(); } if (op.trainOptions.printAnnotatedRuleCounts) { binarizer.printRuleCounts(); } if (tuneTreebank != null) { tuneTreebank = tuneTreebank.transform(trainTransformer); } Timing.tick(STR); if (op.testOptions.verbose) { binarizer.dumpStats(); } return new Triple<>(trainTreebank, secondaryTreebank, tuneTreebank); }	"public static Triple<Treebank, Treebank, Treebank> getAnnotatedBinaryTreebankFromTreebank(Treebank trainTreebank, Treebank secondaryTreebank, Treebank tuneTreebank, Options op) {
    TreebankLangParserParams tlpParams = op.tlpParams;
    TreebankLanguagePack tlp = tlpParams.treebankLanguagePack();
    if (op.testOptions.verbose) {
        PrintWriter pwErr = tlpParams.pw(System.err);
        pwErr.print(STR);
        pwErr.println(trainTreebank.textualSummary(tlp));
        if (secondaryTreebank != null) {
            pwErr.print(STR);
            pwErr.println(secondaryTreebank.textualSummary(tlp));
        }
    }
    System.err.print(STR);
    TreeAnnotatorAndBinarizer binarizer = buildTrainBinarizer(op);
    CompositeTreeTransformer trainTransformer = buildTrainTransformer(op, binarizer);
    Treebank wholeTreebank;
    if (secondaryTreebank == null) {
        wholeTreebank = trainTreebank;
    } else {
        wholeTreebank = new CompositeTreebank(trainTreebank, secondaryTreebank);
    }
    if (op.trainOptions.selectiveSplit) {
        op.trainOptions.splitters = ParentAnnotationStats.getSplitCategories(wholeTreebank, op.trainOptions.tagSelectiveSplit, NUM, op.trainOptions.selectiveSplitCutOff, op.trainOptions.tagSelectiveSplitCutOff, tlp);
        removeDeleteSplittersFromSplitters(tlp, op);
        if (op.testOptions.verbose) {
            List<String> list = new ArrayList<String>(op.trainOptions.splitters);
            Collections.sort(list);
            System.err.println(STR + list);
        }
    }
    if (op.trainOptions.selectivePostSplit) {
        TreeTransformer myTransformer = new TreeAnnotator(tlpParams.headFinder(), tlpParams, op);
        wholeTreebank = wholeTreebank.transform(myTransformer);
        op.trainOptions.postSplitters = ParentAnnotationStats.getSplitCategories(wholeTreebank, true, NUM, op.trainOptions.selectivePostSplitCutOff, op.trainOptions.tagSelectivePostSplitCutOff, tlp);
        if (op.testOptions.verbose) {
            System.err.println(STR + op.trainOptions.postSplitters);
        }
    }
    if (op.trainOptions.hSelSplit) {
        int ptt = op.trainOptions.printTreeTransformations;
        op.trainOptions.printTreeTransformations = NUM;
        binarizer.setDoSelectiveSplit(false);
        for (Tree tree : wholeTreebank) {
            trainTransformer.transformTree(tree);
        }
        binarizer.setDoSelectiveSplit(true);
        op.trainOptions.printTreeTransformations = ptt;
    }
    trainTreebank = trainTreebank.transform(trainTransformer);
    if (secondaryTreebank != null) {
        secondaryTreebank = secondaryTreebank.transform(trainTransformer);
    }
    if (op.trainOptions.printAnnotatedStateCounts) {
        binarizer.printStateCounts();
    }
    if (op.trainOptions.printAnnotatedRuleCounts) {
        binarizer.printRuleCounts();
    }
    if (tuneTreebank != null) {
        tuneTreebank = tuneTreebank.transform(trainTransformer);
    }
    Timing.tick(STR);
    if (op.testOptions.verbose) {
        binarizer.dumpStats();
    }
    return new Triple<Treebank, Treebank, Treebank>(trainTreebank, secondaryTreebank, tuneTreebank);
}"	@return A triple of binaryTrainTreebank, binarySecondaryTrainTreebank, binaryTuneTreebank.	@return a pair of binaryTrainTreebank,binaryTuneTreebank.	1	0	12	68	437
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 38: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, yytext()); } case 55: break; case 43: // general lookahead, find correct zzMarkedPos { int zzFState = 9; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 10; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { // try to work around an apparent jflex bug where it // gets a space at the token end by getting // wrong the length of the trailing context. while (yylength() > 0) { char last = yycharat(yylength()-1); if (last == ' ' || last == '\t' || (last >= '\n' && last <= '\r' || last == '\u0085')) { yypushback(1); } else { break; } } return getNext(); } case 56: break; case 11: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 57: break; case 19: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 58: break; case 8: { return handleQuotes(yytext(), false); } case 59: break; case 35: // lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), false); } case 60: break; case 27: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 61: break; case 33: // lookahead expression with fixed lookahead length yypushback(1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 62: break; case 49: // lookahead expression with fixed lookahead length yypushback(1); { return getNormalizedAmpNext(); } case 63: break; case 36: { return getNormalizedAmpNext(); } case 64: break; case 23: { if (invertible) { prevWordAfter.append(yytext()); } } case 65: break; case 37: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, yytext()); } case 66: break; case 53: // lookahead expression with fixed lookahead length yypushback(4); { return getNext(); } case 67: break; case 46: // lookahead expression with fixed lookahead length yypushback(2); { return getNext(); } case 68: break; case 42: // general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 69: break; case 41: // general lookahead, find correct zzMarkedPos { int zzFState = 16; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 17; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 70: break; case 40: // general lookahead, find correct zzMarkedPos { int zzFState = 13; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 71: break; case 3: { return getNext(); } case 72: break; case 24: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(); } case 73: break; case 51: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } return getNext(txt, yytext()); } case 74: break; case 26: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, origTxt); } case 75: break; case 6: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 76: break; case 29: // general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 77: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 78: break; case 2: { return getNext(""<"", yytext()); } case 79: break; case 30: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 80: break; case 18: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 81: break; case 54: { String txt = yytext(); if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 82: break; case 50: { yypushback(3) ; return getNext(); } case 83: break; case 25: // lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), true); } case 84: break; case 39: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 85: break; case 21: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 86: break; case 17: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 87: break; case 13: { return handleEllipsis(yytext()); } case 88: break; case 34: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 1; { /* invert quote - often but not always right */ return handleQuotes(yytext(), true); } case 89: break; case 14: { return normalizeFractions(yytext()); } case 90: break; case 15: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(); } } case 91: break; case 47: // general lookahead, find correct zzMarkedPos { int zzFState = 11; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 12; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 92: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 93: break; case 9: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 94: break; case 45: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 95: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 96: break; case 28: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 97: break; case 48: { if (keepAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 98: break; case 20: { if (normalizeOtherBrackets) { return getNext(""-RSB-"", yytext()); } else { return getNext(); } } case 99: break; case 12: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 100: break; case 31: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 101: break; case 10: { return getNext("">"", yytext()); } case 102: break; case 32: { // this one should only match if we're basically at the end of file // since the last one matches two things, even newlines String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 103: break; case 22: { if (normalizeOtherBrackets) { return getNext(""-LSB-"", yytext()); } else { return getNext(); } } case 104: break; case 52: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { // try to work around an apparent jflex bug where it // gets a space at the token end by getting // wrong the length of the trailing context. while (yylength() > 0) { char last = yycharat(yylength()-1); if (last == ' ' || last == '\t' || (last >= '\n' && last <= '\r' || last == '\u0085')) { yypushback(1); } else { break; } } String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 105: break; case 1: { String str = yytext(); int first = str.charAt(0); String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } LOGGER.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: LOGGER.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 106: break; case 44: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 107: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 108: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }"	"  public Object next() throws java.io.IOException {
    int zzInput;
    int zzAction;

    // cached fields:
    int zzCurrentPosL;
    int zzMarkedPosL;
    int zzEndReadL = zzEndRead;
    char [] zzBufferL = zzBuffer;
    char [] zzCMapL = ZZ_CMAP;

    int [] zzTransL = ZZ_TRANS;
    int [] zzRowMapL = ZZ_ROWMAP;
    int [] zzAttrL = ZZ_ATTRIBUTE;

    while (true) {
      zzMarkedPosL = zzMarkedPos;

      yychar+= zzMarkedPosL-zzStartRead;

      zzAction = -1;

      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
  
      zzState = ZZ_LEXSTATE[zzLexicalState];


      zzForAction: {
        while (true) {
    
          if (zzCurrentPosL < zzEndReadL)
            zzInput = zzBufferL[zzCurrentPosL++];
          else if (zzAtEOF) {
            zzInput = YYEOF;
            break zzForAction;
          }
          else {
            // store back cached positions
            zzCurrentPos  = zzCurrentPosL;
            zzMarkedPos   = zzMarkedPosL;
            boolean eof = zzRefill();
            // get translated positions and possibly new buffer
            zzCurrentPosL  = zzCurrentPos;
            zzMarkedPosL   = zzMarkedPos;
            zzBufferL      = zzBuffer;
            zzEndReadL     = zzEndRead;
            if (eof) {
              zzInput = YYEOF;
              break zzForAction;
            }
            else {
              zzInput = zzBufferL[zzCurrentPosL++];
            }
          }
          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
          if (zzNext == -1) break zzForAction;
          zzState = zzNext;

          int zzAttributes = zzAttrL[zzState];
          if ( (zzAttributes & 1) == 1 ) {
            zzAction = zzState;
            zzMarkedPosL = zzCurrentPosL;
            if ( (zzAttributes & 8) == 8 ) break zzForAction;
          }

        }
      }

      // store back cached position
      zzMarkedPos = zzMarkedPosL;

      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
        case 39: 
          { String txt = yytext();
                  if (escapeForwardSlashAsterisk) {
                    txt = delimit(txt, '/');
                  }
                  if (normalizeSpace) {
                    // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                    txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space

                  }
                  return getNext(txt, yytext());
          }
        case 55: break;
        case 43: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 9;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 10;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { // try to work around an apparent jflex bug where it
                          // gets a space at the token end by getting
                          // wrong the length of the trailing context.
                          while (yylength() > 0) {
                            char last = yycharat(yylength()-1);
                            if (last == ' ' || last == '\t' || (last >= '\n' && last <= '\r' || last == '\u0085')) {
                              yypushback(1);
                            } else {
                              break;
                            }
                          }
			  return getNext();
          }
        case 56: break;
        case 11: 
          { if (ptb3Dashes) {
                            return getNext(ptbmdash, yytext()); }
                          else {
                            return getNext();
                          }
          }
        case 57: break;
        case 19: 
          { if (escapeForwardSlashAsterisk) {
                    return getNext(delimit(yytext(), '*'), yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 58: break;
        case 36: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return handleQuotes(yytext(), false);
          }
        case 59: break;
        case 8: 
          { return handleQuotes(yytext(), false);
          }
        case 60: break;
        case 28: 
          { String txt = yytext();
                  String origText = txt;
                  if (normalizeParentheses) {
                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                  }
                  return getNext(txt, origText);
          }
        case 61: break;
        case 34: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { String txt = yytext();
                  String origText = txt;
                  if (normalizeParentheses) {
                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                  }
                  return getNext(txt, origText);
          }
        case 62: break;
        case 49: 
          { if (splitAssimilations) {
                            yypushback(2) ; return getNext();
                          } else {
                            return getNext();
                          }
          }
        case 63: break;
        case 50: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return getNormalizedAmpNext();
          }
        case 64: break;
        case 37: 
          { return getNormalizedAmpNext();
          }
        case 65: break;
        case 23: 
          { if (invertible) {
                            prevWordAfter.append(yytext());
                        }
          }
        case 66: break;
        case 38: 
          { String txt = yytext();
                  if (escapeForwardSlashAsterisk) {
                    txt = delimit(txt, '/');
                  }
                  if (normalizeSpace) {
                    // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                    txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                  }
                  return getNext(txt, yytext());
          }
        case 67: break;
        case 53: 
          // lookahead expression with fixed lookahead length
          yypushback(4);
          { return getNext();
          }
        case 68: break;
        case 47: 
          // lookahead expression with fixed lookahead length
          yypushback(2);
          { return getNext();
          }
        case 69: break;
        case 46: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 7;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 8;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { // try to work around an apparent jflex bug where it
                          // gets a space at the token end by getting
                          // wrong the length of the trailing context.
                          while (yylength() > 0) {
                            char last = yycharat(yylength()-1);
                            if (last == ' ' || last == '\t' || (last >= '\n' && last <= '\r' || last == '\u0085')) {
                              yypushback(1);
                            } else {
                              break;
                            }
                          }
                          String s;
			  if (yylength() == 2) { // ""I."", etc.
			    yypushback(1); // return a period next time;
			    s = yytext(); // return the word without the final period
                          } else if (strictTreebank3 && ! ""U.S."".equals(yytext())) {
                            yypushback(1); // return a period for next time
                            s = yytext(); // return the word without the final period
                          } else {
                            s = yytext(); // return the word WITH the final period
                            yypushback(1); // (redpulication:) also return a period for next time
                          }
                          return getNext(s, yytext());
          }
        case 70: break;
        case 42: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 15;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 14;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { return getNext();
          }
        case 71: break;
        case 41: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 16;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 17;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { return getNext();
          }
        case 72: break;
        case 3: 
          { return getNext();
          }
        case 73: break;
        case 24: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 13;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 14;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { return getNext();
          }
        case 74: break;
        case 25: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return getNext();
          }
        case 75: break;
        case 52: 
          { String txt = yytext();
                          if (escapeForwardSlashAsterisk) {
                            txt = delimit(txt, '/');
                          }
                          return getNext(txt, yytext());
          }
        case 76: break;
        case 27: 
          { final String origTxt = yytext();
                          String txt = origTxt;
                          if (normalizeSpace) {
                            // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                            txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                          }
                          return getNext(txt, origTxt);
          }
        case 77: break;
        case 6: 
          { final String origTxt = yytext();
                          String tmp = removeSoftHyphens(origTxt);
                          if (americanize) {
                            tmp = Americanize.americanize(tmp);
                          }
                          return getNext(tmp, origTxt);
          }
        case 78: break;
        case 30: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 3;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 4;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { final String origTxt = yytext();
                          String tmp = removeSoftHyphens(origTxt);
                          if (americanize) {
                            tmp = Americanize.americanize(tmp);
                          }
                          return getNext(tmp, origTxt);
          }
        case 79: break;
        case 16: 
          { if (normalizeOtherBrackets) {
                    return getNext(closebrace, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 80: break;
        case 2: 
          { return getNext(""<"", yytext());
          }
        case 81: break;
        case 31: 
          { if (escapeForwardSlashAsterisk) {
                            return getNext(delimit(yytext(), '/'), yytext());
                          } else {
                            return getNext();
                          }
          }
        case 82: break;
        case 18: 
          { if (normalizeParentheses) {
                    return getNext(closeparen, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 83: break;
        case 54: 
          { String txt = yytext();
                          if (normalizeSpace) {
                            // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                            txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                          }
                          if (normalizeParentheses) {
                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                          }
                          return getNext(txt, yytext());
          }
        case 84: break;
        case 26: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return handleQuotes(yytext(), true);
          }
        case 85: break;
        case 40: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 5;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 6;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { final String txt = yytext();
                          return getNext(removeSoftHyphens(txt),
                                         txt);
          }
        case 86: break;
        case 21: 
          { if (normalizeOtherBrackets) {
                    return getNext(openbrace, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 87: break;
        case 51: 
          { if (splitAssimilations) {
                            yypushback(3) ; return getNext();
                          } else {
                            return getNext();
                          }
          }
        case 88: break;
        case 17: 
          { if (normalizeParentheses) {
                    return getNext(openparen, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 89: break;
        case 13: 
          { return handleEllipsis(yytext());
          }
        case 90: break;
        case 35: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 1;
          { /* invert quote - often but not always right */
                  return handleQuotes(yytext(), true);
          }
        case 91: break;
        case 14: 
          { return normalizeFractions(yytext());
          }
        case 92: break;
        case 15: 
          { if (normalizeCurrency) {
                            return getNext(normalizeCurrency(yytext()), yytext()); }
                          else {
                            return getNext();
                          }
          }
        case 93: break;
        case 48: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 11;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 12;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { String s;
                          if (strictTreebank3 && ! ""U.S."".equals(yytext())) {
                            yypushback(1); // return a period for next time
                            s = yytext();
                          } else {
                            s = yytext();
                            yypushback(1); // return a period for next time
                          }
                          return getNext(s, yytext());
          }
        case 94: break;
        case 7: 
          { if (invertible) {
                     prevWordAfter.append(yytext());
                  }
          }
        case 95: break;
        case 9: 
          { if (escapeForwardSlashAsterisk) {
                    return getNext(delimit(yytext(), '/'), yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 96: break;
        case 45: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return getNext(removeSoftHyphens(yytext()),
                                               yytext());
          }
        case 97: break;
        case 4: 
          { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {
                    return getNext(ptbmdash, yytext());
                  } else {
                    return getNext();
                  }
          }
        case 98: break;
        case 29: 
          { return getNext(removeSoftHyphens(yytext()), yytext());
          }
        case 99: break;
        case 20: 
          { if (normalizeOtherBrackets) {
                    return getNext(""-RSB-"", yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 100: break;
        case 12: 
          { return getNext(removeSoftHyphens(yytext()),
                                         yytext());
          }
        case 101: break;
        case 32: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return getNext(removeSoftHyphens(yytext()),
                                         yytext());
          }
        case 102: break;
        case 10: 
          { return getNext("">"", yytext());
          }
        case 103: break;
        case 33: 
          { // this one should only match if we're basically at the end of file
                          // since the last one matches two things, even newlines
                          String s;
                          if (strictTreebank3 && ! ""U.S."".equals(yytext())) {
                            yypushback(1); // return a period for next time
                            s = yytext();
                          } else {
                            s = yytext();
                            yypushback(1); // return a period for next time
                          }
                          return getNext(s, yytext());
          }
        case 104: break;
        case 22: 
          { if (normalizeOtherBrackets) {
                    return getNext(""-LSB-"", yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 105: break;
        case 1: 
          { String str = yytext();
          int first = str.charAt(0);
          String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));
          switch (untokenizable) {
            case NONE_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              break;
            case FIRST_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              if ( ! this.seenUntokenizableCharacter) {
                LOGGER.warning(msg);
                this.seenUntokenizableCharacter = true;
              }
              break;
            case ALL_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              LOGGER.warning(msg);
              this.seenUntokenizableCharacter = true;
              break;
            case NONE_KEEP:
              return getNext();
            case FIRST_KEEP:
              if ( ! this.seenUntokenizableCharacter) {
                LOGGER.warning(msg);
                this.seenUntokenizableCharacter = true;
              }
              return getNext();
            case ALL_KEEP:
              LOGGER.warning(msg);
              this.seenUntokenizableCharacter = true;
              return getNext();
          }
          }
        case 106: break;
        case 44: 
          { String txt = yytext();
                          if (escapeForwardSlashAsterisk) {
                            txt = delimit(txt, '/');
                            txt = delimit(txt, '*');
                          }
                          return getNext(txt, yytext());
          }
        case 107: break;
        case 5: 
          { if (tokenizeNLs) {
                      return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns
                  } else if (invertible) {
                      prevWordAfter.append(yytext());
                  }
          }
        case 108: break;
        default: 
          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
            zzAtEOF = true;
              {
                if (invertible) {
            prevWordAfter.append(yytext());
            String str = prevWordAfter.toString();
            prevWordAfter.setLength(0);
            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);
          }
          return null;
              }
          } 
          else {
            zzScanError(ZZ_NO_MATCH);
          }
      }
    }
  }
"	@return the next token	@return the next token	0	1	17	702	4305
private String getHostname(final InetAddress remote) throws FirewallException { FutureTask<String> lookup = new FutureTask<String>(new Callable<String>() { public String call() { return remote.getCanonicalHostName(); } }); DNS_LOOKUP.execute(lookup); try { return lookup.get(DNS_TIMEOUT, TimeUnit.MILLISECONDS); } catch (Exception e) { return null; } finally { lookup.cancel(true); } }	"private String getHostname(final InetAddress remote) {
    final String[] hostname = new String[] { null };
    final AtomicBoolean done = new AtomicBoolean(false);
    Thread thread = new Thread(new Runnable() {

        public void run() {
            hostname[NUM] = remote.getCanonicalHostName();
            done.getAndSet(true);
            synchronized (done) {
                done.notifyAll();
            }
        }
    });
    thread.run();
    long endTime = System.currentTimeMillis() + DNS_TIMEOUT;
    while (System.currentTimeMillis() < endTime && !done.get()) {
        try {
            synchronized (done) {
                done.wait(endTime - System.currentTimeMillis());
            }
        } catch (InterruptedException e) {
        }
    }
    return hostname[NUM];
}"	@return the hostname, null if not found, takes longer than 30s to find or otherwise fails	@return the hostname, null if not found or takes longer than 30s to find	1	0	9	16	79
"public static GrammaticalRelation getAcl(String aclString) { /* Check for nmod subtypes which are not stored in the `nmods` map. */ if (aclString.equals(""relcl"")) { return RELATIVE_CLAUSE_MODIFIER; } GrammaticalRelation result = acls.get(aclString); if (result == null) { synchronized(acls) { result = acls.get(aclString); if (result == null) { result = new GrammaticalRelation(Language.UniversalEnglish, ""acl"", ""acl_preposition"", CLAUSAL_MODIFIER, aclString); acls.put(aclString, result); threadSafeAddRelation(result); } } } return result; }"	"  public static GrammaticalRelation getAcl(String aclString) {
    GrammaticalRelation result = acls.get(aclString);
    if (result == null) {
      synchronized(acls) {
        result = acls.get(aclString);
        if (result == null) {
          result = new GrammaticalRelation(Language.UniversalEnglish, ""acl"", ""acl_preposition"", CLAUSAL_MODIFIER, aclString);
          acls.put(aclString, result);
          threadSafeAddRelation(result);
        }
      }
    }
    return result;
  }
"	@return A grammatical relation for this preposition	@return A grammatical relation for this preposition	0	1	11	21	112
public static List<SLARegistrationBean> fromJSONArray(JSONArray array) { List<SLARegistrationBean> list = new ArrayList<SLARegistrationBean>(); for (Object obj : array) { list.add(new SLARegistrationBean((JSONObject) obj)); } return list; }	"public static List<SLAEvent> fromJSONArray(JSONArray array) {
    List<SLAEvent> list = new ArrayList<SLAEvent>();
    for (Object obj : array) {
        list.add(new JsonSLARegistrationEvent((JSONObject) obj));
    }
    return list;
}"	@return the corresponding SLA SLARegistrationBean list.	@return the corresponding SLA event list.	1	0	9	7	45
private GraphQLInputType buildInputType(BuildContext buildCtx, Type rawType) { TypeDefinition typeDefinition = buildCtx.getTypeDefinition(rawType); TypeInfo typeInfo = TypeInfo.typeInfo(rawType); GraphQLInputType inputType = buildCtx.hasInputType(typeDefinition); if (inputType != null) { return typeInfo.decorate(inputType); } if (buildCtx.stackContains(typeInfo)) { // we have circled around so put in a type reference and fix it later return typeInfo.decorate(new GraphQLTypeReference(typeInfo.getName())); } buildCtx.push(typeInfo); if (typeDefinition instanceof InputObjectTypeDefinition) { inputType = buildInputObjectType(buildCtx, (InputObjectTypeDefinition) typeDefinition); } else if (typeDefinition instanceof EnumTypeDefinition) { inputType = buildEnumType((EnumTypeDefinition) typeDefinition); } else { inputType = buildScalar(buildCtx, (ScalarTypeDefinition) typeDefinition); } buildCtx.put(inputType); buildCtx.pop(); return typeInfo.decorate(inputType); }	"    private GraphQLInputType buildInputType(BuildContext buildCtx, Type rawType) {

        TypeDefinition typeDefinition = buildCtx.getTypeDefinition(rawType);

        GraphQLInputType inputType = buildCtx.hasInputType(typeDefinition);
        if (inputType != null) {
            return inputType;
        }
        TypeInfo typeInfo = TypeInfo.typeInfo(rawType);

        if (buildCtx.stackContains(typeInfo)) {
            // we have circled around so put in a type reference and fix it later
            return typeInfo.decorate(new GraphQLTypeReference(typeInfo.getName()));
        }

        buildCtx.push(typeInfo);

        if (typeDefinition instanceof InputObjectTypeDefinition) {
            inputType = buildInputObjectType(buildCtx, (InputObjectTypeDefinition) typeDefinition);
        } else if (typeDefinition instanceof EnumTypeDefinition) {
            inputType = buildEnumType((EnumTypeDefinition) typeDefinition);
        } else {
            inputType = buildScalar(buildCtx, (ScalarTypeDefinition) typeDefinition);
        }

        buildCtx.put(inputType);
        buildCtx.pop();
        return typeInfo.decorate(inputType);
    }
"	@return an output type	@return an output type	0	1	10	30	166
"public static ExpectedCondition<Boolean> textToBe(final By locator, final String value) { return new ExpectedCondition<Boolean>() { private String currentValue = null; @Override public Boolean apply(WebDriver driver) { try { currentValue = driver.findElement(locator).getText(); return currentValue.equals(value); } catch (Exception e) { return false; } } @Override public String toString() { return String.format(""element found by %s to have text \""%s\"". Current text: \""%s\"""", locator, value, currentValue); } }; }"	"  public static ExpectedCondition<Boolean> textToBe(final By locator, final String value) {
    return new ExpectedCondition<Boolean>() {
      private String currentValue = null;

      @Override
      public Boolean apply(WebDriver driver) {
        try {
          currentValue = driver.findElement(locator).getText();
          return currentValue.equals(value);
        } catch (Exception e) {
          return false;
        }
      }

      @Override
      public String toString() {
        return String.format(""text to be \""%s\"". Current text: \""%s\"""", value, currentValue);
      }
    };
  }
"	@return Boolean true when element has text value equal to 	@return Boolean true when element has text value equal to	0	1	10	22	117
public byte[] getObjectDigest() { if (holder.getObjectDigestInfo() != null) { return holder.getObjectDigestInfo().getObjectDigest().getBytes(); } return null; }	"public byte[] getObjectDigest() {
    if (holder.getObjectDigestInfo() != null) {
        holder.getObjectDigestInfo().getObjectDigest().getBytes();
    }
    return null;
}"	@return The hash or <code>null</code> if ObjectDigestInfo is absent.	@return The hash or <code>null</code> if no object digest info is set.	1	0	7	6	35
static Folder fromXml(Launcher launcher) { return (Folder) LayoutInflater.from(launcher).inflate(R.layout.user_folder, launcher.getDragLayer(), false); }	"    static Folder fromXml(Context context) {
        return (Folder) LayoutInflater.from(context).inflate(R.layout.user_folder, null);
    }
"	@return A new UserFolder.	@return A new UserFolder.	0	1	7	5	32
public short get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }	"public short get(WithAttributes attributes) {
    return attributes.getAttributes().get(this);
}"	@return the value of this attribute if this attribute is present in the extracted map. Otherwise {@link #getDefaultValue()}	@return the value of this attribute if this attribute is present in the map. Otherwise {@link #getDefaultValue()}	1	0	6	3	19
public static BinaryVisitor<String, Writer> write() { return new Write(); }	"public static BinaryPredicate<String, Writer> write() {
    return new Write();
}"	@return a {@link BinaryVisitor} that will call {@code write(x)} on the {@link java.io.Writer} {@code y}	@return a {@link BinaryPredicate} that will call {@code write(x)} on the {@link java.io.Writer} {@code y}	1	0	5	3	17
public ComponentAdapter createComponentAdapter(ComponentMonitor componentMonitor, LifecycleStrategy lifecycleStrategy, ComponentCharacteristic registerationCharacteristic, Object componentKey, Class componentImplementation, Parameter... parameters) throws PicoIntrospectionException, AssignabilityRegistrationException, NotConcreteRegistrationException { return new SetterInjectionComponentAdapter(componentKey, componentImplementation, parameters, componentMonitor, lifecycleStrategy); }	"public ComponentAdapter createComponentAdapter(ComponentCharacteristic registerationCharacteristic, Object componentKey, Class componentImplementation, Parameter... parameters) throws PicoIntrospectionException, AssignabilityRegistrationException, NotConcreteRegistrationException {
    return new SetterInjectionComponentAdapter(componentKey, componentImplementation, parameters, currentMonitor(), lifecycleStrategy);
}"	the number of the setter. @return Returns a new {@link org.picocontainer.adapters.SetterInjectionComponentAdapter}. @throws PicoIntrospectionException if dependencies cannot be solved	the number of the setter. @return Returns a new {@link SetterInjectionComponentAdapter}.	1	0	5	3	45
"protected FieldValueInfo completeField(ExecutionContext executionContext, ExecutionStrategyParameters parameters, Object fetchedValue) { Field field = parameters.getField().get(0); GraphQLObjectType parentType = parameters.getTypeInfo().castType(GraphQLObjectType.class); GraphQLFieldDefinition fieldDef = getFieldDef(executionContext.getGraphQLSchema(), parentType, field); ExecutionTypeInfo fieldTypeInfo = fieldTypeInfo(parameters, fieldDef); Instrumentation instrumentation = executionContext.getInstrumentation(); InstrumentationFieldCompleteParameters instrumentationParams = new InstrumentationFieldCompleteParameters(executionContext, parameters, fieldDef, fieldTypeInfo, fetchedValue); InstrumentationContext<ExecutionResult> ctxCompleteField = instrumentation.beginFieldComplete( instrumentationParams ); GraphqlFieldVisibility fieldVisibility = executionContext.getGraphQLSchema().getFieldVisibility(); Map<String, Object> argumentValues = valuesResolver.getArgumentValues(fieldVisibility, fieldDef.getArguments(), field.getArguments(), executionContext.getVariables()); NonNullableFieldValidator nonNullableFieldValidator = new NonNullableFieldValidator(executionContext, fieldTypeInfo); ExecutionStrategyParameters newParameters = parameters.transform(builder -> builder.typeInfo(fieldTypeInfo) .arguments(argumentValues) .source(fetchedValue) .nonNullFieldValidator(nonNullableFieldValidator) ); log.debug(""'{}' completing field '{}'..."", executionContext.getExecutionId(), fieldTypeInfo.getPath()); FieldValueInfo fieldValueInfo = completeValue(executionContext, newParameters); CompletableFuture<ExecutionResult> executionResultFuture = fieldValueInfo.getFieldValue(); ctxCompleteField.onDispatched(executionResultFuture); executionResultFuture.whenComplete(ctxCompleteField::onCompleted); return fieldValueInfo; }"	"    protected CompletableFuture<ExecutionResult> completeField(ExecutionContext executionContext, ExecutionStrategyParameters parameters, Object fetchedValue) {
        Field field = parameters.getField().get(0);
        GraphQLObjectType parentType = parameters.getTypeInfo().castType(GraphQLObjectType.class);
        GraphQLFieldDefinition fieldDef = getFieldDef(executionContext.getGraphQLSchema(), parentType, field);
        ExecutionTypeInfo fieldTypeInfo = fieldTypeInfo(parameters, fieldDef);

        Instrumentation instrumentation = executionContext.getInstrumentation();
        InstrumentationFieldCompleteParameters instrumentationParams = new InstrumentationFieldCompleteParameters(executionContext, parameters, fieldDef, fieldTypeInfo, fetchedValue);
        InstrumentationContext<ExecutionResult> ctxCompleteField = instrumentation.beginFieldComplete(
                instrumentationParams
        );

        GraphqlFieldVisibility fieldVisibility = executionContext.getGraphQLSchema().getFieldVisibility();
        Map<String, Object> argumentValues = valuesResolver.getArgumentValues(fieldVisibility, fieldDef.getArguments(), field.getArguments(), executionContext.getVariables());

        NonNullableFieldValidator nonNullableFieldValidator = new NonNullableFieldValidator(executionContext, fieldTypeInfo);

        ExecutionStrategyParameters newParameters = parameters.transform(builder ->
                builder.typeInfo(fieldTypeInfo)
                        .arguments(argumentValues)
                        .source(fetchedValue)
                        .nonNullFieldValidator(nonNullableFieldValidator)
        );

        log.debug(""'{}' completing field '{}'..."", executionContext.getExecutionId(), fieldTypeInfo.getPath());

        CompletableFuture<ExecutionResult> cf = completeValue(executionContext, newParameters);

        ctxCompleteField.onDispatched(cf);
        cf.whenComplete(ctxCompleteField::onCompleted);
        return cf;
    }
"	@return a  FieldValueInfo	@return an ExecutionResult	1	0	9	34	227
static protected String session(final String query) { return Query.arg(STR, query, STR); }	"static protected String session(final String query) {
    return Query.arg(null, query, STR);
}"	@return corresponding session key, or empty string if none	@return corresponding session key	1	0	5	3	22
public boolean equals(Object o) { return this == o || o instanceof CallingConvention && ordinal == ((CallingConvention) o).ordinal; }	"    public boolean equals(Object o)
    {
        if (o == null) {
            return false;
        }

        return ordinal == ((CallingConvention) o).ordinal;
    }
"	@return true if they are equal, false otherwise	@return true if they are equal, false otherwise	0	1	8	7	28
boolean findCellForSpan(int[] cellXY, int spanX, int spanY) { // return the span represented by the CellInfo only there is no view there // (this.cell == null) and there is enough space if (this.cell == null && this.spanX >= spanX && this.spanY >= spanY) { if (cellXY != null) { cellXY[0] = cellX; cellXY[1] = cellY; } return true; } int startX = 0; if (intersectX >= 0) { startX = Math.max(startX, intersectX - (spanX - 1)); } int endX = mCountX - (spanX - 1); if (intersectX >= 0) { endX = Math.min(endX, intersectX + (spanX - 1)); } int startY = 0; if (intersectY >= 0) { startY = Math.max(startY, intersectY - (spanY - 1)); } int endY = mCountY - (spanY - 1); if (intersectY >= 0) { endY = Math.min(endY, intersectY + (spanY - 1)); } for (int x = startX; x < endX + 1; x++) { inner: for (int y = startY; y < endY; y++) { for (int i = 0; i < spanX; i++) { for (int j = 0; j < spanY; j++) { if (mOccupied[x + i][y + j]) { // small optimization: we can skip to below the row we just found // an occupied cell y += j; continue inner; } } } if (cellXY != null) { cellXY[0] = x; cellXY[1] = y; } return true; } } return false; }	"        boolean findCellForSpan(int[] cellXY, int spanX, int spanY) {
            return findCellForSpan(cellXY, spanX, spanY, true);
        }
"	@return True if a vacant cell of the specified dimension was found, false otherwise.	@return True if a vacant cell of the specified dimension was found, false otherwise.	0	1	15	52	333
public static TimeExtractionFunction createDefault(String timeZone) { return new TimeExtractionFunction(ISO_TIME_FORMAT, null, timeZone, null); }	"  public static TimeExtractionFunction createDefault() {
    return new TimeExtractionFunction(ISO_TIME_FORMAT, null, ""UTC"", null);
  }
"	@return the time extraction function	@return the time extraction function	0	1	5	4	23
public static <T> T getObject(Heap heap, JsonValue name, Class<T> type) throws HeapException { if (name.isNull()) { return null; } return getRequiredObject(heap, name, type); }	"@SuppressWarnings(STR)
public static <T> T getObject(Heap heap, JsonValue name, Class<T> type) throws HeapException {
    Object o = heap.get(name.required().asString());
    if (o != null && !(type.isInstance(o))) {
        throw new JsonValueException(name, STR + type.getName());
    }
    return (T) o;
}"	@return the specified heap object or {@code null} if name contains {@code null}.	@return the specified heap object.	1	0	6	6	42
private synchronized static Supplier<Annotator> getOrCreate(AnnotatorFactory factory) { return () -> { Annotator rtn = customAnnotators.get(factory.signature()); if (rtn == null) { // Create the annotator rtn = factory.create(); // Register the annotator customAnnotators.put(factory.signature(), factory.create()); // Clean up memory if needed while (customAnnotators.size() > 10) { customAnnotators.keySet().iterator().remove(); } } return rtn; }; }	"  private synchronized static Supplier<Annotator> getOrCreate(String name, Properties props, Supplier<Annotator> annotator) {
    customAnnotators.register(name, props, Lazy.cache(annotator));
    return () -> customAnnotators.get(name);
  }
"	@return An annotator created by that factory.	@return An annotator as specified by the given name and properties.	1	0	11	17	98
@Deprecated public List<WorkflowCondition> getConditions() { List<WorkflowCondition> allConds = new Vector<WorkflowCondition>(); allConds.addAll(preConditions); allConds.addAll(this.postConditions); return allConds; }	"public List<WorkflowCondition> getConditions() {
    return conditions;
}"	@return All pre-and-post conditions.	@return the conditions	1	0	8	7	35
public int toStatusCode(Throwable thrown) { if (thrown == null) { return SUCCESS; } else if (thrown instanceof InvalidCookieDomainException) { return INVALID_COOKIE_DOMAIN; } else if (thrown instanceof UnableToSetCookieException) { return UNABLE_TO_SET_COOKIE; } else if (thrown instanceof NoSuchWindowException) { return NO_SUCH_WINDOW; } else if (thrown instanceof InvalidSelectorException) { return INVALID_SELECTOR_ERROR; } else if (thrown instanceof NoSuchElementException) { return NO_SUCH_ELEMENT; } else if (thrown instanceof NoSuchFrameException) { return NO_SUCH_FRAME; } else if (thrown instanceof StaleElementReferenceException) { return STALE_ELEMENT_REFERENCE; } else if (thrown instanceof ElementNotVisibleException) { return ELEMENT_NOT_VISIBLE; } else if (thrown instanceof InvalidElementStateException) { return INVALID_ELEMENT_STATE; } else if (thrown instanceof XPathLookupException) { return XPATH_LOOKUP_ERROR; } else if (thrown instanceof TimeoutException) { return ASYNC_SCRIPT_TIMEOUT; } else if (thrown instanceof InvalidCoordinatesException) { return INVALID_ELEMENT_COORDINATES; } else if (thrown instanceof ImeNotAvailableException) { return IME_NOT_AVAILABLE; } else if (thrown instanceof ImeActivationFailedException) { return IME_ENGINE_ACTIVATION_FAILED; } else if (thrown instanceof NoAlertPresentException) { return NO_ALERT_PRESENT; } else if (thrown instanceof UnhandledAlertException) { return UNEXPECTED_ALERT_PRESENT; } else if (thrown instanceof MoveTargetOutOfBoundsException) { return MOVE_TARGET_OUT_OF_BOUNDS; } else { return UNHANDLED_ERROR; } }	"  public int toStatusCode(Throwable thrown) {
    if (thrown == null) {
      return SUCCESS;
    } else if (thrown instanceof InvalidCookieDomainException) {
      return INVALID_COOKIE_DOMAIN;
    } else if (thrown instanceof UnableToSetCookieException) {
      return UNABLE_TO_SET_COOKIE;
    } else if (thrown instanceof NoSuchWindowException) {
      return NO_SUCH_WINDOW;
    } else if (thrown instanceof InvalidSelectorException) {
      return INVALID_SELECTOR_ERROR;
    } else if (thrown instanceof NoSuchElementException) {
      return NO_SUCH_ELEMENT;
    } else if (thrown instanceof NoSuchFrameException) {
      return NO_SUCH_FRAME;
    } else if (thrown instanceof StaleElementReferenceException) {
      return STALE_ELEMENT_REFERENCE;
    } else if (thrown instanceof ElementNotVisibleException) {
      return ELEMENT_NOT_VISIBLE;
    } else if (thrown instanceof InvalidElementStateException) {
      return INVALID_ELEMENT_STATE;
    } else if (thrown instanceof XPathLookupException) {
      return XPATH_LOOKUP_ERROR;
    } else if (thrown instanceof TimeoutException) {
      return ASYNC_SCRIPT_TIMEOUT;
    } else if (thrown instanceof InvalidCoordinatesException) {
      return INVALID_ELEMENT_COORDINATES;
    } else if (thrown instanceof ImeNotAvailableException) {
      return IME_NOT_AVAILABLE;
    } else if (thrown instanceof ImeActivationFailedException) {
      return IME_ENGINE_ACTIVATION_FAILED;
    } else if (thrown instanceof NoAlertPresentException) {
      return NO_ALERT_PRESENT;
    } else if (thrown instanceof MoveTargetOutOfBoundsException) {
      return MOVE_TARGET_OUT_OF_BOUNDS;
    } else {
      return UNHANDLED_ERROR;
    }
  }
"	@return The corresponding status code for the given thrown error.	@return The corresponding status code for the given thrown error.	0	1	23	42	229
public ArrayList<GridView> getCurrentGridViews() { return getCurrentViews(GridView.class); }	"	public ArrayList<GridView> getCurrentGridViews() {
		ArrayList<GridView> gridViewList = new ArrayList<GridView>();
		ArrayList<View> viewList = getViews();
		for(View view : viewList){
			if (view instanceof android.widget.GridView)
				gridViewList.add((GridView) view);
		}
		return gridViewList;
	}
"	@return a  List of the  GridViews contained in the current  Activity	@return a List of the GridViews contained in the current Activity	0	1	6	4	15
public ArrayList<ToggleButton> getCurrentToggleButtons() { return ensureArrayListOrNull(viewFetcher.getCurrentViews(ToggleButton.class)); }	"	public ArrayList<ToggleButton> getCurrentToggleButtons() {
		ArrayList<ToggleButton> toggleButtonList = viewFetcher.getCurrentViews(ToggleButton.class);
		return toggleButtonList;
	}
"	@return a  List of the  ToggleButtons contained in the current  Activity	@return a List of the ToggleButtons contained in the current Activity	0	1	7	4	19
public static String optimizeImage(Context context, String path) { if (context == null || TextUtils.isEmpty(path)) { return path; } File file = new File(path); if (!file.exists()) { return path; } String mimeType = MediaUtils.getMediaFileMimeType(file); if (mimeType.equals(STR)) { return path; } Uri imageUri = Uri.parse(path); if (imageUri == null) { return path; } String fileName = MediaUtils.getMediaFileName(file, mimeType); String fileExtension = MimeTypeMap.getFileExtensionFromUrl(fileName).toLowerCase(); int[] dimensions = getImageSize(imageUri, context); int selectedWidth = dimensions[NUM]; final int maxImageWidth = NUM; if (selectedWidth > maxImageWidth) { selectedWidth = maxImageWidth; } int orientation = getImageOrientation(context, path); File resizedImageFile; FileOutputStream out; try { resizedImageFile = File.createTempFile(STR, STR + fileExtension); out = new FileOutputStream(resizedImageFile); } catch (IOException e) { AppLog.e(AppLog.T.MEDIA, STR); return path; } catch (SecurityException e) { AppLog.e(AppLog.T.MEDIA, STR); return path; } try { boolean res = resizeImageAndWriteToStream(context, imageUri, fileExtension, selectedWidth, orientation, NUM, out); if (!res) { AppLog.w(AppLog.T.MEDIA, STR); return path; } } catch (IOException e) { AppLog.e(AppLog.T.MEDIA, STR); return path; } catch (OutOfMemoryError e) { AppLog.e(AppLog.T.MEDIA, STR); return path; } finally { try { out.flush(); out.close(); } catch (IOException e) { } } String tempFilePath = resizedImageFile.getPath(); if (!TextUtils.isEmpty(tempFilePath)) { return tempFilePath; } else { AppLog.e(AppLog.T.MEDIA, STR); } return path; }	"public static String optimizeImage(Context context, String path) {
    File file = new File(path);
    if (!file.exists()) {
        return path;
    }
    String mimeType = MediaUtils.getMediaFileMimeType(file);
    if (mimeType.equals(STR)) {
        return path;
    }
    String fileName = MediaUtils.getMediaFileName(file, mimeType);
    String fileExtension = MimeTypeMap.getFileExtensionFromUrl(fileName).toLowerCase();
    int[] dimensions = getImageSize(Uri.fromFile(file), context);
    int orientation = getImageOrientation(context, path);
    Uri imageUri = Uri.parse(path);
    if (context == null || imageUri == null) {
        return path;
    }
    File resizedImageFile;
    FileOutputStream out;
    try {
        resizedImageFile = File.createTempFile(STR, STR + fileExtension);
        out = new FileOutputStream(resizedImageFile);
    } catch (IOException e) {
        AppLog.e(AppLog.T.MEDIA, STR);
        return path;
    } catch (SecurityException e) {
        AppLog.e(AppLog.T.MEDIA, STR);
        return path;
    }
    try {
        boolean res = resizeImageAndWriteToStream(context, imageUri, fileExtension, dimensions[NUM], orientation, NUM, out);
        if (!res) {
            AppLog.w(AppLog.T.MEDIA, STR);
            return path;
        }
    } catch (IOException e) {
        AppLog.e(AppLog.T.MEDIA, STR);
        return path;
    } catch (OutOfMemoryError e) {
        AppLog.e(AppLog.T.MEDIA, STR);
        return path;
    } finally {
        try {
            out.flush();
            out.close();
        } catch (IOException e) {
        }
    }
    String tempFilePath = resizedImageFile.getPath();
    if (!TextUtils.isEmpty(tempFilePath)) {
        return tempFilePath;
    } else {
        AppLog.e(AppLog.T.MEDIA, STR);
    }
    return path;
}"	@return the path to the optimized image	@return the path to the optmized image	1	0	8	64	362
public T setDecodeAllFrames(boolean decodeAllFrames) { mDecodeAllFrames = decodeAllFrames; return getThis(); }	"  public ImageDecodeOptionsBuilder setDecodeAllFrames(boolean decodeAllFrames) {
    mDecodeAllFrames = decodeAllFrames;
    return this;
  }
"	@return this builder	@return this builder	0	1	5	5	17
public String getHomeDirectory() { return m_loomHome; }	"public String getHomeDirectory() {
    return m_phoenixHome;
}"	@return the home directory of loom	@return the home directory of phoenix	1	0	4	3	10
public int getJdbcId() { return jdbcId; }	"    public int getJdbcId() {
        return jdbc;
    }
"	@return JDBC id of the type as reported by JDBC metadata	@return JDBC id of the type as reported by JDBC metadata	0	1	4	4	10
public boolean isInMeleeDistance(WorldPoint other) { return isInMeleeDistance(new WorldArea(other, NUM, NUM)); }	"public boolean isInMeleeDistance(WorldArea other) {
    if (other == null || this.getPlane() != other.getPlane()) {
        return false;
    }
    Point distances = getAxisDistances(other);
    return distances.getX() + distances.getY() == NUM;
}"	@return true if in melee distance, false otherwise	@return Returns true if it is in melee distance	1	0	6	3	23
public static long asLong(byte[] bytes) { return asLong(bytes, 0); }	"	public static long asLong(byte[] bytes) {
		if ( bytes == null ) {
			return 0;
		}
		if ( bytes.length != 8 ) {
			throw new IllegalArgumentException( ""Expecting 8 byte values to construct a long"" );
		}
		long value = 0;
		for (int i=0; i<8; i++) {
			value = (value << 8) | (bytes[i] & 0xff);
		}
		return value;
	}
"	@return The long	@return The long	0	1	5	4	20
public Node parseXML(String text, Document doc) { return null; }	"public DocumentFragment parseXML(String text, Document doc) {
    return null;
}"	@return The document/document fragment or null on error.	@return The document fragment or null on error.	1	0	4	3	15
"protected static String getStartingMessage() { DateFormat dateFormat = SimpleDateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.MEDIUM); StringBuilder strBuilder = new StringBuilder(200); strBuilder.append(Constant.PROGRAM_NAME).append(' ').append(Constant.PROGRAM_VERSION); strBuilder.append("" started ""); strBuilder.append(dateFormat.format(new Date())); return strBuilder.toString(); }"	"    protected static String getStartingMessage() {
        return Constant.PROGRAM_NAME + "" "" + Constant.PROGRAM_VERSION + "" started."";
    }
"	@return the starting message	@return the starting message	0	1	7	9	72
"protected String fillAliasInSelectClause(StringBuilder sb) { final List<String> aliases = new LinkedList<String>(); final int startPos = shallowIndexOf( sb, SELECT_WITH_SPACE, 0 ); int endPos = shallowIndexOfWord( sb, FROM, startPos ); int nextComa = startPos; int prevComa = startPos; int unique = 0; boolean selectsMultipleColumns = false; while ( nextComa != -1 ) { prevComa = nextComa; nextComa = shallowIndexOf( sb, "","", nextComa ); if ( nextComa > endPos ) { break; } if ( nextComa != -1 ) { String expression = sb.substring( prevComa, nextComa ); if ( selectsMultipleColumns( expression ) ) { selectsMultipleColumns = true; } else { String alias = getAlias( expression ); if ( alias == null ) { // Inserting alias. It is unlikely that we would have to add alias, but just in case. alias = StringHelper.generateAlias( ""page"", unique ); sb.insert( nextComa, "" as "" + alias ); ++unique; nextComa += ( "" as "" + alias ).length(); } aliases.add( alias ); } ++nextComa; } } // Processing last column. endPos = shallowIndexOfWord( sb, FROM, startPos ); // Refreshing end position, because we might have inserted new alias. String expression = sb.substring( prevComa, endPos ); if ( selectsMultipleColumns( expression ) ) { selectsMultipleColumns = true; } else { String alias = getAlias( expression ); if ( alias == null ) { // Inserting alias. It is unlikely that we would have to add alias, but just in case. alias = StringHelper.generateAlias( ""page"", unique ); sb.insert( endPos - 1, "" as "" + alias ); } aliases.add( alias ); } // In case of '*' or '{table}.*' expressions adding an alias breaks SQL syntax, returning '*'. return selectsMultipleColumns ? ""*"" : StringHelper.join( "", "", aliases.iterator() ); }"	"	protected String fillAliasInSelectClause(StringBuilder sb) {
		final List<String> aliases = new LinkedList<String>();
		final int startPos = shallowIndexOf( sb, SELECT_WITH_SPACE, 0 );
		int endPos = shallowIndexOfWord( sb, FROM, startPos );
		int nextComa = startPos;
		int prevComa = startPos;
		int unique = 0;

		while ( nextComa != -1 ) {
			prevComa = nextComa;
			nextComa = shallowIndexOf( sb, "","", nextComa );
			if ( nextComa > endPos ) {
				break;
			}
			if ( nextComa != -1 ) {
				String expression = sb.substring( prevComa, nextComa );
				String alias = getAlias( expression );
				if ( alias == null ) {
					// Inserting alias. It is unlikely that we would have to add alias, but just in case.
					alias = StringHelper.generateAlias( ""page"", unique );
					sb.insert( nextComa, "" as "" + alias );
					++unique;
					nextComa += ( "" as "" + alias ).length();
				}
				aliases.add( alias );
				++nextComa;
			}
		}
		// Processing last column.
		endPos = shallowIndexOfWord( sb, FROM, startPos ); // Refreshing end position, because we might have inserted new alias.
		String expression = sb.substring( prevComa, endPos );
		String alias = getAlias( expression );
		if ( alias == null ) {
			// Inserting alias. It is unlikely that we would have to add alias, but just in case.
			alias = StringHelper.generateAlias( ""page"", unique );
			sb.insert( endPos - 1, "" as "" + alias );
		}
		aliases.add( alias );

		return StringHelper.join( "", "", aliases.iterator() );
	}
"	@return List of aliases separated with comas or @literal .	@return List of aliases separated with comas.	1	0	14	54	372
protected TheInnerClass newTheInnerClass( ) { return this.injectMembers(new TheInnerClass()); }	"  protected TheInnerClass newTheInnerClass( ) {
    return new TheInnerClass();
  }
"	@return an instance of the inner class, at runtime the generated subclass (or replacement) of the template inner class	@return an instance of the inner class, at runtime the generated subclass (or replacement) of the template inner class	0	1	7	4	17
public AvaticaHandler getHandler(Service service, Driver.Serialization serialization) { return getHandler(service, serialization, NoopMetricsSystemConfiguration.getInstance()); }	"  public Handler getHandler(Service service, Driver.Serialization serialization) {
    return getHandler(service, serialization, NoopMetricsSystemConfiguration.getInstance());
  }
"	@return The  AvaticaHandler.	@return The Handler.	1	0	5	4	26
private List<WorkerInfo> checkWorkers() { boolean failJob = true; int pollAttempt = NUM; List<WorkerInfo> healthyWorkerInfoList = new ArrayList<WorkerInfo>(); List<WorkerInfo> unhealthyWorkerInfoList = new ArrayList<WorkerInfo>(); int totalResponses = -NUM; while (pollAttempt < maxPollAttempts) { getAllWorkerInfos(getSuperstep(), healthyWorkerInfoList, unhealthyWorkerInfoList); totalResponses = healthyWorkerInfoList.size() + unhealthyWorkerInfoList.size(); if ((totalResponses * NUM / maxWorkers) >= minPercentResponded) { failJob = false; break; } getContext().setStatus(getGraphMapper().getMapFunctions() + STR + STR + totalResponses + STR + maxWorkers + STR + getSuperstep()); if (getWorkerHealthRegistrationChangedEvent().waitMsecs(msecsPollPeriod)) { if (LOG.isDebugEnabled()) { LOG.debug(STR + STR); } getWorkerHealthRegistrationChangedEvent().reset(); continue; } if (LOG.isInfoEnabled()) { LOG.info(STR + totalResponses + STR + maxWorkers + STR + getSuperstep() + STR + msecsPollPeriod + STR + pollAttempt + STR + maxPollAttempts + STR); if ((maxWorkers - totalResponses) <= partitionLongTailMinPrint) { Set<Integer> partitionSet = new TreeSet<Integer>(); for (WorkerInfo workerInfo : healthyWorkerInfoList) { partitionSet.add(workerInfo.getPartitionId()); } for (WorkerInfo workerInfo : unhealthyWorkerInfoList) { partitionSet.add(workerInfo.getPartitionId()); } for (int i = NUM; i <= maxWorkers; ++i) { if (partitionSet.contains(new Integer(i))) { continue; } else if (i == getTaskPartition()) { continue; } else { LOG.info(STR + STR + i + STR); } } } } ++pollAttempt; } if (failJob) { LOG.error(STR + STR + totalResponses + STR + minWorkers + STR + STR + STR + STR); return null; } if (healthyWorkerInfoList.size() < minWorkers) { LOG.error(STR + healthyWorkerInfoList.size() + STR + minWorkers + STR); return null; } return healthyWorkerInfoList; }	"private Map<String, JSONArray> checkWorkers() {
    boolean failJob = true;
    int pollAttempt = NUM;
    List<String> healthyWorkerList = new ArrayList<String>();
    List<String> unhealthyWorkerList = new ArrayList<String>();
    int totalResponses = -NUM;
    while (pollAttempt < maxPollAttempts) {
        getWorkers(getSuperstep(), healthyWorkerList, unhealthyWorkerList);
        totalResponses = healthyWorkerList.size() + unhealthyWorkerList.size();
        if ((totalResponses * NUM / maxWorkers) >= minPercentResponded) {
            failJob = false;
            break;
        }
        getContext().setStatus(getGraphMapper().getMapFunctions() + STR + STR + totalResponses + STR + maxWorkers + STR + getSuperstep());
        if (getWorkerHealthRegistrationChangedEvent().waitMsecs(msecsPollPeriod)) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(STR + STR);
            }
            getWorkerHealthRegistrationChangedEvent().reset();
            continue;
        }
        if (LOG.isInfoEnabled()) {
            LOG.info(STR + totalResponses + STR + maxWorkers + STR + getSuperstep() + STR + msecsPollPeriod + STR + pollAttempt + STR + maxPollAttempts + STR);
            if ((maxWorkers - totalResponses) <= partitionLongTailMinPrint) {
                Set<Integer> partitionSet = new TreeSet<Integer>();
                for (String hostnamePartitionId : healthyWorkerList) {
                    int lastIndex = hostnamePartitionId.lastIndexOf(STR);
                    Integer partition = Integer.parseInt(hostnamePartitionId.substring(lastIndex + NUM));
                    partitionSet.add(partition);
                }
                for (String hostnamePartitionId : unhealthyWorkerList) {
                    int lastIndex = hostnamePartitionId.lastIndexOf(STR);
                    Integer partition = Integer.parseInt(hostnamePartitionId.substring(lastIndex + NUM));
                    partitionSet.add(partition);
                }
                for (int i = NUM; i <= maxWorkers; ++i) {
                    if (partitionSet.contains(new Integer(i))) {
                        continue;
                    } else if (i == getTaskPartition()) {
                        continue;
                    } else {
                        LOG.info(STR + STR + i + STR);
                    }
                }
            }
        }
        ++pollAttempt;
    }
    if (failJob) {
        LOG.error(STR + STR + totalResponses + STR + minWorkers + STR + STR + STR + STR);
        return null;
    }
    if (healthyWorkerList.size() < minWorkers) {
        LOG.error(STR + healthyWorkerList.size() + STR + minWorkers + STR);
        return null;
    }
    Map<String, JSONArray> workerHostnamePortMap = new HashMap<String, JSONArray>();
    for (String healthyWorker : healthyWorkerList) {
        String healthyWorkerPath = null;
        try {
            healthyWorkerPath = getWorkerHealthyPath(getApplicationAttempt(), getSuperstep()) + STR + healthyWorker;
            JSONArray hostnamePortArray = new JSONArray(new String(getZkExt().getData(healthyWorkerPath, false, null)));
            workerHostnamePortMap.put(healthyWorker, hostnamePortArray);
        } catch (JSONException e) {
            throw new RuntimeException(STR + healthyWorker + STR + healthyWorkerPath);
        } catch (KeeperException e) {
            throw new IllegalStateException(STR, e);
        } catch (InterruptedException e) {
            throw new IllegalStateException(STR, e);
        }
    }
    return workerHostnamePortMap;
}"	@return List of of healthy workers	@return map of healthy worker list to JSONArray(hostname, port)	1	0	21	54	376
public Future<HttpResponse> executeAsync(Executor executor) { FutureTask<HttpResponse> future = new FutureTask<HttpResponse>(new Callable<HttpResponse>() { public HttpResponse call() throws Exception { return execute(); } }); executor.execute(future); return future; }	"public Future<HttpResponse> executeAsync(Executor exec) {
    final SettableFuture<HttpResponse> future = SettableFuture.create();
    exec.execute(new Runnable() {

        public void run() {
            try {
                future.set(execute());
            } catch (IOException ex) {
                future.setException(ex);
            }
        }
    });
    return future;
}"	@return future for accessing the HTTP response	@return A future for accessing the results of the asynchronous request.	1	0	9	10	49
private File[] getDirectoryHistory() { return Settings.instance().getDirectoryHistory(); }	"private File[] getDirectoryHistory() {
    File[] dirhist = Settings.instance().getDirectoryHistory();
    if (dirhist == null || dirhist.length == NUM)
        return new File[] { new File(STR).getAbsoluteFile() };
    else
        return dirhist;
}"	@return current directory history. Should never return null.	@return current directory history, or if empty, only current directory (as File[0]).	1	0	5	3	18
public char get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }	"public char get(WithAttributes attributes) {
    return attributes.getAttributes().get(this);
}"	@return the value of this attribute if this attribute is present in the extracted map. Otherwise {@link #getDefaultValue()}	@return the value of this attribute if this attribute is present in the map. Otherwise {@link #getDefaultValue()}	1	0	6	3	19
public List<EndpointAffinity> getOperatorAffinity() { return this.endpointAffinities; }	"  public List<EndpointAffinity> getOperatorAffinity() {

    if (this.endpointAffinities == null) {
      BlockMapBuilder bmb = new BlockMapBuilder(fs, formatPlugin.getContext().getBits());
      try {
        List<TimedRunnable<Void>> blockMappers = Lists.newArrayList();
        for (RowGroupInfo rgi : rowGroupInfos) {
          blockMappers.add(new BlockMapper(bmb, rgi));
        }
        TimedRunnable.run(""Load Parquet RowGroup block maps"", logger, blockMappers, 16);
      } catch (IOException e) {
        logger.warn(""Failure while determining operator affinity."", e);
        return Collections.emptyList();
      }

      this.endpointAffinities = AffinityCreator.getAffinityMap(rowGroupInfos);
    }
    return this.endpointAffinities;
  }
"	@return a list of EndpointAffinity objects	@return a list of EndpointAffinity objects	0	1	5	4	12
public static InvalidOperationBehavior parse(String value) { if (value == null) { return null; } value = value.trim(); for (InvalidOperationBehavior option : InvalidOperationBehavior.values()) { if (option.getValue().equalsIgnoreCase(value)) { return option; } } return null; }	"        public static InvalidOperationBehavior parse(String value, String defaultValue) {
            InvalidOperationBehavior mode = parse(value);
            if (mode == null && defaultValue != null) mode = parse(defaultValue);
            return mode;
        }
"	@return the matching option, or null if no match is found	@return the matching option, or null if no match is found and the non-null default is invalid	1	0	8	13	57
public Bundle getActivityLaunchOptions(Launcher launcher, View v) { if (hasControlRemoteAppTransitionPermission()) { try { RemoteAnimationRunnerCompat runner = new LauncherAnimationRunner(mLauncher) { @Override public void onAnimationStart(RemoteAnimationTargetCompat[] targets, Runnable finishedCallback) { // Post at front of queue ignoring sync barriers to make sure it gets // processed before the next frame. postAtFrontOfQueueAsynchronously(v.getHandler(), () -> { mAnimator = new AnimatorSet(); setCurrentAnimator(mAnimator); mAnimator.play(getLauncherAnimators(v)); mAnimator.play(getWindowAnimators(v, targets)); mAnimator.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { // Reset launcher to normal state v.setVisibility(View.VISIBLE); ((ViewGroup) mDragLayer.getParent()).removeView(mFloatingView); mDragLayer.setAlpha(1f); mDragLayer.setTranslationY(0f); View appsView = mLauncher.getAppsView(); appsView.setAlpha(1f); appsView.setTranslationY(0f); finishedCallback.run(); } }); mAnimator.start(); // Because t=0 has the app icon in its original spot, we can skip the // first frame and have the same movement one frame earlier. mAnimator.setCurrentPlayTime(REFRESH_RATE_MS); }); } }; return ActivityOptionsCompat.makeRemoteAnimation( new RemoteAnimationAdapterCompat(runner, 500, 380)).toBundle(); } catch (NoClassDefFoundError e) { // Gracefully fall back to default launch options if the user's platform doesn't // have the latest changes. } } return getDefaultActivityLaunchOptions(launcher, v); }	"    public ActivityOptions getActivityLaunchOptions(Launcher launcher, View v) {
        if (hasControlRemoteAppTransitionPermission()) {
            try {
                RemoteAnimationRunnerCompat runner = new LauncherAnimationRunner(mHandler) {

                    @Override
                    public AnimatorSet getAnimator(RemoteAnimationTargetCompat[] targetCompats) {
                        AnimatorSet anim = new AnimatorSet();


                        if (!composeRecentsLaunchAnimator(v, targetCompats, anim)) {
                            // Set the state animation first so that any state listeners are called
                            // before our internal listeners.
                            mLauncher.getStateManager().setCurrentAnimation(anim);

                            anim.play(getIconAnimator(v));
                            if (launcherIsATargetWithMode(targetCompats, MODE_CLOSING)) {
                                anim.play(getLauncherContentAnimator(false /* show */));
                            }
                            anim.play(getWindowAnimators(v, targetCompats));
                        }
                        return anim;
                    }
                };

                int duration = findTaskViewToLaunch(launcher, v, null) != null
                        ? RECENTS_LAUNCH_DURATION : APP_LAUNCH_DURATION;
                int statusBarTransitionDelay = duration - STATUS_BAR_TRANSITION_DURATION;
                return ActivityOptionsCompat.makeRemoteAnimation(new RemoteAnimationAdapterCompat(
                        runner, duration, statusBarTransitionDelay));
            } catch (NoClassDefFoundError e) {
                // Gracefully fall back to default launch options if the user's platform doesn't
                // have the latest changes.
            }
        }
        return getDefaultActivityLaunchOptions(launcher, v);
    }
"	@return A Bundle with remote animations that controls how the window of the opening targets are displayed.	@return ActivityOptions with remote animations that controls how the window of the opening targets are displayed.	1	0	19	49	300
"public Action doCometSupport(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException { req.setAttribute(BROADCASTER_FACTORY, broadcasterFactory); req.setAttribute(PROPERTY_USE_STREAM, useStreamForFlushingComments); req.setAttribute(BROADCASTER_CLASS, broadcasterClassName); req.setAttribute(SUPPORT_TRACKABLE, config.getInitParameter(SUPPORT_TRACKABLE)); try { if (config.getInitParameter(ALLOW_QUERYSTRING_AS_HEADER) != null) { return cometSupport.service(new AtmosphereRequest.Builder().headers(configureHeader(req)).request(req).build(), res); } else { return cometSupport.service(req, res); } } catch (IllegalStateException ex) { logger.warn(ex.getMessage(), ex); if (ex.getMessage() != null && ex.getMessage().startsWith(""Tomcat failed"")) { if (!isFilter) { logger.warn(""Failed using comet support: {}, error: {}"", cometSupport.getClass().getName(), ex.getMessage()); logger.warn(""Using BlockingIOCometSupport.""); } cometSupport = new BlockingIOCometSupport(config); service(req, res); } else { logger.error(""AtmosphereServlet exception"", ex); throw ex; } } return null; }"	"    public Action doCometSupport(HttpServletRequest req, HttpServletResponse res)
            throws IOException, ServletException {
        req.setAttribute(BROADCASTER_FACTORY, broadcasterFactory);
        req.setAttribute(PROPERTY_USE_STREAM, useStreamForFlushingComments);
        req.setAttribute(BROADCASTER_CLASS, broadcasterClassName);
        req.setAttribute(SUPPORT_TRACKABLE, config.getInitParameter(SUPPORT_TRACKABLE));

        try {
            return cometSupport.service(req, res);
        } catch (IllegalStateException ex) {
            logger.warn(ex.getMessage(), ex);
            if (ex.getMessage() != null && ex.getMessage().startsWith(""Tomcat failed"")) {
                if (!isFilter) {
                    logger.warn(""Failed using comet support: {}, error: {}"", cometSupport.getClass().getName(),
                            ex.getMessage());
                    logger.warn(""Using BlockingIOCometSupport."");
                }

                cometSupport = new BlockingIOCometSupport(config);
                service(req, res);
            } else {
                logger.error(""AtmosphereServlet exception"", ex);
                throw ex;
            }
        }
        return null;
    }
"	@return an  Action	@return an Action	0	1	12	32	230
public float getY() { if (top == null) { calculateTop(); } return top.floatValue(); }	"public float getY() {
    return center[NUM];
}"	@return The y position of the top of this shape.	@return The y location of the center of this circle	1	0	6	6	24
protected Object convertDouble(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0.0d; } if (data instanceof Double) return data; if (data instanceof Number) { Number value = (Number) data; return new Double(value.doubleValue()); } if (data instanceof Boolean) { return ((Boolean) data).booleanValue() ? DOUBLE_TRUE : DOUBLE_FALSE; } return handleUnknownData(column, fieldDefn, data); }	"    protected Object convertDouble(Column column, Field fieldDefn, Object data) {
        if (data == null) return null;
        if (data instanceof Double) return data;
        if (data instanceof Number) {
            Number value = (Number) data;
            return new Double(value.doubleValue());
        }
        if (data instanceof Boolean) {
            return ((Boolean) data).booleanValue() ? DOUBLE_TRUE : DOUBLE_FALSE;
        }
        return handleUnknownData(column, fieldDefn, data);
    }
"	@return the converted value, or null if the conversion could not be made and the column allows nulls	@return the converted value, or null if the conversion could not be made	1	0	8	19	119
"private DbObjectBase findDbEntry(PumpHistoryEntry treatment, List<? extends DbObjectBase> entriesFromHistory) { long proposedTime = DateTimeUtil.toMillisFromATD(treatment.atechDateTime); //proposedTime += (this.pumpTime.timeDifference * 1000); if (doubleBolusDebug) LOG.debug(""DoubleBolusDebug: findDbEntry Treatment={}, FromDb={}"", treatment, gson.toJson(entriesFromHistory)); if (entriesFromHistory.size() == 0) { if (doubleBolusDebug) LOG.debug(""DoubleBolusDebug: findDbEntry Treatment={}, FromDb=null"", treatment); return null; } else if (entriesFromHistory.size() == 1) { if (doubleBolusDebug) LOG.debug(""DoubleBolusDebug: findDbEntry Treatment={}, FromDb={}. Type=SingleEntry"", treatment, entriesFromHistory.get(0)); // TODO: Fix db code // if difference is bigger than 2 minutes we discard entry long maxMillisAllowed = DateTimeUtil.getMillisFromATDWithAddedMinutes(treatment.atechDateTime, 2); if (doubleBolusDebug) LOG.debug(""DoubleBolusDebug: findDbEntry maxMillisAllowed={}, AtechDateTime={} (add 2 minutes). "", maxMillisAllowed, treatment.atechDateTime); if (entriesFromHistory.get(0).getDate() > maxMillisAllowed) { if (doubleBolusDebug) LOG.debug(""DoubleBolusDebug: findDbEntry entry filtered out, returning null. ""); return null; } return entriesFromHistory.get(0); } for (int min = 0; min < 2; min += 1) { for (int sec = 0; sec <= 50; sec += 10) { if (min == 1 && sec == 50) { sec = 59; } int diff = (sec * 1000); List<DbObjectBase> outList = new ArrayList<>(); for (DbObjectBase treatment1 : entriesFromHistory) { if ((treatment1.getDate() > proposedTime - diff) && (treatment1.getDate() < proposedTime + diff)) { outList.add(treatment1); } } if (outList.size() == 1) { if (doubleBolusDebug) LOG.debug(""DoubleBolusDebug: findDbEntry Treatment={}, FromDb={}. Type=EntrySelected, AtTimeMin={}, AtTimeSec={}"", treatment, entriesFromHistory.get(0), min, sec); return outList.get(0); } if (min == 0 && sec == 10 && outList.size() > 1) { if (isLogEnabled()) LOG.error(""Too many entries (with too small diff): (timeDiff=[min={},sec={}],count={},list={})"", min, sec, outList.size(), gson.toJson(outList)); if (doubleBolusDebug) LOG.debug(""DoubleBolusDebug: findDbEntry Error - Too many entries (with too small diff): (timeDiff=[min={},sec={}],count={},list={})"", min, sec, outList.size(), gson.toJson(outList)); } } } return null; }"	"    private DbObjectBase findDbEntry(PumpHistoryEntry treatment, List<? extends DbObjectBase> entriesFromHistory) {

        long proposedTime = DateTimeUtil.toMillisFromATD(treatment.atechDateTime);

        //proposedTime += (this.pumpTime.timeDifference * 1000);

        if (entriesFromHistory.size() == 0) {
            return null;
        } else if (entriesFromHistory.size() == 1) {
            return entriesFromHistory.get(0);
        }

        for (int min = 0; min < 2; min += 1) {

            for (int sec = 0; sec <= 50; sec += 10) {

                if (min == 1 && sec == 50) {
                    sec = 59;
                }

                int diff = (sec * 1000);

                List<DbObjectBase> outList = new ArrayList<>();

                for (DbObjectBase treatment1 : entriesFromHistory) {

                    if ((treatment1.getDate() > proposedTime - diff) && (treatment1.getDate() < proposedTime + diff)) {
                        outList.add(treatment1);
                    }
                }

//                LOG.debug(""Entries: (timeDiff=[min={},sec={}],count={},list={})"", min, sec, outList.size(),
//                        gsonPretty.toJson(outList));

                if (outList.size() == 1) {
                    return outList.get(0);
                }

                if (min == 0 && sec == 10 && outList.size() > 1) {
                    if (isLogEnabled())
                        LOG.error(""Too many entries (with too small diff): (timeDiff=[min={},sec={}],count={},list={})"",
                                min, sec, outList.size(), gson.toJson(outList));
                }
            }
        }

        return null;
    }
"	@return DbObject from AAPS (if found)	@return DbObject from AAPS (if found)	0	1	13	73	547
@Deprecated public long getNumBytesUploaded() { return totalBytesServerReceived; }	"public long getNumBytesUploaded() {
    return bytesUploaded;
}"	@return the number of bytes the server received so far	@return the number of bytes uploaded	1	0	4	4	12
public static LoopBound calculateWCA(String wcaA) throws BadAnnotationException { int ai = wcaA.indexOf(STR); if (ai != -NUM) { String annotString = wcaA.substring(ai + STR.length()); if (annotString.indexOf(STR) < NUM) return null; Pattern pattern1 = Pattern.compile(STR); Pattern pattern2 = Pattern.compile(STR); Matcher matcher1 = pattern1.matcher(annotString); if (matcher1.matches()) { int ub = Integer.parseInt(matcher1.group(NUM)); int lb = (matcher1.group(NUM).equals(STR)) ? ub : NUM; return new LoopBound(lb, ub); } Matcher matcher2 = pattern2.matcher(annotString); if (matcher2.matches()) { int lb = Integer.parseInt(matcher2.group(NUM)); int ub = Integer.parseInt(matcher2.group(NUM)); return new LoopBound(lb, ub); } throw new BadAnnotationException(STR + annotString); } return null; }	"public static int calculateWCA(String wcaA) {
    int ai = wcaA.indexOf(STR);
    if (ai != -NUM) {
        String c = wcaA.substring(ai + STR.length());
        Pattern pattern = Pattern.compile(STR);
        Matcher matcher = pattern.matcher(c);
        if (!matcher.matches()) {
            logger.error(STR + c + STR);
            return -NUM;
        }
        int val = Integer.parseInt(matcher.group(NUM));
        return val;
    }
    return -NUM;
}"	@return the loop bound limit or null if no annotation was found	@return the loop bound limit or -1 if no annotation was found or the annotation was erroneous	1	0	11	24	188
public double getRotX() { return Math.toDegrees(mOrientation.getRotationX()); }	"public double getRotX() {
    return mOrientation.getRotationX();
}"	@return double The roll Euler angle in degrees.	@return double The roll Euler angle.	1	0	5	3	17
public long getMillis(long value) { return FieldUtils.safeMultiply(value, getUnitMillis()); }	"    public long getMillis(long value) {
        return value * getUnitMillis();
    }
"	@return the milliseconds that the field represents, which may be negative	@return the milliseconds that the field represents, which may be negative	0	1	5	4	20
@Override public void createRecord(DBRecord rec, Connection conn) { throw new NotImplementedException(this, STR); }	"@Override
public boolean createRecord(DBRecord rec, Connection conn) {
    return error(Errors.NotImplemented, STR);
}"	@return a not implemented error	@return an error, because querys could't add new records to the database	1	0	5	4	23
protected SqlStatementLogger sqlStatementLogger() { return sqlStatementLogger; }	"	protected SqlStatementLogger sqlStatementLogger() {
		return jdbcCoordinator.getTransactionCoordinator()
				.getTransactionContext()
				.getTransactionEnvironment()
				.getJdbcServices()
				.getSqlStatementLogger();
	}
"	@return The underlying JDBC services.	@return The underlying JDBC services.	0	1	4	4	10
private boolean isLogicalOneToOne(Type type) { return type.isEntityType() && ( (EntityType) type ).isLogicalOneToOne(); }	"	private boolean isLogicalOneToOne(Type type) {
		if ( ! type.isEntityType() ) {
			return false;
		}
		final EntityType entityType = (EntityType) type;
		if ( entityType.isOneToOne() ) {
			// physical one-to-one
			return true;
		}
		// todo : still need to handle the many-to-one w/ property-ref
		//		actually there is a question about whether the constrained side
		//		can declare the orphan-delete.  If not, then the side declaring
		//		the orphan-delete can only ever be a <one-to-one/>
		return false;
	}
"	@return True if the attribute represents a logical one to one association	@return True if the attribute represents a logical one to one association	0	1	6	4	26
public JSONArray getExtraJSONArray(String key) throws JSONException { return mExtraData.getJSONArray(key); }	"public JSONArray getExtraJSONArray(String key) {
    return mExtraData.optJSONArray(key);
}"	@return The stored value.	@return The stored value or null if it doesn't exist in specified form.	1	0	5	3	18
protected ArrayList evalXQExpression(XMLDataValue xmlContext, boolean returnResults, int[] resultXType) throws Exception { if (SanityManager.DEBUG) { SanityManager.ASSERT((query != null) && (query.getExpression() != null), STR); } if (xmlContext.getXType() != XML.XML_DOC_ANY) { throw StandardException.newException(SQLState.LANG_INVALID_XML_CONTEXT_ITEM, (returnResults ? STR : STR)); } Document docNode = null; docNode = dBuilder.parse(new InputSource(new StringReader(xmlContext.getString()))); getXPathContext(); xpContext.reset(); XObject xOb = query.execute(xpContext, docNode, null); if (!returnResults) { if ((xOb instanceof XNodeSet) && (((XNodeSet) xOb).nodelist().getLength() > NUM)) { return new ArrayList(NUM); } else if (!(xOb instanceof XNodeSet)) return new ArrayList(NUM); else { return null; } } NodeList nodeList = null; int numItems = NUM; if (!(xOb instanceof XNodeSet)) numItems = NUM; else { nodeList = xOb.nodelist(); numItems = nodeList.getLength(); } ArrayList itemRefs = new ArrayList(); if (nodeList == null) itemRefs.add(xOb.str()); else { for (int i = NUM; i < numItems; i++) itemRefs.add(nodeList.item(i)); } nodeList = null; if ((numItems == NUM) && ((itemRefs.get(NUM) instanceof Document) || (itemRefs.get(NUM) instanceof Element))) { resultXType[NUM] = XML.XML_DOC_ANY; } else resultXType[NUM] = XML.XML_SEQUENCE; return itemRefs; }	"protected boolean evalXQExpression(XMLDataValue xmlContext) throws Exception {
    if (SanityManager.DEBUG) {
        SanityManager.ASSERT((query != null) && (query.getExpression() != null), STR);
    }
    Document docNode = null;
    docNode = dBuilder.parse(new InputSource(new StringReader(xmlContext.getString())));
    getXPathContext();
    xpContext.reset();
    XObject xOb = query.execute(xpContext, docNode, null);
    if ((xOb instanceof XNodeSet) && (((XNodeSet) xOb).nodelist().getLength() > NUM)) {
        return true;
    } else if (!(xOb instanceof XNodeSet))
        return true;
    return false;
}"	@return If returnResults is false then return an empty ArrayList if evaluation returned at least one item and return null otherwise. If returnResults is true then return an array list containing all of the result items and return the qualified XML type via the resultXType parameter.	@return True if evaluation returned at least one item, false otherwise.	1	0	9	42	319
public Order placeOrder(Order body) throws ApiException { Call call = placeOrderCall(body); Type returnType = new TypeToken<Order>(){}.getType(); return apiClient.execute(call, returnType); }	"  public Order placeOrder(Order body) throws ApiException {
    ApiResponse<Order> resp = placeOrderWithHttpInfo(body);
    return resp.getData();
  }
"	@return Order	@return Order	0	1	8	6	40
public boolean isAggregator() { return false; }	"  public boolean isAggregator() {
    return this instanceof SqlAggFunction;
  }
"	@return whether this operator is an aggregator	@return whether this operator is an aggregator	0	1	4	4	10
protected int getVersion() { return VCardConfig.VERSION_21; }	"protected int getVersion() {
    return VCardConfig.FLAG_V21;
}"	@return {@link VCardConfig#VERSION_21}	@return {@link VCardConfig#FLAG_V21}	1	0	4	3	11
protected Object[] createWriteMethodArguments(Method method, Object value) throws IllegalAccessException, ClassCastException { try { if (value != null) { Class<?>[] types = method.getParameterTypes(); if (types != null && types.length > 0) { Class<?> paramType = types[0]; if (paramType.isPrimitive()) { paramType = Primitives.wrap(paramType); } if (!paramType.isAssignableFrom(value.getClass())) { value = convertType(paramType, value); } } } return new Object[]{value}; } catch (InvocationTargetException e) { throw new IllegalArgumentException(e.getMessage()); } catch (InstantiationException e) { throw new IllegalArgumentException(e.getMessage()); } }	"    protected Object[] createWriteMethodArguments(Method method, Object value) throws IllegalAccessException, ClassCastException {
        try {
            if (value != null) {
                Class<?>[] types = method.getParameterTypes();
                if (types != null && types.length > 0) {
                    Class<?> paramType = types[0];
                    if (paramType.isPrimitive()) {
                        paramType = Primitives.wrap(paramType);
                    }
                    if (!paramType.isAssignableFrom(value.getClass())) {
                        value = convertType(paramType, value);
                    }
                }
            }
            Object[] answer = {value};
            return answer;
        } catch (InvocationTargetException e) {
            throw new IllegalArgumentException(e.getMessage());
        } catch (InstantiationException e) {
            throw new IllegalArgumentException(e.getMessage());
        }
    }
"	@return an array containing one object that is either the given value or a transformed value	@return an array containing one object that is either the given value or a transformed value	0	1	13	22	141
"public PeriodType withWeeksRemoved() { return withFieldRemoved(2, ""NoWeeks""); }"	"    public PeriodType withWeeksRemoved() {
        if (!weeks().isSupported()) {
            return this;
        }
        return MaskedType.mask(this, 1 << 2);
    }
"	@return a new period type that supports the original set of fields except weeks	@return a new period type that supports the original set of fields except weeks	0	1	5	4	17
@Deprecated public List<String> readScopes() { return SENTINEL_EMPTY_SCOPES; }	"public List<String> readScopes() {
    return readScopes;
}"	@return an empty list	@return the allowed read scopes	1	0	5	4	13
"public GtidSet purgedGtidSet() { AtomicReference<String> gtidSetStr = new AtomicReference<String>(); try { jdbc.query(""SHOW GLOBAL VARIABLES LIKE \""gtid_purged\"""", rs -> { if (rs.next() && rs.getMetaData().getColumnCount() > 1) { gtidSetStr.set(rs.getString(2));// GTID set, may be null, blank, or contain a GTID set } }); } catch (SQLException e) { throw new ConnectException(""Unexpected error while connecting to MySQL and looking at gtid_purged variable: "", e); } String result = gtidSetStr.get(); if (result == null) { result = """"; } return new GtidSet(result); }"	"    public String purgedGtidSet() {
        AtomicReference<String> gtidSetStr = new AtomicReference<String>();
        try {
            jdbc.query(""SHOW GLOBAL VARIABLES LIKE \""gtid_purged\"""", rs -> {
                if (rs.next() && rs.getMetaData().getColumnCount() > 1) {
                    gtidSetStr.set(rs.getString(2));// GTID set, may be null, blank, or contain a GTID set
                }
            });
        } catch (SQLException e) {
            throw new ConnectException(""Unexpected error while connecting to MySQL and looking at gtid_purged variable: "", e);
        }

        String result = gtidSetStr.get();
        return result != null ? result : """";
    }
"	@return A GTID set; may be empty if not using GTIDs or none have been purged yet	@return string representation of GTID set or empty string	1	0	12	21	139
public AccessType getAccessType() { if (isPublic()) { return AccessType.ACC_PUBLIC; } if (isPrivate()) { return AccessType.ACC_PRIVATE; } if (isProtected()) { return AccessType.ACC_PROTECTED; } return AccessType.ACC_PACKAGE; }	"public int getAccessType() {
    if (isPublic()) {
        return ACC_PUBLIC;
    }
    if (isPrivate()) {
        return ACC_PRIVATE;
    }
    if (isProtected()) {
        return ACC_PROTECTED;
    }
    return ACC_PACKAGE;
}"	@return a value of {@link AccessType}.	@return one of {@link #ACC_PRIVATE}, {@link #ACC_PROTECTED}, {@link #ACC_PACKAGE} or {@link #ACC_PUBLIC}.	1	0	6	12	47
public List<HostAuthentication> getListAuth() { return listAuth; }	"    public Vector<HostAuthentication> getListAuth() {
        return listAuth;
    }
"	@return Returns the listAuth.	@return Returns the listAuth.	0	1	5	4	11
public DirectRowSet rowSet() throws RpcException { // Ignore all but the first non-empty batch. QueryDataBatch dataBatch = null; for (QueryDataBatch batch : results()) { if (dataBatch == null && batch.getHeader().getRowCount() != 0) { dataBatch = batch; } else { batch.release(); } } // No results? if (dataBatch == null) { return null; } // Unload the batch and convert to a row set. final RecordBatchLoader loader = new RecordBatchLoader(client.allocator()); try { loader.load(dataBatch.getHeader().getDef(), dataBatch.getData()); dataBatch.release(); VectorContainer container = loader.getContainer(); container.setRecordCount(loader.getRecordCount()); return DirectRowSet.fromContainer(container); } catch (SchemaChangeException e) { throw new IllegalStateException(e); } }	"  public DirectRowSet rowSet() throws RpcException {

    // Ignore all but the first non-empty batch.

    QueryDataBatch dataBatch = null;
    for (QueryDataBatch batch : results()) {
      if (dataBatch == null  &&  batch.getHeader().getRowCount() != 0) {
        dataBatch = batch;
      } else {
        batch.release();
      }
    }

    // No results?

    if (dataBatch == null) {
      return null;
    }

    // Unload the batch and convert to a row set.

    final RecordBatchLoader loader = new RecordBatchLoader(client.allocator());
    try {
      loader.load(dataBatch.getHeader().getDef(), dataBatch.getData());
      dataBatch.release();
      VectorContainer container = loader.getContainer();
      container.setRecordCount(loader.getRecordCount());
      return new DirectRowSet(client.allocator(), container);
    } catch (SchemaChangeException e) {
      throw new IllegalStateException(e);
    }
  }
"	@return a row set that represents the first batch returned from the query	@return a row set that represents the first batch returned from the query	0	1	9	33	164
public Object defaultValue() { return defaultValueGenerator.get(); }	"    public String defaultValue() {
        return defaultValueGenerator.get();
    }
"	@return the default value, or  null if there is no default value	@return the default value as a string; never null	1	0	4	4	13
protected Object convertDouble(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0.0d; } if (data instanceof Double) return data; if (data instanceof Number) { // Includes BigDecimal and other numeric values ... Number value = (Number) data; return Double.valueOf(value.doubleValue()); } if (data instanceof SpecialValueDecimal) { return ((SpecialValueDecimal)data).toDouble(); } if (data instanceof Boolean) { return NumberConversions.getDouble((Boolean) data); } return handleUnknownData(column, fieldDefn, data); }	"    protected Object convertDouble(Column column, Field fieldDefn, Object data) {
        if (data == null) {
            data = fieldDefn.schema().defaultValue();
        }
        if (data == null) {
            if (column.isOptional()) return null;
            return 0.0d;
        }
        if (data instanceof Double) return data;
        if (data instanceof Number) {
            // Includes BigDecimal and other numeric values ...
            Number value = (Number) data;
            return Double.valueOf(value.doubleValue());
        }
        if (data instanceof DebeziumDecimal) {
            return ((DebeziumDecimal)data).toDouble();
        }
        if (data instanceof Boolean) {
            return NumberConversions.getDouble((Boolean) data);
        }
        return handleUnknownData(column, fieldDefn, data);
    }
"	@return the converted value, or null if the conversion could not be made and the column allows nulls	@return the converted value, or null if the conversion could not be made and the column allows nulls	0	1	8	23	141
"private static File findBinary(String... binaryNames) { final String[] paths = System.getenv(""PATH"").split(File.pathSeparator); for (String binaryName : binaryNames) { for (String path : paths) { File file = new File(path, binaryName); if (file.exists()) { return file; } if (Platform.getCurrent().is(Platform.WINDOWS)) { File exe = new File(path, binaryName + "".exe""); if (exe.exists()) { return exe; } } } } return null; }"	"  private static File findBinary(String... binaryNames) {
    final String[] paths = System.getenv(""PATH"").split(File.pathSeparator);
    for (String binaryName : binaryNames) {
      for (String path : paths) {
        File file = new File(path, binaryName);
        if (file.exists()) {
          return file;
        }
      }
    }
    return null;
  }
"	@return the first binary found matching that name.	@return the first binary found matching that name.	0	1	13	19	111
@Action(value = STR) public String execute() throws Exception { if (statusMessage == null || statusMessage.trim().length() == NUM) { request.setAttribute(STR, STR); return STR; } SASFHelper helper = SASFStaticHelper.getHelper(request); SocialAuthManager manager = helper.getAuthManager(); AuthProvider provider = null; if (manager != null) { provider = manager.getCurrentAuthProvider(); } if (provider != null) { try { provider.updateStatus(statusMessage); request.setAttribute(STR, STR); return STR; } catch (SocialAuthException e) { request.setAttribute(STR, e.getMessage()); e.printStackTrace(); } } return STR; }	"@Override
public ActionForward execute(final ActionMapping mapping, final ActionForm form, final HttpServletRequest request, final HttpServletResponse response) throws Exception {
    String statusMsg = request.getParameter(STR);
    if (statusMsg == null || statusMsg.trim().length() == NUM) {
        request.setAttribute(STR, STR);
        return mapping.findForward(STR);
    }
    SASFHelper helper = SASFStaticHelper.getHelper(request);
    SocialAuthManager manager = helper.getAuthManager();
    AuthProvider provider = null;
    if (manager != null) {
        provider = manager.getCurrentAuthProvider();
    }
    if (provider != null) {
        try {
            provider.updateStatus(statusMsg);
            request.setAttribute(STR, STR);
            return mapping.findForward(STR);
        } catch (SocialAuthException e) {
            request.setAttribute(STR, e.getMessage());
            e.printStackTrace();
        }
    }
    return mapping.findForward(STR);
}"	@return String where the action should flow	@return ActionForward where the action should flow	1	0	9	24	130
public boolean add(Tag tag) { return isCategoryValid(tag.getCategory()) && mSelectedTopics.add(tag); }	"public boolean add(String tagId, String category) {
    return isCategoryValid(category) && mSelectedTopics.add(tagId);
}"	@return True if the set of filters was modified by this call.	@return boolean Returns a boolean to indicate whether the operation was successful.	1	0	6	3	25
public RelNode decorrelate(SqlNode query, RelNode rootRel) { if (!enableDecorrelation()) { return rootRel; } final RelNode result = decorrelateQuery(rootRel); if (result != rootRel) { checkConvertedType(query, result); } return result; }	"  public RelNode decorrelate(SqlNode query, RelNode rootRel) {
    RelNode result = rootRel;
    if (enableDecorrelation()
        && hasCorrelation()) {
      result = decorrelateQuery(result);
      checkConvertedType(query, result);
    }
    return result;
  }
"	@return New root relational expression after decorrelation	@return New root relational expression after decorrelation	0	1	7	11	50
public synchronized IConfigurationElement[] getContainerExtensions(String containerid, String[] containerPaths) { if (extensions == null) processProxyExtensionExtensionPoint(); return (IConfigurationElement[]) extensions.containerPathContributions.getContributors(containerid, containerPaths); }	"public synchronized IConfigurationElement[] getContainerExtensions(String containerid) {
    if (containerToExtensions == null)
        processProxyExtensionExtensionPoint();
    return (IConfigurationElement[]) containerToExtensions.get(containerid);
}"	@return Array of configuration elements.	@return Array of extension registration elements or <code>null</code> if this container has no contributions.	1	0	6	5	41
"public boolean getBoolean(String name, boolean defaultValue) { String value = getString(name); return (value != null) && (value.equals(""1"") || value.toLowerCase().equals(""true"")); }"	"  public boolean getBoolean(String name, boolean defaultValue) {
    String value = this.getAttribute(name, Boolean.toString(defaultValue));
    return value.equals(""1"") || value.toLowerCase().equals(""true"");
  }
"	@return the value, or defaultValue if the attribute does not exist.	@return the value, or defaultValue if the attribute does not exist.	0	1	8	5	49
public String toLowerCase() { return CaseMapper.toLowerCase(Locale.getDefault(), this, value, offset, count); }	"public String toLowerCase() {
    return toLowerCase(Locale.getDefault());
}"	@return a new lowercase string, or {@code this} if it's already all-lowercase.	@return a new string containing the lowercase characters equivalent to the characters in this string.	1	0	5	3	25
public boolean searchButton(String text, int minimumNumberOfMatches, boolean onlyVisible) { return searcher.searchWithTimeoutFor(Button.class, text, minimumNumberOfMatches, true, onlyVisible); }	"	public boolean searchButton(String text, int minimumNumberOfMatches, boolean onlyVisible) {
		boolean found = searcher.searchWithTimeoutFor(Button.class, text, minimumNumberOfMatches, true, onlyVisible);
		return found;
	}
"	@return  true if a  Button with the given text is found a given number of times and  false if it is not found	@return true if a Button with the given text is found a given number of times and false if it is not found	0	1	6	4	31
public boolean dependsOn(Collection<AddOn> addOns) { if (dependencies == null || dependencies.getAddOns().isEmpty()) { return false; } for (AddOn addOn : addOns) { if (dependsOn(addOn)) { return true; } } return false; }	"public boolean dependsOn(AddOn addOn) {
    if (dependencies == null || dependencies.getAddOns().isEmpty()) {
        return false;
    }
    return dependsOn(dependencies.getAddOns(), addOn);
}"	@return {@code true} if it depends on any of the given add-ons, {@code false} otherwise.	@return {@code true} if it depends on the given add-on, {@code false} otherwise.	1	0	8	11	53
public static boolean deleteDir(File dir) { if (dir.isDirectory()) { String[] children = dir.list(); if (children == null) { return false; } for (String aChildren : children) { boolean success = deleteDir(new File(dir, aChildren)); if (!success) { return false; } } } return dir.delete(); }	"  public static boolean deleteDir(File dir) {
    if (dir.isDirectory()) {
      String[] children = dir.list();
      for (String aChildren : children) {
        boolean success = deleteDir(new File(dir, aChildren));
        if (!success)
          return false;
      }
    }

    return dir.delete();
  }
"	@return true on success; false, otherwise.	@return true on success; false, otherwise.	0	1	11	17	76
@Deprecated public Object getField() { return getValue(); }	"public Object getField() {
    return field;
}"	@return the value for this accumulator	@return the field for this accumulator	1	0	4	4	14
public static Builder create() { return new Builder() { private Properties props = new Properties(); @Override public Builder with(String key, String value) { props.setProperty(key, value); return this; } @Override public Builder withDefault(String key, String value) { if (!props.containsKey(key)) { props.setProperty(key, value); } return this; } @Override public Builder apply(Consumer<Builder> function) { function.accept(this); return this; } @Override public JdbcConfiguration build() { return JdbcConfiguration.adapt(Configuration.from(props)); } @Override public String toString() { return props.toString(); } }; }	"    public static Builder create() {
        return new Builder() {
            private Properties props = new Properties();

            @Override
            public Builder with(String key, String value) {
                props.setProperty(key, value);
                return this;
            }

            @Override
            public JdbcConfiguration build() {
                return JdbcConfiguration.adapt(Configuration.from(props));
            }

            @Override
            public String toString() {
                return props.toString();
            }
        };
    }
"	@return the configuration builder	@return the configuration builder	0	1	10	36	141
public RedeliveryPolicy getRedeliveryPolicy() throws JMSException { return redeliveryPolicyMap.getDefaultEntry(); }	"    public RedeliveryPolicy getRedeliveryPolicy() throws JMSException {
        return redeliveryPolicy;
    }
"	@return Returns the RedeliveryPolicy.	@return Returns the RedeliveryPolicy.	0	1	4	4	15
public boolean isEmpty(){ return pendingCount <= 0; }	"    public boolean isEmpty(){
        return empty;
    }
"	@return true if there are no pendingCount messages	@return true if there are no pending messages	1	0	5	4	11
"public int yylex() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; // set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { if (DBG) System.err.printf(""Accepting |%s|%n"", yytext()); return ACCEPT; } case 4: break; case 2: { return IGNORE; } case 5: break; case 3: { if (DBG) System.err.printf(""Ignoring |%s|%n"", yytext()); return IGNORE; } case 6: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; return YYEOF; } else { zzScanError(ZZ_NO_MATCH); } } } }"	"  public int yylex() throws java.io.IOException {
    int zzInput;
    int zzAction;

    // cached fields:
    int zzCurrentPosL;
    int zzMarkedPosL;
    int zzEndReadL = zzEndRead;
    char [] zzBufferL = zzBuffer;
    char [] zzCMapL = ZZ_CMAP;

    int [] zzTransL = ZZ_TRANS;
    int [] zzRowMapL = ZZ_ROWMAP;
    int [] zzAttrL = ZZ_ATTRIBUTE;

    while (true) {
      zzMarkedPosL = zzMarkedPos;

      zzAction = -1;

      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
  
      zzState = ZZ_LEXSTATE[zzLexicalState];

      // set up zzAction for empty match case:
      int zzAttributes = zzAttrL[zzState];
      if ( (zzAttributes & 1) == 1 ) {
        zzAction = zzState;
      }


      zzForAction: {
        while (true) {
    
          if (zzCurrentPosL < zzEndReadL)
            zzInput = zzBufferL[zzCurrentPosL++];
          else if (zzAtEOF) {
            zzInput = YYEOF;
            break zzForAction;
          }
          else {
            // store back cached positions
            zzCurrentPos  = zzCurrentPosL;
            zzMarkedPos   = zzMarkedPosL;
            boolean eof = zzRefill();
            // get translated positions and possibly new buffer
            zzCurrentPosL  = zzCurrentPos;
            zzMarkedPosL   = zzMarkedPos;
            zzBufferL      = zzBuffer;
            zzEndReadL     = zzEndRead;
            if (eof) {
              zzInput = YYEOF;
              break zzForAction;
            }
            else {
              zzInput = zzBufferL[zzCurrentPosL++];
            }
          }
          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
          if (zzNext == -1) break zzForAction;
          zzState = zzNext;

          zzAttributes = zzAttrL[zzState];
          if ( (zzAttributes & 1) == 1 ) {
            zzAction = zzState;
            zzMarkedPosL = zzCurrentPosL;
            if ( (zzAttributes & 8) == 8 ) break zzForAction;
          }

        }
      }

      // store back cached position
      zzMarkedPos = zzMarkedPosL;

      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
        case 1: 
          { if (DBG) System.err.printf(""Accepting |%s|, staying in YYINITIAL%n"", yytext());
                          return ACCEPT;
          }
        case 19: break;
        case 2: 
          { return IGNORE;
          }
        case 20: break;
        case 3: 
          { reportError(yytext());
          }
        case 21: break;
        case 4: 
          { if (DBG) System.err.printf(""Ignoring |%s|, staying in YYINITIAL%n"", yytext());
                          return IGNORE;
          }
        case 22: break;
        case 5: 
          { if (DBG) System.err.printf(""Ignoring |%s|, moving to DATETIME%n"", yytext());
                          yybegin(DATETIME); return IGNORE;
          }
        case 23: break;
        case 6: 
          { yybegin(DATEINHEADER); return IGNORE;
          }
        case 24: break;
        case 7: 
          { if (DBG) System.err.printf(""Ignoring |%s|, moving to DOCNO%n"", yytext());
                          yybegin(DOCNO); return IGNORE;
          }
        case 25: break;
        case 8: 
          { if (DBG) System.err.printf(""Ignoring |%s|, moving to SRCID%n"", yytext());
                          yybegin(SRCID); return IGNORE;
          }
        case 26: break;
        case 9: 
          { //System.err.println(""Transitioning to YYINITIAL"");
                   yybegin(YYINITIAL); return IGNORE;
          }
        case 27: break;
        case 10: 
          { yybegin(HEADER); return IGNORE;
          }
        case 28: break;
        case 11: 
          { if (DBG) System.err.printf(""Ignoring |%s|, moving to HEADER%n"", yytext());
                          yybegin(HEADER); return IGNORE;
          }
        case 29: break;
        case 12: 
          { // System.err.println(""Transitioning to YYINITIAL"");
                  yybegin(YYINITIAL); return IGNORE;
          }
        case 30: break;
        case 13: 
          { //System.err.println(""In SRCID; Transitioning to YYINITIAL"");
                yybegin(YYINITIAL); return IGNORE;
          }
        case 31: break;
        case 14: 
          { //System.err.println(""Transitioning to YYINITIAL"");
                yybegin(YYINITIAL); return IGNORE;
          }
        case 32: break;
        case 15: 
          { if (DBG) System.err.printf(""Ignoring |%s|, moving to DOCTYPE%n"", yytext());
                          yybegin(DOCTYPE); return IGNORE;
          }
        case 33: break;
        case 16: 
          { if (DBG) System.err.printf(""Ignoring |%s|, moving to PREAMBLE%n"", yytext());
                          yybegin(PREAMBLE); return IGNORE;
          }
        case 34: break;
        case 17: 
          { //System.err.println(""Transitioning to YYINITIAL"");
                  yybegin(YYINITIAL); return IGNORE;
          }
        case 35: break;
        case 18: 
          { yybegin(YYINITIAL); return IGNORE;
          }
        case 36: break;
        default: 
          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
            zzAtEOF = true;
            return YYEOF;
          } 
          else {
            zzScanError(ZZ_NO_MATCH);
          }
      }
    }
  }
"	@return the next token	@return the next token	0	1	17	102	415
"private boolean isSpillNeeded(int incomingSize) { if (bufferedBatches.size() >= config.getBufferedBatchLimit()) { return true; } // Can't spill if less than two batches else the merge // can't make progress. final boolean spillNeeded = memManager.isSpillNeeded(allocator.getAllocatedMemory(), incomingSize); if (bufferedBatches.size() < 2) { // If we can't fit the batch into memory, then place a definite error // message into the log to simplify debugging. if (spillNeeded) { logger.error(""Insufficient memory to merge two batches. Incoming batch size: {}, available memory: {}"", incomingSize, memManager.freeMemory(allocator.getAllocatedMemory())); } return false; } return spillNeeded; }"	"  private boolean isSpillNeeded(int incomingSize) {

    // Can't spill if less than two batches else the merge
    // can't make progress.

    if (bufferedBatches.size() < 2) {
      return false; }

    if (bufferedBatches.size() >= config.getBufferedBatchLimit()) {
      return true; }
    return memManager.isSpillNeeded(allocator.getAllocatedMemory(), incomingSize);
  }
"	@return true if spilling is needed (and possible), false otherwise	@return true if spilling is needed, false otherwise	1	0	10	25	145
public Remote getPort(QName portName, Class proxyInterface) throws ServiceException { Remote stub = getGeneratedStub(portName, proxyInterface); return stub != null ? stub : getPort(null, portName, proxyInterface); }	"public Remote getPort(QName portName, Class proxyInterface) throws ServiceException {
    return getPort(null, portName, proxyInterface);
}"	@return java.rmi.Remote The stub implementation.	@return java.rmi.Remote ...	1	0	6	4	39
private ConnectionJDBC getConnection() throws SQLException { return (ConnectionJDBC) statement.getConnection(); }	"private ConnectionJDBC2 getConnection() throws SQLException {
    return (ConnectionJDBC2) statement.getConnection();
}"	@return {@link ConnectionJDBC} object.	@return {@link ConnectionJDBC2} object.	1	0	5	3	18
public DurationType getDurationType(Object object) { return DurationType.getMillisType(); }	"    public DurationType getDurationType(Object object) {
        return DurationType.getAverageYearMonthType();
    }
"	@return the duration type, never null	@return the duration type, never null	0	1	4	4	15
public boolean clearReference() { return sScheduler.clearReference(this); }	"    public void clearReference() {
        sScheduler.clearReference(this);
    }
"	@return true if the handler wants to stay alive.	@return true if the handler wants to stay alive.	0	1	5	4	14
"public String toVarName(String name) { if (reservedWords.contains(name)) { return escapeReservedWord(name); } else if (((CharSequence) name).chars().anyMatch(character -> specialCharReplacements.keySet().contains( """" + ((char) character)))) { return escapeSpecialCharacters(name, null, null); } else { return name; } }"	"    public String toVarName(String name) {
        if (reservedWords.contains(name)) {
            return escapeReservedWord(name);
        } else {
            return name;
        }
    }
"	@return the sanitized variable name	@return the sanitized variable name	0	1	8	10	77
protected EngineParameterMetaData getParameterMetaData() throws SQLException { if (stmtPmeta != null) return stmtPmeta; stmtPmeta = ((EnginePreparedStatement) ps).getEmbedParameterSetMetaData(); return stmtPmeta; }	"protected EmbedParameterSetMetaData getParameterMetaData() throws SQLException {
    if (stmtPmeta != null)
        return stmtPmeta;
    EmbedParameterSetMetaData pmeta = null;
    Class[] getParameterMetaDataParam = {};
    try {
        Method sh = getPreparedStatement().getClass().getMethod(STR, getParameterMetaDataParam);
        pmeta = (EmbedParameterSetMetaData) sh.invoke(getPreparedStatement(), null);
        stmtPmeta = pmeta;
    } catch (Exception e) {
        handleReflectionException(e);
    }
    return stmtPmeta;
}"	@return EngineParameterMetaData for the prepared statement. Note: there is no separate BrokeredParameterSetMetaData.	@return EmbedParameterSetMetaData for the prepared statement. Note: there is no separate BrokeredParameterSetMetaData.	1	0	6	6	32
public List<Integer> getHistoryIdsOfHistType(long sessionId, int... histTypes) throws DatabaseException { return getHistoryIdsByParams(sessionId, 0, true, histTypes); }	"    public List<Integer> getHistoryIdsOfHistType(long sessionId, int... histTypes) throws DatabaseException {
        try {
			boolean hasHistTypes = histTypes != null && histTypes.length > 0;
			int strLength = hasHistTypes ? 97 : 68;
			StringBuilder strBuilder = new StringBuilder(strLength);
			strBuilder.append(""SELECT "").append(HISTORYID);
			strBuilder.append("" FROM "").append(TABLE_NAME).append("" WHERE "").append(SESSIONID).append("" = ?"");
			if (hasHistTypes) {
			    strBuilder.append("" AND "").append(HISTTYPE).append("" IN ( UNNEST(?) )"");
			}
			strBuilder.append("" ORDER BY "").append(HISTORYID);

			try (PreparedStatement psReadSession = getConnection().prepareStatement(strBuilder.toString())) {

			    psReadSession.setLong(1, sessionId);
			    if (hasHistTypes) {
			        Array arrayHistTypes = getConnection().createArrayOf(""INTEGER"", ArrayUtils.toObject(histTypes));
			        psReadSession.setArray(2, arrayHistTypes);
			    }
			    try (ResultSet rs = psReadSession.executeQuery()) {
			        ArrayList<Integer> ids = new ArrayList<>();
			        while (rs.next()) {
			            ids.add(rs.getInt(HISTORYID));
			        }
			        ids.trimToSize();

			        return ids;
			    }
			}
		} catch (SQLException e) {
			throw new DatabaseException(e);
		}
    }
"	@return a  List with all the history IDs of the given session and history types, never  null	@return a List with all the history IDs of the given session and history types, never null	0	1	5	4	27
public static boolean removeWorkspaceOrFolderItem(Launcher launcher, ItemInfo item, View view) { if (item instanceof ShortcutInfo) { LauncherModel.deleteItemFromDatabase(launcher, item); } else if (item instanceof FolderInfo) { FolderInfo folder = (FolderInfo) item; launcher.removeFolder(folder); LauncherModel.deleteFolderContentsFromDatabase(launcher, folder); } else if (item instanceof LauncherAppWidgetInfo) { final LauncherAppWidgetInfo widget = (LauncherAppWidgetInfo) item; // Remove the widget from the workspace launcher.removeAppWidget(widget); LauncherModel.deleteItemFromDatabase(launcher, widget); final LauncherAppWidgetHost appWidgetHost = launcher.getAppWidgetHost(); if (appWidgetHost != null && !widget.isCustomWidget() && widget.isWidgetIdValid()) { // Deleting an app widget ID is a void call but writes to disk before returning // to the caller... new AsyncTask<Void, Void, Void>() { public Void doInBackground(Void ... args) { appWidgetHost.deleteAppWidgetId(widget.appWidgetId); return null; } }.executeOnExecutor(Utilities.THREAD_POOL_EXECUTOR); } } else { return false; } if (view != null) { launcher.getWorkspace().removeWorkspaceItem(view); launcher.getWorkspace().stripEmptyScreens(); } return true; }	"    public static boolean removeWorkspaceOrFolderItem(Launcher launcher, ItemInfo item, View view) {
        // Remove the item from launcher and the db, we can ignore the containerInfo in this call
        // because we already remove the drag view from the folder (if the drag originated from
        // a folder) in Folder.beginDrag()
        launcher.removeItem(view, null, item, true /* deleteFromDb */);
        launcher.getWorkspace().stripEmptyScreens();
        return true;
    }
"	@return true if the item was removed.	@return true if the item was removed.	0	1	14	38	222
protected final Map<K, V> copyMap(Map<K, Expirable<V>> map) { ClassLoader classLoader = cacheManager.getClassLoader(); return map.entrySet().stream().collect(toMap(entry -> copier.copy(entry.getKey(), classLoader), entry -> copier.copy(entry.getValue().get(), classLoader))); }	"protected final Map<K, V> copyMap(Map<K, Expirable<V>> map) {
    ClassLoader classLoader = cacheManager.getClassLoader();
    return map.entrySet().stream().collect(Collectors.toMap(entry -> copier.copy(entry.getKey(), classLoader), entry -> copier.copy(entry.getValue().get(), classLoader)));
}"	@return a deep or shallow copy of the mappings depending on the store by value setting	@return a copy of the mappings if storing by value or the same instance if by reference	1	0	10	4	67
public ServiceReference getServiceReference() { return m_ps.getServiceReference(); }	"public ServiceReference getServiceReference() {
    return m_serviceReference;
}"	@return the service reference (null if the service is unregistered).	@return the service reference (null if the service is unregistred).	1	0	4	3	13
static public IStructuredTextExpert getExpert(String type, StructuredTextEnvironment environment) { IStructuredTextExpert expert; if (environment == null) environment = StructuredTextEnvironment.DEFAULT; synchronized (sharedExperts) { Map experts = (Map) sharedExperts.get(type); if (experts == null) { experts = new HashMap(); sharedExperts.put(type, experts); } expert = (IStructuredTextExpert) experts.get(environment); if (expert == null) { StructuredTextTypeHandler handler = StructuredTextTypeHandlerFactory.getHandler(type); if (handler == null) throw new IllegalArgumentException(STR); expert = new StructuredTextImpl(handler, environment, false); experts.put(type, expert); } } return expert; }	"static public ISTextExpert getExpert(String type, STextEnvironment environment) {
    ISTextExpert expert;
    if (environment == null)
        environment = STextEnvironment.DEFAULT;
    synchronized (sharedExperts) {
        Map experts = (Map) sharedExperts.get(type);
        if (experts == null) {
            experts = new HashMap();
            sharedExperts.put(type, experts);
        }
        expert = (ISTextExpert) experts.get(environment);
        if (expert == null) {
            STextTypeHandler handler = STextTypeHandlerFactory.getHandler(type);
            if (handler == null)
                throw new IllegalArgumentException(STR);
            expert = new STextImpl(handler, environment, false);
            experts.put(type, expert);
        }
    }
    return expert;
}"	@return the IStructuredTextExpert instance.	@return the ISTextExpert instance.	1	0	9	21	122
protected SqlSelect createSourceSelectForDelete(SqlDelete call) { final SqlNodeList selectList = new SqlNodeList(SqlParserPos.ZERO); selectList.add(SqlIdentifier.star(SqlParserPos.ZERO)); SqlNode sourceTable = call.getTargetTable(); if (call.getAlias() != null) { sourceTable = SqlValidatorUtil.addAlias( sourceTable, call.getAlias().getSimple()); } return new SqlSelect(SqlParserPos.ZERO, null, selectList, sourceTable, call.getCondition(), null, null, null, null, null, null, null); }	"  protected SqlSelect createSourceSelectForDelete(SqlDelete call) {
    final SqlNodeList selectList = new SqlNodeList(SqlParserPos.ZERO);
    selectList.add(SqlIdentifier.star(SqlParserPos.ZERO));
    SqlNode sourceTable = call.getTargetTable();
    if (call.getAlias() != null) {
      sourceTable =
          SqlValidatorUtil.addAlias(
              sourceTable,
              call.getAlias().getSimple());
    }
    return new SqlSelect(SqlParserPos.ZERO, null, selectList, sourceTable,
        call.getCondition(), null, null, null, null, null, null);
  }
"	@return select statement	@return select statement	0	1	9	14	96
public static MerkleTreeLeaf parseMerkleTreeLeaf(InputStream in) { int version = (int) readNumber(in, CTConstants.VERSION_LENGTH); if (version != Ct.Version.V1.getNumber()) { throw new SerializationException(String.format(STR, version)); } int leafType = (int) readNumber(in, NUM); if (leafType != Ct.MerkleLeafType.TIMESTAMPED_ENTRY_VALUE) { throw new SerializationException(String.format(STR, leafType)); } return new MerkleTreeLeaf(Ct.Version.valueOf(version), Ct.MerkleLeafType.valueOf(leafType), parseTimestampedEntry(in)); }	"public static Ct.MerkleTreeLeaf parseMerkleTreeLeaf(InputStream in) {
    Ct.MerkleTreeLeaf.Builder merkleTreeLeafBuilder = Ct.MerkleTreeLeaf.newBuilder();
    int version = (int) readNumber(in, CTConstants.VERSION_LENGTH);
    if (version != Ct.Version.V1.getNumber()) {
        throw new SerializationException(String.format(STR, version));
    }
    merkleTreeLeafBuilder.setVersion(Ct.Version.valueOf(version));
    int leafType = (int) readNumber(in, NUM);
    if (leafType != Ct.MerkleLeafType.TIMESTAMPED_ENTRY_VALUE) {
        throw new SerializationException(String.format(STR, leafType));
    }
    merkleTreeLeafBuilder.setType(Ct.MerkleLeafType.valueOf(leafType));
    merkleTreeLeafBuilder.setTimestampedEntry((parseTimestampedEntry(in)));
    return merkleTreeLeafBuilder.build();
}"	@return Built {@link MerkleTreeLeaf}.	@return Built {@link Ct.MerkleTreeLeaf}.	1	0	8	11	108
public T caseCustomersType(CustomersType object) { return null; }	"public Object caseCustomersType(CustomersType object) {
    return null;
}"	@return the result of interpretting the object as an instance of '<em>Customers Type</em>'.	@return the result of interpretting the object as an instance of '<em>sType</em>'.	1	0	4	3	12
public JSONArray getJSONArray(String key) { Object object = this.get(key); if (object == null) { return null; } if (object instanceof JSONArray) { return (JSONArray) object; } throw new RuntimeException(STR + quote(key) + STR); }	"public JSONArray getJSONArray(String key) {
    Object object = this.get(key);
    if (object instanceof JSONArray) {
        return (JSONArray) object;
    }
    throw new RuntimeException(STR + quote(key) + STR);
}"	@return A JSONArray which is the value, or null if not present	@return A JSONArray which is the value.	1	0	8	10	55
private ZapTextField getTxtFind() { if (txtFind == null) { txtFind = new ZapTextField(); txtFind.setMinimumSize(new java.awt.Dimension(120,24)); txtFind.setPreferredSize(new java.awt.Dimension(120,24)); } return txtFind; }	"	private JTextField getTxtFind() {
		if (txtFind == null) {
			txtFind = new JTextField();
			txtFind.setMinimumSize(new java.awt.Dimension(120,24));
			txtFind.setPreferredSize(new java.awt.Dimension(120,24));
		}
		return txtFind;
	}
"	@return javax.swing.ZapTextField	@return javax.swing.JTextField	1	0	10	9	51
"public static String getCharacterSet(String s) { if (s.charAt(0) == '\'') { return null; } if (Character.toUpperCase(s.charAt(0)) == 'N') { return CalciteSystemProperty.DEFAULT_NATIONAL_CHARSET.value(); } int i = s.indexOf(""'""); return s.substring(1, i); // skip prefixed '_' }"	"  public static String getCharacterSet(String s) {
    if (s.charAt(0) == '\'') {
      return null;
    }
    if (Character.toUpperCase(s.charAt(0)) == 'N') {
      return SaffronProperties.INSTANCE.defaultNationalCharset().get();
    }
    int i = s.indexOf(""'"");
    return s.substring(1, i); // skip prefixed '_'
  }
"	@return the character-set prefix of an sql string literal; returns null if there is none	@return the character-set prefix of an sql string literal; returns null if there is none	0	1	7	11	77
"public boolean searchForText(String regex, int matches, boolean scroll) { sleeper.sleep(); inst.waitForIdleSync(); Pattern p = Pattern.compile(regex); Matcher matcher; ArrayList<TextView> textViewList = viewFetcher.getCurrentViews(TextView.class); if(matches == 0) matches = 1; for(TextView textView : textViewList){ matcher = p.matcher(textView.getText().toString()); if(matcher.find()){ countMatches++; } if (countMatches == matches) { countMatches=0; return true; } } if (scroll && scroller.scroll(Scroller.Direction.DOWN)) { return searchForText(regex, matches, scroll); } else { if (countMatches > 0) Log.d(LOG_TAG, "" There are only "" + countMatches + "" matches of "" + regex); countMatches=0; return false; } }"	"	public boolean searchForText(String search, int matches, boolean scroll) {
		sleeper.sleep();
		inst.waitForIdleSync();
		Pattern p = Pattern.compile(search);
		Matcher matcher;
		ArrayList<TextView> textViewList = viewFetcher.getCurrentViews(TextView.class);
		if(matches == 0)
			matches = 1;
		for(TextView textView : textViewList){
			matcher = p.matcher(textView.getText().toString());
			if(matcher.find()){	
				countMatches++;
			}
			if (countMatches == matches) {
				countMatches=0;
				return true;
			}
		}

		if (scroll && scroller.scroll(Scroller.Direction.DOWN)) {
			return searchForText(search, matches, scroll);
		} else {
			if (countMatches > 0)
				Log.d(LOG_TAG, "" There are only "" + countMatches + "" matches of "" + search);
			countMatches=0;
			return false;
		}
		
	}
"	@return true if regex string is found a given number of times and false if the regex string is not found	@return true if search string is found a given number of times and false if the search string is not found	1	0	11	30	162
public static SummaryEntry[] querySummaries(Variations variationPatterns, String scenarioPattern) { return getDefault().internalQuerySummaries(variationPatterns, scenarioPattern); }	"public static SummaryEntry[] querySummaries(Variations variationPatterns, boolean global) {
    return getDefault().internalQuerySummaries(variationPatterns, null);
}"	@return array of summaries or <code>null</code> if an error occured.	@return array of SummaryEntries	1	0	6	3	26
public int replaceListener(int id, FileDownloadListener listener) { final BaseDownloadTask task = FileDownloadList.getImpl().get(id); if (task == null) { return 0; } task.setListener(listener); return task.getId(); }	"    public int replaceListener(int id, FileDownloadListener listener) {
        final BaseDownloadTask task = FileDownloadList.getImpl().get(id);
        if (task == null) {
            return 0;
        }

        task.setListener(listener);
        return task.getDownloadId();
    }
"	@return The target task's DownloadId, if not exist target task, and replace failed, will be 0.	@return The target task's DownloadId, if not exist target task, and replace failed, will be 0.	0	1	7	10	46
"public static Link parse(final String serialized) throws IllegalArgumentException { try { final String[] parts = serialized.split("":""); switch (parts.length) { case 2: { String[] nameSplit = parts[0].split(""/""); String[] aliasSplit = parts[1].split(""/""); return new Link(nameSplit[nameSplit.length - 1], aliasSplit[aliasSplit.length - 1]); } default: { throw new IllegalArgumentException(); } } } catch (final Exception e) { throw new IllegalArgumentException(""Error parsing Link '"" + serialized + ""'""); } }"	"	public static Link parse(final String serialized) throws IllegalArgumentException
	{
		try {
			final String[] parts = serialized.split("":"");
			switch (parts.length) {
			case 2: {
				return new Link(parts[0], parts[1]);
			}
			default: {
				throw new IllegalArgumentException();
			}
			}
		} catch (final Exception e) {
			throw new IllegalArgumentException(""Error parsing Link '"" + serialized + ""'"");
		}
	}
"	@return a  Link matching the specification	@return a Link matching the specification	0	1	12	19	128
"public Object convert(Column column, String value) { if (value == null) { return value; } // boolean is also TINYINT(1) if (""TINYINT"".equals(column.typeName())) { if (""true"".equalsIgnoreCase(value) || ""false"".equalsIgnoreCase(value)) { return convertToBoolean(value); } } switch (column.jdbcType()) { case Types.DATE: return convertToLocalDate(column, value); case Types.TIMESTAMP: return convertToLocalDateTime(column, value); case Types.TIMESTAMP_WITH_TIMEZONE: return convertToTimestamp(column, value); case Types.TIME: return convertToDuration(column, value); case Types.BOOLEAN: return convertToBoolean(value); case Types.BIT: return convertToBits(column, value); case Types.NUMERIC: case Types.DECIMAL: return convertToDecimal(column, value); case Types.FLOAT: case Types.DOUBLE: case Types.REAL: return convertToDouble(value); } return value; }"	"    public Object convert(Column column, String value) {
        if (value == null) {
            return value;
        }
        switch (column.jdbcType()) {
        case Types.DATE:
            return convertToLocalDate(column, value);
        case Types.TIMESTAMP:
            return convertToLocalDateTime(column, value);
        case Types.TIMESTAMP_WITH_TIMEZONE:
            return convertToTimestamp(column, value);
        case Types.TIME:
            return convertToDuration(column, value);
        case Types.BOOLEAN:
            return convertToBoolean(value);
        case Types.BIT:
            return convertToBits(column, value);

        case Types.NUMERIC:
        case Types.DECIMAL:
            return convertToDecimal(column, value);

        case Types.FLOAT:
        case Types.DOUBLE:
        case Types.REAL:
            return convertToDouble(value);
        }
        return value;
    }
"	@return value converted to a Java type	@return value converted to a Java type	0	1	9	37	189
private String prepareQueryString(String groupPath, String jobName, Properties options) { List<NameValuePair> parameters = new ArrayList<NameValuePair>(); parameters.add(new BasicNameValuePair(STR, groupPath)); parameters.add(new BasicNameValuePair(STR, jobName)); if (options != null) { for (Entry<Object, Object> option : options.entrySet()) { parameters.add(new BasicNameValuePair(STR + option.getKey(), String.valueOf(option.getValue()))); } } return URLEncodedUtils.format(parameters, HTTP.UTF_8); }	"private NameValuePair[] prepareQueryString(String groupPath, String jobName, Properties options) {
    List<NameValuePair> queryString = new ArrayList<NameValuePair>();
    queryString.add(new NameValuePair(STR, groupPath));
    queryString.add(new NameValuePair(STR, jobName));
    if (options != null) {
        for (Entry<Object, Object> option : options.entrySet()) {
            queryString.add(new NameValuePair(STR + option.getKey(), String.valueOf(option.getValue())));
        }
    }
    return queryString.toArray(new NameValuePair[queryString.size()]);
}"	@return an url-encoded string	@return an array of {@link NameValuePair}, won't be null or empty (at least 2 entries : group and job)	1	0	11	11	105
"public boolean addFile(File sourceFile) { String filename = sourceFile.getName(); File destFile = null; String codeExtension = null; boolean replacement = false; // if the file appears to be code related, drop it // into the code folder, instead of the data folder if (filename.toLowerCase().endsWith("".class"") || filename.toLowerCase().endsWith("".jar"") || filename.toLowerCase().endsWith("".dll"") || filename.toLowerCase().endsWith("".jnilib"") || filename.toLowerCase().endsWith("".so"")) { //if (!codeFolder.exists()) codeFolder.mkdirs(); prepareCodeFolder(); destFile = new File(codeFolder, filename); } else { for (String extension : getExtensions()) { String lower = filename.toLowerCase(); if (lower.endsWith(""."" + extension)) { destFile = new File(this.folder, filename); codeExtension = extension; } } if (codeExtension == null) { prepareDataFolder(); destFile = new File(dataFolder, filename); } } // check whether this file already exists if (destFile.exists()) { Object[] options = { ""OK"", ""Cancel"" }; String prompt = ""Replace the existing version of "" + filename + ""?""; int result = JOptionPane.showOptionDialog(editor, prompt, ""Replace"", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options[0]); if (result == JOptionPane.YES_OPTION) { replacement = true; } else { return false; } } // If it's a replacement, delete the old file first, // otherwise case changes will not be preserved. // http://dev.processing.org/bugs/show_bug.cgi?id=969 if (replacement) { boolean muchSuccess = destFile.delete(); if (!muchSuccess) { Base.showWarning(""Error adding file"", ""Could not delete the existing '"" + filename + ""' file."", null); return false; } } // make sure they aren't the same file if ((codeExtension == null) && sourceFile.equals(destFile)) { Base.showWarning(""You can't fool me"", ""This file has already been copied to the\n"" + ""location from which where you're trying to add it.\n"" + ""I ain't not doin nuthin'."", null); return false; } // in case the user is ""adding"" the code in an attempt // to update the sketch's tabs if (!sourceFile.equals(destFile)) { try { Base.copyFile(sourceFile, destFile); } catch (IOException e) { Base.showWarning(""Error adding file"", ""Could not add '"" + filename + ""' to the sketch."", e); return false; } } if (codeExtension != null) { SketchCode newCode = new SketchCode(destFile, codeExtension); if (replacement) { replaceCode(newCode); } else { insertCode(newCode); sortCode(); } setCurrentCode(filename); editor.header.repaint(); if (editor.untitled) { // TODO probably not necessary? problematic? // Mark the new code as modified so that the sketch is saved current.setModified(true); } } else { if (editor.untitled) { // TODO probably not necessary? problematic? // If a file has been added, mark the main code as modified so // that the sketch is properly saved. code[0].setModified(true); } } return true; }"	"  public boolean addFile(File sourceFile) {
    String filename = sourceFile.getName();
    File destFile = null;
    String codeExtension = null;
    boolean replacement = false;

    // if the file appears to be code related, drop it
    // into the code folder, instead of the data folder
    if (filename.toLowerCase().endsWith("".class"") ||
        filename.toLowerCase().endsWith("".jar"") ||
        filename.toLowerCase().endsWith("".dll"") ||
        filename.toLowerCase().endsWith("".jnilib"") ||
        filename.toLowerCase().endsWith("".so"")) {

      //if (!codeFolder.exists()) codeFolder.mkdirs();
      prepareCodeFolder();
      destFile = new File(codeFolder, filename);

    } else {
      for (String extension : getExtensions()) {
        String lower = filename.toLowerCase();
        if (lower.endsWith(""."" + extension)) {
          destFile = new File(this.folder, filename);
          codeExtension = extension;
        }
      }
      if (codeExtension == null) {
        prepareDataFolder();
        destFile = new File(dataFolder, filename);
      }
    }

    // check whether this file already exists
    if (destFile.exists()) {
      Object[] options = { ""OK"", ""Cancel"" };
      String prompt = ""Replace the existing version of "" + filename + ""?"";
      int result = JOptionPane.showOptionDialog(editor,
                                                prompt,
                                                ""Replace"",
                                                JOptionPane.YES_NO_OPTION,
                                                JOptionPane.QUESTION_MESSAGE,
                                                null,
                                                options,
                                                options[0]);
      if (result == JOptionPane.YES_OPTION) {
        replacement = true;
      } else {
        return false;
      }
    }

    // make sure they aren't the same file
    if ((codeExtension == null) && sourceFile.equals(destFile)) {
      Base.showWarning(""You can't fool me"",
                       ""This file has already been copied to the\n"" +
                       ""location from which where you're trying to add it.\n"" +
                       ""I ain't not doin nuthin'."", null);
      return false;
    }

    // in case the user is ""adding"" the code in an attempt
    // to update the sketch's tabs
    if (!sourceFile.equals(destFile)) {
      try {
        Base.copyFile(sourceFile, destFile);

      } catch (IOException e) {
        Base.showWarning(""Error adding file"",
                         ""Could not add '"" + filename + ""' to the sketch."", e);
        return false;
      }
    }

    if (codeExtension != null) {
      SketchCode newCode = new SketchCode(destFile, codeExtension);

      if (replacement) {
        replaceCode(newCode);

      } else {
        insertCode(newCode);
        sortCode();
      }
      setCurrentCode(filename);
      editor.header.repaint();
      if (editor.untitled) {  // TODO probably not necessary? problematic?
        // Mark the new code as modified so that the sketch is saved
        current.setModified(true);
      }

    } else {
      if (editor.untitled) {  // TODO probably not necessary? problematic?
        // If a file has been added, mark the main code as modified so
        // that the sketch is properly saved.
        code[0].setModified(true);
      }
    }
    return true;
  }
"	@return true if successful.	@return true if successful.	0	1	13	113	708
public AggregateCall copy(List<Integer> args, int filterArg) { return new AggregateCall(aggFunction, distinct, args, filterArg, type, name); }	"  public AggregateCall copy(List<Integer> args) {
    return new AggregateCall(aggFunction, distinct, args, type, name);
  }
"	@return AggregateCall that suits new inputs and GROUP BY columns	@return AggregateCall that suits new inputs and GROUP BY columns	0	1	6	5	30
private XmlAttributeNode getScriptSourcePath(XmlTagNode node) { for (XmlAttributeNode attribute : node.getAttributes()) { if (attribute.getName().getLexeme().equals(SRC)) { return attribute; } } return null; }	"private String getScriptSourcePath(XmlTagNode node) {
    for (XmlAttributeNode attribute : node.getAttributes()) {
        if (attribute.getName().getLexeme().equals(SRC)) {
            String text = attribute.getText();
            return text != null && text.length() > NUM ? text : null;
        }
    }
    return null;
}"	@return the source attribute contained in the given tag	@return the source path or {@code null} if not defined	1	0	8	8	43
public static final Weblogger getRoller() { if (rollerInstance == null) { throw new IllegalStateException(STR); } return rollerInstance; }	"public static final Roller getRoller() {
    if (rollerInstance == null) {
        throw new IllegalStateException(STR);
    }
    return rollerInstance;
}"	@return Weblogger An instance of Weblogger.	@return Roller An instance of Roller.	1	0	7	6	26
@Override public final TYPE next() { if (next == null) { return fromIterator.next(); } else { final TYPE result = next; next = null; return result; } }	"@Override
public final TYPE next() {
    TYPE result = next;
    next = null;
    result = (result == null ? fromIterator.next() : result);
    return result;
}"	@return the next element of the Iterable, or null if not present.	@return the next element obf the iteration	1	0	7	10	37
"protected Tree determineNonTrivialHead(Tree t, Tree parent) { String motherCat = tlp.basicCategory(t.label().value()); if (DEBUG) { System.err.println(""At "" + motherCat + "", my parent is "" + parent); } // do VPs with auxiliary as special case if ((motherCat.equals(""VP"") || motherCat.equals(""SQ"") || motherCat.equals(""SINV""))) { Tree[] kids = t.children(); // try to find if there is an auxiliary verb if (DEBUG) { System.err.println(""Semantic head finder: at VP""); System.err.println(""Class is "" + t.getClass().getName()); t.pennPrint(System.err); //System.err.println(""hasVerbalAuxiliary = "" + hasVerbalAuxiliary(kids, verbalAuxiliaries)); } // looks for auxiliaries if (hasVerbalAuxiliary(kids, verbalAuxiliaries, true) || hasPassiveProgressiveAuxiliary(kids)) { // String[] how = new String[] {""left"", ""VP"", ""ADJP"", ""NP""}; // Including NP etc seems okay for copular sentences but is // problematic for other auxiliaries, like 'he has an answer' // But maybe doing ADJP is fine! String[] how = { ""left"", ""VP"", ""ADJP"" }; Tree pti = traverseLocate(kids, how, false); if (DEBUG) { System.err.println(""Determined head (case 1) for "" + t.value() + "" is: "" + pti); } if (pti != null) { return pti; // } else { // System.err.println(""------""); // System.err.println(""SemanticHeadFinder failed to reassign head for""); // t.pennPrint(System.err); // System.err.println(""------""); } } // looks for copular verbs if (hasVerbalAuxiliary(kids, copulars, false) && ! isExistential(t, parent) && ! isWHQ(t, parent)) { String[] how; if (motherCat.equals(""SQ"")) { how = new String[]{""right"", ""VP"", ""ADJP"", ""NP"", ""WHADJP"", ""WHNP""}; } else { how = new String[]{""left"", ""VP"", ""ADJP"", ""NP"", ""WHADJP"", ""WHNP""}; } Tree pti = traverseLocate(kids, how, false); // don't allow a temporal to become head if (pti != null && pti.label() != null && pti.label().value().contains(""-TMP"")) { pti = null; } // In SQ, only allow an NP to become head if there is another one to the left (then it's probably predicative) if (motherCat.equals(""SQ"") && pti != null && pti.label() != null && pti.label().value().startsWith(""NP"")) { boolean foundAnotherNp = false; for (Tree kid : kids) { if (kid == pti) { break; } else if (kid.label() != null && kid.label().value().startsWith(""NP"")) { foundAnotherNp = true; break; } } if ( ! foundAnotherNp) { pti = null; } } if (DEBUG) { System.err.println(""Determined head (case 2) for "" + t.value() + "" is: "" + pti); } if (pti != null) { return pti; } else { if (DEBUG) { System.err.println(""------""); System.err.println(""SemanticHeadFinder failed to reassign head for""); t.pennPrint(System.err); System.err.println(""------""); } } } } Tree hd = super.determineNonTrivialHead(t, parent); /* ---- // This should now be handled at the AbstractCollinsHeadFinder level, so see if we can comment this out // Heuristically repair punctuation heads Tree[] hdChildren = hd.children(); if (hdChildren != null && hdChildren.length > 0 && hdChildren[0].isLeaf()) { if (tlp.isPunctuationWord(hdChildren[0].label().value())) { Tree[] tChildren = t.children(); if (DEBUG) { System.err.printf(""head is punct: %s\n"", hdChildren[0].label()); } for (int i = tChildren.length - 1; i >= 0; i--) { if (!tlp.isPunctuationWord(tChildren[i].children()[0].label().value())) { hd = tChildren[i]; if (DEBUG) { System.err.printf(""New head of %s is %s%n"", hd.label(), hd.children()[0].label()); } break; } } } } */ if (DEBUG) { System.err.println(""Determined head (case 3) for "" + t.value() + "" is: "" + hd); } return hd; }"	"  protected Tree determineNonTrivialHead(Tree t, Tree parent) {
    String motherCat = tlp.basicCategory(t.label().value());

    if (DEBUG) {
      System.err.println(""At "" + motherCat + "", my parent is "" + parent);
    }

    if (motherCat.equals(""SBARQ"")) { 
      if (!makeCopulaHead) {
        for (TregexPattern pattern : headOfCopulaTregex) {
          TregexMatcher matcher = pattern.matcher(t);
          if (matcher.matchesAt(t)) {
            return matcher.getNode(""head"");
          }
        }
      }

      // if none of the above patterns match, use the standard method
    }

    // do VPs with auxiliary as special case
    if ((motherCat.equals(""VP"") || motherCat.equals(""SQ"") || motherCat.equals(""SINV""))) {
      Tree[] kids = t.children();
      // try to find if there is an auxiliary verb

      if (DEBUG) {
        System.err.println(""Semantic head finder: at VP"");
        System.err.println(""Class is "" + t.getClass().getName());
        t.pennPrint(System.err);
        //System.err.println(""hasVerbalAuxiliary = "" + hasVerbalAuxiliary(kids, verbalAuxiliaries));
      }

      // looks for auxiliaries
      if (hasVerbalAuxiliary(kids, verbalAuxiliaries, true) || hasPassiveProgressiveAuxiliary(kids)) {
        // String[] how = new String[] {""left"", ""VP"", ""ADJP"", ""NP""};
        // Including NP etc seems okay for copular sentences but is
        // problematic for other auxiliaries, like 'he has an answer'
        // But maybe doing ADJP is fine!
        String[] how = { ""left"", ""VP"", ""ADJP"" };
        Tree pti = traverseLocate(kids, how, false);
        if (DEBUG) {
          System.err.println(""Determined head (case 1) for "" + t.value() + "" is: "" + pti);
        }
        if (pti != null) {
          return pti;
        // } else {
          // System.err.println(""------"");
          // System.err.println(""SemanticHeadFinder failed to reassign head for"");
          // t.pennPrint(System.err);
          // System.err.println(""------"");
        }
      }

      // looks for copular verbs
      if (hasVerbalAuxiliary(kids, copulars, false) && ! isExistential(t, parent) && ! isWHQ(t, parent)) {
        String[] how;
        if (motherCat.equals(""SQ"")) {
          how = new String[]{""right"", ""VP"", ""ADJP"", ""NP"", ""WHADJP"", ""WHNP""};
        } else {
          how = new String[]{""left"", ""VP"", ""ADJP"", ""NP"", ""WHADJP"", ""WHNP""};
        }
        Tree pti = traverseLocate(kids, how, false);
        // don't allow a temporal to become head
        if (pti != null && pti.label() != null && pti.label().value().contains(""-TMP"")) {
          pti = null;
        }
        // In SQ, only allow an NP to become head if there is another one to the left (then it's probably predicative)
        if (motherCat.equals(""SQ"") && pti != null && pti.label() != null && pti.label().value().startsWith(""NP"")) {
            boolean foundAnotherNp = false;
            for (Tree kid : kids) {
              if (kid == pti) {
                break;
              } else if (kid.label() != null && kid.label().value().startsWith(""NP"")) {
                foundAnotherNp = true;
                break;
              }
            }
          if ( ! foundAnotherNp) {
            pti = null;
          }
        }

        if (DEBUG) {
          System.err.println(""Determined head (case 2) for "" + t.value() + "" is: "" + pti);
        }
        if (pti != null) {
          return pti;
        } else {
          if (DEBUG) {
            System.err.println(""------"");
            System.err.println(""SemanticHeadFinder failed to reassign head for"");
            t.pennPrint(System.err);
            System.err.println(""------"");
          }
        }
      }
    }

    Tree hd = super.determineNonTrivialHead(t, parent);

    /* ----
    // This should now be handled at the AbstractCollinsHeadFinder level, so see if we can comment this out
    // Heuristically repair punctuation heads
    Tree[] hdChildren = hd.children();
    if (hdChildren != null && hdChildren.length > 0 &&
        hdChildren[0].isLeaf()) {
      if (tlp.isPunctuationWord(hdChildren[0].label().value())) {
         Tree[] tChildren = t.children();
         if (DEBUG) {
           System.err.printf(""head is punct: %s\n"", hdChildren[0].label());
         }
         for (int i = tChildren.length - 1; i >= 0; i--) {
           if (!tlp.isPunctuationWord(tChildren[i].children()[0].label().value())) {
             hd = tChildren[i];
             if (DEBUG) {
               System.err.printf(""New head of %s is %s%n"", hd.label(), hd.children()[0].label());
             }
             break;
           }
         }
      }
    }
    */

    if (DEBUG) {
      System.err.println(""Determined head (case 3) for "" + t.value() + "" is: "" + hd);
    }
    return hd;
  }
"	@return The parse tree that is the head	@return The parse tree that is the head	0	1	16	117	1069
public boolean updateComponent(Widget component, UIDL uidl, boolean manageCaption) { if (!widgetFactory.isCorrectImplementation(component, uidl)) { Layout parent = getParentLayout(component); if (parent != null) { Widget w = widgetFactory.createWidget(uidl); registerPaintable(uidl.getId(), (Paintable) w); parent.replaceChildComponent(component, w); ((Paintable) w).updateFromUIDL(uidl, this); return true; } } if (manageCaption) { Layout parent = getParentLayout(component); if (parent != null) parent.updateCaption(component, uidl); } if (component instanceof FocusWidget) ((FocusWidget) component).setEnabled(!uidl.getBooleanAttribute(STR)); boolean visible = !uidl.getBooleanAttribute(STR); component.setVisible(visible); if (!visible) return true; return false; }	"public boolean updateComponent(Widget component, UIDL uidl, boolean manageCaption) {
    if (manageCaption) {
        Layout parent = getParentLayout(component);
        if (parent != null)
            parent.updateCaption(component, uidl);
    }
    boolean visible = !uidl.getBooleanAttribute(STR);
    component.setVisible(visible);
    if (!visible)
        return true;
    if (widgetFactory.isCorrectImplementation(component, uidl))
        return false;
    Layout parent = getParentLayout(component);
    if (parent == null)
        return false;
    Widget w = widgetFactory.createWidget(uidl);
    registerPaintable(uidl.getId(), (Paintable) w);
    parent.replaceChildComponent(component, w);
    ((Paintable) w).updateFromUIDL(uidl, this);
    return true;
}"	@return Returns true iff no further painting is needed by caller	@return Returns true	1	0	10	24	163
public static FlushMode interpretExternalSetting(String externalName) { return FlushModeTypeHelper.interpretExternalSetting( externalName ); }	"	public static FlushMode interpretExternalSetting(String externalName) {
		if ( externalName == null ) {
			return null;
		}

		try {
			return FlushMode.valueOf( externalName.toUpperCase(Locale.ROOT) );
		}
		catch ( IllegalArgumentException e ) {
			throw new MappingException( ""unknown FlushMode : "" + externalName );
		}
	}
"	@return The interpreted FlushMode value.	@return The interpreted FlushMode value.	0	1	5	4	17
public String[] createText(MilStd2525TacticalGraphic graphic) { String[] result; String functionId = graphic.getFunctionId(); if (CircularFireSupportArea.FUNCTION_ID_TARGET.equals(functionId)) { result = new String[] { graphic.getText() }; } else { boolean useSeparateTimeLabel = this.isShowSeparateTimeLabel(functionId); String mainText = this.createMainText(graphic, functionId, !useSeparateTimeLabel); if (useSeparateTimeLabel) { String timeText = this.createTimeRangeText(graphic); result = new String[] { mainText, timeText }; } else { result = new String[] { mainText }; } } return result; }	"public String createText(MilStd2525TacticalGraphic graphic) {
    String functionId = graphic.getFunctionId();
    if (CircularFireSupportArea.FUNCTION_ID_TARGET.equals(functionId))
        return graphic.getText();
    else
        return createDateRangeText(graphic, functionId);
}"	@return Array of text for labels. This array will always include at least one string: the main label text. It may include a second element. The second element (if present) is text for a label that must be placed at the left side of the area.	@return Label text.	1	0	11	17	110
public static Map mapOfSize(int size) { return new HashMap( determineProperSizing( size ), LOAD_FACTOR ); }	"	public static Map mapOfSize(int size) {
		final int currentSize = (int) (size / 0.75f);
		return new HashMap( Math.max( currentSize+ 1, 16), 0.75f );
	}
"	@return The sized map.	@return The sized map.	0	1	6	4	22
"public List<Lattice> addQuery(RelNode r) { // Push filters into joins and towards leaves final HepPlanner planner = new HepPlanner(PROGRAM, null, true, null, RelOptCostImpl.FACTORY); planner.setRoot(r); final RelNode r2 = planner.findBestExp(); final Query q = new Query(space); final Frame frame = frame(q, r2); if (frame == null) { return ImmutableList.of(); } final AttributedDirectedGraph<TableRef, StepRef> g = AttributedDirectedGraph.create(new StepRef.Factory()); final Multimap<Pair<TableRef, TableRef>, IntPair> map = LinkedListMultimap.create(); for (TableRef tableRef : frame.tableRefs) { g.addVertex(tableRef); } for (Hop hop : frame.hops) { map.put(Pair.of(hop.source.t, hop.target.t), IntPair.of(hop.source.c, hop.target.c)); } for (Map.Entry<Pair<TableRef, TableRef>, Collection<IntPair>> e : map.asMap().entrySet()) { final TableRef source = e.getKey().left; final TableRef target = e.getKey().right; final StepRef stepRef = q.stepRef(source, target, ImmutableList.copyOf(e.getValue())); g.addVertex(stepRef.source()); g.addVertex(stepRef.target()); g.addEdge(stepRef.source(), stepRef.target(), stepRef.step, stepRef.ordinalInQuery); } // If the join graph is cyclic, we can't use it. final Set<TableRef> cycles = new CycleDetector<>(g).findCycles(); if (!cycles.isEmpty()) { return ImmutableList.of(); } // Translate the query graph to mutable nodes final Map<TableRef, MutableNode> nodes = new IdentityHashMap<>(); final Map<List, MutableNode> nodesByParent = new HashMap<>(); final List<MutableNode> rootNodes = new ArrayList<>(); for (TableRef tableRef : TopologicalOrderIterator.of(g)) { final List<StepRef> edges = g.getInwardEdges(tableRef); final MutableNode node; switch (edges.size()) { case 0: node = new MutableNode(tableRef.table); rootNodes.add(node); break; case 1: final StepRef edge = edges.get(0); final MutableNode parent = nodes.get(edge.source()); final List key = ImmutableList.of(parent, tableRef.table, edge.step.keys); final MutableNode existingNode = nodesByParent.get(key); if (existingNode == null) { node = new MutableNode(tableRef.table, parent, edge.step); nodesByParent.put(key, node); } else { node = existingNode; } break; default: for (StepRef edge2 : edges) { final MutableNode parent2 = nodes.get(edge2.source()); final MutableNode node2 = new MutableNode(tableRef.table, parent2, edge2.step); parent2.children.add(node2); } node = null; break; } nodes.put(tableRef, node); } // Transcribe the hierarchy of mutable nodes to immutable nodes final List<Lattice> lattices = new ArrayList<>(); for (MutableNode rootNode : rootNodes) { if (rootNode.isCyclic()) { continue; } final CalciteSchema rootSchema = CalciteSchema.createRootSchema(false); final Lattice.Builder latticeBuilder = new Lattice.Builder(space, rootSchema, rootNode); final List<MutableNode> flatNodes = new ArrayList<>(); rootNode.flatten(flatNodes); for (MutableMeasure measure : frame.measures) { for (ColRef arg : measure.arguments) { if (arg == null) { // Cannot handle expressions, e.g. ""sum(x + 1)"" yet return ImmutableList.of(); } } latticeBuilder.addMeasure( new Lattice.Measure(measure.aggregate, measure.distinct, measure.name, Lists.transform(measure.arguments, colRef -> { final Lattice.Column column; if (colRef instanceof BaseColRef) { final BaseColRef baseColRef = (BaseColRef) colRef; final MutableNode node = nodes.get(baseColRef.t); final int table = flatNodes.indexOf(node); column = latticeBuilder.column(table, baseColRef.c); } else if (colRef instanceof DerivedColRef) { final DerivedColRef derivedColRef = (DerivedColRef) colRef; final String alias = deriveAlias(measure, derivedColRef); column = latticeBuilder.expression(derivedColRef.e, alias, derivedColRef.tableAliases()); } else { throw new AssertionError(""expression in measure""); } latticeBuilder.use(column, true); return column; }))); } for (int i = 0; i < frame.columnCount; i++) { final ColRef c = frame.column(i); if (c instanceof DerivedColRef) { final DerivedColRef derivedColRef = (DerivedColRef) c; final Lattice.Column expression = latticeBuilder.expression(derivedColRef.e, derivedColRef.alias, derivedColRef.tableAliases()); latticeBuilder.use(expression, false); } } final Lattice lattice0 = latticeBuilder.build(); final Lattice lattice1 = findMatch(lattice0, rootNode); lattices.add(lattice1); } return ImmutableList.copyOf(lattices); }"	"  public List<Lattice> addQuery(RelNode r) {
    // Push filters into joins and towards leaves
    final HepPlanner planner =
        new HepPlanner(PROGRAM, null, true, null, RelOptCostImpl.FACTORY);
    planner.setRoot(r);
    final RelNode r2 = planner.findBestExp();

    final Query q = new Query(space);
    final Frame frame = frame(q, r2);
    if (frame == null) {
      return ImmutableList.of();
    }
    final AttributedDirectedGraph<TableRef, StepRef> g =
        AttributedDirectedGraph.create(new StepRef.Factory());
    final Multimap<Pair<TableRef, TableRef>, IntPair> map =
        LinkedListMultimap.create();
    for (TableRef tableRef : frame.tableRefs) {
      g.addVertex(tableRef);
    }
    for (Hop hop : frame.hops) {
      map.put(Pair.of(hop.source.t, hop.target.t),
          IntPair.of(hop.source.c, hop.target.c));
    }
    for (Map.Entry<Pair<TableRef, TableRef>, Collection<IntPair>> e
        : map.asMap().entrySet()) {
      final TableRef source = e.getKey().left;
      final TableRef target = e.getKey().right;
      final StepRef stepRef =
          q.stepRef(source, target, ImmutableList.copyOf(e.getValue()));
      g.addVertex(stepRef.source());
      g.addVertex(stepRef.target());
      g.addEdge(stepRef.source(), stepRef.target(), stepRef.step,
          stepRef.ordinalInQuery);
    }

    // If the join graph is cyclic, we can't use it.
    final Set<TableRef> cycles = new CycleDetector<>(g).findCycles();
    if (!cycles.isEmpty()) {
      return ImmutableList.of();
    }

    // Translate the query graph to mutable nodes
    final Map<TableRef, MutableNode> nodes = new IdentityHashMap<>();
    final Map<List, MutableNode> nodesByParent = new HashMap<>();
    final List<MutableNode> rootNodes = new ArrayList<>();
    for (TableRef tableRef : TopologicalOrderIterator.of(g)) {
      final List<StepRef> edges = g.getInwardEdges(tableRef);
      final MutableNode node;
      switch (edges.size()) {
      case 0:
        node = new MutableNode(tableRef.table);
        rootNodes.add(node);
        break;
      case 1:
        final StepRef edge = edges.get(0);
        final MutableNode parent = nodes.get(edge.source());
        final List key =
            ImmutableList.of(parent, tableRef.table, edge.step.keys);
        final MutableNode existingNode = nodesByParent.get(key);
        if (existingNode == null) {
          node = new MutableNode(tableRef.table, parent, edge.step);
          nodesByParent.put(key, node);
        } else {
          node = existingNode;
        }
        break;
      default:
        for (StepRef edge2 : edges) {
          final MutableNode parent2 = nodes.get(edge2.source());
          final MutableNode node2 =
              new MutableNode(tableRef.table, parent2, edge2.step);
          parent2.children.add(node2);
        }
        node = null;
        break;
      }
      nodes.put(tableRef, node);
    }

    // Transcribe the hierarchy of mutable nodes to immutable nodes
    final List<Lattice> lattices = new ArrayList<>();
    for (MutableNode rootNode : rootNodes) {
      if (rootNode.isCyclic()) {
        continue;
      }
      final CalciteSchema rootSchema = CalciteSchema.createRootSchema(false);
      final Lattice.Builder latticeBuilder =
          new Lattice.Builder(space, rootSchema, rootNode);

      final List<MutableNode> flatNodes = new ArrayList<>();
      rootNode.flatten(flatNodes);

      for (MutableMeasure measure : frame.measures) {
        for (ColRef arg : measure.arguments) {
          if (arg == null) {
            // Cannot handle expressions, e.g. ""sum(x + 1)"" yet
            return ImmutableList.of();
          }
        }
        latticeBuilder.addMeasure(
            new Lattice.Measure(measure.aggregate, measure.distinct,
                measure.name,
                Lists.transform(measure.arguments, colRef -> {
                  if (colRef instanceof BaseColRef) {
                    final BaseColRef baseColRef = (BaseColRef) colRef;
                    final MutableNode node = nodes.get(baseColRef.t);
                    final int table = flatNodes.indexOf(node);
                    return latticeBuilder.column(table, baseColRef.c);
                  } else if (colRef instanceof DerivedColRef) {
                    final DerivedColRef derivedColRef =
                        (DerivedColRef) colRef;
                    final String alias = deriveAlias(measure, derivedColRef);
                    return latticeBuilder.expression(derivedColRef.e, alias,
                        derivedColRef.tableAliases());
                  } else {
                    throw new AssertionError(""expression in measure"");
                  }
                })));
      }

      for (int i = 0; i < frame.columnCount; i++) {
        final ColRef c = frame.column(i);
        if (c instanceof DerivedColRef) {
          final DerivedColRef derivedColRef = (DerivedColRef) c;
          final Lattice.Column expression =
              latticeBuilder.expression(derivedColRef.e,
                  derivedColRef.alias, derivedColRef.tableAliases());
        }
      }

      final Lattice lattice0 = latticeBuilder.build();
      final Lattice lattice1 = findMatch(lattice0, rootNode);
      lattices.add(lattice1);
    }
    return ImmutableList.copyOf(lattices);
  }
"	@return A list of join graphs: usually 1; more if the query contains a cartesian product; zero if the query graph is cyclic	@return A list of join graphs: usually 1; more if the query contains a cartesian product; zero if the query graph is cyclic	0	1	18	141	923
public int size() { return data.length(); }	"    public int size() {
        return data.size();
    }
"	@return the value of the count field, which is the number of valid bytes in this output stream.	@return the value of the count field, which is the number of valid bytes in this output stream.	0	1	4	4	13
public boolean isEmpty() { return STR.equals(token) && STR.equals(tokenSecret); }	"public boolean isEmpty() {
    return STR.equals(this.getToken()) && STR.equals(this.secret);
}"	"@return true if the token is empty (oauth_token = """", oauth_token_secret = """")"	"@return true if the token is empty (token = """", secret = """")"	1	0	6	3	21
protected Session currentSession() { return sessionFactory.getCurrentSession(); }	"    protected Session currentSession() {
        return provider.getCurrentSession();
    }
"	@return the current session	@return the current session	0	1	4	4	13
public static StringTemplate stringTemplate(Template template, ImmutableList<?> args) { return new StringTemplate(template, args); }	"    public static StringTemplate stringTemplate(Template template, ImmutableList<?> args) {
        return new StringTemplate(template, ImmutableList.copyOf(args));
    }
"	@return template expression	@return template expression	0	1	5	4	23
protected long expireTimeMS(Supplier<Duration> expires) { try { Duration duration = expires.get(); if (duration == null) { return -NUM; } return duration.isZero() ? NUM : duration.getAdjustedTime(currentTimeMillis()); } catch (Exception e) { logger.log(Level.WARNING, STR, e); return -NUM; } }	"protected long expireTimeMS(Supplier<Duration> expires) {
    try {
        Duration duration = expires.get();
        return duration.isZero() ? NUM : duration.getAdjustedTime(currentTimeMillis());
    } catch (Exception e) {
        logger.log(Level.WARNING, STR, e);
        return Long.MAX_VALUE;
    }
}"	@return the time when the entry will expire, or negative if the time should not be changed	@return the time when the entry will expire	1	0	7	12	69
"public static List<Point> convexHull(List<Point> points) { if (points.size() < 3) { return null; } List<Point> ch = new ArrayList<>(); // find the left most point Point left = findLeftMost(points); // current point we are on Point current = left; do { ch.add(current); assert ch.size() <= points.size() : ""hull has more points than graph""; if (ch.size() > points.size()) { // Just to make sure we never somehow get stuck in this loop return null; } // the next point - all points are to the right of the // line between current and next Point next = null; for (Point p : points) { if (next == null) { next = p; continue; } long cp = crossProduct(current, p, next); if (cp > 0 || (cp == 0 && current.distanceTo(p) > current.distanceTo(next))) { next = p; } } // Points can be null if they are behind or very close to the camera. if (next == null) { return null; } current = next; } while (current != left); return ch; }"	"	public static List<Point> convexHull(List<Point> points)
	{
		if (points.size() < 3)
		{
			return null;
		}

		List<Point> ch = new ArrayList<>();

		// find the left most point
		Point left = findLeftMost(points);

		// current point we are on
		Point current = left;

		do
		{
			ch.add(current);

			// the next point - all points are to the right of the
			// line between current and next
			Point next = null;

			for (Point p : points)
			{
				if (next == null)
				{
					next = p;
					continue;
				}

				int cp = crossProduct(current, p, next);
				if (cp > 0 || (cp == 0 && current.distanceTo(p) > current.distanceTo(next)))
				{
					next = p;
				}
			}

			// Points can be null if they are behind or very close to the camera.
			if (next == null)
			{
				return null;
			}

			assert ch.size() <= points.size() : ""hull has more points than graph"";
			current = next;
		}
		while (current != left);

		return ch;
	}
"	@return list containing the points part of the convex hull	@return list containing the points part of the convex hull	0	1	12	57	240
public static Iterable<Runnable> thread(final String title, Iterable<Runnable> runnables){ //--Preparation //(variables) final AtomicBoolean haveStarted = new AtomicBoolean(false); final ReentrantLock metaInfoLock = new ReentrantLock(); final AtomicInteger numPending = new AtomicInteger(0); final Iterator<Runnable> iter = runnables.iterator(); //--Create Runnables return new IterableIterator<>(new Iterator<Runnable>() { @Override public boolean hasNext() { synchronized (iter) { return iter.hasNext(); } } @Override public synchronized Runnable next() { final Runnable runnable; synchronized (iter) { runnable = iter.next(); } // (don't flood the queu) while (numPending.get() > 100) { try { Thread.sleep(100); } catch (InterruptedException e) { } } numPending.incrementAndGet(); // (add the job) Runnable toReturn = new Runnable() { public void run() { boolean threadFinished = false; try { //(signal start of threads) metaInfoLock.lock(); if (!haveStarted.getAndSet(true)) { startThreads(title); //<--this must be a blocking operation } metaInfoLock.unlock(); //(run runnable) try { runnable.run(); } catch (Exception | AssertionError e) { e.printStackTrace(); System.exit(1); } //(signal end of thread) finishThread(); threadFinished = true; //(signal end of threads) int numStillPending = numPending.decrementAndGet(); synchronized (iter) { if (numStillPending <= 0 && !iter.hasNext()) { endThreads(title); } } } catch (Throwable t) { t.printStackTrace(); if (!threadFinished) { finishThread(); } } } }; return toReturn; } @Override public void remove() { synchronized (iter) { iter.remove(); } } }); }	"    public static ArrayList<Runnable> thread(final String title, Iterable<Runnable> runnables){
      //--Preparation
      //(variables)
      final AtomicBoolean haveStarted = new AtomicBoolean(false);
      final ReentrantLock metaInfoLock = new ReentrantLock();
      int count = 0;
      //(count runnables)
      Iterator<Runnable> iterableRunnables = runnables.iterator();
      while (iterableRunnables.hasNext()) {
        count++;
        iterableRunnables.next();
      }
      final int numToRun = count;
      //--Create Runnables
      ArrayList<Runnable> rtn = new ArrayList<Runnable>(numToRun);
      final AtomicInteger runnablesSeen = new AtomicInteger(0);
      for(final Runnable runnable : runnables){
        rtn.add(new Runnable(){
          public void run(){
            try{
              //(signal start of threads)
              metaInfoLock.lock();
              if(!haveStarted.getAndSet(true)){
                startThreads(title); //<--this must be a blocking operation
              }
              metaInfoLock.unlock();
              //(run runnable)
              try{
                runnable.run();
              } catch (Exception e){
                e.printStackTrace();
                System.exit(1);
              } catch (AssertionError e) {
                e.printStackTrace();
                System.exit(1);
              }
              //(signal end of thread)
              finishThread();
              //(signal end of threads)
              int seen = runnablesSeen.getAndIncrement() + 1;
              if(seen == numToRun){
                endThreads(title);
              }
            } catch(Throwable t){
              t.printStackTrace();
              System.exit(1);
            }
          }
        });
      }
      //--Return
      return rtn;
    }
"	@return A new collection of Runnables with the Redwood overhead taken care of	@return A new collection of Runnables with the Redwood overhead taken care of	0	1	17	78	377
public Button getButton(int index) { return getter.getView(Button.class, index); }	"	public Button getButton(int index) {
		Button button = getter.getView(Button.class, index);
		return button;
	}
"	@return the  Button with a specified index or  null if index is invalid	@return the Button with a specified index or null if index is invalid	0	1	6	4	19
public boolean searchForEditText(String regex, boolean scroll) { return searchFor(EditText.class, regex, 1, scroll); }	"	public boolean searchForEditText(String regex, boolean scroll) {
		inst.waitForIdleSync();
		Pattern p = Pattern.compile(regex);
		Matcher matcher;
		ArrayList<EditText> editTextList = viewFetcher.getCurrentViews(EditText.class);
		for(EditText editText : editTextList){
			matcher = p.matcher(editText.getText().toString());
			if (matcher.find()) {
				return true;
			}
		}

		if (scroll && scroller.scroll(Scroller.Direction.DOWN))
			return searchForEditText(regex, scroll);
		else
			return false;
	}
"	@return true if an edit text with the given text is found or false if it is not found	@return true if an edit text with the given text is found or false if it is not found	0	1	6	4	25
public Optional<GraphQLError> add(Definition definition) { // extensions if (definition instanceof ObjectTypeExtensionDefinition) { ObjectTypeExtensionDefinition newEntry = (ObjectTypeExtensionDefinition) definition; return defineExt(typeExtensions, newEntry, ObjectTypeExtensionDefinition::getName); } else if (definition instanceof InterfaceTypeExtensionDefinition) { InterfaceTypeExtensionDefinition newEntry = (InterfaceTypeExtensionDefinition) definition; return defineExt(interfaceTypeExtensions, newEntry, InterfaceTypeExtensionDefinition::getName); } else if (definition instanceof UnionTypeExtensionDefinition) { UnionTypeExtensionDefinition newEntry = (UnionTypeExtensionDefinition) definition; return defineExt(unionTypeExtensions, newEntry, UnionTypeExtensionDefinition::getName); } else if (definition instanceof EnumTypeExtensionDefinition) { EnumTypeExtensionDefinition newEntry = (EnumTypeExtensionDefinition) definition; return defineExt(enumTypeExtensions, newEntry, EnumTypeExtensionDefinition::getName); } else if (definition instanceof ScalarTypeExtensionDefinition) { ScalarTypeExtensionDefinition newEntry = (ScalarTypeExtensionDefinition) definition; return defineExt(scalarTypeExtensions, newEntry, ScalarTypeExtensionDefinition::getName); } else if (definition instanceof InputObjectTypeExtensionDefinition) { InputObjectTypeExtensionDefinition newEntry = (InputObjectTypeExtensionDefinition) definition; return defineExt(inputObjectTypeExtensions, newEntry, InputObjectTypeExtensionDefinition::getName); // // normal } else if (definition instanceof ScalarTypeDefinition) { ScalarTypeDefinition newEntry = (ScalarTypeDefinition) definition; return define(scalarTypes, scalarTypes, newEntry); } else if (definition instanceof TypeDefinition) { TypeDefinition newEntry = (TypeDefinition) definition; return define(types, types, newEntry); } else if (definition instanceof SchemaDefinition) { SchemaDefinition newSchema = (SchemaDefinition) definition; if (schema != null) { return Optional.of(new SchemaRedefinitionError(this.schema, newSchema)); } else { schema = newSchema; } } return Optional.empty(); }	"    public Optional<GraphQLError> add(Definition definition) {
        if (definition instanceof ObjectTypeExtensionDefinition) {
            ObjectTypeExtensionDefinition newEntry = (ObjectTypeExtensionDefinition) definition;
            return defineExt(typeExtensions, newEntry);
        } else if (definition instanceof ScalarTypeDefinition) {
            ScalarTypeDefinition newEntry = (ScalarTypeDefinition) definition;
            return define(scalarTypes, scalarTypes, newEntry);
        } else if (definition instanceof TypeDefinition) {
            TypeDefinition newEntry = (TypeDefinition) definition;
            return define(types, types, newEntry);
        } else if (definition instanceof SchemaDefinition) {
            SchemaDefinition newSchema = (SchemaDefinition) definition;
            if (schema != null) {
                return Optional.of(new SchemaRedefinitionError(this.schema, newSchema));
            } else {
                schema = newSchema;
            }
        }
        return Optional.empty();
    }
"	@return an optional error	@return an optional error	0	1	19	39	293
public static Set getAllInterfaces(List objects) { Set interfaces = new HashSet(); for (Iterator iterator = objects.iterator(); iterator.hasNext(); ) { Object o = iterator.next(); Class clazz = o.getClass(); getInterfaces(clazz, interfaces); } return interfaces; }	"public static Class[] getAllInterfaces(List objects) {
    Set interfaces = new HashSet();
    for (Iterator iterator = objects.iterator(); iterator.hasNext(); ) {
        Object o = iterator.next();
        Class clazz = o.getClass();
        getInterfaces(clazz, interfaces);
    }
    return (Class[]) interfaces.toArray(new Class[interfaces.size()]);
}"	@return a {@link Set} of interfaces.	@return an array of interfaces.	1	0	7	9	58
public PendingMessageCursor getSubscriberPendingMessageCursor(Broker broker,String clientId, String name, int maxBatchSize, Subscription sub) { return new StoreDurableSubscriberCursor(broker,clientId, name, maxBatchSize, sub); }	"    public PendingMessageCursor getSubscriberPendingMessageCursor(String clientId, String name, Store tmpStorage, int maxBatchSize, Subscription sub) {
        return new StoreDurableSubscriberCursor(clientId, name, tmpStorage, maxBatchSize, sub);
    }
"	@return the Pending Message cursor	@return the Pending Message cursor	0	1	5	4	36
public static <K, V> FluentMap<K, V> newMap(final Class<K> keyType, final Class<V> valueType) { return newMap(null, keyType, valueType); }	"public static <K, V> FluentMap<K, V> newMap(Class<K> keyType, Class<V> valueType) {
    return newMap(null);
}"	@return the map	@return the map The value type	1	0	6	3	33
public IBuildConfiguration[] getBuildOrder() { if (buildOrder != null) return buildOrder; String[] order = description.getBuildOrder(false); if (order != null) { LinkedHashSet configs = new LinkedHashSet(); for (int i = NUM; i < order.length; i++) { IProject project = getRoot().getProject(order[i]); if (project.isAccessible()) configs.add(((Project) project).internalGetActiveBuildConfig()); } configs.addAll(Arrays.asList(vertexOrderToProjectBuildConfigOrder(computeActiveBuildConfigurationOrder()).buildConfigurations)); IBuildConfiguration[] bo = new IBuildConfiguration[configs.size()]; configs.toArray(bo); this.buildOrder = bo; } else buildOrder = vertexOrderToProjectBuildConfigOrder(computeActiveBuildConfigurationOrder()).buildConfigurations; return buildOrder; }	"public IProject[] getBuildOrder() {
    if (buildOrder != null) {
        return buildOrder;
    }
    String[] order = description.getBuildOrder(false);
    if (order != null) {
        List projectList = new ArrayList(order.length);
        for (int i = NUM; i < order.length; i++) {
            IProject project = getRoot().getProject(order[i]);
            if (project.isAccessible()) {
                projectList.add(project);
            }
        }
        buildOrder = new IProject[projectList.size()];
        projectList.toArray(buildOrder);
    } else {
        buildOrder = computeFullProjectOrder().projects;
    }
    return buildOrder;
}"	@return the list of currently open projects active buildConfigs (and the project buildConfigs they depend on) in the workspace in the order in which they would be built by <code>IWorkspace.build</code>.	@return the list of currently open projects in the workspace in the order in which they would be built by <code>IWorkspace.build</code>.	1	0	13	19	145
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 38: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, yytext()); } case 55: break; case 43: // general lookahead, find correct zzMarkedPos { int zzFState = 9; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 10; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { // try to work around an apparent jflex bug where it // gets a space at the token end by getting // wrong the length of the trailing context. while (yylength() > 0) { char last = yycharat(yylength()-1); if (last == ' ' || last == '\t' || (last >= '\n' && last <= '\r' || last == '\u0085')) { yypushback(1); } else { break; } } return getNext(); } case 56: break; case 11: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 57: break; case 19: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 58: break; case 8: { return handleQuotes(yytext(), false); } case 59: break; case 35: // lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), false); } case 60: break; case 27: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 61: break; case 33: // lookahead expression with fixed lookahead length yypushback(1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 62: break; case 49: // lookahead expression with fixed lookahead length yypushback(1); { return getNormalizedAmpNext(); } case 63: break; case 36: { return getNormalizedAmpNext(); } case 64: break; case 23: { if (invertible) { prevWordAfter.append(yytext()); } } case 65: break; case 37: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, yytext()); } case 66: break; case 53: // lookahead expression with fixed lookahead length yypushback(4); { return getNext(); } case 67: break; case 46: // lookahead expression with fixed lookahead length yypushback(2); { return getNext(); } case 68: break; case 42: // general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 69: break; case 41: // general lookahead, find correct zzMarkedPos { int zzFState = 16; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 17; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 70: break; case 40: // general lookahead, find correct zzMarkedPos { int zzFState = 13; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 71: break; case 3: { return getNext(); } case 72: break; case 24: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(); } case 73: break; case 51: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } return getNext(txt, yytext()); } case 74: break; case 26: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, origTxt); } case 75: break; case 6: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 76: break; case 29: // general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 77: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 78: break; case 2: { return getNext(""<"", yytext()); } case 79: break; case 30: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 80: break; case 18: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 81: break; case 54: { String txt = yytext(); if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 82: break; case 50: { yypushback(3) ; return getNext(); } case 83: break; case 25: // lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), true); } case 84: break; case 39: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 85: break; case 21: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 86: break; case 17: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 87: break; case 13: { return handleEllipsis(yytext()); } case 88: break; case 34: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 1; { /* invert quote - often but not always right */ return handleQuotes(yytext(), true); } case 89: break; case 14: { return normalizeFractions(yytext()); } case 90: break; case 15: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(); } } case 91: break; case 47: // general lookahead, find correct zzMarkedPos { int zzFState = 11; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 12; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 92: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 93: break; case 9: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 94: break; case 45: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 95: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 96: break; case 28: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 97: break; case 48: { if (keepAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 98: break; case 20: { if (normalizeOtherBrackets) { return getNext(""-RSB-"", yytext()); } else { return getNext(); } } case 99: break; case 12: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 100: break; case 31: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 101: break; case 10: { return getNext("">"", yytext()); } case 102: break; case 32: { // this one should only match if we're basically at the end of file // since the last one matches two things, even newlines String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 103: break; case 22: { if (normalizeOtherBrackets) { return getNext(""-LSB-"", yytext()); } else { return getNext(); } } case 104: break; case 52: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { // try to work around an apparent jflex bug where it // gets a space at the token end by getting // wrong the length of the trailing context. while (yylength() > 0) { char last = yycharat(yylength()-1); if (last == ' ' || last == '\t' || (last >= '\n' && last <= '\r' || last == '\u0085')) { yypushback(1); } else { break; } } String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 105: break; case 1: { String str = yytext(); int first = str.charAt(0); String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } LOGGER.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: LOGGER.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 106: break; case 44: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 107: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 108: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }"	"  public Object next() throws java.io.IOException {
    int zzInput;
    int zzAction;

    // cached fields:
    int zzCurrentPosL;
    int zzMarkedPosL;
    int zzEndReadL = zzEndRead;
    char [] zzBufferL = zzBuffer;
    char [] zzCMapL = ZZ_CMAP;

    int [] zzTransL = ZZ_TRANS;
    int [] zzRowMapL = ZZ_ROWMAP;
    int [] zzAttrL = ZZ_ATTRIBUTE;

    while (true) {
      zzMarkedPosL = zzMarkedPos;

      yychar+= zzMarkedPosL-zzStartRead;

      zzAction = -1;

      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
  
      zzState = ZZ_LEXSTATE[zzLexicalState];


      zzForAction: {
        while (true) {
    
          if (zzCurrentPosL < zzEndReadL)
            zzInput = zzBufferL[zzCurrentPosL++];
          else if (zzAtEOF) {
            zzInput = YYEOF;
            break zzForAction;
          }
          else {
            // store back cached positions
            zzCurrentPos  = zzCurrentPosL;
            zzMarkedPos   = zzMarkedPosL;
            boolean eof = zzRefill();
            // get translated positions and possibly new buffer
            zzCurrentPosL  = zzCurrentPos;
            zzMarkedPosL   = zzMarkedPos;
            zzBufferL      = zzBuffer;
            zzEndReadL     = zzEndRead;
            if (eof) {
              zzInput = YYEOF;
              break zzForAction;
            }
            else {
              zzInput = zzBufferL[zzCurrentPosL++];
            }
          }
          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
          if (zzNext == -1) break zzForAction;
          zzState = zzNext;

          int zzAttributes = zzAttrL[zzState];
          if ( (zzAttributes & 1) == 1 ) {
            zzAction = zzState;
            zzMarkedPosL = zzCurrentPosL;
            if ( (zzAttributes & 8) == 8 ) break zzForAction;
          }

        }
      }

      // store back cached position
      zzMarkedPos = zzMarkedPosL;

      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
        case 38: 
          { String txt = yytext();
                  if (escapeForwardSlashAsterisk) {
                    txt = delimit(txt, '/');
                  }
                  if (normalizeSpace) {
                    // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                    txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space

                  }
                  return getNext(txt, yytext());
          }
        case 55: break;
        case 43: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 9;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 10;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { // try to work around an apparent jflex bug where it
                          // gets a space at the token end by getting
                          // wrong the length of the trailing context.
                          while (yylength() > 0) {
                            char last = yycharat(yylength()-1);
                            if (last == ' ' || last == '\t' || (last >= '\n' && last <= '\r' || last == '\u0085')) {
                              yypushback(1);
                            } else {
                              break;
                            }
                          }
			  return getNext();
          }
        case 56: break;
        case 11: 
          { if (ptb3Dashes) {
                            return getNext(ptbmdash, yytext()); }
                          else {
                            return getNext();
                          }
          }
        case 57: break;
        case 19: 
          { if (escapeForwardSlashAsterisk) {
                    return getNext(delimit(yytext(), '*'), yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 58: break;
        case 8: 
          { return handleQuotes(yytext(), false);
          }
        case 59: break;
        case 35: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return handleQuotes(yytext(), false);
          }
        case 60: break;
        case 27: 
          { String txt = yytext();
                  String origText = txt;
                  if (normalizeParentheses) {
                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                  }
                  return getNext(txt, origText);
          }
        case 61: break;
        case 33: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { String txt = yytext();
                  String origText = txt;
                  if (normalizeParentheses) {
                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                  }
                  return getNext(txt, origText);
          }
        case 62: break;
        case 48: 
          { if (splitAssimilations) {
                            yypushback(2) ; return getNext();
                          } else {
                            return getNext();
                          }
          }
        case 63: break;
        case 49: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return getNormalizedAmpNext();
          }
        case 64: break;
        case 36: 
          { return getNormalizedAmpNext();
          }
        case 65: break;
        case 23: 
          { if (invertible) {
                            prevWordAfter.append(yytext());
                        }
          }
        case 66: break;
        case 37: 
          { String txt = yytext();
                  if (escapeForwardSlashAsterisk) {
                    txt = delimit(txt, '/');
                  }
                  if (normalizeSpace) {
                    // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                    txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                  }
                  return getNext(txt, yytext());
          }
        case 67: break;
        case 53: 
          // lookahead expression with fixed lookahead length
          yypushback(4);
          { return getNext();
          }
        case 68: break;
        case 46: 
          // lookahead expression with fixed lookahead length
          yypushback(2);
          { return getNext();
          }
        case 69: break;
        case 42: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 15;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 14;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { return getNext();
          }
        case 70: break;
        case 41: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 16;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 17;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { return getNext();
          }
        case 71: break;
        case 40: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 13;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 14;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { return getNext();
          }
        case 72: break;
        case 3: 
          { return getNext();
          }
        case 73: break;
        case 24: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return getNext();
          }
        case 74: break;
        case 51: 
          { String txt = yytext();
                          if (escapeForwardSlashAsterisk) {
                            txt = delimit(txt, '/');
                          }
                          return getNext(txt, yytext());
          }
        case 75: break;
        case 26: 
          { final String origTxt = yytext();
                          String txt = origTxt;
                          if (normalizeSpace) {
                            // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                            txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                          }
                          return getNext(txt, origTxt);
          }
        case 76: break;
        case 6: 
          { final String origTxt = yytext();
                          String tmp = removeSoftHyphens(origTxt);
                          if (americanize) {
                            tmp = Americanize.americanize(tmp);
                          }
                          return getNext(tmp, origTxt);
          }
        case 77: break;
        case 29: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 3;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 4;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { final String origTxt = yytext();
                          String tmp = removeSoftHyphens(origTxt);
                          if (americanize) {
                            tmp = Americanize.americanize(tmp);
                          }
                          return getNext(tmp, origTxt);
          }
        case 78: break;
        case 16: 
          { if (normalizeOtherBrackets) {
                    return getNext(closebrace, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 79: break;
        case 2: 
          { return getNext(""<"", yytext());
          }
        case 80: break;
        case 30: 
          { if (escapeForwardSlashAsterisk) {
                            return getNext(delimit(yytext(), '/'), yytext());
                          } else {
                            return getNext();
                          }
          }
        case 81: break;
        case 18: 
          { if (normalizeParentheses) {
                    return getNext(closeparen, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 82: break;
        case 54: 
          { String txt = yytext();
                          if (normalizeSpace) {
                            // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                            txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                          }
                          if (normalizeParentheses) {
                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                          }
                          return getNext(txt, yytext());
          }
        case 83: break;
        case 25: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return handleQuotes(yytext(), true);
          }
        case 84: break;
        case 39: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 5;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 6;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { final String txt = yytext();
                          return getNext(removeSoftHyphens(txt),
                                         txt);
          }
        case 85: break;
        case 21: 
          { if (normalizeOtherBrackets) {
                    return getNext(openbrace, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 86: break;
        case 50: 
          { if (splitAssimilations) {
                            yypushback(3) ; return getNext();
                          } else {
                            return getNext();
                          }
          }
        case 87: break;
        case 17: 
          { if (normalizeParentheses) {
                    return getNext(openparen, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 88: break;
        case 13: 
          { return handleEllipsis(yytext());
          }
        case 89: break;
        case 34: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 1;
          { /* invert quote - often but not always right */
                  return handleQuotes(yytext(), true);
          }
        case 90: break;
        case 14: 
          { return normalizeFractions(yytext());
          }
        case 91: break;
        case 15: 
          { if (normalizeCurrency) {
                            return getNext(normalizeCurrency(yytext()), yytext()); }
                          else {
                            return getNext();
                          }
          }
        case 92: break;
        case 47: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 11;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 12;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { String s;
                          if (strictTreebank3 && ! ""U.S."".equals(yytext())) {
                            yypushback(1); // return a period for next time
                            s = yytext();
                          } else {
                            s = yytext();
                            yypushback(1); // return a period for next time
                          }
                          return getNext(s, yytext());
          }
        case 93: break;
        case 7: 
          { if (invertible) {
                     prevWordAfter.append(yytext());
                  }
          }
        case 94: break;
        case 9: 
          { if (escapeForwardSlashAsterisk) {
                    return getNext(delimit(yytext(), '/'), yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 95: break;
        case 45: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return getNext(removeSoftHyphens(yytext()),
                                               yytext());
          }
        case 96: break;
        case 4: 
          { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {
                    return getNext(ptbmdash, yytext());
                  } else {
                    return getNext();
                  }
          }
        case 97: break;
        case 28: 
          { return getNext(removeSoftHyphens(yytext()), yytext());
          }
        case 98: break;
        case 20: 
          { if (normalizeOtherBrackets) {
                    return getNext(""-RSB-"", yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 99: break;
        case 12: 
          { return getNext(removeSoftHyphens(yytext()),
                                         yytext());
          }
        case 100: break;
        case 31: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return getNext(removeSoftHyphens(yytext()),
                                         yytext());
          }
        case 101: break;
        case 10: 
          { return getNext("">"", yytext());
          }
        case 102: break;
        case 32: 
          { // this one should only match if we're basically at the end of file
                          // since the last one matches two things, even newlines
                          String s;
                          if (strictTreebank3 && ! ""U.S."".equals(yytext())) {
                            yypushback(1); // return a period for next time
                            s = yytext();
                          } else {
                            s = yytext();
                            yypushback(1); // return a period for next time
                          }
                          return getNext(s, yytext());
          }
        case 103: break;
        case 22: 
          { if (normalizeOtherBrackets) {
                    return getNext(""-LSB-"", yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 104: break;
        case 52: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 7;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 8;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { // try to work around an apparent jflex bug where it
                          // gets a space at the token end by getting
                          // wrong the length of the trailing context.
                          while (yylength() > 0) {
                            char last = yycharat(yylength()-1);
                            if (last == ' ' || last == '\t' || (last >= '\n' && last <= '\r' || last == '\u0085')) {
                              yypushback(1);
                            } else {
                              break;
                            }
                          }
                          String s;
                          if (strictTreebank3 && ! ""U.S."".equals(yytext())) {
                            yypushback(1); // return a period for next time
                            s = yytext();
                          } else {
                            s = yytext();
                            yypushback(1); // return a period for next time
                          }
                          return getNext(s, yytext());
          }
        case 105: break;
        case 1: 
          { String str = yytext();
          int first = str.charAt(0);
          String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));
          switch (untokenizable) {
            case NONE_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              break;
            case FIRST_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              if ( ! this.seenUntokenizableCharacter) {
                LOGGER.warning(msg);
                this.seenUntokenizableCharacter = true;
              }
              break;
            case ALL_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              LOGGER.warning(msg);
              this.seenUntokenizableCharacter = true;
              break;
            case NONE_KEEP:
              return getNext();
            case FIRST_KEEP:
              if ( ! this.seenUntokenizableCharacter) {
                LOGGER.warning(msg);
                this.seenUntokenizableCharacter = true;
              }
              return getNext();
            case ALL_KEEP:
              LOGGER.warning(msg);
              this.seenUntokenizableCharacter = true;
              return getNext();
          }
          }
        case 106: break;
        case 44: 
          { String txt = yytext();
                          if (escapeForwardSlashAsterisk) {
                            txt = delimit(txt, '/');
                            txt = delimit(txt, '*');
                          }
                          return getNext(txt, yytext());
          }
        case 107: break;
        case 5: 
          { if (tokenizeNLs) {
                      return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns
                  } else if (invertible) {
                      prevWordAfter.append(yytext());
                  }
          }
        case 108: break;
        default: 
          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
            zzAtEOF = true;
              {
                if (invertible) {
            prevWordAfter.append(yytext());
            String str = prevWordAfter.toString();
            prevWordAfter.setLength(0);
            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);
          }
          return null;
              }
          } 
          else {
            zzScanError(ZZ_NO_MATCH);
          }
      }
    }
  }
"	@return the next token	@return the next token	0	1	17	702	4305
private char[] encodePattern(List<Cell> pattern) { return mEncrypter != null ? mEncrypter.encrypt(this, pattern) : LockPatternUtils.patternToSha1(pattern).toCharArray(); }	"private char[] encodePattern(List<Cell> pattern) {
    if (mEncrypter == null) {
        return LockPatternUtils.patternToSha1(pattern).toCharArray();
    } else {
        try {
            return mEncrypter.encrypt(this, LockPatternUtils.patternToSha1(pattern).toCharArray());
        } catch (Throwable t) {
            throw new InvalidEncrypterException();
        }
    }
}"	@return the encoded chars of {@code pattern}.	@return SHA-1 of {@code pattern}, or encrypted string of its.	1	0	6	3	34
public boolean validatePassword(String passString) { if (passString.length() >= 8) { return true; } else { Snackbar snackbar = Snackbar .make(findViewById(android.R.id.content), R.string.password_length, Snackbar.LENGTH_LONG); snackbar.show(); return false; } }	"    public boolean validatePassword(String passString) {
        if (passString.length() >= 8) {
            Pattern pattern;
            Matcher matcher;
            final String PASSWORD_PATTERN = ""^(?=.*[0-9])(?=.*[A-Z])(?=.*[_@#$%^?&+=!])(?=\\S+$).{4,}$"";
            pattern = Pattern.compile(PASSWORD_PATTERN);
            matcher = pattern.matcher(passString);

            if (matcher.matches()) {
                return true;
            } else {
                Snackbar snackbar = Snackbar
                        .make(findViewById(android.R.id.content), R.string.invalid_password, Snackbar.LENGTH_LONG);
                snackbar.show();
                return false;
            }
        } else {
            Snackbar snackbar = Snackbar
                    .make(findViewById(android.R.id.content), R.string.password_length, Snackbar.LENGTH_LONG);
            snackbar.show();
            return false;
        }
    }
"	@return Boolean returns true if email format is correct, otherwise false	@return Boolean returns true if email format is correct, otherwise false	0	1	9	11	54
public Date getStart() { if (records.size() == NUM) { return new Date(); } else { Date first = records.get(NUM).getDate(); for (Entry e : records) { if (e.getDate().before(first)) { first = e.getDate(); } } return first; } }	"public Date getStart() {
    if (records.size() == NUM) {
        return null;
    } else {
        Date first = records.get(NUM).getDate();
        for (Entry e : records) {
            if (e.getDate().before(first)) {
                first = e.getDate();
            }
        }
        return first;
    }
}"	@return The time of the first record, or the current time if there are no records	@return The time of the first record or null if there are no records	1	0	11	13	68
"public String next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 180: { return(stem(3,""te"",""ed"")); } case 373: break; case 298: { return(stem(1,""a"",""s"")); } case 374: break; case 94: { return(stem(3,""ide"",""ed"")); } case 375: break; case 126: { return(stem(2,""al"",""s"")); } case 376: break; case 15: { return(null_stem()); } case 377: break; case 293: { return(stem(2,""la"",""s"")); } case 378: break; case 38: { return(stem(3,""will"","""")); } case 379: break; case 8: { yybegin(scan); if (option(tag_output)) return yytext(); } case 380: break; case 11: { return cnull_stem(); } case 381: break; case 72: { return(stem(3,""eel"",""ed"")); } case 382: break; case 173: { return(stem(3,""eal"",""ed"")); } case 383: break; case 177: { return(stem(4,""ake"",""en"")); } case 384: break; case 134: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,""I"","""")); } case 385: break; case 133: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(1,""y"","""")); } case 386: break; case 259: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 4; { return(stem(1,""y"","""")); } case 387: break; case 89: { return(stem(3,""ay"",""ed"")); } case 388: break; case 272: { return(stem(3,""se"",""ed"")); } case 389: break; case 95: { return(stem(3,""ise"",""ed"")); } case 390: break; case 236: { return(stem(3,""ike"",""ed"")); } case 391: break; case 29: { return(ynull_stem()); } case 392: break; case 111: { return(stem(3,""ell"",""ed"")); } case 393: break; case 10: { return(stem(1,""us"",""s"")); } case 394: break; case 1: { return(common_noun_stem()); } case 395: break; case 13: // lookahead expression with fixed lookahead length yypushback(1); { return(common_noun_stem()); } case 396: break; case 70: { return(stem(3,""ly"",""ed"")); } case 397: break; case 67: { return(stem(3,""ive"",""ed"")); } case 398: break; case 356: { return(stem(3,""is"",""s"")); } case 399: break; case 239: { return(stem(5,""eek"",""ed"")); } case 400: break; case 160: { return(stem(3,""ar"",""ed"")); } case 401: break; case 267: { return(stem(4,""ame"",""ed"")); } case 402: break; case 33: { return(stem(3,""see"",""ed"")); } case 403: break; case 151: { return(stem(3,""epe"",""ed"")); } case 404: break; case 21: { return(stem(3,""get"",""ed"")); } case 405: break; case 352: { return(stem(8,""-de-sac"",""s"")); } case 406: break; case 370: { return(stem(12,""-in-the-box"",""s"")); } case 407: break; case 266: { return(stem(5,""ing"",""ed"")); } case 408: break; case 182: { return(stem(2,""i"",""s"")); } case 409: break; case 162: { return(stem(3,""an"",""ed"")); } case 410: break; case 30: { return(stem(3,""red"",""ed"")); } case 411: break; case 51: { return(stem(3,""e"",""ing"")); } case 412: break; case 214: { return(stem(3,""ass"",""ed"")); } case 413: break; case 249: { return(stem(2,""re"",""s"")); } case 414: break; case 65: { return(stem(2,""e"",""s"")); } case 415: break; case 78: { return(stem(3,""o"",""en"")); } case 416: break; case 155: { return(stem(5,""do"",""ed"")); } case 417: break; case 71: { return(stem(3,""all"",""ed"")); } case 418: break; case 125: { return(stem(2,""ra"",""s"")); } case 419: break; case 212: { return(stem(6,""clepe"",""ed"")); } case 420: break; case 256: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 4; { return(stem(1,"""","""")); } case 421: break; case 60: { return(stem(3,""ear"",""ed"")); } case 422: break; case 63: { return(stem(3,""ome"",""ed"")); } case 423: break; case 52: { return(stem(1,"""",""ed"")); } case 424: break; case 157: { return(stem(3,""eeze"",""ed"")); } case 425: break; case 27: { return(stem(3,""light"",""ed"")); } case 426: break; case 139: { return(stem(3,""y"",""s"")); } case 427: break; case 296: { return(stem(2,""zo"",""s"")); } case 428: break; case 31: { return(stem(3,""run"",""ed"")); } case 429: break; case 46: { return(stem(2,""an"",""s"")); } case 430: break; case 333: { return(stem(3,""ix"",""ed"")); } case 431: break; case 304: { return(stem(4,""g"",""ing"")); } case 432: break; case 57: { return(stem(3,""end"",""ed"")); } case 433: break; case 131: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 7; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return(proper_name_stem()); } case 434: break; case 50: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 1; { return(proper_name_stem()); } case 435: break; case 55: { return(stem(3,""low"",""ed"")); } case 436: break; case 193: { return(stem(2,""ny"",""s"")); } case 437: break; case 138: { return(stem(3,""y"",""ed"")); } case 438: break; case 104: { return(stem(3,""mite"",""ed"")); } case 439: break; case 305: { return(stem(3,""d"",""en"")); } case 440: break; case 14: { return(stem(2,""e"",""ed"")); } case 441: break; case 100: { return(stem(3,""hoot"",""ed"")); } case 442: break; case 185: { return(stem(2,""so"",""s"")); } case 443: break; case 341: { return(stem(2,""r"",""s"")); } case 444: break; case 231: { return(stem(5,""elt"",""en"")); } case 445: break; case 225: { return(stem(4,""eeze"",""en"")); } case 446: break; case 332: { return(stem(4,""y"",""ing"")); } case 447: break; case 130: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { yybegin(noun); yypushback(yylength()); return(next()); } case 448: break; case 81: { return(stem(3,""ew"",""en"")); } case 449: break; case 113: { return(stem(3,""aw"",""en"")); } case 450: break; case 49: // lookahead expression with fixed lookahead length yypushback(2); { yybegin(verb); yypushback(yylength()); return(next()); } case 451: break; case 314: { return(stem(3,""ship"",""ed"")); } case 452: break; case 335: { return(stem(1,""de"",""s"")); } case 453: break; case 365: { return(stem(9,""-mutuel"",""s"")); } case 454: break; case 371: { return(stem(14,""y-in-waiting"",""s"")); } case 455: break; case 9: { return(stem(2,""be"","""")); } case 456: break; case 206: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,""be"","""")); } case 457: break; case 69: { return(stem(3,""lee"",""ed"")); } case 458: break; case 40: { return(stem(1,""um"",""s"")); } case 459: break; case 56: { return(stem(3,""reed"",""ed"")); } case 460: break; case 163: { return(stem(3,""ap"",""ed"")); } case 461: break; case 344: { return(stem(2,""te"",""s"")); } case 462: break; case 197: { return(stem(3,""f"",""s"")); } case 463: break; case 200: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,""can"","""")); } case 464: break; case 300: { return(stem(2,""lio"",""s"")); } case 465: break; case 108: { return(stem(3,""wim"",""en"")); } case 466: break; case 91: { return(stem(3,""ow"",""en"")); } case 467: break; case 321: { return(stem(2,""g"",""s"")); } case 468: break; case 228: { return(semi_reg_stem(1,"""")); } case 469: break; case 275: { return(stem(2,""gue"",""s"")); } case 470: break; case 143: { return(stem(3,""ei"",""ed"")); } case 471: break; case 37: { return(stem(3,""eat"",""ed"")); } case 472: break; case 17: { return(stem(3,""bid"",""ed"")); } case 473: break; case 217: { return(stem(3,"""",""en"")); } case 474: break; case 355: { return(stem(10,""an-at-arms"",""s"")); } case 475: break; case 132: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,""we"","""")); } case 476: break; case 244: { return(stem(2,""ron"",""s"")); } case 477: break; case 338: { return(stem(2,""non"",""s"")); } case 478: break; case 196: { return(stem(2,""uum"",""s"")); } case 479: break; case 24: { return(stem(3,""have"",""ed"")); } case 480: break; case 345: { return(stem(3,""ff"",""s"")); } case 481: break; case 251: { return(stem(2,""mum"",""s"")); } case 482: break; case 242: { return(stem(2,""ie"",""ed"")); } case 483: break; case 273: { return(stem(2,""ee"",""ed"")); } case 484: break; case 334: { return(stem(2,""do"",""s"")); } case 485: break; case 262: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,""do"",""s"")); } case 486: break; case 361: { return(stem(6,""-doux"",""s"")); } case 487: break; case 299: { return(stem(3,""ly"",""s"")); } case 488: break; case 224: { return(stem(4,""w"",""ed"")); } case 489: break; case 237: { return(stem(4,""eal"",""en"")); } case 490: break; case 253: { return(stem(6,""m.p."",""s"")); } case 491: break; case 45: { return(stem(2,"""",""s"")); } case 492: break; case 347: { return(stem(9,""an-of-war"",""s"")); } case 493: break; case 90: { return(stem(3,""ie"",""en"")); } case 494: break; case 121: { return(stem(2,""tum"",""s"")); } case 495: break; case 199: { return(stem(5,""eyrir"",""s"")); } case 496: break; case 110: { return(stem(3,""ee"",""en"")); } case 497: break; case 204: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,""will"","""")); } case 498: break; case 250: { return(stem(2,""ia"",""s"")); } case 499: break; case 255: { return(stem(3,""s"",""s"")); } case 500: break; case 44: { return(stem(2,""uo"",""s"")); } case 501: break; case 226: { return(stem(5,""ight"",""ed"")); } case 502: break; case 124: { return(stem(3,""ouse"",""s"")); } case 503: break; case 359: { return(stem(2,""t"",""s"")); } case 504: break; case 7: { return(stem(2,""be"",""s"")); } case 505: break; case 260: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,""be"",""s"")); } case 506: break; case 53: { return(semi_reg_stem(0,""e"")); } case 507: break; case 357: { return(stem(8,""-in-law"",""s"")); } case 508: break; case 181: { return(stem(4,""."",""s"")); } case 509: break; case 169: { return(stem(3,""ay"",""en"")); } case 510: break; case 165: { return(stem(3,""se"",""en"")); } case 511: break; case 39: { return(stem(3,""have"","""")); } case 512: break; case 3: { // The first word isn't stemmed separately, but the second half can be String stem = common_noun_stem(); String n = next(); if (n == null) { return stem; } else { return stem.concat(n); } } case 513: break; case 166: { return(stem(3,""ine"",""ed"")); } case 514: break; case 278: { return(stem(5,""ink"",""ed"")); } case 515: break; case 326: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 4; { return(stem(4,""be"",""ed"")); } case 516: break; case 116: { return(stem(4,""be"",""ed"")); } case 517: break; case 360: { return(stem(9,""-down"",""ing"")); } case 518: break; case 297: { return(stem(3,""en"",""s"")); } case 519: break; case 148: { return(stem(4,""ear"",""en"")); } case 520: break; case 362: { return(stem(8,""-de-lys"",""s"")); } case 521: break; case 115: { return(stem(4,""go"",""ed"")); } case 522: break; case 309: { return(stem(4,""y"",""ed"")); } case 523: break; case 42: { return(stem(2,""a"",""s"")); } case 524: break; case 189: { return(stem(3,""x"",""s"")); } case 525: break; case 61: { return(stem(3,""id"",""ed"")); } case 526: break; case 83: { return(stem(4,""have"",""s"")); } case 527: break; case 59: { return(stem(3,""ear"",""en"")); } case 528: break; case 96: { return(stem(3,""eeve"",""ed"")); } case 529: break; case 76: { return(stem(3,""ild"",""ed"")); } case 530: break; case 354: { return(stem(10,""anservant"",""s"")); } case 531: break; case 202: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 3; { return(stem(3,""he"","""")); } case 532: break; case 254: { return(stem(4,""ex"",""s"")); } case 533: break; case 150: { return(stem(3,""oose"",""ed"")); } case 534: break; case 336: { return(stem(4,""-in"",""s"")); } case 535: break; case 285: { return(stem(6,""ork"",""ed"")); } case 536: break; case 144: { return(stem(3,""eak"",""ed"")); } case 537: break; case 112: { return(stem(3,""ink"",""ed"")); } case 538: break; case 241: { return(stem(3,""a"",""ed"")); } case 539: break; case 141: { return(stem(3,""rn"",""ed"")); } case 540: break; case 330: { return(stem(6,""-up"",""ed"")); } case 541: break; case 156: { return(stem(3,""y"",""en"")); } case 542: break; case 119: { return(stem(2,""um"",""s"")); } case 543: break; case 222: { return(stem(4,""tch"",""ed"")); } case 544: break; case 88: { return(stem(3,""ose"",""ed"")); } case 545: break; case 25: { return(stem(3,""have"",""s"")); } case 546: break; case 101: { return(stem(3,""hit"",""ed"")); } case 547: break; case 122: { return(stem(3,""oot"",""s"")); } case 548: break; case 68: { return(stem(4,""do"",""s"")); } case 549: break; case 97: { return(stem(3,""ing"",""ed"")); } case 550: break; case 246: { return(stem(3,""denum"",""s"")); } case 551: break; case 353: { return(stem(6,""-over"",""s"")); } case 552: break; case 191: { return(stem(1,""s"",""s"")); } case 553: break; case 34: { return(stem(3,""win"",""ed"")); } case 554: break; case 82: { return(stem(3,""eave"",""ed"")); } case 555: break; case 343: { return(stem(7,""-up"",""ing"")); } case 556: break; case 74: { return(stem(3,""eld"",""ed"")); } case 557: break; case 289: { return(stem(4,""yatid"",""s"")); } case 558: break; case 342: { return(stem(4,""us"",""s"")); } case 559: break; case 291: { return(stem(1,""o"",""s"")); } case 560: break; case 127: { return(stem(2,""lo"",""s"")); } case 561: break; case 103: { return(stem(3,""lide"",""ed"")); } case 562: break; case 41: { return(stem(2,""."",""s"")); } case 563: break; case 175: { return(stem(3,""and"",""ed"")); } case 564: break; case 223: { return(stem(3,""am"",""ed"")); } case 565: break; case 114: { return(stem(3,""read"",""ed"")); } case 566: break; case 263: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,""have"",""s"")); } case 567: break; case 350: { return(stem(8,""-down"",""ed"")); } case 568: break; case 209: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,""have"",""ed"")); } case 569: break; case 137: { return(stem(3,"""",""ing"")); } case 570: break; case 146: { return(stem(5,""be"",""ing"")); } case 571: break; case 219: { return(stem(4,""te"",""ing"")); } case 572: break; case 322: { return(stem(4,""isee"",""s"")); } case 573: break; case 118: { return(stem(1,""on"",""s"")); } case 574: break; case 117: { return(stem(2,"""",""ed"")); } case 575: break; case 307: { return(stem(4,""y"",""s"")); } case 576: break; case 346: { return(stem(4,""-on"",""s"")); } case 577: break; case 337: { return(stem(8,""onsieur"",""s"")); } case 578: break; case 178: { return(stem(4,""eave"",""en"")); } case 579: break; case 248: { return(stem(3,""us"",""s"")); } case 580: break; case 366: { return(stem(9,""-de-camp"",""s"")); } case 581: break; case 201: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 3; { return(stem(3,""she"","""")); } case 582: break; case 64: { return(stem(3,""raw"",""ed"")); } case 583: break; case 317: { return(stem(2,""cio"",""s"")); } case 584: break; case 372: { return(stem(11,""y-general"",""s"")); } case 585: break; case 320: { return(stem(2,""eum"",""s"")); } case 586: break; case 369: { return(stem(9,""-at-arms"",""s"")); } case 587: break; case 315: { return(stem(2,""ion"",""s"")); } case 588: break; case 368: { return(stem(11,""erfamilias"",""s"")); } case 589: break; case 328: { return(stem(6,""-down"",""s"")); } case 590: break; case 288: { return(stem(1,""x"",""s"")); } case 591: break; case 323: { return(stem(2,""oan"",""s"")); } case 592: break; case 306: { return(stem(5,""eech"",""ed"")); } case 593: break; case 73: { return(stem(3,""row"",""ed"")); } case 594: break; case 4: { return yytext(); } case 595: break; case 292: { return(stem(2,""ro"",""s"")); } case 596: break; case 252: { return(stem(3,""ey"",""s"")); } case 597: break; case 324: { return(stem(2,""ton"",""s"")); } case 598: break; case 5: { return(stem(1,"""",""s"")); } case 599: break; case 303: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 3; { return(stem(3,""be"","""")); } case 600: break; case 36: { return(stem(3,""be"","""")); } case 601: break; case 229: { return(stem(5,""et"",""en"")); } case 602: break; case 99: { return(stem(3,""hoe"",""ed"")); } case 603: break; case 164: { return(stem(3,""de"",""en"")); } case 604: break; case 43: { return(xnull_stem()); } case 605: break; case 363: { return(stem(8,""-de-lis"",""s"")); } case 606: break; case 207: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,""have"","""")); } case 607: break; case 271: { return(stem(5,""ivy"",""s"")); } case 608: break; case 238: { return(stem(3,""ge"",""ed"")); } case 609: break; case 233: { return(stem(3,""ce"",""ed"")); } case 610: break; case 176: { return(stem(3,""ke"",""en"")); } case 611: break; case 105: { return(stem(3,""pin"",""ed"")); } case 612: break; case 287: { return(stem(2,""no"",""s"")); } case 613: break; case 312: { return(semi_reg_stem(0,""ue"")); } case 614: break; case 235: { return(stem(3,""il"",""ed"")); } case 615: break; case 351: { return(stem(2,""l"",""s"")); } case 616: break; case 167: { return(semi_reg_stem(0,"""")); } case 617: break; case 159: { return(stem(3,""ve"",""en"")); } case 618: break; case 203: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 3; { return(stem(2,""e"","""")); } case 619: break; case 234: { return(stem(5,""ink"",""en"")); } case 620: break; case 145: { return(stem(3,""gin"",""ed"")); } case 621: break; case 286: { return(stem(5,""y"",""ed"")); } case 622: break; case 205: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 3; { return(stem(3,""we"","""")); } case 623: break; case 171: { return(stem(3,""ill"",""ed"")); } case 624: break; case 232: { return(stem(3,""ue"",""ed"")); } case 625: break; case 245: { return(stem(1,""i"",""s"")); } case 626: break; case 183: { return(stem(2,""d"",""s"")); } case 627: break; case 19: { return(stem(3,""do"",""ed"")); } case 628: break; case 58: { return(stem(4,""be"",""en"")); } case 629: break; case 270: { return(stem(5,""ivy"",""ed"")); } case 630: break; case 168: { return(stem(3,""i"",""ed"")); } case 631: break; case 187: { return(stem(1,""e"",""s"")); } case 632: break; case 340: { return(stem(2,""le"",""s"")); } case 633: break; case 280: { return(stem(5,""ead"",""en"")); } case 634: break; case 301: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 5; { return(stem(2,""y"","""")); } case 635: break; case 149: { return(stem(3,""rse"",""ed"")); } case 636: break; case 66: { return(stem(4,""do"",""en"")); } case 637: break; case 170: { return(stem(3,""ite"",""ed"")); } case 638: break; case 227: { return(stem(3,""l"",""en"")); } case 639: break; case 128: { return(stem(4,""ABC"",""s"")); } case 640: break; case 106: { return(stem(3,""peed"",""ed"")); } case 641: break; case 215: { return(stem(4,""eak"",""en"")); } case 642: break; case 28: { return(stem(3,""meet"",""ed"")); } case 643: break; case 348: { return(stem(4,""-by"",""s"")); } case 644: break; case 135: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(1, """", ""n"")); } case 645: break; case 325: { return(stem(4,""s"",""s"")); } case 646: break; case 318: { return(stem(3,""esis"",""s"")); } case 647: break; case 230: { return(stem(3,""ey"",""ed"")); } case 648: break; case 142: { return(stem(3,""ess"",""ed"")); } case 649: break; case 218: { return(stem(3,""e"",""en"")); } case 650: break; case 349: { return(stem(4,""o"",""s"")); } case 651: break; case 152: { return(stem(4,""are"",""ed"")); } case 652: break; case 147: { return(stem(4,""ind"",""ed"")); } case 653: break; case 172: { return(stem(3,""ick"",""ed"")); } case 654: break; case 153: { return(stem(4,""ie"",""ing"")); } case 655: break; case 107: { return(stem(3,""pit"",""ed"")); } case 656: break; case 184: { return(stem(2,""u"",""s"")); } case 657: break; case 129: { return(stem(2,""to"",""s"")); } case 658: break; case 268: { return(stem(3,""ride"",""ed"")); } case 659: break; case 186: { return(stem(2,""denum"",""s"")); } case 660: break; case 290: { return(stem(4,""sbok"",""s"")); } case 661: break; case 308: { return(stem(6,""ivy"",""ing"")); } case 662: break; case 367: { return(stem(13,""ademoiselle"",""s"")); } case 663: break; case 195: { return(stem(4,""ooth"",""s"")); } case 664: break; case 20: { return(stem(3,""feed"",""ed"")); } case 665: break; case 98: { return(stem(3,""ink"",""en"")); } case 666: break; case 92: { return(stem(3,""ake"",""ed"")); } case 667: break; case 62: { return(stem(3,""lothe"",""ed"")); } case 668: break; case 18: { return(stem(3,""dig"",""ed"")); } case 669: break; case 279: { return(stem(4,""k"",""ed"")); } case 670: break; case 194: { return(stem(2,""po"",""s"")); } case 671: break; case 221: { return(stem(3,""ose"",""en"")); } case 672: break; case 174: { return(stem(3,""ave"",""ed"")); } case 673: break; case 77: { return(stem(3,""ird"",""ed"")); } case 674: break; case 161: { return(stem(3,""in"",""ed"")); } case 675: break; case 210: { return(stem(4,"""",""ing"")); } case 676: break; case 85: { return(stem(3,""en"",""ed"")); } case 677: break; case 87: { return(stem(3,""o"",""ed"")); } case 678: break; case 281: { return(stem(3,""mel"",""s"")); } case 679: break; case 274: { return(stem(4,""-up"",""s"")); } case 680: break; case 12: { return(stem(2,""is"",""s"")); } case 681: break; case 23: { return(stem(3,""hide"",""ed"")); } case 682: break; case 93: { return(stem(3,""ing"",""en"")); } case 683: break; case 257: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 3; { return(stem(3,""not"","""")); } case 684: break; case 283: { return(stem(4,""i"",""ing"")); } case 685: break; case 243: { return(stem(4,""e"",""ing"")); } case 686: break; case 284: { return(stem(4,""a"",""ing"")); } case 687: break; case 136: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,""'s"","""")); } case 688: break; case 264: { return(condub_stem(3,"""",""ing"")); } case 689: break; case 120: { return(stem(3,""a"",""s"")); } case 690: break; case 327: { return(stem(4,""l"",""ing"")); } case 691: break; case 316: { return(stem(2,""ne"",""s"")); } case 692: break; case 247: { return(stem(3,""ur"",""s"")); } case 693: break; case 198: { return(stem(2,""b"",""s"")); } case 694: break; case 220: { return(stem(5,""uy"",""ed"")); } case 695: break; case 258: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 3; { return(stem(3,""shall"","""")); } case 696: break; case 190: { return(stem(3,""fe"",""s"")); } case 697: break; case 216: { return(stem(2,"""",""en"")); } case 698: break; case 311: { return(stem(5,""ify"",""s"")); } case 699: break; case 313: { return(stem(5,""k"",""ing"")); } case 700: break; case 6: { return(cnull_stem()); } case 701: break; case 80: { return(stem(3,""old"",""ed"")); } case 702: break; case 339: { return(stem(4,""ese"",""s"")); } case 703: break; case 2: { String str = yytext(); int first = str.charAt(0); String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s) - this may be because your text isn't using _ as a tag delimiter"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); LOGGER.warning(msg); } case 704: break; case 294: { return(stem(2,""dum"",""s"")); } case 705: break; case 47: { return(stem(2,""s"",""s"")); } case 706: break; case 329: { return(stem(5,""y"",""ing"")); } case 707: break; case 358: { return(stem(6,""-lit"",""s"")); } case 708: break; case 158: { return(stem(3,""ip"",""ed"")); } case 709: break; case 79: { return(stem(3,""ang"",""ed"")); } case 710: break; case 331: { return(stem(6,""ify"",""ing"")); } case 711: break; case 295: { return(stem(4,""belly"",""s"")); } case 712: break; case 188: { return(stem(4,""oose"",""s"")); } case 713: break; case 282: { return(stem(4,""ge"",""ing"")); } case 714: break; case 109: { return(stem(3,""wim"",""ed"")); } case 715: break; case 179: { return(stem(3,""t"",""en"")); } case 716: break; case 276: { return(stem(4,""ue"",""ing"")); } case 717: break; case 48: { return(stem(2,""vum"",""s"")); } case 718: break; case 123: { return(stem(2,""rum"",""s"")); } case 719: break; case 192: { return(stem(2,""num"",""s"")); } case 720: break; case 102: { return(stem(3,""lay"",""ed"")); } case 721: break; case 277: { return(stem(5,""ell"",""en"")); } case 722: break; case 140: { return(stem(3,"""",""ed"")); } case 723: break; case 261: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,""as"","""")); } case 724: break; case 16: { return(stem(3,""bite"",""ed"")); } case 725: break; case 154: { return(stem(3,""al"",""ed"")); } case 726: break; case 213: { return(stem(3,"""",""s"")); } case 727: break; case 302: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 3; { return(stem(3,""be"",""ed"")); } case 728: break; case 35: { return(stem(3,""be"",""ed"")); } case 729: break; case 32: { return(stem(3,""sit"",""ed"")); } case 730: break; case 240: { return(stem(5,""each"",""ed"")); } case 731: break; case 364: { return(stem(9,""-a-terre"",""s"")); } case 732: break; case 84: { return(stem(3,""now"",""ed"")); } case 733: break; case 22: { return(stem(3,""gin"",""en"")); } case 734: break; case 269: { return(stem(3,""ie"",""ed"")); } case 735: break; case 75: { return(stem(3,""ee"",""ed"")); } case 736: break; case 86: { return(stem(3,""eep"",""ed"")); } case 737: break; case 208: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,""would"","""")); } case 738: break; case 54: { return(stem(3,""leed"",""ed"")); } case 739: break; case 26: { return(stem(3,""lead"",""ed"")); } case 740: break; case 265: { return(stem(7,""clepe"",""ed"")); } case 741: break; case 319: { return(stem(4,""eps"",""s"")); } case 742: break; case 310: { return(stem(5,""ify"",""ed"")); } case 743: break; case 211: { return(condub_stem(2,"""",""ed"")); } case 744: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }"	"  public String next() throws java.io.IOException {
    int zzInput;
    int zzAction;

    // cached fields:
    int zzCurrentPosL;
    int zzMarkedPosL;
    int zzEndReadL = zzEndRead;
    char [] zzBufferL = zzBuffer;
    char [] zzCMapL = ZZ_CMAP;

    int [] zzTransL = ZZ_TRANS;
    int [] zzRowMapL = ZZ_ROWMAP;
    int [] zzAttrL = ZZ_ATTRIBUTE;

    while (true) {
      zzMarkedPosL = zzMarkedPos;

      zzAction = -1;

      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
  
      zzState = ZZ_LEXSTATE[zzLexicalState];

      // set up zzAction for empty match case:
      int zzAttributes = zzAttrL[zzState];
      if ( (zzAttributes & 1) == 1 ) {
        zzAction = zzState;
      }


      zzForAction: {
        while (true) {
    
          if (zzCurrentPosL < zzEndReadL)
            zzInput = zzBufferL[zzCurrentPosL++];
          else if (zzAtEOF) {
            zzInput = YYEOF;
            break zzForAction;
          }
          else {
            // store back cached positions
            zzCurrentPos  = zzCurrentPosL;
            zzMarkedPos   = zzMarkedPosL;
            boolean eof = zzRefill();
            // get translated positions and possibly new buffer
            zzCurrentPosL  = zzCurrentPos;
            zzMarkedPosL   = zzMarkedPos;
            zzBufferL      = zzBuffer;
            zzEndReadL     = zzEndRead;
            if (eof) {
              zzInput = YYEOF;
              break zzForAction;
            }
            else {
              zzInput = zzBufferL[zzCurrentPosL++];
            }
          }
          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
          if (zzNext == -1) break zzForAction;
          zzState = zzNext;

          zzAttributes = zzAttrL[zzState];
          if ( (zzAttributes & 1) == 1 ) {
            zzAction = zzState;
            zzMarkedPosL = zzCurrentPosL;
            if ( (zzAttributes & 8) == 8 ) break zzForAction;
          }

        }
      }

      // store back cached position
      zzMarkedPos = zzMarkedPosL;

      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
        case 1: 
          { return(common_noun_stem());
          }
        case 382: break;
        case 2: 
          { return(stem(1,""be"",""""));
          }
        case 383: break;
        case 3: 
          { return(stem(1,""have"",""""));
          }
        case 384: break;
        case 4: 
          { String str = yytext();
                            int first = str.charAt(0);
	                          String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s) - this may be because your text isn't using _ as a tag delimiter"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));
                  LOGGER.warning(msg);
          }
        case 385: break;
        case 5: 
          { // The first word isn't stemmed separately, but the second half can be
                            String stem = common_noun_stem();
                            String n = next();
                            if (n == null) {
                              return stem;
                            } else {
                              return stem.concat(n);
                            }
          }
        case 386: break;
        case 6: 
          { return yytext();
          }
        case 387: break;
        case 7: 
          { return(stem(1,"""",""s""));
          }
        case 388: break;
        case 8: 
          { return(cnull_stem());
          }
        case 389: break;
        case 9: 
          { return(stem(1,""o"",""""));
          }
        case 390: break;
        case 10: 
          { return(stem(2,""know"",""""));
          }
        case 391: break;
        case 11: 
          { return(stem(2,""be"",""""));
          }
        case 392: break;
        case 12: 
          { return(stem(2,""have"",""""));
          }
        case 393: break;
        case 13: 
          { return(stem(2,""be"",""s""));
          }
        case 394: break;
        case 14: 
          { yybegin(scan); if (option(tag_output)) return yytext();
          }
        case 395: break;
        case 15: 
          { return(stem(1,""us"",""s""));
          }
        case 396: break;
        case 16: 
          { return cnull_stem();
          }
        case 397: break;
        case 17: 
          { return(stem(2,""is"",""s""));
          }
        case 398: break;
        case 18: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return(common_noun_stem());
          }
        case 399: break;
        case 19: 
          { return(stem(2,""e"",""ed""));
          }
        case 400: break;
        case 20: 
          { return(null_stem());
          }
        case 401: break;
        case 21: 
          { return(stem(3,""bite"",""ed""));
          }
        case 402: break;
        case 22: 
          { return(stem(3,""bid"",""ed""));
          }
        case 403: break;
        case 23: 
          { return(stem(3,""dig"",""ed""));
          }
        case 404: break;
        case 24: 
          { return(stem(3,""do"",""ed""));
          }
        case 405: break;
        case 25: 
          { return(stem(3,""feed"",""ed""));
          }
        case 406: break;
        case 26: 
          { return(stem(3,""get"",""ed""));
          }
        case 407: break;
        case 27: 
          { return(stem(3,""gin"",""en""));
          }
        case 408: break;
        case 28: 
          { return(stem(3,""hide"",""ed""));
          }
        case 409: break;
        case 29: 
          { return(stem(1,""ve"",""ed""));
          }
        case 410: break;
        case 30: 
          { return(stem(1,""ve"",""s""));
          }
        case 411: break;
        case 31: 
          { return(stem(3,""lead"",""ed""));
          }
        case 412: break;
        case 32: 
          { return(stem(3,""light"",""ed""));
          }
        case 413: break;
        case 33: 
          { return(stem(3,""meet"",""ed""));
          }
        case 414: break;
        case 34: 
          { return(ynull_stem());
          }
        case 415: break;
        case 35: 
          { return(stem(3,""red"",""ed""));
          }
        case 416: break;
        case 36: 
          { return(stem(3,""run"",""ed""));
          }
        case 417: break;
        case 37: 
          { return(stem(3,""sit"",""ed""));
          }
        case 418: break;
        case 38: 
          { return(stem(3,""see"",""ed""));
          }
        case 419: break;
        case 39: 
          { return(stem(3,""win"",""ed""));
          }
        case 420: break;
        case 40: 
          { return(stem(3,""be"",""ed""));
          }
        case 421: break;
        case 41: 
          { return(stem(3,""be"",""""));
          }
        case 422: break;
        case 42: 
          { return(stem(3,""eat"",""ed""));
          }
        case 423: break;
        case 43: 
          { return(stem(3,""will"",""""));
          }
        case 424: break;
        case 44: 
          { return(stem(3,""have"",""""));
          }
        case 425: break;
        case 45: 
          { return(stem(1,""um"",""s""));
          }
        case 426: break;
        case 46: 
          { return(stem(2,""."",""s""));
          }
        case 427: break;
        case 47: 
          { return(stem(2,""a"",""s""));
          }
        case 428: break;
        case 48: 
          { return(xnull_stem());
          }
        case 429: break;
        case 49: 
          { return(stem(2,""uo"",""s""));
          }
        case 430: break;
        case 50: 
          { return(stem(2,"""",""s""));
          }
        case 431: break;
        case 51: 
          { return(stem(2,""an"",""s""));
          }
        case 432: break;
        case 52: 
          { return(stem(2,""s"",""s""));
          }
        case 433: break;
        case 53: 
          { return(stem(2,""vum"",""s""));
          }
        case 434: break;
        case 54: 
          // lookahead expression with fixed lookahead length
          yypushback(2);
          { yybegin(verb); yypushback(yylength()); return(next());
          }
        case 435: break;
        case 55: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 1;
          { return(proper_name_stem());
          }
        case 436: break;
        case 56: 
          { return(stem(3,""e"",""ing""));
          }
        case 437: break;
        case 57: 
          { return(stem(1,"""",""ed""));
          }
        case 438: break;
        case 58: 
          { return(semi_reg_stem(0,""e""));
          }
        case 439: break;
        case 59: 
          { return(stem(3,""leed"",""ed""));
          }
        case 440: break;
        case 60: 
          { return(stem(3,""low"",""ed""));
          }
        case 441: break;
        case 61: 
          { return(stem(3,""reed"",""ed""));
          }
        case 442: break;
        case 62: 
          { return(stem(3,""end"",""ed""));
          }
        case 443: break;
        case 63: 
          { return(stem(4,""be"",""en""));
          }
        case 444: break;
        case 64: 
          { return(stem(3,""ear"",""en""));
          }
        case 445: break;
        case 65: 
          { return(stem(3,""ear"",""ed""));
          }
        case 446: break;
        case 66: 
          { return(stem(3,""id"",""ed""));
          }
        case 447: break;
        case 67: 
          { return(stem(3,""lothe"",""ed""));
          }
        case 448: break;
        case 68: 
          { return(stem(3,""ome"",""ed""));
          }
        case 449: break;
        case 69: 
          { return(stem(3,""raw"",""ed""));
          }
        case 450: break;
        case 70: 
          { return(stem(2,""e"",""s""));
          }
        case 451: break;
        case 71: 
          { return(stem(4,""do"",""en""));
          }
        case 452: break;
        case 72: 
          { return(stem(3,""ive"",""ed""));
          }
        case 453: break;
        case 73: 
          { return(stem(3,""lee"",""ed""));
          }
        case 454: break;
        case 74: 
          { return(stem(3,""ly"",""ed""));
          }
        case 455: break;
        case 75: 
          { return(stem(3,""all"",""ed""));
          }
        case 456: break;
        case 76: 
          { return(stem(3,""eel"",""ed""));
          }
        case 457: break;
        case 77: 
          { return(stem(3,""row"",""ed""));
          }
        case 458: break;
        case 78: 
          { return(stem(3,""eld"",""ed""));
          }
        case 459: break;
        case 79: 
          { return(stem(3,""ee"",""ed""));
          }
        case 460: break;
        case 80: 
          { return(stem(3,""ild"",""ed""));
          }
        case 461: break;
        case 81: 
          { return(stem(3,""ird"",""ed""));
          }
        case 462: break;
        case 82: 
          { return(stem(3,""o"",""en""));
          }
        case 463: break;
        case 83: 
          { return(stem(3,""ang"",""ed""));
          }
        case 464: break;
        case 84: 
          { return(stem(3,""old"",""ed""));
          }
        case 465: break;
        case 85: 
          { return(stem(3,""ew"",""en""));
          }
        case 466: break;
        case 86: 
          { return(stem(3,""eave"",""ed""));
          }
        case 467: break;
        case 87: 
          { return(stem(2,""ve"",""s""));
          }
        case 468: break;
        case 88: 
          { return(stem(3,""now"",""ed""));
          }
        case 469: break;
        case 89: 
          { return(stem(3,""en"",""ed""));
          }
        case 470: break;
        case 90: 
          { return(stem(3,""eep"",""ed""));
          }
        case 471: break;
        case 91: 
          { return(stem(3,""o"",""ed""));
          }
        case 472: break;
        case 92: 
          { return(stem(3,""ose"",""ed""));
          }
        case 473: break;
        case 93: 
          { return(stem(3,""ay"",""ed""));
          }
        case 474: break;
        case 94: 
          { return(stem(3,""ie"",""en""));
          }
        case 475: break;
        case 95: 
          { return(stem(3,""ow"",""en""));
          }
        case 476: break;
        case 96: 
          { return(stem(3,""ake"",""ed""));
          }
        case 477: break;
        case 97: 
          { return(stem(3,""ing"",""en""));
          }
        case 478: break;
        case 98: 
          { return(stem(3,""ide"",""ed""));
          }
        case 479: break;
        case 99: 
          { return(stem(3,""ise"",""ed""));
          }
        case 480: break;
        case 100: 
          { return(stem(3,""eeve"",""ed""));
          }
        case 481: break;
        case 101: 
          { return(stem(3,""ing"",""ed""));
          }
        case 482: break;
        case 102: 
          { return(stem(3,""ink"",""en""));
          }
        case 483: break;
        case 103: 
          { return(stem(3,""hoe"",""ed""));
          }
        case 484: break;
        case 104: 
          { return(stem(3,""hoot"",""ed""));
          }
        case 485: break;
        case 105: 
          { return(stem(3,""hit"",""ed""));
          }
        case 486: break;
        case 106: 
          { return(stem(3,""lay"",""ed""));
          }
        case 487: break;
        case 107: 
          { return(stem(3,""lide"",""ed""));
          }
        case 488: break;
        case 108: 
          { return(stem(3,""mite"",""ed""));
          }
        case 489: break;
        case 109: 
          { return(stem(3,""pin"",""ed""));
          }
        case 490: break;
        case 110: 
          { return(stem(3,""peed"",""ed""));
          }
        case 491: break;
        case 111: 
          { return(stem(3,""pit"",""ed""));
          }
        case 492: break;
        case 112: 
          { return(stem(3,""wim"",""en""));
          }
        case 493: break;
        case 113: 
          { return(stem(3,""wim"",""ed""));
          }
        case 494: break;
        case 114: 
          { return(stem(3,""ee"",""en""));
          }
        case 495: break;
        case 115: 
          { return(stem(3,""ell"",""ed""));
          }
        case 496: break;
        case 116: 
          { return(stem(3,""ink"",""ed""));
          }
        case 497: break;
        case 117: 
          { return(stem(3,""aw"",""en""));
          }
        case 498: break;
        case 118: 
          { return(stem(3,""read"",""ed""));
          }
        case 499: break;
        case 119: 
          { return(stem(4,""go"",""ed""));
          }
        case 500: break;
        case 120: 
          { return(stem(4,""be"",""ed""));
          }
        case 501: break;
        case 121: 
          { return(stem(2,"""",""ed""));
          }
        case 502: break;
        case 122: 
          { return(stem(1,""on"",""s""));
          }
        case 503: break;
        case 123: 
          { return(stem(2,""um"",""s""));
          }
        case 504: break;
        case 124: 
          { return(stem(3,""a"",""s""));
          }
        case 505: break;
        case 125: 
          { return(stem(2,""tum"",""s""));
          }
        case 506: break;
        case 126: 
          { return(stem(3,""oot"",""s""));
          }
        case 507: break;
        case 127: 
          { return(stem(2,""rum"",""s""));
          }
        case 508: break;
        case 128: 
          { return(stem(3,""ouse"",""s""));
          }
        case 509: break;
        case 129: 
          { return(stem(2,""ra"",""s""));
          }
        case 510: break;
        case 130: 
          { return(stem(2,""al"",""s""));
          }
        case 511: break;
        case 131: 
          { return(stem(2,""lo"",""s""));
          }
        case 512: break;
        case 132: 
          { return(stem(4,""ABC"",""s""));
          }
        case 513: break;
        case 133: 
          { return(stem(2,""to"",""s""));
          }
        case 514: break;
        case 134: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 2;
          { return(stem(2,""we"",""""));
          }
        case 515: break;
        case 135: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 1;
          { return(stem(1,""would"",""""));
          }
        case 516: break;
        case 136: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 2;
          { return(stem(1,""y"",""""));
          }
        case 517: break;
        case 137: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 2;
          { return(stem(2,""I"",""""));
          }
        case 518: break;
        case 138: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 1;
          { return(stem(1,""not"",""""));
          }
        case 519: break;
        case 139: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 2;
          { return(stem(1, """", ""n""));
          }
        case 520: break;
        case 140: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 2;
          { return(stem(2,""'s"",""""));
          }
        case 521: break;
        case 141: 
          { return(stem(3,"""",""ing""));
          }
        case 522: break;
        case 142: 
          { return(stem(3,""y"",""ed""));
          }
        case 523: break;
        case 143: 
          { return(stem(3,""y"",""s""));
          }
        case 524: break;
        case 144: 
          { return(stem(3,"""",""ed""));
          }
        case 525: break;
        case 145: 
          { return(stem(3,""rn"",""ed""));
          }
        case 526: break;
        case 146: 
          { return(stem(3,""ess"",""ed""));
          }
        case 527: break;
        case 147: 
          { return(stem(3,""ei"",""ed""));
          }
        case 528: break;
        case 148: 
          { return(stem(3,""eak"",""ed""));
          }
        case 529: break;
        case 149: 
          { return(stem(3,""gin"",""ed""));
          }
        case 530: break;
        case 150: 
          { return(stem(5,""be"",""ing""));
          }
        case 531: break;
        case 151: 
          { return(stem(4,""ind"",""ed""));
          }
        case 532: break;
        case 152: 
          { return(stem(4,""ear"",""en""));
          }
        case 533: break;
        case 153: 
          { return(stem(3,""rse"",""ed""));
          }
        case 534: break;
        case 154: 
          { return(stem(3,""oose"",""ed""));
          }
        case 535: break;
        case 155: 
          { return(stem(3,""epe"",""ed""));
          }
        case 536: break;
        case 156: 
          { return(stem(4,""are"",""ed""));
          }
        case 537: break;
        case 157: 
          { return(stem(4,""ie"",""ing""));
          }
        case 538: break;
        case 158: 
          { return(stem(3,""al"",""ed""));
          }
        case 539: break;
        case 159: 
          { return(stem(5,""do"",""ed""));
          }
        case 540: break;
        case 160: 
          { return(stem(3,""y"",""en""));
          }
        case 541: break;
        case 161: 
          { return(stem(3,""eeze"",""ed""));
          }
        case 542: break;
        case 162: 
          { return(stem(3,""ip"",""ed""));
          }
        case 543: break;
        case 163: 
          { return(stem(3,""ve"",""en""));
          }
        case 544: break;
        case 164: 
          { return(stem(3,""ar"",""ed""));
          }
        case 545: break;
        case 165: 
          { return(stem(3,""in"",""ed""));
          }
        case 546: break;
        case 166: 
          { return(stem(3,""an"",""ed""));
          }
        case 547: break;
        case 167: 
          { return(stem(3,""ap"",""ed""));
          }
        case 548: break;
        case 168: 
          { return(stem(3,""de"",""en""));
          }
        case 549: break;
        case 169: 
          { return(stem(3,""se"",""en""));
          }
        case 550: break;
        case 170: 
          { return(stem(3,""ine"",""ed""));
          }
        case 551: break;
        case 171: 
          { return(semi_reg_stem(0,""""));
          }
        case 552: break;
        case 172: 
          { return(stem(3,""i"",""ed""));
          }
        case 553: break;
        case 173: 
          { return(stem(3,""ay"",""en""));
          }
        case 554: break;
        case 174: 
          { return(stem(3,""ite"",""ed""));
          }
        case 555: break;
        case 175: 
          { return(stem(3,""ill"",""ed""));
          }
        case 556: break;
        case 176: 
          { return(stem(3,""ick"",""ed""));
          }
        case 557: break;
        case 177: 
          { return(stem(3,""eal"",""ed""));
          }
        case 558: break;
        case 178: 
          { return(stem(3,""ave"",""ed""));
          }
        case 559: break;
        case 179: 
          { return(stem(3,""and"",""ed""));
          }
        case 560: break;
        case 180: 
          { return(stem(3,""ke"",""en""));
          }
        case 561: break;
        case 181: 
          { return(stem(4,""ake"",""en""));
          }
        case 562: break;
        case 182: 
          { return(stem(4,""eave"",""en""));
          }
        case 563: break;
        case 183: 
          { return(stem(3,""t"",""en""));
          }
        case 564: break;
        case 184: 
          { return(stem(3,""te"",""ed""));
          }
        case 565: break;
        case 185: 
          { return(stem(4,""."",""s""));
          }
        case 566: break;
        case 186: 
          { return(stem(2,""i"",""s""));
          }
        case 567: break;
        case 187: 
          { return(stem(2,""d"",""s""));
          }
        case 568: break;
        case 188: 
          { return(stem(2,""u"",""s""));
          }
        case 569: break;
        case 189: 
          { return(stem(2,""so"",""s""));
          }
        case 570: break;
        case 190: 
          { return(stem(2,""denum"",""s""));
          }
        case 571: break;
        case 191: 
          { return(stem(1,""e"",""s""));
          }
        case 572: break;
        case 192: 
          { return(stem(4,""oose"",""s""));
          }
        case 573: break;
        case 193: 
          { return(stem(3,""x"",""s""));
          }
        case 574: break;
        case 194: 
          { return(stem(3,""fe"",""s""));
          }
        case 575: break;
        case 195: 
          { return(stem(1,""s"",""s""));
          }
        case 576: break;
        case 196: 
          { return(stem(2,""num"",""s""));
          }
        case 577: break;
        case 197: 
          { return(stem(2,""ny"",""s""));
          }
        case 578: break;
        case 198: 
          { return(stem(2,""po"",""s""));
          }
        case 579: break;
        case 199: 
          { return(stem(4,""ooth"",""s""));
          }
        case 580: break;
        case 200: 
          { return(stem(2,""uum"",""s""));
          }
        case 581: break;
        case 201: 
          { return(stem(3,""f"",""s""));
          }
        case 582: break;
        case 202: 
          { return(stem(2,""b"",""s""));
          }
        case 583: break;
        case 203: 
          { return(stem(5,""eyrir"",""s""));
          }
        case 584: break;
        case 204: 
          // lookahead expression with fixed lookahead length
          yypushback(4);
          { yybegin(noun); yypushback(yylength()); return(next());
          }
        case 585: break;
        case 205: 
          // lookahead expression with fixed lookahead length
          yypushback(4);
          { return(proper_name_stem());
          }
        case 586: break;
        case 206: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 2;
          { return(stem(2,""can"",""""));
          }
        case 587: break;
        case 207: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 3;
          { return(stem(3,""she"",""""));
          }
        case 588: break;
        case 208: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 3;
          { return(stem(3,""he"",""""));
          }
        case 589: break;
        case 209: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 3;
          { return(stem(2,""e"",""""));
          }
        case 590: break;
        case 210: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 2;
          { return(stem(2,""will"",""""));
          }
        case 591: break;
        case 211: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 1;
          { return(stem(1,""be"",""s""));
          }
        case 592: break;
        case 212: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 3;
          { return(stem(3,""we"",""""));
          }
        case 593: break;
        case 213: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 2;
          { return(stem(2,""be"",""""));
          }
        case 594: break;
        case 214: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 2;
          { return(stem(2,""have"",""""));
          }
        case 595: break;
        case 215: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 2;
          { return(stem(2,""would"",""""));
          }
        case 596: break;
        case 216: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 2;
          { return(stem(2,""have"",""ed""));
          }
        case 597: break;
        case 217: 
          { return(stem(4,"""",""ing""));
          }
        case 598: break;
        case 218: 
          { return(condub_stem(2,"""",""ed""));
          }
        case 599: break;
        case 219: 
          { return(stem(6,""clepe"",""ed""));
          }
        case 600: break;
        case 220: 
          { return(stem(3,"""",""s""));
          }
        case 601: break;
        case 221: 
          { return(stem(3,""ass"",""ed""));
          }
        case 602: break;
        case 222: 
          { return(stem(4,""eak"",""en""));
          }
        case 603: break;
        case 223: 
          { return(stem(2,"""",""en""));
          }
        case 604: break;
        case 224: 
          { return(stem(3,"""",""en""));
          }
        case 605: break;
        case 225: 
          { return(stem(3,""e"",""en""));
          }
        case 606: break;
        case 226: 
          { return(stem(4,""te"",""ing""));
          }
        case 607: break;
        case 227: 
          { return(stem(5,""uy"",""ed""));
          }
        case 608: break;
        case 228: 
          { return(stem(3,""ose"",""en""));
          }
        case 609: break;
        case 229: 
          { return(stem(4,""tch"",""ed""));
          }
        case 610: break;
        case 230: 
          { return(stem(3,""am"",""ed""));
          }
        case 611: break;
        case 231: 
          { return(stem(4,""w"",""ed""));
          }
        case 612: break;
        case 232: 
          { return(stem(4,""eeze"",""en""));
          }
        case 613: break;
        case 233: 
          { return(stem(5,""ight"",""ed""));
          }
        case 614: break;
        case 234: 
          { return(stem(3,""l"",""en""));
          }
        case 615: break;
        case 235: 
          { return(semi_reg_stem(1,""""));
          }
        case 616: break;
        case 236: 
          { return(stem(5,""et"",""en""));
          }
        case 617: break;
        case 237: 
          { return(stem(3,""ey"",""ed""));
          }
        case 618: break;
        case 238: 
          { return(stem(5,""elt"",""en""));
          }
        case 619: break;
        case 239: 
          { return(stem(3,""ue"",""ed""));
          }
        case 620: break;
        case 240: 
          { return(stem(3,""ce"",""ed""));
          }
        case 621: break;
        case 241: 
          { return(stem(5,""ink"",""en""));
          }
        case 622: break;
        case 242: 
          { return(stem(3,""il"",""ed""));
          }
        case 623: break;
        case 243: 
          { return(stem(3,""ike"",""ed""));
          }
        case 624: break;
        case 244: 
          { return(stem(4,""eal"",""en""));
          }
        case 625: break;
        case 245: 
          { return(stem(3,""ge"",""ed""));
          }
        case 626: break;
        case 246: 
          { return(stem(5,""eek"",""ed""));
          }
        case 627: break;
        case 247: 
          { return(stem(5,""each"",""ed""));
          }
        case 628: break;
        case 248: 
          { return(stem(3,""a"",""ed""));
          }
        case 629: break;
        case 249: 
          { return(stem(2,""ie"",""ed""));
          }
        case 630: break;
        case 250: 
          { return(stem(4,""e"",""ing""));
          }
        case 631: break;
        case 251: 
          { return(stem(2,""ron"",""s""));
          }
        case 632: break;
        case 252: 
          { return(stem(1,""i"",""s""));
          }
        case 633: break;
        case 253: 
          { return(stem(3,""denum"",""s""));
          }
        case 634: break;
        case 254: 
          { return(stem(3,""ur"",""s""));
          }
        case 635: break;
        case 255: 
          { return(stem(3,""us"",""s""));
          }
        case 636: break;
        case 256: 
          { return(stem(2,""re"",""s""));
          }
        case 637: break;
        case 257: 
          { return(stem(2,""ia"",""s""));
          }
        case 638: break;
        case 258: 
          { return(stem(2,""mum"",""s""));
          }
        case 639: break;
        case 259: 
          { return(stem(3,""ey"",""s""));
          }
        case 640: break;
        case 260: 
          { return(stem(6,""m.p."",""s""));
          }
        case 641: break;
        case 261: 
          { return(stem(4,""ex"",""s""));
          }
        case 642: break;
        case 262: 
          { return(stem(3,""s"",""s""));
          }
        case 643: break;
        case 263: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 4;
          { return(stem(1,"""",""""));
          }
        case 644: break;
        case 264: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 3;
          { return(stem(3,""not"",""""));
          }
        case 645: break;
        case 265: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 3;
          { return(stem(3,""shall"",""""));
          }
        case 646: break;
        case 266: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 4;
          { return(stem(1,""y"",""""));
          }
        case 647: break;
        case 267: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 2;
          { return(stem(2,""be"",""s""));
          }
        case 648: break;
        case 268: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 3;
          { return(stem(3,""will"",""""));
          }
        case 649: break;
        case 269: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 2;
          { return(stem(2,""as"",""""));
          }
        case 650: break;
        case 270: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 2;
          { return(stem(2,""do"",""s""));
          }
        case 651: break;
        case 271: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 2;
          { return(stem(2,""have"",""s""));
          }
        case 652: break;
        case 272: 
          { return(condub_stem(3,"""",""ing""));
          }
        case 653: break;
        case 273: 
          { return(stem(7,""clepe"",""ed""));
          }
        case 654: break;
        case 274: 
          { return(stem(5,""ing"",""ed""));
          }
        case 655: break;
        case 275: 
          { return(stem(4,""ame"",""ed""));
          }
        case 656: break;
        case 276: 
          { return(stem(3,""ride"",""ed""));
          }
        case 657: break;
        case 277: 
          { return(stem(3,""ie"",""ed""));
          }
        case 658: break;
        case 278: 
          { return(stem(5,""ivy"",""ed""));
          }
        case 659: break;
        case 279: 
          { return(stem(5,""ivy"",""s""));
          }
        case 660: break;
        case 280: 
          { return(stem(3,""se"",""ed""));
          }
        case 661: break;
        case 281: 
          { return(stem(2,""ee"",""ed""));
          }
        case 662: break;
        case 282: 
          { return(stem(4,""-up"",""s""));
          }
        case 663: break;
        case 283: 
          { return(stem(2,""gue"",""s""));
          }
        case 664: break;
        case 284: 
          { return(stem(4,""ue"",""ing""));
          }
        case 665: break;
        case 285: 
          { return(stem(5,""ell"",""en""));
          }
        case 666: break;
        case 286: 
          { return(stem(5,""ink"",""ed""));
          }
        case 667: break;
        case 287: 
          { return(stem(4,""k"",""ed""));
          }
        case 668: break;
        case 288: 
          { return(stem(5,""ead"",""en""));
          }
        case 669: break;
        case 289: 
          { return(stem(3,""mel"",""s""));
          }
        case 670: break;
        case 290: 
          { return(stem(4,""ge"",""ing""));
          }
        case 671: break;
        case 291: 
          { return(stem(4,""i"",""ing""));
          }
        case 672: break;
        case 292: 
          { return(stem(4,""a"",""ing""));
          }
        case 673: break;
        case 293: 
          { return(stem(6,""ork"",""ed""));
          }
        case 674: break;
        case 294: 
          { return(stem(5,""y"",""ed""));
          }
        case 675: break;
        case 295: 
          { return(stem(2,""no"",""s""));
          }
        case 676: break;
        case 296: 
          { return(stem(1,""x"",""s""));
          }
        case 677: break;
        case 297: 
          { return(stem(4,""yatid"",""s""));
          }
        case 678: break;
        case 298: 
          { return(stem(4,""sbok"",""s""));
          }
        case 679: break;
        case 299: 
          { return(stem(1,""o"",""s""));
          }
        case 680: break;
        case 300: 
          { return(stem(2,""ro"",""s""));
          }
        case 681: break;
        case 301: 
          { return(stem(2,""la"",""s""));
          }
        case 682: break;
        case 302: 
          { return(stem(2,""dum"",""s""));
          }
        case 683: break;
        case 303: 
          { return(stem(4,""belly"",""s""));
          }
        case 684: break;
        case 304: 
          { return(stem(2,""zo"",""s""));
          }
        case 685: break;
        case 305: 
          { return(stem(3,""en"",""s""));
          }
        case 686: break;
        case 306: 
          { return(stem(1,""a"",""s""));
          }
        case 687: break;
        case 307: 
          { return(stem(3,""ly"",""s""));
          }
        case 688: break;
        case 308: 
          { return(stem(2,""lio"",""s""));
          }
        case 689: break;
        case 309: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 5;
          { return(stem(2,""y"",""""));
          }
        case 690: break;
        case 310: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 4;
          { return(stem(4,""will"",""""));
          }
        case 691: break;
        case 311: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 3;
          { return(stem(3,""be"",""ed""));
          }
        case 692: break;
        case 312: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 3;
          { return(stem(3,""be"",""""));
          }
        case 693: break;
        case 313: 
          { return(stem(4,""g"",""ing""));
          }
        case 694: break;
        case 314: 
          { return(stem(3,""d"",""en""));
          }
        case 695: break;
        case 315: 
          { return(stem(5,""eech"",""ed""));
          }
        case 696: break;
        case 316: 
          { return(stem(4,""y"",""s""));
          }
        case 697: break;
        case 317: 
          { return(stem(6,""ivy"",""ing""));
          }
        case 698: break;
        case 318: 
          { return(stem(4,""y"",""ed""));
          }
        case 699: break;
        case 319: 
          { return(stem(5,""ify"",""ed""));
          }
        case 700: break;
        case 320: 
          { return(stem(5,""ify"",""s""));
          }
        case 701: break;
        case 321: 
          { return(semi_reg_stem(0,""ue""));
          }
        case 702: break;
        case 322: 
          { return(stem(5,""k"",""ing""));
          }
        case 703: break;
        case 323: 
          { return(stem(3,""ship"",""ed""));
          }
        case 704: break;
        case 324: 
          { return(stem(2,""ion"",""s""));
          }
        case 705: break;
        case 325: 
          { return(stem(2,""ne"",""s""));
          }
        case 706: break;
        case 326: 
          { return(stem(2,""cio"",""s""));
          }
        case 707: break;
        case 327: 
          { return(stem(3,""esis"",""s""));
          }
        case 708: break;
        case 328: 
          { return(stem(4,""eps"",""s""));
          }
        case 709: break;
        case 329: 
          { return(stem(2,""eum"",""s""));
          }
        case 710: break;
        case 330: 
          { return(stem(2,""g"",""s""));
          }
        case 711: break;
        case 331: 
          { return(stem(4,""isee"",""s""));
          }
        case 712: break;
        case 332: 
          { return(stem(2,""oan"",""s""));
          }
        case 713: break;
        case 333: 
          { return(stem(2,""ton"",""s""));
          }
        case 714: break;
        case 334: 
          { return(stem(4,""s"",""s""));
          }
        case 715: break;
        case 335: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 4;
          { return(stem(4,""be"",""ed""));
          }
        case 716: break;
        case 336: 
          { return(stem(4,""l"",""ing""));
          }
        case 717: break;
        case 337: 
          { return(stem(6,""-down"",""s""));
          }
        case 718: break;
        case 338: 
          { return(stem(5,""y"",""ing""));
          }
        case 719: break;
        case 339: 
          { return(stem(6,""-up"",""ed""));
          }
        case 720: break;
        case 340: 
          { return(stem(6,""ify"",""ing""));
          }
        case 721: break;
        case 341: 
          { return(stem(4,""y"",""ing""));
          }
        case 722: break;
        case 342: 
          { return(stem(3,""ix"",""ed""));
          }
        case 723: break;
        case 343: 
          { return(stem(2,""do"",""s""));
          }
        case 724: break;
        case 344: 
          { return(stem(1,""de"",""s""));
          }
        case 725: break;
        case 345: 
          { return(stem(4,""-in"",""s""));
          }
        case 726: break;
        case 346: 
          { return(stem(8,""onsieur"",""s""));
          }
        case 727: break;
        case 347: 
          { return(stem(2,""non"",""s""));
          }
        case 728: break;
        case 348: 
          { return(stem(4,""ese"",""s""));
          }
        case 729: break;
        case 349: 
          { return(stem(2,""le"",""s""));
          }
        case 730: break;
        case 350: 
          { return(stem(2,""r"",""s""));
          }
        case 731: break;
        case 351: 
          { return(stem(4,""us"",""s""));
          }
        case 732: break;
        case 352: 
          { return(stem(7,""-up"",""ing""));
          }
        case 733: break;
        case 353: 
          { return(stem(2,""te"",""s""));
          }
        case 734: break;
        case 354: 
          { return(stem(3,""ff"",""s""));
          }
        case 735: break;
        case 355: 
          { return(stem(4,""-on"",""s""));
          }
        case 736: break;
        case 356: 
          { return(stem(9,""an-of-war"",""s""));
          }
        case 737: break;
        case 357: 
          { return(stem(4,""-by"",""s""));
          }
        case 738: break;
        case 358: 
          { return(stem(4,""o"",""s""));
          }
        case 739: break;
        case 359: 
          { return(stem(8,""-down"",""ed""));
          }
        case 740: break;
        case 360: 
          { return(stem(2,""l"",""s""));
          }
        case 741: break;
        case 361: 
          { return(stem(8,""-de-sac"",""s""));
          }
        case 742: break;
        case 362: 
          { return(stem(6,""-over"",""s""));
          }
        case 743: break;
        case 363: 
          { return(stem(10,""anservant"",""s""));
          }
        case 744: break;
        case 364: 
          { return(stem(10,""an-at-arms"",""s""));
          }
        case 745: break;
        case 365: 
          { return(stem(3,""is"",""s""));
          }
        case 746: break;
        case 366: 
          { return(stem(8,""-in-law"",""s""));
          }
        case 747: break;
        case 367: 
          { return(stem(6,""-lit"",""s""));
          }
        case 748: break;
        case 368: 
          { return(stem(2,""t"",""s""));
          }
        case 749: break;
        case 369: 
          { return(stem(9,""-down"",""ing""));
          }
        case 750: break;
        case 370: 
          { return(stem(6,""-doux"",""s""));
          }
        case 751: break;
        case 371: 
          { return(stem(8,""-de-lys"",""s""));
          }
        case 752: break;
        case 372: 
          { return(stem(8,""-de-lis"",""s""));
          }
        case 753: break;
        case 373: 
          { return(stem(9,""-a-terre"",""s""));
          }
        case 754: break;
        case 374: 
          { return(stem(9,""-mutuel"",""s""));
          }
        case 755: break;
        case 375: 
          { return(stem(9,""-de-camp"",""s""));
          }
        case 756: break;
        case 376: 
          { return(stem(13,""ademoiselle"",""s""));
          }
        case 757: break;
        case 377: 
          { return(stem(11,""erfamilias"",""s""));
          }
        case 758: break;
        case 378: 
          { return(stem(9,""-at-arms"",""s""));
          }
        case 759: break;
        case 379: 
          { return(stem(12,""-in-the-box"",""s""));
          }
        case 760: break;
        case 380: 
          { return(stem(14,""y-in-waiting"",""s""));
          }
        case 761: break;
        case 381: 
          { return(stem(11,""y-general"",""s""));
          }
        case 762: break;
        default: 
          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
            zzAtEOF = true;
              {
                return null;
              }
          } 
          else {
            zzScanError(ZZ_NO_MATCH);
          }
      }
    }
  }
"	@return the next token	@return the next token	0	1	17	1682	10726
@ApiModelProperty(value = STR) public String getType() { return type; }	"@ApiModelProperty(value = STR)
public TypeEnum getType() {
    return type;
}"	@return String type	@return TypeEnum type	1	0	5	4	16
"public String toString() { if (isEmpty(hostIp)) { return hostPortSpec; } else if (hostPortSpec == null) { return hostIp; } else { return hostIp + "":"" + hostPortSpec; } }"	"        public String toString() {
            if (isEmpty(hostIp)) {
                return hostPort;
            } else if (hostPort == null) {
                return hostIp;
            } else {
                return hostIp + "":"" + hostPort;
            }
        }
"	@return a string representation of this  Binding	@return a string representation of this Binding	0	1	9	10	42
private ComponentAdapter prepRES_lifecycleManagerHonorsInstantiationSequence(MutablePicoContainer picoContainer) { picoContainer.addComponent(RecordingLifecycle.One.class); PoolingComponentAdapter poolingComponentAdapter = new PoolingComponentAdapter(new ConstructorInjectionComponentAdapter(RecordingLifecycle.Recorder.class, RecordingLifecycle.Two.class)); return picoContainer.addAdapter(poolingComponentAdapter).lastCA(); }	"private ComponentAdapter prepRES_lifecycleManagerHonorsInstantiationSequence(MutablePicoContainer picoContainer) {
    picoContainer.component(RecordingLifecycle.One.class);
    PoolingComponentAdapter poolingComponentAdapter = new PoolingComponentAdapter(new ConstructorInjectionComponentAdapter(RecordingLifecycle.Recorder.class, RecordingLifecycle.Two.class));
    return picoContainer.adapter(poolingComponentAdapter).lastCA();
}"	@return the addAdapter to test	@return the adapter to test	1	0	8	5	45
@Processor public String login(String username, String password) { return config.getClient().login(username, password); }	"@Processor
@InvalidateConnectionOn(exception = JiraConnectorException.class)
public String login(String username, String password) {
    return client.login(username, password);
}"	@return the authentication config.getToken()	@return the authentication token	1	0	6	4	26
private static Optional<List<CoreLabel>> getValidEntityChunk(SemanticGraph parse, IndexedWord root, Optional<String> noopArc) { return getValidChunk(parse, root, VALID_ENTITY_ARCS, noopArc); }	"  private static Optional<List<CoreLabel>> getValidEntityChunk(SemanticGraph parse, IndexedWord root) {
    return getValidChunk(parse, root, VALID_ENTITY_ARCS);
  }
"	@return If this subtree is a valid entity, we return its yield. Otherwise, we return empty.	@return If this subtree is a valid entity, we return its yield. Otherwise, we return empty.	0	1	7	4	31
@Override public Map<String, DatatypeValidator> getBuiltInTypes() { return new HashMap<>(fBuiltInTypes); }	"public Hashtable getBuiltInTypes() {
    return (Hashtable) fBuiltInTypes.clone();
}"	@return a Map which contains all datatypes	@return a hashtable which contains all datatypes	1	0	5	4	19
private AttributeDetails minDequeIterator(AttributeDetails valObject) { if (valueRemoved != null) { for (Iterator<AttributeDetails> iterator = minDeque.descendingIterator(); iterator.hasNext(); ) { AttributeDetails possibleMinValue = iterator.next(); if (possibleMinValue.getValue() > valObject.getValue() || possibleMinValue.getValue() >= valueRemoved.getValue()) { if (possibleMinValue.getValue() > valObject.getValue()) { iterator.remove(); } else if (valueRemoved.equals(possibleMinValue)) { iterator.remove(); } } else { break; } } } else { for (Iterator<AttributeDetails> iterator = minDeque.descendingIterator(); iterator.hasNext(); ) { if (iterator.next().getValue() > valObject.getValue()) { iterator.remove(); } else { break; } } } valObject.setMinThreshold(); minDeque.addLast(valObject); return minDeque.peek(); }	"private attributeDetails minDequeIterator(attributeDetails valObject) {
    if (valueRemoved != null) {
        for (Iterator<attributeDetails> iterator = minDeque.descendingIterator(); iterator.hasNext(); ) {
            double possibleMinValue = iterator.next().getValue();
            if (possibleMinValue > valObject.getValue() || possibleMinValue >= valueRemoved.getValue()) {
                if (possibleMinValue > valObject.getValue()) {
                    iterator.remove();
                } else if (valueRemoved.getValue() == possibleMinValue) {
                    iterator.remove();
                    break;
                }
            } else {
                break;
            }
        }
    } else {
        for (Iterator<attributeDetails> iterator = minDeque.descendingIterator(); iterator.hasNext(); ) {
            if (iterator.next().getValue() > valObject.getValue()) {
                iterator.remove();
            } else {
                break;
            }
        }
    }
    valObject.setMinThreshold();
    minDeque.addLast(valObject);
    return minDeque.peek();
}"	@return minimum value (without checking preBoundChange, postBoundChange conditions)	@return minimum value (without checking d, D conditions)	1	0	13	27	168
"public static Platform fromString(String name) { try { return Platform.valueOf(name); } catch (IllegalArgumentException ex) { for (Platform os : Platform.values()) { for (String matcher : os.partOfOsName) { if (name.toLowerCase().equals(matcher.toLowerCase())) { return os; } } } throw new WebDriverException(""Unrecognized platform: "" + name); } }"	"  public static Platform fromString(String name) {
    for (Platform os : Platform.values()) {
      for (String matcher : os.partOfOsName) {
        if (name.toLowerCase().equals(matcher.toLowerCase())) {
          return os;
        }
      }
    }
    throw new WebDriverException(""Unknown platform: "" + name);
  }
"	@return the Platform enum value matching the parameter	@return the Platform enum value matching the parameter	0	1	12	15	81
public static SecureConnectionMode parse(String value, String defaultValue) { SecureConnectionMode mode = parse(value); if (mode == null && defaultValue != null) { mode = parse(defaultValue); } return mode; }	"        public static TopicSelectionStrategy parse(String value) {
            if (value == null) {
                return null;
            }
            value = value.trim();
            for (TopicSelectionStrategy option : TopicSelectionStrategy.values()) {
                if (option.getValue().equalsIgnoreCase(value)) {
                    return option;
                }
            }
            return null;
        }
"	@return the matching option, or null if no match is found and the non-null default is invalid	@return the matching option, or null if no match is found	1	0	8	8	41
"private int processPartition(final int currentRow) throws DrillException { logger.trace(""{} rows remaining to process, currentRow: {}, outputCount: {}"", remainingRows, currentRow, outputCount); setupWriteFirstValue(internal, container); if (popConfig.isFrameUnitsRows()) { return processROWS(currentRow); } else { return processRANGE(currentRow); } }"	"  private int processPartition(final int currentRow) throws DrillException {
    logger.trace(""process partition {}, currentRow: {}, outputCount: {}"", partition, currentRow, outputCount);

    setupWriteFirstValue(internal, container);

    int row = currentRow;

    // process all rows except the last one of the batch/partition
    while (row < outputCount && !partition.isDone()) {
      processRow(row);

      row++;
    }

    return row;
  }
"	@return index of next unprocessed row	@return index of next unprocessed row	0	1	7	12	72
private Connection handleRedirect(IBasicRequest oldRequest, Headers responseHeaders) { IBasicRequest redirectRequest = null; RedirectHandler redirectHandler = oldRequest.getRedirectHandler(); if (redirectHandler != null) { if (redirectHandler.isDisallowedRedirect(responseHeaders)) return new Connection(null, responseHeaders, null, null); else redirectRequest = redirectHandler.onRedirect(responseHeaders); } if (redirectRequest == null) { redirectRequest = new StringRequest(responseHeaders.getLocation(), oldRequest.getRequestMethod()); redirectRequest.setSSLSocketFactory(oldRequest.getSSLSocketFactory()); redirectRequest.setHostnameVerifier(oldRequest.getHostnameVerifier()); redirectRequest.setProxy(oldRequest.getProxy()); } return getConnection(redirectRequest); }	"private ConnectionResult handleRedirect(IBasicRequest oldRequest, Headers responseHeaders) {
    IBasicRequest redirectRequest = null;
    RedirectHandler redirectHandler = oldRequest.getRedirectHandler();
    if (redirectHandler != null) {
        if (redirectHandler.isDisallowedRedirect(responseHeaders))
            return new ConnectionResult(null, responseHeaders, null, null);
        else
            redirectRequest = redirectHandler.onRedirect(responseHeaders);
    }
    if (redirectRequest == null) {
        redirectRequest = new StringRequest(responseHeaders.getLocation(), oldRequest.getRequestMethod());
        redirectRequest.setSSLSocketFactory(oldRequest.getSSLSocketFactory());
        redirectRequest.setHostnameVerifier(oldRequest.getHostnameVerifier());
        redirectRequest.setProxy(oldRequest.getProxy());
    }
    return getConnection(redirectRequest);
}"	@return {@link Connection}.	@return {@link ProtocolResult}.	1	0	9	17	115
public SimpleConfiguration getReporterConfiguration(String reporter) { return subset(REPORTER_PREFIX + STR + reporter); }	"public Configuration getReporterConfiguration(String reporter) {
    return subset(REPORTER_PREFIX + STR + reporter);
}"	@return A subset of this configuration using the prefix {@value #REPORTER_PREFIX} with the reporter parameter appended. Any change made to subset will be reflected in this configuration, but with the prefix added.	@return A {@link SubsetConfiguration} using the prefix {@value #REPORTER_PREFIX} with the reporter parameter appended. Any change made to subset will be reflected in this configuration, but with the prefix added.	1	0	7	3	19
public CacheManager getCacheFactory() { return jbcFactory; }	"	public JBossCacheFactory getCacheFactory() {
        return jbcFactory;
    }
"	@return Value for property 'cacheFactory'.	@return Value for property 'cacheFactory'.	0	1	4	4	10
public IStatus doit() { return Status.OK_STATUS; }	"public boolean doit() {
    return false;
}"	@return Status.OK_STATUS if it is successful.	@return true if it is successful.	1	0	4	3	11
public IncomparableBuilder<T> withField(final Function<T, Object> field) { return new IncomparableBuilder<>(expectedType, fields).withField(field); }	"public IncomparableBuilder<T> withField(final Function<T, Object> field) {
    return new IncomparableBuilder<>(expectedType, field);
}"	@return A builder which will support {@linkplain Object#equals(Object) equals} &amp; {@linkplain Object#hashCode() hashCode} but not support {@linkplain Comparable#compareTo(Object) compareTo}.	@return A builder which will support {@linkplain Object#equals(Object) equals} & {@linkplain Object#hashCode() hashCode} but not support {@linkplain Comparable#compareTo(Object) compareTo}.	1	0	6	3	27
public static Function<String, Integer> osBits() { return new Function<String, Integer>() { @Override public Integer apply(String description) { if (description != null) { Matcher m = OS_BITS_PATTERN.matcher(description); if (m.matches()) { return Integer.parseInt(m.group(NUM)); } } return null; } }; }	"public static Function<ProductItem, Integer> osBits() {
    return new Function<ProductItem, Integer>() {

        @Override
        public Integer apply(ProductItem productItem) {
            checkNotNull(productItem, STR);
            Matcher m = OS_BITS_PATTERN.matcher(productItem.getDescription());
            if (m.matches()) {
                return Integer.parseInt(m.group(NUM));
            } else {
                throw new NoSuchElementException(STR + productItem);
            }
        }
    };
}"	@return the number of bits or null if the number of bits cannot be determined	@return the number of bits	1	0	13	15	72
public User getUserByName(String username) throws ApiException { ApiResponse<User> localVarResp = getUserByNameWithHttpInfo(username); return localVarResp.getData(); }	"    public User getUserByName(String username) throws ApiException {
        ApiResponse<User> resp = getUserByNameWithHttpInfo(username);
        return resp.getData();
    }
"	@return User	@return User	0	1	6	5	25
public ChromeDriverService build() { return (ChromeDriverService) super.build(); }	"    public ChromeDriverService build() {
      if (port == 0) {
        port = PortProber.findFreePort();
      }

      checkState(exe != null, ""Path to the chromedriver executable not specified"");

      try {
        return new ChromeDriverService(exe, port, environment, logFile);
      } catch (IOException e) {
        throw new WebDriverException(e);
      }
    }
"	@return The new binary.	@return The new binary.	0	1	5	4	16
public String getInitParameter(String name) { try { String value = framework.getServletConfig().getInitParameter(name); if (value == null && useServletContextParameters) { value = framework.getServletContext().getInitParameter(name); } return value; } catch (Throwable ex) { return null; } }	"public String getInitParameter(String name) {
    try {
        return framework.getServletConfig().getInitParameter(name);
    } catch (Throwable ex) {
        return null;
    }
}"	@return the value for the init parameter if defined	@return the list of init params defined in web.xml or application.xml	1	0	10	11	56
"public IntegrationFlow tfrErrors() { return IntegrationFlows.from(tfrErrorChannel()) .enrichHeaders(Mail.headers() .subject(""File split and transfer failed"") .from(""foo@bar"") .toFunction(m -> new String[] {""bar@baz""})) .enrichHeaders(h -> h.header(EMAIL_SUCCESS_SUFFIX, "".failed"") .headerExpression(FileHeaders.ORIGINAL_FILE, ""payload.failedMessage.headers['"" + FileHeaders.ORIGINAL_FILE + ""']"")) .<MessagingException, String>transform(p -> p.getFailedMessage().getPayload().toString() + ""\n"" + getStackTraceAsString(p)) .channel(""toMail.input"") .get(); }"	"	public IntegrationFlow tfrErrors() {
		return f -> f.enrichHeaders(Mail.headers()
					.subject(""File split and transfer failed"")
					.from(""foo@bar"")
					.toFunction(m -> new String[] {""bar@baz""}))
				.enrichHeaders(h -> h.header(EMAIL_SUCCESS_SUFFIX, "".failed"")
						.headerExpression(FileHeaders.ORIGINAL_FILE, ""payload.failedMessage.headers['""
								+ FileHeaders.ORIGINAL_FILE + ""']""))
				.<MessagingException, String>transform(p ->
						p.getFailedMessage().getPayload().toString() + ""\n"" + getStackTraceAsString(p))
				.channel(""toMail.input"");
	}
"	@return the flow.	@return the flow.	0	1	11	15	130
@Deprecated public String getBodyContents() { return getStringPayload(); }	"public String getBodyContents() {
    try {
        return new String(getByteBodyContents(), getCharset());
    } catch (UnsupportedEncodingException uee) {
        throw new OAuthException(STR + charset, uee);
    }
}"	@return value set in {@link #setPayload(java.lang.String)}	@return form encoded string	1	0	4	4	14
"public Client call123testSpecialTags(Client body) throws ApiException { Object localVarPostBody = body; // verify the required parameter 'body' is set if (body == null) { throw new ApiException(400, ""Missing the required parameter 'body' when calling call123testSpecialTags""); } // create path and map variables String localVarPath = ""/another-fake/dummy"".replaceAll(""\\{format\\}"",""json""); // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, String> localVarCookieParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { ""application/json"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { ""application/json"" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Client> localVarReturnType = new GenericType<Client>() {}; return apiClient.invokeAPI(localVarPath, ""PATCH"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	"  public Client call123testSpecialTags(Client body) throws ApiException {
    Object localVarPostBody = body;
    
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, ""Missing the required parameter 'body' when calling call123testSpecialTags"");
    }
    
    // create path and map variables
    String localVarPath = ""/another-fake/dummy"".replaceAll(""\\{format\\}"",""json"");

    // query params
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();


    
    
    final String[] localVarAccepts = {
      ""application/json""
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      ""application/json""
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    GenericType<Client> localVarReturnType = new GenericType<Client>() {};
    return apiClient.invokeAPI(localVarPath, ""PATCH"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);
      }
"	@return a  Client	@return a Client	0	1	8	37	234
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 25: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 32: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 33: break; case 12: { final String origTxt = yytext(); return getNext(asciiQuotes(origTxt), origTxt); } case 34: break; case 15: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 35: break; case 10: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { String origTxt = yytext(); return getNext(asciiDash(origTxt), origTxt); } } case 36: break; case 1: { String str = yytext(); int first = str.charAt(0); String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } LOGGER.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: LOGGER.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 37: break; case 27: // lookahead expression with fixed lookahead length yypushback(2); { return getNext(); } case 38: break; case 24: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 39: break; case 23: // general lookahead, find correct zzMarkedPos { int zzFState = 1; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 2; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 40: break; case 18: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(); } case 41: break; case 4: { return getNext(); } case 42: break; case 28: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 43: break; case 7: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 44: break; case 9: { return handleEllipsis(yytext()); } case 45: break; case 17: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 46: break; case 2: { if (normalizeOtherBrackets) { return getNext(openparen, yytext()); } else { return getNext(); } } case 47: break; case 30: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } return getNext(txt, yytext()); } case 48: break; case 14: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 49: break; case 11: { return normalizeFractions(yytext()); } case 50: break; case 31: { String txt = yytext(); if (normalizeParentheses) { txt = txt.replaceAll(""\\("", openparen); txt = txt.replaceAll(""\\)"", closeparen); } return getNext(txt, yytext()); } case 51: break; case 26: { return getNormalizedAmpNext(); } case 52: break; case 22: // general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String txt = asciiQuotes(origTxt); return getNext(asciiDash(txt), origTxt); } case 53: break; case 20: { // this one should only match if we're basically at the end of file // since the last one matches two things, even newlines String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 54: break; case 8: { if (invertible) { prevWordAfter.append(yytext()); } } case 55: break; case 29: { yypushback(3) ; return getNext(); } case 56: break; case 3: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 57: break; case 21: { final String origTxt = yytext(); return getNext(asciiDash(origTxt), origTxt); } case 58: break; case 13: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 59: break; case 19: { if (!noSGML) { return getNext(); } } case 60: break; case 6: { if (normalizeOtherBrackets) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 61: break; case 16: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 62: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }"	"  public Object next() throws java.io.IOException {
    int zzInput;
    int zzAction;

    // cached fields:
    int zzCurrentPosL;
    int zzMarkedPosL;
    int zzEndReadL = zzEndRead;
    char [] zzBufferL = zzBuffer;
    char [] zzCMapL = ZZ_CMAP;

    int [] zzTransL = ZZ_TRANS;
    int [] zzRowMapL = ZZ_ROWMAP;
    int [] zzAttrL = ZZ_ATTRIBUTE;

    while (true) {
      zzMarkedPosL = zzMarkedPos;

      yychar+= zzMarkedPosL-zzStartRead;

      zzAction = -1;

      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
  
      zzState = ZZ_LEXSTATE[zzLexicalState];

      // set up zzAction for empty match case:
      int zzAttributes = zzAttrL[zzState];
      if ( (zzAttributes & 1) == 1 ) {
        zzAction = zzState;
      }


      zzForAction: {
        while (true) {
    
          if (zzCurrentPosL < zzEndReadL)
            zzInput = zzBufferL[zzCurrentPosL++];
          else if (zzAtEOF) {
            zzInput = YYEOF;
            break zzForAction;
          }
          else {
            // store back cached positions
            zzCurrentPos  = zzCurrentPosL;
            zzMarkedPos   = zzMarkedPosL;
            boolean eof = zzRefill();
            // get translated positions and possibly new buffer
            zzCurrentPosL  = zzCurrentPos;
            zzMarkedPosL   = zzMarkedPos;
            zzBufferL      = zzBuffer;
            zzEndReadL     = zzEndRead;
            if (eof) {
              zzInput = YYEOF;
              break zzForAction;
            }
            else {
              zzInput = zzBufferL[zzCurrentPosL++];
            }
          }
          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
          if (zzNext == -1) break zzForAction;
          zzState = zzNext;

          zzAttributes = zzAttrL[zzState];
          if ( (zzAttributes & 1) == 1 ) {
            zzAction = zzState;
            zzMarkedPosL = zzCurrentPosL;
            if ( (zzAttributes & 8) == 8 ) break zzForAction;
          }

        }
      }

      // store back cached position
      zzMarkedPos = zzMarkedPosL;

      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
        case 1: 
          { String str = yytext();
          int first = str.charAt(0);
          String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));
          switch (untokenizable) {
            case NONE_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              break;
            case FIRST_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              if ( ! this.seenUntokenizableCharacter) {
                LOGGER.warning(msg);
                this.seenUntokenizableCharacter = true;
              }
              break;
            case ALL_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              LOGGER.warning(msg);
              this.seenUntokenizableCharacter = true;
              break;
            case NONE_KEEP:
              return getNext();
            case FIRST_KEEP:
              if ( ! this.seenUntokenizableCharacter) {
                LOGGER.warning(msg);
                this.seenUntokenizableCharacter = true;
              }
              return getNext();
            case ALL_KEEP:
              LOGGER.warning(msg);
              this.seenUntokenizableCharacter = true;
              return getNext();
          }
          }
        case 33: break;
        case 2: 
          { if (normalizeOtherBrackets) {
                    return getNext(openparen, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 34: break;
        case 3: 
          { if (escapeForwardSlashAsterisk) {
                    return getNext(delimit(yytext(), '/'), yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 35: break;
        case 4: 
          { return getNext();
          }
        case 36: break;
        case 5: 
          { if (tokenizeNLs) {
                      return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns
                  } else if (invertible) {
                      prevWordAfter.append(yytext());
                  }
          }
        case 37: break;
        case 6: 
          { if (normalizeOtherBrackets) {
                    return getNext(closeparen, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 38: break;
        case 7: 
          { if (ptb3Dashes) {
                            return getNext(ptbmdash, yytext()); }
                          else {
                            return getNext();
                          }
          }
        case 39: break;
        case 8: 
          { if (invertible) {
                     prevWordAfter.append(yytext());
                  }
          }
        case 40: break;
        case 9: 
          { return handleEllipsis(yytext());
          }
        case 41: break;
        case 10: 
          { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {
	            return getNext(ptbmdash, yytext());
                  } else {
		    String origTxt = yytext();
                    return getNext(asciiDash(origTxt), origTxt);
		  }
          }
        case 42: break;
        case 11: 
          { return normalizeFractions(yytext());
          }
        case 43: break;
        case 12: 
          { final String origTxt = yytext();
                          return getNext(asciiQuotes(origTxt), origTxt);
          }
        case 44: break;
        case 13: 
          { if (normalizeOtherBrackets) {
                    return getNext(closebrace, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 45: break;
        case 14: 
          { if (normalizeParentheses) {
                    return getNext(openparen, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 46: break;
        case 15: 
          { if (normalizeParentheses) {
                    return getNext(closeparen, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 47: break;
        case 16: 
          { if (escapeForwardSlashAsterisk) {
                    return getNext(delimit(yytext(), '*'), yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 48: break;
        case 17: 
          { if (normalizeOtherBrackets) {
                    return getNext(openbrace, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 49: break;
        case 18: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return getNext();
          }
        case 50: break;
        case 19: 
          { if (!noSGML) {
                            return getNext();
			  }
          }
        case 51: break;
        case 20: 
          { // this one should only match if we're basically at the end of file
			  // since the last one matches two things, even newlines
                          String s;
                          if (strictTreebank3 && ! ""U.S."".equals(yytext())) {
                            yypushback(1); // return a period for next time
                            s = yytext();
                          } else {
                            s = yytext();
                            yypushback(1); // return a period for next time
                          }
	                  return getNext(s, yytext());
          }
        case 52: break;
        case 21: 
          { final String origTxt = yytext();
                          return getNext(asciiDash(origTxt), origTxt, COMPOUND_ANNOTATION);
          }
        case 53: break;
        case 22: 
          { final String origTxt = yytext();
                          return getNext(asciiDash(origTxt), origTxt);
          }
        case 54: break;
        case 23: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 3;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
            while (zzFPos <= zzMarkedPos) {
              zzFinL[zzFPos++] = false;
            }

            zzFState = 4;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { final String origTxt = yytext();
                          String txt = asciiQuotes(origTxt);
                          return getNext(asciiDash(txt), origTxt);
          }
        case 55: break;
        case 24: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 1;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
            while (zzFPos <= zzMarkedPos) {
              zzFinL[zzFPos++] = false;
            }

            zzFState = 2;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { return getNext();
          }
        case 56: break;
        case 25: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 7;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
            while (zzFPos <= zzMarkedPos) {
              zzFinL[zzFPos++] = false;
            }

            zzFState = 8;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { return getNext();
          }
        case 57: break;
        case 26: 
          { String txt = yytext();
                          if (escapeForwardSlashAsterisk) {
                            txt = delimit(txt, '/');
                            txt = delimit(txt, '*');
                          }
                          return getNext(txt, yytext());
          }
        case 58: break;
        case 27: 
          { return getNormalizedAmpNext();
          }
        case 59: break;
        case 28: 
          // lookahead expression with fixed lookahead length
          yypushback(2);
          { return getNext();
          }
        case 60: break;
        case 29: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 5;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
            while (zzFPos <= zzMarkedPos) {
              zzFinL[zzFPos++] = false;
            }

            zzFState = 6;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { String s;
                          if (strictTreebank3 && ! ""U.S."".equals(yytext())) {
                            yypushback(1); // return a period for next time
                            s = yytext();
                          } else {
                            s = yytext();
                            yypushback(1); // return a period for next time
                          }
	                  return getNext(s, yytext());
          }
        case 61: break;
        case 30: 
          { yypushback(3) ; return getNext();
          }
        case 62: break;
        case 31: 
          { String txt = yytext();
                          if (escapeForwardSlashAsterisk) {
                            txt = delimit(txt, '/');
                          }
                          return getNext(txt, yytext());
          }
        case 63: break;
        case 32: 
          { String txt = yytext();
			  if (normalizeParentheses) {
			    txt = txt.replaceAll(""\\("", openparen);
			    txt = txt.replaceAll(""\\)"", closeparen);
			  }
			  return getNext(txt, yytext());
          }
        case 64: break;
        default: 
          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
            zzAtEOF = true;
              {
                if (invertible) {
            prevWordAfter.append(yytext());
            String str = prevWordAfter.toString();
            prevWordAfter.setLength(0);
            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);
          }
          return null;
              }
          } 
          else {
            zzScanError(ZZ_NO_MATCH);
          }
      }
    }
  }
"	@return the next token	@return the next token	0	1	17	422	2344
public static int getKeyLength(AsymmetricKeyParameter keyParams) { if (keyParams instanceof RSAKeyParameters) { return ((RSAKeyParameters) keyParams).getModulus().bitLength(); } else if (keyParams instanceof DSAKeyParameters) { return ((DSAKeyParameters) keyParams).getParameters().getP().bitLength(); } else if (keyParams instanceof DHKeyParameters) { return ((DHKeyParameters) keyParams).getParameters().getP().bitLength(); } else if (keyParams instanceof ECKeyParameters) { return UNKNOWN_KEY_SIZE; } LOG.warning(STR + keyParams); return UNKNOWN_KEY_SIZE; }	"public static int getKeyLength(AsymmetricKeyParameter keyParams) throws CryptoException {
    if (keyParams instanceof RSAKeyParameters) {
        return ((RSAKeyParameters) keyParams).getModulus().bitLength();
    } else if (keyParams instanceof DSAKeyParameters) {
        return ((DSAKeyParameters) keyParams).getParameters().getP().bitLength();
    } else if (keyParams instanceof DHKeyParameters) {
        return ((DHKeyParameters) keyParams).getParameters().getP().bitLength();
    } else {
        throw new CryptoException(RB.getString(STR));
    }
}"	@return The key size, {@link #UNKNOWN_KEY_SIZE} if not known	@return The key size	1	0	9	13	107
"private MessageBatcher getBatcher(final String serviceUrl, String pBatcherName) { String batcherName = null; try { batcherName = new URL(serviceUrl).getHost(); } catch (MalformedURLException e1) { batcherName = serviceUrl; } String absoluteBatcherName = batcherName + ""-"" + pBatcherName; ConfigurationManager.getConfigInstance().setProperty( ""batcher."" + absoluteBatcherName + "".queue.maxMessages"", config.getMaxElementsInPeerReplicationPool()); ConfigurationManager.getConfigInstance().setProperty( ""batcher."" + absoluteBatcherName + "".batch.maxMessages"", 250); ConfigurationManager.getConfigInstance().setProperty( ""batcher."" + absoluteBatcherName + "".keepAliveTime"", config.getMaxIdleThreadAgeInMinutesForPeerReplication() * 60); ConfigurationManager.getConfigInstance().setProperty( ""batcher."" + absoluteBatcherName + "".maxThreads"", config.getMaxThreadsForPeerReplication()); return BatcherFactory.createBatcher(absoluteBatcherName, new MessageProcessor<ReplicationTask>() { private String BATCH_URL_PATH = ""peerreplication/batch/"";; @Override public void process(List<ReplicationTask> tasks) { if (!tasks.get(0).isBatchingSupported()) { executeSingle(tasks); } else if (!executeBatch(tasks)) { executeSingle(tasks); } } private boolean executeBatch(List<ReplicationTask> tasks) { boolean success = true; boolean done = true; PeerEurekaNode.ReplicationList list = new PeerEurekaNode.ReplicationList(); for (ReplicationTask task : tasks) { if (System.currentTimeMillis() - config.getMaxTimeForReplication() > task .getSubmitTime()) { Object[] args = { task.getAppName(), task.getId(), task.getAction(), new Date(System.currentTimeMillis()), new Date(task.getSubmitTime()) }; logger.warn( ""Replication events older than the threshold. AppName : {}, Id: {}, Action : {}, Current Time : {}, Submit Time :{}"", args); continue; } PeerEurekaNode.ReplicationInstance instance = new PeerEurekaNode.ReplicationInstance(); instance.setAppName(task.getAppName()); instance.setId(task.getId()); InstanceInfo instanceInfo = task.getInstanceInfo(); if (instanceInfo != null) { String overriddenStatus = (task .getOverriddenStatus() == null ? null : task.getOverriddenStatus().name()); instance.setOverriddenStatus(overriddenStatus); instance.setLastDirtyTimestamp(instanceInfo .getLastDirtyTimestamp()); if (task.shouldReplicateInstanceInfo()) { instance.setInstanceInfo(instanceInfo); } String instanceStatus = instanceInfo .getStatus() == null ? null : instanceInfo.getStatus().name(); instance.setStatus(instanceStatus); } instance.setAction(task.getAction()); list.addReplicationInstance(instance); } if (list.getList().size() == 0) { return true; } Action action = list.getList().get(0).action; DynamicCounter.increment(""Batch_"" + action + ""_tries""); do { done = true; ClientResponse response = null; try { response = jerseyApacheClient .resource(serviceUrl) .path(BATCH_URL_PATH) .accept(MediaType.APPLICATION_JSON_TYPE) .type(MediaType.APPLICATION_JSON_TYPE) .post(ClientResponse.class, list); if (!isSuccess(response)) { return false; } DynamicCounter.increment(""Batch_"" + action + ""_success""); PeerEurekaNode.ReplicationListResponse batchResponse = response .getEntity(PeerEurekaNode.ReplicationListResponse.class); int ctr = 0; for (PeerEurekaNode.ReplicationInstanceResponse singleResponse : batchResponse .getResponseList()) { int statusCode = singleResponse .getStatusCode(); if ((!isSuccess(response)) || (singleResponse .getResponseEntity() != null)) { if (singleResponse.getResponseEntity() != null) { tasks.get(ctr) .setPeerInstanceInfo( singleResponse .getResponseEntity()); } tasks.get(ctr) .handleFailure(statusCode); } ++ctr; } done = true; } catch (Throwable e) { if ((isNetworkConnectException(e))) { DynamicCounter.increment(""Batch_"" + action + ""_retries""); done = false; } else { success = false; logger.info( ""Not re-trying this exception because it does not seem to be a network exception"", e); } } finally { if (response != null) { response.close(); } } } while (!done); return success; } private boolean isSuccess(ClientResponse response) { return response.getStatus() < 200 || response.getStatus() >= 300; } private void executeSingle(List<ReplicationTask> tasks) { for (ReplicationTask task : tasks) { boolean done = true; do { done = true; try { if (System.currentTimeMillis() - config.getMaxTimeForReplication() > task .getSubmitTime()) { Object[] args = { task.getAppName(), task.getId(), task.getAction(), new Date(System.currentTimeMillis()), new Date(task.getSubmitTime()) }; logger.warn( ""Replication events older than the threshold. AppName : {}, Id: {}, Action : {}, Current Time : {}, Submit Time :{}"", args); continue; } DynamicCounter.increment(""Single_"" + task.getAction().name() + ""_tries""); int statusCode = task.execute(); if (statusCode < 200 && statusCode > 299) { task.handleFailure(statusCode); } DynamicCounter.increment(""Single_"" + task.getAction().name() + ""_success""); } catch (Throwable e) { logger.error( name + task.getAppName() + ""/"" + task.getId() + "":"" + task.getAction(), e); try { Thread.sleep(RETRY_SLEEP_TIME_MS); } catch (InterruptedException e1) { } if ((isNetworkConnectException(e))) { DynamicCounter.increment(task .getAction().name() + ""_retries""); done = false; } else { logger.info( ""Not re-trying this exception because it does not seem to be a network exception"", e); } } } while (!done); } } }); }"	"    private MessageBatcher getBatcher(final String serviceUrl, String pBatcherName) {
        String batcherName = null;
        try {
            batcherName = new URL(serviceUrl).getHost();
        } catch (MalformedURLException e1) {
            batcherName = serviceUrl;
        }
        String absoluteBatcherName = batcherName + ""-"" + pBatcherName;
        ConfigurationManager.getConfigInstance().setProperty(
                ""batcher."" + absoluteBatcherName + "".queue.maxMessages"",
                config.getMaxElementsInPeerReplicationPool());
        ConfigurationManager.getConfigInstance().setProperty(
                ""batcher."" + absoluteBatcherName + "".batch.maxMessages"",
                 250);
        ConfigurationManager.getConfigInstance().setProperty(
                ""batcher."" + absoluteBatcherName + "".keepAliveTime"",
                config.getMaxIdleThreadAgeInMinutesForPeerReplication() * 60);
        ConfigurationManager.getConfigInstance().setProperty(
                ""batcher."" + absoluteBatcherName + "".maxThreads"",
                config.getMaxThreadsForPeerReplication());

        return BatcherFactory.createBatcher(absoluteBatcherName,
                new MessageProcessor<ReplicationTask>() {

            private String BATCH_URL_PATH = ""apps/batch/"";;

            @Override
            public void process(List<ReplicationTask> tasks) {
                if (!tasks.get(0).isBatchingSupported()) {
                    executeSingle(tasks);
                } else if (!executeBatch(tasks)) {
                    executeSingle(tasks);
                }
            }

            private boolean executeBatch(List<ReplicationTask> tasks) {
                boolean success = true;
                boolean done = true;
                PeerEurekaNode.ReplicationList list = new PeerEurekaNode.ReplicationList();
                for (ReplicationTask task : tasks) {
                   if (System.currentTimeMillis()
                            - config.getMaxTimeForReplication() > task
                            .getSubmitTime()) {
                       Object[] args = { task.getAppName(), task.getId(),
                               task.getAction(),
                               new Date(System.currentTimeMillis()),
                               new Date(task.getSubmitTime()) };
                    
                        logger.warn(
                                ""Replication events older than the threshold. AppName : {}, Id: {}, Action : {}, Current Time : {}, Submit Time :{}"",
                                args);

                        continue;
                    }
                    PeerEurekaNode.ReplicationInstance instance = new PeerEurekaNode.ReplicationInstance();
                    instance.setAppName(task.getAppName());
                    instance.setId(task.getId());
                    InstanceInfo instanceInfo = task.getInstanceInfo();
                    if (instanceInfo != null) {
                        String overriddenStatus = (task
                                .getOverriddenStatus() == null ? null
                                        : task.getOverriddenStatus().name());
                        instance.setOverriddenStatus(overriddenStatus);
                        instance.setLastDirtyTimestamp(instanceInfo
                                .getLastDirtyTimestamp());
                        if (task.shouldReplicateInstanceInfo()) {
                            instance.setInstanceInfo(instanceInfo);
                        }
                        String instanceStatus = instanceInfo
                        .getStatus() == null ? null
                                : instanceInfo.getStatus().name();
                        instance.setStatus(instanceStatus);
                    }
                    instance.setAction(task.getAction());
                    list.addReplicationInstance(instance);
                }
                if (list.getList().size() == 0) {
                    return true;
                }
                Action action = list.getList().get(0).action;
                DynamicCounter.increment(""Batch_""
                        + action

                        + ""_tries"");

                do {
                    done = true;
                    ClientResponse response = null;
                    try {
                        response = jerseyApacheClient
                        .resource(serviceUrl)
                        .path(BATCH_URL_PATH)
                        .accept(MediaType.APPLICATION_JSON_TYPE)
                        .type(MediaType.APPLICATION_JSON_TYPE)
                        .post(ClientResponse.class, list);
                        if (!isSuccess(response)) {
                            return false;
                        }
                        DynamicCounter.increment(""Batch_""
                                + action

                                + ""_success"");

                        PeerEurekaNode.ReplicationListResponse batchResponse = response
                        .getEntity(PeerEurekaNode.ReplicationListResponse.class);
                        int ctr = 0;
                        for (PeerEurekaNode.ReplicationInstanceResponse singleResponse : batchResponse
                                .getResponseList()) {
                            int statusCode = singleResponse
                            .getStatusCode();
                            if ((!isSuccess(response))
                                    || (singleResponse
                                    .getResponseEntity() != null)) {
                                if (singleResponse.getResponseEntity() != null) {
                                    tasks.get(ctr)
                                    .setPeerInstanceInfo(
                                            singleResponse
                                            .getResponseEntity());
                                }
                                tasks.get(ctr)
                                .handleFailure(statusCode);
                            }

                            ++ctr;
                        }
                        done = true;

                    } catch (Throwable e) {

                        if ((isNetworkConnectException(e))) {
                            DynamicCounter.increment(""Batch_""
                                    + action
                              + ""_retries"");
                            done = false;
                        } else {
                            success = false;
                            logger.info(
                                    ""Not re-trying this exception because it does not seem to be a network exception"",
                                    e);
                        }
                    } finally {
                        if (response != null) {
                            response.close();
                        }
                    }
                } while (!done);
                return success;
            }

            private boolean isSuccess(ClientResponse response) {
                return response.getStatus() < 200
                        || response.getStatus() >= 300;
            }

            private void executeSingle(List<ReplicationTask> tasks) {
                for (ReplicationTask task : tasks) {
                    boolean done = true;
                    do {
                        done = true;
                        try {
                              if (System.currentTimeMillis()
                                    - config.getMaxTimeForReplication() > task
                                    .getSubmitTime()) {
                                  Object[] args = {
                                          task.getAppName(),
                                          task.getId(),
                                          task.getAction(),
                                          new Date(System.currentTimeMillis()),
                                          new Date(task.getSubmitTime()) };
       
                                logger.warn(
                                        ""Replication events older than the threshold. AppName : {}, Id: {}, Action : {}, Current Time : {}, Submit Time :{}"",
                                        args);

                                continue;
                            }
                            DynamicCounter.increment(""Single_""
                                    + task.getAction().name()

                                    + ""_tries"");

                            int statusCode = task.execute();
                            if (statusCode < 200 && statusCode > 299) {
                                task.handleFailure(statusCode);
                            }
                            DynamicCounter.increment(""Single_""
                                    + task.getAction().name()

                                    + ""_success"");

                        } catch (Throwable e) {
                            logger.error(
                                    name + task.getAppName() + ""/""
                                    + task.getId() + "":""
                                    + task.getAction(), e);
                            try {
                                Thread.sleep(RETRY_SLEEP_TIME_MS);
                            } catch (InterruptedException e1) {

                            }
                            if ((isNetworkConnectException(e))) {
                                DynamicCounter.increment(task
                                        .getAction().name()
                                        + ""_retries"");
                                done = false;
                            } else {
                                logger.info(
                                        ""Not re-trying this exception because it does not seem to be a network exception"",
                                        e);
                            }
                        }
                    } while (!done);
                }
            }
        });
    }
"	@return The batcher instance	@return The batcher instance	0	1	20	217	1115
public boolean isRcsAssociated(final String phoneNumber) { boolean result = false; Cursor cur = ctx.getContentResolver().query(RichAddressBookData.CONTENT_URI, new String[] { RichAddressBookData.KEY_CONTACT_NUMBER }, RichAddressBookData.KEY_CONTACT_NUMBER + STR, new String[] { phoneNumber }, null); if (cur != null) { if (cur.moveToFirst()) { result = true; } cur.close(); } else { result = false; } return result; }	"public boolean isRcsAssociated(final String phoneNumber) {
    return !getRcsRawContactIdFromPhoneNumber(phoneNumber).isEmpty();
}"	@return true if contact has an entry in the rich address book provider, else false	@return true if contact is associated to a RCS raw contact, else false	1	0	9	13	84
public TreeGraphNode headWordNode() { return safeCast(label.get(TreeCoreAnnotations.HeadWordAnnotation.class)); }	"  public TreeGraphNode headWordNode() {
    TreeGraphNode hwn = safeCast(label.get(TreeCoreAnnotations.HeadWordAnnotation.class));
    if (hwn == null || (hwn.treeGraph() != null && !(hwn.treeGraph().equals(this.treeGraph())))) {
      return null;
    }
    return hwn;
  }
"	@return the node containing the head word for this node	@return the node containing the head word for this node	0	1	7	4	19
public Date getEnd() { if (records.size() == NUM) { return new Date(); } else { Date last = records.get(NUM).getDate(); for (Entry e : records) { if (e.getDate().after(last)) { last = e.getDate(); } } return last; } }	"public Date getEnd() {
    if (records.size() == NUM) {
        return null;
    } else {
        Date last = records.get(NUM).getDate();
        for (Entry e : records) {
            if (e.getDate().after(last)) {
                last = e.getDate();
            }
        }
        return last;
    }
}"	@return The time of the last record, or the current time if there are no records	@return The time of the last record or null if there are no records	1	0	11	13	68
public boolean isStarting() { return status.get() == STARTING; }	"    public boolean isStarting() {
        return starting.get();
    }
"	@return true if the Connection is starting	@return true if the Connection is starting	0	1	5	4	14
private int waitForSocket(Launcher launcher, int port, int timeout) { try { LocalPortReceiveAdbPortTask task = new LocalPortReceiveAdbPortTask(port, timeout); return launcher.getChannel().call(task); } catch (InterruptedException ex) { } catch (IOException e) { } return -NUM; }	"private boolean waitForSocket(Launcher launcher, int port, int timeout) {
    try {
        LocalPortOpenTask task = new LocalPortOpenTask(port, timeout);
        return launcher.getChannel().call(task);
    } catch (InterruptedException ex) {
    } catch (IOException e) {
    }
    return false;
}"	@return port number of the emulator if the socket was available, -1 if we timed-out.	@return <code>true</code> if the socket was available, <code>false</code> if we timed-out.	1	0	7	9	56
public final Location doGeoLookup(final String ip) { Location location = null; Integer ipAddressType = determineIpAddressType(ip); switch(ipAddressType) { case NUM: location = ip4Lookup.getLocation(ip); break; case NUM: location = ip6Lookup.getLocationV6(ip); break; default: break; } return location; }	"private Tuple doGeoLookup(final String ip) throws ExecException {
    Location location = null;
    Integer ipAddressType = determineIpAddressType(ip);
    Tuple output = tupleFactory.newTuple(this.neededGeoFieldNames.size());
    switch(ipAddressType) {
        case NUM:
            location = ip4Lookup.getLocation(ip);
            break;
        case NUM:
            location = ip6Lookup.getLocationV6(ip);
            break;
        case NUM:
            warn(STR, PigWarning.UDF_WARNING_1);
            return null;
        default:
            warn(STR, PigWarning.UDF_WARNING_1);
            return null;
    }
    if (location != null) {
        int i = NUM;
        String value = null;
        for (GeoIpLookupField field : this.neededGeoFieldNames) {
            switch(field) {
                case COUNTRYCODE:
                    value = location.countryCode;
                    break;
                case CONTINENTCODE:
                    value = getContinentCode(location.countryCode);
                    break;
                case CONTINENTNAME:
                    value = getContinentName(location.countryCode);
                    break;
                case REGION:
                    value = location.region;
                    break;
                case CITY:
                    value = location.city;
                    break;
                case POSTALCODE:
                    value = location.postalCode;
                    break;
                case LATITUDE:
                    value = Float.toString(location.latitude);
                    break;
                case LONGITUDE:
                    value = Float.toString(location.longitude);
                    break;
                case DMACODE:
                    value = Integer.toString(location.dma_code);
                    break;
                case AREACODE:
                    value = Integer.toString(location.area_code);
                    break;
                case METROCODE:
                    value = Integer.toString(location.metro_code);
                    break;
                default:
                    break;
            }
            output.set(i, value);
            i++;
        }
    } else {
        warn(STR, PigWarning.UDF_WARNING_3);
        return null;
    }
    return output;
}"	@return location object	@return Tuple containing the requested the geocoded field	1	0	8	15	59
public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws ApiException { return uploadFileWithRequiredFileWithHttpInfo(petId, requiredFile, additionalMetadata).getData(); }	"  public ModelApiResponse uploadFileWithRequiredFile(Long petId, File file, String additionalMetadata) throws ApiException {
    return uploadFileWithRequiredFileWithHttpInfo(petId, file, additionalMetadata).getData();
      }
"	@return ModelApiResponse	@return ModelApiResponse	0	1	5	4	30
protected final List<SyntaxTreeNode> getContents() { return _contents; }	"protected final Vector getContents() {
    return _contents;
}"	@return A List containing all the child nodes of this node.	@return A Vector containing all the child nodes of this node.	1	0	5	3	12
public static List getEditorSearchPath() { String[] paths = PropertyEditorManager.getEditorSearchPath(); List pathList = new ArrayList(paths.length); for (int i = NUM; i < paths.length; i++) { pathList.add(paths[i]); } return pathList; }	"public static List getEditorSearchPath() {
    String[] path = PropertyEditorManager.getEditorSearchPath();
    List list = new ArrayList(path.length);
    for (int i = NUM; i < path.length; i++) {
        list.add(path[i]);
    }
    return list;
}"	@return a List object containing all of the registered search paths.	@return The package names that will be searched for property editors.	1	0	9	8	54
public <T> int querySimpleList(Class<T> c, String sqlCmd, Connection conn, Collection<T> result) { if (checkOpen() == false) return -NUM; ResultSet rs = null; try { long start = System.currentTimeMillis(); if (log.isInfoEnabled()) log.info(STR + sqlCmd); rs = driver.executeQuery(sqlCmd, null, false, conn); if (rs == null) { error(driver); return -NUM; } int count = NUM; while (rs.next()) { T item = ObjectUtils.convert(c, rs.getObject(NUM)); result.add(item); count++; } if (log.isInfoEnabled()) log.info(STR + String.valueOf(count) + STR + String.valueOf(System.currentTimeMillis() - start) + STR); clearError(); return count; } catch (ClassCastException e) { log.error(STR, e); error(Errors.Exception, e); return -NUM; } catch (SQLException e) { log.error(STR, e); error(DBErrors.QueryFailed, e); return -NUM; } finally { closeResultSet(rs); } }	"public <T> List<T> querySimpleList(Class<T> c, String sqlCmd, Connection conn) {
    if (checkOpen() == false)
        return null;
    ResultSet rs = null;
    try {
        if (checkOpen() == false)
            return null;
        long start = System.currentTimeMillis();
        if (log.isInfoEnabled())
            log.info(STR + sqlCmd);
        rs = driver.executeQuery(sqlCmd, null, false, conn);
        if (rs == null) {
            error(driver);
            return null;
        }
        List<T> result = new ArrayList<T>();
        while (rs.next()) {
            T item = ObjectUtils.convert(c, rs.getObject(NUM));
            result.add(item);
        }
        if (log.isInfoEnabled())
            log.info(STR + String.valueOf(result.size()) + STR + String.valueOf(System.currentTimeMillis() - start) + STR);
        clearError();
        return result;
    } catch (ClassCastException e) {
        log.error(STR, e);
        error(Errors.Exception, e);
        return null;
    } catch (SQLException e) {
        log.error(STR, e);
        error(DBErrors.QueryFailed, e);
        return null;
    } finally {
        closeResultSet(rs);
    }
}"	@return the number of elements that have been added to the collection or -1 if an error occurred	@return a list of the values of the first column of an sql query	1	0	12	35	230
public synchronized Media getMediaAt(int index) { if (index < NUM || index >= getCount()) throw new IndexOutOfBoundsException(); final Media media = mMediaArray.get(index); media.retain(); return media; }	"public synchronized Media getMediaAt(int index) {
    if (index < NUM || index > getCount())
        return null;
    return mMediaArray.get(index);
}"	@return Media hold by MediaList. This Media should be released with {@link #release()}.	@return Media hold by MediaList, Should NOT be released.	1	0	6	7	44
"public DateTimeField halfdayOfDay() { return UnsupportedDateTimeField.getInstance (DateTimeFieldType.halfdayOfDay(), UnsupportedDurationField.getInstance(""halfdays"")); }"	"    public DateTimeField halfdayOfDay() {
        return UnsupportedDateTimeField.getInstance
            (""halfdayOfDay"", UnsupportedDurationField.getInstance(""halfdays""));
    }
"	@return DateTimeField or UnsupportedDateTimeField if unsupported	@return DateTimeField or UnsupportedDateTimeField if unsupported	0	1	6	5	25
public final int getValue(long timestamp) { Score s = getByTimestamp(timestamp); if (s != null) return s.getValue(); return NUM; }	"public int getValue(long timestamp) {
    computeAll();
    String[] args = { habit.getId().toString(), Long.toString(timestamp) };
    return SQLiteUtils.intQuery(STR, args);
}"	@return score value for that day	@return score for that day	1	0	6	6	32
public Integer getIndexForColumnName(String columnName, ResultSet rs) throws SQLException { final Integer cached = columnNameToIndexCache.get( columnName ); if ( cached != null ) { return cached; } else { final Integer index = Integer.valueOf( rs.findColumn( columnName ) ); columnNameToIndexCache.put( columnName, index); return index; } }	"	public int getIndexForColumnName(String columnName, ResultSet rs) throws SQLException {
		final Integer cached = columnNameToIndexCache.get( columnName );
		if ( cached != null ) {
			return cached;
		}
		else {
			final int index = rs.findColumn( columnName );
			columnNameToIndexCache.put( columnName, index);
			return index;
		}
	}
"	@return The index	@return The index	0	1	9	12	61
"public static SchemaPath parseFromString(String expr) { if (expr == null || expr.isEmpty()) { return null; } if (SchemaPath.DYNAMIC_STAR.equals(expr)) { return SchemaPath.getSimplePath(expr); } LogicalExpression logicalExpression = LogicalExpressionParser.parse(expr); if (logicalExpression instanceof SchemaPath) { return (SchemaPath) logicalExpression; } else { throw new IllegalStateException(String.format(""Schema path is not a valid format: %s."", logicalExpression)); } }"	"  public static SchemaPath parseFromString(String expr) {
    if (expr == null || expr.isEmpty()) {
      return null;
    }
    try {
      if (SchemaPath.DYNAMIC_STAR.equals(expr)) {
        return SchemaPath.getSimplePath(expr);
      }
      ExprLexer lexer = new ExprLexer(new ANTLRStringStream(expr));
      CommonTokenStream tokens = new CommonTokenStream(lexer);
      ExprParser parser = new ExprParser(tokens);

      parse_return ret = parser.parse();

      if (ret.e instanceof SchemaPath) {
        return (SchemaPath) ret.e;
      } else {
        throw new IllegalStateException(""Schema path is not a valid format."");
      }
    } catch (RecognitionException e) {
      throw new RuntimeException(e);
    }
  }
"	@return  SchemaPath instance	@return SchemaPath instance	0	1	8	17	93
public PingResult performCheck(PingConfiguration configuration) { PingResult info = client.ping(configuration); setPingInfo(info, configuration, client); return info; }	"public PingInfo performCheck(PingConfiguration configuration) {
    PingInfo info = client.ping(configuration);
    setPingInfo(info, configuration, client);
    return info;
}"	@return {@link PingResult}	@return {@link PingInfo}	1	0	6	5	29
"public String toString() { return ""Converter["" + (getSupportedType() == null ? ""null"" : getSupportedType().getName()) + ""]""; }"	"    public String toString() {
        return ""Converter["" + getSupportedType() + ""]"";
    }
"	@return a debugging string	@return a debugging string	0	1	8	4	35
public MultiJoin getMultiJoinRel() { return multiJoin; }	"public MultiJoinRel getMultiJoinRel() {
    return multiJoin;
}"	@return the MultiJoin corresponding to this multijoin	@return the MultiJoinRel corresponding to this multijoin	1	0	4	3	10
public Task<EncodedImage> get(CacheKey key, AtomicBoolean isCancelled) { final EncodedImage pinnedImage = mStagingArea.get(key); if (pinnedImage != null) { return foundPinnedImage(key, pinnedImage); } return getAsync(key, isCancelled); }	"public Task<EncodedImage> get(final CacheKey key, final AtomicBoolean isCancelled) {
    Preconditions.checkNotNull(key);
    Preconditions.checkNotNull(isCancelled);
    final EncodedImage pinnedImage = mStagingArea.get(key);
    if (pinnedImage != null) {
        FLog.v(TAG, STR, key.toString());
        mImageCacheStatsTracker.onStagingAreaHit();
        return Task.forResult(pinnedImage);
    }
    try {
        return Task.call(new Callable<EncodedImage>() {

            @Override
            public EncodedImage call() throws Exception {
                if (isCancelled.get()) {
                    throw new CancellationException();
                }
                EncodedImage result = mStagingArea.get(key);
                if (result != null) {
                    FLog.v(TAG, STR, key.toString());
                    mImageCacheStatsTracker.onStagingAreaHit();
                } else {
                    FLog.v(TAG, STR, key.toString());
                    mImageCacheStatsTracker.onStagingAreaMiss();
                    try {
                        final PooledByteBuffer buffer = readFromDiskCache(key);
                        CloseableReference<PooledByteBuffer> ref = CloseableReference.of(buffer);
                        try {
                            result = new EncodedImage(ref);
                        } finally {
                            CloseableReference.closeSafely(ref);
                        }
                    } catch (Exception exception) {
                        return null;
                    }
                }
                if (Thread.interrupted()) {
                    FLog.v(TAG, STR);
                    if (result != null) {
                        result.close();
                    }
                    throw new InterruptedException();
                } else {
                    return result;
                }
            }
        }, mReadExecutor);
    } catch (Exception exception) {
        FLog.w(TAG, exception, STR, key.toString());
        return Task.forError(exception);
    }
}"	@return Task that resolves to cached element or null if one cannot be retrieved; returned task never rethrows any exception	@return ListenableFuture that resolves to cached element or null if one cannot be retrieved; returned future never rethrows any exception	1	0	7	7	46
"protected boolean useGzipWhenAccepted(Response r) { return r.getMimeType() != null && r.getMimeType().toLowerCase().contains(""text/""); }"	"    protected boolean useGzipWhenAccepted() {
        return false;
    }
"	@return true if the gzip compression should be used if the client accespts it. Default this option is on for text content and off for everything else.	@return true if the gzip compression should be used if the client accespts it. Default this option is tuned off.	1	0	7	4	33
public int toStatusCode(Throwable e) { if (e == null) { return SUCCESS; } Set<Integer> possibleMatches = KNOWN_ERRORS.stream() .filter(knownError -> knownError.getException().equals(e.getClass())) .filter(knownError -> knownError.isCanonicalJsonCodeForException) .map(KnownError::getJsonCode) .collect(Collectors.toSet()); return Iterables.getOnlyElement(possibleMatches, UNHANDLED_ERROR); }	"  public int toStatusCode(Throwable e) {
    if (e == null) {
      return SUCCESS;
    }

    // Handle the cases where the JSON wire protocol was more specific than the W3C one
    if (ImeNotAvailableException.class.equals(e.getClass())) {
      return IME_NOT_AVAILABLE;
    }
    if (ImeActivationFailedException.class.equals(e.getClass())) {
      return IME_ENGINE_ACTIVATION_FAILED;
    }

    // And then handle the other cases
    Stream<StatusTuple> allCodesStream = ALL_CODES.values().stream()
      .flatMap(Collection::stream)
      .filter(tuple -> tuple.getException() != null)
      .filter(tuple -> tuple.associatedException.isAssignableFrom(e.getClass()));

    if (e instanceof WebDriverException && ((WebDriverException)e).getStatusCode() != null) {
      allCodesStream = allCodesStream.filter(tuple -> ((WebDriverException)e).getStatusCode() == tuple.jsonStatus );
    }

    Set<Integer> possibleMatches = allCodesStream
      .map(StatusTuple::getStatusFromException)
      .collect(Collectors.toSet());

    if (possibleMatches.size() > 1) {
      // if there's multiple matches, let's try filtering on the exact exception class to see if we
      // can reduce the possibilities
      Set<Integer> reducedPossibleMatches = ALL_CODES.values().stream()
        .flatMap(Collection::stream)
        .filter(tuple -> tuple.getException() != null)
        .filter(tuple -> tuple.associatedException.equals(e.getClass()))
        .map(StatusTuple::getStatusFromException)
        .collect(Collectors.toSet());

      if (reducedPossibleMatches.size() > 0) {
        possibleMatches = reducedPossibleMatches;
      }
    }

    return Preconditions.checkNotNull(Iterables.getFirst(possibleMatches, UNHANDLED_ERROR));
  }
"	@return The exception type that corresponds to the provided status code or  null if  statusCode == 0.	@return The exception type that corresponds to the provided status code or null if statusCode == 0.	0	1	10	14	73
protected int getInSubqueryThreshold() { return IN_SUBQUERY_THRESHOLD; }	"  protected int getInSubqueryThreshold() {
    return 20;
  }
"	@return threshold, default  #IN_SUBQUERY_THRESHOLD	@return threshold, default 20	1	0	4	4	10
public static String jenkinsJobName(BuildConfig bc) { String namespace = bc.getMetadata().getNamespace(); String name = bc.getMetadata().getName(); return jenkinsJobName(namespace, name); }	"public static String jenkinsJobName(BuildConfig bc, String defaultNamespace) {
    String namespace = bc.getMetadata().getNamespace();
    String name = bc.getMetadata().getName();
    return jenkinsJobName(namespace, name, defaultNamespace);
}"	@return the jenkins job name for the given BuildConfig	@return the jenkins job name for the given BuildConfig and default namespace	1	0	6	5	38
@Action(value = STR) public String execute() throws Exception { LOG.info(STR + id); SASFHelper helper = SASFStaticHelper.getHelper(request); if (mode == null) { url = STR + id; return STR; } else if (STR.equals(mode)) { SocialAuthManager manager = null; if (helper != null) { manager = helper.getAuthManager(); if (manager != null) { manager.disconnectProvider(id); } } return STR; } return STR; }	"@Override
public ActionForward execute(final ActionMapping mapping, final ActionForm form, final HttpServletRequest request, final HttpServletResponse response) throws Exception {
    SASFHelper helper = SASFStaticHelper.getHelper(request);
    AuthForm authForm = (AuthForm) form;
    String id = authForm.getId();
    String mode = request.getParameter(STR);
    ActionForward fwd = null;
    if (mode == null) {
        String filterUrl = STR + id;
        fwd = new ActionForward(STR, filterUrl, true);
    } else if (mode.equals(STR)) {
        SocialAuthManager manager = null;
        if (helper != null) {
            manager = helper.getAuthManager();
            if (manager != null)
                manager.disconnectProvider(id);
        }
        fwd = mapping.findForward(STR);
    }
    return fwd;
}"	@return String where the action should flow	@return ActionForward where the action should flow	1	0	12	19	95
public static int getIntParam(JSONObject params, String paramName) throws ApiException { if (!params.containsKey(paramName)) { throw new ApiException(ApiException.Type.MISSING_PARAMETER, paramName); } try { return params.getInt(paramName); } catch (JSONException e) { throw new ApiException(ApiException.Type.ILLEGAL_PARAMETER, paramName, e); } }	"	public static int getIntParam(JSONObject params, String paramName) throws ApiException {
		int value;
		try {
			value = params.getInt(paramName);
		} catch (Exception ex) {
			throw new ApiException(Type.MISSING_PARAMETER, paramName + "": "" + ex.getLocalizedMessage());
		}
		return value;
	}
"	@return the int param	@return the int param	0	1	7	12	67
public SqlNode getTargetTable() { return targetTable; }	"  public SqlIdentifier getTargetTable() {
    return targetTable;
  }
"	@return the identifier for the target table of the insertion	@return the identifier for the target table of the insertion	0	1	4	4	10
protected Function<?, ?> getTypeFunction(Class<?> aType) { return (Function<?, ?>) defaultFunctions.get(aType); }	"protected Function getTypeFunction(Class aType) {
    return (Function) typeFunctions.get(aType);
}"	@return a transformer that will convert strings into that type, or null if the given type is not a primitive type	@return a applyer that will convert strings into that type, or null if the given type is not a primitive type	1	0	6	3	26
public static boolean isLocalContactUri(Uri uri) { return isLocalContentUri(uri) && ContactsContract.AUTHORITY.equals(uri.getAuthority()) && !uri.getPath().startsWith(LOCAL_CONTACT_IMAGE_URI.getPath()); }	"  public static boolean isLocalContactUri(Uri uri) {
    return isLocalContentUri(uri)
        && ContactsContract.AUTHORITY.equals(uri.getAuthority())
        && !uri.getPath().startsWith(LOCAL_CONTACT_IMAGE_PREFIX);
  }
"	@return true if the uri is a Contact URI, and is not already specifying a display photo.	@return true if the uri is a Contact URI, and is not already specifying a display photo.	0	1	7	6	41
public static String getMessageId(SipRequest request) { String result = null; try { String content = request.getContent(); int index = content.indexOf(ImdnUtils.HEADER_IMDN_MSG_ID); if (index != -NUM) { index = index + ImdnUtils.HEADER_IMDN_MSG_ID.length() + NUM; String part = content.substring(index); String msgId = part.substring(NUM, part.indexOf(CRLF)); result = msgId.trim(); } } catch (Exception e) { } return result; }	"public static String getMessageId(SipRequest request) {
    ExtensionHeader messageIdHeader = (ExtensionHeader) request.getHeader(ImdnUtils.HEADER_IMDN_MSG_ID);
    if (messageIdHeader != null) {
        return messageIdHeader.getValue();
    }
    try {
        String content = request.getContent();
        int index = content.indexOf(ImdnUtils.HEADER_IMDN_MSG_ID);
        if (index != -NUM) {
            index = index + ImdnUtils.HEADER_IMDN_MSG_ID.length() + NUM;
            String part = content.substring(index);
            String msgId = part.substring(NUM, part.indexOf(SipUtils.CRLF));
            return msgId.trim();
        }
    } catch (Exception e) {
    }
    return null;
}"	@return Message ID	@return String or empty	1	0	10	15	91
private HiscoreLookup getCorrectLookupFor(final ChatMessage chatMessage) { Player localPlayer = client.getLocalPlayer(); final String player = sanitize(chatMessage.getName()); // If we are sending the message then just use the local hiscore endpoint for the world if (chatMessage.getType().equals(ChatMessageType.PRIVATECHATOUT) || player.equals(localPlayer.getName())) { return new HiscoreLookup(localPlayer.getName(), hiscoreEndpoint); } // Public chat on a leagues world is always league hiscores, regardless of icon if (chatMessage.getType() == ChatMessageType.PUBLICCHAT || chatMessage.getType() == ChatMessageType.MODCHAT) { if (client.getWorldType().contains(WorldType.LEAGUE)) { return new HiscoreLookup(player, HiscoreEndpoint.LEAGUE); } } // Get ironman status from their icon in chat HiscoreEndpoint endpoint = getHiscoreEndpointByName(chatMessage.getName()); return new HiscoreLookup(player, endpoint); }	"	private HiscoreLookup getCorrectLookupFor(final ChatMessage chatMessage)
	{
		final String player;
		final HiscoreEndpoint ironmanStatus;

		if (chatMessage.getType().equals(ChatMessageType.PRIVATECHATOUT))
		{
			player = client.getLocalPlayer().getName();
			ironmanStatus = hiscoreEndpoint;
		}
		else
		{
			player = sanitize(chatMessage.getName());

			if (player.equals(client.getLocalPlayer().getName()))
			{
				// Get ironman status from for the local player
				ironmanStatus = hiscoreEndpoint;
			}
			else
			{
				// Get ironman status from their icon in chat
				ironmanStatus = getHiscoreEndpointByName(chatMessage.getName());
			}
		}

		return new HiscoreLookup(player, ironmanStatus);
	}
"	@return hiscore lookup data	@return hiscore lookup data	0	1	9	26	170
public String getterAndSetterCapitalize(String name) { if (name == null || name.length() == 0) { return name; } return org.openapitools.codegen.utils.StringUtils.camelize(toVarName(name)); }	"    public String getterAndSetterCapitalize(String name) {
        if (name == null || name.length() == 0) {
            return name;
        }
        return camelize(toVarName(name));
    }
"	@return Camelized string	@return Camelized string	0	1	6	7	40
public PlaceType getPlaceType(String placeTypeName) throws InvalidPlaceType { PlaceType type = placeTypeNameCache.get(placeTypeName); if (type == null) throw new InvalidPlaceType(placeTypeName); return type; }	"public PlaceType getPlaceType(String placeType) {
    return placeTypesCache.get(placeType);
}"	@return the PlaceType corresponding to the provided name.	@return the PlaceType corresponding to the provided name, or null.	1	0	6	6	34
public HttpSession getSelectedSession() { final int selectedRow = this.sessionsTable.getSelectedRow(); if (selectedRow == -1) { // No row selected return null; } final int rowIndex = sessionsTable.convertRowIndexToModel(this.sessionsTable.getSelectedRow()); return this.sessionsModel.getHttpSessionAt(rowIndex); }	"	public HttpSession getSelectedSession() {
		final int rowIndex = sessionsTable.convertRowIndexToModel(this.sessionsTable.getSelectedRow());
		return this.sessionsModel.getHttpSessionAt(rowIndex);
	}
"	@return the selected session, or null if nothing is selected	@return the selected session, or null if nothing is selected	0	1	7	10	53
public ScalewayCloud getCloud() { Jenkins instance = Jenkins.getInstance(); if (instance != null) { return (ScalewayCloud) instance.getCloud(cloudName); } return null; }	"public Cloud getCloud() {
    return (Cloud) Jenkins.getInstance().getCloud(cloudName);
}"	@return the ScalewayCloud associated with the specified cloudName	@return the Cloud associated with the specified cloudName	1	0	8	7	35
@Override public ActivityOptions getActivityLaunchOptions(Launcher launcher, View v) { if (hasControlRemoteAppTransitionPermission()) { try { RemoteAnimationRunnerCompat runner = new LauncherAnimationRunner(mHandler) { @Override public AnimatorSet getAnimator(RemoteAnimationTargetCompat[] targetCompats) { AnimatorSet anim = new AnimatorSet(); if (!composeRecentsLaunchAnimator(v, targetCompats, anim)) { mLauncher.getStateManager().setCurrentAnimation(anim); anim.play(getIconAnimator(v)); if (launcherIsATargetWithMode(targetCompats, MODE_CLOSING)) { anim.play(getLauncherContentAnimator(false)); } anim.play(getWindowAnimators(v, targetCompats)); } return anim; } }; int duration = findTaskViewToLaunch(launcher, v, null) != null ? RECENTS_LAUNCH_DURATION : APP_LAUNCH_DURATION; int statusBarTransitionDelay = duration - STATUS_BAR_TRANSITION_DURATION; return ActivityOptionsCompat.makeRemoteAnimation(new RemoteAnimationAdapterCompat(runner, duration, statusBarTransitionDelay)); } catch (NoClassDefFoundError e) { } } return getDefaultActivityLaunchOptions(launcher, v); }	"@Override
public Bundle getActivityLaunchOptions(Launcher launcher, View v) {
    if (hasControlRemoteAppTransitionPermission()) {
        try {
            RemoteAnimationRunnerCompat runner = new LauncherAnimationRunner(mLauncher) {

                @Override
                public void onAnimationStart(RemoteAnimationTargetCompat[] targets, Runnable finishedCallback) {
                    postAtFrontOfQueueAsynchronously(v.getHandler(), () -> {
                        mAnimator = new AnimatorSet();
                        setCurrentAnimator(mAnimator);
                        mAnimator.play(getLauncherAnimators(v));
                        mAnimator.play(getWindowAnimators(v, targets));
                        mAnimator.addListener(new AnimatorListenerAdapter() {

                            @Override
                            public void onAnimationEnd(Animator animation) {
                                v.setVisibility(View.VISIBLE);
                                ((ViewGroup) mDragLayer.getParent()).removeView(mFloatingView);
                                mDragLayer.setAlpha(NUM);
                                mDragLayer.setTranslationY(NUM);
                                View appsView = mLauncher.getAppsView();
                                appsView.setAlpha(NUM);
                                appsView.setTranslationY(NUM);
                                finishedCallback.run();
                            }
                        });
                        mAnimator.start();
                        mAnimator.setCurrentPlayTime(REFRESH_RATE_MS);
                    });
                }
            };
            return ActivityOptionsCompat.makeRemoteAnimation(new RemoteAnimationAdapterCompat(runner, NUM, NUM)).toBundle();
        } catch (NoClassDefFoundError e) {
        }
    }
    return getDefaultActivityLaunchOptions(launcher, v);
}"	@return ActivityOptions with remote animations that controls how the window of the opening targets are displayed.	@return A Bundle with remote animations that controls how the window of the opening targets are displayed.	1	0	17	28	174
public static String quantityToRSDecimalStack(int quantity, boolean precise) { String quantityStr = String.valueOf(quantity); if (quantityStr.length() <= 4) { return quantityStr; } int power = (int) Math.log10(quantity); // Output thousandths for values above a million NumberFormat format = precise && power >= 6 ? PRECISE_DECIMAL_FORMATTER : DECIMAL_FORMATTER; return format.format(quantity / (Math.pow(10, (power / 3) * 3))) + SUFFIXES[power / 3]; }	"	public static String quantityToRSDecimalStack(int quantity)
	{
		String quantityStr = String.valueOf(quantity);
		if (quantityStr.length() <= 4)
		{
			return quantityStr;
		}

		int power = (int) Math.log10(quantity);
		return DECIMAL_FORMATTER.format(quantity / (Math.pow(10, (power / 3) * 3))) + SUFFIXES[power / 3];
	}
"	@return The stack size as it would appear in RS, with decimals, with K after 100,000 and M after 10,000,000	@return The stack size as it would appear in RS, with decimals, with K after 100,000 and M after 10,000,000	0	1	10	18	96
"private Uri getResizedImage (final String realPath, final int initialWidth, final int initialHeight) { final BitmapFactory.Options options = new BitmapFactory.Options(); options.inSampleSize = 8; Bitmap photo = BitmapFactory.decodeFile(realPath, options); Bitmap scaledphoto = null; if (maxWidth == 0) { maxWidth = initialWidth; } if (maxHeight == 0) { maxHeight = initialHeight; } double widthRatio = (double)maxWidth / initialWidth; double heightRatio = (double)maxHeight / initialHeight; double ratio = (widthRatio < heightRatio) ? widthRatio : heightRatio; int newWidth = (int)(initialWidth * ratio); int newHeight = (int)(initialHeight * ratio); scaledphoto = Bitmap.createScaledBitmap(photo, newWidth, newHeight, true); ByteArrayOutputStream bytes = new ByteArrayOutputStream(); scaledphoto.compress(Bitmap.CompressFormat.JPEG, quality, bytes); String filname = UUID.randomUUID().toString(); File path = Environment.getExternalStoragePublicDirectory( Environment.DIRECTORY_PICTURES); File f = new File(path, filname +"".jpg""); try { // Make sure the Pictures directory exists. path.mkdirs(); f.createNewFile(); } catch (IOException e) { e.printStackTrace(); } FileOutputStream fo; try { fo = new FileOutputStream(f); try { fo.write(bytes.toByteArray()); } catch (IOException e) { e.printStackTrace(); } } catch (FileNotFoundException e) { e.printStackTrace(); } // recycle to avoid java.lang.OutOfMemoryError if (photo != null) { photo.recycle(); photo = null; } return Uri.fromFile(f); }"	"  private String getResizedImage (final String realPath, final int initialWidth, final int initialHeight) {
        Bitmap photo = BitmapFactory.decodeFile(realPath);

        Bitmap scaledphoto = null;
        if (maxWidth == 0) {
            maxWidth  = initialWidth;
        }
        if (maxHeight == 0) {
            maxHeight = initialHeight;
        }
        double widthRatio = (double)maxWidth / initialWidth;
        double heightRatio = (double)maxHeight / initialHeight;

        double ratio = (widthRatio < heightRatio)
                ? widthRatio
                : heightRatio;

        int newWidth = (int)(initialWidth * ratio);
        int newHeight = (int)(initialHeight * ratio);

        scaledphoto = Bitmap.createScaledBitmap(photo, newWidth, newHeight, true);
        ByteArrayOutputStream bytes = new ByteArrayOutputStream();
        scaledphoto.compress(Bitmap.CompressFormat.JPEG, quality, bytes);
        String filname = UUID.randomUUID().toString();
        File path = Environment.getExternalStoragePublicDirectory(
            Environment.DIRECTORY_PICTURES);
        File f = new File(path, filname +"".jpg"");
        try {
            // Make sure the Pictures directory exists.
            path.mkdirs();

            f.createNewFile();
        } catch (IOException e) {
            e.printStackTrace();
        }
        FileOutputStream fo;
        try {
            fo = new FileOutputStream(f);
            try {
                fo.write(bytes.toByteArray());
            } catch (IOException e) {
                e.printStackTrace();
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
        return f.getAbsolutePath();
  }
"	@return uri of resized file	@return absolute path of resized file	1	0	7	57	295
public static ReferenceResult findReferencedMembers(FieldInfo fieldInfo) { Set<String> members = new HashSet<String>(); ClassMemberVisitor visitor = new ClassMemberVisitor(members); Set<Integer> ids = findPoolReferences(fieldInfo); visitor.visitField(fieldInfo); visitPoolReferences(fieldInfo.getClassInfo(), visitor, ids); return new ReferenceResult(members, new ArrayList<InvokeSite>(NUM)); }	"public static Set<String> findReferencedMembers(FieldInfo fieldInfo) {
    Set<String> members = new HashSet<String>();
    ClassMemberVisitor visitor = new ClassMemberVisitor(members);
    Set<Integer> ids = findPoolReferences(fieldInfo);
    visitor.visitField(fieldInfo);
    visitPoolReferences(fieldInfo.getClassInfo(), visitor, ids);
    return members;
}"	@return a set of class names and class member signatures found in the field.	@return a set of class names and class member signatures found in the class.	1	0	8	8	67
public int pingAndWaitForReply(Message message, int numPings, long timeout) throws JMSException, InterruptedException { String messageCorrelationId = Long.toString(idGenerator.incrementAndGet()); message.setJMSCorrelationID(messageCorrelationId); for (int i = NUM; i < numPings; i++) { message.setLongProperty(STR, System.currentTimeMillis()); _producer.send(message); } commitTx(getProducerSession()); if (_verbose) { _logger.info(timestampFormatter.format(new Date()) + STR + messageCorrelationId); } CountDownLatch trafficLight = new CountDownLatch(numPings); trafficLights.put(messageCorrelationId, trafficLight); trafficLight.await(timeout, TimeUnit.MILLISECONDS); int numReplies = numPings - (int) trafficLight.getCount(); if ((numReplies < numPings) && _verbose) { _logger.info(STR + messageCorrelationId); } else if (_verbose) { _logger.info(STR + messageCorrelationId); } return numReplies; }	"public Message pingAndWaitForReply(Message message, long timeout) throws JMSException, InterruptedException {
    _producer.send(message);
    String messageId = message.getJMSMessageID();
    commitTx();
    BooleanLatch trafficLight = new BooleanLatch();
    trafficLights.put(messageId, trafficLight);
    trafficLight.await(timeout * NUM);
    Message result = replies.get(messageId);
    return result;
}"	@return The number of replies received. This may be less than the number sent if the timeout terminated the wait for all prematurely.	@return The reply, or null if no reply arrives before the timeout.	1	0	11	22	173
private static CoreMap fromProto(CoreNLPProtos.Sentence proto) { CoreMap sentence = new ArrayCoreMap(); // Required fields sentence.set(TokenBeginAnnotation.class, proto.getTokenOffsetBegin()); sentence.set(TokenEndAnnotation.class, proto.getTokenOffsetEnd()); // Optional fields if (proto.hasSentenceIndex()) { sentence.set(SentenceIndexAnnotation.class, proto.getSentenceIndex()); } if (proto.hasCharacterOffsetBegin()) { sentence.set(CharacterOffsetBeginAnnotation.class, proto.getCharacterOffsetBegin()); } if (proto.hasCharacterOffsetEnd()) { sentence.set(CharacterOffsetEndAnnotation.class, proto.getCharacterOffsetEnd()); } if (proto.hasParseTree()) { sentence.set(TreeAnnotation.class, fromProto(proto.getParseTree())); } // Non-default fields if (proto.hasHasRelationAnnotations() && proto.getHasRelationAnnotations()) { // set entities List<EntityMention> entities = new ArrayList<EntityMention>(); for (CoreNLPProtos.Entity entity : proto.getEntityList()) { entities.add(fromProto(entity, sentence)); } sentence.set(EntityMentionsAnnotation.class, entities); // set relations List<RelationMention> relations = new ArrayList<RelationMention>(); for (CoreNLPProtos.Relation relation : proto.getRelationList()) { relations.add(fromProto(relation, sentence)); } sentence.set(RelationMentionsAnnotation.class, relations); } // Return return sentence; }	"  public CoreLabel fromProto(CoreNLPProtos.Token proto) {
    CoreLabel word = new CoreLabel();
    // Required fields
    word.setWord(proto.getWord());
    // Optional fields
    if (proto.hasPos()) { word.setTag(proto.getPos()); }
    if (proto.hasValue()) { word.setValue(proto.getValue()); }
    if (proto.hasCategory()) { word.setCategory(proto.getCategory()); }
    if (proto.hasBefore()) { word.setBefore(proto.getBefore()); }
    if (proto.hasAfter()) { word.setAfter(proto.getAfter()); }
    if (proto.hasOriginalText()) { word.setOriginalText(proto.getOriginalText()); }
    if (proto.hasNer()) { word.setNER(proto.getNer()); }
    if (proto.hasLemma()) { word.setLemma(proto.getLemma()); }
    if (proto.hasBeginChar()) { word.setBeginPosition(proto.getBeginChar()); }
    if (proto.hasEndChar()) { word.setEndPosition(proto.getEndChar()); }
    if (proto.hasSpeaker()) { word.set(SpeakerAnnotation.class, proto.getSpeaker()); }
    if (proto.hasUtterance()) { word.set(UtteranceAnnotation.class, proto.getUtterance()); }
    if (proto.hasBeginIndex()) { word.set(BeginIndexAnnotation.class, proto.getBeginIndex()); }
    if (proto.hasEndIndex()) { word.set(EndIndexAnnotation.class, proto.getEndIndex()); }
    if (proto.hasTokenBeginIndex()) { word.set(TokenBeginAnnotation.class, proto.getTokenBeginIndex()); }
    if (proto.hasTokenEndIndex()) { word.set(TokenEndAnnotation.class, proto.getTokenEndIndex()); }
    if (proto.hasNormalizedNER()) { word.set(NormalizedNamedEntityTagAnnotation.class, proto.getNormalizedNER()); }
    if (proto.hasTimexValue()) { word.set(TimexAnnotation.class, fromProto(proto.getTimexValue())); }
    if (proto.hasHasXmlContext() && proto.getHasXmlContext()) { word.set(XmlContextAnnotation.class, proto.getXmlContextList()); }
    if (proto.hasCorefClusterID()) { word.set(CorefClusterIdAnnotation.class, proto.getCorefClusterID()); }
    if (proto.hasAnswer()) { word.set(AnswerAnnotation.class, proto.getAnswer()); }
    if (proto.hasOperator()) { word.set(NaturalLogicAnnotations.OperatorAnnotation.class, fromProto(proto.getOperator())); }
    if (proto.hasPolarity()) { word.set(NaturalLogicAnnotations.PolarityAnnotation.class, fromProto(proto.getPolarity())); }
    // Non-default annotators
    if (proto.hasGender()) { word.set(GenderAnnotation.class, proto.getGender()); }
    if (proto.hasTrueCase()) { word.set(TrueCaseAnnotation.class, proto.getTrueCase()); }
    if (proto.hasTrueCaseText()) { word.set(TrueCaseTextAnnotation.class, proto.getTrueCaseText()); }
    // Return
    return word;
  }
"	@return A CoreMap, representing a sentence as stored in the protocol buffer (and therefore missing some fields)	@return A CoreLabel, missing the fields that are not stored in the CoreLabel protobuf.	1	0	10	25	256
public static boolean isResolvableDevice(UrlDevice urlDevice) { String type = urlDevice.optExtraString(TYPE_KEY, STR); return type.equals(BLE_DEVICE_TYPE) || type.equals(SSDP_DEVICE_TYPE) || type.equals(MDNS_PUBLIC_DEVICE_TYPE); }	"public static boolean isResolvableDevice(UrlDevice urlDevice) {
    try {
        urlDevice.getExtraString(TITLE_KEY);
    } catch (JSONException e) {
        return false;
    }
    return true;
}"	@return If the device is resolvable or not.	@return If the device is local or not.	1	0	7	4	41
Class[] getServiceClasses(final Class type, final List issues) { final ServiceDescriptorSet set = (ServiceDescriptorSet) type.getAnnotation(ServiceDescriptorSet.class); if (null != set) { final ServiceDescriptor[] descriptors = set.value(); final Class[] services = new Class[descriptors.length]; for (int i = NUM; i < descriptors.length; i++) { ServiceDescriptor descriptor = descriptors[i]; services[i] = descriptor.type(); } return services; } else { return new Class[NUM]; } }	"Class[] getServiceClasses(final Class type, final List issues) {
    final List services = new ArrayList();
    final ClassLoader classLoader = type.getClassLoader();
    final Attribute[] attributes = Attributes.getAttributes(type, STR);
    for (int i = NUM; i < attributes.length; i++) {
        final String classname = attributes[i].getParameter(STR);
        try {
            final Class clazz = classLoader.loadClass(classname);
            services.add(clazz);
        } catch (final Throwable t) {
            final Object[] args = new Object[] { classname, t };
            final String message = getMessage(STR, args);
            final VerifyIssue issue = new VerifyIssue(VerifyIssue.ERROR, message);
            issues.add(issue);
        }
    }
    return (Class[]) services.toArray(new Class[services.size()]);
}"	@return an array of Classes for all the value	@return an array of Classes for all the services	1	0	11	14	103
public String getConsoleOutput() throws IOException { if (process == null || stream == null) { return null; } return stream instanceof CircularOutputStream ? stream.toString() : null; }	"  public String getConsoleOutput() throws IOException {
    if (process == null) {
      return null;
    }

    return Streams.drainStream(stream);
  }
"	@return the console output of the executed binary.	@return the console output of the executed binary.	0	1	6	8	35
"protected long[] executeBatchInternal() throws SQLException { for (int i = 0; i < connection.maxRetriesPerExecute; i++) { try { return connection.prepareAndUpdateBatch(this, batchedSql).updateCounts; } catch (NoSuchStatementException e) { resetStatement(); } } throw new RuntimeException(""Failed to successfully execute batch update after "" + connection.maxRetriesPerExecute + "" attempts""); }"	"  protected int[] executeBatchInternal() throws SQLException {
    for (int i = 0; i < connection.maxRetriesPerExecute; i++) {
      try {
        Meta.ExecuteBatchResult result = connection.prepareAndUpdateBatch(this, batchedSql);
        return result.updateCounts;
      } catch (NoSuchStatementException e) {
        resetStatement();
      }
    }

    throw new RuntimeException(""Failed to successfully execute batch update after ""
        +  connection.maxRetriesPerExecute + "" attempts"");
  }
"	@return an array of long mapping to the update count per SQL command.	@return an array of integers mapping to the update count per SQL command.	1	0	8	13	73
"public ResponseEntity<Void> deleteUserWithHttpInfo(String username) throws RestClientException { Object postBody = null; // verify the required parameter 'username' is set if (username == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'username' when calling deleteUser""); } // create path and map variables final Map<String, Object> uriVariables = new HashMap<String, Object>(); uriVariables.put(""username"", username); String path = apiClient.expandPath(""/user/{username}"", uriVariables); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<Void> returnType = new ParameterizedTypeReference<Void>() {}; return apiClient.invokeAPI(path, HttpMethod.DELETE, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType); }"	"    public ResponseEntity<Void> deleteUserWithHttpInfo(String username) throws RestClientException {
        Object postBody = null;
        
        // verify the required parameter 'username' is set
        if (username == null) {
            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'username' when calling deleteUser"");
        }
        
        // create path and map variables
        final Map<String, Object> uriVariables = new HashMap<String, Object>();
        uriVariables.put(""username"", username);
        String path = apiClient.expandPath(""/user/{username}"", uriVariables);

        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();
        final HttpHeaders headerParams = new HttpHeaders();
        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();

        final String[] accepts = { };
        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);
        final String[] contentTypes = { };
        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);

        String[] authNames = new String[] {  };

        ParameterizedTypeReference<Void> returnType = new ParameterizedTypeReference<Void>() {};
        return apiClient.invokeAPI(path, HttpMethod.DELETE, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);
    }
"	@return ResponseEntity&lt;Void&gt;	@return ResponseEntity&lt;Void&gt;	0	1	8	29	238
public int getBufferSizeBytes() { if (DEFAULT == mBufferSizeBytes) { return getConfiguration().getInt(IO_FILE_BUFFER_SIZE_KEY, IO_FILE_BUFFER_SIZE_DEFAULT); } return mBufferSizeBytes; }	"      public int getBufferSizeBytes() {
        if (DEFAULT == mBufferSizeBytes) {
          return getConfiguration().getInt(""io.file.buffer.size"", DEFAULT_BUFFER_SIZE_BYTES);
        }
        return mBufferSizeBytes;
      }
"	@return The buffer size in bytes.	@return The buffer size in bytes.	0	1	8	8	28
"public String getResourceManagerId() throws JMSException { waitForBrokerInfo(); if( brokerInfo==null ) throw new JMSException(""Connection failed before Broker info was received.""); return brokerInfo.getBrokerId().getValue(); }"	"    public String getResourceManagerId() throws JMSException {
        waitForBrokerInfo();
        if( brokerInfo==null )
            throw new JMSException(""Connection failed before Broker info was received."");            
        return brokerInfo.getBrokerId().getBrokerId();
    }
"	@return Returns the resourceManagerId.	@return Returns the resourceManagerId.	0	1	6	7	42
public Element[] getElements(String name) { Element[] elems = (Element[]) m_elements.get(name.toLowerCase()); return elems; }	"public Element[] getElements(String name) {
    Element[] elems = (Element[]) m_elements.get(name.toLowerCase());
    if (elems == null) {
        return new Element[NUM];
    } else {
        return elems;
    }
}"	@return the resulting element array (null if the search failed)	@return the resulting element array (empty if the search failed)	1	0	7	4	32
public Options useAstDefinitions(boolean flag) { return new Options(this.includeIntrospectionTypes, this.includeScalars, this.includeExtendedScalars, this.includeSchemaDefinition, this.includeDirectives, flag, this.descriptionsAsHashComments, this.comparatorRegistry); }	"        public Options useAstDefinitions(boolean flag) {
            return new Options(this.includeIntrospectionTypes, this.includeScalars, this.includeExtendedScalars, this.includeSchemaDefinition, this.includeDirectives, flag, this.comparatorRegistry);
        }
"	@return new instance of options	@return new instance of options	0	1	6	4	37
@Deprecated public int getTileSize() { return Math.max(tileHeight, tileWidth); }	"public int getTileSize() {
    return tileSize;
}"	@return tile height or width, whichever is larger	@return the size of tiles in pixels	1	0	5	4	18
"public ArrayList<Word> segmentWords(MatchHeuristic h) throws UnsupportedOperationException { if(lattice==null || len < 0) throw new UnsupportedOperationException(""segmentWords must be run first""); List<Word> segmentedWords = new ArrayList<>(); // Init dynamic programming: double[] costs = new double[len+1]; List<DFSATransition<Word, Integer>> bptrs = new ArrayList<>(); for (int i = 0; i < len + 1; ++i) { bptrs.add(null); } costs[0]=0.0; for (int i=1; i<=len; ++i) costs[i] = Double.MAX_VALUE; // DP: for (int start=0; start<len; ++start) { DFSAState<Word, Integer> fromState = states.get(start); Collection<DFSATransition<Word, Integer>> trs = fromState.transitions(); for (DFSATransition<Word, Integer> tr : trs) { DFSAState<Word, Integer> toState = tr.getTarget(); double lcost = tr.score(); int end = toState.stateID(); //System.err.println(""start=""+start+"" end=""+end+"" word=""+tr.getInput()); if (h == MatchHeuristic.MINWORDS) { // Minimize number of words: if (costs[start]+1 < costs[end]) { costs[end] = costs[start]+lcost; bptrs.set(end, tr); //System.err.println(""start=""+start+"" end=""+end+"" word=""+tr.getInput()); } } else if (h == MatchHeuristic.MAXWORDS) { // Maximze number of words: if (costs[start]+1 < costs[end]) { costs[end] = costs[start]-lcost; bptrs.set(end, tr); } } else { throw new UnsupportedOperationException(""unimplemented heuristic""); } } } // Extract min-cost path: int i=len; while (i>0) { DFSATransition<Word, Integer> tr = bptrs.get(i); DFSAState<Word, Integer> fromState = tr.getSource(); Word word = tr.getInput(); if (!word.word().equals("" "")) segmentedWords.add(0, word); i = fromState.stateID(); } if(DEBUG) { // Print lattice density ([1,+inf[) : if equal to 1, it means // there is only one segmentation using words of the lexicon. double density = edgesNb*1.0/segmentedWords.size(); System.err.println(""latticeDensity: ""+density+"" cost: ""+costs[len]); } return new ArrayList<>(segmentedWords); }"	"  public ArrayList<Word> segmentWords(MatchHeuristic h) throws UnsupportedOperationException {
    if(lattice==null || len < 0)
      throw new UnsupportedOperationException(""segmentWords must be run first"");
    List<Word> segmentedWords = new ArrayList<Word>();
    // Init dynamic programming:
    double costs[] = new double[len+1];
    List<DFSATransition<Word, Integer>> bptrs = new ArrayList<DFSATransition<Word, Integer>>();
    for (int i = 0; i < len + 1; ++i) {
      bptrs.add(null);
    }
    costs[0]=0.0;
    for (int i=1; i<=len; ++i)
       costs[i] = Double.MAX_VALUE;
    // DP:
    for (int start=0; start<len; ++start) {
      DFSAState<Word, Integer> fromState = states.get(start);
      Collection<DFSATransition<Word, Integer>> trs = fromState.transitions();
      for (DFSATransition<Word, Integer> tr : trs) {
        DFSAState<Word, Integer> toState = tr.getTarget();
        double lcost = tr.score();
        int end = toState.stateID();
        //System.err.println(""start=""+start+"" end=""+end+"" word=""+tr.getInput());
        if (h == MatchHeuristic.MINWORDS) {
          // Minimize number of words:
          if (costs[start]+1 < costs[end]) {
            costs[end] = costs[start]+lcost;
            bptrs.set(end, tr);
            //System.err.println(""start=""+start+"" end=""+end+"" word=""+tr.getInput());
          }
        } else if (h == MatchHeuristic.MAXWORDS) {
          // Maximze number of words:
          if (costs[start]+1 < costs[end]) {
            costs[end] = costs[start]-lcost;
            bptrs.set(end, tr);
          }
        } else {
          throw new UnsupportedOperationException(""unimplemented heuristic"");
        }
      }
    }
    // Extract min-cost path:
    int i=len;
    while (i>0) {
      DFSATransition<Word, Integer> tr = bptrs.get(i);
      DFSAState<Word, Integer> fromState = tr.getSource();
      Word word = tr.getInput();
      if (!word.word().equals("" ""))
        segmentedWords.add(0, word);
      i = fromState.stateID();
    }
    if(DEBUG) {
      // Print lattice density ([1,+inf[) : if equal to 1, it means
      // there is only one segmentation using words of the lexicon.
      double density = edgesNb*1.0/segmentedWords.size();
      System.err.println(""latticeDensity: ""+density+"" cost: ""+costs[len]);
    }
    return new ArrayList<Word>(segmentedWords);
  }
"	@return Segmented sentence.	@return Segmented sentence.	0	1	17	59	520
"public static SchemaGenAction interpret(Object value) { if ( value == null ) { return NONE; } if ( SchemaGenAction.class.isInstance( value ) ) { return (SchemaGenAction) value; } final String name = value.toString(); if ( StringHelper.isEmpty( name ) || NONE.externalName.equals( name ) ) { // default is NONE return NONE; } if ( CREATE.externalName.equals( name ) ) { return CREATE; } else if ( DROP.externalName.equals( name ) ) { return DROP; } else if ( BOTH.externalName.equals( name ) ) { return BOTH; } throw new IllegalArgumentException( String.format( ""Unrecognized '%s' or '%s' value : %s"", AvailableSettings.SCHEMA_GEN_DATABASE_ACTION, AvailableSettings.SCHEMA_GEN_SCRIPTS_ACTION, value ) ); }"	"	public static SchemaGenAction interpret(String value) {
		if ( StringHelper.isEmpty( value ) || NONE.externalName.equals( value ) ) {
			// default is NONE
			return NONE;
		}

		if ( CREATE.externalName.equals( value ) ) {
			return CREATE;
		}
		else if ( DROP.externalName.equals( value ) ) {
			return DROP;
		}
		else if ( BOTH.externalName.equals( value ) ) {
			return BOTH;
		}

		throw new IllegalArgumentException(
				String.format(
						""Unrecognized '%s' or '%s' value : %s"",
						AvailableSettings.SCHEMA_GEN_DATABASE_ACTION,
						AvailableSettings.SCHEMA_GEN_SCRIPTS_ACTION,
						value
				)
		);
	}
"	@return The matching enum value. An empty value will return  #NONE.	@return The matching enum value. An empty value will return #NONE.	0	1	8	35	149
public SubProjectData getProjectInfo(AbstractProject context) { SubProjectData subProjectData = new SubProjectData(); iterateBuilds(context, projects, subProjectData); subProjectData.getTriggered().removeAll(subProjectData.getDynamic()); subProjectData.getTriggered().removeAll(subProjectData.getFixed()); return subProjectData; }	"public List<Set<?>> getProjectInfo(AbstractProject context) {
    Comparator customComparator = new Comparator<AbstractProject>() {

        public int compare(AbstractProject abstractProject1, AbstractProject abstractProject2) {
            return abstractProject1.getFullName().compareTo(abstractProject2.getFullName());
        }
    };
    Set<AbstractProject> dynamicProject = new TreeSet<AbstractProject>(customComparator);
    Set<AbstractProject> staticProject = new TreeSet<AbstractProject>(customComparator);
    Set<AbstractProject> triggeredProject = new TreeSet<AbstractProject>(customComparator);
    Set<String> unresolvedProject = new TreeSet<String>();
    iterateBuilds(context, projects, dynamicProject, staticProject, triggeredProject, unresolvedProject);
    triggeredProject.removeAll(dynamicProject);
    triggeredProject.removeAll(staticProject);
    return Arrays.asList(staticProject, dynamicProject, triggeredProject, unresolvedProject);
}"	@return A data object containing sets with projects	@return A list containing sets with Projects	1	0	6	7	52
public boolean hasDataFetcher(FieldCoordinates coordinates) { return hasDataFetcherImpl(coordinates, dataFetcherMap, systemDataFetcherMap); }	"        public boolean hasDataFetcher(String parentTypeName, String fieldName) {
            return hasDataFetcherImpl(parentTypeName, fieldName, dataFetcherMap, systemDataFetcherMap);
        }
"	@return the true if there is a data fetcher already for this field	@return the true if there is a data fetcher already for this field	0	1	5	4	19
protected Object convertGeometry(Column column, Field fieldDefn, Object data) { final MySqlGeometry empty = MySqlGeometry.createEmpty(); return convertValue(column, fieldDefn, data, io.debezium.data.geometry.Point.createValue(fieldDefn.schema(), empty.getWkb(), empty.getSrid()), (r) -> { if (data instanceof byte[]) { // The binlog utility sends a byte array for any Geometry type, we will use our own binaryParse to parse the byte to WKB, hence // to the suitable class if (data instanceof byte[]) { // The binlog utility sends a byte array for any Geometry type, we will use our own binaryParse to parse the byte to WKB, hence // to the suitable class MySqlGeometry mySqlGeometry = MySqlGeometry.fromBytes((byte[]) data); r.deliver(io.debezium.data.geometry.Geometry.createValue(fieldDefn.schema(), mySqlGeometry.getWkb(), mySqlGeometry.getSrid())); } } }); }	"    protected Object convertGeometry(Column column, Field fieldDefn, Object data) {
        return convertValue(column, fieldDefn, data, (Supplier<?>)() -> {
            final MySqlGeometry empty = MySqlGeometry.createEmpty();
            return io.debezium.data.geometry.Point.createValue(fieldDefn.schema(), empty.getWkb(), empty.getSrid());
        }, (r) -> {
            if (data instanceof byte[]) {
                // The binlog utility sends a byte array for any Geometry type, we will use our own binaryParse to parse the byte to WKB, hence
                // to the suitable class
                if (data instanceof byte[]) {
                    // The binlog utility sends a byte array for any Geometry type, we will use our own binaryParse to parse the byte to WKB, hence
                    // to the suitable class
                    MySqlGeometry mySqlGeometry = MySqlGeometry.fromBytes((byte[]) data);
                    r.deliver(io.debezium.data.geometry.Geometry.createValue(fieldDefn.schema(), mySqlGeometry.getWkb(), mySqlGeometry.getSrid()));
                }
            }
        });
    }
"	@return the converted value, or null if the conversion could not be made and the column allows nulls	@return the converted value, or null if the conversion could not be made and the column allows nulls	0	1	14	16	191
public static String deprocess(String str, STextProcessor processor) { if ((str == null) || (str.length() <= NUM)) return str; STextEnvironment env = new STextEnvironment(null, false, STextEnvironment.ORIENT_UNKNOWN); if (!env.isProcessingNeeded()) return str; return STextEngine.fullToLeanText(processor, env, str, null); }	"public static String deprocess(String str, STextProcessor processor) {
    if ((str == null) || (str.length() <= NUM) || !isProcessingNeeded())
        return str;
    STextEnvironment env = new STextEnvironment(null, false, STextEnvironment.ORIENT_UNKNOWN);
    return STextEngine.fullToLeanText(processor, env, str, null);
}"	@return string without directional formatting characters	@return string with no directional formatting characters.	1	0	6	8	69
private List<InputSplit> generateInputSplits(GiraphInputFormat inputFormat, int numWorkers, String inputSplitType) { String logPrefix = STR + inputSplitType + STR; List<InputSplit> splits; try { splits = inputFormat.getSplits(getContext(), numWorkers); } catch (IOException e) { throw new IllegalStateException(logPrefix + STR, e); } catch (InterruptedException e) { throw new IllegalStateException(logPrefix + STR, e); } float samplePercent = getConfiguration().getFloat(GiraphConfiguration.INPUT_SPLIT_SAMPLE_PERCENT, GiraphConfiguration.INPUT_SPLIT_SAMPLE_PERCENT_DEFAULT); if (samplePercent != GiraphConfiguration.INPUT_SPLIT_SAMPLE_PERCENT_DEFAULT) { int lastIndex = (int) (samplePercent * splits.size() / NUM); List<InputSplit> sampleSplits = splits.subList(NUM, lastIndex); LOG.warn(logPrefix + STR + sampleSplits.size() + STR + splits.size() + STR); return sampleSplits; } else { if (LOG.isInfoEnabled()) { LOG.info(logPrefix + STR + splits.size() + STR + numWorkers + STR); } return splits; } }	"private List<InputSplit> generateInputSplits(int numWorkers) {
    VertexInputFormat<I, V, E, M> vertexInputFormat = getConfiguration().createVertexInputFormat();
    List<InputSplit> splits;
    try {
        splits = vertexInputFormat.getSplits(getContext(), numWorkers);
        float samplePercent = getConfiguration().getFloat(GiraphConfiguration.INPUT_SPLIT_SAMPLE_PERCENT, GiraphConfiguration.INPUT_SPLIT_SAMPLE_PERCENT_DEFAULT);
        if (samplePercent != GiraphConfiguration.INPUT_SPLIT_SAMPLE_PERCENT_DEFAULT) {
            int lastIndex = (int) (samplePercent * splits.size() / NUM);
            List<InputSplit> sampleSplits = splits.subList(NUM, lastIndex);
            LOG.warn(STR + STR + sampleSplits.size() + STR + splits.size() + STR);
            return sampleSplits;
        } else {
            if (LOG.isInfoEnabled()) {
                LOG.info(STR + splits.size() + STR + numWorkers + STR);
            }
            return splits;
        }
    } catch (IOException e) {
        throw new IllegalStateException(STR, e);
    } catch (InterruptedException e) {
        throw new IllegalStateException(STR, e);
    }
}"	@return List of input splits for the given format	@return List of input splits	1	0	14	23	187
public Date getFinalFireTime() { if (endTime == null) return null; Date finalTime = null; java.util.Calendar currCal = java.util.Calendar.getInstance(); currCal.setTime(this.endTime); while ((finalTime == null) && (this.startTime.before(currCal.getTime()))) { currCal.add(java.util.Calendar.DATE, -NUM); finalTime = getFireTimeAfter(currCal.getTime()); } return finalTime; }	"public Date getFinalFireTime() {
    Date finalTime = null;
    java.util.Calendar currCal = java.util.Calendar.getInstance();
    currCal.setTime(this.endTime);
    while ((finalTime == null) && (this.startTime.before(currCal.getTime()))) {
        currCal.add(java.util.Calendar.DATE, -NUM);
        finalTime = getFireTimeAfter(currCal.getTime());
    }
    return finalTime;
}"	@return the last time the trigger will fire, or null if there is no last time.	@return the last time the trigger will fire.	1	0	8	12	83
public String getTableName(FileSelection selection) { List<Path> files = selection.getFiles(); assert (files.size() == 1); return files.get(0).toUri().getPath(); }	"  public String getTableName(FileSelection selection) {
    List<String> files = selection.getFiles();
    assert (files.size() == 1);
    return files.get(0);
  }
"	@return string table name	@return string table name	0	1	6	6	39
protected AbstractBuilderNode addAttribute(final String name) { supportedAttributes.add(name); return this; }	"protected AbstractCustomBuilderNode addAttribute(final String name) {
    supportedAttributes.add(name);
    return this;
}"	@return AbstractBuilderNode (this) to allow for method chaining.	@return AbstractCustomBuilderNode (this) to allow for method chaining.	1	0	5	4	19
public static WebClient getWebClient(HttpServletRequest request) { HttpSession session = request.getSession(true); WebClient client = getWebClient(session); if (client == null || client.isClosed()) { client = WebClient.createWebClient(request); session.setAttribute(webClientAttribute, client); } return client; }	"public static WebClient getWebClient(HttpSession session) {
    return (WebClient) session.getAttribute(webClientAttribute);
}"	@return the current client or a newly creates	@return the web client for the current HTTP session or null if there is not a web client created yet	1	0	8	9	56
public Struct struct(String databaseName) { this.databaseName = databaseName; return struct((TableId) null); }	"    public Struct struct() {
        return struct(null);
    }
"	@return the source partition and offset  Struct; never null	@return the source partition and offset Struct; never null	0	1	6	5	22
public BackupResultStatus backupSession(final Session session) { if (_log.isInfoEnabled()) { _log.debug(STR + session.getId()); } final MemcachedBackupSession backupSession = (MemcachedBackupSession) session; final BackupSessionTask task = getOrCreateBackupSessionTask(backupSession); final Map<String, Object> attributes = backupSession.getAttributesInternal(); final byte[] attributesData = _transcoderService.serializeAttributes(backupSession, attributes); final int hashCode = Arrays.hashCode(attributesData); if (backupSession.getDataHashCode() != hashCode || task.sessionCookieWasRelocated()) { final byte[] data = _transcoderService.serialize(backupSession, attributesData); final BackupResult result = task.backupSession(data, attributesData); if (result.getAttributesData() != null) { backupSession.setDataHashCode(Arrays.hashCode(result.getAttributesData())); } return result.getStatus(); } else { return BackupResultStatus.SKIPPED; } }	"public BackupResult backupSession(final Session session) {
    if (_log.isInfoEnabled()) {
        _log.debug(STR + session.getId());
    }
    final BackupSessionTask task = getOrCreateBackupSessionTask((MemcachedBackupSession) session);
    return task.backupSession();
}"	@return the {@link SessionTrackerValve.SessionBackupService.BackupResultStatus}	@return the {@link SessionTrackerValve.SessionBackupService.BackupResult}	1	0	10	20	157
"public JSONObject getJSONObject(String key) { Object object = this.get(key); if (object == null) { return null; } if (object instanceof JSONObject) { return (JSONObject)object; } throw new RuntimeException(""JSONObject["" + quote(key) + ""] is not a JSONObject.""); }"	"  public JSONObject getJSONObject(String key) {
    Object object = this.get(key);
    if (object instanceof JSONObject) {
      return (JSONObject)object;
    }
    throw new RuntimeException(""JSONObject["" + quote(key) + ""] is not a JSONObject."");
  }
"	@return A JSONObject which is the value or null if not available.	@return A JSONObject which is the value.	1	0	8	11	64
public static GtidNewChannelPosition parse(String value, String defaultValue) { GtidNewChannelPosition mode = parse(value); if (mode == null && defaultValue != null) { mode = parse(defaultValue); } return mode; }	"        public static EventProcessingFailureHandlingMode parse(String value) {
            if (value == null) {
                return null;
            }

            value = value.trim();

            for (EventProcessingFailureHandlingMode option : EventProcessingFailureHandlingMode.values()) {
                if (option.getValue().equalsIgnoreCase(value)) {
                    return option;
                }
            }

            return null;
        }
"	@return the matching option, or null if no match is found and the non-null default is invalid	@return the matching option, or null if no match is found	1	0	8	8	41
"public boolean isOrdered(String locator1, String locator2) { return (Boolean) seleneseMethods.get(""isOrdered"").apply(driver, locator1, locator2); }"	"  public boolean isOrdered(String locator1, String locator2) {
    WebElement one = elementFinder.findElement(driver, locator1);
    WebElement two = elementFinder.findElement(driver, locator2);
    
    String ordered =
      ""    if (arguments[0] === arguments[1]) return false;\n"" + 
      ""\n"" + 
      ""    var previousSibling;\n"" + 
      ""    while ((previousSibling = arguments[1].previousSibling) != null) {\n"" + 
      ""        if (previousSibling === arguments[0]) {\n"" + 
      ""            return true;\n"" + 
      ""        }\n"" + 
      ""        arguments[1] = previousSibling;\n"" + 
      ""    }\n"" + 
      ""    return false;\n"";
    
    Boolean result = (Boolean) javascriptLibrary.executeScript(driver, ordered, one, two);
    return result != null && result.booleanValue();
  }
"	@return true if element1 is the previous sibling of element2, false otherwise	@return true if element1 is the previous sibling of element2, false otherwise	0	1	7	4	32
public Receiver getReceiver() { return receiver; }	"public com.vaadin.terminal.Receiver getReceiver() {
    return receiver;
}"	@return the StreamVariable.	@return the Receiver.	1	0	4	3	10
protected boolean verifyJmsMessageReceivedOnOutputChannel(Object obj, SubscribableChannel expectedOutputChannel, CountDownHandler handler) throws JMSException, InterruptedException{ return verifyJmsMessageOnOutputChannel(obj, expectedOutputChannel, handler, 7000); }	"	protected boolean verifyJmsMessageReceivedOnOutputChannel(Object obj, SubscribableChannel expectedOutputChannel, CountDownHandler handler) throws JMSException, InterruptedException{
		return verifyJmsMessageOnOutputChannel(obj, expectedOutputChannel, handler, 5000);
	}
"	@return true if the message was received on the expected channel	@return true if the message was received on the expected channel	0	1	5	4	31
public ArrayList<View> getViews() { final Activity activity = soloActivity.getCurrentActivity(); final Dialog currentDialog = dialogUtils.getCurrentDialog(); inst.waitForIdleSync(); final Window window; try { if (currentDialog != null) { window = currentDialog.getWindow(); } else { window = activity.getWindow(); } View decorView = window.getDecorView(); viewList.clear(); getViews(getTopParent(decorView)); return viewList; } catch (Throwable e) { e.printStackTrace(); } return null; }	"public ArrayList<View> getViews() {
    Activity activity = soloActivity.getCurrentActivity();
    inst.waitForIdleSync();
    final Window window;
    final Dialog currentDialog = getCurrentDialog(activity);
    try {
        if (currentDialog != null) {
            window = currentDialog.getWindow();
        } else {
            window = activity.getWindow();
        }
        View decorView = window.getDecorView();
        viewList.clear();
        getViews(getTopParent(decorView));
        return viewList;
    } catch (Throwable e) {
        e.printStackTrace();
    }
    return null;
}"	@return ArrayList with the views found in the current activity or dialog	@return ArrayList with the views found in the current activity	1	0	8	20	97
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; // set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { String str = yytext(); int first = str.charAt(0); String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } LOGGER.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: LOGGER.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 35: break; case 2: { if (normalizeOtherBrackets) { return getNext(openparen, yytext()); } else { return getNext(); } } case 36: break; case 3: { if (escapeForwardSlashAsterisk) { return getNext(LexerUtils.escapeChar(yytext(), '/'), yytext()); } else { return getNext(); } } case 37: break; case 4: { return getNext(); } case 38: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 39: break; case 6: { if (normalizeOtherBrackets) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 40: break; case 7: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 41: break; case 8: { if (invertible) { prevWordAfter.append(yytext()); } } case 42: break; case 9: { return handleEllipsis(yytext()); } case 43: break; case 10: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { String origTxt = yytext(); return getNext(asciiDash(origTxt), origTxt); } } case 44: break; case 11: { return normalizeFractions(yytext()); } case 45: break; case 12: { final String origTxt = yytext(); return getNext(asciiQuotes(origTxt), origTxt); } case 46: break; case 13: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 47: break; case 14: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 48: break; case 15: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 49: break; case 16: { if (escapeForwardSlashAsterisk) { return getNext(LexerUtils.escapeChar(yytext(), '*'), yytext()); } else { return getNext(); } } case 50: break; case 17: { String txt = yytext(); if (DEBUG) { LOGGER.info(""Used {EMOJI} to recognize "" + txt); } return getNext(txt, txt); } case 51: break; case 18: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 52: break; case 19: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(); } case 53: break; case 20: { final String origTxt = yytext(); return getNext(origTxt, origTxt, CONTR_ANNOTATION); } case 54: break; case 21: { if (!noSGML) { return getNext(); } } case 55: break; case 22: { // this one should only match if we're basically at the end of file // since the last one matches two things, even newlines String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 56: break; case 23: { final String origTxt = yytext(); return getNext(asciiDash(origTxt), origTxt, COMPOUND_ANNOTATION); } case 57: break; case 24: { final String origTxt = yytext(); return getNext(asciiDash(origTxt), origTxt); } case 58: break; case 25: // general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String txt = asciiQuotes(origTxt); return getNext(asciiDash(txt), origTxt); } case 59: break; case 26: // general lookahead, find correct zzMarkedPos { int zzFState = 1; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 2; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 60: break; case 27: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 61: break; case 28: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = LexerUtils.escapeChar(txt, '/'); txt = LexerUtils.escapeChar(txt, '*'); } return getNext(txt, yytext()); } case 62: break; case 29: { return getNormalizedAmpNext(); } case 63: break; case 30: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { return getNext(); } case 64: break; case 31: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 65: break; case 32: { yypushback(3) ; return getNext(); } case 66: break; case 33: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = LexerUtils.escapeChar(txt, '/'); } return getNext(txt, yytext()); } case 67: break; case 34: { String txt = yytext(); if (normalizeParentheses) { txt = txt.replaceAll(""\\("", openparen); txt = txt.replaceAll(""\\)"", closeparen); } return getNext(txt, yytext()); } case 68: break; default: zzScanError(ZZ_NO_MATCH); } } } }"	"  public Object next() throws java.io.IOException {
    int zzInput;
    int zzAction;

    // cached fields:
    int zzCurrentPosL;
    int zzMarkedPosL;
    int zzEndReadL = zzEndRead;
    char [] zzBufferL = zzBuffer;
    char [] zzCMapL = ZZ_CMAP;

    int [] zzTransL = ZZ_TRANS;
    int [] zzRowMapL = ZZ_ROWMAP;
    int [] zzAttrL = ZZ_ATTRIBUTE;

    while (true) {
      zzMarkedPosL = zzMarkedPos;

      yychar+= zzMarkedPosL-zzStartRead;

      zzAction = -1;

      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
  
      zzState = ZZ_LEXSTATE[zzLexicalState];

      // set up zzAction for empty match case:
      int zzAttributes = zzAttrL[zzState];
      if ( (zzAttributes & 1) == 1 ) {
        zzAction = zzState;
      }


      zzForAction: {
        while (true) {
    
          if (zzCurrentPosL < zzEndReadL) {
            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);
            zzCurrentPosL += Character.charCount(zzInput);
          }
          else if (zzAtEOF) {
            zzInput = YYEOF;
            break zzForAction;
          }
          else {
            // store back cached positions
            zzCurrentPos  = zzCurrentPosL;
            zzMarkedPos   = zzMarkedPosL;
            boolean eof = zzRefill();
            // get translated positions and possibly new buffer
            zzCurrentPosL  = zzCurrentPos;
            zzMarkedPosL   = zzMarkedPos;
            zzBufferL      = zzBuffer;
            zzEndReadL     = zzEndRead;
            if (eof) {
              zzInput = YYEOF;
              break zzForAction;
            }
            else {
              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);
              zzCurrentPosL += Character.charCount(zzInput);
            }
          }
          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
          if (zzNext == -1) break zzForAction;
          zzState = zzNext;

          zzAttributes = zzAttrL[zzState];
          if ( (zzAttributes & 1) == 1 ) {
            zzAction = zzState;
            zzMarkedPosL = zzCurrentPosL;
            if ( (zzAttributes & 8) == 8 ) break zzForAction;
          }

        }
      }

      // store back cached position
      zzMarkedPos = zzMarkedPosL;

      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
        zzAtEOF = true;
              {
                if (invertible) {
            prevWordAfter.append(yytext());
            String str = prevWordAfter.toString();
            prevWordAfter.setLength(0);
            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);
          }
          return null;
              }
      }
      else {
        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
          case 1: 
            { String str = yytext();
          int first = str.charAt(0);
          String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));
          switch (untokenizable) {
            case NONE_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              break;
            case FIRST_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              if ( ! this.seenUntokenizableCharacter) {
                LOGGER.warning(msg);
                this.seenUntokenizableCharacter = true;
              }
              break;
            case ALL_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              LOGGER.warning(msg);
              this.seenUntokenizableCharacter = true;
              break;
            case NONE_KEEP:
              return getNext();
            case FIRST_KEEP:
              if ( ! this.seenUntokenizableCharacter) {
                LOGGER.warning(msg);
                this.seenUntokenizableCharacter = true;
              }
              return getNext();
            case ALL_KEEP:
              LOGGER.warning(msg);
              this.seenUntokenizableCharacter = true;
              return getNext();
          }
            }
          case 34: break;
          case 2: 
            { if (normalizeOtherBrackets) {
                    return getNext(openparen, yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 35: break;
          case 3: 
            { if (escapeForwardSlashAsterisk) {
                    return getNext(delimit(yytext(), '/'), yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 36: break;
          case 4: 
            { return getNext();
            }
          case 37: break;
          case 5: 
            { if (tokenizeNLs) {
                      return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns
                  } else if (invertible) {
                      prevWordAfter.append(yytext());
                  }
            }
          case 38: break;
          case 6: 
            { if (normalizeOtherBrackets) {
                    return getNext(closeparen, yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 39: break;
          case 7: 
            { if (ptb3Dashes) {
                            return getNext(ptbmdash, yytext()); }
                          else {
                            return getNext();
                          }
            }
          case 40: break;
          case 8: 
            { if (invertible) {
                     prevWordAfter.append(yytext());
                  }
            }
          case 41: break;
          case 9: 
            { return handleEllipsis(yytext());
            }
          case 42: break;
          case 10: 
            { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {
	            return getNext(ptbmdash, yytext());
                  } else {
		    String origTxt = yytext();
                    return getNext(asciiDash(origTxt), origTxt);
		  }
            }
          case 43: break;
          case 11: 
            { return normalizeFractions(yytext());
            }
          case 44: break;
          case 12: 
            { final String origTxt = yytext();
                          return getNext(asciiQuotes(origTxt), origTxt);
            }
          case 45: break;
          case 13: 
            { if (normalizeOtherBrackets) {
                    return getNext(closebrace, yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 46: break;
          case 14: 
            { if (normalizeParentheses) {
                    return getNext(openparen, yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 47: break;
          case 15: 
            { if (normalizeParentheses) {
                    return getNext(closeparen, yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 48: break;
          case 16: 
            { if (escapeForwardSlashAsterisk) {
                    return getNext(delimit(yytext(), '*'), yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 49: break;
          case 17: 
            { if (normalizeOtherBrackets) {
                    return getNext(openbrace, yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 50: break;
          case 18: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { return getNext();
            }
          case 51: break;
          case 19: 
            { final String origTxt = yytext();
                          return getNext(origTxt, origTxt, CONTR_ANNOTATION);
            }
          case 52: break;
          case 20: 
            { if (!noSGML) {
                            return getNext();
			  }
            }
          case 53: break;
          case 21: 
            { // this one should only match if we're basically at the end of file
			  // since the last one matches two things, even newlines
                          String s;
                          if (strictTreebank3 && ! ""U.S."".equals(yytext())) {
                            yypushback(1); // return a period for next time
                            s = yytext();
                          } else {
                            s = yytext();
                            yypushback(1); // return a period for next time
                          }
	                  return getNext(s, yytext());
            }
          case 54: break;
          case 22: 
            { final String origTxt = yytext();
                          return getNext(asciiDash(origTxt), origTxt, COMPOUND_ANNOTATION);
            }
          case 55: break;
          case 23: 
            { final String origTxt = yytext();
                          return getNext(asciiDash(origTxt), origTxt);
            }
          case 56: break;
          case 24: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 3;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 4;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { final String origTxt = yytext();
                          String txt = asciiQuotes(origTxt);
                          return getNext(asciiDash(txt), origTxt);
            }
          case 57: break;
          case 25: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 1;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 2;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return getNext();
            }
          case 58: break;
          case 26: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 7;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 8;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return getNext();
            }
          case 59: break;
          case 27: 
            { String txt = yytext();
                          if (escapeForwardSlashAsterisk) {
                            txt = delimit(txt, '/');
                            txt = delimit(txt, '*');
                          }
                          return getNext(txt, yytext());
            }
          case 60: break;
          case 28: 
            { return getNormalizedAmpNext();
            }
          case 61: break;
          case 29: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);
            { return getNext();
            }
          case 62: break;
          case 30: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 5;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 6;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { String s;
                          if (strictTreebank3 && ! ""U.S."".equals(yytext())) {
                            yypushback(1); // return a period for next time
                            s = yytext();
                          } else {
                            s = yytext();
                            yypushback(1); // return a period for next time
                          }
	                  return getNext(s, yytext());
            }
          case 63: break;
          case 31: 
            { yypushback(3) ; return getNext();
            }
          case 64: break;
          case 32: 
            { String txt = yytext();
                          if (escapeForwardSlashAsterisk) {
                            txt = delimit(txt, '/');
                          }
                          return getNext(txt, yytext());
            }
          case 65: break;
          case 33: 
            { String txt = yytext();
			  if (normalizeParentheses) {
			    txt = txt.replaceAll(""\\("", openparen);
			    txt = txt.replaceAll(""\\)"", closeparen);
			  }
			  return getNext(txt, yytext());
            }
          case 66: break;
          default:
            zzScanError(ZZ_NO_MATCH);
        }
      }
    }
  }
"	@return the next token	@return the next token	0	1	19	469	2667
public BigInteger getNumber() { BigDecimal bigDecimal = getEnteredNumber().setScale(NUM, BigDecimal.ROUND_FLOOR); return bigDecimal.toBigIntegerExact(); }	"public int getNumber() {
    String numberString = doubleToString(getEnteredNumber());
    String[] split = numberString.split(STR);
    return Integer.parseInt(split[NUM]);
}"	@return an String representation of the number with no decimal	@return an int representation of the number with no decimal	1	0	7	4	26
public static List<Pattern> listOfRegex(String input, int regexFlags) { return listOf(input, RegExSplitter::split, (str) -> Pattern.compile(str, regexFlags)); }	"    public static Set<Pattern> listOfRegex(String input, int regexFlags) {
        return listOf(input, RegExSplitter::split, (str) -> Pattern.compile(str, regexFlags));
    }
"	@return the list of regular expression  Patterns included in the list; never null	@return the list of regular expression Patterns included in the list; never null	0	1	7	4	37
"public static String versionName() { return ""1.0.6""; }"	"    public static String versionName() {
        return ""1.0.5"";
    }
"	@return  String.	@return String.	0	1	4	4	15
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 35: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, yytext()); } case 50: break; case 8: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 51: break; case 19: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 52: break; case 47: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; // try to work around an apparent jflex bug where it // gets a space at the token end by getting // wrong the length of the trailing context. while (yylength() > 0) { char last = yycharat(yylength()-1); if (last == ' ' || last == '\t' || (last >= '\n' && last <= '\r' || last == '\u0085')) { yypushback(1); } else { break; } } if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 53: break; case 15: { return handleQuotes(yytext(), false); } case 54: break; case 32: // lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), false); } case 55: break; case 24: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 56: break; case 30: // lookahead expression with fixed lookahead length yypushback(1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 57: break; case 44: // lookahead expression with fixed lookahead length yypushback(1); { return getNormalizedAmpNext(); } case 58: break; case 31: { return getNormalizedAmpNext(); } case 59: break; case 34: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, yytext()); } case 60: break; case 48: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 4; { return getNext(); } case 61: break; case 40: // lookahead expression with fixed lookahead length yypushback(2); { return getNext(); } case 62: break; case 38: // general lookahead, find correct zzMarkedPos { int zzFState = 13; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 12; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 63: break; case 37: // general lookahead, find correct zzMarkedPos { int zzFState = 11; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 12; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 64: break; case 4: { return getNext(); } case 65: break; case 21: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(); } case 66: break; case 46: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } return getNext(txt, yytext()); } case 67: break; case 23: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, origTxt); } case 68: break; case 6: { if (normalizeOtherBrackets) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 69: break; case 7: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 70: break; case 28: // general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 71: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 72: break; case 43: { yypushback(2) ; return getNext(); } case 73: break; case 25: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 74: break; case 18: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 75: break; case 49: { String txt = yytext(); if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 76: break; case 45: { yypushback(3) ; return getNext(); } case 77: break; case 22: // lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), true); } case 78: break; case 2: { if (normalizeOtherBrackets) { return getNext(openparen, yytext()); } else { return getNext(); } } case 79: break; case 36: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 80: break; case 20: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 81: break; case 17: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 82: break; case 11: { return handleEllipsis(yytext()); } case 83: break; case 33: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 1; { /* invert quote - often but not always right */ return handleQuotes(yytext(), true); } case 84: break; case 13: { return normalizeFractions(yytext()); } case 85: break; case 14: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(); } } case 86: break; case 41: // general lookahead, find correct zzMarkedPos { int zzFState = 9; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 10; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 87: break; case 10: { if (invertible) { prevWordAfter.append(yytext()); } } case 88: break; case 3: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 89: break; case 42: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 90: break; case 12: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 91: break; case 27: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 92: break; case 9: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 93: break; case 29: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 94: break; case 26: { // this one should only match if we're basically at the end of file // since the last one matches two things, even newlines String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 95: break; case 1: { String str = yytext(); int first = str.charAt(0); String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } LOGGER.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: LOGGER.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 96: break; case 39: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 97: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 98: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }"	"  public Object next() throws java.io.IOException {
    int zzInput;
    int zzAction;

    // cached fields:
    int zzCurrentPosL;
    int zzMarkedPosL;
    int zzEndReadL = zzEndRead;
    char [] zzBufferL = zzBuffer;
    char [] zzCMapL = ZZ_CMAP;

    int [] zzTransL = ZZ_TRANS;
    int [] zzRowMapL = ZZ_ROWMAP;
    int [] zzAttrL = ZZ_ATTRIBUTE;

    while (true) {
      zzMarkedPosL = zzMarkedPos;

      yychar+= zzMarkedPosL-zzStartRead;

      zzAction = -1;

      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
  
      zzState = ZZ_LEXSTATE[zzLexicalState];


      zzForAction: {
        while (true) {
    
          if (zzCurrentPosL < zzEndReadL)
            zzInput = zzBufferL[zzCurrentPosL++];
          else if (zzAtEOF) {
            zzInput = YYEOF;
            break zzForAction;
          }
          else {
            // store back cached positions
            zzCurrentPos  = zzCurrentPosL;
            zzMarkedPos   = zzMarkedPosL;
            boolean eof = zzRefill();
            // get translated positions and possibly new buffer
            zzCurrentPosL  = zzCurrentPos;
            zzMarkedPosL   = zzMarkedPos;
            zzBufferL      = zzBuffer;
            zzEndReadL     = zzEndRead;
            if (eof) {
              zzInput = YYEOF;
              break zzForAction;
            }
            else {
              zzInput = zzBufferL[zzCurrentPosL++];
            }
          }
          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
          if (zzNext == -1) break zzForAction;
          zzState = zzNext;

          int zzAttributes = zzAttrL[zzState];
          if ( (zzAttributes & 1) == 1 ) {
            zzAction = zzState;
            zzMarkedPosL = zzCurrentPosL;
            if ( (zzAttributes & 8) == 8 ) break zzForAction;
          }

        }
      }

      // store back cached position
      zzMarkedPos = zzMarkedPosL;

      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
        case 33: 
          { String txt = yytext();
                  if (escapeForwardSlashAsterisk) {
                    txt = delimit(txt, '/');
                  }
                  if (normalizeSpace) {
                    // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                    txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space

                  }
                  return getNext(txt, yytext());
          }
        case 48: break;
        case 8: 
          { if (ptb3Dashes) {
                            return getNext(ptbmdash, yytext()); }
                          else {
                            return getNext();
                          }
          }
        case 49: break;
        case 19: 
          { if (escapeForwardSlashAsterisk) {
                    return getNext(delimit(yytext(), '*'), yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 50: break;
        case 45: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 7;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 8;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { String s;
                          // try to work around an apparent jflex bug where it
                          // gets a space at the token end by getting
                          // wrong the length of the trailing context.
                          while (yylength() > 0) {
                            char last = yycharat(yylength()-1);
                            if (last == ' ' || last == '\t' || (last >= '\n' && last <= '\r' || last == '\u0085')) {
                              yypushback(1);
                            } else {
                              break;
                            }
                          }
                          if (strictTreebank3 && ! ""U.S."".equals(yytext())) {
                            yypushback(1); // return a period for next time
                            s = yytext();
                          } else {
                            s = yytext();
                            yypushback(1); // return a period for next time
                          }
                          return getNext(s, yytext());
          }
        case 51: break;
        case 15: 
          { return handleQuotes(yytext(), false);
          }
        case 52: break;
        case 30: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return handleQuotes(yytext(), false);
          }
        case 53: break;
        case 42: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return getNormalizedAmpNext();
          }
        case 54: break;
        case 29: 
          { return getNormalizedAmpNext();
          }
        case 55: break;
        case 32: 
          { String txt = yytext();
                  if (escapeForwardSlashAsterisk) {
                    txt = delimit(txt, '/');
                  }
                  if (normalizeSpace) {
                    // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                    txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                  }
                  return getNext(txt, yytext());
          }
        case 56: break;
        case 46: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 4;
          { return getNext();
          }
        case 57: break;
        case 38: 
          // lookahead expression with fixed lookahead length
          yypushback(2);
          { return getNext();
          }
        case 58: break;
        case 36: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 13;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 12;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { return getNext();
          }
        case 59: break;
        case 4: 
          { return getNext();
          }
        case 60: break;
        case 21: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return getNext();
          }
        case 61: break;
        case 35: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 11;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 12;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { return getNext();
          }
        case 62: break;
        case 44: 
          { String txt = yytext();
                          if (escapeForwardSlashAsterisk) {
                            txt = delimit(txt, '/');
                          }
                          return getNext(txt, yytext());
          }
        case 63: break;
        case 23: 
          { final String origTxt = yytext();
                          String txt = origTxt;
                          if (normalizeSpace) {
                            // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                            txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                          }
                          return getNext(txt, origTxt);
          }
        case 64: break;
        case 6: 
          { if (normalizeOtherBrackets) {
                    return getNext(closeparen, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 65: break;
        case 7: 
          { final String origTxt = yytext();
                          String tmp = removeSoftHyphens(origTxt);
                          if (americanize) {
                            tmp = Americanize.americanize(tmp);
                          }
                          return getNext(tmp, origTxt);
          }
        case 66: break;
        case 27: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 3;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 4;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { final String origTxt = yytext();
                          String tmp = removeSoftHyphens(origTxt);
                          if (americanize) {
                            tmp = Americanize.americanize(tmp);
                          }
                          return getNext(tmp, origTxt);
          }
        case 67: break;
        case 16: 
          { if (normalizeOtherBrackets) {
                    return getNext(closebrace, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 68: break;
        case 41: 
          { yypushback(2) ; return getNext();
          }
        case 69: break;
        case 24: 
          { if (escapeForwardSlashAsterisk) {
                            return getNext(delimit(yytext(), '/'), yytext());
                          } else {
                            return getNext();
                          }
          }
        case 70: break;
        case 18: 
          { if (normalizeParentheses) {
                    return getNext(closeparen, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 71: break;
        case 47: 
          { String txt = yytext();
                          if (normalizeSpace) {
                            // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                            txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                          }
                          if (normalizeParentheses) {
                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                          }
                          return getNext(txt, yytext());
          }
        case 72: break;
        case 43: 
          { yypushback(3) ; return getNext();
          }
        case 73: break;
        case 22: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return handleQuotes(yytext(), true);
          }
        case 74: break;
        case 2: 
          { if (normalizeOtherBrackets) {
                    return getNext(openparen, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 75: break;
        case 34: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 5;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 6;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { final String txt = yytext();
                          return getNext(removeSoftHyphens(txt),
                                         txt);
          }
        case 76: break;
        case 20: 
          { if (normalizeOtherBrackets) {
                    return getNext(openbrace, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 77: break;
        case 17: 
          { if (normalizeParentheses) {
                    return getNext(openparen, yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 78: break;
        case 11: 
          { return handleEllipsis(yytext());
          }
        case 79: break;
        case 31: 
          // lookahead expression with fixed base length
          zzMarkedPos = zzStartRead + 1;
          { /* invert quote - often but not always right */
                  return handleQuotes(yytext(), true);
          }
        case 80: break;
        case 13: 
          { return normalizeFractions(yytext());
          }
        case 81: break;
        case 14: 
          { if (normalizeCurrency) {
                            return getNext(normalizeCurrency(yytext()), yytext()); }
                          else {
                            return getNext();
                          }
          }
        case 82: break;
        case 39: 
          // general lookahead, find correct zzMarkedPos
          { int zzFState = 9;
            int zzFPos = zzStartRead;
            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
            boolean zzFinL[] = zzFin;
            while (zzFState != -1 && zzFPos < zzMarkedPos) {
              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 
              zzInput = zzBufferL[zzFPos++];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            }
            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } 

            zzFState = 10;
            zzFPos = zzMarkedPos;
            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
              zzInput = zzBufferL[--zzFPos];
              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
            };
            zzMarkedPos = zzFPos;
          }
          { String s;
                          if (strictTreebank3 && ! ""U.S."".equals(yytext())) {
                            yypushback(1); // return a period for next time
                            s = yytext();
                          } else {
                            s = yytext();
                            yypushback(1); // return a period for next time
                          }
                          return getNext(s, yytext());
          }
        case 83: break;
        case 10: 
          { if (invertible) {
                     prevWordAfter.append(yytext());
                  }
          }
        case 84: break;
        case 3: 
          { if (escapeForwardSlashAsterisk) {
                    return getNext(delimit(yytext(), '/'), yytext()); }
                  else {
                    return getNext();
                  }
          }
        case 85: break;
        case 40: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return getNext(removeSoftHyphens(yytext()),
                                               yytext());
          }
        case 86: break;
        case 12: 
          { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {
                    return getNext(ptbmdash, yytext());
                  } else {
                    return getNext();
                  }
          }
        case 87: break;
        case 26: 
          { return getNext(removeSoftHyphens(yytext()), yytext());
          }
        case 88: break;
        case 9: 
          { return getNext(removeSoftHyphens(yytext()),
                                         yytext());
          }
        case 89: break;
        case 28: 
          // lookahead expression with fixed lookahead length
          yypushback(1);
          { return getNext(removeSoftHyphens(yytext()),
                                         yytext());
          }
        case 90: break;
        case 25: 
          { // this one should only match if we're basically at the end of file
                          // since the last one matches two things, even newlines
                          String s;
                          if (strictTreebank3 && ! ""U.S."".equals(yytext())) {
                            yypushback(1); // return a period for next time
                            s = yytext();
                          } else {
                            s = yytext();
                            yypushback(1); // return a period for next time
                          }
                          return getNext(s, yytext());
          }
        case 91: break;
        case 1: 
          { String str = yytext();
          int first = str.charAt(0);
          String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));
          switch (untokenizable) {
            case NONE_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              break;
            case FIRST_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              if ( ! this.seenUntokenizableCharacter) {
                LOGGER.warning(msg);
                this.seenUntokenizableCharacter = true;
              }
              break;
            case ALL_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              LOGGER.warning(msg);
              this.seenUntokenizableCharacter = true;
              break;
            case NONE_KEEP:
              return getNext();
            case FIRST_KEEP:
              if ( ! this.seenUntokenizableCharacter) {
                LOGGER.warning(msg);
                this.seenUntokenizableCharacter = true;
              }
              return getNext();
            case ALL_KEEP:
              LOGGER.warning(msg);
              this.seenUntokenizableCharacter = true;
              return getNext();
          }
          }
        case 92: break;
        case 37: 
          { String txt = yytext();
                          if (escapeForwardSlashAsterisk) {
                            txt = delimit(txt, '/');
                            txt = delimit(txt, '*');
                          }
                          return getNext(txt, yytext());
          }
        case 93: break;
        case 5: 
          { if (tokenizeNLs) {
                      return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns
                  } else if (invertible) {
                      prevWordAfter.append(yytext());
                  }
          }
        case 94: break;
        default: 
          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
            zzAtEOF = true;
              {
                if (invertible) {
            prevWordAfter.append(yytext());
            String str = prevWordAfter.toString();
            prevWordAfter.setLength(0);
            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);
          }
          return null;
              }
          } 
          else {
            zzScanError(ZZ_NO_MATCH);
          }
      }
    }
  }
"	@return the next token	@return the next token	0	1	17	625	3731
protected Object convertRowId(Column column, Field fieldDefn, Object data) { return convertValue(column, fieldDefn, data, BYTE_BUFFER_ZERO, (r) -> { if (data instanceof java.sql.RowId) { java.sql.RowId row = (java.sql.RowId) data; r.deliver(ByteBuffer.wrap(row.getBytes())); } }); }	"    protected Object convertRowId(Column column, Field fieldDefn, Object data) {
        if (data == null && !fieldDefn.schema().isOptional()) {
            data = fieldDefn.schema().defaultValue();
        }
        if (data == null) {
            if (column.isOptional()) return null;
            return ByteBuffer.wrap(new byte[0]);
        }
        if (data instanceof java.sql.RowId) {
            java.sql.RowId row = (java.sql.RowId) data;
            return ByteBuffer.wrap(row.getBytes());
        }
        return handleUnknownData(column, fieldDefn, data);
    }
"	@return the converted value, or null if the conversion could not be made and the column allows nulls	@return the converted value, or null if the conversion could not be made and the column allows nulls	0	1	13	9	68
public static ActiveMQConnectionFactory createConnectionFactoryWithoutHA(final DiscoveryGroupConfiguration groupConfiguration, JMSFactoryType jmsFactoryType) { ActiveMQConnectionFactory factory = null; if (jmsFactoryType.equals(JMSFactoryType.CF)) { factory = new ActiveMQJMSConnectionFactory(false, groupConfiguration); } else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_CF)) { factory = new ActiveMQQueueConnectionFactory(false, groupConfiguration); } else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_CF)) { factory = new ActiveMQTopicConnectionFactory(false, groupConfiguration); } else if (jmsFactoryType.equals(JMSFactoryType.XA_CF)) { factory = new ActiveMQXAConnectionFactory(false, groupConfiguration); } else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_XA_CF)) { factory = new ActiveMQXAQueueConnectionFactory(false, groupConfiguration); } else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_XA_CF)) { factory = new ActiveMQXATopicConnectionFactory(false, groupConfiguration); } return factory; }	"public static HornetQConnectionFactory createConnectionFactoryWithoutHA(final DiscoveryGroupConfiguration groupConfiguration, JMSFactoryType jmsFactoryType) {
    HornetQConnectionFactory factory = null;
    if (jmsFactoryType.equals(JMSFactoryType.CF)) {
        factory = new HornetQJMSConnectionFactory(false, groupConfiguration);
    } else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_CF)) {
        factory = new HornetQQueueConnectionFactory(false, groupConfiguration);
    } else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_CF)) {
        factory = new HornetQTopicConnectionFactory(false, groupConfiguration);
    } else if (jmsFactoryType.equals(JMSFactoryType.XA_CF)) {
        factory = new HornetQXAConnectionFactory(false, groupConfiguration);
    } else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_XA_CF)) {
        factory = new HornetQXAQueueConnectionFactory(false, groupConfiguration);
    } else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_XA_CF)) {
        factory = new HornetQXATopicConnectionFactory(false, groupConfiguration);
    }
    return factory;
}"	@return the ActiveMQConnectionFactory	@return the HornetQConnectionFactory	1	0	13	17	146
protected String computeDigest() { RelDigestWriter rdw = new RelDigestWriter(); explain(rdw); return rdw.digest; }	"  protected String computeDigest() {
    StringWriter sw = new StringWriter();
    RelWriter pw =
        new RelWriterImpl(
            new PrintWriter(sw),
            SqlExplainLevel.DIGEST_ATTRIBUTES, false) {
          protected void explain_(
              RelNode rel, List<Pair<String, Object>> values) {
            pw.write(getRelTypeName());

            for (RelTrait trait : traitSet) {
              pw.write(""."");
              pw.write(trait.toString());
            }

            pw.write(""("");
            int j = 0;
            for (Pair<String, Object> value : values) {
              if (j++ > 0) {
                pw.write("","");
              }
              pw.write(value.left);
              pw.write(""="");
              if (value.right instanceof RelNode) {
                RelNode input = (RelNode) value.right;
                pw.write(input.getRelTypeName());
                pw.write(""#"");
                pw.write(Integer.toString(input.getId()));
              } else {
                pw.write(String.valueOf(value.right));
              }
            }
            pw.write("")"");
          }
        };
    explain(pw);
    return sw.toString();
  }
"	@return Digest	@return Digest	0	1	6	6	23
public int getMaxConnections() { return getConnectionsPool().getMaxIdlePerKey(); }	"    public int getMaxConnections() {
        return getConnectionsPool().getMaxIdle();
    }
"	@return the maxConnections that will be created for this pool.	@return the maxConnections that will be created for this pool.	0	1	5	4	15
public static DateTimeFormatter weekyear() { return Constants.we; }	"    public static DateTimeFormatter weekyear() {
        return weekyearElement();
    }
"	@return a formatter for xxxx	@return a formatter for xxxx	0	1	4	4	12
private IProject getProject() { return (IProject) managedProject.getOwner(); }	"private IProject getProject() {
    return managedTarget.getOwner().getProject();
}"	@return the <code>IProject</code> associated with the managed project	@return the <code>IProject</code> associated with the target	1	0	5	3	16
public Type getParameterType(String parameterName) { return parameterTypes.get(parameterName); }	"    public Type getParameterType(String parameterName) {
	    return (Type) parameterTypes.get(parameterName);
    }
"	@return The type of the named parameter.	@return The type of the named parameter.	0	1	5	4	16
public SequenceService createSequenceService() { return createSequenceService(defaultEndpointUrl); }	"public SequenceService createSequenceService() {
    return createSequenceService(defaultServerUrl);
}"	@return a new sequence service with the default endpoint URL	@return a new sequence service with the default server URL	1	0	5	3	13
public DateTimeFormatterBuilder appendYearOfEra(int minDigits, int maxDigits) { return appendDecimal(DateTimeFieldType.yearOfEra(), minDigits, maxDigits); }	"    public DateTimeFormatterBuilder appendYearOfEra(final int minDigits, final int maxDigits) {
        return appendDecimal(iChronoUTC.yearOfEra(), minDigits, maxDigits);
    }
"	@return this DateTimeFormatterBuilder	@return this DateTimeFormatterBuilder	0	1	5	4	25
public long reorganizeSpace(Connection con, SequencerEngine seq, FxTreeMode sourceMode, FxTreeMode destMode, long nodeId, boolean includeNodeId, BigDecimal overrideSpacing, BigDecimal overrideLeft, FxTreeNodeInfo insertParent, int insertPosition, BigDecimal insertSpace, BigDecimal[] insertBoundaries, int depthDelta, Long destinationNode, boolean createMode, boolean createKeepIds) throws FxTreeException { long firstCreatedNodeId = -NUM; FxTreeNodeInfoSpreaded nodeInfo; try { nodeInfo = (FxTreeNodeInfoSpreaded) getTreeNodeInfo(con, sourceMode, nodeId); } catch (Exception e) { return -NUM; } if (!nodeInfo.isSpaceOptimizable()) { if (nodeId == ROOT_NODE) { return -NUM; } return reorganizeSpace(con, seq, sourceMode, destMode, nodeInfo.getParentId(), includeNodeId, overrideSpacing, overrideLeft, insertParent, insertPosition, insertSpace, insertBoundaries, depthDelta, destinationNode, createMode, createKeepIds); } BigDecimal SPACING = nodeInfo.getDefaultSpacing(); if (overrideSpacing != null && overrideSpacing.compareTo(SPACING) < NUM) { SPACING = overrideSpacing; } else { if (SPACING.compareTo(GO_UP) < NUM) { return reorganizeSpace(con, seq, sourceMode, destMode, nodeInfo.getParentId(), includeNodeId, overrideSpacing, overrideLeft, insertParent, insertPosition, insertSpace, insertBoundaries, depthDelta, destinationNode, createMode, createKeepIds); } } Statement stmt = null; PreparedStatement ps = null; ResultSet rs; BigDecimal left = overrideLeft == null ? nodeInfo.getLeft() : overrideLeft; BigDecimal right = null; String includeNode = includeNodeId ? STR : STR; long counter = NUM; long newId = -NUM; try { String createProps = createMode ? STR : STR; String sql = STR + createProps + STR + createProps + STR + getTable(sourceMode) + STR + STR + includeNode + nodeInfo.getLeft() + STR + includeNode + nodeInfo.getRight() + STR + STR; stmt = con.createStatement(); rs = stmt.executeQuery(sql); if (createMode) { ps = con.prepareStatement(STR + getTable(destMode) + STR + STR + STR); } else { ps = con.prepareStatement(STR + getTable(sourceMode) + STR); } long id; int total_childs; int direct_childs; BigDecimal nextLeft; int lastDepth = nodeInfo.getDepth() + (includeNodeId ? NUM : NUM); int depth; BigDecimal _rgt; BigDecimal _lft; Long ref = null; String template = null; String name = STR; Stack<Long> currentParent = null; if (createMode) { currentParent = new Stack<Long>(); currentParent.push(destinationNode); } while (rs.next()) { id = rs.getLong(NUM); total_childs = rs.getInt(NUM); direct_childs = rs.getInt(NUM); _lft = rs.getBigDecimal(NUM); _rgt = rs.getBigDecimal(NUM); depth = rs.getInt(NUM); if (createMode) { ref = rs.getLong(NUM); if (rs.wasNull()) ref = null; name = rs.getString(NUM); template = rs.getString(NUM); if (rs.wasNull()) template = null; } left = left.add(SPACING).add(BigDecimal.ONE); if (lastDepth - depth > NUM) { BigDecimal depthDifference = SPACING.add(BigDecimal.ONE); left = left.add(depthDifference.multiply(new BigDecimal(lastDepth - depth))); } if (createMode) { if (lastDepth < depth) { currentParent.push(newId); } else if (lastDepth > depth) { currentParent.pop(); } } right = left.add(SPACING).add(BigDecimal.ONE); if (total_childs > NUM) { BigDecimal childSpace = SPACING.multiply(new BigDecimal(total_childs * NUM)); childSpace = childSpace.add(new BigDecimal((total_childs * NUM) - NUM)); right = right.add(childSpace); nextLeft = left; } else { nextLeft = right; } if (insertBoundaries != null) { if (_lft.compareTo(insertBoundaries[NUM]) > NUM) { left = left.add(insertSpace); } if (_rgt.compareTo(insertBoundaries[NUM]) > NUM) { right = right.add(insertSpace); } } if (createMode) { newId = createKeepIds ? id : seq.getId(destMode.getSequencer()); if (firstCreatedNodeId == -NUM) { firstCreatedNodeId = newId; } ps.setLong(NUM, newId); ps.setLong(NUM, currentParent.peek()); ps.setLong(NUM, depth + depthDelta); ps.setBoolean(NUM, destMode != FxTreeMode.Live); if (ref == null) { ps.setNull(NUM, java.sql.Types.NUMERIC); } else { ps.setLong(NUM, ref); } if (template == null) { ps.setNull(NUM, java.sql.Types.VARCHAR); } else { ps.setString(NUM, template); } ps.setBigDecimal(NUM, left); ps.setBigDecimal(NUM, right); ps.setInt(NUM, total_childs); ps.setInt(NUM, direct_childs); ps.setString(NUM, name); ps.setLong(NUM, System.currentTimeMillis()); ps.addBatch(); } else { ps.setBigDecimal(NUM, left); ps.setBigDecimal(NUM, right); ps.setInt(NUM, depth + depthDelta); ps.setLong(NUM, id); ps.addBatch(); ps.executeBatch(); ps.clearBatch(); } left = nextLeft; lastDepth = depth; counter++; if (counter % NUM == NUM) { ps.executeBatch(); ps.clearBatch(); } } rs.close(); stmt.close(); stmt = null; ps.executeBatch(); return firstCreatedNodeId; } catch (Throwable e) { throw new FxTreeException(LOG, e, STR, counter, left, right, e.getMessage()); } finally { try { if (stmt != null) stmt.close(); } catch (Throwable t) { } try { if (ps != null) ps.close(); } catch (Throwable t) { } } }	"public boolean reorganizeSpace(Connection con, SequencerEngine seq, FxTreeMode sourceMode, FxTreeMode destMode, long nodeId, boolean includeNodeId, BigDecimal overrideSpacing, BigDecimal overrideLeft, FxTreeNodeInfo insertParent, int insertPosition, BigDecimal insertSpace, BigDecimal[] insertBoundaries, int depthDelta, Long destinationNode, boolean createMode, boolean createKeepIds, Long firstCreatedNodeId) throws FxTreeException {
    FxTreeNodeInfoSpreaded nodeInfo;
    try {
        nodeInfo = (FxTreeNodeInfoSpreaded) getTreeNodeInfo(con, sourceMode, nodeId);
    } catch (Exception e) {
        return false;
    }
    if (!nodeInfo.isSpaceOptimizable()) {
        if (nodeId == ROOT_NODE) {
            return false;
        }
        return reorganizeSpace(con, seq, sourceMode, destMode, nodeInfo.getParentId(), includeNodeId, overrideSpacing, overrideLeft, insertParent, insertPosition, insertSpace, insertBoundaries, depthDelta, destinationNode, createMode, createKeepIds, firstCreatedNodeId);
    }
    BigDecimal SPACING = nodeInfo.getDefaultSpacing();
    if (overrideSpacing != null && overrideSpacing.compareTo(SPACING) < NUM) {
        SPACING = overrideSpacing;
    } else {
        if (SPACING.compareTo(GO_UP) < NUM) {
            return reorganizeSpace(con, seq, sourceMode, destMode, nodeInfo.getParentId(), includeNodeId, overrideSpacing, overrideLeft, insertParent, insertPosition, insertSpace, insertBoundaries, depthDelta, destinationNode, createMode, createKeepIds, firstCreatedNodeId);
        }
    }
    Statement stmt = null;
    PreparedStatement ps = null;
    ResultSet rs;
    BigDecimal left = overrideLeft == null ? nodeInfo.getLeft() : overrideLeft;
    BigDecimal right = null;
    String includeNode = includeNodeId ? STR : STR;
    long counter = NUM;
    firstCreatedNodeId = -NUM;
    long newId = -NUM;
    try {
        String createProps = createMode ? STR : STR;
        String sql = STR + createProps + STR + createProps + STR + getTable(sourceMode) + STR + STR + includeNode + nodeInfo.getLeft() + STR + includeNode + nodeInfo.getRight() + STR + STR;
        stmt = con.createStatement();
        rs = stmt.executeQuery(sql);
        if (createMode) {
            ps = con.prepareStatement(STR + getTable(destMode) + STR + STR + STR);
        } else {
            ps = con.prepareStatement(STR + getTable(sourceMode) + STR);
        }
        long id;
        int total_childs;
        int direct_childs;
        BigDecimal nextLeft;
        int lastDepth = nodeInfo.getDepth() + (includeNodeId ? NUM : NUM);
        int depth;
        BigDecimal _rgt;
        BigDecimal _lft;
        Long ref = null;
        String template = null;
        String name = STR;
        Stack<Long> currentParent = null;
        if (createMode) {
            currentParent = new Stack<Long>();
            currentParent.push(destinationNode);
        }
        while (rs.next()) {
            id = rs.getLong(NUM);
            total_childs = rs.getInt(NUM);
            direct_childs = rs.getInt(NUM);
            _lft = rs.getBigDecimal(NUM);
            _rgt = rs.getBigDecimal(NUM);
            depth = rs.getInt(NUM);
            if (createMode) {
                ref = rs.getLong(NUM);
                if (rs.wasNull())
                    ref = null;
                name = rs.getString(NUM);
                template = rs.getString(NUM);
                if (rs.wasNull())
                    template = null;
            }
            left = left.add(SPACING).add(BigDecimal.ONE);
            if (lastDepth - depth > NUM) {
                BigDecimal depthDifference = SPACING.add(BigDecimal.ONE);
                left = left.add(depthDifference.multiply(new BigDecimal(lastDepth - depth)));
            }
            if (createMode) {
                if (lastDepth < depth) {
                    currentParent.push(newId);
                } else if (lastDepth > depth) {
                    currentParent.pop();
                }
            }
            right = left.add(SPACING).add(BigDecimal.ONE);
            if (total_childs > NUM) {
                BigDecimal childSpace = SPACING.multiply(new BigDecimal(total_childs * NUM));
                childSpace = childSpace.add(new BigDecimal((total_childs * NUM) - NUM));
                right = right.add(childSpace);
                nextLeft = left;
            } else {
                nextLeft = right;
            }
            if (insertBoundaries != null) {
                if (_lft.compareTo(insertBoundaries[NUM]) > NUM) {
                    left = left.add(insertSpace);
                }
                if (_rgt.compareTo(insertBoundaries[NUM]) > NUM) {
                    right = right.add(insertSpace);
                }
            }
            if (createMode) {
                newId = createKeepIds ? id : seq.getId(destMode.getSequencer());
                if (firstCreatedNodeId == -NUM) {
                    firstCreatedNodeId = newId;
                }
                ps.setLong(NUM, newId);
                ps.setLong(NUM, currentParent.peek());
                ps.setLong(NUM, depth + depthDelta);
                ps.setBoolean(NUM, destMode != FxTreeMode.Live);
                if (ref == null) {
                    ps.setNull(NUM, java.sql.Types.NUMERIC);
                } else {
                    ps.setLong(NUM, ref);
                }
                if (template == null) {
                    ps.setNull(NUM, java.sql.Types.VARCHAR);
                } else {
                    ps.setString(NUM, template);
                }
                ps.setBigDecimal(NUM, left);
                ps.setBigDecimal(NUM, right);
                ps.setInt(NUM, total_childs);
                ps.setInt(NUM, direct_childs);
                ps.setString(NUM, name);
                ps.setLong(NUM, System.currentTimeMillis());
                ps.addBatch();
            } else {
                ps.setBigDecimal(NUM, left);
                ps.setBigDecimal(NUM, right);
                ps.setInt(NUM, depth + depthDelta);
                ps.setLong(NUM, id);
                ps.addBatch();
                ps.executeBatch();
                ps.clearBatch();
            }
            left = nextLeft;
            lastDepth = depth;
            counter++;
            if (counter % NUM == NUM) {
                ps.executeBatch();
                ps.clearBatch();
            }
        }
        rs.close();
        stmt.close();
        stmt = null;
        ps.executeBatch();
        return true;
    } catch (Throwable e) {
        throw new FxTreeException(LOG, e, STR, counter, left, right, e.getMessage());
    } finally {
        try {
            if (stmt != null)
                stmt.close();
        } catch (Throwable t) {
        }
        try {
            if (ps != null)
                ps.close();
        } catch (Throwable t) {
        }
    }
}"	@return first created node id or -1 if no node was created using this method	@return true if the function was successfully	1	0	20	164	1108
public DateTimeFormatterBuilder appendHourOfHalfday(final int minDigits) { return appendDecimal(iChronoUTC.hourOfHalfday(), minDigits, 2); }	"    public DateTimeFormatterBuilder appendHourOfHalfday(final int minDigits) {
        return appendNumeric(iChronoUTC.hourOfHalfday(), minDigits, 2);
    }
"	@return this DateTimeFormatterBuilder	@return this DateTimeFormatterBuilder	0	1	5	4	23
public Collection<OsmPrimitive> getSelected() { return Collections.unmodifiableSet(selectedPrimitives); }	"public Collection<OsmPrimitive> getSelected() {
    return new ArrayList<OsmPrimitive>(selectedPrimitives);
}"	@return unmodifiable collection of primitives	@return List of all selected objects.	1	0	5	3	15
@Nullable public synchronized Habit getHabitByPosition(int position) { if (position < NUM || position >= data.habits.size()) return null; return data.habits.get(position); }	"@NonNull
public Habit getHabitByPosition(int position) {
    return data.habits.get(position);
}"	@return the habit at given position or null if position is invalid	@return the habit at given position	1	0	6	6	36
public AuditEvent convertToAuditEvent(PersistentAuditEvent persistentAuditEvent) { return new AuditEvent(Date.from(persistentAuditEvent.getAuditEventDate()), persistentAuditEvent.getPrincipal(), persistentAuditEvent.getAuditEventType(), convertDataToObjects(persistentAuditEvent.getData())); }	"    public AuditEvent convertToAuditEvent(PersistentAuditEvent persistentAuditEvent) {
        Instant instant = persistentAuditEvent.getAuditEventDate().atZone(ZoneId.systemDefault()).toInstant();
        return new AuditEvent(Date.from(instant), persistentAuditEvent.getPrincipal(),
            persistentAuditEvent.getAuditEventType(), convertDataToObjects(persistentAuditEvent.getData()));
    }
"	@return the converted list.	@return the converted list.	0	1	6	5	41
private int getColumnCount() { // Initialize currentRow = rowIterator.next(); int rowNumber = readerConfig.headerRow > 0 ? sheet.getFirstRowNum() : 0; // If the headerRow is greater than zero, advance the iterator to the first row of data // This is unfortunately necessary since the streaming reader eliminated the getRow() method. for (int i = 1; i < rowNumber; i++) { currentRow = rowIterator.next(); } return currentRow.getPhysicalNumberOfCells(); }	"  private int getColumnCount() {
    int rowNumber = readerConfig.headerRow > 0 ? sheet.getFirstRowNum() : 0;
    XSSFRow sheetRow = sheet.getRow(rowNumber);

    return sheetRow != null ? sheetRow.getPhysicalNumberOfCells() : 0;
  }
"	@return The number of actual columns	@return The number of actual columns	0	1	7	14	91
@Override public String toString() { if (stringRep == null) { stringRep = toString(true); } return stringRep; }	"public String toString(boolean altMemberSep) {
    StringBuffer s = new StringBuffer();
    if (className != null) {
        s.append(className);
    }
    if (memberName != null) {
        if (className != null) {
            s.append(altMemberSep ? ALT_MEMBER_SEPARATOR : STR);
        }
        s.append(memberName);
    }
    if (descriptor != null && (className == null || memberName != null)) {
        s.append(descriptor);
    }
    return s.toString();
}"	@return a unique representation of this member ID.	@return the signature string	1	0	8	7	25
protected RuntimeException handleAccessDeniedException(AccessDeniedException originalException) { ExceptionToCatchEvent exceptionToCatchEvent = new ExceptionToCatchEvent(originalException); this.beanManager.fireEvent(exceptionToCatchEvent); if (!exceptionToCatchEvent.isHandled()) { throw originalException; } return null; }	"private boolean handleAccessDeniedException(AccessDeniedException ade) throws AccessDeniedException {
    ExceptionToCatchEvent exceptionToCatchEvent = new ExceptionToCatchEvent(ade);
    exceptionToCatchEvent.setOptional(true);
    beanManager.fireEvent(exceptionToCatchEvent);
    if (!exceptionToCatchEvent.isHandled()) {
        throw ade;
    }
    return false;
}"	@return the original exception if the default behavior was changed and the exception is unhandled	@return False if the processing should be aborted.	1	0	6	8	40
public static Project createThermalProject(File file) { return createProject(file, THERMAL); }	"public static Project createThermalProject(File file) {
    return createProject(file, Type.THERMAL);
}"	@return the created project, or null if file was not writable or it already existed.	@return the created project, or null if file was not writable.	1	0	5	3	18
"public static String getHostFromUrl(String url) { String authority = getAuthorityFromUrl(url); // no port int idx = authority.indexOf("":""); if (idx == -1) return authority; // port, return only the portion preceding the port return authority.substring(0, idx); }"	"   public static String getHostFromUrl(String url)
   {
      // no work to do
      if (url.indexOf('/') == -1)
         return url;
      
      // presume no protocol; if present, skip those slashes
      int slashes = 0;
      if (url.contains(""://""))
         slashes += 2;
      
      // split on slashes and return first component
      String[] parts = url.split(""/"");
      if (parts.length < slashes)
         return url;
      return parts[slashes];
   }
"	@return The host, as a string.	@return Host name and port, as a string.	1	0	6	13	60
public static String formatObjectKey(String key) { int index = key == null ? -NUM : key.indexOf(STR); if (index >= NUM) { return key.substring(index + NUM); } return formatKey(key, false, true, false, true); }	"public static String formatObjectKey(String key) {
    int index = key == null ? -NUM : key.indexOf(STR);
    if (index >= NUM) {
        return key.substring(index + NUM);
    }
    return formatKey(key, false, false, false, true);
}"	@return {@link #formatKey(String, boolean, boolean, boolean)} formatColon = false, formatAt = true, formatHyphen = false, firstCase = true	@return {@link #formatKey(String, boolean, boolean, boolean)} formatColon = false, formatAt = false, formatHyphen = false, firstCase = true	1	0	8	7	54
static public String proxy(final String href) { final int hash = href.indexOf(STR); return -NUM == hash ? href : href.substring(NUM, hash); }	"static public String proxy(final String uri) {
    final int fragmentStart = uri.indexOf(STR);
    return -NUM == fragmentStart ? uri : uri.substring(NUM, fragmentStart);
}"	@return <code>href</code>, stripped of any <code>fragment</code>	@return <code>uri</code>, stripped of any <code>fragment</code>	1	0	6	4	35
public SystemUsage getUsageManager() { return this.usageManager; }	"    public UsageManager getUsageManager() {
        return this.usageManager;
    }
"	@return the usageManager	@return the usageManager	0	1	5	4	11
public Class getASTNodeType(int tokenType) { switch ( tokenType ) { case SELECT: case QUERY: return QueryNode.class; case UPDATE: return UpdateStatement.class; case DELETE: return DeleteStatement.class; case INSERT: return InsertStatement.class; case INTO: return IntoClause.class; case FROM: return FromClause.class; case FROM_FRAGMENT: return FromElement.class; case IMPLIED_FROM: return ImpliedFromElement.class; case DOT: return DotNode.class; case INDEX_OP: return IndexNode.class; // Alias references and identifiers use the same node class. case ALIAS_REF: case IDENT: return IdentNode.class; case SQL_TOKEN: return SqlFragment.class; case METHOD_CALL: return MethodNode.class; case ELEMENTS: case INDICES: return CollectionFunction.class; case SELECT_CLAUSE: return SelectClause.class; case SELECT_EXPR: return SelectExpressionImpl.class; case AGGREGATE: return AggregateNode.class; case COUNT: return CountNode.class; case CONSTRUCTOR: return ConstructorNode.class; case NUM_INT: case NUM_FLOAT: case NUM_LONG: case NUM_DOUBLE: case QUOTED_STRING: return LiteralNode.class; case TRUE: case FALSE: return BooleanLiteralNode.class; case JAVA_CONSTANT: return JavaConstantNode.class; case ORDER: return OrderByClause.class; case PLUS: case MINUS: case STAR: case DIV: return BinaryArithmeticOperatorNode.class; case UNARY_MINUS: case UNARY_PLUS: return UnaryArithmeticNode.class; case CASE2: return Case2Node.class; case CASE: return CaseNode.class; case PARAM: case NAMED_PARAM: return ParameterNode.class; case EQ: case NE: case LT: case GT: case LE: case GE: case LIKE: case NOT_LIKE: return BinaryLogicOperatorNode.class; case IN: case NOT_IN: return InLogicOperatorNode.class; case BETWEEN: case NOT_BETWEEN: return BetweenOperatorNode.class; case IS_NULL: return IsNullLogicOperatorNode.class; case IS_NOT_NULL: return IsNotNullLogicOperatorNode.class; case EXISTS: return UnaryLogicOperatorNode.class; case KEY: { return MapKeyNode.class; } case VALUE: { return MapValueNode.class; } case ENTRY: { return MapEntryNode.class; } default: return SqlNode.class; } // switch }	"	public Class getASTNodeType(int tokenType) {
		switch ( tokenType ) {
			case SELECT:
			case QUERY:
				return QueryNode.class;
			case UPDATE:
				return UpdateStatement.class;
			case DELETE:
				return DeleteStatement.class;
			case INSERT:
				return InsertStatement.class;
			case INTO:
				return IntoClause.class;
			case FROM:
				return FromClause.class;
			case FROM_FRAGMENT:
				return FromElement.class;
			case IMPLIED_FROM:
				return ImpliedFromElement.class;
			case DOT:
				return DotNode.class;
			case INDEX_OP:
				return IndexNode.class;
				// Alias references and identifiers use the same node class.
			case ALIAS_REF:
			case IDENT:
				return IdentNode.class;
			case SQL_TOKEN:
				return SqlFragment.class;
			case METHOD_CALL:
				return MethodNode.class;
			case ELEMENTS:
			case INDICES:
				return CollectionFunction.class;
			case SELECT_CLAUSE:
				return SelectClause.class;
			case SELECT_EXPR:
				return SelectExpressionImpl.class;
			case AGGREGATE:
				return AggregateNode.class;
			case COUNT:
				return CountNode.class;
			case CONSTRUCTOR:
				return ConstructorNode.class;
			case NUM_INT:
			case NUM_FLOAT:
			case NUM_LONG:
			case NUM_DOUBLE:
			case QUOTED_STRING:
				return LiteralNode.class;
			case TRUE:
			case FALSE:
				return BooleanLiteralNode.class;
			case JAVA_CONSTANT:
				return JavaConstantNode.class;
			case ORDER:
				return OrderByClause.class;
			case PLUS:
			case MINUS:
			case STAR:
			case DIV:
				return BinaryArithmeticOperatorNode.class;
			case UNARY_MINUS:
			case UNARY_PLUS:
				return UnaryArithmeticNode.class;
			case CASE2:
				return Case2Node.class;
			case CASE:
				return CaseNode.class;
			case PARAM:
			case NAMED_PARAM:
				return ParameterNode.class;
			case EQ:
			case NE:
			case LT:
			case GT:
			case LE:
			case GE:
			case LIKE:
			case NOT_LIKE:
				return BinaryLogicOperatorNode.class;
			case IN:
			case NOT_IN:
				return InLogicOperatorNode.class;
			case BETWEEN:
			case NOT_BETWEEN:
				return BetweenOperatorNode.class;
			case IS_NULL:
				return IsNullLogicOperatorNode.class;
			case IS_NOT_NULL:
				return IsNotNullLogicOperatorNode.class;
			case EXISTS:
				return UnaryLogicOperatorNode.class;
			default:
				return SqlNode.class;
		} // switch
	}
"	@return Class - The AST node class to instantiate.	@return Class - The AST node class to instantiate.	0	1	8	107	366
public static Criterion fromRawSelection(final String selection, final String[] selectionArgs) { if (TextUtils.isEmpty(selection)) { return null; } return new Criterion(null) { @Override protected void populate(SqlBuilder builder, boolean forSqlValidation) { builder.sql.append(selection); if (selectionArgs != null && selectionArgs.length > NUM) { if (builder.args == null) { throw new UnsupportedOperationException(STR + STR); } Collections.addAll(builder.args, selectionArgs); } } }; }	"public static Criterion fromRawSelection(final String selection, final String[] selectionArgs) {
    if (TextUtils.isEmpty(selection)) {
        return Criterion.all;
    }
    return new Criterion(null) {

        @Override
        protected void populate(SqlBuilder builder, boolean forSqlValidation) {
            builder.sql.append(selection);
            if (selectionArgs != null && selectionArgs.length > NUM) {
                if (builder.args == null) {
                    throw new UnsupportedOperationException(STR + STR);
                }
                Collections.addAll(builder.args, selectionArgs);
            }
        }
    };
}"	@return a {@link Criterion} that evaluates the raw selection and selection args. If the selection string is empty, this will return null.	@return a {@link Criterion} that evaluates the raw selection and selection args	1	0	13	18	99
protected Object convertTimestampToEpochMicros(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0L; // return epoch } try { return MicroTimestamp.toEpochMicros(data, adjuster); } catch (IllegalArgumentException e) { return handleUnknownData(column, fieldDefn, data); } }	"    protected Object convertTimestampToEpochMicros(Column column, Field fieldDefn, Object data) {
        if (data == null) {
            data = fieldDefn.schema().defaultValue();
        }
        if (data == null) {
            if (column.isOptional()) return null;
            return 0L; // return epoch
        }
        try {
            return MicroTimestamp.toEpochMicros(data);
        } catch (IllegalArgumentException e) {
            return handleUnknownData(column, fieldDefn, data);
        }
    }
"	@return the converted value, or null if the conversion could not be made and the column allows nulls	@return the converted value, or null if the conversion could not be made and the column allows nulls	0	1	8	15	84
protected boolean isRunning() { return this.runningThread.get() != null; }	"    protected boolean isRunning() {
        return this.running.get();
    }
"	@return  true if running, or  false otherwise	@return true if running, or false otherwise	0	1	6	4	16
public int compareTo(IndexedWord w) { if (this.equals(IndexedWord.NO_WORD)) { if (w.equals(IndexedWord.NO_WORD)) { return 0; } else { return -1; } } if (w.equals(IndexedWord.NO_WORD)) { return 1; } // Override the default comparator if pseudo-positions are set. // This is needed for splicing trees together awkwardly in OpenIE. if (!Double.isNaN(w.pseudoPosition) || !Double.isNaN(this.pseudoPosition)) { double val = this.pseudoPosition() - w.pseudoPosition(); if (val < 0) { return -1; } if (val > 0) { return 1; } else { return 0; } } // Otherwise, compare using the normal doc/sentence/token index hierarchy String docID = this.getString(CoreAnnotations.DocIDAnnotation.class); int docComp = docID.compareTo(w.getString(CoreAnnotations.DocIDAnnotation.class)); if (docComp != 0) return docComp; int sentComp = Integer.compare(sentIndex(), w.sentIndex()); if (sentComp != 0) return sentComp; int indexComp = Integer.compare(index(), w.index()); if (indexComp != 0) return indexComp; return Integer.compare(copyCount(), w.copyCount()); }	"  public int compareTo(IndexedWord w) {
    if (this.equals(IndexedWord.NO_WORD)) {
      if (w.equals(IndexedWord.NO_WORD)) {
        return 0;
      } else {
        return -1;
      }
    }
    if (w.equals(IndexedWord.NO_WORD)) {
      return 1;
    }

    // Override the default comparator if pseudo-positions are set.
    // This is needed for splicing trees together awkwardly in OpenIE.
    if (!Double.isNaN(w.pseudoPosition) || !Double.isNaN(this.pseudoPosition)) {
      double val = this.pseudoPosition() - w.pseudoPosition();
      if (val < 0) { return -1; }
      if (val > 0) { return 1; }
      else { return 0; }
    }

    // Otherwise, compare using the normal doc/sentence/token index hierarchy
    String docID = this.getString(CoreAnnotations.DocIDAnnotation.class);
    int docComp = docID.compareTo(w.getString(CoreAnnotations.DocIDAnnotation.class));
    if (docComp != 0) return docComp;

    int sentComp = sentIndex() - w.sentIndex();
    if (sentComp != 0) return sentComp;

    int indexComp = index() - w.index();
    if (indexComp != 0) return indexComp;

    return copyCount() - w.copyCount();
  }
"	@return Whether this is less than w or not in the ordering	@return Whether this is less than w or not in the ordering	0	1	9	35	249
public String getMergePolicy() { return mergePolicyConfig.getPolicy(); }	"public String getMergePolicy() {
    return mergePolicy;
}"	@return the merge policy classname	@return the updated map configuration	1	0	4	3	13
public SubselectFetch getSubselect(EntityKey key) { return subselectsByEntityKey.get( key ); }	"	public SubselectFetch getSubselect(EntityKey key) {
		return (SubselectFetch) subselectsByEntityKey.get(key);
	}
"	@return The fetch descriptor; may return null if no subselect fetch queued for this entity key.	@return The fetch descriptor; may return null if no subselect fetch queued for this entity key.	0	1	5	4	16
public int getMonth() { return date.getMonthValue(); }	"public int getMonth() {
    return month;
}"	@return the month of the year as defined by {@linkplain LocalDate}	@return the month of the year as defined by {@linkplain Calendar}	1	0	4	3	13
protected CompletableFuture<ExecutionResult> resolveField(ExecutionContext executionContext, ExecutionStrategyParameters parameters) { return resolveFieldWithInfo(executionContext,parameters).thenCompose(FieldValueInfo::getFieldValue); }	"    protected CompletableFuture<ExecutionResult> resolveField(ExecutionContext executionContext, ExecutionStrategyParameters parameters) {
        GraphQLFieldDefinition fieldDef = getFieldDef(executionContext, parameters, parameters.getField().get(0));

        Instrumentation instrumentation = executionContext.getInstrumentation();
        InstrumentationContext<ExecutionResult> fieldCtx = instrumentation.beginField(
                new InstrumentationFieldParameters(executionContext, fieldDef, fieldTypeInfo(parameters, fieldDef))
        );

        CompletableFuture<ExecutionResult> result = fetchField(executionContext, parameters)
                .thenCompose((fetchedValue) ->
                        completeField(executionContext, parameters, fetchedValue));

        fieldCtx.onDispatched(result);
        result.whenComplete(fieldCtx::onCompleted);
        return result;
    }
"	@return a promise to an  ExecutionResult	@return an ExecutionResult	1	0	7	4	28
protected Object convertDecimal(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return new BigDecimal(0); } BigDecimal decimal = null; if (data instanceof BigDecimal) decimal = (BigDecimal) data; else if (data instanceof Boolean) decimal = new BigDecimal(((Boolean) data).booleanValue() ? 1 : 0); else if (data instanceof Short) decimal = new BigDecimal(((Short) data).intValue()); else if (data instanceof Integer) decimal = new BigDecimal(((Integer) data).intValue()); else if (data instanceof Long) decimal = BigDecimal.valueOf(((Long) data).longValue()); else if (data instanceof Float) decimal = BigDecimal.valueOf(((Float) data).doubleValue()); else if (data instanceof Double) decimal = BigDecimal.valueOf(((Double) data).doubleValue()); else { return handleUnknownData(column, fieldDefn, data); } return decimal; }	"    protected Object convertDecimal(Column column, Field fieldDefn, Object data) {
        if (data == null) return null;
        BigDecimal decimal = null;
        if (data instanceof BigDecimal)
            decimal = (BigDecimal) data;
        else if (data instanceof Boolean)
            decimal = new BigDecimal(((Boolean) data).booleanValue() ? 1 : 0);
        else if (data instanceof Short)
            decimal = new BigDecimal(((Short) data).intValue());
        else if (data instanceof Integer)
            decimal = new BigDecimal(((Integer) data).intValue());
        else if (data instanceof Long)
            decimal = BigDecimal.valueOf(((Long) data).longValue());
        else if (data instanceof Float)
            decimal = BigDecimal.valueOf(((Float) data).doubleValue());
        else if (data instanceof Double)
            decimal = BigDecimal.valueOf(((Double) data).doubleValue());
        else {
            return handleUnknownData(column, fieldDefn, data);
        }
        return decimal;
    }
"	@return the converted value, or null if the conversion could not be made and the column allows nulls	@return the converted value, or null if the conversion could not be made	1	0	14	29	223
public Map<String, InternalPortletPreference> getStoredPreferences(PortletWindow portletWindow, PortletRequest request) throws PortletContainerException { String key = getFormattedKey(portletWindow, request); Map<String, InternalPortletPreference> preferences = storage.get(key); if (preferences == null) { if (LOG.isDebugEnabled()) { LOG.debug(STR + key); } return Collections.emptyMap(); } else { if (LOG.isDebugEnabled()) { LOG.debug(STR + preferences.size() + STR); } return clonePreferences(preferences); } }	"public InternalPortletPreference[] getStoredPreferences(PortletWindow portletWindow, PortletRequest request) throws PortletContainerException {
    String key = getFormattedKey(portletWindow, request);
    InternalPortletPreference[] preferences = storage.get(key);
    if (preferences == null) {
        if (LOG.isDebugEnabled()) {
            LOG.debug(STR + key);
        }
        return new InternalPortletPreference[NUM];
    } else {
        if (LOG.isDebugEnabled()) {
            LOG.debug(STR + preferences.length + STR);
        }
        return clonePreferences(preferences);
    }
}"	@return a copy of the stored portlet preferences map.	@return a copy of the stored portlet preferences array.	1	0	11	15	98
public boolean isSessionToken(String site, String token) { HashSet<String> siteTokens = sessionTokens.get(site); if (siteTokens == null) return false; return siteTokens.contains(token.toLowerCase(Locale.ENGLISH)); }	"	public boolean isSessionToken(String site, String token) {
		HashSet<String> siteTokens = sessionTokens.get(site);
		if (siteTokens == null)
			return false;
		return siteTokens.contains(token.toLowerCase());
	}
"	@return true, if it is session token	@return true, if it is session token	0	1	6	7	41
public static SocketInputWrapper getInputStream(Socket socket, long timeout) throws IOException { InputStream stm = (socket.getChannel() == null) ? socket.getInputStream() : new SocketInputStream(socket); SocketInputWrapper w = new SocketInputWrapper(socket, stm); w.setTimeout(timeout); return w; }	"public static InputStream getInputStream(Socket socket, long timeout) throws IOException {
    return (socket.getChannel() == null) ? socket.getInputStream() : new SocketInputStream(socket, timeout);
}"	@return SocketInputWrapper for reading from the socket.	@return InputStream for reading from the socket.	1	0	7	6	55
public long addWrapField(long instant, int months) { return set(instant, FieldUtils.getWrappedValue(get(instant), months, MIN, iMax)); }	"    public long addWrapField(long instant, int months) {
        return set(instant, FieldUtils.getWrappedValue(get(instant), months, MIN, MAX));
    }
"	@return the updated time instant.	@return the updated time instant.	0	1	7	4	33
protected Class<T> getConfigurationClass() { return (Class<T>) Generics.getTypeParameter(getClass(), Configuration.class); }	"    protected Class<T> getConfigurationClass() {
        return (Class<T>) Generics.getTypeParameter(getClass());
    }
"	@return the  Class of the configuration type	@return the Class of the configuration type	0	1	7	4	24
public static ParameterMemento fromRegistration(ParameterRegistrationImplementor registration) { return new ParameterMemento( registration.getPosition(), registration.getName(), registration.getMode(), registration.getParameterType(), registration.getHibernateType(), registration.isPassNullsEnabled() ); }	"		public static ParameterMemento fromRegistration(ParameterRegistrationImplementor registration) {
			return new ParameterMemento(
					registration.getPosition(),
					registration.getName(),
					registration.getMode(),
					registration.getType(),
					registration.getHibernateType(),
					registration.isPassNullsEnabled()
			);
		}
"	@return The memento	@return The memento	0	1	5	11	45
public Item[] getItems() { return (Item[]) items.values().toArray(new Item[items.values().size()]); }	"public Iterator getItems() {
    return items.values().iterator();
}"	@return an array of items	@return an <code>Iterator</code>	1	0	9	3	34
public Report findOneThrowExceptionIfNotFound(final Long id) { return this.reportRepository.findById(id) .orElseThrow(() -> new ReportNotFoundException(id)); }	"    public Report findOneThrowExceptionIfNotFound(final Long id) {
        final Report report = this.reportRepository.findOne(id);
        
        if (report == null) {
            throw new ReportNotFoundException(id);
        }
        
        return report;
    }
"	@return  Report object	@return Report object	0	1	8	5	29
public static Query parse(String queryString, BulletConfig config) { Query query = GSON.fromJson(queryString, Query.class); query.configure(config); return query; }	"public static Specification parse(String queryString, BulletConfig config) {
    Specification specification = GSON.fromJson(queryString, Specification.class);
    specification.configure(config);
    return specification;
}"	@return The parsed, configured Query.	@return The parsed, configured Specification.	1	0	7	5	33
public boolean isEmpty() { return pendingCount <= NUM; }	"public boolean isEmpty() {
    return empty;
}"	@return true if there are no pendingCount messages	@return true if there are no pending messages	1	0	5	3	11
public OfflinePlayer asOfflinePlayer() { return Bukkit.getOfflinePlayer(raw); }	"public OfflinePlayer asOfflinePlayer() {
    return Bukkit.getOfflinePlayer(arg);
}"	@return The offline player by the name of the raw raw	@return The offline player by the name of the raw arg	1	0	5	3	14
private static Class getVMPrimitiveType(final String name) { return VM_PRIMITIVES.get(name); }	"    private static Class getVMPrimitiveType(final String name) {
        return (Class) VM_PRIMITIVES.get(name);
    }
"	@return Primitive type or null.	@return Primitive type or null.	0	1	5	4	18
"public Object getValue(PgProto.DatumMessage datumMessage, PgConnectionSupplier connection, boolean includeUnknownDatatypes) { int columnType = (int) datumMessage.getColumnType(); switch (columnType) { case PgOid.BOOL: return datumMessage.hasDatumBool() ? datumMessage.getDatumBool() : null; case PgOid.INT2: case PgOid.INT4: return datumMessage.hasDatumInt32() ? datumMessage.getDatumInt32() : null; case PgOid.INT8: case PgOid.OID: case PgOid.MONEY: return datumMessage.hasDatumInt64() ? datumMessage.getDatumInt64() : null; case PgOid.FLOAT4: return datumMessage.hasDatumFloat()? datumMessage.getDatumFloat() : null; case PgOid.FLOAT8: return datumMessage.hasDatumDouble() ? datumMessage.getDatumDouble() : null; case PgOid.NUMERIC: if (datumMessage.hasDatumDouble()) { return datumMessage.getDatumDouble(); } else if (datumMessage.hasDatumString()) { final String s = datumMessage.getDatumString(); final SpecialValue v = PostgresValueConverter.toSpecialValue(s); return v != null ? v : new BigDecimal(s); } return null; case PgOid.CHAR: case PgOid.VARCHAR: case PgOid.BPCHAR: case PgOid.TEXT: case PgOid.JSON: case PgOid.JSONB_OID: case PgOid.XML: case PgOid.UUID: case PgOid.BIT: case PgOid.VARBIT: return datumMessage.hasDatumString() ? datumMessage.getDatumString() : null; case PgOid.DATE: return datumMessage.hasDatumInt32() ? (long) datumMessage.getDatumInt32() : null; case PgOid.TIMESTAMP: case PgOid.TIMESTAMPTZ: case PgOid.TIME: if (!datumMessage.hasDatumInt64()) { return null; } // these types are sent by the plugin as LONG - microseconds since Unix Epoch // but we'll convert them to nanos which is the smallest unit return TimeUnit.NANOSECONDS.convert(datumMessage.getDatumInt64(), TimeUnit.MICROSECONDS); case PgOid.TIMETZ: if (!datumMessage.hasDatumDouble()) { return null; } // the value is sent as a double microseconds, convert to nano return BigDecimal.valueOf(datumMessage.getDatumDouble() * 1000).longValue(); case PgOid.INTERVAL: // these are sent as doubles by the plugin since their storage is larger than 8 bytes return datumMessage.hasDatumDouble() ? datumMessage.getDatumDouble() : null; // the plugin will send back a TZ formatted string case PgOid.BYTEA: return datumMessage.hasDatumBytes() ? datumMessage.getDatumBytes().toByteArray() : null; case PgOid.POINT: { PgProto.Point datumPoint = datumMessage.getDatumPoint(); return new PGpoint(datumPoint.getX(), datumPoint.getY()); } case PgOid.TSTZRANGE_OID: return datumMessage.hasDatumBytes() ? new String(datumMessage.getDatumBytes().toByteArray(), Charset.forName(""UTF-8"")) : null; case PgOid.INT2_ARRAY: case PgOid.INT4_ARRAY: case PgOid.INT8_ARRAY: case PgOid.TEXT_ARRAY: case PgOid.NUMERIC_ARRAY: case PgOid.FLOAT4_ARRAY: case PgOid.FLOAT8_ARRAY: case PgOid.BOOL_ARRAY: case PgOid.DATE_ARRAY: case PgOid.TIME_ARRAY: case PgOid.TIMETZ_ARRAY: case PgOid.TIMESTAMP_ARRAY: case PgOid.TIMESTAMPTZ_ARRAY: case PgOid.BYTEA_ARRAY: case PgOid.VARCHAR_ARRAY: case PgOid.OID_ARRAY: case PgOid.BPCHAR_ARRAY: case PgOid.MONEY_ARRAY: case PgOid.NAME_ARRAY: case PgOid.INTERVAL_ARRAY: case PgOid.CHAR_ARRAY: case PgOid.VARBIT_ARRAY: case PgOid.UUID_ARRAY: case PgOid.XML_ARRAY: case PgOid.POINT_ARRAY: case PgOid.JSONB_ARRAY: case PgOid.JSON_ARRAY: case PgOid.REF_CURSOR_ARRAY: return getArray(datumMessage, connection, columnType); case PgOid.UNSPECIFIED: return null; default: PostgresType type = typeRegistry.get(columnType); if (type.getOid() == typeRegistry.geometryOid() || type.getOid() == typeRegistry.geographyOid() ) { return datumMessage.getDatumBytes().toByteArray(); } if (type.getOid() == typeRegistry.geometryArrayOid() || type.getOid() == typeRegistry.geographyArrayOid() ) { return getArray(datumMessage, connection, columnType); } // unknown datatype is sent by decoder as binary value if (includeUnknownDatatypes && datumMessage.hasDatumBytes()) { return datumMessage.getDatumBytes().toByteArray(); } return null; } }"	"    public Object getValue(PgProto.DatumMessage datumMessage, PgConnectionSupplier connection, boolean includeUnknownDatatypes) {
        int columnType = (int) datumMessage.getColumnType();
        switch (columnType) {
            case PgOid.BOOL:
                return datumMessage.hasDatumBool() ? datumMessage.getDatumBool() : null;
            case PgOid.INT2:
            case PgOid.INT4:
                return datumMessage.hasDatumInt32() ? datumMessage.getDatumInt32() : null;
            case PgOid.INT8:
            case PgOid.OID:
            case PgOid.MONEY:
                return datumMessage.hasDatumInt64() ? datumMessage.getDatumInt64() : null;
            case PgOid.FLOAT4:
                return datumMessage.hasDatumFloat()? datumMessage.getDatumFloat() : null;
            case PgOid.FLOAT8:
            case PgOid.NUMERIC:
                return datumMessage.hasDatumDouble() ? datumMessage.getDatumDouble() : null;
            case PgOid.CHAR:
            case PgOid.VARCHAR:
            case PgOid.BPCHAR:
            case PgOid.TEXT:
            case PgOid.JSON:
            case PgOid.JSONB_OID:
            case PgOid.XML:
            case PgOid.UUID:
            case PgOid.BIT:
            case PgOid.VARBIT:
                return datumMessage.hasDatumString() ? datumMessage.getDatumString() : null;
            case PgOid.DATE:
                return datumMessage.hasDatumInt32() ? (long) datumMessage.getDatumInt32() : null;
            case PgOid.TIMESTAMP:
            case PgOid.TIMESTAMPTZ:
            case PgOid.TIME:
                if (!datumMessage.hasDatumInt64()) {
                    return null;
                }
                // these types are sent by the plugin as LONG - microseconds since Unix Epoch
                // but we'll convert them to nanos which is the smallest unit
                return TimeUnit.NANOSECONDS.convert(datumMessage.getDatumInt64(), TimeUnit.MICROSECONDS);
            case PgOid.TIMETZ:
                if (!datumMessage.hasDatumDouble()) {
                    return null;
                }
                // the value is sent as a double microseconds, convert to nano
                return BigDecimal.valueOf(datumMessage.getDatumDouble() * 1000).longValue();
            case PgOid.INTERVAL:
                // these are sent as doubles by the plugin since their storage is larger than 8 bytes
                return datumMessage.hasDatumDouble() ? datumMessage.getDatumDouble() : null;
            // the plugin will send back a TZ formatted string
            case PgOid.BYTEA:
                return datumMessage.hasDatumBytes() ? datumMessage.getDatumBytes().toByteArray() : null;
            case PgOid.POINT: {
                PgProto.Point datumPoint = datumMessage.getDatumPoint();
                return new PGpoint(datumPoint.getX(), datumPoint.getY());
            }
            case PgOid.TSTZRANGE_OID:
                return datumMessage.hasDatumBytes() ? new String(datumMessage.getDatumBytes().toByteArray(), Charset.forName(""UTF-8"")) : null;
            case PgOid.INT2_ARRAY:
            case PgOid.INT4_ARRAY:
            case PgOid.INT8_ARRAY:
            case PgOid.TEXT_ARRAY:
            case PgOid.NUMERIC_ARRAY:
            case PgOid.FLOAT4_ARRAY:
            case PgOid.FLOAT8_ARRAY:
            case PgOid.BOOL_ARRAY:
            case PgOid.DATE_ARRAY:
            case PgOid.TIME_ARRAY:
            case PgOid.TIMETZ_ARRAY:
            case PgOid.TIMESTAMP_ARRAY:
            case PgOid.TIMESTAMPTZ_ARRAY:
            case PgOid.BYTEA_ARRAY:
            case PgOid.VARCHAR_ARRAY:
            case PgOid.OID_ARRAY:
            case PgOid.BPCHAR_ARRAY:
            case PgOid.MONEY_ARRAY:
            case PgOid.NAME_ARRAY:
            case PgOid.INTERVAL_ARRAY:
            case PgOid.CHAR_ARRAY:
            case PgOid.VARBIT_ARRAY:
            case PgOid.UUID_ARRAY:
            case PgOid.XML_ARRAY:
            case PgOid.POINT_ARRAY:
            case PgOid.JSONB_ARRAY:
            case PgOid.JSON_ARRAY:
            case PgOid.REF_CURSOR_ARRAY:
                return getArray(datumMessage, connection, columnType);

            case PgOid.UNSPECIFIED:
                return null;

            default:
                PostgresType type = typeRegistry.get(columnType);
                if (type.getOid() == typeRegistry.geometryOid() || type.getOid() == typeRegistry.geographyOid() ) {
                    return datumMessage.getDatumBytes().toByteArray();
                }
                if (type.getOid() == typeRegistry.geometryArrayOid() || type.getOid() == typeRegistry.geographyArrayOid() ) {
                    return getArray(datumMessage, connection, columnType);
                }

                // unknown datatype is sent by decoder as binary value
                if (includeUnknownDatatypes && datumMessage.hasDatumBytes()) {
                    return datumMessage.getDatumBytes().toByteArray();
                }

                return null;
        }
    }
"	@return the value; may be null	@return the value; may be null	0	1	11	117	748
private Object getIdFromParameter() { String parameter = FacesUtils.getParameter(ID); if (parameter == null || parameter.isEmpty()) { return null; } try { Class idType = EntityUtils.getIdType(entityClass); if (idType.equals(Long.class)) { return Long.parseLong(StringUtils.getOnlyIntegerNumbers(parameter)); } else if (idType.equals(Integer.class)) { return Integer.parseInt(StringUtils.getOnlyIntegerNumbers(parameter)); } else { logger.log(Level.SEVERE, STR, new Object[] { idType.getName(), entityClass.getName() }); return null; } } catch (NumberFormatException ex) { return null; } }	"private Long getIdFromParameter() {
    String parameter = FacesUtils.getParameter(ID);
    if (parameter == null || parameter.isEmpty()) {
        return null;
    }
    try {
        return Long.parseLong(StringUtils.getOnlyIntegerNumbers(parameter));
    } catch (NumberFormatException ex) {
        return null;
    }
}"	@return A Number instance of id passed in parameter	@return A Long instance of id passed in parameter	1	0	11	19	128
public EigenbaseException newValidationSignatureError() { return validator.newValidationError(call, RESOURCE.canNotApplyOp2Type(getOperator().getName(), call.getCallSignature(validator, scope), getOperator().getAllowedSignatures())); }	"  public EigenbaseException newValidationSignatureError() {
    return validator.newValidationError(
        call,
        EigenbaseResource.instance().CanNotApplyOp2Type.ex(
            getOperator().getName(),
            call.getCallSignature(validator, scope),
            getOperator().getAllowedSignatures()));
  }
"	@return signature exception	@return signature exception	0	1	7	7	40
"public String getResourceManagerId() throws JMSException { if (isRmIdFromConnectionId()) { return info.getConnectionId().getValue(); } waitForBrokerInfo(); if (brokerInfo == null) { throw new JMSException(""Connection failed before Broker info was received.""); } return brokerInfo.getBrokerId().getValue(); }"	"    public String getResourceManagerId() throws JMSException {
        waitForBrokerInfo();
        if (brokerInfo == null) {
            throw new JMSException(""Connection failed before Broker info was received."");
        }
        return brokerInfo.getBrokerId().getValue();
    }
"	@return Returns the resourceManagerId.	@return Returns the resourceManagerId.	0	1	7	11	61
public CalendarDay getSelectedDate() { List<CalendarDay> dates = adapter.getSelectedDates(); if (dates.isEmpty()) { return null; } else { return dates.get(dates.size() - NUM); } }	"public CalendarDay getSelectedDate() {
    return adapter.getSelectedDate();
}"	@return the selected day, or null if no selection. If in multiple selection mode, this will return the last selected date	@return the currently selected day, or null if no selection	1	0	8	8	42
protected String getUrlProtocol() { return STR + (getPort() > NUM ? getPort() : DEFAULT_PORT) + STR; }	"protected String getUrlProtocol() {
    return PROTOCOL;
}"	@return Returns protocol	@return Always returns {@link DerbyDatabase#PROTOCOL}.	1	0	8	3	25
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; // set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { String str = yytext(); int first = str.codePointAt(0); String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } logger.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: logger.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 67: break; case 2: { return getNext(""<"", yytext()); } case 68: break; case 3: { return getNext(); } case 69: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 70: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 71: break; case 6: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 72: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 73: break; case 8: { return handleQuotes(yytext(), false); } case 74: break; case 9: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 75: break; case 10: { return getNext("">"", yytext()); } case 76: break; case 11: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 77: break; case 12: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 78: break; case 13: { return handleEllipsis(yytext()); } case 79: break; case 14: { return normalizeFractions(yytext()); } case 80: break; case 15: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(minimallyNormalizeCurrency(yytext()), yytext()); } } case 81: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 82: break; case 17: { if (normalizeOtherBrackets) { return getNext(""-RSB-"", yytext()); } else { return getNext(); } } case 83: break; case 18: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 84: break; case 19: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 85: break; case 20: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 86: break; case 21: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 87: break; case 22: { if (normalizeOtherBrackets) { return getNext(""-LSB-"", yytext()); } else { return getNext(); } } case 88: break; case 23: { if (invertible) { prevWordAfter.append(yytext()); } } case 89: break; case 24: { return getNext(""\u2022"", yytext()); } case 90: break; case 25: { return getNext(""\u2122"", yytext()); } case 91: break; case 26: // general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 92: break; case 27: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(); } case 93: break; case 28: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return handleQuotes(yytext(), true); } case 94: break; case 29: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 95: break; case 30: { breakByHyphens(yytext()); return getNext(removeSoftHyphens(yytext()), yytext()); } case 96: break; case 31: // general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 97: break; case 32: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 98: break; case 33: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 99: break; case 34: { // this one should only match if we're basically at the end of file // since the last one matches two things, even newlines (if not tokenize per line) String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 100: break; case 35: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 101: break; case 36: // lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 1); { /* invert quote - often but not always right */ return handleQuotes(yytext(), true); } case 102: break; case 37: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return handleQuotes(yytext(), false); } case 103: break; case 38: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 104: break; case 39: { String txt = yytext(); // if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space... if (strictTreebank3) { int spaceIndex = indexOfSpace(txt); if (spaceIndex >= 0) { yypushback(txt.length() - spaceIndex); String newText = yytext(); return getNext(newText, newText); } } if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, txt); } case 105: break; case 40: { return getNormalizedAmpNext(); } case 106: break; case 41: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, origTxt); } case 107: break; case 42: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space } return getNext(txt, origTxt); } case 108: break; case 43: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 109: break; case 44: { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 110: break; case 45: // general lookahead, find correct zzMarkedPos { int zzFState = 17; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 111: break; case 46: // lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 112: break; case 47: // general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 113: break; case 48: // general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 22; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 114: break; case 49: // general lookahead, find correct zzMarkedPos { int zzFState = 18; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 19; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 115: break; case 50: // general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 116: break; case 51: // general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 21; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 117: break; case 52: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 118: break; case 53: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { breakByHyphens(yytext()); return getNext(removeSoftHyphens(yytext()), yytext()); } case 119: break; case 54: { if (splitAssimilations) { yypushback(3) ; return getNext(); } else { return getNext(); } } case 120: break; case 55: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNormalizedAmpNext(); } case 121: break; case 56: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 9; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 122: break; case 57: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { return getNext(); } case 123: break; case 58: // general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 124: break; case 59: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 125: break; case 60: // general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 13; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 126: break; case 61: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } return getNext(txt, yytext()); } case 127: break; case 62: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4); { return getNext(); } case 128: break; case 63: // lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { return getNext(); } case 129: break; case 64: { String txt = yytext(); if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 130: break; case 65: // general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 25; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 131: break; case 66: // general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 24; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 132: break; default: zzScanError(ZZ_NO_MATCH); } } } }"	"  public Object next() throws java.io.IOException {
    int zzInput;
    int zzAction;

    // cached fields:
    int zzCurrentPosL;
    int zzMarkedPosL;
    int zzEndReadL = zzEndRead;
    char [] zzBufferL = zzBuffer;
    char [] zzCMapL = ZZ_CMAP;

    int [] zzTransL = ZZ_TRANS;
    int [] zzRowMapL = ZZ_ROWMAP;
    int [] zzAttrL = ZZ_ATTRIBUTE;

    while (true) {
      zzMarkedPosL = zzMarkedPos;

      yychar+= zzMarkedPosL-zzStartRead;

      zzAction = -1;

      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
  
      zzState = ZZ_LEXSTATE[zzLexicalState];

      // set up zzAction for empty match case:
      int zzAttributes = zzAttrL[zzState];
      if ( (zzAttributes & 1) == 1 ) {
        zzAction = zzState;
      }


      zzForAction: {
        while (true) {
    
          if (zzCurrentPosL < zzEndReadL) {
            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);
            zzCurrentPosL += Character.charCount(zzInput);
          }
          else if (zzAtEOF) {
            zzInput = YYEOF;
            break zzForAction;
          }
          else {
            // store back cached positions
            zzCurrentPos  = zzCurrentPosL;
            zzMarkedPos   = zzMarkedPosL;
            boolean eof = zzRefill();
            // get translated positions and possibly new buffer
            zzCurrentPosL  = zzCurrentPos;
            zzMarkedPosL   = zzMarkedPos;
            zzBufferL      = zzBuffer;
            zzEndReadL     = zzEndRead;
            if (eof) {
              zzInput = YYEOF;
              break zzForAction;
            }
            else {
              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);
              zzCurrentPosL += Character.charCount(zzInput);
            }
          }
          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
          if (zzNext == -1) break zzForAction;
          zzState = zzNext;

          zzAttributes = zzAttrL[zzState];
          if ( (zzAttributes & 1) == 1 ) {
            zzAction = zzState;
            zzMarkedPosL = zzCurrentPosL;
            if ( (zzAttributes & 8) == 8 ) break zzForAction;
          }

        }
      }

      // store back cached position
      zzMarkedPos = zzMarkedPosL;

      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
        zzAtEOF = true;
              {
                if (invertible) {
            prevWordAfter.append(yytext());
            String str = prevWordAfter.toString();
            prevWordAfter.setLength(0);
            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);
          }
          return null;
              }
      }
      else {
        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
          case 1: 
            { String str = yytext();
          int first = str.codePointAt(0);
          String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));
          switch (untokenizable) {
            case NONE_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              break;
            case FIRST_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              if ( ! this.seenUntokenizableCharacter) {
                logger.warning(msg);
                this.seenUntokenizableCharacter = true;
              }
              break;
            case ALL_DELETE:
              if (invertible) {
                prevWordAfter.append(str);
              }
              logger.warning(msg);
              this.seenUntokenizableCharacter = true;
              break;
            case NONE_KEEP:
              return getNext();
            case FIRST_KEEP:
              if ( ! this.seenUntokenizableCharacter) {
                logger.warning(msg);
                this.seenUntokenizableCharacter = true;
              }
              return getNext();
            case ALL_KEEP:
              logger.warning(msg);
              this.seenUntokenizableCharacter = true;
              return getNext();
          }
            }
          case 67: break;
          case 2: 
            { return getNext(""<"", yytext());
            }
          case 68: break;
          case 3: 
            { return getNext();
            }
          case 69: break;
          case 4: 
            { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {
                    return getNext(ptbmdash, yytext());
                  } else {
                    return getNext();
                  }
            }
          case 70: break;
          case 5: 
            { if (tokenizeNLs) {
                      return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns
                  } else if (invertible) {
                      prevWordAfter.append(yytext());
                  }
            }
          case 71: break;
          case 6: 
            { final String origTxt = yytext();
                          String tmp = removeSoftHyphens(origTxt);
                          if (americanize) {
                            tmp = Americanize.americanize(tmp);
                          }
                          return getNext(tmp, origTxt);
            }
          case 72: break;
          case 7: 
            { if (invertible) {
                     prevWordAfter.append(yytext());
                  }
            }
          case 73: break;
          case 8: 
            { return handleQuotes(yytext(), false);
            }
          case 74: break;
          case 9: 
            { if (escapeForwardSlashAsterisk) {
                    return getNext(delimit(yytext(), '/'), yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 75: break;
          case 10: 
            { return getNext("">"", yytext());
            }
          case 76: break;
          case 11: 
            { if (ptb3Dashes) {
                            return getNext(ptbmdash, yytext()); }
                          else {
                            return getNext();
                          }
            }
          case 77: break;
          case 12: 
            { return getNext(removeSoftHyphens(yytext()),
                                         yytext());
            }
          case 78: break;
          case 13: 
            { return handleEllipsis(yytext());
            }
          case 79: break;
          case 14: 
            { return normalizeFractions(yytext());
            }
          case 80: break;
          case 15: 
            { if (normalizeCurrency) {
                            return getNext(normalizeCurrency(yytext()), yytext());
			  } else {
                            return getNext(minimallyNormalizeCurrency(yytext()), yytext());
                          }
            }
          case 81: break;
          case 16: 
            { if (normalizeOtherBrackets) {
                    return getNext(closebrace, yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 82: break;
          case 17: 
            { if (normalizeParentheses) {
                    return getNext(openparen, yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 83: break;
          case 18: 
            { if (normalizeParentheses) {
                    return getNext(closeparen, yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 84: break;
          case 19: 
            { if (escapeForwardSlashAsterisk) {
                    return getNext(delimit(yytext(), '*'), yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 85: break;
          case 20: 
            { if (normalizeOtherBrackets) {
                    return getNext(openbrace, yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 86: break;
          case 21: 
            { if (normalizeOtherBrackets) {
                    return getNext(""-RSB-"", yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 87: break;
          case 22: 
            { if (normalizeOtherBrackets) {
                    return getNext(""-LSB-"", yytext()); }
                  else {
                    return getNext();
                  }
            }
          case 88: break;
          case 23: 
            { if (invertible) {
                            prevWordAfter.append(yytext());
                        }
            }
          case 89: break;
          case 24: 
            { return getNext(""\u2022"", yytext());
            }
          case 90: break;
          case 25: 
            { return getNext(""\u2122"", yytext());
            }
          case 91: break;
          case 26: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 15;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 16;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return getNext();
            }
          case 92: break;
          case 27: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { return getNext();
            }
          case 93: break;
          case 28: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { return handleQuotes(yytext(), true);
            }
          case 94: break;
          case 29: 
            { String txt = yytext();
                  String origText = txt;
                  if (normalizeParentheses) {
                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                  }
                  return getNext(txt, origText);
            }
          case 95: break;
          case 30: 
            { breakByHyphens(yytext());
                    return getNext(removeSoftHyphens(yytext()), yytext());
            }
          case 96: break;
          case 31: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 3;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 4;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { final String origTxt = yytext();
                          String tmp = removeSoftHyphens(origTxt);
                          if (americanize) {
                            tmp = Americanize.americanize(tmp);
                          }
                          return getNext(tmp, origTxt);
            }
          case 97: break;
          case 32: 
            { if (escapeForwardSlashAsterisk) {
                            return getNext(delimit(yytext(), '/'), yytext());
                          } else {
                            return getNext();
                          }
            }
          case 98: break;
          case 33: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { return getNext(removeSoftHyphens(yytext()), yytext());
            }
          case 99: break;
          case 34: 
            { // this one should only match if we're basically at the end of file
                          // since the last one matches two things, even newlines (if not tokenize per line)
                          String s;
                          if (strictTreebank3 && ! ""U.S."".equals(yytext())) {
                            yypushback(1); // return a period for next time
                            s = yytext();
                          } else {
                            s = yytext();
                            yypushback(1); // return a period for next time
                          }
                          return getNext(s, yytext());
            }
          case 100: break;
          case 35: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { String txt = yytext();
                  String origText = txt;
                  if (normalizeParentheses) {
                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                  }
                  return getNext(txt, origText);
            }
          case 101: break;
          case 36: 
            // lookahead expression with fixed base length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 1);
            { /* invert quote - often but not always right */
                  return handleQuotes(yytext(), true);
            }
          case 102: break;
          case 37: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { return handleQuotes(yytext(), false);
            }
          case 103: break;
          case 38: 
            { return getNext(removeSoftHyphens(yytext()), yytext());
            }
          case 104: break;
          case 39: 
            { String txt = yytext();
                  // if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space...
                  if (strictTreebank3) {
                    int spaceIndex = indexOfSpace(txt);
                    if (spaceIndex >= 0) {
                      yypushback(txt.length() - spaceIndex);
                      String newText = yytext();
                      return getNext(newText, newText);
                    }
                  }
                  if (escapeForwardSlashAsterisk) {
                    txt = delimit(txt, '/');
                  }
                  if (normalizeSpace) {
                    txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                  }
                  return getNext(txt, txt);
            }
          case 105: break;
          case 40: 
            { return getNormalizedAmpNext();
            }
          case 106: break;
          case 41: 
            { final String origTxt = yytext();
                          String txt = origTxt;
                          if (normalizeSpace) {
                            txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                          }
                          return getNext(txt, origTxt);
            }
          case 107: break;
          case 42: 
            { final String origTxt = yytext();
                          String txt = origTxt;
                          if (normalizeSpace) {
                            txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space
                          }
                          return getNext(txt, origTxt);
            }
          case 108: break;
          case 43: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 5;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 6;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { final String txt = yytext();
                          return getNext(removeSoftHyphens(txt),
                                         txt);
            }
          case 109: break;
          case 44: 
            { if (splitAssimilations) {
                            yypushback(2) ; return getNext();
                          } else {
                            return getNext();
                          }
            }
          case 110: break;
          case 45: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 17;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 16;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return getNext();
            }
          case 111: break;
          case 46: 
            // lookahead expression with fixed base length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);
            { if (splitAssimilations) {
                            yypushback(2) ; return getNext();
                          } else {
                            return getNext();
                          }
            }
          case 112: break;
          case 47: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 10;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 11;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return processAbbrev3();
            }
          case 113: break;
          case 48: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 20;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 22;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */
                                    return handleEllipsis(yytext());
            }
          case 114: break;
          case 49: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 18;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 19;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return getNext();
            }
          case 115: break;
          case 50: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 10;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 11;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return processAbbrev3();
            }
          case 116: break;
          case 51: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 20;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 21;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */
                                    return handleEllipsis(yytext());
            }
          case 117: break;
          case 52: 
            { String txt = yytext();
                          if (escapeForwardSlashAsterisk) {
                            txt = delimit(txt, '/');
                            txt = delimit(txt, '*');
                          }
                          return getNext(txt, yytext());
            }
          case 118: break;
          case 53: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { breakByHyphens(yytext());
                    return getNext(removeSoftHyphens(yytext()), yytext());
            }
          case 119: break;
          case 54: 
            { if (splitAssimilations) {
                            yypushback(3) ; return getNext();
                          } else {
                            return getNext();
                          }
            }
          case 120: break;
          case 55: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);
            { return getNormalizedAmpNext();
            }
          case 121: break;
          case 56: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 7;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 9;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return processAcronym();
            }
          case 122: break;
          case 57: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);
            { return getNext();
            }
          case 123: break;
          case 58: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 12;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 14;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return processAbbrev1();
            }
          case 124: break;
          case 59: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 7;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 8;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return processAcronym();
            }
          case 125: break;
          case 60: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 12;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 13;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { return processAbbrev1();
            }
          case 126: break;
          case 61: 
            { String txt = yytext();
                          if (escapeForwardSlashAsterisk) {
                            txt = delimit(txt, '/');
                          }
                          return getNext(txt, yytext());
            }
          case 127: break;
          case 62: 
            // lookahead expression with fixed lookahead length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4);
            { return getNext();
            }
          case 128: break;
          case 63: 
            // lookahead expression with fixed base length
            zzMarkedPos = Character.offsetByCodePoints
                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);
            { return getNext();
            }
          case 129: break;
          case 64: 
            { String txt = yytext();
                          if (normalizeSpace) {
                            txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space
                          }
                          if (normalizeParentheses) {
                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);
                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);
                          }
                          return getNext(txt, yytext());
            }
          case 130: break;
          case 65: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 23;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 25;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */
                                    return handleEllipsis(yytext());
            }
          case 131: break;
          case 66: 
            // general lookahead, find correct zzMarkedPos
            { int zzFState = 23;
              int zzFPos = zzStartRead;
              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }
              boolean zzFinL[] = zzFin;
              while (zzFState != -1 && zzFPos < zzMarkedPos) {
                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);
                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);
                zzFPos += Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              }
              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } 
              while (zzFPos <= zzMarkedPos) {
                zzFinL[zzFPos++] = false;
              }

              zzFState = 24;
              zzFPos = zzMarkedPos;
              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);
                zzFPos -= Character.charCount(zzInput);
                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];
              };
              zzMarkedPos = zzFPos;
            }
            { /* attempt to treat fourth ellipsis as period if followed by space and letter. */
                                    return handleEllipsis(yytext());
            }
          case 132: break;
          default:
            zzScanError(ZZ_NO_MATCH);
        }
      }
    }
  }
"	@return the next token	@return the next token	0	1	19	966	6267
"public boolean isCookiePresent(String name) { return (Boolean) seleneseMethods.get(""isCookiePresent"").apply(driver, name); }"	"  public boolean isCookiePresent(String name) {
    return getCookieByName(name) != null;
  }
"	@return true if a cookie with the specified name is present, or false otherwise.	@return true if a cookie with the specified name is present, or false otherwise.	0	1	7	4	27
protected Object convertTimestampToEpochNanos(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0L; // return epoch } try { return NanoTimestamp.toEpochNanos(data); } catch (IllegalArgumentException e) { return handleUnknownData(column, fieldDefn, data); } }	"    protected Object convertTimestampToEpochNanos(Column column, Field fieldDefn, Object data) {
        if ( data == null ) return null;
        try {
            return NanoTimestamp.toEpochNanos(data);
        } catch (IllegalArgumentException e) {
            return handleUnknownData(column, fieldDefn, data);
        }
    }
"	@return the converted value, or null if the conversion could not be made and the column allows nulls	@return the converted value, or null if the conversion could not be made	1	0	8	15	82
public List<X_AD_ReplicationTable> getReplicationTables() { final String whereClause = I_AD_ReplicationTable.COLUMNNAME_AD_ReplicationStrategy_ID + STR; return new Query(getCtx(), I_AD_ReplicationTable.Table_Name, whereClause, get_TrxName()).setClient_ID().setParameters(getAD_ReplicationStrategy_ID()).setOnlyActiveRecords(true).setApplyAccessFilter(false).list(); }	"public Collection<X_AD_ReplicationTable> getReplicationTables() {
    final String whereClause = new StringBuffer(X_AD_ReplicationTable.COLUMNNAME_AD_ReplicationStrategy_ID) + STR;
    return new Query(getCtx(), X_AD_ReplicationTable.Table_Name, whereClause, get_TrxName()).setClient_ID().setParameters(getAD_ReplicationStrategy_ID()).setOnlyActiveRecords(true).setApplyAccessFilter(false).list();
}"	@return the list the X_AD_ReplicationTable	@return the collection the X_AD_ReplicationTable	1	0	6	4	54
public static FortranEditorTasks instance(AbstractFortranEditor editor) { if (editor.reconcilerTasks == null) editor.reconcilerTasks = new FortranEditorTasks(editor); return (FortranEditorTasks) editor.reconcilerTasks; }	"public static FortranEditorVPGTasks instance(AbstractFortranEditor editor) {
    if (editor.reconcilerTasks == null)
        editor.reconcilerTasks = new FortranEditorVPGTasks(editor);
    return (FortranEditorVPGTasks) editor.reconcilerTasks;
}"	@return the instance of FortranEditorTasks associated with the given editor, creating the instance on-demand if necessary	@return the instance of FortranEditorVPGTasks associated with the given editor, creating the instance on-demand if necessary	1	0	7	5	31
"public static SchemaPath parseFromString(String expr) { if (expr == null || expr.isEmpty()) { return null; } try { if (SchemaPath.DYNAMIC_STAR.equals(expr)) { return SchemaPath.getSimplePath(expr); } ExprLexer lexer = new ExprLexer(new ANTLRStringStream(expr)); CommonTokenStream tokens = new CommonTokenStream(lexer); ExprParser parser = new ExprParser(tokens); parse_return ret = parser.parse(); if (ret.e instanceof SchemaPath) { return (SchemaPath) ret.e; } else { throw new IllegalStateException(""Schema path is not a valid format.""); } } catch (RecognitionException e) { throw new RuntimeException(e); } }"	"  public static SchemaPath parseFromString(String expr) {
    if (expr == null || expr.isEmpty()) {
      return null;
    }
    try {
      ExprLexer lexer = new ExprLexer(new ANTLRStringStream(expr));
      CommonTokenStream tokens = new CommonTokenStream(lexer);
      ExprParser parser = new ExprParser(tokens);

      parse_return ret = parser.parse();

      if (ret.e instanceof SchemaPath) {
        return (SchemaPath) ret.e;
      } else {
        throw new IllegalStateException(""Schema path is not a valid format."");
      }
    } catch (RecognitionException e) {
      throw new RuntimeException(e);
    }
  }
"	@return  SchemaPath instance	@return SchemaPath instance	0	1	8	24	130
static boolean implementsMethod(TypeElement clazz, MethodSpec method, Types typeUtils) { ExecutableElement methodOnClass = getMethodOnClass(clazz, method, typeUtils); if (methodOnClass == null) { return false; } Set<Modifier> modifiers = methodOnClass.getModifiers(); return !modifiers.contains(Modifier.ABSTRACT); }	"static boolean implementsMethod(TypeElement clazz, MethodSpec method, Types typeUtils) {
    ExecutableElement methodOnClass = getMethodOnClass(clazz, method, typeUtils);
    if (methodOnClass == null) {
        return false;
    }
    Element implementingClass = methodOnClass.getEnclosingElement();
    if (implementingClass.getSimpleName().toString().equals(STR)) {
        return false;
    }
    Set<Modifier> modifiers = methodOnClass.getModifiers();
    return !modifiers.contains(Modifier.ABSTRACT);
}"	@return True if the clazz (or one of its superclasses) implements the given method. Returns false if the method doesn't exist anywhere in the class hierarchy or it is abstract.	@return True if the clazz (or one of its superclasses except for Object) implements the given method. Returns false if the method doesn't exist anywhere in the class hierarchy or it is abstract.	1	0	6	8	53
"protected String removeNonNameElementToCamelCase(final String name, final String nonNameElementPattern) { String result = Arrays.stream(name.split(nonNameElementPattern)) .map(StringUtils::capitalize) .collect(Collectors.joining("""")); if (result.length() > 0) { result = result.substring(0, 1).toLowerCase() + result.substring(1); } return result; }"	"    protected String removeNonNameElementToCamelCase(final String name, final String nonNameElementPattern) {
        String result = StringUtils.join(Lists.transform(Lists.newArrayList(name.split(nonNameElementPattern)), new Function<String, String>() {
            @Nullable
            @Override
            public String apply(String input) {
                return StringUtils.capitalize(input);
            }
        }), """");
        if (result.length() > 0) {
            result = result.substring(0, 1).toLowerCase() + result.substring(1);
        }
        return result;
    }
"	@return camelized string	@return camelized string	0	1	9	10	73
"public Object clone() { throw ExceptionUtils.unsupportedInGwt(); // try { // return super.clone(); // } catch (CloneNotSupportedException ex) { // throw new InternalError(""Clone error""); // } }"	"    public Object clone() {
        try {
            return super.clone();
        } catch (CloneNotSupportedException ex) {
            throw new InternalError(""Clone error"");
        }
    }
"	@return a clone of this object.	@return a clone of this object.	0	1	4	9	49
"public boolean setTaskCompleted(List<FileDownloadTaskAtom> taskAtomList) { FileDownloadLog.w(this, ""If you invoked this method, please remove it directly feel free, "" + ""it doesn't need any longer""); return true; }"	"    public boolean setTaskCompleted(List<FileDownloadTaskAtom> taskAtomList) {
        return FileDownloadServiceProxy.getImpl().setTaskCompleted(taskAtomList);
    }
"	@return Whether is successful to update all tasks' status to the Filedownloader Engine. If one task atom among them is not match the Rules in FileDownloadMgr#obtainCompletedTaskShelfModel(String, String, long) will receive false, and non of them would be updated to DB.	@return Whether is successful to update all tasks' status to the Filedownloader Engine. If one task atom among them is not match the Rules in com.liulishuo.filedownloader.services.FileDownloadMgr#obtainCompletedTaskShelfModel(String, String, long) will receive false, and non of them would be updated to DB.	1	0	6	6	45
public static MailboxMessage<HBaseId> messageMetaFromResult(Configuration conf, Result result) { HBaseMailboxMessage message = null; Flags flags = new Flags(); List<Property> propList = new ArrayList<Property>(); KeyValue[] keys = result.raw(); String mediaType = null, subType = null; Long modSeq = null, uid, bodyOctets = null, contentOctets = null, textualLineCount = null; Date internalDate = null; int i = NUM; if (Bytes.equals(keys[i].getQualifier(), MESSAGE_BODY_OCTETS)) { bodyOctets = Bytes.toLong(keys[i].getValue()); i++; } if (Bytes.equals(keys[i].getQualifier(), MESSAGE_CONTENT_OCTETS)) { contentOctets = Bytes.toLong(keys[i].getValue()); i++; } if (Bytes.equals(keys[i].getQualifier(), MESSAGE_INTERNALDATE)) { internalDate = new Date(Bytes.toLong(keys[i].getValue())); i++; } if (Bytes.equals(keys[i].getQualifier(), MESSAGE_TEXT_LINE_COUNT)) { textualLineCount = Bytes.toLong(keys[i].getValue()); i++; } if (Bytes.equals(keys[i].getQualifier(), MESSAGE_MODSEQ)) { modSeq = Bytes.toLong(keys[i].getValue()); i++; } if (Bytes.equals(keys[i].getQualifier(), MESSAGE_MEDIA_TYPE)) { mediaType = Bytes.toString(keys[i].getValue()); i++; } if (Bytes.equals(keys[i].getQualifier(), MESSAGE_SUB_TYPE)) { subType = Bytes.toString(keys[i].getValue()); i++; } if (i < NUM) { throw new RuntimeException(STR); } while (i < keys.length) { if (Bytes.startsWith(keys[i].getQualifier(), PREFIX_PROP_B)) { propList.add(getProperty(keys[i].getValue())); } else if (Bytes.startsWith(keys[i].getQualifier(), PREFIX_SFLAGS_B)) { if (Bytes.equals(MARKER_PRESENT, keys[i].getValue())) { flags.add(systemFlagFromBytes(keys[i].getQualifier())); } } else if (Bytes.startsWith(keys[i].getQualifier(), PREFIX_UFLAGS_B)) { flags.add(userFlagFromBytes(keys[i].getQualifier())); } i++; } HBaseId uuid = HBaseIdFromRowKey(result.getRow()); uid = Long.MAX_VALUE - Bytes.toLong(result.getRow(), NUM); PropertyBuilder props = new PropertyBuilder(propList); props.setMediaType(mediaType); props.setSubType(subType); message = new HBaseMailboxMessage(conf, uuid, internalDate, flags, contentOctets, (int) (contentOctets - bodyOctets), props); message.setUid(uid); message.setModSeq(modSeq); message.setTextualLineCount(textualLineCount); return message; }	"public static Message<HBaseId> messageMetaFromResult(Configuration conf, Result result) {
    HBaseMessage message = null;
    Flags flags = new Flags();
    List<Property> propList = new ArrayList<Property>();
    KeyValue[] keys = result.raw();
    String mediaType = null, subType = null;
    Long modSeq = null, uid, bodyOctets = null, contentOctets = null, textualLineCount = null;
    Date internalDate = null;
    int i = NUM;
    if (Bytes.equals(keys[i].getQualifier(), MESSAGE_BODY_OCTETS)) {
        bodyOctets = Bytes.toLong(keys[i].getValue());
        i++;
    }
    if (Bytes.equals(keys[i].getQualifier(), MESSAGE_CONTENT_OCTETS)) {
        contentOctets = Bytes.toLong(keys[i].getValue());
        i++;
    }
    if (Bytes.equals(keys[i].getQualifier(), MESSAGE_INTERNALDATE)) {
        internalDate = new Date(Bytes.toLong(keys[i].getValue()));
        i++;
    }
    if (Bytes.equals(keys[i].getQualifier(), MESSAGE_TEXT_LINE_COUNT)) {
        textualLineCount = Bytes.toLong(keys[i].getValue());
        i++;
    }
    if (Bytes.equals(keys[i].getQualifier(), MESSAGE_MODSEQ)) {
        modSeq = Bytes.toLong(keys[i].getValue());
        i++;
    }
    if (Bytes.equals(keys[i].getQualifier(), MESSAGE_MEDIA_TYPE)) {
        mediaType = Bytes.toString(keys[i].getValue());
        i++;
    }
    if (Bytes.equals(keys[i].getQualifier(), MESSAGE_SUB_TYPE)) {
        subType = Bytes.toString(keys[i].getValue());
        i++;
    }
    if (i < NUM) {
        throw new RuntimeException(STR);
    }
    while (i < keys.length) {
        if (Bytes.startsWith(keys[i].getQualifier(), PREFIX_PROP_B)) {
            propList.add(getProperty(keys[i].getValue()));
        } else if (Bytes.startsWith(keys[i].getQualifier(), PREFIX_SFLAGS_B)) {
            if (Bytes.equals(MARKER_PRESENT, keys[i].getValue())) {
                flags.add(systemFlagFromBytes(keys[i].getQualifier()));
            }
        } else if (Bytes.startsWith(keys[i].getQualifier(), PREFIX_UFLAGS_B)) {
            flags.add(userFlagFromBytes(keys[i].getQualifier()));
        }
        i++;
    }
    HBaseId uuid = HBaseIdFromRowKey(result.getRow());
    uid = Long.MAX_VALUE - Bytes.toLong(result.getRow(), NUM);
    PropertyBuilder props = new PropertyBuilder(propList);
    props.setMediaType(mediaType);
    props.setSubType(subType);
    message = new HBaseMessage(conf, uuid, internalDate, flags, contentOctets, (int) (contentOctets - bodyOctets), props);
    message.setUid(uid);
    message.setModSeq(modSeq);
    message.setTextualLineCount(textualLineCount);
    return message;
}"	@return a HBaseMailboxMessage instance with message metadata.	@return a HBaseMessage instance with message metadata.	1	0	15	63	559
"public Object getValue(PgProto.DatumMessage datumMessage, PgConnectionSupplier connection, boolean includeUnknownDatatypes) { if (datumMessage.hasDatumMissing()) { return UnchangedToastedReplicationMessageColumn.UNCHANGED_TOAST_VALUE; } int columnType = (int) datumMessage.getColumnType(); switch (columnType) { case PgOid.BOOL: return datumMessage.hasDatumBool() ? datumMessage.getDatumBool() : null; case PgOid.INT2: case PgOid.INT4: return datumMessage.hasDatumInt32() ? datumMessage.getDatumInt32() : null; case PgOid.INT8: case PgOid.OID: case PgOid.MONEY: return datumMessage.hasDatumInt64() ? datumMessage.getDatumInt64() : null; case PgOid.FLOAT4: return datumMessage.hasDatumFloat()? datumMessage.getDatumFloat() : null; case PgOid.FLOAT8: return datumMessage.hasDatumDouble() ? datumMessage.getDatumDouble() : null; case PgOid.NUMERIC: if (datumMessage.hasDatumDouble()) { // For backwards compatibility only to enable independent upgrade of Postgres plug-in return datumMessage.getDatumDouble(); } else if (datumMessage.hasDatumString()) { final String s = datumMessage.getDatumString(); return PostgresValueConverter.toSpecialValue(s).orElseGet(() -> new SpecialValueDecimal(new BigDecimal(s))); } return null; case PgOid.CHAR: case PgOid.VARCHAR: case PgOid.BPCHAR: case PgOid.TEXT: case PgOid.JSON: case PgOid.JSONB_OID: case PgOid.XML: case PgOid.UUID: case PgOid.BIT: case PgOid.VARBIT: case PgOid.INET_OID: case PgOid.CIDR_OID: case PgOid.MACADDR_OID: case PgOid.MACADDR8_OID: return datumMessage.hasDatumString() ? datumMessage.getDatumString() : null; case PgOid.DATE: return datumMessage.hasDatumInt32() ? (long) datumMessage.getDatumInt32() : null; case PgOid.TIMESTAMP: if (!datumMessage.hasDatumInt64()) { return null; } // these types are sent by the plugin as LONG - microseconds since Unix Epoch return Conversions.toInstantFromMicros(datumMessage.getDatumInt64()); case PgOid.TIMESTAMPTZ: if (!datumMessage.hasDatumInt64()) { return null; } // these types are sent by the plugin as LONG - microseconds since Unix Epoch return Conversions.toInstantFromMicros(datumMessage.getDatumInt64()).atOffset(ZoneOffset.UTC); case PgOid.TIME: if (!datumMessage.hasDatumInt64()) { return null; } // these types are sent by the plugin as LONG - microseconds since Unix Epoch return Duration.of(datumMessage.getDatumInt64(), ChronoUnit.MICROS); case PgOid.TIMETZ: if (!datumMessage.hasDatumDouble()) { return null; } // the value is sent as a double microseconds return Conversions.toInstantFromMicros((long) datumMessage.getDatumDouble()) .atOffset(ZoneOffset.UTC) .toOffsetTime(); case PgOid.INTERVAL: // these are sent as doubles by the plugin since their storage is larger than 8 bytes return datumMessage.hasDatumDouble() ? datumMessage.getDatumDouble() : null; // the plugin will send back a TZ formatted string case PgOid.BYTEA: return datumMessage.hasDatumBytes() ? datumMessage.getDatumBytes().toByteArray() : null; case PgOid.POINT: { PgProto.Point datumPoint = datumMessage.getDatumPoint(); return new PGpoint(datumPoint.getX(), datumPoint.getY()); } case PgOid.TSRANGE_OID: case PgOid.TSTZRANGE_OID: case PgOid.DATERANGE_OID: case PgOid.INT4RANGE_OID: case PgOid.NUM_RANGE_OID: case PgOid.INT8RANGE_OID: return datumMessage.hasDatumBytes() ? new String(datumMessage.getDatumBytes().toByteArray(), Charset.forName(""UTF-8"")) : null; case PgOid.INT2_ARRAY: case PgOid.INT4_ARRAY: case PgOid.INT8_ARRAY: case PgOid.TEXT_ARRAY: case PgOid.NUMERIC_ARRAY: case PgOid.FLOAT4_ARRAY: case PgOid.FLOAT8_ARRAY: case PgOid.BOOL_ARRAY: case PgOid.DATE_ARRAY: case PgOid.TIME_ARRAY: case PgOid.TIMETZ_ARRAY: case PgOid.TIMESTAMP_ARRAY: case PgOid.TIMESTAMPTZ_ARRAY: case PgOid.BYTEA_ARRAY: case PgOid.VARCHAR_ARRAY: case PgOid.OID_ARRAY: case PgOid.BPCHAR_ARRAY: case PgOid.MONEY_ARRAY: case PgOid.NAME_ARRAY: case PgOid.INTERVAL_ARRAY: case PgOid.CHAR_ARRAY: case PgOid.VARBIT_ARRAY: case PgOid.UUID_ARRAY: case PgOid.XML_ARRAY: case PgOid.POINT_ARRAY: case PgOid.JSONB_ARRAY: case PgOid.JSON_ARRAY: case PgOid.REF_CURSOR_ARRAY: case PgOid.INET_ARRAY: case PgOid.CIDR_ARRAY: case PgOid.MACADDR_ARRAY: case PgOid.MACADDR8_ARRAY: case PgOid.TSRANGE_ARRAY: case PgOid.TSTZRANGE_ARRAY: case PgOid.DATERANGE_ARRAY: case PgOid.INT4RANGE_ARRAY: case PgOid.NUM_RANGE_ARRAY: case PgOid.INT8RANGE_ARRAY: return getArray(datumMessage, connection, columnType); case PgOid.UNSPECIFIED: return null; default: PostgresType type = typeRegistry.get(columnType); if (type.getOid() == typeRegistry.geometryOid() || type.getOid() == typeRegistry.geographyOid() || type.getOid() == typeRegistry.citextOid() ) { return datumMessage.getDatumBytes().toByteArray(); } if(type.getOid() == typeRegistry.hstoreOid()) { return datumMessage.getDatumBytes().toByteArray(); } if (type.getOid() == typeRegistry.geometryArrayOid() || type.getOid() == typeRegistry.geographyArrayOid() || type.getOid() == typeRegistry.citextArrayOid() || type.getOid() == typeRegistry.hstoreArrayOid()) { return getArray(datumMessage, connection, columnType); } // unknown data type is sent by decoder as binary value if (includeUnknownDatatypes && datumMessage.hasDatumBytes()) { return datumMessage.getDatumBytes().toByteArray(); } return null; } }"	"    public Object getValue(PgProto.DatumMessage datumMessage, PgConnectionSupplier connection, boolean includeUnknownDatatypes) {
        if (datumMessage.hasDatumMissing()) {
            return ToastedReplicationMessageColumn.UNCHANGED_TOAST_VALUE;
        }

        int columnType = (int) datumMessage.getColumnType();
        switch (columnType) {
            case PgOid.BOOL:
                return datumMessage.hasDatumBool() ? datumMessage.getDatumBool() : null;
            case PgOid.INT2:
            case PgOid.INT4:
                return datumMessage.hasDatumInt32() ? datumMessage.getDatumInt32() : null;
            case PgOid.INT8:
            case PgOid.OID:
            case PgOid.MONEY:
                return datumMessage.hasDatumInt64() ? datumMessage.getDatumInt64() : null;
            case PgOid.FLOAT4:
                return datumMessage.hasDatumFloat()? datumMessage.getDatumFloat() : null;
            case PgOid.FLOAT8:
                return datumMessage.hasDatumDouble() ? datumMessage.getDatumDouble() : null;
            case PgOid.NUMERIC:
                if (datumMessage.hasDatumDouble()) {
                    // For backwards compatibility only to enable independent upgrade of Postgres plug-in
                    return datumMessage.getDatumDouble();
                }
                else if (datumMessage.hasDatumString()) {
                    final String s = datumMessage.getDatumString();
                    return PostgresValueConverter.toSpecialValue(s).orElseGet(() -> new SpecialValueDecimal(new BigDecimal(s)));
                }
                return null;
            case PgOid.CHAR:
            case PgOid.VARCHAR:
            case PgOid.BPCHAR:
            case PgOid.TEXT:
            case PgOid.JSON:
            case PgOid.JSONB_OID:
            case PgOid.XML:
            case PgOid.UUID:
            case PgOid.BIT:
            case PgOid.VARBIT:
            case PgOid.INET_OID:
            case PgOid.CIDR_OID:
            case PgOid.MACADDR_OID:
            case PgOid.MACADDR8_OID:
                return datumMessage.hasDatumString() ? datumMessage.getDatumString() : null;
            case PgOid.DATE:
                return datumMessage.hasDatumInt32() ? (long) datumMessage.getDatumInt32() : null;
            case PgOid.TIMESTAMP:
                if (!datumMessage.hasDatumInt64()) {
                    return null;
                }
                // these types are sent by the plugin as LONG - microseconds since Unix Epoch
                return Conversions.toInstantFromMicros(datumMessage.getDatumInt64());
            case PgOid.TIMESTAMPTZ:
                if (!datumMessage.hasDatumInt64()) {
                    return null;
                }
                // these types are sent by the plugin as LONG - microseconds since Unix Epoch
                return Conversions.toInstantFromMicros(datumMessage.getDatumInt64()).atOffset(ZoneOffset.UTC);
            case PgOid.TIME:
                if (!datumMessage.hasDatumInt64()) {
                    return null;
                }

                // these types are sent by the plugin as LONG - microseconds since Unix Epoch
                return Duration.of(datumMessage.getDatumInt64(), ChronoUnit.MICROS);
            case PgOid.TIMETZ:
                if (!datumMessage.hasDatumDouble()) {
                    return null;
                }
                // the value is sent as a double microseconds
                return Conversions.toInstantFromMicros((long) datumMessage.getDatumDouble())
                        .atOffset(ZoneOffset.UTC)
                        .toOffsetTime();
            case PgOid.INTERVAL:
                // these are sent as doubles by the plugin since their storage is larger than 8 bytes
                return datumMessage.hasDatumDouble() ? datumMessage.getDatumDouble() : null;
            // the plugin will send back a TZ formatted string
            case PgOid.BYTEA:
                return datumMessage.hasDatumBytes() ? datumMessage.getDatumBytes().toByteArray() : null;
            case PgOid.POINT: {
                PgProto.Point datumPoint = datumMessage.getDatumPoint();
                return new PGpoint(datumPoint.getX(), datumPoint.getY());
            }
            case PgOid.TSRANGE_OID:
            case PgOid.TSTZRANGE_OID:
            case PgOid.DATERANGE_OID:
            case PgOid.INT4RANGE_OID:
            case PgOid.NUM_RANGE_OID:
            case PgOid.INT8RANGE_OID:
                return datumMessage.hasDatumBytes() ? new String(datumMessage.getDatumBytes().toByteArray(), Charset.forName(""UTF-8"")) : null;
            case PgOid.INT2_ARRAY:
            case PgOid.INT4_ARRAY:
            case PgOid.INT8_ARRAY:
            case PgOid.TEXT_ARRAY:
            case PgOid.NUMERIC_ARRAY:
            case PgOid.FLOAT4_ARRAY:
            case PgOid.FLOAT8_ARRAY:
            case PgOid.BOOL_ARRAY:
            case PgOid.DATE_ARRAY:
            case PgOid.TIME_ARRAY:
            case PgOid.TIMETZ_ARRAY:
            case PgOid.TIMESTAMP_ARRAY:
            case PgOid.TIMESTAMPTZ_ARRAY:
            case PgOid.BYTEA_ARRAY:
            case PgOid.VARCHAR_ARRAY:
            case PgOid.OID_ARRAY:
            case PgOid.BPCHAR_ARRAY:
            case PgOid.MONEY_ARRAY:
            case PgOid.NAME_ARRAY:
            case PgOid.INTERVAL_ARRAY:
            case PgOid.CHAR_ARRAY:
            case PgOid.VARBIT_ARRAY:
            case PgOid.UUID_ARRAY:
            case PgOid.XML_ARRAY:
            case PgOid.POINT_ARRAY:
            case PgOid.JSONB_ARRAY:
            case PgOid.JSON_ARRAY:
            case PgOid.REF_CURSOR_ARRAY:
            case PgOid.INET_ARRAY:
            case PgOid.CIDR_ARRAY:
            case PgOid.MACADDR_ARRAY:
            case PgOid.MACADDR8_ARRAY:
            case PgOid.TSRANGE_ARRAY:
            case PgOid.TSTZRANGE_ARRAY:
            case PgOid.DATERANGE_ARRAY:
            case PgOid.INT4RANGE_ARRAY:
            case PgOid.NUM_RANGE_ARRAY:
            case PgOid.INT8RANGE_ARRAY:
            return getArray(datumMessage, connection, columnType);

            case PgOid.UNSPECIFIED:
                return null;

            default:
                PostgresType type = typeRegistry.get(columnType);
                if (type.getOid() == typeRegistry.geometryOid() || type.getOid() == typeRegistry.geographyOid() || type.getOid() == typeRegistry.citextOid() ) {
                    return datumMessage.getDatumBytes().toByteArray();
                }
                if(type.getOid() == typeRegistry.hstoreOid()) {
                    return datumMessage.getDatumBytes().toByteArray();
                }
                if (type.getOid() == typeRegistry.geometryArrayOid() ||
                        type.getOid() == typeRegistry.geographyArrayOid() ||
                        type.getOid() == typeRegistry.citextArrayOid() ||
                        type.getOid() == typeRegistry.hstoreArrayOid()) {
                    return getArray(datumMessage, connection, columnType);
                }
                // unknown data type is sent by decoder as binary value
                if (includeUnknownDatatypes && datumMessage.hasDatumBytes()) {
                    return datumMessage.getDatumBytes().toByteArray();
                }

                return null;
        }
    }
"	@return the value; may be null	@return the value; may be null	0	1	14	157	974
public int update(Object[] before, Object[] after, long ts, int rowNumber, int numberOfRows) throws InterruptedException { return converter.update(source, before, after, rowNumber, numberOfRows, includedColumns, ts, consumer); }	"        public int update(Object[] before, Object[] after, long ts, int rowNumber) throws InterruptedException {
            return converter.update(source, before, after, rowNumber, includedColumns, ts, consumer);
        }
"	@return the number of records produced; will be 0 or more	@return the number of records produced; will be 0 or more	0	1	5	4	48
public String ceDataschema() { return dataSchemaUrl; }	"    public String ceDataschema() {
        return (dataSchemaUrl == null) ? """" : dataSchemaUrl;
    }
"	@return the data schema url of CloudEvents envelope	@return the data schema url of CloudEvents envelope	0	1	4	4	10
public boolean isThisMyUrl(String url) { return isInstanceURL(url, applicationInfoManager.getInfo()); }	"    public boolean isThisMyUrl(String url) {
        InstanceInfo myInfo = applicationInfoManager.getInfo();
        String hostName = hostFromUrl(url);
        return hostName != null && hostName.equals(myInfo.getHostName());
    }
"	@return true, if the url represents the current node which is trying to replicate, false otherwise.	@return true, if the url represents the current node which is trying to replicate, false otherwise.	0	1	5	4	20
@RequestMapping(value = STR, method = { RequestMethod.POST }) @ResponseBody public CubeRequest saveCubeDesc(@RequestBody CubeRequest cubeRequest) { CubeDesc desc = deserializeCubeDesc(cubeRequest); if (desc == null) { cubeRequest.setMessage(STR); return cubeRequest; } String name = CubeService.getCubeNameFromDesc(desc.getName()); if (StringUtils.isEmpty(name)) { logger.info(STR); throw new BadRequestException(STR); } CubeInstance cubeInstance; try { desc.setUuid(UUID.randomUUID().toString()); String projectName = (null == cubeRequest.getProject()) ? ProjectInstance.DEFAULT_PROJECT_NAME : cubeRequest.getProject(); cubeInstance = cubeService.createCubeAndDesc(name, projectName, desc); } catch (Exception e) { logger.error(STR, e); throw new InternalErrorException(e.getLocalizedMessage(), e); } boolean createStreamingConfigSuccess = false, createKafkaConfigSuccess = false; StreamingConfig streamingConfig = null; KafkaConfig kafkaConfig = null; boolean isStreamingCube = cubeRequest.getStreamingCube() != null && cubeRequest.getStreamingCube().equals(STR); try { if (isStreamingCube) { streamingConfig = deserializeStreamingDesc(cubeRequest); kafkaConfig = deserializeKafkaDesc(cubeRequest); if (kafkaConfig == null) { cubeRequest.setMessage(STR); return cubeRequest; } if (streamingConfig == null) { cubeRequest.setMessage(STR); return cubeRequest; } try { streamingConfig.setUuid(UUID.randomUUID().toString()); streamingService.createStreamingConfig(streamingConfig); createStreamingConfigSuccess = true; } catch (IOException e) { logger.error(STR + e.getLocalizedMessage(), e); throw new InternalErrorException(STR + e.getLocalizedMessage()); } try { kafkaConfig.setUuid(UUID.randomUUID().toString()); kafkaConfigService.createKafkaConfig(kafkaConfig); createKafkaConfigSuccess = true; } catch (IOException e) { logger.error(STR + e.getLocalizedMessage(), e); throw new InternalErrorException(STR + e.getLocalizedMessage()); } } } finally { if (isStreamingCube) { if (createStreamingConfigSuccess == false || createKafkaConfigSuccess == false) { try { cubeService.deleteCube(cubeInstance); } catch (Exception ex) { throw new InternalErrorException(STR + STR + ex.getMessage(), ex); } if (createStreamingConfigSuccess == true) { try { streamingService.dropStreamingConfig(streamingConfig); } catch (IOException e) { throw new InternalErrorException(STR + e.getLocalizedMessage()); } } if (createKafkaConfigSuccess == true) { try { kafkaConfigService.dropKafkaConfig(kafkaConfig); } catch (IOException e) { throw new InternalErrorException(STR + e.getLocalizedMessage()); } } } } } cubeRequest.setUuid(desc.getUuid()); cubeRequest.setSuccessful(true); return cubeRequest; }	"@RequestMapping(value = STR, method = { RequestMethod.POST })
@ResponseBody
public CubeRequest saveCubeDesc(@RequestBody CubeRequest cubeRequest) {
    MetadataManager metaManager = MetadataManager.getInstance(cubeService.getConfig());
    DataModelDesc modelDesc = deserializeDataModelDesc(cubeRequest);
    if (modelDesc == null) {
        return errorRequest(cubeRequest, STR);
    }
    if (StringUtils.isEmpty(modelDesc.getName())) {
        return errorRequest(cubeRequest, STR);
    }
    try {
        DataModelDesc existingModel = metaManager.getDataModelDesc(modelDesc.getName());
        if (existingModel == null) {
            metaManager.createDataModelDesc(modelDesc);
        } else {
            modelDesc.setLastModified(existingModel.getLastModified());
            metaManager.updateDataModelDesc(modelDesc);
        }
    } catch (IOException e) {
        logger.error(STR + e.getLocalizedMessage(), e);
        throw new InternalErrorException(STR + e.getLocalizedMessage());
    }
    CubeDesc desc = deserializeCubeDesc(cubeRequest);
    if (desc == null) {
        return cubeRequest;
    }
    if (StringUtils.isEmpty(desc.getName())) {
        logger.info(STR);
        return errorRequest(cubeRequest, STR);
    }
    try {
        desc.setUuid(UUID.randomUUID().toString());
        String projectName = (null == cubeRequest.getProject()) ? ProjectInstance.DEFAULT_PROJECT_NAME : cubeRequest.getProject();
        CubeInstance createdCube = cubeService.createCubeAndDesc(desc.getName(), projectName, desc);
        accessService.init(createdCube, AclPermission.ADMINISTRATION);
        ProjectInstance project = cubeService.getProjectManager().getProject(projectName);
        accessService.inherit(createdCube, project);
    } catch (Exception e) {
        logger.error(STR, e);
        throw new InternalErrorException(e.getLocalizedMessage(), e);
    }
    cubeRequest.setUuid(desc.getUuid());
    cubeRequest.setSuccessful(true);
    return cubeRequest;
}"	@return Table metadata array	@return cubeRequest cube change request	1	0	15	84	495
public static Set getAllInterfaces(Class clazz) { Set interfaces = new HashSet(); getInterfaces(clazz, interfaces); return interfaces; }	"public static Class[] getAllInterfaces(Class clazz) {
    Set interfaces = new HashSet();
    getInterfaces(clazz, interfaces);
    return (Class[]) interfaces.toArray(new Class[interfaces.size()]);
}"	@return a {@link Set} with all interfaces. The array may be empty.	@return an array with all interfaces. The array may be empty.	1	0	6	5	27
public static int getAnimationResource(int gravity, boolean isInAnimation) { switch (gravity) { case Gravity.BOTTOM: return isInAnimation ? R.anim.pickerview_slide_in_bottom : R.anim.pickerview_slide_out_bottom; } return INVALID; }	"    public static int getAnimationResource(int gravity, boolean isInAnimation) {
        switch (gravity) {
            case Gravity.BOTTOM:
                return isInAnimation ? R.anim.slide_in_bottom : R.anim.slide_out_bottom;
        }
        return INVALID;
    }
"	@return the id of the animation resource	@return the id of the animation resource	0	1	7	8	37
public static Internal hide() { return hide(null); }	"public static Hidden hide() {
    return hide(null);
}"	@return Internal source	@return Hidden source	1	0	5	3	14
"public TopologyInfo getTopologyInfo(String topologyId) throws NotAliveException, TException { StormClusterState stormClusterState = data.getStormClusterState(); try { // get topology's StormBase StormBase base = stormClusterState.storm_base(topologyId, null); if (base == null) { throw new NotAliveException(""No topology of "" + topologyId); } return getTopologyInfo(topologyId, base); } catch (TException e) { LOG.info(""Failed to get topologyInfo "" + topologyId, e); throw e; } catch (Exception e) { LOG.info(""Failed to get topologyInfo "" + topologyId, e); throw new TException(""Failed to get topologyInfo"" + topologyId); } }"	"	public TopologyInfo getTopologyInfo(String topologyId)
			throws NotAliveException, TException {

		TopologyInfo topologyInfo = new TopologyInfo();

		StormClusterState stormClusterState = data.getStormClusterState();

		try {

			// get topology's StormBase
			StormBase base = stormClusterState.storm_base(topologyId, null);
			if (base == null) {
				throw new NotAliveException(""No topology of "" + topologyId);
			}
			topologyInfo.set_id(topologyId);
			topologyInfo.set_name(base.getStormName());
			topologyInfo.set_uptime_secs(TimeUtils.time_delta(base
					.getLanchTimeSecs()));
			topologyInfo.set_status(base.getStatusString());

			// get topology's Assignment
			Assignment assignment = stormClusterState.assignment_info(
					topologyId, null);
			if (assignment == null) {
				throw new TException(""Failed to get StormBase from ZK of ""
						+ topologyId);
			}

			// get topology's map<taskId, componentId>
			Map<Integer, String> taskInfo = Cluster.topology_task_info(
					stormClusterState, topologyId);

			Map<Integer, TaskSummary> tasks = NimbusUtils.mkTaskSummary(
					stormClusterState, assignment, taskInfo, topologyId);
			List<TaskSummary> taskSumms = new ArrayList<TaskSummary>();
			for (Entry<Integer, TaskSummary> entry : tasks.entrySet()) {
				taskSumms.add(entry.getValue());
			}
			topologyInfo.set_tasks(taskSumms);
			List<WorkerSummary> workers = NimbusUtils.mkWorkerSummary(
					topologyId, assignment, tasks);
			topologyInfo.set_workers(workers);

			return topologyInfo;
		} catch (TException e) {
			LOG.info(""Failed to get topologyInfo "" + topologyId, e);
			throw e;
		} catch (Exception e) {
			LOG.info(""Failed to get topologyInfo "" + topologyId, e);
			throw new TException(""Failed to get topologyInfo"" + topologyId);
		}

	}
"	@return TopologyInfo	@return TopologyInfo	0	1	9	23	129
public boolean isRemove() { return command != null && command.getDataStructureType() == CommandTypes.MESSAGE_ACK && subscriptionName == null; }	"    public boolean isRemove() {
        return command != null && command.getDataStructureType() == CommandTypes.MESSAGE_ACK;
    }
"	@return true if a MessageAck command	@return true if a MessageAck command	0	1	7	4	24
public List<I> joinWithTimeout() { if (timeout < 0) { join(); return null; } // Make blocking calls to the last processes that are running if ( ! threadPool.isShutdown()) { try { List<I> leftover = null; int i; for (i = nThreads; i > 0; --i) { if (idleProcessors.poll(timeout, TimeUnit.MILLISECONDS) == null) { leftover = shutdownNow(); break; } } // if the poll hit a timeout, retake the remaining processors // so join() can guarantee the threads are finished if (i > 0) { for ( ; i > leftover.size(); --i) { idleProcessors.take(); } return leftover; } else { threadPool.shutdown(); // Sanity check. The threadpool should be done after iterating over // the processors. threadPool.awaitTermination(10, TimeUnit.SECONDS); } } catch (InterruptedException e) { throw new RuntimeException(e); } } return null; }	"  public List<I> joinWithTimeout() {
    if (timeout < 0) {
      join();
      return new ArrayList<>();
    }
    // Make blocking calls to the last processes that are running
    if ( ! threadPool.isShutdown()) {
      try {
        List<I> leftover = null;
        int i;
        for (i = nThreads; i > 0; --i) {
          if (idleProcessors.poll(timeout, TimeUnit.MILLISECONDS) == null) {
            leftover = shutdownNow();
            break;
          }
        }
        // if the poll hit a timeout, retake the remaining processors
        // so join() can guarantee the threads are finished
        if (i > 0) {
          for ( ; i > leftover.size(); --i) {
            idleProcessors.take();
          }
          return leftover;
        } else {
          threadPool.shutdown();
          // Sanity check. The threadpool should be done after iterating over
          // the processors.
          threadPool.awaitTermination(10, TimeUnit.SECONDS);
        }
      } catch (InterruptedException e) {
        throw new RuntimeInterruptedException(e);
      }
    }
    return new ArrayList<>();
  }
"	@return a list of jobs which had never been started if timeout was reached, or null if that did not happen.	@return a list of jobs which had never been started if timeout was reached, or an empty list if that did not happen.	1	0	12	36	195
