new_code_raw	old_comment_raw	label	pre_label
private static EmbeddedElasticsearchNode create(Settings settings) { // ensure PainlessPlugin is installed or otherwise scripted fields would not work Node node = new LocalNode(settings, Arrays.asList(Netty4Plugin.class, PainlessPlugin.class)); return new EmbeddedElasticsearchNode(node); }	Creates elastic node as single member of a cluster.	1	0
"private byte[] marshalAggregatorValues(long superstep) { if (superstep == INPUT_SUPERSTEP) { return new byte[0]; } ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); DataOutputStream output = new DataOutputStream(outputStream); for (Entry<String, AggregatorWrapper<Writable>> entry : getAggregatorMap().entrySet()) { if (entry.getValue().isChanged()) { try { output.writeUTF(entry.getKey()); entry.getValue().getCurrentAggregatedValue().write(output); } catch (IOException e) { throw new IllegalStateException(""Failed to marshall aggregator "" + ""with IOException "" + entry.getKey(), e); } } } if (LOG.isInfoEnabled()) { LOG.info( ""marshalAggregatorValues: Finished assembling aggregator values""); } return outputStream.toByteArray(); }"	Marshal the aggregator values of to a JSONArray that will later be aggregated by master.	1	0
"static MongoDatabasePolicy create() { final MongoClient client; if (MongoAssertions.useMongo()) { // use to real client (connects to mongo) client = new MongoClient(); } else if (MongoAssertions.useFongo()) { // in-memory DB (fake Mongo) client = new Fongo(MongoDatabasePolicy.class.getSimpleName()).getMongo(); } else { throw new UnsupportedOperationException(""I can only connect to Mongo or Fongo instances""); } return new MongoDatabasePolicy(client); }"	Create an instance based on current maven profile (as defined by -Pit).	1	0
public Struct ceDataAttribute() { return recordParser.data(); }	Construct the value of the data attribute of CloudEvents.	0	1
public ZapTextField getTxtPattern() { if (txtPattern == null) { txtPattern = new ZapTextField(); } return txtPattern; }	This method initializes txtPattern	0	1
"public static StandardProperty buildStandardProperty(AttributeBinding property, boolean lazyAvailable) { final Type type = property.getHibernateTypeDescriptor().getExplicitType(); // we need to dirty check collections, since they can cause an owner // version number increment // we need to dirty check many-to-ones with not-found=""ignore"" in order // to update the cache (not the database), since in this case a null // entity reference can lose information boolean alwaysDirtyCheck = type.isAssociationType() && ( (AssociationType) type ).isAlwaysDirtyChecked(); if ( property.isSimpleValue() ) { SimpleAttributeBinding simpleProperty = ( SimpleAttributeBinding ) property; return new StandardProperty( simpleProperty.getAttribute().getName(), simpleProperty.getNodeName(), type, lazyAvailable && simpleProperty.isLazy(), simpleProperty.isInsertable(), simpleProperty.isUpdatable(), simpleProperty.getGeneration() == PropertyGeneration.INSERT || simpleProperty.getGeneration() == PropertyGeneration.ALWAYS, simpleProperty.getGeneration() == PropertyGeneration.ALWAYS, simpleProperty.isNullable(), alwaysDirtyCheck || simpleProperty.isUpdatable(), simpleProperty.isOptimisticLockable(), // TODO: get cascadeStyle from simpleProperty when HHH-6355 is fixed; for now, assume NONE //simpleProperty.getCascadeStyle(), CascadeStyle.NONE, // TODO: get fetchMode() from simpleProperty when HHH-6357 is fixed; for now, assume FetchMode.DEFAULT //simpleProperty.getFetchMode() FetchMode.DEFAULT ); } else { PluralAttributeBinding pluralProperty = ( PluralAttributeBinding ) property; return new StandardProperty( pluralProperty.getAttribute().getName(), pluralProperty.getNodeName(), type, lazyAvailable && pluralProperty.isLazy(), // TODO: fix this when HHH-6356 is fixed; for now assume PluralAttributeBinding is updatable and insertable // pluralProperty.isInsertable(), //pluralProperty.isUpdatable(), true, true, false, false, pluralProperty.isNullable(), // TODO: fix this when HHH-6356 is fixed; for now assume PluralAttributeBinding is updatable and insertable //alwaysDirtyCheck || pluralProperty.isUpdatable(), true, pluralProperty.isOptimisticLocked(), // TODO: get cascadeStyle from property when HHH-6355 is fixed; for now, assume NONE //pluralProperty.getCascadeStyle(), CascadeStyle.NONE, // TODO: get fetchMode() from simpleProperty when HHH-6357 is fixed; for now, assume FetchMode.DEFAULT //pluralProperty.getFetchMode() FetchMode.DEFAULT ); } }"	"Generate a ""standard"" (i.e., non-identifier and non-version) based on the given mapped property."	0	1
public boolean isMirrored() { if (!fMirroringEnabled) return false; Object property = getProperty(MIRRORED); return property instanceof Boolean && (Boolean) property; }	Only the views are mirrored.	1	0
"public Element writeSchema(Class javaType, Types types) throws Exception { // Let the caller generate WSDL if this is not a SimpleType if (!SimpleType.class.isAssignableFrom(javaType)) return null; // ComplexType representation of SimpleType bean class Element complexType = types.createElement(""complexType""); types.writeSchemaElement(xmlType, complexType); complexType.setAttribute(""name"", xmlType.getLocalPart()); // Produce simpleContent extending base type. Element simpleContent = types.createElement(""simpleContent""); complexType.appendChild(simpleContent); Element extension = types.createElement(""extension""); simpleContent.appendChild(extension); // Get the base type from the ""value"" element of the bean String base = ""string""; for (int i=0; i<propertyDescriptor.length; i++) { String propName = propertyDescriptor[i].getName(); if (!propName.equals(""value"")) { if (typeDesc != null) { FieldDesc field = typeDesc.getFieldByName(propName); if (field != null) { if (field.isElement()) { // throw? } QName qname = field.getXmlName(); if (qname == null) { // Use the default... qname = new QName("""", propName); } // write attribute element Class fieldType = propertyDescriptor[i].getType(); // Attribute must be a simple type, enum or SimpleType if (!types.isAcceptableAsAttribute(fieldType)) { throw new AxisFault(Messages.getMessage(""AttrNotSimpleType00"", propName, fieldType.getName())); } // write attribute element // TODO the attribute name needs to be preserved from the XML Element elem = types.createAttributeElement(propName, fieldType, field.getXmlType(), false, extension.getOwnerDocument()); extension.appendChild(elem); } } continue; } BeanPropertyDescriptor bpd = propertyDescriptor[i]; Class type = bpd.getType(); // Attribute must extend a simple type, enum or SimpleType if (!types.isAcceptableAsAttribute(type)) { throw new AxisFault(Messages.getMessage(""AttrNotSimpleType01"", type.getName())); } base = types.writeType(type); extension.setAttribute(""base"", base); } // done return complexType; }"	Return XML schema for the specified type, suitable for insertion into the element of a WSDL document.	1	0
public boolean add(String tagId, String category) { return isCategoryValid(category) && mSelectedTopics.add(tagId); }	Add a tag to the set of filters	1	0
public Options includeDirectives(boolean flag) { return new Options(this.includeIntrospectionTypes, this.includeScalars, this.includeExtendedScalars, this.includeSchemaDefinition, this.useAstDefinitions, this.descriptionsAsHashComments, directive -> flag, this.comparatorRegistry); }	Allow to print directives.	0	1
public static String[] getModulePrefixes(ServletContext context) { return (String[]) context.getAttribute(Globals.MODULE_PREFIXES_KEY); }	Return the list of module prefixes that are defined for this web application, creating it if necessary.	1	0
private ObjectWriter buildColumn(ParentShim parent, ColumnMetadata colSchema) { if (colSchema.isMultiList()) { return buildRepeatedList(parent, colSchema); } else if (colSchema.isMap()) { return buildMap(parent, colSchema); } else if (isSingleList(colSchema)) { return buildSingleList(parent, colSchema); } else if (colSchema.isVariant()) { return buildVariant(parent, colSchema); } else if (colSchema.isDict()) { return buildDict(parent, colSchema); } else { return buildPrimitive(parent, colSchema); } }	Build the column writer, and any nested content, returning the built column writer as a generic object writer.	0	1
public long getDifferenceAsLong(ReadableInstant instant) { if (instant == null) { return getField().getDifferenceAsLong(getMillis(), DateTimeUtils.currentTimeMillis()); } return getField().getDifferenceAsLong(getMillis(), instant.getMillis()); }	Returns the difference between this field property instant and the one passed in, in the units of this field.	0	1
public ResourceRepo removeResource(Resource resource) { if ((this.resourceRepos == null) || (resource == null)) { return null; } ResourceRepo doomed = null; for (ResourceRepo rc : this.resourceRepos) { if (resource.equals(rc.getResourceRepoPK().getResource())) { doomed = rc; break; } } if (doomed != null) { this.resourceRepos.remove(doomed); } return doomed; }	Unsubscribes the resource from this channel, if it exists.	1	0
public boolean isFlagSet(int flagsToCheck) { return (flags & flagsToCheck) != 0; }	Checks if a flag is set.	1	0
"public static IType createType(IASTDeclarator declarator) { IASTDeclSpecifier declSpec = null; IASTNode node = declarator.getParent(); while( node instanceof IASTDeclarator ){ declarator = (IASTDeclarator) node; node = node.getParent(); } if( node instanceof IASTParameterDeclaration ) declSpec = ((IASTParameterDeclaration) node).getDeclSpecifier(); else if( node instanceof IASTSimpleDeclaration ) declSpec = ((IASTSimpleDeclaration)node).getDeclSpecifier(); else if( node instanceof IASTFunctionDefinition ) declSpec = ((IASTFunctionDefinition)node).getDeclSpecifier(); else if( node instanceof IASTTypeId ) declSpec = ((IASTTypeId)node).getDeclSpecifier(); boolean isParameter = ( node instanceof IASTParameterDeclaration || node.getParent() instanceof ICASTKnRFunctionDeclarator ); IType type = null; //C99 6.7.5.3-12 The storage class specifier for a parameter declaration is ignored unless the declared parameter is one of the //members of the parameter type list for a function definition. if( isParameter && node.getParent().getParent() instanceof IASTFunctionDefinition ){ type = createBaseType( declSpec ); } else { type = createType( declSpec ); } type = createType( type, declarator ); if( isParameter ) { //C99: 6.7.5.3-7 a declaration of a parameter as ""array of type"" shall be adjusted to ""qualified pointer to type"", where the //type qualifiers (if any) are those specified within the [ and ] of the array type derivation if( type instanceof IArrayType ){ CArrayType at = (CArrayType) type; type = new CQualifiedPointerType( at.getType(), at.getModifier() ); } else if( type instanceof IFunctionType ) { //-8 A declaration of a parameter as ""function returning type"" shall be adjusted to ""pointer to function returning type"" type = new CPointerType( type ); } } return type; }"	Create an IType for an IASTName.	1	0
public static PTBTokenizer<CoreLabel> newPTBTokenizer(Reader r, boolean tokenizeNLs, boolean invertible) { return new PTBTokenizer<>(r, tokenizeNLs, invertible, false, new CoreLabelTokenFactory()); }	Constructs a new PTBTokenizer that makes CoreLabel tokens.	0	1
"private ZapTextArea getTxtSkipURL() { if (txtSkipURL == null) { txtSkipURL = new ZapTextArea(); txtSkipURL.setFont(new java.awt.Font(""Default"", java.awt.Font.PLAIN, 11)); if (Model.getSingleton().getOptionsParam().getViewParam().getWmUiHandlingOption() == 0) { txtSkipURL.setSize(new java.awt.Dimension(290,52)); } } return txtSkipURL; }"	This method initializes jTextArea	1	0
protected Object convertTimestamp(Field fieldDefn, Object data) { java.util.Date date = null; if (data instanceof java.sql.Timestamp) { // JDBC specification indicates that this will be the canonical object for this JDBC type. date = (java.util.Date) data; } else if (data instanceof java.sql.Date) { // This should still work, even though it should have just date info date = (java.util.Date) data; } else if (data instanceof java.util.Date) { // Possible that some implementations might use this. date = (java.util.Date) data; } else if (data instanceof java.time.LocalDate) { // If we get a local date (no TZ info), we need to just convert to a util.Date (no TZ info) ... java.time.LocalDate local = (java.time.LocalDate) data; date = java.util.Date.from(local.atStartOfDay().toInstant(ZoneOffset.UTC)); } else if (data instanceof java.time.LocalDateTime) { // Get the instant in time by changing any date info to the epoch day so we only have time ... java.time.LocalDateTime local = (java.time.LocalDateTime) data; date = java.util.Date.from(local.toInstant(ZoneOffset.UTC)); } else { // An unexpected date = unexpectedTimestamp(data, fieldDefn); } return date; }	Converts a value object for an expected JDBC type of Types#TIMESTAMP.	0	1
public static Boolean areColumnsUnique(RelNode rel, BitSet columns) { final BuiltInMetadata.ColumnUniqueness metadata = rel.metadata(BuiltInMetadata.ColumnUniqueness.class); return metadata.areColumnsUnique(columns, false); }	Determines if a specified set of columns from a specified relational expression are unique.	1	0
public static Observable<Boolean> observeInternetConnectivity() { return observeInternetConnectivity(DEFAULT_INITIAL_PING_INTERVAL_IN_MS, DEFAULT_PING_INTERVAL_IN_MS, DEFAULT_PING_HOST, DEFAULT_PING_PORT, DEFAULT_PING_TIMEOUT_IN_MS, new DefaultErrorHandler()); }	Observes connectivity with the Internet with default settings.	0	1
public static EBoolean endsWith(Expr<String> left, String right) { return operationFactory.createBoolean(Ops.ENDSWITH, left, exprFactory .createConstant(right)); }	Expr : left.endsWith(right) (ignore case)	1	0
private Frame getFrame(RelNode r, boolean safe) { final Frame frame = map.get(r); if (frame == null && safe) { return new Frame(r, r, ImmutableSortedMap.of(), identityMap(r.getRowType().getFieldCount())); } return frame; }	Create RelNode tree that produces a list of correlated variables.	0	1
public RowSetBuilder addSingleCol(Object value) { return addRow(new Object[] { value }); }	The #add(Object...) method uses Java variable-length arguments to pass a row of values.	1	0
public boolean shouldBuffer() { Window window = runningQuery.getQuery().getWindow(); boolean noWindow = window == null; // Only buffer if there is no window (including Raw) or if it's a record based window. return noWindow || !window.isTimeBased(); }	Returns if this query should buffer before emitting results.	1	0
public MenuItem addItem(String text, boolean asHTML, Command cmd) { return addItem(new MenuItem(text, asHTML, cmd)); }	Adds a menu item to the bar containing SafeHtml, that will fire the given command when it is selected.	1	0
public String appendIdentitySelectToInsert(String insertString) { return getIdentityColumnSupport().appendIdentitySelectToInsert( insertString ); }	"Provided we #supportsInsertSelectIdentity, then attach the ""select identity"" clause to the insert statement."	0	1
private ColumnDescriptor getColumn(int columnIndex) { Tree tree = viewer.getTree(); TreeColumn column = tree.getColumn(columnIndex); ColumnDescriptor descriptor = (ColumnDescriptor) column.getData(); return descriptor; }	Get the specific column's ContextColumn object.	1	0
protected CoreLabel fromProto(CoreNLPProtos.Token proto) { CoreLabel word = new CoreLabel(); // Required fields word.setWord(proto.getWord()); // Optional fields if (proto.hasPos()) { word.setTag(proto.getPos()); } if (proto.hasValue()) { word.setValue(proto.getValue()); } if (proto.hasCategory()) { word.setCategory(proto.getCategory()); } if (proto.hasBefore()) { word.setBefore(proto.getBefore()); } if (proto.hasAfter()) { word.setAfter(proto.getAfter()); } if (proto.hasOriginalText()) { word.setOriginalText(proto.getOriginalText()); } if (proto.hasNer()) { word.setNER(proto.getNer()); } if (proto.hasLemma()) { word.setLemma(proto.getLemma()); } if (proto.hasBeginChar()) { word.setBeginPosition(proto.getBeginChar()); } if (proto.hasEndChar()) { word.setEndPosition(proto.getEndChar()); } if (proto.hasSpeaker()) { word.set(SpeakerAnnotation.class, proto.getSpeaker()); } if (proto.hasUtterance()) { word.set(UtteranceAnnotation.class, proto.getUtterance()); } if (proto.hasBeginIndex()) { word.set(BeginIndexAnnotation.class, proto.getBeginIndex()); } if (proto.hasEndIndex()) { word.set(EndIndexAnnotation.class, proto.getEndIndex()); } if (proto.hasTokenBeginIndex()) { word.set(TokenBeginAnnotation.class, proto.getTokenBeginIndex()); } if (proto.hasTokenEndIndex()) { word.set(TokenEndAnnotation.class, proto.getTokenEndIndex()); } if (proto.hasNormalizedNER()) { word.set(NormalizedNamedEntityTagAnnotation.class, proto.getNormalizedNER()); } if (proto.hasTimexValue()) { word.set(TimexAnnotation.class, fromProto(proto.getTimexValue())); } if (proto.hasHasXmlContext() && proto.getHasXmlContext()) { word.set(XmlContextAnnotation.class, proto.getXmlContextList()); } if (proto.hasCorefClusterID()) { word.set(CorefClusterIdAnnotation.class, proto.getCorefClusterID()); } if (proto.hasAnswer()) { word.set(AnswerAnnotation.class, proto.getAnswer()); } // Non-default annotators if (proto.hasGender()) { word.set(GenderAnnotation.class, proto.getGender()); } if (proto.hasTrueCase()) { word.set(TrueCaseAnnotation.class, proto.getTrueCase()); } if (proto.hasTrueCaseText()) { word.set(TrueCaseTextAnnotation.class, proto.getTrueCaseText()); } // Return return word; }	Create a CoreMap representing a sentence from this protocol buffer.	1	0
public boolean isFlagSet(int flagsToCheck) { return isFlagSet(flags, flagsToCheck); }	Checks if a flag is set.	1	0
public static Query parse(String queryString, BulletConfig config) { Query query = GSON.fromJson(queryString, Query.class); query.configure(config); return query; }	Parses a Specification out of the query string.	1	0
public final DBCompareColExpr in(Collection<?> values) { if (values==null || values.isEmpty()) return cmp(DBCmpType.EQUAL, null); // create expression return cmp(DBCmpType.IN, values); }	"Creates and returns a new comparison object for the SQL ""in"" operator."	1	0
public String getAuthorizationUrl() { return createAuthorizationUrlBuilder().build(); }	Returns the URL where you should redirect your users to authenticate your application.	0	1
public boolean equals(Object obj) { if (obj == null) { return false; } if (obj == this) { return true; } if (obj.getClass() != getClass()) { return false; } FiltersAggregation rhs = (FiltersAggregation) obj; return super.equals(obj) && Objects.equals(bucketMap, rhs.bucketMap); }	Method for getting counts using named filters	0	1
"public String getMatchedSentences() { StringBuilder sb = new StringBuilder(); for (int i = 0, sz = list.getModel().getSize(); i < sz; i++) { String t = list.getModel().getElementAt(i).getLabel().getText(); sb.append(t); sb.append(""\n""); } return sb.toString(); }"	Returns all currently displayed sentences in string buffer, plain text form	1	0
"protected Checkmark findNewest() { return new Select().from(Checkmark.class) .where(""habit = ?"", habit.getId()) .and(""timestamp <= ?"", DateUtils.getStartOfToday()) .orderBy(""timestamp desc"") .limit(1) .executeSingle(); }"	Returns newest checkmark that has already been computed.	0	1
public static List handleHTML(HttpURLConnection httpCon) throws IOException { ContentHandler handler = new HTMLHandler(); handler.parse(httpCon.getInputStream()); if (handler.getRobotFollow()) { List links = handler.getLinks(); return links; } return null; }	DOCUMENT ME!	1	0
public static Schema getReferencedSchema(OpenAPI openAPI, Schema schema) { if (schema != null && StringUtils.isNotEmpty(schema.get$ref())) { String name = getSimpleRef(schema.get$ref()); Schema referencedSchema = getSchema(openAPI, name); if(referencedSchema != null) { return referencedSchema; } } return schema; }	If a Schema contains a reference to an other Schema with '$ref', returns the referenced Schema or the actual Schema in the other cases.	1	0
public ArrayList<GridView> getCurrentGridViews() { return getCurrentViews(GridView.class); }	Returns a List of the GridViews contained in the current Activity.	0	1
"public boolean updateComponent(Widget component, UIDL uidl, boolean manageCaption) { // Switch to correct implementation if neede if (!widgetFactory.isCorrectImplementation(component, uidl)) { Layout parent = getParentLayout(component); if (parent != null) { Widget w = widgetFactory.createWidget(uidl); registerPaintable(uidl.getId(), (Paintable) w); parent.replaceChildComponent(component, w); ((Paintable) w).updateFromUIDL(uidl, this); return true; } } // Set captions // TODO Manage Error messages if (manageCaption) { Layout parent = getParentLayout(component); if (parent != null) parent.updateCaption(component, uidl); } // Visibility, Disabling and read-only status if (component instanceof FocusWidget) ((FocusWidget) component).setEnabled(!uidl .getBooleanAttribute(""disabled"")); boolean visible = !uidl.getBooleanAttribute(""invisible""); component.setVisible(visible); if (!visible) return true; return false; }"	Ensure that correct implementation is used for the component.	1	0
private HttpSession getMatchingHttpSession(List<HttpCookie> cookies, final HttpSessionTokensSet siteTokens) { Collection<HttpSession> sessionsCopy; synchronized (sessions) { sessionsCopy = new ArrayList<>(sessions); } return CookieBasedSessionManagementHelper.getMatchingHttpSession(sessionsCopy, cookies, siteTokens); }	Gets the matching http session for a particular message containing a list of cookies.	0	1
public Node getSecondNode() { return m_node2; } //	Return the GraphItem representing the second (target) node in the edge.	1	0
"protected static ASTNode findDeclaration(Name findMe) { // WARNING: You're entering the Rube Goldberg territory of Experimental Mode. // To debug this code, thou must take the Recursive Leap of Faith. // log(""entering --findDeclaration1 -- "" + findMe.toString()); ASTNode declaringClass = null; ASTNode parent = findMe.getParent(); ASTNode ret = null; ArrayList<Integer> constrains = new ArrayList<Integer>(); if (parent.getNodeType() == ASTNode.METHOD_INVOCATION) { Expression exp = (Expression) ((MethodInvocation) parent) .getStructuralProperty(MethodInvocation.EXPRESSION_PROPERTY); //TODO: Note the imbalance of constrains.add(ASTNode.METHOD_DECLARATION); // Possibly a bug here. Investigate later. if (((MethodInvocation) parent).getName().toString() .equals(findMe.toString())) { constrains.add(ASTNode.METHOD_DECLARATION); if (exp != null) { constrains.add(ASTNode.TYPE_DECLARATION); // log(""MI EXP: "" + exp.toString() + "" of type "" // + exp.getClass().getName() + "" parent: "" + exp.getParent()); if (exp instanceof MethodInvocation) { SimpleType stp = extracTypeInfo(findDeclaration(((MethodInvocation) exp) .getName())); if (stp == null) return null; declaringClass = findDeclaration(stp.getName()); return definedIn(declaringClass, ((MethodInvocation) parent) .getName().toString(), constrains, declaringClass); } else if (exp instanceof FieldAccess) { SimpleType stp = extracTypeInfo(findDeclaration(((FieldAccess) exp) .getName())); if (stp == null) return null; declaringClass = findDeclaration((stp.getName())); return definedIn(declaringClass, ((MethodInvocation) parent) .getName().toString(), constrains, declaringClass); } if (exp instanceof SimpleName) { SimpleType stp = extracTypeInfo(findDeclaration(((SimpleName) exp))); if (stp == null) return null; declaringClass = findDeclaration(stp.getName()); // log(""MI.SN "" + getNodeAsString(declaringClass)); constrains.add(ASTNode.METHOD_DECLARATION); return definedIn(declaringClass, ((MethodInvocation) parent) .getName().toString(), constrains, declaringClass); } } } else { parent = parent.getParent(); // Move one up the ast. V V IMP!! } } else if (parent.getNodeType() == ASTNode.FIELD_ACCESS) { FieldAccess fa = (FieldAccess) parent; Expression exp = fa.getExpression(); if (fa.getName().toString().equals(findMe.toString())) { constrains.add(ASTNode.FIELD_DECLARATION); if (exp != null) { constrains.add(ASTNode.TYPE_DECLARATION); // log(""FA EXP: "" + exp.toString() + "" of type "" // + exp.getClass().getName() + "" parent: "" + exp.getParent()); if (exp instanceof MethodInvocation) { SimpleType stp = extracTypeInfo(findDeclaration(((MethodInvocation) exp) .getName())); if (stp == null) return null; declaringClass = findDeclaration(stp.getName()); return definedIn(declaringClass, fa.getName().toString(), constrains, declaringClass); } else if (exp instanceof FieldAccess) { SimpleType stp = extracTypeInfo(findDeclaration(((FieldAccess) exp) .getName())); if (stp == null) return null; declaringClass = findDeclaration((stp.getName())); constrains.add(ASTNode.TYPE_DECLARATION); return definedIn(declaringClass, fa.getName().toString(), constrains, declaringClass); } if (exp instanceof SimpleName) { SimpleType stp = extracTypeInfo(findDeclaration(((SimpleName) exp))); if (stp == null) return null; declaringClass = findDeclaration(stp.getName()); // log(""FA.SN "" + getNodeAsString(declaringClass)); constrains.add(ASTNode.METHOD_DECLARATION); return definedIn(declaringClass, fa.getName().toString(), constrains, declaringClass); } } } else { parent = parent.getParent(); // Move one up the ast. V V IMP!! } } else if (parent.getNodeType() == ASTNode.QUALIFIED_NAME) { QualifiedName qn = (QualifiedName) parent; if (!findMe.toString().equals(qn.getQualifier().toString())) { SimpleType stp = extracTypeInfo(findDeclaration((qn.getQualifier()))); // log(qn.getQualifier() + ""->"" + qn.getName()); if (stp == null) { return null; } declaringClass = findDeclaration(stp.getName()); // log(""QN decl class: "" + getNodeAsString(declaringClass)); constrains.clear(); constrains.add(ASTNode.TYPE_DECLARATION); constrains.add(ASTNode.FIELD_DECLARATION); return definedIn(declaringClass, qn.getName().toString(), constrains, null); } else{ if(findMe instanceof QualifiedName){ QualifiedName qnn = (QualifiedName) findMe; // log(""findMe is a QN, "" // + (qnn.getQualifier().toString() + "" other "" + qnn.getName() // .toString())); SimpleType stp = extracTypeInfo(findDeclaration((qnn.getQualifier()))); if (stp == null) { return null; } declaringClass = findDeclaration(stp.getName()); constrains.clear(); constrains.add(ASTNode.TYPE_DECLARATION); constrains.add(ASTNode.FIELD_DECLARATION); return definedIn(declaringClass, qnn.getName().toString(), constrains, null); } } } else if (parent.getNodeType() == ASTNode.SIMPLE_TYPE) { constrains.add(ASTNode.TYPE_DECLARATION); if (parent.getParent().getNodeType() == ASTNode.CLASS_INSTANCE_CREATION) { constrains.add(ASTNode.CLASS_INSTANCE_CREATION); } } else if (parent.getNodeType() == ASTNode.TYPE_DECLARATION) { // The condition where we look up the name of a class decl TypeDeclaration td = (TypeDeclaration) parent; if (findMe.equals(td.getName())) { return parent; } } else if (parent instanceof Expression) { // constrains.add(ASTNode.TYPE_DECLARATION); // constrains.add(ASTNode.METHOD_DECLARATION); // constrains.add(ASTNode.FIELD_DECLARATION); } // else if(findMe instanceof QualifiedName){ // QualifiedName qn = (QualifiedName) findMe; // System.out // .println(""findMe is a QN, "" // + (qn.getQualifier().toString() + "" other "" + qn.getName() // .toString())); // } while (parent != null) { // log(""findDeclaration1 -> "" + getNodeAsString(parent)); for (Object oprop : parent.structuralPropertiesForType()) { StructuralPropertyDescriptor prop = (StructuralPropertyDescriptor) oprop; if (prop.isChildProperty() || prop.isSimpleProperty()) { if (parent.getStructuralProperty(prop) instanceof ASTNode) { // log(prop + "" C/S Prop of -> "" // + getNodeAsString(parent)); ret = definedIn((ASTNode) parent.getStructuralProperty(prop), findMe.toString(), constrains, declaringClass); if (ret != null) return ret; } } else if (prop.isChildListProperty()) { // log((prop) + "" ChildList props of "" // + getNodeAsString(parent)); List<ASTNode> nodelist = (List<ASTNode>) parent .getStructuralProperty(prop); for (ASTNode retNode : nodelist) { ret = definedIn(retNode, findMe.toString(), constrains, declaringClass); if (ret != null) return ret; } } } parent = parent.getParent(); } return null; }"	Give this thing a Name instance - a SimpleName from the	0	1
"public Action timedout(AtmosphereRequest request, AtmosphereResponse response) throws IOException, ServletException { AtmosphereResourceImpl r = null; try { SessionTimeoutSupport.restoreTimeout(request); if (trackActiveRequest) { long l = (Long) request.getAttribute(MAX_INACTIVE); if (l == -1) { // The closedDetector closed the connection. return timedoutAction; } request.setAttribute(MAX_INACTIVE, (long) -1); } logger.debug(""Timing out the connection for request {}"", request); // Something went wrong. if (request == null || response == null) { logger.warn(""Invalid Request/Response: {}/{}"", request, response); return timedoutAction; } r = (AtmosphereResourceImpl) request.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE); if (r != null && r.getAtmosphereResourceEvent().isSuspended()) { r.getAtmosphereResourceEvent().setIsResumedOnTimeout(true); Broadcaster b = r.getBroadcaster(); if (b instanceof DefaultBroadcaster) { ((DefaultBroadcaster) b).broadcastOnResume(r); } if (request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT) != null) { r.getAtmosphereResourceEvent().setIsResumedOnTimeout( (Boolean) request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT)); } invokeAtmosphereHandler(r); } } catch (Throwable t) { logger.error(""failed to timeout resource {}"", r, t); } finally { config.framework().notify(Action.TYPE.TIMEOUT, request, response); try { if (r != null) { r.notifyListeners(); r.setIsInScope(false); r.cancel(); } } catch (Throwable t) { logger.trace(""timedout"", t); } finally { try { response.getOutputStream().close(); } catch (Throwable t) { try { response.getWriter().close(); } catch (Throwable t2) { } } if (r != null) { destroyResource(r); } } } return timedoutAction; }"	All proprietary Comet based Servlet must invoke the timedout method when the underlying WebServer time out the AtmosphereResponse.	0	1
File getBaseDir(final File file1, final File file2) { if (file1 == null || file2 == null) { return null; } final Iterator bases = getParents(file1).iterator(); final Iterator fileParents = getParents(file2.getAbsoluteFile()).iterator(); File result = null; while (bases.hasNext() && fileParents.hasNext()) { File next = (File) bases.next(); if (next.equals(fileParents.next())) { result = next; } else { break; } } return result; }	Returns the common base directory between a current base directory and a given file.	1	0
public ArrayList<RadioButton> getCurrentRadioButtons() { return viewFetcher.getCurrentViews(RadioButton.class); }	Returns an ArrayList of the RadioButtons contained in the current Activity.	0	1
public static StringExpression stringTemplate(String template, Object... args) { return new StringTemplate(createTemplate(template), ImmutableList.copyOf(args)); }	Create a new Template expression	0	1
"private boolean installRemotePackages( @NonNull List<RemotePackage> requestPackages, @NonNull RepoManager repoManager, @NonNull Downloader downloader, @NonNull ProgressIndicator progress) { List<RemotePackage> remotePackages = InstallerUtil.computeRequiredPackages( requestPackages, repoManager.getPackages(), progress); if (remotePackages == null) { return false; } for (RemotePackage p : remotePackages) { if (p.getLicense() != null && !p.getLicense().checkAccepted( repoManager.getLocalPath(), mSdkHandler.getFileOp())) { progress.setText( ""The license for package "" + p.getDisplayName() + "" was not accepted. "" + ""Please install this package through Android Studio SDK "" + ""Manager.""); return false; } Installer installer = SdkInstallerUtil .findBestInstallerFactory(p, mSdkHandler) .createInstaller(p, repoManager, downloader, mSdkHandler.getFileOp()); boolean result = installer.prepare(progress) && installer.complete(progress); if (!result) { return false; } } return true; }"	Installs a list of RemotePackage and their dependent packages.	1	0
"private String getConfigurationTable(Connection con) { try { if (StorageManager.getStorageImpl(con.getMetaData().getDatabaseProductName()).requiresConfigSchema()) { if (DatabaseConst.getConfigSchema().endsWith(""."")) return DatabaseConst.getConfigSchema() + TBL_GLOBAL_CONFIG; else return DatabaseConst.getConfigSchema() + ""."" + TBL_GLOBAL_CONFIG; } } catch (SQLException e) { LOG.warn(e); } return TBL_GLOBAL_CONFIG; }"	Get the global configuration table name including the correct escaped schema	1	0
public List<Tree> getChildrenAsList() { return new ArrayList<>(Arrays.asList(children())); }	Returns a List of children for the current node.	0	1
public UninstallationResult calculateUninstallChanges(Set<AddOn> selectedAddOns) { List<AddOn> remainingAddOns = new ArrayList<>(installedAddOns.getAddOns()); remainingAddOns.removeAll(selectedAddOns); Set<AddOn> uninstallations = new HashSet<>(); List<AddOn> addOnsToCheck = new ArrayList<>(remainingAddOns); while (!addOnsToCheck.isEmpty()) { AddOn addOn = addOnsToCheck.remove(0); AddOn.AddOnRunRequirements requirements = addOn.calculateRunRequirements(remainingAddOns); if (!requirements.hasDependencyIssue()) { addOnsToCheck.removeAll(requirements.getDependencies()); } else if (AddOn.InstallationStatus.UNINSTALLATION_FAILED != addOn.getInstallationStatus()) { uninstallations.add(addOn); } } for (Iterator<AddOn> it = uninstallations.iterator(); it.hasNext();) { AddOn addOn = it.next(); if (addOn.calculateRunRequirements(installedAddOns.getAddOns()).hasDependencyIssue() && !containsAny(addOn.getIdsAddOnDependencies(), uninstallations)) { it.remove(); } } remainingAddOns.removeAll(uninstallations); Set<Extension> extensions = new HashSet<>(); for (AddOn addOn : remainingAddOns) { if (addOn.hasExtensionsWithDeps()) { for (Extension ext : addOn.getLoadedExtensions()) { AddOn.AddOnRunRequirements requirements = addOn.calculateExtensionRunRequirements(ext, remainingAddOns); if (!requirements.getExtensionRequirements().isEmpty()) { AddOn.ExtensionRunRequirements extReqs = requirements.getExtensionRequirements().get(0); if (!extReqs.isRunnable()) { extensions.add(ext); } } } } } uninstallations.addAll(selectedAddOns); return new UninstallationResult(selectedAddOns, uninstallations, extensions); }	Calculates the changes required to uninstall the given add-ons.	0	1
static public IStructuredTextExpert getStatefulExpert(StructuredTextTypeHandler handler, StructuredTextEnvironment environment) { if (environment == null) environment = StructuredTextEnvironment.DEFAULT; return new StructuredTextImpl(handler, environment, true); }	Obtains a ISTextExpert instance for processing structured text with the specified type handler and the specified environment.	1	0
public String print(ReadablePartial partial) { StringBuilder builder = new StringBuilder(requirePrinter().estimatePrintedLength()); try { printTo(builder, partial); } catch (IOException e) { // StringBuilder does not throw IOException } return builder.toString(); }	Prints a ReadablePartial to a new String.	0	1
@GET public Set<CassandraInstance> findAll() { return service.findAll(); }	Return the list of Cassandra instances ordered by position on ring, indicated by token.	1	0
"public static PathMetadata<String> forProperty(Path<?> parent, String property) { return new PathMetadata<String>(parent, Assert.hasLength(property,""property""), PathType.PROPERTY); }"	Create a new PathMetadata for property access	0	1
"public static Token seek(String path, Parser parser) { // return current token if no path is given if (!StringUtils.hasText(path)) { return null; } List<String> tokens = StringUtils.tokenize(path, ""/""); return seek(parser, tokens.toArray(new String[tokens.size()])); }"	Seeks the field with the given name in the stream and positions (and returns) the parser to the next available token (value or not).	0	1
"public static Treepath getNextSibling( Treepath treepath ) { if( treepath.getHeight() < 2 ) { throw new IllegalArgumentException( ""Treepath must have minimum height of 2"" ) ; } final Tree treeToMove = treepath.getBottom() ; final Tree parent = treepath.getTreeAtHeight( 1 ) ; for( int i = 0 ; i < parent.getChildCount() - 1 ; i++ ) { final Tree child = parent.getChildAt( i ) ; if( child == treeToMove ) { return Treepath.create( treepath.getParent(), parent.getChildAt( i + 1 ) ) ; } } throw new IllegalArgumentException( ""No next sibling"" ) ; }"	Returns the sibling on the right of the end of given Treepath.	1	0
public static int[] getViewToHeaderPosition(JTextArea view, int start, int end) { validateView(view); validateStartEnd(start, end); if (!isValidStartEndForLength(start, end, view.getDocument().getLength())) { return INVALID_POSITION; } return getViewToHeaderPositionImpl(view, start, end); }	Gets the given start and end view positions offset to a header.	0	1
public Element writeSchema(Class javaType, Types types) throws Exception { return null; }	Return XML schema for the specified type, suitable for insertion into the &lt;types&gt; element of a WSDL document.	1	0
public static String getPluginQuality(PluginPassiveScanner scanner) { // String scannerPackage = scanner.getClass().getCanonicalName(); String scannerName = scanner.getName(); return (getSpecificQuality(scannerName, scanner)); }	Gets the quality or status of the given passive scanner.	0	1
public static String asJson(Object object) throws IOException { return JSON.writeValueAsString(object); }	Converts the given object into a JSON AST.	1	0
"private JXTable getTableExtension() { if (tableExt == null) { tableExt = new JXTable(); tableExt.setModel(getExtensionModel()); tableExt.setRowHeight(DisplayUtils.getScaledSize(18)); tableExt.getColumnModel().getColumn(0).setPreferredWidth(DisplayUtils.getScaledSize(70)); tableExt.getColumnModel().getColumn(1).setPreferredWidth(DisplayUtils.getScaledSize(70)); tableExt.getColumnModel().getColumn(2).setPreferredWidth(DisplayUtils.getScaledSize(120)); tableExt.getColumnModel().getColumn(3).setPreferredWidth(DisplayUtils.getScaledSize(220)); tableExt.setSortOrder(3, SortOrder.ASCENDING); ListSelectionListener sl = new ListSelectionListener() { @Override public void valueChanged(ListSelectionEvent arg0) { int selectedRow = tableExt.getSelectedRow(); if (selectedRow > -1) { Extension ext = getExtensionModel().getExtension(tableExt.convertRowIndexToModel(selectedRow)); if (ext != null) { try { extName.setText(ext.getUIName()); extDescription.setText(ext.getDescription()); if (ext.getAuthor() != null) { extAuthor.setText(ext.getAuthor()); } else { extAuthor.setText(""""); } if (ext.getURL() != null) { extURL.setText(ext.getURL().toString()); getUrlLaunchButton().setEnabled(true); } else { extURL.setText(""""); getUrlLaunchButton().setEnabled(false); } } catch (Exception e) { // Just to be safe log.error(e.getMessage(), e); } } } }}; tableExt.getSelectionModel().addListSelectionListener(sl); tableExt.setColumnControlVisible(true); } return tableExt; }"	This method initializes tableAuth	0	1
public ArrayList getImageSrcs() { return this.img_src; }	DOCUMENT ME!	1	0
"protected Tree determineNonTrivialHead(Tree t, Tree parent) { String motherCat = tlp.basicCategory(t.label().value()); if (DEBUG) { System.err.println(""At "" + motherCat + "", my parent is "" + parent); } // do VPs with auxiliary as special case if ((motherCat.equals(""VP"") || motherCat.equals(""SQ"") || motherCat.equals(""SINV""))) { Tree[] kids = t.children(); // try to find if there is an auxiliary verb if (DEBUG) { System.err.println(""Semantic head finder: at VP""); System.err.println(""Class is "" + t.getClass().getName()); t.pennPrint(System.err); //System.err.println(""hasVerbalAuxiliary = "" + hasVerbalAuxiliary(kids, verbalAuxiliaries)); } // looks for auxiliaries if (hasVerbalAuxiliary(kids, verbalAuxiliaries, true) || hasPassiveProgressiveAuxiliary(kids)) { // String[] how = new String[] {""left"", ""VP"", ""ADJP"", ""NP""}; // Including NP etc seems okay for copular sentences but is // problematic for other auxiliaries, like 'he has an answer' // But maybe doing ADJP is fine! String[] how = { ""left"", ""VP"", ""ADJP"" }; Tree pti = traverseLocate(kids, how, false); if (DEBUG) { System.err.println(""Determined head (case 1) for "" + t.value() + "" is: "" + pti); } if (pti != null) { return pti; // } else { // System.err.println(""------""); // System.err.println(""SemanticHeadFinder failed to reassign head for""); // t.pennPrint(System.err); // System.err.println(""------""); } } // looks for copular verbs if (hasVerbalAuxiliary(kids, copulars, false) && ! isExistential(t, parent) && ! isWHQ(t, parent)) { String[] how; if (motherCat.equals(""SQ"")) { how = new String[]{""right"", ""VP"", ""ADJP"", ""NP"", ""WHADJP"", ""WHNP""}; } else { how = new String[]{""left"", ""VP"", ""ADJP"", ""NP"", ""WHADJP"", ""WHNP""}; } Tree pti = traverseLocate(kids, how, false); // don't allow a temporal to become head if (pti != null && pti.label() != null && pti.label().value().contains(""-TMP"")) { pti = null; } // In SQ, only allow an NP to become head if there is another one to the left (then it's probably predicative) if (motherCat.equals(""SQ"") && pti != null && pti.label() != null && pti.label().value().startsWith(""NP"")) { boolean foundAnotherNp = false; for (Tree kid : kids) { if (kid == pti) { break; } else if (kid.label() != null && kid.label().value().startsWith(""NP"")) { foundAnotherNp = true; break; } } if ( ! foundAnotherNp) { pti = null; } } if (DEBUG) { System.err.println(""Determined head (case 2) for "" + t.value() + "" is: "" + pti); } if (pti != null) { return pti; } else { if (DEBUG) { System.err.println(""------""); System.err.println(""SemanticHeadFinder failed to reassign head for""); t.pennPrint(System.err); System.err.println(""------""); } } } } Tree hd = super.determineNonTrivialHead(t, parent); /* ---- // This should now be handled at the AbstractCollinsHeadFinder level, so see if we can comment this out // Heuristically repair punctuation heads Tree[] hdChildren = hd.children(); if (hdChildren != null && hdChildren.length > 0 && hdChildren[0].isLeaf()) { if (tlp.isPunctuationWord(hdChildren[0].label().value())) { Tree[] tChildren = t.children(); if (DEBUG) { System.err.printf(""head is punct: %s\n"", hdChildren[0].label()); } for (int i = tChildren.length - 1; i >= 0; i--) { if (!tlp.isPunctuationWord(tChildren[i].children()[0].label().value())) { hd = tChildren[i]; if (DEBUG) { System.err.printf(""New head of %s is %s%n"", hd.label(), hd.children()[0].label()); } break; } } } } */ if (DEBUG) { System.err.println(""Determined head (case 3) for "" + t.value() + "" is: "" + hd); } return hd; }"	Determine which daughter of the current parse tree is the head.	0	1
public RepoContentSource removeContentSource(ContentSource contentSource) { if ((this.repoContentSources == null) || (contentSource == null)) { return null; } RepoContentSource doomed = null; for (RepoContentSource ccs : this.repoContentSources) { if (contentSource.equals(ccs.getRepoContentSourcePK().getContentSource())) { doomed = ccs; break; } } if (doomed != null) { this.repoContentSources.remove(doomed); } return doomed; }	Removes the content source from this channel, if it exists.	1	0
static Folder fromXml(Launcher launcher) { return (Folder) launcher.getLayoutInflater() .inflate(R.layout.user_folder_icon_normalized, null); }	Creates a new UserFolder, inflated from R.layout.user_folder.	0	1
public ImageSource tilingDisabled() { return setTiling(false); }	Disable tiling of the image.	0	1
public Subject login(AuthenticationToken token) throws AuthenticationException { Account account; try { account = authenticate(token); rememberMeSuccessfulLogin(token, account); } catch (AuthenticationException ae) { rememberMeFailedLogin(token, ae); throw ae; //propagate } Subject secCtx = createSubject(token, account); assertCreation(secCtx); bind(secCtx); return secCtx; }	First authenticates the AuthenticationToken argument, and if successful, constructs a SecurityContext instance representing the authenticated account's identity.	1	0
protected int intersectsValidDropTarget(int id) { LauncherAccessibilityDelegate delegate = LauncherAppState.getInstance().getAccessibilityDelegate(); if (delegate == null) { return -1; } int y = id % mCountY; int x = id / mCountY; LauncherAccessibilityDelegate.DragInfo dragInfo = delegate.getDragInfo(); if (dragInfo.dragType == DragType.WIDGET) { // For a widget, every cell must be vacant. In addition, we will return any valid // drop target by which the passed id is contained. boolean fits = false; // These represent the amount that we can back off if we hit a problem. They // get consumed as we move up and to the right, trying new regions. int spanX = dragInfo.info.spanX; int spanY = dragInfo.info.spanY; for (int m = 0; m < spanX; m++) { for (int n = 0; n < spanY; n++) { fits = true; int x0 = x - m; int y0 = y - n; if (x0 < 0 || y0 < 0) continue; for (int i = x0; i < x0 + spanX; i++) { if (!fits) break; for (int j = y0; j < y0 + spanY; j++) { if (i >= mCountX || j >= mCountY || mOccupied[i][j]) { fits = false; break; } } } if (fits) { return x0 * mCountY + y0; } } } return -1; } else { // For an icon, we simply check the view directly below View child = getChildAt(x, y); if (child == null || child == dragInfo.item) { // Empty cell. Good for an icon or folder. return id; } else if (dragInfo.dragType != DragType.FOLDER) { // For icons, we can consider cells that have another icon or a folder. ItemInfo info = (ItemInfo) child.getTag(); if (info instanceof AppInfo || info instanceof FolderInfo || info instanceof ShortcutInfo) { return id; } } return -1; } }	Find the virtual view id corresponding to the top left corner of any drop region by which the passed id is contained.	0	1
public boolean overlaps(ReadableInterval interval) { if (interval == null) { return containsNow(); } long otherStart = interval.getStartMillis(); long otherEnd = interval.getEndMillis(); long thisStart = getStartMillis(); long thisEnd = getEndMillis(); return (thisStart < otherEnd && otherStart < thisEnd); }	Does this time interval overlap the specified time interval.	0	1
"private NameValuePair[] prepareQueryString(String groupPath, String jobName, Properties options) { List<NameValuePair> queryString = new ArrayList<NameValuePair>(); queryString.add(new NameValuePair(""groupPath"", groupPath)); queryString.add(new NameValuePair(""jobName"", jobName)); if (options != null) { for (Entry<Object, Object> option : options.entrySet()) { queryString.add(new NameValuePair(""extra.command.option."" + option.getKey(), String.valueOf(option.getValue()))); } } return queryString.toArray(new NameValuePair[queryString.size()]); }"	prepares an url-encoded HTTP queryString containing the group/job and the options.	1	0
"public static int getAccentColorFromThemeIfAvailable(Context context) { TypedValue typedValue = new TypedValue(); // First, try the android:colorAccent if (Build.VERSION.SDK_INT >= 21) { context.getTheme().resolveAttribute(android.R.attr.colorAccent, typedValue, true); return typedValue.data; } // Next, try colorAccent from support lib int colorAccentResId = context.getResources().getIdentifier(""colorAccent"", ""attr"", context.getPackageName()); if (colorAccentResId != 0 && context.getTheme().resolveAttribute(colorAccentResId, typedValue, true)) { return typedValue.data; } // Return the value in mdtp_accent_color return ContextCompat.getColor(context, R.color.mdtp_accent_color); }"	Gets the colorAccent from the current context, if possible/available	0	1
final public ParseException generateParseException() { this.jj_expentries.removeAllElements(); boolean[] la1tokens = new boolean[27]; for (int i = 0; i < 27; i++) { la1tokens[i] = false; } if (this.jj_kind >= 0) { la1tokens[this.jj_kind] = true; this.jj_kind = -1; } for (int i = 0; i < 13; i++) { if (this.jj_la1[i] == this.jj_gen) { for (int j = 0; j < 32; j++) { if ((this.jj_la1_0[i] & (1 << j)) != 0) { la1tokens[j] = true; } } } } for (int i = 0; i < 27; i++) { if (la1tokens[i]) { this.jj_expentry = new int[1]; this.jj_expentry[0] = i; this.jj_expentries.addElement(this.jj_expentry); } } this.jj_endpos = 0; jj_rescan_token(); jj_add_error_token(0, 0); int[][] exptokseq = new int[this.jj_expentries.size()][]; for (int i = 0; i < this.jj_expentries.size(); i++) { exptokseq[i] = (int[]) this.jj_expentries.elementAt(i); } return new ParseException(this.token, exptokseq, tokenImage); }	DOCUMENT ME!	1	0
View createShortcut(ShortcutInfo info) { return createShortcut(R.layout.application, (ViewGroup) mWorkspace.getChildAt(mWorkspace.getCurrentScreen()), info); }	Creates a view representing a shortcut.	0	1
@Override protected Bitmap alloc(int size) { return Bitmap.createBitmap( 1, (int) Math.ceil(size / (double) BitmapUtil.RGB_565_BYTES_PER_PIXEL), Bitmap.Config.RGB_565); }	Allocate a bitmap with the specified width and height.	1	0
"public Mono<Client> testClientModel(Client body) throws RestClientException { Object postBody = body; // verify the required parameter 'body' is set if (body == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'body' when calling testClientModel""); } String path = UriComponentsBuilder.fromPath(""/fake"").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { ""application/json"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { ""application/json"" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {}; return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType); }"	To test \&quot;client\&quot; model	0	1
private String getTag() { if (lineage.isEmpty()) { return name; } else { return lineage.get(0).getName(); } }	All Paths are 'tagged' in swagger with the final entity type name in the path.	1	0
public boolean isFull() { return getPrefetchSize() == 0 ? prefetchExtension.get() == 0 : dispatched.size() - prefetchExtension.get() >= info.getPrefetchSize(); }	Used to determine if the broker can dispatch to the consumer.	0	1
public static final Element elementFromUse(ExpressionTree node) { return InternalUtils.symbol(node); }	Gets the element for the method corresponding to this invocation.	1	0
public static Struct fromLogical(Schema schema, SpecialValueDecimal value) { return fromLogical(schema, value.getDecimalValue().orElse(null)); }	Converts a value from its logical format (BigDecimal) to its encoded format - a struct containing the scale of the number and a binary representation of the number.	1	0
"public CodegenOperation fromOperation(String path, String httpMethod, Operation operation, Map<String, Model> definitions, Swagger swagger) { CodegenOperation op = CodegenModelFactory.newInstance(CodegenModelType.OPERATION); Set<String> imports = new HashSet<String>(); op.vendorExtensions = operation.getVendorExtensions(); String operationId = getOrGenerateOperationId(operation, path, httpMethod); operationId = removeNonNameElementToCamelCase(operationId); op.path = path; op.operationId = toOperationId(operationId); op.summary = escapeText(operation.getSummary()); op.unescapedNotes = operation.getDescription(); op.notes = escapeText(operation.getDescription()); op.tags = operation.getTags(); op.hasConsumes = false; op.hasProduces = false; List<String> consumes = new ArrayList<String>(); if (operation.getConsumes() != null) { if (operation.getConsumes().size() > 0) { // use consumes defined in the operation consumes = operation.getConsumes(); } else { // empty list, do nothing to override global setting } } else if (swagger != null && swagger.getConsumes() != null && swagger.getConsumes().size() > 0) { // use consumes defined globally consumes = swagger.getConsumes(); LOGGER.debug(""No consumes defined in operation. Using global consumes ("" + swagger.getConsumes() + "") for "" + op.operationId); } // if ""consumes"" is defined (per operation or using global definition) if (consumes != null && consumes.size() > 0) { List<Map<String, String>> c = new ArrayList<Map<String, String>>(); int count = 0; for (String key : consumes) { Map<String, String> mediaType = new HashMap<String, String>(); // escape quotation to avoid code injection mediaType.put(""mediaType"", escapeText(escapeQuotationMark(key))); count += 1; if (count < consumes.size()) { mediaType.put(""hasMore"", ""true""); } else { mediaType.put(""hasMore"", null); } c.add(mediaType); } op.consumes = c; op.hasConsumes = true; } List<String> produces = new ArrayList<String>(); if (operation.getProduces() != null) { if (operation.getProduces().size() > 0) { // use produces defined in the operation produces = operation.getProduces(); } else { // empty list, do nothing to override global setting } } else if (swagger != null && swagger.getProduces() != null && swagger.getProduces().size() > 0) { // use produces defined globally produces = swagger.getProduces(); LOGGER.debug(""No produces defined in operation. Using global produces ("" + swagger.getProduces() + "") for "" + op.operationId); } // if ""produces"" is defined (per operation or using global definition) if (produces != null && produces.size() > 0) { List<Map<String, String>> c = new ArrayList<Map<String, String>>(); int count = 0; for (String key : produces) { Map<String, String> mediaType = new HashMap<String, String>(); // escape quotation to avoid code injection mediaType.put(""mediaType"", escapeText(escapeQuotationMark(key))); count += 1; if (count < produces.size()) { mediaType.put(""hasMore"", ""true""); } else { mediaType.put(""hasMore"", null); } c.add(mediaType); } op.produces = c; op.hasProduces = true; } if (operation.getResponses() != null && !operation.getResponses().isEmpty()) { Response methodResponse = findMethodResponse(operation.getResponses()); for (Map.Entry<String, Response> entry : operation.getResponses().entrySet()) { Response response = entry.getValue(); CodegenResponse r = fromResponse(entry.getKey(), response); r.hasMore = true; if (r.baseType != null && !defaultIncludes.contains(r.baseType) && !languageSpecificPrimitives.contains(r.baseType)) { imports.add(r.baseType); } r.isDefault = response == methodResponse; op.responses.add(r); if (r.isBinary && r.isDefault){ op.isResponseBinary = Boolean.TRUE; } } op.responses.get(op.responses.size() - 1).hasMore = false; if (methodResponse != null) { if (methodResponse.getSchema() != null) { CodegenProperty cm = fromProperty(""response"", methodResponse.getSchema()); Property responseProperty = methodResponse.getSchema(); if (responseProperty instanceof ArrayProperty) { ArrayProperty ap = (ArrayProperty) responseProperty; CodegenProperty innerProperty = fromProperty(""response"", ap.getItems()); op.returnBaseType = innerProperty.baseType; } else { if (cm.complexType != null) { op.returnBaseType = cm.complexType; } else { op.returnBaseType = cm.baseType; } } op.examples = new ExampleGenerator(definitions).generate(methodResponse.getExamples(), operation.getProduces(), responseProperty); op.defaultResponse = toDefaultValue(responseProperty); op.returnType = cm.datatype; op.hasReference = definitions != null && definitions.containsKey(op.returnBaseType); // lookup discriminator if (definitions != null) { Model m = definitions.get(op.returnBaseType); if (m != null) { CodegenModel cmod = fromModel(op.returnBaseType, m, definitions); op.discriminator = cmod.discriminator; } } if (cm.isContainer != null) { op.returnContainer = cm.containerType; if (""map"".equals(cm.containerType)) { op.isMapContainer = Boolean.TRUE; } else if (""list"".equalsIgnoreCase(cm.containerType)) { op.isListContainer = Boolean.TRUE; } else if (""array"".equalsIgnoreCase(cm.containerType)) { op.isListContainer = Boolean.TRUE; } } else { op.returnSimpleType = true; } if (languageSpecificPrimitives().contains(op.returnBaseType) || op.returnBaseType == null) { op.returnTypeIsPrimitive = true; } } addHeaders(methodResponse, op.responseHeaders); } } List<Parameter> parameters = operation.getParameters(); CodegenParameter bodyParam = null; List<CodegenParameter> allParams = new ArrayList<CodegenParameter>(); List<CodegenParameter> bodyParams = new ArrayList<CodegenParameter>(); List<CodegenParameter> pathParams = new ArrayList<CodegenParameter>(); List<CodegenParameter> queryParams = new ArrayList<CodegenParameter>(); List<CodegenParameter> headerParams = new ArrayList<CodegenParameter>(); List<CodegenParameter> cookieParams = new ArrayList<CodegenParameter>(); List<CodegenParameter> formParams = new ArrayList<CodegenParameter>(); if (parameters != null) { for (Parameter param : parameters) { CodegenParameter p = fromParameter(param, imports); // rename parameters to make sure all of them have unique names if (ensureUniqueParams) { while (true) { boolean exists = false; for (CodegenParameter cp : allParams) { if (p.paramName.equals(cp.paramName)) { exists = true; break; } } if (exists) { p.paramName = generateNextName(p.paramName); } else { break; } } } // set isPrimitiveType and baseType for allParams /*if (languageSpecificPrimitives.contains(p.baseType)) { p.isPrimitiveType = true; p.baseType = getSwaggerType(p); }*/ allParams.add(p); // Issue #2561 (neilotoole) : Moved setting of is<Type>Param flags // from here to fromParameter(). if (param instanceof QueryParameter) { queryParams.add(p.copy()); } else if (param instanceof PathParameter) { pathParams.add(p.copy()); } else if (param instanceof HeaderParameter) { headerParams.add(p.copy()); } else if (param instanceof CookieParameter) { cookieParams.add(p.copy()); } else if (param instanceof BodyParameter) { bodyParam = p; bodyParams.add(p.copy()); } else if (param instanceof FormParameter) { formParams.add(p.copy()); } if (p.required == null || !p.required) { op.hasOptionalParams = true; } } } for (String i : imports) { if (needToImport(i)) { op.imports.add(i); } } op.bodyParam = bodyParam; op.httpMethod = httpMethod.toUpperCase(); // move ""required"" parameters in front of ""optional"" parameters if (sortParamsByRequiredFlag) { Collections.sort(allParams, new Comparator<CodegenParameter>() { @Override public int compare(CodegenParameter one, CodegenParameter another) { boolean oneRequired = one.required == null ? false : one.required; boolean anotherRequired = another.required == null ? false : another.required; if (oneRequired == anotherRequired) return 0; else if (oneRequired) return -1; else return 1; } }); } op.allParams = addHasMore(allParams); op.bodyParams = addHasMore(bodyParams); op.pathParams = addHasMore(pathParams); op.queryParams = addHasMore(queryParams); op.headerParams = addHasMore(headerParams); // op.cookieParams = cookieParams; op.formParams = addHasMore(formParams); // legacy support op.nickname = op.operationId; if (op.allParams.size() > 0) { op.hasParams = true; } op.externalDocs = operation.getExternalDocs(); // set Restful Flag op.isRestfulShow = op.isRestfulShow(); op.isRestfulIndex = op.isRestfulIndex(); op.isRestfulCreate = op.isRestfulCreate(); op.isRestfulUpdate = op.isRestfulUpdate(); op.isRestfulDestroy = op.isRestfulDestroy(); op.isRestful = op.isRestful(); return op; }"	Convert Swagger Operation object to Codegen Operation object (without providing a Swagger object)	1	0
private boolean makeSureFileLockRemainsGone(File lock, long timeToWait) { for (long start = System.currentTimeMillis(); System.currentTimeMillis() < start + timeToWait;) { AsyncExecute.sleepTight(500); if (lock.exists()) return false; } return !lock.exists(); }	When initializing the profile, Opera rapidly starts, stops, restarts and stops again; we need to wait a bit to make sure the file lock is really gone.	0	1
public static Iterable<ProviderMetadata> collocatedWith(ProviderMetadata providerMetadata, TypeToken<? extends Wrapper> contextWrappableAs) { return filter(all(), Predicates.and(ProviderPredicates.intersectingIso3166Code(providerMetadata), ProviderPredicates.contextWrappableAs(contextWrappableAs))); }	Returns the providers that have at least one common ISO 3166 code and are of the given type.	1	0
public static UserSpinnerAdapter createUserSpinnerAdapter(UserManager userManager, Context context) { List<UserHandle> userProfiles = userManager.getUserProfiles(); if (userProfiles.size() < 2) { return null; } UserHandle myUserHandle = new UserHandle(UserHandle.myUserId()); // The first option should be the current profile userProfiles.remove(myUserHandle); userProfiles.add(0, myUserHandle); ArrayList<UserDetails> userDetails = new ArrayList<UserDetails>(userProfiles.size()); final int count = userProfiles.size(); for (int i = 0; i < count; i++) { userDetails.add(new UserDetails(userProfiles.get(i), userManager, context)); } return new UserSpinnerAdapter(context, userDetails); }	Creates a UserAdapter if there is more than one profile on the device.	1	0
public TokenStream getDefaultTokenStream() { return tokenizationStream; }	Returns TwitterTokenStream to tokenize a text.	1	0
static String boxClassName(Type type) { if (!(type instanceof Class)) { return type.toString(); } Primitive primitive = Primitive.of(type); if (primitive != null) { return primitive.boxClass.getSimpleName(); } else { return className(type); } }	Boxes a type, if it is primitive, and returns the type name.	0	1
public static DrillFileSystem createFileSystem(String proxyUserName, Configuration fsConf) { return createFileSystem(createProxyUgi(proxyUserName), fsConf, null); }	Create DrillFileSystem for given proxyUserName, configuration and stats.	1	0
public static Collection<Simon> getSimons(SimonFilter simonFilter) { return manager.getSimons(simonFilter); }	Returns collection containing all existing Simons matching the pattern (can be null).	1	0
public QueueReceiver createReceiver(Queue queue, String messageSelector) throws JMSException { checkClosed(); ActiveMQPrefetchPolicy prefetchPolicy = this.connection.getPrefetchPolicy(); return new ActiveMQQueueReceiver(this, getNextConsumerId(), ActiveMQMessageTransformation .transformDestination(queue), messageSelector, prefetchPolicy.getQueuePrefetch(), prefetchPolicy.getMaximumPendingMessageLimit(), asyncDispatch); }	Creates a QueueReceiver object to receive messages from the specified queue using a message selector.	0	1
public static boolean isTree(SemanticGraph tree) { for (IndexedWord vertex : tree.vertexSet()) { // Check one and only one incoming edge if (tree.getRoots().contains(vertex)) { if (tree.incomingEdgeIterator(vertex).hasNext()) { return false; } } else { Iterator<SemanticGraphEdge> iter = tree.incomingEdgeIterator(vertex); if (!iter.hasNext()) { return false; } iter.next(); if (iter.hasNext()) { return false; } } // Check incoming and outgoing edges match for (SemanticGraphEdge edge : tree.outgoingEdgeIterable(vertex)) { boolean foundReverse = false; for (SemanticGraphEdge reverse : tree.incomingEdgeIterable(edge.getDependent())) { if (reverse == edge) { foundReverse = true; } } if (!foundReverse) { return false; } } for (SemanticGraphEdge edge : tree.incomingEdgeIterable(vertex)) { boolean foundReverse = false; for (SemanticGraphEdge reverse : tree.outgoingEdgeIterable(edge.getGovernor())) { if (reverse == edge) { foundReverse = true; } } if (!foundReverse) { return false; } } } // Check topological sort -- sometimes fails? // try { // tree.topologicalSort(); // } catch (Exception e) { // e.printStackTrace(); // return false; // } return true; }	A little utility function to make sure a SemanticGraph is a tree.	0	1
"public Action doCometSupport(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException { req.setAttribute(BROADCASTER_FACTORY, broadcasterFactory); req.setAttribute(PROPERTY_USE_STREAM, useStreamForFlushingComments); req.setAttribute(BROADCASTER_CLASS, broadcasterClassName); req.setAttribute(ATMOSPHERE_CONFIG, config); Action a = null; try { if ((config.getInitParameter(ALLOW_QUERYSTRING_AS_REQUEST) != null || (isIECandidate(req) || req.getParameter(HeaderConfig.JSONP_CALLBACK_NAME) != null)) && req.getAttribute(WebSocket.WEBSOCKET_SUSPEND) == null) { Map<String, String> headers = configureQueryStringAsRequest(req); String body = headers.remove(ATMOSPHERE_POST_BODY); if (body != null && body.isEmpty()) { body = null; } req.headers(headers) .method(body != null && req.getMethod().equalsIgnoreCase(""GET"") ? ""POST"" : req.getMethod()); if (body != null) { req.body(body); } a = asyncSupport.service(req, res); } else { return asyncSupport.service(req, res); } } catch (IllegalStateException ex) { if (ex.getMessage() != null && (ex.getMessage().startsWith(""Tomcat failed"") || ex.getMessage().startsWith(""JBoss failed"") )) { if (!isFilter) { logger.warn(""Failed using comet support: {}, error: {} Is the Nio or Apr Connector enabled?"", asyncSupport.getClass().getName(), ex.getMessage()); logger.warn(""Using BlockingIOCometSupport.""); } logger.trace(ex.getMessage(), ex); asyncSupport = new BlockingIOCometSupport(config); doCometSupport(req, res); } else { logger.error(""AtmosphereServlet exception"", ex); throw ex; } } finally { if (req != null && a != null && a.type != Action.TYPE.SUSPEND) { req.destroy(); res.destroy(); } } return null; }"	Invoke the proprietary CometSupport	1	0
protected static String cstString(DalvInsn insn) { CstInsn ci = (CstInsn) insn; Constant cst = ci.getConstant(); return cst.toHuman(); }	Helper method to return the constant string for a CstInsn in human form.	1	0
public Collection<TvShow> getTvShows() { return (Set<TvShow>) ((LinkedHashSet<TvShow>) tvShows).clone(); }	We should return a full clone of TvShow objects inside catalog because all this data is in memory and anyone can change it if we don't return only copies, but this is just a sample!	0	1
public boolean contains(ReadableInterval interval) { if (interval == null) { return containsNow(); } long otherStart = interval.getStartMillis(); long otherEnd = interval.getEndMillis(); long thisStart = getStartMillis(); long thisEnd = getEndMillis(); return (thisStart <= otherStart && otherStart < thisEnd && otherEnd <= thisEnd); }	Does this time interval contain or equal the specified time interval.	1	0
public Field withValidation(Validator... validators) { Validator actualValidator = validator; for (Validator validator : validators) { if (validator != null) actualValidator = validator.and(actualValidator); } return new Field(name(), displayName(), type(), width(), description(), importance(), dependents, defaultValueGenerator, actualValidator, recommender); }	Create and return a new Field instance that that is a copy of this field but that uses the supplied predicate during Field#validate(Configuration, Consumer).	1	0
public static ApiResponse getReferencedApiResponse(OpenAPI openAPI, ApiResponse apiResponse) { if (apiResponse != null && StringUtils.isNotEmpty(apiResponse.get$ref())) { String name = getSimpleRef(apiResponse.get$ref()); ApiResponse referencedApiResponse = getApiResponse(openAPI, name); if(referencedApiResponse != null) { return referencedApiResponse; } } return apiResponse; }	If a ApiResponse contains a reference to an other ApiResponse with '$ref', returns the referenced ApiResponse or the actual ApiResponse in the other cases.	1	0
"@Override public void createRecord(DBRecord rec, Connection conn) { throw new NotImplementedException(this, ""createRecord""); }"	Returns an error, because querys could't add new records to the database.	1	0
public boolean isSelected(final ToolItem toolItem) { boolean selectionState = Display.syncExec(new ResultRunnable<Boolean>() { @Override public Boolean run() { return toolItem.getSelection(); } }); return selectionState; }	Checks if toolitem is selected	1	0
private boolean getStatusBasedOnPos() { return getProgress() > 0.5f; }	return the status based on position of thumb	0	1
protected Object convertTimestampToEpochMillisAsDate(Column column, Field fieldDefn, Object data) { // epoch is the fallback value return convertValue(column, fieldDefn, data, 0L, (r) -> { try { r.deliver(new java.util.Date(Timestamp.toEpochMillis(data, adjuster))); } catch (IllegalArgumentException e) { } }); }	Converts a value object for an expected JDBC type of Types#TIMESTAMP to java.util.Date values representing milliseconds past epoch.	0	1
"public String convert(Object object) { if (object == null) { return null; } try { JsonElement json = convertObject(object); return new GsonBuilder().serializeNulls().create().toJson(json); } catch (Exception e) { throw new WebDriverException(""Unable to convert: "" + object, e); } }"	Convert an object that may or may not be a JSONArray or JSONObject into its JSON string representation, handling the case where it is neither in a graceful way.	1	0
public static MemberID parse(String memberID) { return parse(memberID, false, AppInfo.getSingleton().getClassPath()); }	Parse a signature, with or without classname, with or without descriptor.	1	0
"private static Provider getDefaultProvider() { // approach 1 try { String providerClass = System.getProperty(""org.joda.time.DateTimeZone.Provider""); if (providerClass != null) { try { Provider provider = (Provider) Class.forName(providerClass).newInstance(); return validateProvider(provider); } catch (Exception ex) { throw new RuntimeException(ex); } } } catch (SecurityException ex) { // ignored } // approach 2 try { String dataFolder = System.getProperty(""org.joda.time.DateTimeZone.Folder""); if (dataFolder != null) { try { Provider provider = new ZoneInfoProvider(new File(dataFolder)); return validateProvider(provider); } catch (Exception ex) { throw new RuntimeException(ex); } } } catch (SecurityException ex) { // ignored } // approach 3 try { Provider provider = new ZoneInfoProvider(""org/joda/time/tz/data""); return validateProvider(provider); } catch (Exception ex) { ex.printStackTrace(); } // approach 4 return new UTCProvider(); }"	Gets the default zone provider.	0	1
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; // set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { // prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); // System.err.println(""At end of text making after: |"" + str + ""|""); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); // System.err.println(""prevWord is |"" + prevWord.get(CoreAnnotations.TextAnnotation.class) + ""|, its after is |"" + // prevWord.get(CoreAnnotations.AfterAnnotation.class) + ""|""); prevWordAfter.setLength(0); } return null; } } else { switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { String str = yytext(); int first = str.codePointAt(0); String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } logger.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: logger.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 79: break; case 2: { return getNext(""<"", yytext()); } case 80: break; case 3: { return getNext(); } case 81: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 82: break; case 5: { if (tokenizeNLs) { return getNext(AbstractTokenizer.NEWLINE_TOKEN, yytext()); // for tokenizing newliens } else if (invertible) { // System.err.println(""Appending newline: |"" + yytext() + ""|""); prevWordAfter.append(yytext()); } } case 83: break; case 6: { final String origTxt = yytext(); String tok = LexerUtils.removeSoftHyphens(origTxt); if (americanize) { tok = Americanize.americanize(tok); } if (DEBUG) { logger.info(""Used {WORD} (2) to recognize "" + origTxt + "" as "" + tok); } return getNext(tok, origTxt); } case 84: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 85: break; case 8: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {QUOTES} (3) to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 86: break; case 9: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {SREDAUX} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 87: break; case 10: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 88: break; case 11: { return getNext("">"", yytext()); } case 89: break; case 12: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 90: break; case 13: { handleHyphenatedNumber(yytext()); if (DEBUG) { logger.info(""Used {NUMBER} to recognize "" + yytext() + "" as "" + removeFromNumber(yytext())); } return getNext(removeFromNumber(yytext()), yytext()); } case 91: break; case 14: { return handleEllipsis(yytext()); } case 92: break; case 15: { // breakByHyphens(yytext()); // this is causing fail of attempted to pushback too much! String tok = yytext(); /* A THING can contain quote like O'Malley */ String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {THING} (2) to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 93: break; case 16: { String txt = yytext(); String norm = normalizeFractions(yytext()); if (DEBUG) { logger.info(""Used {FRAC2} to recognize "" + txt + "" as "" + norm + ""; normalizeFractions="" + normalizeFractions + "", escapeForwardSlashAsterisk="" + escapeForwardSlashAsterisk); } return getNext(norm, txt); } case 94: break; case 17: { if (normalizeCurrency) { return getNext(LexerUtils.normalizeCurrency(yytext()), yytext()); } else { return getNext(LexerUtils.minimallyNormalizeCurrency(yytext()), yytext()); } } case 95: break; case 18: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 96: break; case 19: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 97: break; case 20: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 98: break; case 21: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 99: break; case 22: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 100: break; case 23: { if (normalizeOtherBrackets) { return getNext(""-LSB-"", yytext()); } else { return getNext(); } } case 101: break; case 24: { if (normalizeOtherBrackets) { return getNext(""-RSB-"", yytext()); } else { return getNext(); } } case 102: break; case 25: { String tok = yytext(); String norm = LexerUtils.processCp1252misc(tok); if (DEBUG) { logger.info(""Used {CP1252_MISC_SYMBOL} to recognize "" + tok + "" as "" + norm); } return getNext(norm, tok); } case 103: break; case 26: { if (invertible) { prevWordAfter.append(yytext()); } } case 104: break; case 27: // general lookahead, find correct zzMarkedPos { int zzFState = 17; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 18; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 105: break; case 28: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(); } case 106: break; case 29: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {REDAUX} (2) to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 107: break; case 30: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {APOWORD} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 108: break; case 31: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); String norm = handleQuotes(tok, true); if (DEBUG) { logger.info(""Used {DBLQUOT} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + true); } return getNext(norm, tok); } case 109: break; case 32: { String tok = yytext(); if (DEBUG) { logger.info(""Used {PROG_LANGS} to recognize "" + tok + "" as "" + tok); } return getNext(tok, tok); } case 110: break; case 33: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String txt = yytext(); if (DEBUG) { logger.info(""Used {DIGIT}/{SEP_SUFFIX} to recognize "" + txt); } return getNext(txt, txt); } case 111: break; case 34: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 112: break; case 35: { breakByHyphens(yytext()); if (DEBUG) { logger.info(""Used {HTHING} to recognize "" + yytext() + "" as "" + LexerUtils.removeSoftHyphens(yytext())); } return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext()); } case 113: break; case 36: // general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tok = LexerUtils.removeSoftHyphens(origTxt); if (americanize) { tok = Americanize.americanize(tok); } if (DEBUG) { logger.info(""Used {WORD} to recognize "" + origTxt + "" as "" + tok); } return getNext(tok, origTxt); } case 114: break; case 37: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 115: break; case 38: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String origTok = yytext(); String norm = LexerUtils.removeSoftHyphens(origTok); if (DEBUG) { logger.info(""Used {WORD} (3) to recognize "" + origTok + "" as "" + norm); } return getNext(norm, origTok); } case 116: break; case 39: { // this one should only match if we're basically at the end of file // since the last one matches two things, even newlines (if not tokenize per line) return processAbbrev1(); } case 117: break; case 40: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 118: break; case 41: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { // Extra context is to not match on ones like 'd but you do want words like ""a"" // can't have digit here because of cases like '90s String tok = yytext(); /* invert single quote - often but not always right */ String norm = handleQuotes(tok, true); if (DEBUG) { logger.info(""Used {QUOTES} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + true); } return getNext(norm, tok); } case 119: break; case 42: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {REDAUX} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 120: break; case 43: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { // Extra context is to not match on ones like 'd but you do want words like ""a"" // can't have digit here because of cases like '90s String tok = yytext(); /* invert single quote - often but not always right */ String norm = handleQuotes(tok, true); if (DEBUG) { logger.info(""Used {QUOTES} (2) to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + true); } return getNext(norm, tok); } case 121: break; case 44: { return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext()); } case 122: break; case 45: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {SREDAUX} (2) to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 123: break; case 46: { if (splitAssimilations) { yypushback(2); } String tok = yytext(); if (DEBUG) { logger.info(""Used {ASSIMILATIONS3} to recognize "" + tok + "" as "" + tok + ""; splitAssimilations="" + splitAssimilations); } return getNext(tok, tok); } case 124: break; case 47: { String txt = yytext(); // if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space... if (strictTreebank3) { int spaceIndex = indexOfSpace(txt); if (spaceIndex >= 0) { yypushback(txt.length() - spaceIndex); return getNext(); } } if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, yytext()); } case 125: break; case 48: { final String origTxt = yytext(); String tok; if (normalizeAmpersandEntity) { tok = LexerUtils.normalizeAmp(origTxt); } else { tok = origTxt; } if (DEBUG) { logger.info(""Used {THINGA} (2) to recognize "" + origTxt + "" as "" + tok); } return getNext(tok, origTxt); } case 126: break; case 49: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, origTxt); } case 127: break; case 50: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space } return getNext(txt, origTxt); } case 128: break; case 51: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tok = LexerUtils.removeSoftHyphens(origTxt); if (DEBUG) { logger.info(""Used {SWORD} to recognize "" + origTxt + "" as "" + tok); } return getNext(tok, origTxt); } case 129: break; case 52: // general lookahead, find correct zzMarkedPos { int zzFState = 19; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 18; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 130: break; case 53: { String txt = yytext(); String normTok = txt; if (escapeForwardSlashAsterisk) { normTok = delimit(normTok, '*'); } if (DEBUG) { logger.info(""Used {SWEARING} to recognize "" + txt + "" as "" + normTok); } return getNext(normTok, txt); } case 131: break; case 54: { final String origTxt = yytext(); String tok; if (normalizeAmpersandEntity) { tok = LexerUtils.normalizeAmp(origTxt); } else { tok = origTxt; } if (DEBUG) { logger.info(""Used {TBSPEC} to recognize "" + origTxt + "" as "" + tok); } return getNext(tok, origTxt); } case 132: break; case 55: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {SREDAUX} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 133: break; case 56: // general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 13; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 134: break; case 57: // general lookahead, find correct zzMarkedPos { int zzFState = 22; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 24; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 135: break; case 58: // general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 21; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 136: break; case 59: // general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 13; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 137: break; case 60: // general lookahead, find correct zzMarkedPos { int zzFState = 22; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 23; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 138: break; case 61: { String txt = yytext(); String norm = txt; if (escapeForwardSlashAsterisk) { norm = delimit(norm, '/'); norm = delimit(norm, '*'); } if (DEBUG) { logger.info(""Used {LIKELYURL} to recognize "" + txt + "" as "" + norm); } return getNext(norm, txt); } case 139: break; case 62: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); breakByHyphens(tok); tok = yytext(); String norm = LexerUtils.removeSoftHyphens(tok); if (DEBUG) { logger.info(""Used {HTHING} (2) to recognize "" + tok + "" as "" + norm); } return getNext(norm, tok); } case 140: break; case 63: { if (splitAssimilations) { yypushback(3); } String tok = yytext(); if (DEBUG) { logger.info(""Used {ASSIMILATIONS3} to recognize "" + tok + "" as "" + tok + ""; splitAssimilations="" + splitAssimilations); } return getNext(tok, tok); } case 141: break; case 64: { final String origTxt = yytext(); String tok; if (normalizeAmpersandEntity) { tok = LexerUtils.normalizeAmp(origTxt); } else { tok = origTxt; } if (DEBUG) { logger.info(""Used {SPAMP} to recognize "" + origTxt + "" as "" + tok); } return getNext(tok, origTxt); } case 142: break; case 65: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext()); } case 143: break; case 66: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { final String origTxt = yytext(); String tok; if (normalizeAmpersandEntity) { tok = LexerUtils.normalizeAmp(origTxt); } else { tok = origTxt; } if (DEBUG) { logger.info(""Used {THINGA} to recognize "" + origTxt + "" as "" + tok); } return getNext(tok, origTxt); } case 144: break; case 67: // general lookahead, find correct zzMarkedPos { int zzFState = 9; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 145: break; case 68: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { return getNext(); } case 146: break; case 69: // general lookahead, find correct zzMarkedPos { int zzFState = 14; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 147: break; case 70: // general lookahead, find correct zzMarkedPos { int zzFState = 9; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 10; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 148: break; case 71: // general lookahead, find correct zzMarkedPos { int zzFState = 14; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 15; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 149: break; case 72: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } return getNext(txt, yytext()); } case 150: break; case 73: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4); { return getNext(); } case 151: break; case 74: // lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { return getNext(); } case 152: break; case 75: { String txt = yytext(); String norm = txt; if (escapeForwardSlashAsterisk) { norm = delimit(norm, '/'); norm = delimit(norm, '*'); } if (DEBUG) { logger.info(""Used {FULLURL} to recognize "" + txt + "" as "" + norm); } return getNext(norm, txt); } case 153: break; case 76: { String txt = yytext(); if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } if (DEBUG) { logger.info(""Used {PHONE} to recognize "" + yytext() + "" as "" + txt); } return getNext(txt, yytext()); } case 154: break; case 77: // general lookahead, find correct zzMarkedPos { int zzFState = 25; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 27; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 155: break; case 78: // general lookahead, find correct zzMarkedPos { int zzFState = 25; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 26; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 156: break; default: zzScanError(ZZ_NO_MATCH); } } } }"	Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.	0	1
public Charset getEncoding() { return _charset; }	Returns the encoding used to send and receive lines from the IRC server, or null if not set.	1	0
@NonNull protected List<Action> retrieveActions(@NonNull SCMHead head, @NonNull SCMHeadEvent event, @NonNull TaskListener listener) throws IOException, InterruptedException { return Collections.emptyList(); }	SPI for #fetchActions(SCMHead, TaskListener).	1	0
"private boolean processResults(boolean returnKeys, boolean update) throws SQLException { if (!resultQueue.isEmpty()) { throw new IllegalStateException( ""There should be no queued results.""); } while (!tds.isEndOfResponse()) { if (!tds.getMoreResults()) { if (tds.isUpdateCount()) { if (update && connection.isLastUpdateCount()) { resultQueue.clear(); } resultQueue.addLast(new Integer(tds.getUpdateCount())); } } else { if (returnKeys) { // This had better be the generated key // FIXME We could use SELECT @@IDENTITY AS jTDS_SOMETHING and check the column name to make sure if (tds.getNextRow()) { genKeyResultSet = new CachedResultSet(this, tds.getColumns(), tds.getRowData()); } } else { // TODO Should we allow execution of multiple statements via executeUpdate? if (update && resultQueue.isEmpty()) { throw new SQLException( Messages.get(""error.statement.nocount""), ""07000""); } resultQueue.add(new JtdsResultSet( this, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY, tds.getColumns())); break; } } } return !resultQueue.isEmpty(); }"	Queue up update counts until the end of the response is reached or a ResultSet is encountered into #resultQueue.	1	0
public int getLeapAmount() { return getField().getLeapAmount(getMillis()); }	Gets the amount by which this field is leap.	0	1
protected IsolationLevel getTransactionIsolation() { return this.transactionIsolationLevel; }	Retrieve the currently specified TransactionIsolation level.	1	0
public static Set<String> getAllSupportedComponentTypes() { return SUPPORTED_COMPONENT_TYPES; }	Returns an array of codes representing all supported component types (see specific type constants).	1	0
public boolean isEmpty() { return propertyPathsByTransientEntity == null || propertyPathsByTransientEntity.isEmpty(); }	Are there any paths currently tracked here?	0	1
"protected Object convertDateToEpochDays(Column column, Field fieldDefn, Object data) { // epoch is the fallback value return convertValue(column, fieldDefn, data, 0, (r) -> { try { r.deliver(Date.toEpochDay(data, adjuster)); } catch (IllegalArgumentException e) { logger.warn(""Unexpected JDBC DATE value for field {} with schema {}: class={}, value={}"", fieldDefn.name(), fieldDefn.schema(), data.getClass(), data); } }); }"	Converts a value object for an expected JDBC type of Types#DATE to the number of days past epoch.	0	1
public Iterator getPorts() throws ServiceException { if (wsdlService == null || wsdlService.getPorts() == null){ // Return an empty iterator; return new Vector().iterator(); } return wsdlService.getPorts().keySet().iterator(); }	Returns an Iterator that can be used to get all of the ports specified in the WSDL file associated with this Service (if there is a WSDL file).	1	0
"@Override public String toString() { return ""["" + name + "" "" + state + ""]""; }"	Returns name, state and stats of the Simon as a human readable string.	1	0
public long getContentDuration() { return mBundle.getLong(KEY_CONTENT_DURATION, -1); }	Gets the total duration of the content to be played as a floating point number of seconds.	1	0
public Configuration addCacheableFile(String xmlFile) throws MappingException { metadataSources.addCacheableFile( xmlFile ); return this; }	Add a cacheable mapping file.	0	1
protected ComponentTemplate getMetaData( final Object entry ) { return (ComponentTemplate)entry; }	Return the org.jcontainer.loom.components.util.metadata.ComponentMetaData for specified component entry.	1	0
public static DateTimeFormatter basicTime() { return Constants.bt; }	Returns a basic formatter for a two digit hour of day, two digit minute of hour, two digit second of minute, three digit millis, and time zone offset (HHmmss.SSSZ).	0	1
"public <T> int querySimpleList(Class<T> c, String sqlCmd, Connection conn, Collection<T> result) { // Check status if (checkOpen()==false) return -1; // Start query ResultSet rs = null; try { // Log performance long start = System.currentTimeMillis(); if (log.isInfoEnabled()) log.info(""executing: "" + sqlCmd); // Get the next Value rs = driver.executeQuery(sqlCmd, null, false, conn); if (rs == null) { // Error error(driver); return -1; } // Check Result int count=0; while (rs.next()) { T item = ObjectUtils.convert(c, rs.getObject(1)); result.add(item); count++; } // No Value if (log.isInfoEnabled()) log.info(""querySimpleList retured ""+String.valueOf(count)+"" items. Query completed in "" + String.valueOf(System.currentTimeMillis() - start) + "" ms""); clearError(); return count; } catch (ClassCastException e) { log.error(""querySingleValue cast exception: "", e); error(Errors.Exception, e); return -1; } catch (SQLException e) { log.error(""querySimpleList exception: "", e); error(DBErrors.QueryFailed, e); return -1; } finally { // Cleanup closeResultSet(rs); } }"	Returns a one dimensional array from an sql query.	1	0
public boolean scrollUp(){ return scroller.scroll(Scroller.Direction.UP); }	Scrolls up the screen.	0	1
public TokenStream duplicate() { DuplicatedTokenStream duplicate = new DuplicatedTokenStream(inputStream); duplicatedStreams.add(duplicate); return duplicate; }	Returns a new TwitterTokenStream which provides the same output as the original TwitterTokenStream.	1	0
public static Schema getKeyWriterSchema(Configuration conf) { String json = conf.get(CONF_KEY_WRITER_SCHEMA); return null == json ? null : new Schema.Parser().parse(json); }	Gets the writer schema of the AvroKey datum that is being serialized/deserialized.	0	1
"public String toModelName(final String name) { String result = camelize(sanitizeName(name)); if (!StringUtils.isEmpty(modelNamePrefix)) { result = modelNamePrefix + ""_"" + result; } // model name cannot use reserved keyword, e.g. return if (isReservedWord(name)) { String modelName = ""Model_"" + result; LOGGER.warn(name + "" (reserved word) cannot be used as model name. Renamed to "" + modelName); return modelName; } // model name starts with number if (result.matches(""^\\d.*"")) { String modelName = ""Model_"" + result; // e.g. 200Response => Model_200Response (after camelize) LOGGER.warn(name + "" (model name starts with number) cannot be used as model name. Renamed to "" + modelName); return modelName; } if (languageSpecificPrimitives.contains(result)) { String modelName = ""Model_"" + result; LOGGER.warn(name + "" (model name matches existing language type) cannot be used as a model name. Renamed to "" + modelName); return modelName; } if (!StringUtils.isEmpty(modelNameSuffix)) { result = result + ""_"" + modelNameSuffix; } return result; }"	Output the proper model name (capitalized).	0	1
static boolean observe( @Nullable final Object object ) { return !( object instanceof ComponentObservable ) || asComponentObservable( object ).observe(); }	Invoke #observe() on the supplied object.	1	0
public double getBalance(World world) { if (!Config.multiWorld) return getBalance(CurrencyHandler.getCurrency(Config.currencyDefault, true)); return getBalance(CurrencyHandler.getCurrency(Config.currencyDefault, true),world); }	Get the player balance.	1	0
"private boolean propertyHasBreakingCharacters(String str) { final String regex = ""^.*[+*:;,.()-]+.*$""; final Pattern pattern = Pattern.compile(regex); final Matcher matcher = pattern.matcher(str); return matcher.matches(); }"	Checks whether property names have breaking characters like ':', '-'.	0	1
public SequenceService createSequenceService() { return createSequenceService(defaultEndpointUrl); }	Create and return a new sequence service with the default server URL.	1	0
public ProcessingPartitionScanner getProcessingPartitionScanner() { return (fPartitionScanner == null) ? new ProcessingPartitionScanner() : fPartitionScanner; }	Return a scanner for creating Processing partitions.	0	1
"public Reader getReader() { debug(""\nContents: "" + this.contentsBuffer.toString()); return new StringReader(this.contentsBuffer.toString()); }"	DOCUMENT ME!	1	0
"private Symbol generate(Resolver.Action action, Map<Object, Symbol> seen) throws IOException { if (action instanceof Resolver.DoNothing) { return simpleGen(action.writer, seen); } else if (action instanceof Resolver.ErrorAction) { return Symbol.error(action.toString()); } else if (action instanceof Resolver.Skip) { return Symbol.skipAction(simpleGen(action.writer, seen)); } else if (action instanceof Resolver.Promote) { return Symbol.resolve(simpleGen(action.writer, seen), simpleGen(action.reader, seen)); } else if (action instanceof Resolver.ReaderUnion) { Resolver.ReaderUnion ru = (Resolver.ReaderUnion) action; Symbol s = generate(ru.actualAction, seen); return Symbol.seq(Symbol.unionAdjustAction(ru.firstMatch, s), Symbol.UNION); } else if (action.writer.getType() == Schema.Type.ARRAY) { Symbol es = generate(((Resolver.Container) action).elementAction, seen); return Symbol.seq(Symbol.repeat(Symbol.ARRAY_END, es), Symbol.ARRAY_START); } else if (action.writer.getType() == Schema.Type.MAP) { Symbol es = generate(((Resolver.Container) action).elementAction, seen); return Symbol.seq(Symbol.repeat(Symbol.MAP_END, es, Symbol.STRING), Symbol.MAP_START); } else if (action.writer.getType() == Schema.Type.UNION) { if (((Resolver.WriterUnion) action).unionEquiv) return simpleGen(action.writer, seen); Resolver.Action[] branches = ((Resolver.WriterUnion) action).actions; Symbol[] symbols = new Symbol[branches.length]; String[] labels = new String[branches.length]; int i = 0; for (Resolver.Action branch : branches) { symbols[i] = generate(branch, seen); labels[i] = action.writer.getTypes().get(i).getFullName(); i++; } return Symbol.seq(Symbol.alt(symbols, labels), Symbol.WRITER_UNION_ACTION); } else if (action instanceof Resolver.EnumAdjust) { Resolver.EnumAdjust e = (Resolver.EnumAdjust) action; Object[] adjs = new Object[e.adjustments.length]; for (int i = 0; i < adjs.length; i++) adjs[i] = (0 <= e.adjustments[i] ? new Integer(e.adjustments[i]) : ""No match for "" + e.writer.getEnumSymbols().get(i)); return Symbol.seq(Symbol.enumAdjustAction(e.reader.getEnumSymbols().size(), adjs), Symbol.ENUM); } else if (action instanceof Resolver.RecordAdjust) { Symbol result = seen.get(action); if (result == null) { final Resolver.RecordAdjust ra = (Resolver.RecordAdjust) action; int defaultCount = ra.readerOrder.length - ra.firstDefault; int count = 1 + ra.fieldActions.length + 3 * defaultCount; Symbol[] production = new Symbol[count]; result = Symbol.seq(production); seen.put(action, result); production[--count] = Symbol.fieldOrderAction(ra.readerOrder); for (Resolver.Action wfa : ra.fieldActions) production[--count] = generate(wfa, seen); for (int i = ra.firstDefault; i < ra.readerOrder.length; i++) { Schema.Field rf = ra.readerOrder[i]; byte[] bb = getBinary(rf.schema(), Accessor.defaultValue(rf)); production[--count] = Symbol.defaultStartAction(bb); production[--count] = simpleGen(rf.schema(), seen); production[--count] = Symbol.DEFAULT_END_ACTION; } } return result; } throw new IllegalArgumentException(""Unrecognized Resolver.Action: "" + action); }"	Takes a Resolver.Action for resolving two schemas and returns the start symbol for a grammar that implements that resolution.	0	1
public Remote getPort(QName portName, Class proxyInterface) throws ServiceException { // First, try to find a generated stub. If that // returns null, then find a dynamic stub. Remote stub = getGeneratedStub(portName, proxyInterface); return stub != null ? stub : getPort(null, portName, proxyInterface); }	Not implemented yet	1	0
"public Mono<BigDecimal> fakeOuterNumberSerialize(BigDecimal body) throws RestClientException { Object postBody = body; // create path and map variables final Map<String, Object> pathParams = new HashMap<String, Object>(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { ""*/*"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<BigDecimal> returnType = new ParameterizedTypeReference<BigDecimal>() {}; return apiClient.invokeAPI(""/fake/outer/number"", HttpMethod.POST, pathParams, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType); }"	Test serialization of outer number types 200 - Output number	0	1
private boolean nonValueAnno(AnnotatedTypeMirror mirror) { return AnnotationUtils.areSameIgnoringValues( getValueAnnotation(mirror), UNKNOWNVAL) || AnnotationUtils .areSameIgnoringValues( mirror.getAnnotationInHierarchy(ARRAYLEN), ARRAYLEN); }	Check that the annotation in the Value Checker hierarchy has a value of some kind.	1	0
public long getInstantMillis(Object object, Chronology chrono) { Calendar calendar = (Calendar) object; long millisLocal = calendar.getTime().getTime() + calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET); DateTimeZone tz = DateTimeZone.forTimeZone(calendar.getTimeZone()); return millisLocal - tz.getOffsetFromLocal(millisLocal); }	Gets the millis, which is the Calendar millis value.	0	1
public DateTime roundFloorCopy() { DateTime instant = iInstant; return (DateTime)instant.withMillis(iField.roundFloor(instant.getMillis())); }	Rounds to the lowest whole unit of this field on a copy of this DateTime.	0	1
public static <T> Stream<T> from( T object ) { return new Stream<T>( new RepeatingObjectIterator<T>( object ), null ) ; }	Construct a Stream that iterates every Object in an array.	1	0
protected static CodecFactory getCompressionCodec(TaskAttemptContext context) { if (FileOutputFormat.getCompressOutput(context)) { // Default to deflate compression. String outputCodec = context.getConfiguration() .get(AvroJob.CONF_OUTPUT_CODEC, DataFileConstants.DEFLATE_CODEC); if (DataFileConstants.DEFLATE_CODEC.equals(outputCodec)) { int compressionLevel = context.getConfiguration().getInt( org.apache.avro.mapred.AvroOutputFormat.DEFLATE_LEVEL_KEY, org.apache.avro.mapred.AvroOutputFormat.DEFAULT_DEFLATE_LEVEL); return CodecFactory.deflateCodec(compressionLevel); } else { return CodecFactory.fromString(outputCodec); } } // No compression. return CodecFactory.nullCodec(); }	Gets the configured compression codec from the task context.	0	1
"public static void main(String[] args) throws IOException, ClassNotFoundException { RedwoodConfiguration.standard().apply(); // Disable SLF4J crap. ArgumentParser.fillOptions(KBPStatisticalExtractor.class, args); // Fill command-line options // Load the test (or dev) data forceTrack(""Test data""); List<Pair<KBPInput, String>> testExamples = KBPRelationExtractor.readDataset(TEST_FILE); log.info(""Read "" + testExamples.size() + "" examples""); endTrack(""Test data""); // If we can't find an existing model, train one if (!IOUtils.existsInClasspathOrFileSystem(MODEL_FILE)) { forceTrack(""Training data""); List<Pair<KBPInput, String>> trainExamples = KBPRelationExtractor.readDataset(TRAIN_FILE); log.info(""Read "" + trainExamples.size() + "" examples""); log.info("""" + trainExamples.stream().map(Pair::second).filter(NO_RELATION::equals).count() + "" are "" + NO_RELATION); endTrack(""Training data""); // Featurize + create the dataset forceTrack(""Creating dataset""); RVFDataset<String, String> dataset = new RVFDataset<>(); final AtomicInteger i = new AtomicInteger(0); long beginTime = System.currentTimeMillis(); trainExamples.stream().parallel().forEach(example -> { if (i.incrementAndGet() % 1000 == 0) { log.info(""["" + Redwood.formatTimeDifference(System.currentTimeMillis() - beginTime) + ""] Featurized "" + i.get() + "" / "" + trainExamples.size() + "" examples""); } Counter<String> features = features(example.first); // This takes a while per example synchronized (dataset) { dataset.add(new RVFDatum<>(features, example.second)); } }); trainExamples.clear(); // Free up some memory endTrack(""Creating dataset""); // Train the classifier log.info(""Training classifier:""); Classifier<String, String> classifier = trainMultinomialClassifier(dataset, FEATURE_THRESHOLD, SIGMA); dataset.clear(); // Free up some memory // Save the classifier IOUtils.writeObjectToFile(new KBPStatisticalExtractor(classifier), MODEL_FILE); } // Read either a newly-trained or pre-trained model Object model = IOUtils.readObjectFromURLOrClasspathOrFileSystem(MODEL_FILE); KBPStatisticalExtractor classifier; if (model instanceof Classifier) { //noinspection unchecked classifier = new KBPStatisticalExtractor((Classifier<String, String>) model); } else { classifier = ((KBPStatisticalExtractor) model); } // Evaluate the model classifier.computeAccuracy(testExamples.stream(), PREDICTIONS.map(x -> { try { return ""stdout"".equalsIgnoreCase(x) ? System.out : new PrintStream(new FileOutputStream(x)); } catch (IOException e) { throw new RuntimeIOException(e); } })); }"	Score the given input, returning both the classification decision and the probability of that decision.	0	1
public RelOptTable getTableOrigin(RelNode rel) { // Determine the simple origin of the first column in the // RelNode. If it's simple, then that means that the underlying // table is also simple, even if the column itself is derived. if (rel.getRowType().getFieldCount() == 0) { return null; } final Set<RelColumnOrigin> colOrigins = getColumnOrigins(rel, 0); if (colOrigins == null || colOrigins.size() == 0) { return null; } return colOrigins.iterator().next().getOriginTable(); }	Determines the origin of a RelNode, provided it maps to a single table, optionally with filtering and projection.	0	1
"private Type buildAttributeConverterTypeAdapter() { // todo : validate the number of columns present here? final Class entityAttributeJavaType = jpaAttributeConverterDefinition.getEntityAttributeType(); final Class databaseColumnJavaType = jpaAttributeConverterDefinition.getDatabaseColumnType(); // resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // For the JavaTypeDescriptor portion we simply resolve the ""entity attribute representation"" part of // the AttributeConverter to resolve the corresponding descriptor. final JavaTypeDescriptor entityAttributeJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType ); // build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer <-> String // conversions. This is the more complicated piece. First we need to determine the JDBC type code // corresponding to the AttributeConverter's declared ""databaseColumnJavaType"" (how we read that value out // of ResultSets). See JdbcTypeJavaClassMappings for details. Again, given example, this should return // VARCHAR/CHAR final int jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType ); // find the standard SqlTypeDescriptor for that JDBC type code. final SqlTypeDescriptor sqlTypeDescriptor = SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode ); // find the JavaTypeDescriptor representing the ""intermediate database type representation"". Back to the // illustration, this should be the type descriptor for Strings final JavaTypeDescriptor intermediateJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType ); // and finally construct the adapter, which injects the AttributeConverter calls into the binding/extraction // process... final SqlTypeDescriptor sqlTypeDescriptorAdapter = new AttributeConverterSqlTypeDescriptorAdapter( jpaAttributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptor, intermediateJavaTypeDescriptor ); // todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times. final String name = String.format( ""BasicType adapter for AttributeConverter<%s,%s>"", entityAttributeJavaType.getSimpleName(), databaseColumnJavaType.getSimpleName() ); return new AttributeConverterTypeAdapter( name, jpaAttributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptorAdapter, entityAttributeJavaTypeDescriptor ); }"	Build a Hibernate Type that incorporates the JPA AttributeConverter.	0	1
public synchronized PaintContext createContext(ColorModel cm, Rectangle r, Rectangle2D r2d, AffineTransform xform, RenderingHints hints) { return new ColorPaintContext(getRGB(), cm); }	Creates and returns a PaintContext used to generate a solid color field pattern.	1	0
private ServiceReference[] getInitialReferences(boolean trackAllServices, String className, String filterString) throws InvalidSyntaxException { if (trackAllServices) { return context.getAllServiceReferences(className, filterString); } return context.getServiceReferences(className, filterString); }	Returns the list of initial ServiceReference objects that will be tracked by this ServiceTracker object.	1	0
public int toStatusCode(Throwable thrown) { if (thrown == null) { return SUCCESS; } else if (thrown instanceof InvalidCookieDomainException) { return INVALID_COOKIE_DOMAIN; } else if (thrown instanceof UnableToSetCookieException) { return UNABLE_TO_SET_COOKIE; } else if (thrown instanceof NoSuchWindowException) { return NO_SUCH_WINDOW; } else if (thrown instanceof InvalidSelectorException) { return INVALID_SELECTOR_ERROR; } else if (thrown instanceof NoSuchElementException) { return NO_SUCH_ELEMENT; } else if (thrown instanceof NoSuchFrameException) { return NO_SUCH_FRAME; } else if (thrown instanceof StaleElementReferenceException) { return STALE_ELEMENT_REFERENCE; } else if (thrown instanceof ElementNotVisibleException) { return ELEMENT_NOT_VISIBLE; } else if (thrown instanceof InvalidElementStateException) { return INVALID_ELEMENT_STATE; } else if (thrown instanceof XPathLookupException) { return XPATH_LOOKUP_ERROR; } else if (thrown instanceof TimeoutException) { return ASYNC_SCRIPT_TIMEOUT; } else if (thrown instanceof InvalidCoordinatesException) { return INVALID_ELEMENT_COORDINATES; } else if (thrown instanceof ImeNotAvailableException) { return IME_NOT_AVAILABLE; } else if (thrown instanceof ImeActivationFailedException) { return IME_ENGINE_ACTIVATION_FAILED; } else if (thrown instanceof NoAlertPresentException) { return NO_ALERT_PRESENT; } else if (thrown instanceof MoveTargetOutOfBoundsException) { return MOVE_TARGET_OUT_OF_BOUNDS; } else { return UNHANDLED_ERROR; } }	Converts a thrown error into the corresponding status code.	0	1
public Tuplizer getTuplizerOrNull(EntityMode entityMode) { return tuplizers.get( entityMode ); }	Locate the contained tuplizer responsible for the given entity-mode.	0	1
public Future<Map<String, Object>> asyncGetBulk(String... keys) { return asyncGetBulk(Arrays.asList(keys)); }	Asynchronously get a bunch of objects from the cache and decode them with the given transcoder.	1	0
"private String generateMessage(boolean includeErrorIdAndIdentity) { return errorType + "" ERROR: "" + super.getMessage() + ""\n\n"" + context.generateContextMessage(includeErrorIdAndIdentity); }"	Generates a user error message that has the following structure:	0	1
public <RX extends RxInvokerProvider> Client buildRx(String name, Class<RX> invokerType) { return build(name).register(invokerType); }	Builds the RxClient instance.	1	0
public Set<Warning> getWarnings() { return Collections.unmodifiableSet(project.getWarnings(packageName)); }	Returns all the warnings in this package.	1	0
public String getResultKey() { return resultKey; }	Returns the key of this MergedField for the overall result.	0	1
public DurationType getDurationType(Object object) { return DurationType.getMillisType(); }	Selects a suitable duration type for the given object.	0	1
public TregexMatcher matcher(Tree t) { return matcher(t, t, null, new HashMap<String, Tree>(), new VariableStrings()); }	Get a TregexMatcher for this pattern on this tree.	0	1
"public boolean isTextPresent(String pattern) { return (Boolean) seleneseMethods.get(""isTextPresent"").apply(driver, pattern); }"	Verifies that the specified text pattern appears somewhere on the rendered page shown to the user.	0	1
"public WebElement augment(RemoteWebElement element) { // TODO(simon): We should really add a ""SelfDescribing"" interface for this RemoteWebDriver parent = (RemoteWebDriver) element.getWrappedDriver(); if (parent == null) { return element; } Map<String, AugmenterProvider> augmentors = elementAugmentors; CompoundHandler handler = determineAugmentation(parent, augmentors); RemoteWebElement remote = create(handler, element); remote.setId(element.getId()); remote.setParent(parent); return remote; }"	Enhance the interfaces implemented by this instance of WebDriver iff that instance is a org.openqa.selenium.remote.RemoteWebDriver.	1	0
public static Webcam getDefault(long timeout) throws TimeoutException { return getDefault(timeout, TimeUnit.MILLISECONDS); }	Will discover and return first webcam available in the system.	0	1
public int getOrdinalParameterSourceLocation(int position) { return getOrdinalParameterDescriptor( position ).getPosition(); }	Deprecated.	0	1
public Node getFirstNode() { return m_node1; } //	Return the GraphItem representing the first (source) node in the edge.	1	0
"public RelOptTableImpl getTable(final List<String> names) { RelOptTableImpl temporaryTable = null; if (mightBeTemporaryTable(names, session.getDefaultSchemaPath(), drillConfig)) { String temporaryTableName = session.resolveTemporaryTableName(names.get(names.size() - 1)); if (temporaryTableName != null) { List<String> temporaryNames = Lists.newArrayList(temporarySchema, temporaryTableName); temporaryTable = super.getTable(temporaryNames); } } if (temporaryTable != null) { if (allowTemporaryTables) { return temporaryTable; } throw UserException .validationError() .message(""Temporary tables usage is disallowed. Used temporary table name: %s."", names) .build(logger); } RelOptTableImpl table = super.getTable(names); // Check the schema and throw a valid SchemaNotFound exception instead of TableNotFound exception. if (table == null) { isValidSchema(names); } return table; }"	If schema is not indicated (only one element in the list) or schema is default temporary workspace, we need to check among session temporary tables in default temporary workspace first.	0	1
"public int atAdPos(final int pos) { final int take_int = (int) Math.floor((pos + 1) / adfrequency); Log.d(""atAdPosE2"", take_int + """"); return take_int; }"	to display the accumulator for the Ad position	0	1
"public List<LogicalInputSplit> getInputSplits(final HiveReadEntry hiveReadEntry) { final Stopwatch timeGetSplits = Stopwatch.createStarted(); try { if (!isPartitionedTable) { return getTableInputSplits(); } final List<LogicalInputSplit> splits = Lists.newArrayList(); for (HivePartition p : hiveReadEntry.getPartitions()) { splits.addAll(getPartitionInputSplits(p)); } return splits; } catch (final Exception e) { logger.error(""Failed to get InputSplits"", e); throw new DrillRuntimeException(""Failed to get InputSplits"", e); } finally { logger.debug(""Took {} Âµs to get InputSplits from {}.{}"", timeGetSplits.elapsed(TimeUnit.NANOSECONDS) / 1000, hiveReadEntry.getTable().getDbName(), hiveReadEntry.getTable().getTableName()); } }"	Return InputSplitWrappers for given HiveReadEntry.	1	0
"private TimerTask getServiceUrlUpdateTask(final String zone) { return new TimerTask() { @Override public void run() { try { List<String> serviceUrlList = timedGetDiscoveryServiceUrls(zone); if (serviceUrlList.isEmpty()) { logger.warn(""The service url list is empty""); return; } if (!serviceUrlList.equals(eurekaServiceUrls.get())) { logger.info( ""Updating the serviceUrls as they seem to have changed from {} to {} "", Arrays.toString(eurekaServiceUrls.get() .toArray()), Arrays .toString(serviceUrlList.toArray())); eurekaServiceUrls.set(serviceUrlList); } } catch (Throwable e) { logger.error(""Cannot get the eureka service urls :"", e); } } }; }"	Gets the task that is responsible for fetching the eureka service Urls.	0	1
"public String preprocess(String buildPath) throws RunnerException { try { return preprocess(buildPath, new PdePreprocessor(buildPath, name)); } catch (IOException e) { throw new RunnerException(""Error while preprocessing"", true); } }"	Build all the code for this sketch.	0	1
public String toString() { try { return toString(-1); } catch (Exception e) { return null; } }	Make a JSON text of this JSONArray.	1	0
public boolean scrollUp(){ waiter.waitForViews(ListView.class, ScrollView.class, false); return scroller.scroll(Scroller.UP); }	Scrolls up the screen.	0	1
"private File[] getDirectoryHistory() { File[] dirhist = Settings.instance().getDirectoryHistory(); if (dirhist == null || dirhist.length == 0) return new File[] { new File(""."").getAbsoluteFile() }; else return dirhist; }"	Gets current directory history from TODO.	1	0
protected Object getComponentValue(ComponentType type, Object component, String propertyPath) { final int loc = propertyPath.indexOf( '.' ); final String basePropertyName = loc > 0 ? propertyPath.substring( 0, loc ) : propertyPath; final int index = findSubPropertyIndex( type, basePropertyName ); final Object baseValue = type.getPropertyValue( component, index, getEntityMode() ); if ( loc > 0 ) { if ( baseValue == null ) { return null; } return getComponentValue( (ComponentType) type.getSubtypes()[index], baseValue, propertyPath.substring(loc+1) ); } else { return baseValue; } }	Extract a component property value.	0	1
public ArrayList<View> getViews() { try { return viewFetcher.getViews(null, false); } catch (Exception e) { e.printStackTrace(); return null; } }	Returns an ArrayList of the View objects located in the current Activity.	1	0
public static Log named(String name) { // a thread-safe SLF4J initialization routine is apparently hard, so I get to do dumb // shit like this while (true) { final org.slf4j.Logger logger = LoggerFactory.getLogger(name); if (logger instanceof Logger) { return forSlf4jLogger(logger); } } }	Returns a Log instance with the given name.	0	1
public static int nextPowerOfTwo(final int value) { return 1 << (32 - Integer.numberOfLeadingZeros(value - 1)); }	Returns the next power of two that is larger than the specified int value.	1	0
private List<BatchResponse> handleBatchRequests(final List<BatchRequest> requestList, final UriInfo uriInfo) { final List<BatchResponse> responseList = new ArrayList<>(requestList.size()); final List<BatchRequestNode> batchRequestNodes = this.resolutionHelper.getDependingRequests(requestList); checkList.clear(); if(batchRequestNodes.isEmpty()) { final BatchResponse response = new BatchResponse(); ErrorInfo ex = ErrorHandler.handler(new ClientDetailsNotFoundException()); response.setStatusCode(500); response.setBody(ex.getMessage()); responseList.add(response) ; return responseList ; } for (BatchRequestNode rootNode : batchRequestNodes) { final BatchRequest rootRequest = rootNode.getRequest(); final CommandStrategy commandStrategy = this.strategyProvider.getCommandStrategy(CommandContext .resource(rootRequest.getRelativeUrl()).method(rootRequest.getMethod()).build()); final BatchResponse rootResponse = commandStrategy.execute(rootRequest, uriInfo); responseList.add(rootResponse); responseList.addAll(this.processChildRequests(rootNode, rootResponse, uriInfo)); } Collections.sort(responseList, new Comparator<BatchResponse>() { @Override public int compare(BatchResponse source, BatchResponse testee) { return source.getRequestId().compareTo(testee.getRequestId()); } }); checkList = responseList; return responseList; }	Returns the response list by getting a proper org.apache.fineract.batch.command.CommandStrategy.	0	1
private List<CardViewWrapper> getVisibleViewsForCards(List<Card> cardsCopy) { List<CardViewWrapper> originalViews = new ArrayList<CardViewWrapper>(); for (Card card:cardsCopy){ originalViews.add(card.getCardView()); } /*List<CardView> views = new ArrayList<CardView>(); for (int i = 0; i < mCardListView.getChildCount(); i++) { View child = mCardListView.getChildAt(i); if (cardsCopy.contains(views)){ views.add((CardView) child); } }*/ return originalViews; }	Returns the visible view for the cards	0	1
public List<SentenceFragment> clausesInSentence(CoreMap sentence) { return clausesInSentence(sentence.get(SemanticGraphCoreAnnotations.EnhancedPlusPlusDependenciesAnnotation.class), true); }	Find the clauses in a sentence.	0	1
public boolean shouldBuffer() { Window window = runningQuery.getQuery().getWindow(); boolean noWindow = window == null; // If it's a RAW query without a window, it should be buffered if and only if it timed out. This means that the // query is not yet done. So this tells the driver to buffer the query to wait for more potential results. if (noWindow && isRaw()) { return runningQuery.isTimedOut(); } // No window (and not raw) is a duration based query => do buffer. Otherwise, buffer if the window is time based. return noWindow || window.isTimeBased(); }	Returns if this query should be buffered for a bit before getting results out.	1	0
public static ModuleConfig getModuleConfig(PageContext pageContext) { ModuleConfig moduleConfig = (ModuleConfig) pageContext.getRequest().getAttribute(Globals.MODULE_KEY); if (moduleConfig == null) { // Backwards compatibility hack moduleConfig = (ModuleConfig) pageContext.getServletContext().getAttribute(Globals.MODULE_KEY); } return moduleConfig; }	Return the ApplicationConfig object is it exists, null otherwise.	1	0
public byte toOrdinal() { return this.opCode; }	Returns the int representing this operation code.	1	0
private Timestamp[] getTimeframe() { Timestamp oldest = Timestamp.ZERO.plus(1000000); Timestamp newest = Timestamp.ZERO; for (Habit h : selectedHabits) { if(h.getRepetitions().getOldest() == null || h.getRepetitions().getNewest() == null) continue; Timestamp currOld = h.getRepetitions().getOldest().getTimestamp(); Timestamp currNew = h.getRepetitions().getNewest().getTimestamp(); oldest = currOld.isOlderThan(oldest) ? oldest : currOld; newest = currNew.isNewerThan(newest) ? newest : currNew; } return new Timestamp[]{oldest, newest}; }	Gets the overall timeframe of the selected habits.	0	1
@Override public AsyncAppenderBase<IAccessEvent> build() { return new AsyncAppenderBase<IAccessEvent>() { @Override protected void preprocess(IAccessEvent event) { event.prepareForDeferredProcessing(); } }; }	Creates an AsyncAppenderBase of type IAccessEvent.	1	0
public static EString substring(Expr<String> left, int right) { return operationFactory.createString(Ops.SUBSTR1ARG, left, exprFactory .createConstant(right)); }	Expr : left.substring(beginIndex, endIndex)	1	0
public double getMatchRatio(String strA, String strB) { if (strA == null && strB == null) { return MAX_RATIO; } else if (strA == null || strB == null) { return MIN_RATIO; } if (strA.isEmpty() && strB.isEmpty()) { return MAX_RATIO; } else if (strA.isEmpty() || strB.isEmpty()) { return MIN_RATIO; } //get the percentage match against the longer of the 2 strings return (double)getLCS(strA, strB).length() / Math.max(strA.length(), strB.length()); }	Calculate the ratio of similarity between 2 strings using LCS	0	1
public boolean isVisible(String locator) { return ((RenderedWebElement) elementFinder.findElement(driver, locator)).isDisplayed(); }	Determines if the specified element is visible.	0	1
"public static YourKitContext startProfile(boolean enableStackTelemetry, boolean enableCPUProfilling, boolean enableAllocationRecording) { Controller controller; try { controller = new Controller(); // CHECKSTYLE: stop IllegalCatch } catch (Exception e) { // CHECKSTYLE: resume IllegalCatch LOG.info(""Failed to set up YourKit controller"", e); return null; } try { if (enableStackTelemetry) { controller.enableStackTelemetry(); LOG.info(""Enabled Yourkit stack telemetry""); } // CHECKSTYLE: stop IllegalCatch } catch (Exception e) { // CHECKSTYLE: resume IllegalCatch LOG.info(""Failed to enable YourKit stack telemetry"", e); } try { if (enableCPUProfilling) { controller.startCPUProfiling(ProfilingModes.CPU_SAMPLING, Controller.DEFAULT_FILTERS, Controller.DEFAULT_WALLTIME_SPEC); LOG.info(""Started YourKit CPU profiling""); } // CHECKSTYLE: stop IllegalCatch } catch (Exception e) { // CHECKSTYLE: resume IllegalCatch LOG.info(""Failed to start YourKit CPU profiling"", e); } try { if (enableAllocationRecording) { controller.startAllocationRecording(true, ALLOCATION_RECORDING_INTERVAL, false, -1, true, false); LOG.info(""Started YourKit allocation recording""); } // CHECKSTYLE: stop IllegalCatch } catch (Exception e) { // CHECKSTYLE: resume IllegalCatch LOG.info(""Failed to start YourKit allocation recording"", e); } return new YourKitContext(controller); }"	Convenient replacement of #startProfilingCPU(long) with ProfilingModes#CPU_TRACING for the mode.	1	0
public ExecutionInfo treatAs(GraphQLType newType) { return new ExecutionInfo(unwrapNonNull(newType), fieldDefinition, field, path, this.parentInfo, this.typeIsNonNull, arguments); }	This allows you to morph a type into a more specialized form yet return the same parent and non-null ness, for example taking a GraphQLInterfaceType and turning it into a specific graphql.schema.GraphQLObjectType after type resolution has occurred	0	1
public <C extends EvictionCandidate<A, E>> Iterable<C> evaluate(Iterable<C> evictionCandidates) { C selectedEvictionCandidate = null; long now = Clock.currentTimeMillis(); for (C currentEvictionCandidate : evictionCandidates) { if (selectedEvictionCandidate == null) { selectedEvictionCandidate = currentEvictionCandidate; } else { E evictable = currentEvictionCandidate.getEvictable(); if (isExpired(now, evictable)) { return returnEvictionCandidate(currentEvictionCandidate); } int comparisonResult = evictionPolicyComparator.compare(selectedEvictionCandidate, currentEvictionCandidate); if (comparisonResult == EvictionPolicyComparator.SECOND_ENTRY_HAS_HIGHER_PRIORITY_TO_BE_EVICTED) { selectedEvictionCandidate = currentEvictionCandidate; } } } return returnEvictionCandidate(selectedEvictionCandidate); }	Selects the best candidate to be evicted.	1	0
@Transactional(readOnly = true) @Override public int getCount(final List<BatchInstanceStatus> batchInstStatusList, final List<BatchPriority> batchPriorities, final boolean isCurrUsrNotReq, final String currentUser, final Set<String> userRoles, EphesoftUser ephesoftUser) { return batchInstanceDao .getCount(batchInstStatusList, batchPriorities, isCurrUsrNotReq, userRoles, currentUser, ephesoftUser); }	An api to fetch count of the batch instance table for a given status list and batch priority and current user required	1	0
"public static Builder create() { return new Builder() { private Configuration config; private Consumer<SourceRecord> consumer; private ClassLoader classLoader; private Clock clock; private CompletionCallback completionCallback; @Override public Builder using(Configuration config) { this.config = config; return this; } @Override public Builder using(ClassLoader classLoader) { this.classLoader = classLoader; return this; } @Override public Builder using(Clock clock) { this.clock = clock; return this; } @Override public Builder using(CompletionCallback completionCallback) { this.completionCallback = completionCallback; return this; } @Override public Builder notifying(Consumer<SourceRecord> consumer) { this.consumer = consumer; return this; } @Override public EmbeddedEngine build() { if (classLoader == null) classLoader = getClass().getClassLoader(); if (clock == null) clock = Clock.system(); Objects.requireNonNull(config, ""A connector configuration must be specified.""); Objects.requireNonNull(consumer, ""A connector consumer must be specified.""); return new EmbeddedEngine(config, classLoader, clock, consumer, completionCallback); } }; }"	Obtain a new Builder instance that can be used to construct runnable EmbeddedEngine instances.	0	1
public ComponentType introspect(Class<?> implClass) throws ConfigurationLoadException { ComponentType compType = factory.createComponentType(); return introspect(implClass, compType); }	Visits the given implementation type and calls back to org.apache.tuscany.core.extension.config.ImplementationProcessors registered with this introspector to build up a ComponentInfo	1	0
public final Entity getEntity() { return entity; }	Returns the entity as an input stream.	1	0
public List<List<TaggedWord>> process(List<? extends List<? extends HasWord>> sentences) { List<List<TaggedWord>> taggedSentences = Generics.newArrayList(); TestSentence testSentence = new TestSentence(this); for (List<? extends HasWord> sentence : sentences) { taggedSentences.add(testSentence.tagSentence(sentence, false)); } return taggedSentences; }	Tags the Words in each Sentence in the given List with their grammatical part-of-speech.	0	1
@Override public boolean isClosed() { return mode == Mode.PARTITION ? window.isClosedForPartition() : window.isClosed(); }	Returns true if the query window is closed and you should emit the result at this time.	1	0
public android.telecom.Connection.VideoProvider getVideoProvider() { return mVideoProvider; }	Returns the android.telecomm.Connection.VideoProvider for the connection.	1	0
public TopicPublisher createPublisher(Topic topic) throws JMSException { checkClosed(); if (topic instanceof CustomDestination) { CustomDestination customDestination = (CustomDestination)topic; return customDestination.createPublisher(this); } int timeSendOut = connection.getSendTimeout(); return new ActiveMQTopicPublisher(this, ActiveMQMessageTransformation.transformDestination(topic),timeSendOut); }	Creates a publisher for the specified topic.	0	1
public TableEditor editOrCreateTable(TableId tableId) { Table table = forTable(tableId); return table == null ? Table.editor().tableId(tableId) : table.edit(); }	Obtain an editor for the identified table or, if there is no such table, create an editor with the specified ID.	1	0
public static Object deserialize(InputStream inputStream) throws SerializationException { return deserialize( inputStream, Thread.currentThread().getContextClassLoader() ); }	Deserializes an Object from the specified stream. The stream will be closed once the object is written.	1	0
public final TwitterTokenStream deserialize(final byte[] data, final CharSequence charSequence) throws IOException { return deserialize(data, 0, data.length, charSequence); }	Deserializes the previously serialized TokenStream using the provided AttributeSerializer(s).	1	0
public static byte[] readByteCode(ZipInputStream zip) throws IOException { ByteArrayOutputStream bout = new ByteArrayOutputStream(); InputStream in = new BufferedInputStream( zip ); int b; while ( ( b = in.read() ) != -1 ) { bout.write( b ); } return bout.toByteArray(); }	Reads class byte array info from the given input stream.	1	0
public static boolean isComparable(RelDataType type1, RelDataType type2) { if (type1.isStruct() != type2.isStruct()) { return false; } if (type1.isStruct()) { int n = type1.getFieldCount(); if (n != type2.getFieldCount()) { return false; } for (Pair<RelDataTypeField, RelDataTypeField> pair : Pair.zip(type1.getFieldList(), type2.getFieldList())) { if (!isComparable(pair.left.getType(), pair.right.getType())) { return false; } } return true; } RelDataTypeFamily family1 = null; RelDataTypeFamily family2 = null; // REVIEW jvs 2-June-2005: This is needed to keep // the Saffron type system happy. if (type1.getSqlTypeName() != null) { family1 = type1.getSqlTypeName().getFamily(); } if (type2.getSqlTypeName() != null) { family2 = type2.getSqlTypeName().getFamily(); } if (family1 == null) { family1 = type1.getFamily(); } if (family2 == null) { family2 = type2.getFamily(); } if (family1 == family2) { return true; } // If one of the operators is of type 'ANY', return true. if (family1 == SqlTypeFamily.ANY || family2 == SqlTypeFamily.ANY) { return true; } // We can implicitly convert from character to date if (family1 == SqlTypeFamily.CHARACTER && canConvertStringInCompare(family2) || family2 == SqlTypeFamily.CHARACTER && canConvertStringInCompare(family1)) { return true; } return false; }	Returns whether two types are comparable.	0	1
public boolean contains(long millisInstant) { long thisStart = getStartMillis(); long thisEnd = getEndMillis(); return (millisInstant >= thisStart && millisInstant < thisEnd) || (thisStart == millisInstant && thisEnd == millisInstant); }	Does this time interval contain the specified millisecond instant.	1	0
"protected static Extractor[] getExtractorFramesRare(String identifier, TTags ttags) { ArrayList<Extractor> extrs = new ArrayList<>(); List<String> args = StringUtils.valueSplit(identifier, ""[a-zA-Z0-9]*(?:\\([^)]*\\))?"", ""\\s*,\\s*""); for (String arg : args) { if (""naacl2003unknowns"".equalsIgnoreCase(arg)) { extrs.addAll(Arrays.asList(eFrames_motley_naacl2003)); getNaaclExtractors(extrs); } else if ((""lnaacl2003unknowns"").equalsIgnoreCase(arg)) { extrs.addAll(Arrays.asList(eFrames_motley_naacl2003_left)); getNaaclExtractors(extrs); } else if (""caselessnaacl2003unknowns"".equalsIgnoreCase(arg)) { extrs.addAll(Arrays.asList(eFrames_motley_caseless_naacl2003)); getCaselessNaaclExtractors(extrs); // TODO: test this next one } else if (""naacl2003conjunctions"".equalsIgnoreCase(arg)) { extrs.addAll(Arrays.asList(naacl2003Conjunctions())); } else if (""frenchunknowns"".equalsIgnoreCase(arg)) { extrs.addAll(Arrays.asList(french_unknown_extractors)); } else if (arg.startsWith(""wordshapes("")) { int lWindow = Extractor.getParenthesizedNum(arg, 1); int rWindow = Extractor.getParenthesizedNum(arg, 2); String wsc = Extractor.getParenthesizedArg(arg, 3); if (wsc == null) { wsc = ""chris2""; } for (int i = lWindow; i <= rWindow; i++) { extrs.add(new ExtractorWordShapeClassifier(i, wsc)); } } else if (arg.startsWith(""wordshapeconjunction("")) { int lWindow = Extractor.getParenthesizedNum(arg, 1); int rWindow = Extractor.getParenthesizedNum(arg, 2); String wsc = Extractor.getParenthesizedArg(arg, 3); if (wsc == null) { wsc = ""chris2""; } for (int i = lWindow; i <= rWindow; i++) { extrs.add(new ExtractorWordShapeConjunction(lWindow, rWindow, wsc)); } } else if (arg.startsWith(""unicodeshapes("")) { int lWindow = Extractor.getParenthesizedNum(arg, 1); int rWindow = Extractor.getParenthesizedNum(arg, 2); for (int i = lWindow; i <= rWindow; i++) { extrs.add(new ExtractorWordShapeClassifier(i, ""chris4"")); } } else if (arg.startsWith(""unicodeshapeconjunction("")) { int lWindow = Extractor.getParenthesizedNum(arg, 1); int rWindow = Extractor.getParenthesizedNum(arg, 2); extrs.add(new ExtractorWordShapeConjunction(lWindow, rWindow, ""chris4"")); } else if (arg.startsWith(""chinesedictionaryfeatures("")) { throw new RuntimeException(""These features are no longer supported."" + "" The paths and data files associated "" + ""with this material are out of date, and "" + ""the classes used are not thread-safe. "" + ""Those problems would need to be fixed "" + ""to use this feature.""); //String path = Extractor.getParenthesizedArg(arg, 1); //// Default nlp location for these features is: /u/nlp/data/pos-tagger/dictionary //int lWindow = Extractor.getParenthesizedNum(arg, 2); //int rWindow = Extractor.getParenthesizedNum(arg, 3); //// First set up the dictionary prefix for the Chinese dictionaries //ASBCDict.setPathPrefix(path); //for (int i = lWindow; i <= rWindow; i++) { // extrs.addAll(Arrays.asList(ctbPreFeatures(i))); // extrs.addAll(Arrays.asList(ctbSufFeatures(i))); // extrs.addAll(Arrays.asList(ctbUnkDictFeatures(i))); // extrs.addAll(Arrays.asList(asbcUnkFeatures(i))); //} // No longer add prefix suffix features, now that you can more flexibly add them separately. // } else if (""generic"".equalsIgnoreCase(arg)) { // // does prefix and suffix up to 6 grams // for (int i = 1; i <= 6; i++) { // extrs.add(new ExtractorCWordSuff(i)); // extrs.add(new ExtractorCWordPref(i)); // } } else if (arg.equalsIgnoreCase(""motleyUnknown"")) { // This is naacl2003unknown minus prefix and suffix features. extrs.addAll(Arrays.asList(eFrames_motley_naacl2003)); } else if (arg.startsWith(""suffix("")) { int max = Extractor.getParenthesizedNum(arg, 1); // will conveniently be 0 if not specified int position = Extractor.getParenthesizedNum(arg, 2); for (int i = 1; i <= max; i++) { extrs.add(new ExtractorWordSuff(i, position)); } } else if (arg.startsWith(""prefix("")) { int max = Extractor.getParenthesizedNum(arg, 1); // will conveniently be 0 if not specified int position = Extractor.getParenthesizedNum(arg, 2); for (int i = 1; i <= max; i++) { extrs.add(new ExtractorWordPref(i, position)); } } else if (arg.startsWith(""prefixsuffix("")) { int max = Extractor.getParenthesizedNum(arg, 1); for (int i = 1; i <= max; i++) { extrs.add(new ExtractorsConjunction(new ExtractorWordPref(i, 0), new ExtractorWordSuff(i, 0))); } } else if (arg.startsWith(""capitalizationsuffix("")) { int max = Extractor.getParenthesizedNum(arg, 1); for (int i = 1; i <= max; i++) { extrs.add(new ExtractorsConjunction(cWordUppCase, new ExtractorWordSuff(i,0))); } } else if (arg.startsWith(""distsim("")) { String path = Extractor.getParenthesizedArg(arg, 1); // traditional nlp filesystem location is: /u/nlp/data/pos_tags_are_useless/egw.bnc.200.pruned int lWindow = Extractor.getParenthesizedNum(arg, 2); int rWindow = Extractor.getParenthesizedNum(arg, 3); for (int i = lWindow; i <= rWindow; i++) { extrs.add(new ExtractorDistsim(path, i)); } } else if (arg.startsWith(""distsimconjunction("")) { String path = Extractor.getParenthesizedArg(arg, 1); int lWindow = Extractor.getParenthesizedNum(arg, 2); int rWindow = Extractor.getParenthesizedNum(arg, 3); extrs.add(new ExtractorDistsimConjunction(path, lWindow, rWindow)); } else if (arg.equalsIgnoreCase(""lctagfeatures"")) { extrs.addAll(Arrays.asList(lcTagFeatures(ttags))); } } return extrs.toArray(Extractor.EMPTY_EXTRACTOR_ARRAY); }"	Get an array of rare word feature Extractor identified by a name.	0	1
public List getAnchorHRefs(boolean duplicate) { if (duplicate) { return this.htmlHandler.getAllAHRefs(); } return this.htmlHandler.getAHRefs(); }	DOCUMENT ME!	1	0
public static DateTimeFormatter dateHourMinute() { return Constants.dhm; }	Returns a formatter that combines a full date, two digit hour of day, and two digit minute of hour.	0	1
public List<TableDesc> listTables() { return allTables; }	at first stage the only table in II is fact table, TODO: to extend to all tables	1	0
public DateTimeField[] getFields() { DateTimeField[] result = new DateTimeField[getFieldSize()]; for (int i = 0; i < result.length; i++) { result[i] = getField(i); } return result; }	Gets an array of the fields that this partial supports.	0	1
"public static RelDataTypeField extra(RelDataType rowType) { // Even in a case-insensitive connection, the name must be precisely // ""_extra"". return rowType.getField(""_extra"", true, false); }"	"Returns the ""extra"" field in a row type whose presence signals that fields will come into existence just by asking for them."	0	1
"boolean storeRelations(KeyRegistry keyRegistry) { if (relationStoreInfos.isEmpty()) { // No relations waiting to be persisted return false; } ObjectProvider op = getObjectProvider(); ExecutionContext ec = op.getExecutionContext(); DatastoreTable table = getDatastoreTable(); if (datastoreEntity.getKey() != null) { // Register parent key for all owned related objects Key key = datastoreEntity.getKey(); AbstractClassMetaData acmd = op.getClassMetaData(); int[] relationFieldNums = acmd.getRelationMemberPositions(ec.getClassLoaderResolver(), ec.getMetaDataManager()); if (relationFieldNums != null) { for (int i=0;i<relationFieldNums.length;i++) { AbstractMemberMetaData mmd = acmd.getMetaDataForManagedMemberAtAbsolutePosition(relationFieldNums[i]); boolean owned = MetaDataUtils.isOwnedRelation(mmd); if (owned) { Object childValue = op.provideField(mmd.getAbsoluteFieldNumber()); if (childValue != null) { if (childValue instanceof Object[]) { childValue = Arrays.asList((Object[]) childValue); } String expectedType = getExpectedChildType(mmd); if (childValue instanceof Iterable) { // TODO(maxr): Make sure we're not pulling back unnecessary data when we iterate over the values. for (Object element : (Iterable) childValue) { addToParentKeyMap(keyRegistry, element, key, op.getExecutionContext(), expectedType, true); } } else { addToParentKeyMap(keyRegistry, childValue, key, op.getExecutionContext(), expectedType, !table.isParentKeyProvider(mmd)); } } } } } } boolean modifiedEntity = false; // Stage 1 : process FKs for (RelationStoreInformation relInfo : relationStoreInfos) { AbstractMemberMetaData mmd = relInfo.mmd; try { JavaTypeMapping mapping = table.getMemberMappingInDatastoreClass(relInfo.mmd); if (mapping instanceof EmbeddedPCMapping || mapping instanceof SerialisedPCMapping || mapping instanceof SerialisedReferenceMapping || mapping instanceof PersistableMapping || mapping instanceof InterfaceMapping) { if (!table.isParentKeyProvider(mmd)) { EntityUtils.checkParentage(relInfo.value, op); mapping.setObject(getExecutionContext(), datastoreEntity, IS_FK_VALUE_ARR, relInfo.value, op, mmd.getAbsoluteFieldNumber()); } } } catch (NotYetFlushedException e) { // Ignore this. We always have the object in the datastore, at least partially to get the key } } // Stage 2 : postInsert/postUpdate for (RelationStoreInformation relInfo : relationStoreInfos) { try { JavaTypeMapping mapping = table.getMemberMappingInDatastoreClass(relInfo.mmd); if (mapping instanceof MappingCallbacks) { if (operation == StoreFieldManager.Operation.INSERT) { ((MappingCallbacks)mapping).postInsert(op); } else { ((MappingCallbacks)mapping).postUpdate(op); } } } catch (NotYetFlushedException e) { // Ignore this. We always have the object in the datastore, at least partially to get the key } } // Stage 3 : set child keys in parent for (RelationStoreInformation relInfo : relationStoreInfos) { AbstractMemberMetaData mmd = relInfo.mmd; int relationType = mmd.getRelationType(ec.getClassLoaderResolver()); boolean owned = MetaDataUtils.isOwnedRelation(mmd); if (owned) { // Owned relations only store child keys if storageVersion high enough, and at ""owner"" side. if (!getStoreManager().storageVersionAtLeast(StorageVersion.WRITE_OWNED_CHILD_KEYS_TO_PARENTS)) { // don't write child keys to the parent if the storage version isn't high enough continue; } if (relationType == Relation.MANY_TO_ONE_BI) { // We don't store any ""FK"" of the parent at the child side (use parent key instead) continue; } else if (relationType == Relation.ONE_TO_ONE_BI && mmd.getMappedBy() != null) { // We don't store any ""FK"" at the non-owner side (use parent key instead) continue; } } Object value = relInfo.value; String propName = EntityUtils.getPropertyName(getStoreManager().getIdentifierFactory(), mmd); if (value == null) { // Nothing to extract checkSettingToNullValue(mmd, value); if (!datastoreEntity.hasProperty(propName)) { modifiedEntity = true; EntityUtils.setEntityProperty(datastoreEntity, mmd, propName, value); } } else if (Relation.isRelationSingleValued(relationType)) { if (ec.getApiAdapter().isDeleted(value)) { value = null; } else { Key key = EntityUtils.extractChildKey(value, ec, datastoreEntity); if (key == null) { Object childPC = processPersistable(mmd, value); if (childPC != value) { // Child object has been persisted/attached, so update it in the owner op.replaceField(mmd.getAbsoluteFieldNumber(), childPC); } key = EntityUtils.extractChildKey(childPC, ec, datastoreEntity); } value = key; if (!datastoreEntity.hasProperty(propName) || !value.equals(datastoreEntity.getProperty(propName))) { modifiedEntity = true; EntityUtils.setEntityProperty(datastoreEntity, mmd, propName, value); } } } else if (Relation.isRelationMultiValued(relationType)) { if (mmd.hasCollection()) { Collection coll = (Collection) value; List<Key> keys = Utils.newArrayList(); for (Object obj : coll) { // TODO Should process SCO before we get here so we have no deleted objects if (!ec.getApiAdapter().isDeleted(obj)) { Key key = EntityUtils.extractChildKey(obj, ec, datastoreEntity); if (key != null) { keys.add(key); } else { Object childPC = processPersistable(mmd, obj); key = EntityUtils.extractChildKey(childPC, ec, datastoreEntity); keys.add(key); } } } value = keys; if (!datastoreEntity.hasProperty(propName) || !value.equals(datastoreEntity.getProperty(propName))) { modifiedEntity = true; EntityUtils.setEntityProperty(datastoreEntity, mmd, propName, value); } } // TODO Cater for PC array, maps } } relationStoreInfos.clear(); return modifiedEntity; }"	Applies all the relation events that have been built up.	1	0
static boolean hasNoNulls(Statistics stat) { return stat.getNumNulls() <= 0; }	Checks that column chunk's statistics has at least one null	1	0
public static boolean startsWithPattern(final byte[] byteArray, final byte[] pattern) { return hasPatternAt(byteArray, pattern, 0); }	Checks if byteArray interpreted as sequence of bytes starts with pattern starting at position equal to offset.	0	1
public Definition emit(Class cls, String allowedMethods) throws Exception { this.cls = cls; this.allowedMethods = allowedMethods; /** @todo ravi: getting the serviceName from cls name or explicitly ask the user? */ String name = cls.getName(); name = name.substring(name.lastIndexOf('.') + 1); setServiceName(name); return emit(); }	Generates a WSDL Document for a given Class and a space seperated list of methods at design time	1	0
public DateOnly roundHalfFloorCopy() { DateOnly instant = iInstant; return (DateOnly)instant.withMillis(iField.roundHalfFloor(instant.getMillis())); }	Rounds to the nearest whole unit of this field on a copy of this DateOnly, favoring the floor if halfway.	0	1
public Float getTopValue() { return topValue; }	Gets the 'top' CSS-attributes value in specified units.	1	0
"protected WebSocket doWebSocketConnect(final HttpServletRequest request, final String protocol) { logger.info(""WebSocket upgrade requested""); return new WebSocket() { private WebSocketProcessor webSocketProcessor; @Override public void onConnect(WebSocket.Outbound outbound) { webSocketProcessor = new WebSocketProcessor(AtmosphereServlet.this, new JettyWebSocketSupport(outbound)); try { webSocketProcessor.connect(new JettyRequestFix(request)); } catch (IOException e) { logger.warn(""failed to connect to web socket"", e); } } @Override public void onMessage(byte frame, String data) { webSocketProcessor.broadcast(frame, data); } @Override public void onMessage(byte frame, byte[] data, int offset, int length) { webSocketProcessor.broadcast(frame, new String(data, offset, length)); } @Override public void onFragment(boolean more, byte opcode, byte[] data, int offset, int length) { webSocketProcessor.broadcast(opcode, new String(data, offset, length)); } @Override public void onDisconnect() { webSocketProcessor.close(); } }; }"	Jetty 7.2 & 8.0.0-M1/M2and up WebSocket support.	1	0
public Throwable initCause(Throwable cause) { return super.initCause(cause); }	The cause of this exception can only be set when constructed.	1	0
public static ActiveMQConnectionFactory createConnectionFactoryWithoutHA(final DiscoveryGroupConfiguration groupConfiguration, JMSFactoryType jmsFactoryType) { ActiveMQConnectionFactory factory = null; if (jmsFactoryType.equals(JMSFactoryType.CF)) { factory = new ActiveMQJMSConnectionFactory(false, groupConfiguration); } else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_CF)) { factory = new ActiveMQQueueConnectionFactory(false, groupConfiguration); } else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_CF)) { factory = new ActiveMQTopicConnectionFactory(false, groupConfiguration); } else if (jmsFactoryType.equals(JMSFactoryType.XA_CF)) { factory = new ActiveMQXAConnectionFactory(false, groupConfiguration); } else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_XA_CF)) { factory = new ActiveMQXAQueueConnectionFactory(false, groupConfiguration); } else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_XA_CF)) { factory = new ActiveMQXATopicConnectionFactory(false, groupConfiguration); } return factory; }	Create a HornetQConnectionFactory which creates session factories from a set of live servers, no HA backup information is propagated to the client	1	0
public boolean isConstrained(String observation) { return observationIndex.indexOf(observation) >= 0; }	True if this observation is constrained, and false otherwise.	0	1
"public int pingAndWaitForReply(Message message, int numPings, long timeout) throws JMSException, InterruptedException { // Put a unique correlation id on the message before sending it. String messageCorrelationId = Long.toString(idGenerator.incrementAndGet()); message.setJMSCorrelationID(messageCorrelationId); for (int i = 0; i < numPings; i++) { // Re-timestamp the message. message.setLongProperty(""timestamp"", System.currentTimeMillis()); _producer.send(message); } // Commit the transaction if running in transactional mode. This must happen now, rather than at the end of // this method, as the message will not be sent until the transaction is committed. commitTx(getProducerSession()); // Keep the messageId to correlate with the reply. //String messageId = message.getJMSMessageID(); if (_verbose) { _logger.info(timestampFormatter.format(new Date()) + "": Pinged at with correlation id, "" + messageCorrelationId); } // Block the current thread until a reply to the message is received, or it times out. CountDownLatch trafficLight = new CountDownLatch(numPings); trafficLights.put(messageCorrelationId, trafficLight); // Note that this call expects a timeout in nanoseconds, millisecond timeout is multiplied up. trafficLight.await(timeout, TimeUnit.MILLISECONDS); // Work out how many replies were receieved. int numReplies = numPings - (int) trafficLight.getCount(); if ((numReplies < numPings) && _verbose) { _logger.info(""Timed out before all replies received on id, "" + messageCorrelationId); } else if (_verbose) { _logger.info(""Got all replies on id, "" + messageCorrelationId); } return numReplies; }"	Sends the specified ping message and then waits for a correlating reply.	1	0
public TopicSubscriber createSubscriber(Topic topic, String messageSelector, boolean noLocal) throws JMSException { checkClosed(); if (topic instanceof CustomDestination) { CustomDestination customDestination = (CustomDestination) topic; return customDestination.createSubscriber(this, messageSelector, noLocal); } ActiveMQPrefetchPolicy prefetchPolicy = this.connection.getPrefetchPolicy(); return new ActiveMQTopicSubscriber(this, getNextConsumerId(), ActiveMQMessageTransformation .transformDestination(topic), null, messageSelector, prefetchPolicy.getTopicPrefetch(), prefetchPolicy.getMaximumPendingMessageLimit(), noLocal, false, asyncDispatch); }	Creates a nondurable subscriber to the specified topic, using a message selector or specifying whether messages published by its own connection should be delivered to it.	0	1
"public synchronized static String hashPassword(long accountId, String password) { try { return sha1Hash(getBytes(""FX-SALT"" + accountId + password)); } catch (NoSuchAlgorithmException e) { throw new FxCreateException(""Failed to load the SHA1 algorithm."").asRuntimeException(); } }"	Hashes a password, making it almost impossible to read it.	1	0
public WebDriver frame(final String nameOrIdOrIndex) { try { // 1.) try to find frame in current window ... currentWindow = findFrame(currentWindow, nameOrIdOrIndex); } catch (NoSuchFrameException ignored) { // 2.) try to find frame in top window ... final WebWindow topWindow = currentWindow.getTopWindow(); currentWindow = findFrame(topWindow, nameOrIdOrIndex); } return HtmlUnitDriver.this; }	Switches to a given frame according to name or numeric ID.	0	1
public VariableInspector variableInspector() { return inspector; }	Access variable inspector window.	0	1
public Hashtable getBuiltInTypes() { return (Hashtable)fBuiltInTypes.clone(); }	get all built-in DVs, which are stored in a Map keyed by the name	1	0
"public static String versionName() { return ""1.0.3""; }"	Get version name of NoHttp.	0	1
public ArrayList getLinkHRefs() { return this.link_href; }	DOCUMENT ME!	1	0
protected String determineValueColumnName(Properties params, Dialect dialect) { ObjectNameNormalizer normalizer = ( ObjectNameNormalizer ) params.get( IDENTIFIER_NORMALIZER ); String name = PropertiesHelper.getString( VALUE_COLUMN_PARAM, params, DEF_VALUE_COLUMN ); return dialect.quote( normalizer.normalizeIdentifierQuoting( name ) ); }	Determine the name of the column used to store the generator value in the db.	0	1
private static CoreMap fromProto(CoreNLPProtos.Sentence proto) { CoreMap sentence = new ArrayCoreMap(); // Required fields sentence.set(TokenBeginAnnotation.class, proto.getTokenOffsetBegin()); sentence.set(TokenEndAnnotation.class, proto.getTokenOffsetEnd()); // Optional fields if (proto.hasSentenceIndex()) { sentence.set(SentenceIndexAnnotation.class, proto.getSentenceIndex()); } if (proto.hasCharacterOffsetBegin()) { sentence.set(CharacterOffsetBeginAnnotation.class, proto.getCharacterOffsetBegin()); } if (proto.hasCharacterOffsetEnd()) { sentence.set(CharacterOffsetEndAnnotation.class, proto.getCharacterOffsetEnd()); } if (proto.hasParseTree()) { sentence.set(TreeAnnotation.class, fromProto(proto.getParseTree())); } // Non-default fields if (proto.hasHasRelationAnnotations() && proto.getHasRelationAnnotations()) { // set entities List<EntityMention> entities = new ArrayList<EntityMention>(); for (CoreNLPProtos.Entity entity : proto.getEntityList()) { entities.add(fromProto(entity, sentence)); } sentence.set(EntityMentionsAnnotation.class, entities); // set relations List<RelationMention> relations = new ArrayList<RelationMention>(); for (CoreNLPProtos.Relation relation : proto.getRelationList()) { relations.add(fromProto(relation, sentence)); } sentence.set(RelationMentionsAnnotation.class, relations); } // Return return sentence; }	Create a CoreLabel from its serialized counterpart.	1	0
"InputStream openSourceFile(String path) throws IOException { if (path.startsWith(""gen/"")) { // generated file? String rest = path.substring(""gen/"".length()); File fileInGenDir = new File(getGenDir(), rest); if (!fileInGenDir.isFile()) { return null; } return new BufferedInputStream(new FileInputStream(fileInGenDir)); } else { // regular source file? URL resource = recompiler.getResourceLoader().getResource(path); if (resource == null) { return null; } return resource.openStream(); } }"	Finds a source file (or other resource) in this module's source path.	1	0
public byte get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }	Analogous to #get(WithAttributes) except returning a primitive byte.	1	0
"public Chronology getChronology(Object object, DateTimeZone zone) { if (object.getClass().getName().endsWith("".BuddhistCalendar"")) { return BuddhistChronology.getInstance(zone); } else if (object instanceof GregorianCalendar) { GregorianCalendar gc = (GregorianCalendar) object; long cutover = gc.getGregorianChange().getTime(); if (cutover == Long.MIN_VALUE) { return GregorianChronology.getInstance(zone); } else if (cutover == Long.MAX_VALUE) { return JulianChronology.getInstance(zone); } else { return GJChronology.getInstance(zone, cutover, 4); } } else { return ISOChronology.getInstance(zone); } }"	Gets the chronology, which is the GJChronology if a GregorianCalendar is used,	0	1
"public static TsurgeonPattern parseOperation(String operationString) { try { TsurgeonParser parser = new TsurgeonParser(new StringReader(operationString + ""\n"")); return new TsurgeonPatternRoot(new TsurgeonPattern[] {parser.Root()} ); } catch(ParseException e) { throw new TsurgeonParseException(""Error parsing Tsurgeon expression: "" + operationString, e); } catch(TokenMgrError e) { throw new TsurgeonParseException(""Error parsing Tsurgeon expression: "" + operationString, e); } }"	Parses an operation string into a TsurgeonPattern.	0	1
@Override public Object put(Object value) { return put(value, false); }	encode = true	1	0
public CloseableHttpClient build(String name) { final CloseableHttpClient client = buildWithDefaultRequestConfiguration(name).getClient(); // If the environment is present, we tie the client with the server lifecycle if (environment != null) { environment.lifecycle().manage(new Managed() { @Override public void start() throws Exception { } @Override public void stop() throws Exception { client.close(); } }); } return client; }	Builds the HttpClient.	0	1
public boolean useFollowOnLocking() { return useFollowOnLocking( null ); }	Some dialects have trouble applying pessimistic locking depending upon what other query options are specified (paging, ordering, etc).	0	1
public int getRowStatus(int aRow) throws IndexOutOfBoundsException { RowData row = this.getRow(aRow); if (row.isNew()) { return RowData.NEW; } else if (row.isModified()) { return RowData.MODIFIED; } else { return RowData.NOT_MODIFIED; } }	Return the status object for the given row.	1	0
public static EBoolean like(Expr<String> left, String right) { return operationFactory.createBoolean(Ops.LIKE, left, exprFactory.createConstant(right)); }	Expr : left like right	0	1
public File getGeneratedOutput() throws CurnException { return null; }	Get an InputStream that can be used to read the output data produced by the handler, if applicable.	1	0
public HBaseResponse getHTableInfo(String tableName) throws IOException { Configuration hconf = HadoopUtil.getCurrentHBaseConfiguration(); HTable table = null; HBaseResponse hr = null; long tableSize = 0; int regionCount = 0; try { table = new HTable(hconf, tableName); HBaseRegionSizeCalculator cal = new HBaseRegionSizeCalculator(table); Map<byte[], Long> sizeMap = cal.getRegionSizeMap(); for (long s : sizeMap.values()) { tableSize += s; } regionCount = sizeMap.size(); // Set response. hr = new HBaseResponse(); hr.setTableSize(tableSize); hr.setRegionCount(regionCount); } finally { if (null != table) { table.close(); } } return hr; }	Calculate size of each region for given table and other info of the table.	0	1
public ReporterData getSingleData(Xref idc) { List<ReporterData> dlist = data.get(idc); if(dlist != null && dlist.size() > 0) return dlist.get(0); return null; }	Get the first Data instance of the cached data for this gene-product.	1	0
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 8: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 48: break; case 19: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 49: break; case 45: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; // try to work around an apparent jflex bug where it // gets a space at the token end by getting // wrong the length of the trailing context. while (yylength() > 0) { char last = yycharat(yylength()-1); if (last == ' ' || last == '\t' || (last >= '\n' && last <= '\r' || last == '\u0085')) { yypushback(1); } else { break; } } if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 50: break; case 15: { return handleQuotes(yytext(), false); } case 51: break; case 30: // lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), false); } case 52: break; case 42: // lookahead expression with fixed lookahead length yypushback(1); { return getNormalizedAmpNext(); } case 53: break; case 29: { return getNormalizedAmpNext(); } case 54: break; case 46: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 4; { return getNext(); } case 55: break; case 40: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 3; { return getNext(); } case 56: break; case 37: // lookahead expression with fixed lookahead length yypushback(2); { return getNext(); } case 57: break; case 4: { return getNext(); } case 58: break; case 21: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(); } case 59: break; case 34: // general lookahead, find correct zzMarkedPos { int zzFState = 11; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 12; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 60: break; case 35: // general lookahead, find correct zzMarkedPos { int zzFState = 13; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 12; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 61: break; case 44: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } return getNext(txt, yytext()); } case 62: break; case 47: { String txt = yytext(); if (normalizeSpace) { txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 63: break; case 6: { if (normalizeOtherBrackets) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 64: break; case 7: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 65: break; case 27: // general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 66: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 67: break; case 41: { yypushback(2) ; return getNext(); } case 68: break; case 32: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space } return getNext(txt, yytext()); } case 69: break; case 24: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 70: break; case 18: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 71: break; case 43: { yypushback(3) ; return getNext(); } case 72: break; case 22: // lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), true); } case 73: break; case 2: { if (normalizeOtherBrackets) { return getNext(openparen, yytext()); } else { return getNext(); } } case 74: break; case 23: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space } return getNext(txt, origTxt); } case 75: break; case 33: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 76: break; case 20: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 77: break; case 17: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 78: break; case 11: { return handleEllipsis(yytext()); } case 79: break; case 31: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 1; { /* invert quote - often but not always right */ return handleQuotes(yytext(), true); } case 80: break; case 13: { return normalizeFractions(yytext()); } case 81: break; case 14: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(); } } case 82: break; case 38: // general lookahead, find correct zzMarkedPos { int zzFState = 9; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 10; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 83: break; case 10: { if (invertible) { prevWordAfter.append(yytext()); } } case 84: break; case 3: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 85: break; case 39: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 86: break; case 12: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 87: break; case 26: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 88: break; case 9: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 89: break; case 28: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 90: break; case 25: { // this one should only match if we're basically at the end of file // since the last one matches two things, even newlines String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 91: break; case 1: { String str = yytext(); int first = str.charAt(0); String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } LOGGER.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: LOGGER.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 92: break; case 36: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 93: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 94: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(AfterAnnotation.class, str); } return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }"	Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.	0	1
public Set<String> getKeySet() throws CoreException { return DBProperty.getKeySet(db, index); }	Returns a Set of property names (Strings) stored in this object	1	0
public Map<String, String> populateImplicitColumns(String filePath, List<String> partitionValues, boolean includeFileImplicitColumns) { Map<String, String> implicitValues = new LinkedHashMap<>(); for (int i = 0; i < partitionValues.size(); i++) { if (isStarQuery || selectedPartitionColumns.contains(i)) { implicitValues.put(partitionDesignator + i, partitionValues.get(i)); } } if (includeFileImplicitColumns) { Path path = Path.getPathWithoutSchemeAndAuthority(new Path(filePath)); for (Map.Entry<String, ImplicitFileColumns> entry : selectedImplicitColumns.entrySet()) { implicitValues.put(entry.getKey(), entry.getValue().getValue(path)); } } return implicitValues; }	Compares selection root and actual file path to determine partition columns values.	1	0
public Date toDate() { int dom = getDayOfMonth(); Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom, getHourOfDay(), getMinuteOfHour(), getSecondOfMinute()); date.setTime(date.getTime() + getMillisOfSecond()); return correctDstTransition(date, TimeZone.getDefault()); }	Get the date time as a java.util.Date.	0	1
"public String escapeReservedWord(String name) { if(this.reservedWordsMappings().containsKey(name)) { return this.reservedWordsMappings().get(name); } return ""_"" + name; }"	Escapes a reserved word as defined in the `reservedWords` array.	0	1
public ArrayList getAHRefs() { return this.a_href; }	DOCUMENT ME!	1	0
"public static double interp(int scale, double val, double dist[]) { switch ( scale ) { case Constants.LINEAR_SCALE: return linearInterp(val, dist[0], dist[dist.length-1]); case Constants.LOG_SCALE: return logInterp(val, dist[0], dist[dist.length-1]); case Constants.SQRT_SCALE: return sqrtInterp(val, dist[0], dist[dist.length-1]); case Constants.QUANTILE_SCALE: return quantile(val, dist); } throw new IllegalArgumentException(""Unrecognized scale value: ""+scale); }"	Interpolates a value between a given minimum and maximum value using a specified scale.	1	0
public EditText getEditText(String text) { return getter.getView(EditText.class, text, false); }	Returns an EditText which shows a given text.	0	1
@Override public Refactoring getParent() { return this.parent; }	Gets the EmfRefactoring supported by the controller.	1	0
public boolean needCache() { return RequestMethod.GET == getRequestMethod(); }	Randomly generated boundary mark	0	1
"public static MatchFinder allOf(final MatchFinder... finders) { return new MatchFinder() { @Override public boolean matches(UiElement element) { for (MatchFinder finder : finders) { if (!finder.matches(element)) { return false; } } return true; } @Override public String toString() { return ""allOf("" + Joiner.on("","").join(finders) + "")""; } }; }"	Evaluates given @matchers in short-circuit fashion in the order they are passed.	1	0
"public B usingPort(int port) { checkArgument(port >= 0, ""Invalid port number: %d"", port); this.port = port; return (B) this; }"	Sets which port the driver server should be started on.	0	1
"@SuppressWarnings(""static-access"") public ObjectName getQueueObjectName(String virtualHostName, String queue) { // Get the name of the test manager AllObjects allObject = new AllObjects(_mbsc); allObject.querystring = ""org.apache.qpid:type=VirtualHost.Queue,VirtualHost="" + virtualHostName + "",name="" + queue + "",*""; Set<ObjectName> objectNames = allObject.returnObjects(); _test.assertNotNull(""Null ObjectName Set returned"", objectNames); _test.assertEquals(""Incorrect number of queues with name '"" + allObject.querystring + ""' returned"", 1, objectNames.size()); // We have verified we have only one value in objectNames so return it ObjectName objectName = objectNames.iterator().next(); _test.getLogger().info(""Loading: "" + objectName); return objectName; }"	Retrive the ObjectName for the given Exchange on the test Virtualhost.	1	0
"public List<CodegenSecurity> fromSecurity(Map<String, SecurityScheme> securitySchemeMap) { if (securitySchemeMap == null) { return Collections.emptyList(); } List<CodegenSecurity> codegenSecurities = new ArrayList<CodegenSecurity>(securitySchemeMap.size()); for (String key : securitySchemeMap.keySet()) { final SecurityScheme securityScheme = securitySchemeMap.get(key); CodegenSecurity cs = CodegenModelFactory.newInstance(CodegenModelType.SECURITY); cs.name = key; cs.type = securityScheme.getType().toString(); cs.isCode = cs.isPassword = cs.isApplication = cs.isImplicit = false; if (SecurityScheme.Type.APIKEY.equals(securityScheme.getType())) { cs.isBasic = cs.isOAuth = false; cs.isApiKey = true; cs.keyParamName = securityScheme.getName(); cs.isKeyInHeader = securityScheme.getIn() == SecurityScheme.In.HEADER; cs.isKeyInQuery = !cs.isKeyInHeader; } else if (SecurityScheme.Type.HTTP.equals(securityScheme.getType())) { cs.isKeyInHeader = cs.isKeyInQuery = cs.isApiKey = cs.isOAuth = false; cs.isBasic = true; } else if (SecurityScheme.Type.OAUTH2.equals(securityScheme.getType())) { cs.isKeyInHeader = cs.isKeyInQuery = cs.isApiKey = cs.isBasic = false; cs.isOAuth = true; final OAuthFlows flows = securityScheme.getFlows(); if (securityScheme.getFlows() == null) { throw new RuntimeException(""missing oauth flow in "" + cs.name); } if (flows.getPassword() != null) { setOauth2Info(cs, flows.getPassword()); cs.isPassword = true; cs.flow = ""password""; } else if (flows.getImplicit() != null) { setOauth2Info(cs, flows.getImplicit()); cs.isImplicit = true; cs.flow = ""implicit""; } else if (flows.getClientCredentials() != null) { setOauth2Info(cs, flows.getClientCredentials()); cs.isApplication = true; cs.flow = ""application""; } else if (flows.getAuthorizationCode() != null) { setOauth2Info(cs, flows.getAuthorizationCode()); cs.isCode = true; cs.flow = ""accessCode""; } else { throw new RuntimeException(""Could not identify any oauth2 flow in "" + cs.name); } } codegenSecurities.add(cs); } // sort auth methods to maintain the same order Collections.sort(codegenSecurities, new Comparator<CodegenSecurity>() { @Override public int compare(CodegenSecurity one, CodegenSecurity another) { return ObjectUtils.compare(one.name, another.name); } }); // set 'hasMore' Iterator<CodegenSecurity> it = codegenSecurities.iterator(); while (it.hasNext()) { final CodegenSecurity security = it.next(); security.hasMore = it.hasNext(); } return codegenSecurities; }"	Convert map of Swagger SecuritySchemeDefinition objects to a list of Codegen Security objects	1	0
static public IStructuredTextExpert getStatefulExpert(String type) { return getStatefulExpert(type, StructuredTextEnvironment.DEFAULT); }	Obtains a ISTextExpert instance for processing structured text with the specified type handler.	1	0
public FieldSelector build() { List<Path> result = new ArrayList<>(); parse(fullyQualifiedFieldNames, name -> { String[] nameNodes = parseIntoParts(name, name, length -> length < 3, DOT); return new RemovePath(selectNamespacePartAsPattern(nameNodes), selectFieldPartAsNodes(nameNodes)); }, result); parse(fullyQualifiedFieldReplacements, name -> { String[] replacement = parseIntoParts(name, name, length -> length != 2, COLON); String[] nameNodes = parseIntoParts(name, replacement[0], length -> length < 3, DOT); return new RenamePath(selectNamespacePartAsPattern(nameNodes), selectFieldPartAsNodes(nameNodes), replacement[1]); }, result); return new FieldSelector(result); }	Builds the filter selector that returns the field filter for a given collection identifier, using the comma-separated list of fully-qualified field names (for details, see MongoDbConnectorConfig#FIELD_BLACKLIST) defining which fields (if any) should be excluded, and using the comma-separated list of fully-qualified field replacements (for details, see MongoDbConnectorConfig#FIELD_RENAMES) defining which fields (if any) should be renamed.	0	1
public static Tree UCPtransform(Tree t) { if (t == null) { return null; } Tree firstChild = t.firstChild(); if (firstChild != null) { List<Pair<TregexPattern,TsurgeonPattern>> ops = Generics.newArrayList(); for (int i = 0; i < operations.length; i++) { for (TregexPattern pattern : matchPatterns[i]) { ops.add(Generics.newPair(pattern, operations[i])); } } return Tsurgeon.processPatternsOnTree(ops, t); } else { return t; } }	Transforms t if it contains an UCP, it will change the UCP tag into the phrasal tag of the first word of the UCP (UCP (JJ electronic) (, ,) (NN computer) (CC and) (NN building)) will become (ADJP (JJ electronic) (, ,) (NN computer) (CC and) (NN building))	0	1
Class[] getServiceClasses( final Class type, final List issues ) { final ServiceDescriptorSet set = (ServiceDescriptorSet)type.getAnnotation( ServiceDescriptorSet.class ); if( null != set ) { final ServiceDescriptor[] descriptors = set.value(); final Class[] services = new Class[descriptors.length]; for( int i = 0; i < descriptors.length; i++ ) { ServiceDescriptor descriptor = descriptors[i]; services[i] = descriptor.type(); } return services; } else { return new Class[0]; } }	Retrieve an array of Classes for all the services that a Component offers.	1	0
List<ExtensionState> getExtensions() { return extensions; }	Gets the extensions' state (as saved in the configuration file).	0	1
public Dictionary getProperties() { return m_properties; }	Returns the property descriptors	1	0
"private int getIconResId() { JSONObject settings = BackgroundMode.getSettings(); Context context = getApplicationContext(); Resources res = context.getResources(); String pkgName = context.getPackageName(); String icon = settings.optString(""icon"", ""icon""); int resId = res.getIdentifier(icon, ""drawable"", pkgName); if (resId == 0) { resId = res.getIdentifier(""icon"", ""drawable"", pkgName); } return resId; }"	Retrieves the resource ID of the app icon.	0	1
public String getAuthoringPath() { return this.authoringPath; }	DOCUMENT ME!	1	0
"private String buildAddVideoSdpProposal() { if (logger.isActivated()) { logger.debug(""Build SDP proposal to add video stream in the session""); } try { // Build SDP part String ntpTime = SipUtils.constructNTPtime(System.currentTimeMillis()); String ipAddress = getDialogPath().getSipStack().getLocalIpAddress(); getAudioPlayer().getLocalRtpPort(); String audioSdp = AudioSdpBuilder.buildSdpOffer(getAudioPlayer().getSupportedAudioCodecs(), getAudioPlayer().getLocalRtpPort()); String videoSdp; videoSdp = VideoSdpBuilder.buildSdpOfferWithOrientation( getVideoPlayer().getSupportedVideoCodecs(), getVideoPlayer().getLocalRtpPort()); return ""v=0"" + SipUtils.CRLF + ""o=- "" + ntpTime + "" "" + ntpTime + "" "" + SdpUtils.formatAddressType(ipAddress) + SipUtils.CRLF + ""s=-"" + SipUtils.CRLF + ""c="" + SdpUtils.formatAddressType(ipAddress) + SipUtils.CRLF + ""t=0 0"" + SipUtils.CRLF + audioSdp + ""a=sendrcv"" + SipUtils.CRLF + videoSdp + ""a=sendrcv"" + SipUtils.CRLF; } catch (RemoteException e) { if (logger.isActivated()) { logger.error(""Add video has failed"", e); } // Unexpected error handleError(new IPCallError(IPCallError.UNEXPECTED_EXCEPTION, e.getMessage())); return null; } }"	Build sdp proposal for addVideo	1	0
public static DurationFieldType hours() { return HOURS_TYPE; }	Get the hours field type.	0	1
protected static Serializable deserializeTime(ByteArrayInputStream inputStream) throws IOException { // Times are stored as an integer as `HHMMSS`, so we need to split out the digits ... int value = inputStream.readInteger(3); int[] split = split(value, 100, 3); int hours = split[2]; int minutes = split[1]; int seconds = split[0]; return Duration.ofHours(hours).plusMinutes(minutes).plusSeconds(seconds); }	Converts a MySQL TIME value without fractional seconds to a LocalTime.	1	0
public RelOptCost getNonCumulativeCost(RelNode rel) { for (;;) { try { return nonCumulativeCostHandler.getNonCumulativeCost(rel, this); } catch (JaninoRelMetadataProvider.NoHandler e) { nonCumulativeCostHandler = metadataProvider.revise(e.relClass, BuiltInMetadata.NonCumulativeCost.DEF); } } }	Returns the BuiltInMetadata.NonCumulativeCost#getNonCumulativeCost() statistic.	0	1
"private BigDecimal getCurrentCostPriceLL(MPPProductBOM bom, MCostElement element) { log.info(""ElementType: ""+ element.getCostElementType()); BigDecimal costPriceLL = Env.ZERO; if(bom == null) return costPriceLL; for (MPPProductBOMLine bomline : bom.getLines()) { MProduct component = MProduct.get(getCtx(), bomline.getM_Product_ID()); // get the rate for this resource for (MCost cost : getCosts(component, element.getCostElementType())) { BigDecimal qtyPercentage = bomline.getQtyBatch().divide(Env.ONEHUNDRED, 8, BigDecimal.ROUND_UP); BigDecimal qtyBOM = bomline.getQtyBOM(); BigDecimal scrapDec = bomline.getScrap().divide(Env.ONEHUNDRED, 4, BigDecimal.ROUND_UP); BigDecimal qtyTotal = Env.ZERO; if (bomline.isQtyPercentage()) { qtyTotal = qtyPercentage.divide(Env.ONE.subtract(scrapDec), 4, BigDecimal.ROUND_HALF_UP); } else { qtyTotal = qtyBOM.divide(Env.ONE.subtract(scrapDec), 4, BigDecimal.ROUND_HALF_UP); } BigDecimal costPrice = cost.getCurrentCostPrice().add(cost.getCurrentCostPriceLL()); costPriceLL = costPriceLL.add(costPrice.multiply(qtyTotal)); log.info(""Cost Element:""+element.getName() + "", Total Cost Element: "" + costPriceLL + "", QtyPercentage: "" + qtyPercentage + "", QtyBOM: "" + qtyBOM); } // for each cost } // for each BOM line return costPriceLL; }"	get the sum Current Cost Price Level Low for this Cost Element Type	1	0
"protected static String getTargetText(Target target) { if (target != null) { if (target.getStartNode() != null) { return getNodeText(target.getStartNode()); } else if (target.getContext() != null) { return Constant.messages.getString(""context.prefixName"", target.getContext().getName()); } else if (target.isInScopeOnly()) { return Constant.messages.getString(""context.allInScope""); } } return null; }"	Returns the text representation of the given target.	0	1
public VisualItem findItem(Point p) { Point2D p2 = (m_itransform==null ? p : m_itransform.transform(p, m_tmpPoint)); synchronized (m_registry) { Iterator items = m_registry.getItemsReversed(); while (items.hasNext()) { VisualItem vi = (VisualItem) items.next(); Renderer r = vi.getRenderer(); if (r != null && r.locatePoint(p2, vi)) { return vi; } } } return null; } //	Returns the GraphItem located at the given point.	1	0
public short get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }	Analogous to #get(WithAttributes) except returning a primitive short.	1	0
public boolean isConnected(Integer channelId) { synchronized (wsProxies) { if (wsProxies.containsKey(channelId)) { return wsProxies.get(channelId).isConnected(); } } return false; }	Returns true if the WebSocket connection that followed the given	1	0
"private String prepareQueryString(String groupPath, String jobName, Properties options) { List<NameValuePair> parameters = new ArrayList<NameValuePair>(); parameters.add(new BasicNameValuePair(""groupPath"", groupPath)); parameters.add(new BasicNameValuePair(""jobName"", jobName)); if (options != null) { for (Entry<Object, Object> option : options.entrySet()) { parameters.add(new BasicNameValuePair(""extra.command.option."" + option.getKey(), String.valueOf(option.getValue()))); } } return URLEncodedUtils.format(parameters, HTTP.UTF_8); }"	prepare the HttpClient's queryString containing the group/job and the options.	1	0
protected Iterable<Object> toIterable(Object result) { return FpKit.toCollection(result); }	Converts an object that is known to should be an Iterable into one	0	1
public Type getPhysical() { return physical; }	Returns the physical class used by the runtime.	1	0
public Insets getBorderInsets(Component c) { return new Insets(0, 0, 0, 0); }	This default implementation returns a new Insets object that is initialized by the #getBorderInsets(Component,Insets) method.	1	0
"public boolean scroll(int direction, boolean allTheWay) { final ArrayList<View> viewList = RobotiumUtils. removeInvisibleViews(viewFetcher.getAllViews(true)); @SuppressWarnings(""unchecked"") ArrayList<View> views = RobotiumUtils.filterViewsToSet(new Class[] { ListView.class, ScrollView.class, GridView.class, WebView.class}, viewList); View view = viewFetcher.getFreshestView(views); if (view == null) { view = getRecyclerView(viewList); if(view == null){ return false; } } if (view instanceof AbsListView) { return scrollList((AbsListView)view, direction, allTheWay); } if(view instanceof WebView){ return scrollWebView((WebView)view, direction, allTheWay); } if (allTheWay) { scrollViewAllTheWay(view, direction); return false; } else { return scrollView(view, direction); } }"	Scrolls up and down.	0	1
public static boolean isVisibleInExplain(RelNode rel, SqlExplainLevel explainLevel) { final BuiltInMetadata.ExplainVisibility metadata = rel.metadata(BuiltInMetadata.ExplainVisibility.class); Boolean b = metadata.isVisibleInExplain(explainLevel); return b == null || b; }	Determines whether a relational expression should be visible in EXPLAIN	1	0
boolean findCellForSpan(int[] cellXY, int spanX, int spanY) { // return the span represented by the CellInfo only there is no view there // (this.cell == null) and there is enough space if (this.cell == null && this.spanX >= spanX && this.spanY >= spanY) { if (cellXY != null) { cellXY[0] = cellX; cellXY[1] = cellY; } return true; } int startX = 0; if (intersectX >= 0) { startX = Math.max(startX, intersectX - (spanX - 1)); } int endX = mCountX - (spanX - 1); if (intersectX >= 0) { endX = Math.min(endX, intersectX + (spanX - 1)); } int startY = 0; if (intersectY >= 0) { startY = Math.max(startY, intersectY - (spanY - 1)); } int endY = mCountY - (spanY - 1); if (intersectY >= 0) { endY = Math.min(endY, intersectY + (spanY - 1)); } for (int x = startX; x < endX + 1; x++) { inner: for (int y = startY; y < endY; y++) { for (int i = 0; i < spanX; i++) { for (int j = 0; j < spanY; j++) { if (mOccupied[x + i][y + j]) { // small optimization: we can skip to below the row we just found // an occupied cell y += j; continue inner; } } } if (cellXY != null) { cellXY[0] = x; cellXY[1] = y; } return true; } } return false; }	This method can be called only once! Calling #findVacantCellsFromOccupied will restore the ability to call this method.	1	0
public SQLInsertClause populate(Object bean) { return populate(bean, DefaultMapper.DEFAULT); }	Populate the INSERT clause with the properties of the given bean.	0	1
public final File getGeneratedOutput() throws CurnException { return hasGeneratedOutput() ? outputFile : null; }	Get an InputStream that can be used to read the output data produced by the handler, if applicable.	1	0
public boolean available() { return 0 < glTextureID; }	Returns true if the texture has been initialized.	0	1
private int updateRedundancy() { int desiredRedundancy = this.pRegion.getRedundantCopies(); int numBucketHosts = getNumInitializedBuckets(); if (isClosed()) { return numBucketHosts; } int actualRedundancy = numBucketHosts - 1; this.redundancy = actualRedundancy; if (this.redundancySatisfied && numBucketHosts > 0 && actualRedundancy < desiredRedundancy) { incLowRedundancyBucketCount(1); this.redundancySatisfied = false; } else if (!this.redundancySatisfied && numBucketHosts > 0 && actualRedundancy >= desiredRedundancy) { incLowRedundancyBucketCount(-1); this.redundancySatisfied = true; this.redundancyEverSatisfied = true; } return numBucketHosts; }	Get the current number of bucket hosts and update the redundancy statistics for the region	1	0
public static AnnotationMirror getAnnotationMirror(Element element, String fqcn) { assert element != null; assert fqcn != null; AnnotationMirror mirror = null; for ( AnnotationMirror am : element.getAnnotationMirrors() ) { if ( isAnnotationMirrorOfType( am, fqcn ) ) { mirror = am; break; } } return mirror; }	Checks whether the Element hosts an annotation of the specified class.	1	0
private static String literalValue(RexLiteral literal) { Object value = literal.getValue2(); return String.valueOf(value); }	Convert the value of a literal to a string.	0	1
public User getOwner() { return owner; }	Gets the Person that owns the page	1	0
"private Expression translate0(RexNode expr, RexImpTable.NullAs nullAs) { if (nullAs == RexImpTable.NullAs.NULL && !expr.getType().isNullable()) { nullAs = RexImpTable.NullAs.NOT_POSSIBLE; } switch (expr.getKind()) { case INPUT_REF: final int index = ((RexInputRef) expr).getIndex(); Expression x = inputGetter.field(list, index); return list.append( ""v"", nullAs.handle( list.append(""v"", x))); case LOCAL_REF: return translate( program.getExprList().get(((RexLocalRef) expr).getIndex()), nullAs); case LITERAL: return translateLiteral( expr, nullifyType( expr.getType(), isNullable(expr) && nullAs != RexImpTable.NullAs.NOT_POSSIBLE), typeFactory, nullAs); case DYNAMIC_PARAM: return translateParameter((RexDynamicParam) expr, nullAs); default: if (expr instanceof RexCall) { return translateCall((RexCall) expr, nullAs); } throw new RuntimeException( ""cannot translate expression "" + expr); } }"	Translates an expression that is not in the cache.	0	1
public ApiResponse<String> loginUserWithHttpInfo(String username, String password) throws ApiException { okhttp3.Call localVarCall = loginUserValidateBeforeCall(username, password, null, null); Type localVarReturnType = new TypeToken<String>(){}.getType(); return localVarApiClient.execute(localVarCall, localVarReturnType); }	Logs user into the system	0	1
public static SlantType getSlant(World world, Vector3 position) { TileEntity t = position.getTileEntity(world); if (t != null) { if (t instanceof TileEntityConveyorBelt) { TileEntityConveyorBelt tileEntity = (TileEntityConveyorBelt) t; Vector3 frontCheck = position.clone(); frontCheck.modifyPositionFromSide(tileEntity.getDirection()); Vector3 backCheck = position.clone(); backCheck.modifyPositionFromSide(tileEntity.getDirection().getOpposite()); if (Vector3.add(frontCheck, new Vector3(0, 1, 0)).getBlockID(world) == AssemblyLine.blockConveyorBelt.blockID && Vector3.add(backCheck, new Vector3(0, -1, 0)).getBlockID(world) == AssemblyLine.blockConveyorBelt.blockID) { return SlantType.UP; } else if (Vector3.add(frontCheck, new Vector3(0, -1, 0)).getBlockID(world) == AssemblyLine.blockConveyorBelt.blockID && Vector3.add(backCheck, new Vector3(0, 1, 0)).getBlockID(world) == AssemblyLine.blockConveyorBelt.blockID) { return SlantType.DOWN; } } } return null; }	Is this conveyor belt slanted towards a direction?	1	0
"public AnsiClazzes processCode(String code) { if (code == null || code.length() < 2) return null; if (code.charAt(0) != '\033' && code.charAt(code.length() - 1) != 'm') return null; if (code.length() == 2) { clazzes_.clear(); // CSIm is equivalent to CSI0m, which is 'reset' blockClazzes_.clear(); return null; } int extendedColor = 0; boolean extendedMarkerSeen = false; boolean extendedRGBMarkerSeen = false; int extendedRGBColorsSeen = 0; String[] tokens = code.substring(2, code.length() - 1).split("";""); for (String token : tokens) { int codeVal = StringUtil.parseInt(token, -1); if (codeVal == -1) continue; if (extendedColor > 0) { if (!extendedMarkerSeen && !extendedRGBMarkerSeen) { if (codeVal == EXT_BY_INDEX) { extendedMarkerSeen = true; continue; } else if (codeVal == EXT_BY_RGB) { extendedRGBMarkerSeen = true; extendedRGBColorsSeen = 0; } else { // unknown extended color format; hard to recover so // just reset back to defaults and return clazzes_.clear(); blockClazzes_.clear(); return null; } } else { // We don't support colors specified via RGB, but parse the // sequence then ignore it in case there are supported // sequences after it if (extendedRGBMarkerSeen) { extendedRGBColorsSeen++; if (extendedRGBColorsSeen == 3 /*red, green, blue*/) { extendedColor = 0; extendedRGBMarkerSeen = false; extendedRGBColorsSeen = 0; } } else { if (extendedColor == FOREGROUND_EXT) { if (codeVal >= 0 && codeVal <= 255) { currentColor_.setExtended(codeVal); resetForeground(); clazzes_.add(Color.clazzForColorIndex(codeVal, false /*background*/)); } } else { if (codeVal >= 0 && codeVal <= 255) { currentBgColor_.setExtended(codeVal); resetBackground(); clazzes_.add(Color.clazzForColorIndex(codeVal, true /*background*/)); } } extendedColor = 0; extendedMarkerSeen = false; } } } else if (codeVal == RESET) { inverted_ = false; currentColor_.reset(); currentBgColor_.reset(); clazzes_.clear(); blockClazzes_.clear(); } else if (codeVal == BOLD) { clazzes_.add(BOLD_STYLE); } else if (codeVal == BLURRED) { // NYI clazzes_.add(BLURRED_STYLE); } else if (codeVal == BOLD_BLURRED_OFF) { clazzes_.remove(BOLD_STYLE); // NYI clazzes_.remove(BLURRED_STYLE); } else if (codeVal == ITALIC) { clazzes_.add(ITALIC_STYLE); } else if (codeVal == ITALIC_OFF) { clazzes_.remove(ITALIC_STYLE); } else if (codeVal == UNDERLINE) { clazzes_.add(UNDERLINE_STYLE); } else if (codeVal == UNDERLINE_OFF) { clazzes_.remove(UNDERLINE_STYLE); } else if (codeVal == BLINKSLOW || codeVal == BLINKFAST) { clazzes_.add(BLINK_STYLE); } else if (codeVal == BLINK_OFF) { clazzes_.remove(BLINK_STYLE); } else if (codeVal == INVERSE) { if (!inverted_) { resetForeground(); resetBackground(); Color newFg = invertFgColor(); Color newBg = invertBgColor(); currentColor_ = newFg; currentBgColor_ = newBg; inverted_ = true; } } else if (codeVal == INVERSE_OFF) { if (inverted_) { resetForeground(); resetBackground(); Color newFg = invertFgColor(); Color newBg = invertBgColor(); currentColor_ = newFg; currentBgColor_ = newBg; inverted_ = false; } } else if (codeVal == HIDDEN) { clazzes_.add(HIDDEN_STYLE); } else if (codeVal == HIDDEN_OFF) { clazzes_.remove(HIDDEN_STYLE); } else if (codeVal == STRIKETHROUGH) { clazzes_.add(STRIKETHROUGH_STYLE); } else if (codeVal == STRIKETHROUGH_OFF) { clazzes_.remove(STRIKETHROUGH_STYLE); } else if (Color.isFgColorCode(codeVal)) { currentColor_.setCode(codeVal); resetForeground(); clazzes_.add(clazzForColor(codeVal)); } else if (Color.isBgColorCode(codeVal)) { currentBgColor_ = new Color(false, codeVal); resetBackground(); clazzes_.add(clazzForBgColor(codeVal)); } else if (codeVal == RESET_FOREGROUND) { currentColor_.reset(); resetForeground(); } else if (codeVal == RESET_BACKGROUND) { currentBgColor_.reset(); resetBackground(); } else if (codeVal == FOREGROUND_EXT) { extendedColor = codeVal; extendedMarkerSeen = false; } else if (codeVal == BACKGROUND_EXT) { extendedColor = codeVal; extendedMarkerSeen = false; } else if (codeVal == FONT_NINE) { blockClazzes_.add(FONT_NINE_STYLE); } else if (codeVal == DEFAULT_FONT || (codeVal >= FONT_ONE && codeVal <= FONT_EIGHT)) { blockClazzes_.remove(FONT_NINE_STYLE); } else { // ignore all others } } return getStyles(); }"	Map an ANSI escape sequence to the appropriate css styles; only handles colors and visual appearance covered by SGR codes; other sequences such as cursor movement are ignored.	0	1
public final ProviderDescriptor getDescriptor() { return mDescriptor; }	Gets the current route provider descriptor.	1	0
public Float getRightValue() { return rightValue; }	Gets the 'right' CSS-attributes value in specified units.	1	0
protected boolean testSimpleGeometryEquality(Geometry geom1, Geometry geom2) { //return geom1.equals(geom2); return testTypeAndVertexEquality( geom1, geom2 ) && equalSRID( geom1, geom2 ); }	Test whether two geometries, not of type GeometryCollection are equal.	0	1
public List<TestSuite> getSuite() { return this.testSuites; }	Retrieves the parsed Test Suite.	1	0
"public String applyClassNamingPolicy(String input) { if (input != null && input.length() > 0) { if (""string"".equalsIgnoreCase(input)) { return ""string""; } String output = input.substring(0, 1).toUpperCase() + input.substring(1); // class name can't have . so if dot exists remove the same output = output.replace(""."", """"); return output; } else { throw new CodeGenerationException(""Error converting input to first letter caps becuase of null or empty input""); } }"	Converts the first character of the input into upper case .	0	1
public CometSupport defaultCometSupport(final boolean preferBlocking) { if (!preferBlocking && testClassExists(SERVLET_30)) { if (detectWebSocketPresent().size() > 0) { return new Servlet30CometSupportWithWebSocket(config); } return new Servlet30CometSupport(config); } else { return new BlockingIOCometSupport(config); } }	This method is used to determine the default CometSupport if all else fails	0	1
public int compareTo(IndexedWord w) { if (this.equals(IndexedWord.NO_WORD)) { if (w.equals(IndexedWord.NO_WORD)) { return 0; } else { return -1; } } if (w.equals(IndexedWord.NO_WORD)) { return 1; } // Override the default comparator if pseudo-positions are set. // This is needed for splicing trees together awkwardly in OpenIE. if (!Double.isNaN(w.pseudoPosition) || !Double.isNaN(this.pseudoPosition)) { double val = this.pseudoPosition() - w.pseudoPosition(); if (val < 0) { return -1; } if (val > 0) { return 1; } else { return 0; } } // Otherwise, compare using the normal doc/sentence/token index hierarchy String docID = this.getString(CoreAnnotations.DocIDAnnotation.class); int docComp = docID.compareTo(w.getString(CoreAnnotations.DocIDAnnotation.class)); if (docComp != 0) return docComp; int sentComp = Integer.compare(sentIndex(), w.sentIndex()); if (sentComp != 0) return sentComp; int indexComp = Integer.compare(index(), w.index()); if (indexComp != 0) return indexComp; return Integer.compare(copyCount(), w.copyCount()); }	NOTE: This compareTo is based on and made to be compatible with the one from IndexedFeatureLabel.	1	0
private Context getContext(JSONObject params) throws ApiException { return ApiUtils.getContextByName(params, CONTEXT_NAME); }	Returns the Context with the given name.	0	1
"public Object clone() { throw ExceptionUtils.unsupportedInGwt(); // try { // return super.clone(); // } catch (CloneNotSupportedException ex) { // throw new InternalError(""Clone error""); // } }"	Clone this object.	0	1
public static IPath toPath(URI uri) { Assert.isNotNull(uri); if (EFS.SCHEME_FILE.equals(uri.getScheme())) return new Path(uri.getSchemeSpecificPart()); return null; }	Converts a URI to an IPath.	1	0
protected Object convertUnsignedBigint(Column column, Field fieldDefn, Object data){ return convertValue(column, fieldDefn, data, 0L, (r) -> { if (data instanceof BigDecimal) { r.deliver(MySqlUnsignedIntegerConverter.convertUnsignedBigint((BigDecimal)data)); } else if (data instanceof Number) { r.deliver(MySqlUnsignedIntegerConverter.convertUnsignedBigint(new BigDecimal(((Number)data).toString()))); } else if (data instanceof String) { r.deliver(MySqlUnsignedIntegerConverter.convertUnsignedBigint(new BigDecimal((String)data))); } else { r.deliver(convertNumeric(column, fieldDefn, data)); } }); }	Convert the a value representing a Unsigned BIGINT value to the correct Unsigned INT representation.	0	1
public Collection<OsmPrimitive> getSelected() { return Collections.unmodifiableSet(selectedPrimitives); }	Return a list of all selected objects.	1	0
public ArrayList<CheckBox> getCurrentCheckBoxes() { return ensureArrayListOrNull(viewFetcher.getCurrentViews(CheckBox.class)); }	Returns a List of the CheckBoxes contained in the current Activity.	0	1
public String[] createText(MilStd2525TacticalGraphic graphic) { String[] result; String functionId = graphic.getFunctionId(); if (CircularFireSupportArea.FUNCTION_ID_TARGET.equals(functionId)) { result = new String[] { graphic.getText() }; } else { boolean useSeparateTimeLabel = this.isShowSeparateTimeLabel(functionId); String mainText = this.createMainText(graphic, functionId, !useSeparateTimeLabel); if (useSeparateTimeLabel) { String timeText = this.createTimeRangeText(graphic); result = new String[] { mainText, timeText }; } else { result = new String[] { mainText }; } } return result; }	Construct the text for the main label of a graphic.	1	0
public InstrumentationFieldCompleteParameters withNewState(InstrumentationState instrumentationState) { return new InstrumentationFieldCompleteParameters( this.executionContext, executionStrategyParameters, this.fieldDef, this.typeInfo, this.fetchedValue, instrumentationState); }	Returns a cloned parameters object with the new state	0	1
public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws ApiException { return uploadFileWithRequiredFileWithHttpInfo(petId, requiredFile, additionalMetadata).getData(); }	uploads an image (required)	0	1
public Hashtable getBuiltInTypes() { Hashtable toReturn = (Hashtable)fBuiltInTypes.clone(); Enumeration xml11Keys = fXML11BuiltInTypes.keys(); while (xml11Keys.hasMoreElements()) { Object key = xml11Keys.nextElement(); toReturn.put(key, fXML11BuiltInTypes.get(key)); } return toReturn; }	get all built-in DVs, which are stored in a Map keyed by the name	1	0
public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; // set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { return null; } } else { switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { return tokenFactory.makeToken(yytext(), yychar, yylength()); } case 4: break; case 2: { return tokenFactory.makeToken(NEWLINE, yychar, yylength()); } case 5: break; case 3: { } case 6: break; default: zzScanError(ZZ_NO_MATCH); } } } }	Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.	0	1
public final int getEndLine() { return this.bufline[this.bufpos]; }	DOCUMENT ME!	1	0
"public boolean isConnected() { final Health request = new Health.Builder() .local() .timeout(Ints.saturatedCast(requestTimeout.toSeconds())) .build(); final JestResult result = JestUtils.execute(jestClient, request, () -> ""Couldn't check connection status of Elasticsearch""); final int numberOfDataNodes = Optional.of(result.getJsonObject()) .map(json -> asInteger(json.get(""number_of_data_nodes""))) .orElse(0); return numberOfDataNodes > 0; }"	Check if the Elasticsearch org.elasticsearch.node.Node is connected and that there are other nodes in the cluster.	1	0
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 38: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, yytext()); } case 55: break; case 43: // general lookahead, find correct zzMarkedPos { int zzFState = 9; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 10; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { // try to work around an apparent jflex bug where it // gets a space at the token end by getting // wrong the length of the trailing context. while (yylength() > 0) { char last = yycharat(yylength()-1); if (last == ' ' || last == '\t' || (last >= '\n' && last <= '\r' || last == '\u0085')) { yypushback(1); } else { break; } } return getNext(); } case 56: break; case 11: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 57: break; case 19: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 58: break; case 8: { return handleQuotes(yytext(), false); } case 59: break; case 35: // lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), false); } case 60: break; case 27: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 61: break; case 33: // lookahead expression with fixed lookahead length yypushback(1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 62: break; case 49: // lookahead expression with fixed lookahead length yypushback(1); { return getNormalizedAmpNext(); } case 63: break; case 36: { return getNormalizedAmpNext(); } case 64: break; case 23: { if (invertible) { prevWordAfter.append(yytext()); } } case 65: break; case 37: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, yytext()); } case 66: break; case 53: // lookahead expression with fixed lookahead length yypushback(4); { return getNext(); } case 67: break; case 46: // lookahead expression with fixed lookahead length yypushback(2); { return getNext(); } case 68: break; case 42: // general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 69: break; case 41: // general lookahead, find correct zzMarkedPos { int zzFState = 16; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 17; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 70: break; case 40: // general lookahead, find correct zzMarkedPos { int zzFState = 13; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 71: break; case 3: { return getNext(); } case 72: break; case 24: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(); } case 73: break; case 51: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } return getNext(txt, yytext()); } case 74: break; case 26: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, origTxt); } case 75: break; case 6: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 76: break; case 29: // general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 77: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 78: break; case 2: { return getNext(""<"", yytext()); } case 79: break; case 30: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 80: break; case 18: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 81: break; case 54: { String txt = yytext(); if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 82: break; case 50: { yypushback(3) ; return getNext(); } case 83: break; case 25: // lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), true); } case 84: break; case 39: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 85: break; case 21: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 86: break; case 17: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 87: break; case 13: { return handleEllipsis(yytext()); } case 88: break; case 34: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 1; { /* invert quote - often but not always right */ return handleQuotes(yytext(), true); } case 89: break; case 14: { return normalizeFractions(yytext()); } case 90: break; case 15: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(); } } case 91: break; case 47: // general lookahead, find correct zzMarkedPos { int zzFState = 11; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 12; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 92: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 93: break; case 9: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 94: break; case 45: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 95: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 96: break; case 28: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 97: break; case 48: { if (keepAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 98: break; case 20: { if (normalizeOtherBrackets) { return getNext(""-RSB-"", yytext()); } else { return getNext(); } } case 99: break; case 12: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 100: break; case 31: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 101: break; case 10: { return getNext("">"", yytext()); } case 102: break; case 32: { // this one should only match if we're basically at the end of file // since the last one matches two things, even newlines String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 103: break; case 22: { if (normalizeOtherBrackets) { return getNext(""-LSB-"", yytext()); } else { return getNext(); } } case 104: break; case 52: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { // try to work around an apparent jflex bug where it // gets a space at the token end by getting // wrong the length of the trailing context. while (yylength() > 0) { char last = yycharat(yylength()-1); if (last == ' ' || last == '\t' || (last >= '\n' && last <= '\r' || last == '\u0085')) { yypushback(1); } else { break; } } String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 105: break; case 1: { String str = yytext(); int first = str.charAt(0); String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } LOGGER.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: LOGGER.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 106: break; case 44: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 107: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 108: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }"	Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.	0	1
public CharSequence getQueryHint() { final CharSequence hint; if (mQueryHint != null) { hint = mQueryHint; } else if (IS_AT_LEAST_FROYO && mSearchable != null && mSearchable.getHintId() != 0) { hint = getContext().getText(mSearchable.getHintId()); } else { hint = mDefaultQueryHint; } return hint; }	Gets the hint text to display in the query text field.	1	0
@NonNull protected List<Action> retrieveActions(@NonNull SCMSourceEvent event, @NonNull TaskListener listener) throws IOException, InterruptedException { return Collections.emptyList(); }	SPI for #fetchActions(TaskListener).	1	0
public User getUserByName(String username) throws ApiException { return getUserByNameWithHttpInfo(username).getData(); }	Get user by user name	0	1
public final Map<String, String> validateSubDocuments() { final OOXML ooxml = this.getFormatVersion().getXML(); if (!ooxml.canValidate()) return null; final Map<String, String> res = new HashMap<String, String>(); for (final String s : subdocNames) { if (this.getEntries().contains(s)) { final String valid = ooxml.getValidator(this.getDocument(s)).isValid(); if (valid != null) res.put(s, valid); } } return res; }	Call OOXML#isValid(Document) on each XML subdocuments.	1	0
public Schema getDefaultSchema() { return this; }	The schema can be a top level schema which doesn't have its own tables, but refers to one of the default sub schemas for table look up.	0	1
public static List<CmdLineOptionValidator.Result> validate( CmdLineArgs cmdLineArgs) { Validate.notNull(cmdLineArgs); List<CmdLineOptionValidator.Result> results = Lists.newArrayList(); for (CmdLineOptionInstance optionInst : cmdLineArgs .getSpecifiedOptions()) { results.addAll(CmdLineUtils.validate(optionInst)); } return results; }	Runs validation on CmdLineArgs and returns the options which failed validation.	1	0
public Order placeOrder(Order body) throws ApiException { ApiResponse<Order> resp = placeOrderWithHttpInfo(body); return resp.getData(); }	Place an order for a pet	0	1
"public static String asString(final InputStream is, Charset charset) throws IOException { final BufferedReader reader = new BufferedReader(new InputStreamReader(is, charset)); try { final String firstLine = reader.readLine(); if (firstLine == null) { return """"; } final StringBuilder builder = new StringBuilder(firstLine); for (String line = reader.readLine(); line != null; line = reader.readLine()) { builder.append(EOL); builder.append(line); } return builder.toString(); } finally { reader.close(); } }"	Reads the provided input stream as a UTF-8 string and then closes the stream.	1	0
"public String getSchemaType(Schema schema) { if (schema instanceof ComposedSchema) { // composed schema ComposedSchema cs = (ComposedSchema) schema; List<Schema> schemas = ModelUtils.getInterfaces(cs); if (cs.getAllOf() != null) { for (Schema s : cs.getAllOf()) { if (s != null) { //schema = s; } //LOGGER.info(""ALL OF SCHEMA: {}"", s); } LOGGER.info(""Composed schema not yet supported: {}"", cs); // get the model (allOf) return getAlias(""UNKNOWN_COMPOSED_SCHMEA""); } else if (cs.getAnyOf() != null) { // anyOf List<String> names = new ArrayList<String>(); for (Schema s : schemas) { if (StringUtils.isNotBlank(s.get$ref())) { // reference to another definition/schema String schemaName = ModelUtils.getSimpleRef(s.get$ref()); if (StringUtils.isNotEmpty(schemaName)) { names.add(getAlias(schemaName)); } else { LOGGER.warn(""Error obtaining the datatype from ref:"" + schema.get$ref() + "". Default to 'object'""); return ""object""; } } else { // primitive type or model names.add(getAlias(getPrimitiveType(s))); } return ""anyOf<"" + String.join("","", names) + "">""; } } else if (cs.getOneOf() != null) { // oneOf List<String> names = new ArrayList<String>(); for (Schema s : schemas) { if (StringUtils.isNotBlank(s.get$ref())) { // reference to another definition/schema String schemaName = ModelUtils.getSimpleRef(s.get$ref()); if (StringUtils.isNotEmpty(schemaName)) { names.add(getAlias(schemaName)); } else { LOGGER.warn(""Error obtaining the datatype from ref:"" + schema.get$ref() + "". Default to 'object'""); return ""object""; } } else { // primitive type or model names.add(getAlias(getPrimitiveType(s))); } return ""oneOf<"" + String.join("","", names) + "">""; } } } if (StringUtils.isNotBlank(schema.get$ref())) { // reference to another definition/schema // get the schema/model name from $ref String schemaName = ModelUtils.getSimpleRef(schema.get$ref()); if (StringUtils.isNotEmpty(schemaName)) { return getAlias(schemaName); } else { LOGGER.warn(""Error obtaining the datatype from ref:"" + schema.get$ref() + "". Default to 'object'""); return ""object""; } } else { // primitive type or model return getAlias(getPrimitiveType(schema)); } }"	returns the OpenAPI type for the property.	0	1
public static GraphQLSchema transformSchema(GraphQLSchema schema, GraphQLTypeVisitor visitor) { return transformSchema(schema, TraversalType.ALL, visitor); }	Transforms a GrapQLSchema and returns a new GraphQLSchema object.	1	0
"public JDBCException convert(SQLException sqlException, String message, String sql) { String sqlState = JDBCExceptionHelper.extractSqlState( sqlException ); if ( sqlState != null ) { String sqlStateClassCode = JDBCExceptionHelper.determineSqlStateClassCode( sqlState ); if ( sqlStateClassCode != null ) { if ( SQL_GRAMMAR_CATEGORIES.contains( sqlStateClassCode ) ) { return new SQLGrammarException( message, sqlException, sql ); } else if ( INTEGRITY_VIOLATION_CATEGORIES.contains( sqlStateClassCode ) ) { String constraintName = extracter.extractConstraintName( sqlException ); return new ConstraintViolationException( message, sqlException, sql, constraintName ); } else if ( CONNECTION_CATEGORIES.contains( sqlStateClassCode ) ) { return new JDBCConnectionException( message, sqlException, sql ); } else if ( DATA_CATEGORIES.contains( sqlStateClassCode ) ) { return new DataException( message, sqlException, sql ); } } if ( ""40001"".equals( sqlState ) ) { return new LockAcquisitionException( message, sqlException, sql ); } if ( ""61000"".equals( sqlState ) ) { // oracle sql-state code for deadlock return new LockAcquisitionException( message, sqlException, sql ); } if ( ""40XL1"".equals( sqlState ) || ""40XL2"".equals( sqlState )) { // Derby ""A lock could not be obtained within the time requested."" return new PessimisticLockException( message, sqlException, sql ); } } return handledNonSpecificException( sqlException, message, sql ); }"	Convert the given SQLException into Hibernate's JDBCException hierarchy.	0	1
"private StreamEvent findIfActualMin(AttributeDetails latestEvent) { int indexCurrentMin = valueStack.indexOf(currentMin); int postBound = valueStack.indexOf(latestEvent) - indexCurrentMin; // If latest event is at a distance greater than maxPostBound from min, min is not eligible to be sent as output if (postBound > maxPostBound) { currentMin.notEligibleForRealMin(); return null; } // If maxPreBound is 0, no need to check preBoundChange. Send output with postBound value if (maxPreBound == 0) { StreamEvent outputEvent = eventStack.get(indexCurrentMin); complexEventPopulater.populateComplexEvent(outputEvent, new Object[] { ""min"", 0, postBound }); currentMin.sentOutputAsRealMin(); return outputEvent; } int preBound = 1; double dThreshold = currentMin.getValue() + currentMin.getValue() * preBoundChange / 100; while (preBound <= maxPreBound && indexCurrentMin - preBound >= 0) { if (valueStack.get(indexCurrentMin - preBound).getValue() >= dThreshold) { StreamEvent outputEvent = eventStack.get(indexCurrentMin); complexEventPopulater.populateComplexEvent(outputEvent, new Object[] { ""min"", preBound, postBound }); currentMin.sentOutputAsRealMin(); return outputEvent; } ++preBound; } // Completed iterating through maxPreBound older events. No events which satisfy preBoundChange condition found. // Therefore min is not eligible to be sent as output. currentMin.notEligibleForRealMin(); return null; }"	Method to find whether a value d% greater than or equal to min exists within l length window, by looping through older events.	1	0
public static ENumber<Integer> indexOf(Expr<String> left, String right) { return operationFactory.createNumber(Integer.class, Ops.INDEXOF, left, exprFactory.createConstant(right)); }	Expr : left.indexOf(right, i)	1	0
"public static Result createGemFireErrorResult(String message) { return createErrorResult(ERRORCODE_GEODE_ERROR, ""Could not process command due to error. "" + message); }"	Method for convenience to create error result for error in GemFire while executing command.	1	0
public CubeInstance disableCube(CubeInstance cube) throws IOException { aclEvaluate.hasProjectWritePermission(cube.getProjectInstance()); Message msg = MsgPicker.getMsg(); String cubeName = cube.getName(); RealizationStatusEnum ostatus = cube.getStatus(); if (null != ostatus && !RealizationStatusEnum.READY.equals(ostatus)) { throw new BadRequestException(String.format(msg.getDISABLE_NOT_READY_CUBE(), cubeName, ostatus)); } return getCubeManager().updateCubeStatus(cube, RealizationStatusEnum.DISABLED); }	Update a cube status from ready to disabled.	0	1
public boolean isPullSuccessIndicated() { if (isErrorIndicated() || getStatus() == null) { return false; } return (getStatus().contains(DOWNLOAD_COMPLETE) || getStatus().contains(IMAGE_UP_TO_DATE) || getStatus().contains(DOWNLOADED_NEWER_IMAGE) || getStatus().contains(LEGACY_REGISTRY) || getStatus().contains(DOWNLOADED_SWARM) ); }	Returns whether the status indicates a successful pull operation	0	1
public static FlumeNodeState findByValue(int value) { switch (value) { case 0: return HELLO; case 1: return IDLE; case 2: return CONFIGURING; case 3: return ACTIVE; case 4: return ERROR; case 5: return LOST; case 6: return DECOMMISSIONED; default: return null; } }	Find a the enum type by its integer value, as defined in the Thrift IDL.	0	1
"static HintStrategyTable createHintStrategies(HintStrategyTable.Builder builder) { return builder .addHintStrategy(""no_hash_join"", HintStrategies.JOIN) .addHintStrategy(""time_zone"", HintStrategies.SET_VAR) .addHintStrategy(""REPARTITION"", HintStrategies.SET_VAR) .addHintStrategy(""index"", HintStrategies.TABLE_SCAN) .addHintStrategy(""properties"", HintStrategies.TABLE_SCAN) .addHintStrategy( ""resource"", HintStrategies.or( HintStrategies.PROJECT, HintStrategies.AGGREGATE, HintStrategies.CALC)) .addHintStrategy(""AGG_STRATEGY"", HintStrategies.AGGREGATE, (hint, errorHandler) -> errorHandler.check( hint.listOptions.size() == 1 && (hint.listOptions.get(0).equalsIgnoreCase(""ONE_PHASE"") || hint.listOptions.get(0).equalsIgnoreCase(""TWO_PHASE"")), ""Hint {} only allows single option, "" + ""allowed options: [ONE_PHASE, TWO_PHASE]"", hint.hintName )) .addHintStrategy(""use_hash_join"", HintStrategies.and(HintStrategies.JOIN, HintStrategies.explicit((hint, rel) -> { if (!(rel instanceof LogicalJoin)) { return false; } LogicalJoin join = (LogicalJoin) rel; final List<String> tableNames = hint.listOptions; final List<String> inputTables = join.getInputs().stream() .filter(input -> input instanceof TableScan) .map(scan -> Util.last(scan.getTable().getQualifiedName())) .collect(Collectors.toList()); return equalsStringList(tableNames, inputTables); }))) .build(); }"	Creates mock hint strategies.	1	0
public ScalewayCloud getCloud() { Jenkins instance = Jenkins.getInstance(); if (instance != null) { return (ScalewayCloud) instance.getCloud(cloudName); } return null; }	Retrieve a handle to the associated com.segator.jenkins.scaleway.Cloud	1	0
public static Set<ImmutableBitSet> getUniqueKeys(RelNode rel) { final BuiltInMetadata.UniqueKeys metadata = rel.metadata(BuiltInMetadata.UniqueKeys.class); return metadata.getUniqueKeys(false); }	Returns the BuiltInMetadata.UniqueKeys#getUniqueKeys(boolean) statistic.	0	1
@Override public boolean equals(Object obj) { if (obj != null && obj.getClass().equals(this.getClass())) { NoteObject that = (NoteObject) obj; if (content == null && that.getContent() != null) return false; if (content != null && !content.equals(that.getContent())) return false; } return true; }	Tests if two contents are equal.	1	0
public static Path createTestingPath(String relativePath) { return Paths.get(dataDir(), relativePath).toAbsolutePath(); }	Create the path to a file within the test data directory at the given relative path.	0	1
"public static boolean isGZipFile(String file) { String ext = getExtension(file); return ""gz"".equals(ext) || ""z"".equals(ext); }"	"Indicates if the given file ends with a file extension of "".gz"", indicating a GZip file."	1	0
private boolean isSameText() { ArrayList<TextView> textViewList = soloView.getCurrentTextViews(null); int size = textViewList.size(); int constant = 0; if (size > 2) constant = 2; else constant = size; if (checkTextView != null && !checkTextView.getText().equals( textViewList.get(size - constant).getText())) { checkTextView = textViewList.get(size - constant); return false; } else if (checkTextView == null) { checkTextView = textViewList.get(size - constant); return false; } else return true; }	Determines if no more scrolling can be done.	1	0
public static CollectionId parse(String replicaSetName, String str) { final int dotPosition = str.indexOf('.'); if (dotPosition == -1 || (dotPosition + 1) == str.length() || dotPosition == 0) { return null; } return new CollectionId(replicaSetName, str.substring(0, dotPosition), str.substring(dotPosition + 1)); }	Parse the supplied string, extracting the first 3 parts into a Collection.	1	0
"public WebSocket doWebSocketConnect(final HttpServletRequest request, final String protocol) { logger.info(""WebSocket upgrade requested""); return new JettyWebSocketListener(request,this); }"	Jetty 7 and up WebSocket support.	1	0
public Button getButton(int index) { Button button = soloView.getButton(index); return button; }	This method returns a button with a certain index.	0	1
private static CoreMap fromProto(CoreNLPProtos.Sentence proto) { CoreMap sentence = new ArrayCoreMap(); // Required fields sentence.set(TokenBeginAnnotation.class, proto.getTokenOffsetBegin()); sentence.set(TokenEndAnnotation.class, proto.getTokenOffsetEnd()); // Optional fields if (proto.hasSentenceIndex()) { sentence.set(SentenceIndexAnnotation.class, proto.getSentenceIndex()); } if (proto.hasCharacterOffsetBegin()) { sentence.set(CharacterOffsetBeginAnnotation.class, proto.getCharacterOffsetBegin()); } if (proto.hasCharacterOffsetEnd()) { sentence.set(CharacterOffsetEndAnnotation.class, proto.getCharacterOffsetEnd()); } if (proto.hasParseTree()) { sentence.set(TreeAnnotation.class, fromProto(proto.getParseTree())); } // Non-default fields if (proto.hasHasRelationAnnotations() && proto.getHasRelationAnnotations()) { // set entities List<EntityMention> entities = new ArrayList<EntityMention>(); for (CoreNLPProtos.Entity entity : proto.getEntityList()) { entities.add(fromProto(entity, sentence)); } sentence.set(EntityMentionsAnnotation.class, entities); // set relations List<RelationMention> relations = new ArrayList<RelationMention>(); for (CoreNLPProtos.Relation relation : proto.getRelationList()) { relations.add(fromProto(relation, sentence)); } sentence.set(RelationMentionsAnnotation.class, relations); } // Return return sentence; }	Create a CoreLabel from its serialized counterpart.	1	0
protected Object convertDouble(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0.0d; } if (data instanceof Double) return data; if (data instanceof Number) { // Includes BigDecimal and other numeric values ... Number value = (Number) data; return new Double(value.doubleValue()); } if (data instanceof Boolean) { return NumberConversions.getDouble((Boolean) data); } return handleUnknownData(column, fieldDefn, data); }	Converts a value object for an expected JDBC type of Types#DOUBLE.	0	1
"public CubeDesc updateCubeDesc(CubeDesc desc) throws IOException { // Validate CubeDesc if (desc.getUuid() == null || desc.getName() == null) { throw new IllegalArgumentException(); } String name = desc.getName(); if (!cubeDescMap.containsKey(name)) { throw new IllegalArgumentException(""CubeDesc '"" + name + ""' does not exist.""); } try { desc.init(config, getMetadataManager().getAllTablesMap()); } catch (Exception e) { desc.addError(e.getMessage()); return desc; } // Semantic validation CubeMetadataValidator validator = new CubeMetadataValidator(); ValidateContext context = validator.validate(desc); if (!context.ifPass()) { return desc; } desc.setSignature(desc.calculateSignature()); // Save Source String path = desc.getResourcePath(); getStore().putResource(path, desc, CUBE_DESC_SERIALIZER); // Reload the CubeDesc CubeDesc ndesc = loadCubeDesc(path, false); // Here replace the old one cubeDescMap.put(ndesc.getName(), desc); return ndesc; }"	Update CubeDesc with the input.	0	1
public static StringExpression type(EntityPath<?> path) { return StringOperation.create(JPQLOps.TYPE, path); }	Get the type(path) expression	0	1
public float getY() { if(top == null) { calculateTop(); } return top.floatValue(); }	Get the y location of the center of this circle	1	0
"public String toString() { if ( connString == null ) { String wrappedString; try { wrappedString = getRealConnection().toString(); } catch ( SQLException e ) { wrappedString = ""<none>""; } connString = this.getClass().getName() + ""@"" + this.hashCode() + "", Wrapped Connection = "" + wrappedString; } return connString; }"	Get the string representation for the underlying physical connection.	1	0
public Q clone() { return clone(entityManager, getTemplates()); }	Clone the state of this query to a new instance	0	1
AvaticaHttpClient getHttpClient(AvaticaConnection connection, ConnectionConfig config) { URL url; try { url = new URL(config.url()); } catch (MalformedURLException e) { throw new RuntimeException(e); } AvaticaHttpClientFactory httpClientFactory = config.httpClientFactory(); return httpClientFactory.getClient(url, config); }	Creates the HTTP client that communicates with the Avatica server.	0	1
public T caseCustomersType(CustomersType object) { return null; }	Returns the result of interpretting the object as an instance of 'sType'.	1	0
"public String toString() { long millis = getMillis(); StringBuffer buf = new StringBuffer(); buf.append(""PT""); FormatUtils.appendUnpaddedInteger(buf, millis / 1000); long part = Math.abs(millis % 1000); if (part > 0) { buf.append('.'); FormatUtils.appendPaddedInteger(buf, part, 3); } buf.append('S'); return buf.toString(); }"	Gets the value as a String in the ISO8601 duration format.	1	0
public static boolean isMatchedWithTopN(CubeInstance cube, SQLDigest digest) { boolean hasTopN = hasTopNMeasure(cube.getDescriptor()); if (hasTopN == false) { return false; } Collection<TblColRef> dimensionColumns = CubeDimensionDeriver.getDimensionColumns(digest); boolean matchDimensions = isMatchedWithDimensions(dimensionColumns, cube); if (matchDimensions == true) { return false; } Collection<FunctionDesc> functions = digest.aggregations; if (functions == null || functions.size() != 1) { // topN only allow one measure return false; } return isMatchedWithTopN(dimensionColumns, cube, digest); }	Check whether the cube can match the sql digest with TopN measure	0	1
public CreateTableEntry createNewTable(String tableName, List<String> partitionColumns) { return createNewTable(tableName, partitionColumns, StorageStrategy.DEFAULT); }	Creates table entry using table name and list of partition columns if any.	0	1
public int getPosition() { return currentPosition; }	Returns current known position.	1	0
public static ScannableTable generate(int width, int height, int seed) { return new MazeTable(width, height, seed, false); }	Called by reflection based on the definition of the user-defined function in the schema.	1	0
private byte[] read(InputStream in, int length) throws IOException { byte[] buffer = new byte[length]; int bytesRead = 0; do { bytesRead += in.read(buffer); } while (length != bytesRead); int freeSpace = currentFrame.capacity() - currentFrame.position(); if (freeSpace < bytesRead) { currentFrame = reallocate(currentFrame, currentFrame.position() + bytesRead); } // add bytes to current frame and reset to be able to read again currentFrame.put(buffer); return buffer; }	Reads given length from the channel.	1	0
"protected String readAnnouncement( File file ) throws MojoExecutionException { InputStreamReader reader = null; FileInputStream inputStream = null; try { inputStream = new FileInputStream( file ); if ( StringUtils.isEmpty( templateEncoding ) ) { templateEncoding = ReaderFactory.FILE_ENCODING; getLog().warn( ""File encoding has not been set, using platform encoding '"" + templateEncoding + ""', i.e. build is platform dependent!"" ); } reader = new InputStreamReader( inputStream, templateEncoding ); return IOUtil.toString( reader ); } catch ( FileNotFoundException fnfe ) { throw new MojoExecutionException( ""File not found. "" + file ); } catch ( UnsupportedEncodingException uee ) { throw new MojoExecutionException( ""Unsupported encoding: '"" + templateEncoding + ""'"" ); } catch ( IOException ioe ) { throw new MojoExecutionException( ""Failed to read the announcement file."", ioe ); } finally { IOUtil.close( inputStream ); IOUtil.close( reader ); } }"	Read the announcement generated file.	1	0
"public static AuditReader get(EntityManager entityManager) throws AuditException { if (entityManager.getDelegate() instanceof Session) { return get((Session) entityManager.getDelegate()); } if (entityManager.getDelegate() instanceof EntityManager) { return get((EntityManager) entityManager.getDelegate()); } throw new AuditException(""Hibernate EntityManager not present!""); }"	Create an audit reader associated with an open entity manager.	0	1
@NonNull protected List<Action> retrieveActions(@NonNull SCMRevision revision, @NonNull SCMHeadEvent event, @NonNull TaskListener listener) throws IOException, InterruptedException { return Collections.emptyList(); }	SPI for #fetchActions(SCMRevision, TaskListener).	1	0
"protected String[] convert(Path<?> leftHandSide, Object rightHandSide) { String str = rightHandSide.toString(); if (lowerCase){ str = str.toLowerCase(); } if (splitTerms) { if (str.equals("""")) { return new String[] { str }; } else { return StringUtils.split(str); } } else { return new String[] { str }; } }"	Template method, override to customize.	1	0
"public CompletableFuture<ExecutionResult> executeAsync(ExecutionInput executionInput) { try { log.debug(""Executing request. operation name: {}. query: {}. variables {} "", executionInput.getOperationName(), executionInput.getQuery(), executionInput.getVariables()); InstrumentationState instrumentationState = instrumentation.createState(); InstrumentationExecutionParameters instrumentationParameters = new InstrumentationExecutionParameters(executionInput, this.graphQLSchema, instrumentationState); InstrumentationContext<ExecutionResult> executionInstrumentation = instrumentation.beginExecution(instrumentationParameters); CompletableFuture<ExecutionResult> executionResult = parseValidateAndExecute(executionInput, instrumentationState); // // finish up instrumentation executionResult = executionResult.whenComplete(executionInstrumentation::onEnd); // // allow instrumentation to tweak the result executionResult = executionResult.thenCompose(result -> instrumentation.instrumentExecutionResult(result, instrumentationParameters)); return executionResult; } catch (AbortExecutionException abortException) { ExecutionResultImpl executionResult = new ExecutionResultImpl(abortException); return CompletableFuture.completedFuture(executionResult); } }"	Executes the graphql query using the provided input object	0	1
"public static GitlabRepositoryName create(final String url) { LOGGER.log(Level.FINE, ""Constructing from URL {0}"", url); for (Pattern p : URL_PATTERNS) { Matcher m = p.matcher(url.trim()); if (m.matches()) { LOGGER.log(Level.FINE, ""URL matches {0}"", m); GitlabRepositoryName ret = new GitlabRepositoryName(m.group(1), m.group(2), m.group(3)); LOGGER.log(Level.FINE, ""Object is {0}"", ret); return ret; } } LOGGER.log(Level.WARNING, ""Could not match URL {0}"", url); return null; }"	Create GitHubRepositoryName from URL	1	0
"public String toString() { return ""-P: "" + this.directory_prefix; }"	DOCUMENT ME!	1	0
"private static RemoteCalculator lookupRemoteStatelessCalculator() throws NamingException { final Hashtable jndiProperties = new Hashtable(); jndiProperties.put(Context.URL_PKG_PREFIXES, ""org.jboss.ejb.client.naming""); final Context context = new InitialContext(jndiProperties); // The JNDI lookup name for a stateless session bean has the syntax of: // ejb:<appName>/<moduleName>/<distinctName>/<beanName>!<viewClassName> // // <appName> The application name is the name of the EAR that the EJB is deployed in // (without the .ear). If the EJB JAR is not deployed in an EAR then this is // blank. The app name can also be specified in the EAR's application.xml // // <moduleName> By the default the module name is the name of the EJB JAR file (without the // .jar suffix). The module name might be overridden in the ejb-jar.xml // // <distinctName> : WildFly allows each deployment to have an (optional) distinct name. // This example does not use this so leave it blank. // // <beanName> : The name of the session been to be invoked. // // <viewClassName>: The fully qualified classname of the remote interface. Must include // the whole package name. // let's do the lookup return (RemoteCalculator) context.lookup(""ejb:/wildfly-ejb-remote-server-side/CalculatorBean!"" + RemoteCalculator.class.getName()); }"	Looks up and returns the proxy to remote stateless calculator bean	0	1
public final FileChannel getChannel() { synchronized(this) { if(channel == null) { channel = FileChannelFactory.getFileChannel(this, fd.descriptor, options); } return channel; } }	Returns the FileChannel equivalent to this stream.	1	0
public static DateTimeFieldType minuteOfDay() { return MINUTE_OF_DAY_TYPE; }	Get the minute of day field type.	0	1
public List getImageSrcs(boolean duplicate) { if (duplicate) { return this.htmlHandler.getAllImageSrcs(); } return this.htmlHandler.getImageSrcs(); }	DOCUMENT ME!	1	0
"@SuppressWarnings(""static-access"") public ObjectName getExchangeObjectName(String virtualHostName, String exchange) { // Get the name of the test manager AllObjects allObject = new AllObjects(_mbsc); allObject.querystring = ""org.apache.qpid:type=VirtualHost.Exchange,VirtualHost="" + virtualHostName + "",name="" + exchange + "",*""; Set<ObjectName> objectNames = allObject.returnObjects(); _test.assertNotNull(""Null ObjectName Set returned"", objectNames); _test.assertEquals(""Incorrect number of exchange with name '"" + exchange + ""' returned"", 1, objectNames.size()); // We have verified we have only one value in objectNames so return it ObjectName objectName = objectNames.iterator().next(); _test.getLogger().info(""Loading: "" + objectName); return objectName; }"	Retrive the ObjectName for the given Exchange on the test Virtualhost.	1	0
public List<Pet> findPetsByTags(List<String> tags) throws ApiException { Call call = findPetsByTagsCall(tags); Type returnType = new TypeToken<List<Pet>>(){}.getType(); return apiClient.execute(call, returnType); }	Finds Pets by tags	0	1
public ProjectItem getChild(String text) { String[] childPath = new String[path.length + 1]; System.arraycopy(path, 0, childPath, 0, path.length); childPath[childPath.length - 1] = text; return project.getProjectItem(childPath); }	Gets child of the project item with given text without decorators.	1	0
public Double getEnumNumber() { if (enumNumber == null) { return null; } return enumNumber.value(); }	Get enumNumber	0	1
"static Object wrapArgumentForScriptExecution(Object argument) { JSONObject wrappedArgument = new JSONObject(); try { if (argument instanceof String) { wrappedArgument.put(""type"", ""STRING""); wrappedArgument.put(""value"", argument); } else if (argument instanceof Boolean) { wrappedArgument.put(""type"", ""BOOLEAN""); wrappedArgument.put(""value"", argument); } else if (argument instanceof Number) { wrappedArgument.put(""type"", ""NUMBER""); wrappedArgument.put(""value"", argument); } else if (argument instanceof ChromeWebElement) { wrappedArgument.put(""type"", ""ELEMENT""); wrappedArgument.put(""value"", ((ChromeWebElement)argument).getElementId()); } else if (argument instanceof Collection<?>) { JSONArray array = new JSONArray(); for (Object o : (Collection<?>)argument) { array.put(wrapArgumentForScriptExecution(o)); } return array; } else { throw new IllegalArgumentException(""Could not wrap up "" + ""javascript parameter "" + argument + ""(class: "" + argument.getClass() + "")""); } } catch (JSONException e) { throw new WebDriverException(e); } return wrappedArgument; }"	Wraps up values as type: some_type, value: some_value objects	0	1
public SqlTester getTester() { return new SqlTesterImpl(new AdvisorTesterFactory()); }	Converts a list to a string, one item per line.	0	1
public Object getProperty(String name) { if (name == null || !isPropertySupported(name)) throw new IllegalArgumentException(); return callProperties.get(name); } // getProperty	Returns the value associated with the named property - or null if not defined/set.	1	0
"protected static CodecFactory getCompressionCodec(TaskAttemptContext context) { if (FileOutputFormat.getCompressOutput(context)) { // Default to deflate compression. int deflateLevel = context.getConfiguration().getInt( org.apache.avro.mapred.AvroOutputFormat.DEFLATE_LEVEL_KEY, CodecFactory.DEFAULT_DEFLATE_LEVEL); int xzLevel = context.getConfiguration().getInt( org.apache.avro.mapred.AvroOutputFormat.XZ_LEVEL_KEY, CodecFactory.DEFAULT_XZ_LEVEL); String outputCodec = context.getConfiguration() .get(AvroJob.CONF_OUTPUT_CODEC); if (outputCodec == null) { String compressionCodec = context.getConfiguration().get(""mapred.output.compression.codec""); String avroCodecName = HadoopCodecFactory.getAvroCodecName(compressionCodec); if ( avroCodecName != null){ context.getConfiguration().set(AvroJob.CONF_OUTPUT_CODEC, avroCodecName); return HadoopCodecFactory.fromHadoopString(compressionCodec); } else { return CodecFactory.deflateCodec(deflateLevel); } } else if (DataFileConstants.DEFLATE_CODEC.equals(outputCodec)) { return CodecFactory.deflateCodec(deflateLevel); } else if (DataFileConstants.XZ_CODEC.equals(outputCodec)) { return CodecFactory.xzCodec(xzLevel); } else { return CodecFactory.fromString(outputCodec); } } // No compression. return CodecFactory.nullCodec(); }"	Gets the configured compression codec from the task context.	0	1
public boolean peek() { if (outputQueue.isEmpty()) { return false; } else { final int nextId = outputQueue.peek().id; return orderResults ? nextId == lastReturnedId + 1 : true; } }	Indicates whether or not a new result is available.	1	0
"public ResponseEntity<ModelApiResponse> uploadFileWithRequiredFileWithHttpInfo(Long petId, File requiredFile, String additionalMetadata) throws RestClientException { Object postBody = null; // verify the required parameter 'petId' is set if (petId == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'petId' when calling uploadFileWithRequiredFile""); } // verify the required parameter 'requiredFile' is set if (requiredFile == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile""); } // create path and map variables final Map<String, Object> uriVariables = new HashMap<String, Object>(); uriVariables.put(""petId"", petId); String path = apiClient.expandPath(""/fake/{petId}/uploadImageWithRequiredFile"", uriVariables); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); if (additionalMetadata != null) formParams.add(""additionalMetadata"", additionalMetadata); if (requiredFile != null) formParams.add(""requiredFile"", new FileSystemResource(requiredFile)); final String[] accepts = { ""application/json"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { ""multipart/form-data"" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { ""petstore_auth"" }; ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {}; return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType); }"	uploads an image (required) 200 - successful operation	0	1
public ParameterList getBodyParams() { return bodyParams; }	Obtains a Map of the body parameters.	1	0
public ApiResponse<Void> createUsersWithListInputWithHttpInfo(List<User> body) throws ApiException { okhttp3.Call localVarCall = createUsersWithListInputValidateBeforeCall(body, null, null); return localVarApiClient.execute(localVarCall); }	Creates list of users with given input array	0	1
public boolean tryLock() { return sync.tryReadLock(); }	Acquires the shared lock only if it is not held exclusively by another thread at the time of invocation.	1	0
public boolean evaluate(S object) { return ev.<Boolean>evaluate(object); }	filter the given iterator using the given expressionevaluator that evaluates to true / false	0	1
public Task<EncodedImage> get(CacheKey key, AtomicBoolean isCancelled) { final EncodedImage pinnedImage = mStagingArea.get(key); if (pinnedImage != null) { return foundPinnedImage(key, pinnedImage); } return getAsync(key, isCancelled); }	Performs lookup of a series of disk cache keys in a single thread.	1	0
public static StringTemplate stringTemplate(String template, ImmutableList<?> args) { return stringTemplate(createTemplate(template), args); }	Create a new Template expression	0	1
public String getConnectedServer(AccessToken accessToken, String node) { AgentMgtDao agentMgtDao = new AgentMgtDao(); return agentMgtDao.getConnectedServer(accessToken.getId(), node); }	Get node ip connected to the access token	1	0
public final List<ModuleReference> getDependentModulesRecursively(final ModuleReference ref) throws Exception { return getDependentModulesRecursively(ref, new ArrayList<ModuleReference>()); }	The list of modules depending on the passed one.	1	0
public CommonCardView getCardView() { return mCardView; }	This method returns the complete View used	0	1
"public <T extends Server> Server getServer(Class<T> clazz, String name) { for (Server server : getServers()){ if (server.isValid() && server.getLabel().getName().equals(name)){ return server.getAdapter(clazz); } } log.info(""Requested server '"" + name + ""' was not found on Servers view""); log.info(""Available servers are: "" + LoggingUtils.format(getServersNames())); throw new EclipseLayerException(""There is no server with name "" + name); }"	Gets a server of specified type with the given name.	1	0
"public Object getValue(PgProto.DatumMessage datumMessage, PgConnectionSupplier connection, boolean includeUnknownDatatypes) { int columnType = (int) datumMessage.getColumnType(); switch (columnType) { case PgOid.BOOL: return datumMessage.hasDatumBool() ? datumMessage.getDatumBool() : null; case PgOid.INT2: case PgOid.INT4: return datumMessage.hasDatumInt32() ? datumMessage.getDatumInt32() : null; case PgOid.INT8: case PgOid.OID: case PgOid.MONEY: return datumMessage.hasDatumInt64() ? datumMessage.getDatumInt64() : null; case PgOid.FLOAT4: return datumMessage.hasDatumFloat()? datumMessage.getDatumFloat() : null; case PgOid.FLOAT8: return datumMessage.hasDatumDouble() ? datumMessage.getDatumDouble() : null; case PgOid.NUMERIC: if (datumMessage.hasDatumDouble()) { // For backwards compatibility only to enable independent upgrade of Postgres plug-in return datumMessage.getDatumDouble(); } else if (datumMessage.hasDatumString()) { final String s = datumMessage.getDatumString(); return PostgresValueConverter.toSpecialValue(s).orElseGet(() -> new SpecialValueDecimal(new BigDecimal(s))); } return null; case PgOid.CHAR: case PgOid.VARCHAR: case PgOid.BPCHAR: case PgOid.TEXT: case PgOid.JSON: case PgOid.JSONB_OID: case PgOid.XML: case PgOid.UUID: case PgOid.BIT: case PgOid.VARBIT: case PgOid.INET_OID: case PgOid.CIDR_OID: case PgOid.MACADDR_OID: case PgOid.MACADDR8_OID: return datumMessage.hasDatumString() ? datumMessage.getDatumString() : null; case PgOid.DATE: return datumMessage.hasDatumInt32() ? (long) datumMessage.getDatumInt32() : null; case PgOid.TIMESTAMP: if (!datumMessage.hasDatumInt64()) { return null; } // these types are sent by the plugin as LONG - microseconds since Unix Epoch return Conversions.toInstantFromMicros(datumMessage.getDatumInt64()); case PgOid.TIMESTAMPTZ: if (!datumMessage.hasDatumInt64()) { return null; } // these types are sent by the plugin as LONG - microseconds since Unix Epoch return Conversions.toInstantFromMicros(datumMessage.getDatumInt64()).atOffset(ZoneOffset.UTC); case PgOid.TIME: if (!datumMessage.hasDatumInt64()) { return null; } // these types are sent by the plugin as LONG - microseconds since Unix Epoch return Duration.of(datumMessage.getDatumInt64(), ChronoUnit.MICROS); case PgOid.TIMETZ: if (!datumMessage.hasDatumDouble()) { return null; } // the value is sent as a double microseconds return Conversions.toInstantFromMicros((long) datumMessage.getDatumDouble()) .atOffset(ZoneOffset.UTC) .toOffsetTime(); case PgOid.INTERVAL: // these are sent as doubles by the plugin since their storage is larger than 8 bytes return datumMessage.hasDatumDouble() ? datumMessage.getDatumDouble() : null; // the plugin will send back a TZ formatted string case PgOid.BYTEA: return datumMessage.hasDatumBytes() ? datumMessage.getDatumBytes().toByteArray() : null; case PgOid.POINT: { PgProto.Point datumPoint = datumMessage.getDatumPoint(); return new PGpoint(datumPoint.getX(), datumPoint.getY()); } case PgOid.TSRANGE_OID: case PgOid.TSTZRANGE_OID: case PgOid.DATERANGE_OID: case PgOid.INT4RANGE_OID: case PgOid.NUM_RANGE_OID: case PgOid.INT8RANGE_OID: return datumMessage.hasDatumBytes() ? new String(datumMessage.getDatumBytes().toByteArray(), Charset.forName(""UTF-8"")) : null; case PgOid.INT2_ARRAY: case PgOid.INT4_ARRAY: case PgOid.INT8_ARRAY: case PgOid.TEXT_ARRAY: case PgOid.NUMERIC_ARRAY: case PgOid.FLOAT4_ARRAY: case PgOid.FLOAT8_ARRAY: case PgOid.BOOL_ARRAY: case PgOid.DATE_ARRAY: case PgOid.TIME_ARRAY: case PgOid.TIMETZ_ARRAY: case PgOid.TIMESTAMP_ARRAY: case PgOid.TIMESTAMPTZ_ARRAY: case PgOid.BYTEA_ARRAY: case PgOid.VARCHAR_ARRAY: case PgOid.OID_ARRAY: case PgOid.BPCHAR_ARRAY: case PgOid.MONEY_ARRAY: case PgOid.NAME_ARRAY: case PgOid.INTERVAL_ARRAY: case PgOid.CHAR_ARRAY: case PgOid.VARBIT_ARRAY: case PgOid.UUID_ARRAY: case PgOid.XML_ARRAY: case PgOid.POINT_ARRAY: case PgOid.JSONB_ARRAY: case PgOid.JSON_ARRAY: case PgOid.REF_CURSOR_ARRAY: case PgOid.INET_ARRAY: case PgOid.CIDR_ARRAY: case PgOid.MACADDR_ARRAY: case PgOid.MACADDR8_ARRAY: case PgOid.TSRANGE_ARRAY: case PgOid.TSTZRANGE_ARRAY: case PgOid.DATERANGE_ARRAY: case PgOid.INT4RANGE_ARRAY: case PgOid.NUM_RANGE_ARRAY: case PgOid.INT8RANGE_ARRAY: return getArray(datumMessage, connection, columnType); case PgOid.UNSPECIFIED: return null; default: PostgresType type = typeRegistry.get(columnType); if (type.getOid() == typeRegistry.geometryOid() || type.getOid() == typeRegistry.geographyOid() || type.getOid() == typeRegistry.citextOid() ) { return datumMessage.getDatumBytes().toByteArray(); } if(type.getOid() == typeRegistry.hstoreOid()) { return datumMessage.getDatumBytes().toByteArray(); } if (type.getOid() == typeRegistry.geometryArrayOid() || type.getOid() == typeRegistry.geographyArrayOid() || type.getOid() == typeRegistry.citextArrayOid() || type.getOid() == typeRegistry.hstoreArrayOid()) { return getArray(datumMessage, connection, columnType); } // unknown data type is sent by decoder as binary value if (includeUnknownDatatypes && datumMessage.hasDatumBytes()) { return datumMessage.getDatumBytes().toByteArray(); } return null; } }"	Converts the Protobuf value for a io.debezium.connector.postgresql.proto.PgProto.DatumMessage plugin message to a Java value based on the type of the column from the message.	0	1
public static <T> T getObject(Heap heap, JsonValue name, Class<T> type) throws HeapException { if (name.isNull()) { return null; } return getRequiredObject(heap, name, type); }	Retreives an object from a heap with the specified name and type.	1	0
private Integer findColumn(String columnName) throws SQLException { return columnNameCache.getIndexForColumnName( columnName, rs ); }	Locate the column index corresponding to the given column name via the cache.	0	1
public static Predicate<Connectivity> hasState(final NetworkInfo.State... states) { return new Predicate<Connectivity>() { @Override public boolean test(@NonNull Connectivity connectivity) throws Exception { for (NetworkInfo.State state : states) { if (connectivity.state() == state) { return true; } } return false; } }; }	Filter, which returns true if at least one given state occurred	0	1
public InetAddress getNumericalAddress() { return address; }	Returns the address of the sender as a long.	1	0
public SchemaPath getUnIndexed() { return new SchemaPath(getUnIndexedNameSegment(rootSegment, null)); }	Returns schema path with for arrays without index.	0	1
public static Iterable<Runnable> thread(final String title, Iterable<Runnable> runnables){ //--Preparation //(variables) final AtomicBoolean haveStarted = new AtomicBoolean(false); final ReentrantLock metaInfoLock = new ReentrantLock(); final AtomicInteger numPending = new AtomicInteger(0); final Iterator<Runnable> iter = runnables.iterator(); //--Create Runnables return new IterableIterator<>(new Iterator<Runnable>() { @Override public boolean hasNext() { synchronized (iter) { return iter.hasNext(); } } @Override public synchronized Runnable next() { final Runnable runnable; synchronized (iter) { runnable = iter.next(); } // (don't flood the queu) while (numPending.get() > 100) { try { Thread.sleep(100); } catch (InterruptedException e) { } } numPending.incrementAndGet(); // (add the job) Runnable toReturn = new Runnable(){ public void run(){ boolean threadFinished = false; try{ //(signal start of threads) metaInfoLock.lock(); if(!haveStarted.getAndSet(true)){ startThreads(title); //<--this must be a blocking operation } metaInfoLock.unlock(); //(run runnable) try{ runnable.run(); } catch (Exception e){ e.printStackTrace(); System.exit(1); } catch (AssertionError e) { e.printStackTrace(); System.exit(1); } //(signal end of thread) finishThread(); threadFinished = true; //(signal end of threads) int numStillPending = numPending.decrementAndGet(); synchronized (iter) { if (numStillPending <= 0 && !iter.hasNext()) { endThreads(title); } } } catch(Throwable t){ t.printStackTrace(); if (!threadFinished) { finishThread(); } } } }; return toReturn; } @Override public void remove() { synchronized (iter) { iter.remove(); } } }); }	Wrap a collection of threads (Runnables) to be logged by Redwood.	0	1
public static Folder resolveFolder(Folder dir, String relativePath) { final String[] fragments = StringUtils.split(relativePath, '/'); if (ArrayUtils.isEmpty(fragments)) { return dir; } return resolveFolder(dir, Arrays.stream(fragments).iterator()); }	Resolves a relative path (separated by '/') to a folder, e.g.	0	1
public ApiResponse<Void> deleteOrderWithHttpInfo(String orderId) throws ApiException { okhttp3.Call localVarCall = deleteOrderValidateBeforeCall(orderId, null, null); return localVarApiClient.execute(localVarCall); }	Delete purchase order by ID	0	1
public TimeOfDay setCopy(String text) { return setCopy(text, null); }	Sets this field in a copy of the TimeOfDay.	1	0
"public boolean applyAPSRequest(APSResult request, Callback callback) { PumpInterface pump = getActivePump(); request.rate = applyBasalConstraints(request.rate); if (!pump.isInitialized()) { log.debug(""applyAPSRequest: "" + MainApp.sResources.getString(R.string.pumpNotInitialized)); if (callback != null) { callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpNotInitialized)).enacted(false).success(false)).run(); } return false; } if (pump.isSuspended()) { log.debug(""applyAPSRequest: "" + MainApp.sResources.getString(R.string.pumpsuspended)); if (callback != null) { callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpsuspended)).enacted(false).success(false)).run(); } return false; } if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: "" + request.toString()); if ((request.rate == 0 && request.duration == 0) || Math.abs(request.rate - pump.getBaseBasalRate()) < pump.getPumpDescription().basalStep) { if (isTempBasalInProgress()) { if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: cancelTempBasal()""); getCommandQueue().cancelTempBasal(false, callback); if (request.smb == 0) return true; } else { if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: Basal set correctly""); if (callback != null) { callback.result(new PumpEnactResult().absolute(request.rate).duration(0).enacted(false).success(true).comment(""Basal set correctly"")).run(); } if (request.smb == 0) return false; } } else if (isTempBasalInProgress() && getTempBasalRemainingMinutesFromHistory() > 5 && Math.abs(request.rate - getTempBasalAbsoluteRateHistory()) < pump.getPumpDescription().basalStep) { if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: Temp basal set correctly""); if (callback != null) { callback.result(new PumpEnactResult().absolute(getTempBasalAbsoluteRateHistory()).duration(getTempBasalFromHistory(System.currentTimeMillis()).getPlannedRemainingMinutes()).enacted(false).success(true).comment(""Temp basal set correctly"")).run(); } if (request.smb == 0) return false; } else { if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: setTempBasalAbsolute()""); getCommandQueue().tempBasalAbsolute(request.rate, request.duration, false, callback); if (request.smb == 0) return true; } log.debug(""SMB requested in config is: "" + request.smb); if (request.smb != 0) { long lastBolusTime = getLastBolusTime(); if (lastBolusTime != 0 && lastBolusTime + 3 * 60 * 1000 > System.currentTimeMillis()) { log.debug(""SMB requsted but still in 3 min interval""); } else { DetailedBolusInfo detailedBolusInfo = new DetailedBolusInfo(); detailedBolusInfo.eventType = CareportalEvent.CORRECTIONBOLUS; detailedBolusInfo.insulin = request.smb; detailedBolusInfo.isSMB = true; detailedBolusInfo.source = Source.USER; boolean smbDelivered = getCommandQueue().bolus(detailedBolusInfo, callback); if (smbDelivered) return true; else return false; } } return true; }"	expect absolute request and allow both absolute and percent response based on pump capabilities	0	1
public static AnnotationMirror getAnnotationMirror(Element element, Class<? extends Annotation> clazz) { assert clazz != null; return getAnnotationMirror( element, clazz.getName() ); }	Returns the annotation mirror for the specified annotation class from the Element.	1	0
public DateTimeField year() { return UnsupportedDateTimeField.getInstance(DateTimeFieldType.year(), years()); }	Get the year field for this chronology.	0	1
public ProjectRel createNewProject(RelNode projChild, int[] adjustments) { List<Pair<RexNode, String>> projects = new ArrayList<Pair<RexNode, String>>(); if (origProj != null) { for (Pair<RexNode, String> p : origProj.getNamedProjects()) { projects.add( Pair.of( convertRefsAndExprs( p.left, projChild.getRowType().getFieldList(), adjustments), p.right)); } } else { for (Ord<RelDataTypeField> field : Ord.zip(childFields)) { projects.add( Pair.of( (RexNode) rexBuilder.makeInputRef( field.e.getType(), field.i), field.e.getName())); } } return (ProjectRel) CalcRel.createProject( projChild, Pair.left(projects), Pair.right(projects), true /* optimize to avoid trivial projections, as per javadoc */); }	Creates a new projection based on the original projection, adjusting all input refs using an adjustment array passed in.	0	1
"private boolean searchForButton(String regex, int matches) { sleeper.sleep(); inst.waitForIdleSync(); Pattern p = Pattern.compile(regex); Matcher matcher; ArrayList<Button> buttonList = viewFetcher.getCurrentViews(Button.class); if(matches == 0) matches = 1; for(Button button : buttonList){ matcher = p.matcher(button.getText().toString()); if(matcher.find()){ countMatches++; } if (countMatches == matches) { countMatches = 0; return true; } } if (scroller.scroll(Scroller.Direction.DOWN)) { return searchForButton(regex, matches); } else { if (countMatches > 0) Log.d(LOG_TAG, "" There are only "" + countMatches + "" matches of "" + regex); countMatches = 0; return false; } }"	Searches for a button with the given search string and returns true if the searched button is found a given number of times	1	0
"public Action doCometSupport(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException { req.setAttribute(BROADCASTER_FACTORY, broadcasterFactory); req.setAttribute(PROPERTY_USE_STREAM, useStreamForFlushingComments); req.setAttribute(BROADCASTER_CLASS, broadcasterClassName); req.setAttribute(ATMOSPHERE_CONFIG, config); AtmosphereRequest r = null; Action a = null; try { if (config.getInitParameter(ALLOW_QUERYSTRING_AS_REQUEST) != null && (isIECandidate(req) || req.getParameter(HeaderConfig.JSONP_CALLBACK_NAME) != null) && req.getAttribute(WebSocket.WEBSOCKET_SUSPEND) == null) { Map<String, String> headers = configureQueryStringAsRequest(req); String body = headers.remove(ATMOSPHERE_POST_BODY); if (body != null && body.isEmpty()) { body = null; } r = new AtmosphereRequest.Builder() .headers(headers) .method(body != null && req.getMethod().equalsIgnoreCase(""GET"") ? ""POST"" : req.getMethod()) .body(body) .request(req).build(); a = cometSupport.service(r, res); } else { if (AtmosphereRequest.class.isAssignableFrom(req.getClass())) { return cometSupport.service(req, res); } else { return cometSupport.service(AtmosphereRequest.wrap(req), res); } } } catch (IllegalStateException ex) { if (ex.getMessage() != null && ex.getMessage().startsWith(""Tomcat failed"")) { if (!isFilter) { logger.warn(""Failed using comet support: {}, error: {} Is the Nio or Apr Connector enabled?"", cometSupport.getClass().getName(), ex.getMessage()); logger.warn(""Using BlockingIOCometSupport.""); } logger.trace(ex.getMessage(), ex); cometSupport = new BlockingIOCometSupport(config); doCometSupport(req, res); } else { logger.error(""AtmosphereServlet exception"", ex); throw ex; } } finally { if (r != null && a != null && a.type != Action.TYPE.SUSPEND) { r.destroy(); } } return null; }"	Invoke the proprietary CometSupport	0	1
"public Mono<Order> getOrderById(Long orderId) throws RestClientException { Object postBody = null; // verify the required parameter 'orderId' is set if (orderId == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'orderId' when calling getOrderById""); } // create path and map variables final Map<String, Object> uriVariables = new HashMap<String, Object>(); uriVariables.put(""order_id"", orderId); String path = UriComponentsBuilder.fromPath(""/store/order/{order_id}"").buildAndExpand(uriVariables).toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { ""application/xml"", ""application/json"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<Order> returnType = new ParameterizedTypeReference<Order>() {}; return apiClient.invokeAPI(path, HttpMethod.GET, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType); }"	Find purchase order by ID	0	1
"@Processor @OAuthProtected @OAuthInvalidateAccessTokenOn(exception=OAuthTokenExpiredException.class) @Paged public PagingDelegate<File> listFiles( final @Optional @Default(""100"") int maxResults, final @Optional String query, final PagingConfiguration pagingConfiguration) throws IOException { return new TokenBasedPagingDelegate<File>() { @Override public List<File> doGetPage() throws IOException { FileList response = client.files().list() .setMaxResults(maxResults) .setPageToken(this.getPageToken()) .setQ(query) .execute(); this.setPageToken(response.getNextPageToken()); return File.valueOf(response.getItems(), File.class); } }; }"	Lists the user's files.	1	0
protected Object convertDurationToMicroseconds(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0L; } try { if (data instanceof Duration) return ((Duration) data).toNanos() / 1_000; } catch (IllegalArgumentException e) { return handleUnknownData(column, fieldDefn, data); } return handleUnknownData(column, fieldDefn, data); }	Converts a value object for an expected type of java.time.Duration to Long values that represents the time in microseconds.	0	1
private boolean selectFirstItemIfNoneSelected() { if (selectedItem == null) { for (MenuItem nextItem : items) { if (nextItem.isEnabled() && nextItem.isVisible()) { selectItem(nextItem); return true; } } for (MenuItem nextItem : items) { if (nextItem.isVisible()) { selectItem(nextItem); return true; } } return true; } return false; }	Selects the first item in the menu if no items are currently selected.	0	1
protected Function<?,?> getTypeFunction(Class<?> aType) { return (Function<?,?>) defaultFunctions.get(aType); }	Returns a applyer for the given primitive type.	1	0
public static int killProcess(Process process) { if (thisIsWindows()) { return killWinProcess(process); } else { return killUnixProcess(process); } }	"Forcibly kills a process, using OS tools like ""kill"" as a last resort"	0	1
protected Object convertBoolean(Column column, Field fieldDefn, Object data) { return convertValue(column, fieldDefn, data, false, (r) -> { if (data instanceof Boolean) { r.deliver(data); } else if (data instanceof Short) { r.deliver(((Short) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE); } else if (data instanceof Integer) { r.deliver(((Integer) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE); } else if (data instanceof Long) { r.deliver(((Long) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE); } }); }	Converts a value object for an expected JDBC type of Types#BOOLEAN.	0	1
public boolean isSupported(DateTimeFieldType type) { if (type == null) { return false; } return isSupported(type.getDurationType()); }	Checks if the field type specified is supported by this local datetime and chronology.	1	0
public boolean waitForText(String text, int minimumNumberOfMatches, long timeout, boolean scroll) { TextView textView = waiter.waitForText(text, minimumNumberOfMatches, timeout, scroll); return textView != null; }	Waits for a text to be shown.	0	1
"public boolean isRcsAssociated(final String phoneNumber) { boolean result = false; Cursor cur = ctx.getContentResolver().query(RichAddressBookData.CONTENT_URI, new String[]{RichAddressBookData.KEY_CONTACT_NUMBER}, RichAddressBookData.KEY_CONTACT_NUMBER + ""=?"", new String[]{phoneNumber}, null); if (cur!=null){ if (cur.moveToFirst()) { result = true; } cur.close(); }else{ result = false; } return result; }"	Utility to check if a phone number is associated to a RCS account	1	0
private ZapTextField getTxtPattern() { if (txtPattern == null) { txtPattern = new ZapTextField(); } return txtPattern; }	This method initializes txtPattern	0	1
public String executeAs(Function<Response, Response> handler) { Type type = new TypeToken<String>(){}.getType(); return execute(handler).as(type); }	POST /fake/outer/string	0	1
public JobInstance cancel(@PathVariable String jobId) { try { final JobInstance jobInstance = jobService.getJobInstance(jobId); jobService.cancelJob(jobInstance); return jobService.getJobInstance(jobId); } catch (Exception e) { logger.error(e.getLocalizedMessage(), e); throw new InternalErrorException(e); } }	Cancel/discard a job	0	1
"public Object getValue(String columnName, PostgresType type, String fullType, Value rawValue, final PgConnectionSupplier connection, boolean includeUnknownDatatypes) { if (rawValue.isNull()) { // nulls are null return null; } if (type.isArrayType()) { try { final String dataString = rawValue.asString(); PgArray arrayData = new PgArray(connection.get(), type.getOid(), dataString); Object deserializedArray = arrayData.getArray(); return Arrays.asList((Object[])deserializedArray); } catch (SQLException e) { LOGGER.warn(""Unexpected exception trying to process PgArray ({}) column '{}', {}"", fullType, columnName, e); } return null; } switch (type.getName()) { // include all types from https://www.postgresql.org/docs/current/static/datatype.html#DATATYPE-TABLE // plus aliases from the shorter names produced by older wal2json case ""boolean"": case ""bool"": return rawValue.asBoolean(); case ""integer"": case ""int"": case ""int4"": case ""smallint"": case ""int2"": case ""smallserial"": case ""serial"": case ""serial2"": case ""serial4"": case ""oid"": return rawValue.asInteger(); case ""bigint"": case ""bigserial"": case ""int8"": return rawValue.asLong(); case ""real"": case ""float4"": return rawValue.isNumber() ? rawValue.asFloat() : Float.valueOf(rawValue.asString()); case ""double precision"": case ""float8"": return rawValue.isNumber() ? rawValue.asDouble() : Double.valueOf(rawValue.asString()); case ""numeric"": case ""decimal"": if (rawValue.isInteger()) { return new SpecialValueDecimal(new BigDecimal(rawValue.asInteger())); } else if (rawValue.isLong()) { return new SpecialValueDecimal(new BigDecimal(rawValue.asLong())); } else if (rawValue.isBigInteger()) { return new SpecialValueDecimal(new BigDecimal(rawValue.asBigInteger())); } return SpecialValueDecimal.valueOf(rawValue.asString()); case ""character"": case ""char"": case ""character varying"": case ""varchar"": case ""bpchar"": case ""text"": return rawValue.asString(); case ""date"": return DateTimeFormat.get().date(rawValue.asString()); case ""timestamp with time zone"": case ""timestamptz"": return DateTimeFormat.get().timestampWithTimeZone(rawValue.asString()); case ""timestamp"": case ""timestamp without time zone"": final LocalDateTime serverLocal = Conversions.fromNanosToLocalDateTimeUTC(DateTimeFormat.get().timestamp(rawValue.asString())); final Instant utc = serverLocal.atOffset(serverTimezone).toInstant(); return Conversions.toEpochNanos(utc); case ""time"": case ""time without time zone"": return DateTimeFormat.get().time(rawValue.asString()); case ""time with time zone"": case ""timetz"": return DateTimeFormat.get().timeWithTimeZone(rawValue.asString()); case ""bytea"": return Strings.hexStringToByteArray(rawValue.asString()); // these are all PG-specific types and we use the JDBC representations // note that, with the exception of point, no converters for these types are implemented yet, // i.e. those values won't actually be propagated to the outbound message until that's the case case ""box"": try { return new PGbox(rawValue.asString()); } catch (final SQLException e) { LOGGER.error(""Failed to parse point {}, {}"", rawValue.asString(), e); throw new ConnectException(e); } case ""circle"": try { return new PGcircle(rawValue.asString()); } catch (final SQLException e) { LOGGER.error(""Failed to parse circle {}, {}"", rawValue.asString(), e); throw new ConnectException(e); } case ""interval"": try { return new PGInterval(rawValue.asString()); } catch (final SQLException e) { LOGGER.error(""Failed to parse point {}, {}"", rawValue.asString(), e); throw new ConnectException(e); } case ""line"": try { return new PGline(rawValue.asString()); } catch (final SQLException e) { LOGGER.error(""Failed to parse point {}, {}"", rawValue.asString(), e); throw new ConnectException(e); } case ""lseg"": try { return new PGlseg(rawValue.asString()); } catch (final SQLException e) { LOGGER.error(""Failed to parse point {}, {}"", rawValue.asString(), e); throw new ConnectException(e); } case ""money"": try { return new PGmoney(rawValue.asString()).val; } catch (final SQLException e) { LOGGER.error(""Failed to parse money {}, {}"", rawValue.asString(), e); throw new ConnectException(e); } case ""path"": try { return new PGpath(rawValue.asString()); } catch (final SQLException e) { LOGGER.error(""Failed to parse point {}, {}"", rawValue.asString(), e); throw new ConnectException(e); } case ""point"": try { return new PGpoint(rawValue.asString()); } catch (final SQLException e) { LOGGER.error(""Failed to parse point {}, {}"", rawValue.asString(), e); throw new ConnectException(e); } case ""polygon"": try { return new PGpolygon(rawValue.asString()); } catch (final SQLException e) { LOGGER.error(""Failed to parse point {}, {}"", rawValue.asString(), e); throw new ConnectException(e); } // PostGIS types are HexEWKB strings // ValueConverter turns them into the correct types case ""geometry"": case ""geography"": return rawValue.asString(); case ""bit"": case ""bit varying"": case ""varbit"": case ""json"": case ""jsonb"": case ""xml"": case ""uuid"": case ""tstzrange"": return rawValue.asString(); // catch-all for other known/builtin PG types // TODO: improve with more specific/useful classes here? case ""cidr"": case ""inet"": case ""macaddr"": case ""macaddr8"": case ""pg_lsn"": case ""tsquery"": case ""tsvector"": case ""txid_snapshot"": // catch-all for unknown (extension module/custom) types default: break; } if (includeUnknownDatatypes) { // this includes things like PostGIS geometries or other custom types. // leave up to the downstream message recipient to deal with. LOGGER.debug(""processing column '{}' with unknown data type '{}' as byte array"", columnName, fullType); return rawValue.asString(); } LOGGER.debug(""Unknown column type {} for column {} âÂ ignoring"", fullType, columnName); return null; }"	Converts the value (string representation) coming from wal2json plugin to a Java value based on the type of the column from the message.	0	1
public URL getRoot() { return rootUrl; }	Gets the root.	1	0
"protected PingResult parse(int exitValue, List<String> outLines,List<String> errLines) { PingResult info = new PingResult(); Pattern roundTripTimePat = Pattern.compile(RTT_REG_EX); Pattern transmitReceivePat = Pattern.compile(TRANSMITTED_RECEIVED_REG_EX); Pattern noRouteToHostPat = Pattern.compile(NO_ROUTE_TO_HOST_REG_EX); Pattern unknownHostPat = Pattern.compile(UNKNOWN_HOST_REG_EX); info.setHost(getHost()); // Parse the output based on exit value of ping switch (exitValue) { // Clean exit case 0: // Extract the RTT times for (String line : outLines) { Matcher matcher = roundTripTimePat.matcher(line); if (matcher.find()) { info.setRTTMin(Double.parseDouble(matcher.group(1))); info.setRTTAvg(Double.parseDouble(matcher.group(2))); info.setRTTMax(Double.parseDouble(matcher.group(3))); info.setRTTMDev(Double.parseDouble(matcher.group(4))); } } // Extract the transmit and received counts for (String line : outLines) { Matcher matcher = transmitReceivePat.matcher(line); if (matcher.find()) { info.setTransmitted(Integer.parseInt(matcher.group(1))); info.setReceived(Integer.parseInt(matcher.group(2))); } } // If no ICMP packages are returned then consider the test failed if (info.getReceived() == 0) { info.setStatus(ServiceStatus.FAIL); } else { info.setStatus(ServiceStatus.SUCCESS); } break; // Error case: 1) Unable to resolve host ; 2) Host unreachable case 1: case 2: case 68: for (String line : outLines) { Matcher matcher = transmitReceivePat.matcher(line); if (matcher.find()) { info.setTransmitted(Integer.parseInt(matcher.group(1))); info.setReceived(Integer.parseInt(matcher.group(2))); } } for (String line: errLines) { Matcher matcher = unknownHostPat.matcher(line); if (matcher.find()) { info.setMessage(matcher.group(1)); } } info.setStatus(ServiceStatus.FAIL); break; default: assert false: ""Unknown exit code""; } return info; }"	Parses the output of ping and populates a instance of PingInfo	1	0
public RepoPackageVersion removePackageVersion(PackageVersion packageVersion) { if ((this.repoPackageVersions == null) || (packageVersion == null)) { return null; } RepoPackageVersion doomed = null; for (RepoPackageVersion cpv : this.repoPackageVersions) { if (packageVersion.equals(cpv.getRepoPackageVersionPK().getPackageVersion())) { doomed = cpv; break; } } if (doomed != null) { this.repoPackageVersions.remove(doomed); } return doomed; }	Removes the package version from this channel, if it exists.	1	0
"public static Bind parse(String serialized) { try { String[] parts = serialized.split("":""); switch (parts.length) { case 2: { return new Bind(parts[0], Volume.parse(parts[1])); } case 3: { AccessMode accessMode = AccessMode.valueOf(parts[2].toLowerCase()); return new Bind(parts[0], Volume.parse(parts[1]), accessMode); } default: { throw new IllegalArgumentException(); } } } catch (Exception e) { throw new IllegalArgumentException(""Error parsing Bind '"" + serialized + ""'""); } }"	Parses a bind mount specification to a Bind.	0	1
"public static String getLastBaselineBuild(String date) { if (BUILDS == null) { queryAllVariations(""%""); //$NON-NLS-1$ } if (date == null) return LAST_BASELINE_BUILD; String lastBaselineBuild = null; for (int i=0; i<BUILDS_LENGTH; i++) { String build = BUILDS[i]; if (build.startsWith(AbstractResults.VERSION_REF)) { String buildDate = build.substring(build.indexOf('_')+1); if (buildDate.compareTo(date) < 0) { if (lastBaselineBuild == null || build.compareTo(lastBaselineBuild) > 0) { lastBaselineBuild = build; } } } } return lastBaselineBuild; }"	Return the ID of the last baseline build.	1	0
public MainWindowBase getSleakWindow() { //<DEBUG to find undisposed system resources> DeviceData data = new DeviceData(); data.tracking = true; Display display = new Display(data); Sleak sleak = new Sleak(); sleak.open(); Shell shell = new Shell(display); window = new MainWindowBase(shell); return window; //</DEBUG> }	Initiates an instance of MainWindow that is monitored by Sleak.java, to monitor what handles (to OS device context) are in use.	1	0
protected Object convertBoolean(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return false; } if (data instanceof Boolean) return data; if (data instanceof Short) return ((Short) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE; if (data instanceof Integer) return ((Integer) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE; if (data instanceof Long) return ((Long) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE; return handleUnknownData(column, fieldDefn, data); }	Converts a value object for an expected JDBC type of Types#BOOLEAN.	0	1
public DateTimeField yearOfEra() { return UnsupportedDateTimeField.getInstance(DateTimeFieldType.yearOfEra(), years()); }	Get the year of era field for this chronology.	0	1
"public Map<String,InternalPortletPreference> getStoredPreferences( PortletWindow portletWindow, PortletRequest request) throws PortletContainerException { String key = getFormattedKey(portletWindow, request); Map<String,InternalPortletPreference> preferences = storage.get(key); if (preferences == null) { if (LOG.isDebugEnabled()) { LOG.debug(""No portlet preferences found for: "" + key); } return Collections.emptyMap(); } else { if (LOG.isDebugEnabled()) { LOG.debug(""Got "" + preferences.size() + "" stored preferences.""); } return clonePreferences(preferences); } }"	Returns the stored portlet preferences array.	1	0
"public Tree transformTree(Tree t) { if (VERBOSE) { System.err.println(""Input to CoordinationTransformer: "" + t); } Tree tx = tn.transformTree(t); if (VERBOSE) { System.err.println(""After DependencyTreeTransformer: "" + tx); } if (tx == null) { return tx; } Tree tt = UCPtransform(tx); if (VERBOSE) { System.err.println(""After UCPTransformer: "" + tt); } Tree ttt = CCtransform(tt); if (VERBOSE) { System.err.println(""After CCTransformer: "" + ttt); } Tree tttt = qp.transformTree(ttt); if (VERBOSE) { System.err.println(""After QPTreeTransformer: "" + tttt); } Tree flatSQ = SQflatten(tttt); if (VERBOSE) { System.err.println(""After SQ flattening: "" + flatSQ); } Tree fixedDates = dates.transformTree(flatSQ); if (VERBOSE) { System.err.println(""After DateTreeTransformer: "" + fixedDates); } Tree removedXX = removeXOverX(fixedDates); if (VERBOSE) { System.err.println(""After removeXoverX: "" + removedXX); } Tree conjp = combineConjp(removedXX); if (VERBOSE) { System.err.println(""After combineConjp: "" + conjp); } return conjp; }"	Transforms t if it contains a coordination in a flat structure (CCtransform) and transforms UCP (UCPtransform).	0	1
public Float getBottomValue() { return bottomValue; }	Gets the 'bottom' CSS-attributes value in specified units.	1	0
public Builder argument(GraphQLArgument.Builder builder) { return argument(builder.build()); }	Same effect as the argument(GraphQLArgument).	0	1
public DateTimeFormatterBuilder appendHourOfDay(int minDigits) { return appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2); }	Instructs the printer to emit a numeric hourOfDay field.	0	1
public String getAsText(long instant, Locale locale) { return getAsText(get(instant)); }	Get the human-readable, text value of this field from the milliseconds.	0	1
"private String buildRemoveVideoSdpProposal() { if (logger.isActivated()) { logger.debug(""Build SDP proposal to remove video stream from the session""); } try { // Build SDP part String ntpTime = SipUtils.constructNTPtime(System.currentTimeMillis()); String ipAddress = getDialogPath().getSipStack().getLocalIpAddress(); getAudioPlayer().getLocalRtpPort(); String audioSdp = AudioSdpBuilder.buildSdpOffer(getAudioPlayer().getSupportedAudioCodecs(), getAudioPlayer().getLocalRtpPort()); return ""v=0"" + SipUtils.CRLF + ""o=- "" + ntpTime + "" "" + ntpTime + "" "" + SdpUtils.formatAddressType(ipAddress) + SipUtils.CRLF + ""s=-"" + SipUtils.CRLF + ""c="" + SdpUtils.formatAddressType(ipAddress) + SipUtils.CRLF + ""t=0 0"" + SipUtils.CRLF + audioSdp + ""a=sendrcv"" + SipUtils.CRLF; } catch (RemoteException e) { if (logger.isActivated()) { logger.error(""Remove video has failed"", e); } // Unexpected error handleError(new IPCallError(IPCallError.UNEXPECTED_EXCEPTION, e.getMessage())); return null; } }"	Build sdp proposal for removeVideo	1	0
public ResponseEntity<String> finishPasswordReset(@RequestBody KeyAndPasswordVM keyAndPassword) { if (!checkPasswordLength(keyAndPassword.getNewPassword())) { return new ResponseEntity<>(CHECK_ERROR_MESSAGE, HttpStatus.BAD_REQUEST); } return userService.completePasswordReset(keyAndPassword.getNewPassword(), keyAndPassword.getKey()) .map(user -> new ResponseEntity<String>(HttpStatus.OK)) .orElse(new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR)); }	POST /account/reset_password/finish : Finish to reset the password of the user	0	1
public List<RelDataType> collectOperandTypes() { return new AbstractList<RelDataType>() { public RelDataType get(int index) { return getOperandType(index); } public int size() { return getOperandCount(); } }; }	Collects the types of the bound operands into an array.	1	0
"public Symbol generate(Schema sc, Map<LitS, Symbol> seen) { switch (sc.getType()) { case NULL: case BOOLEAN: case INT: case LONG: case FLOAT: case DOUBLE: case STRING: case BYTES: case FIXED: case UNION: return super.generate(sc, seen); case ENUM: return Symbol.seq(Symbol.enumLabelsAction(sc.getEnumSymbols()), Symbol.ENUM); case ARRAY: return Symbol.seq(Symbol.repeat(Symbol.ARRAY_END, Symbol.ITEM_END, generate(sc.getElementType(), seen)), Symbol.ARRAY_START); case MAP: return Symbol.seq(Symbol.repeat(Symbol.MAP_END, Symbol.ITEM_END, generate(sc.getValueType(), seen), Symbol.MAP_KEY_MARKER, Symbol.STRING), Symbol.MAP_START); case RECORD: { LitS wsc = new LitS(sc); Symbol rresult = seen.get(wsc); if (rresult == null) { Symbol[] production = new Symbol[sc.getFields().size() * 3 + 2]; rresult = Symbol.seq(production); seen.put(wsc, rresult); int i = production.length; int n = 0; production[--i] = Symbol.RECORD_START; for (Field f : sc.getFields()) { production[--i] = Symbol.fieldAdjustAction(n, f.name()); production[--i] = generate(f.schema(), seen); production[--i] = Symbol.FIELD_END; n++; } production[--i] = Symbol.RECORD_END; } return rresult; } default: throw new RuntimeException(""Unexpected schema type""); } }"	Returns the non-terminal that is the start symbol for grammar of the given schema sc.	0	1
public String getName() { return this.fullName; }	Returns the name of the element.	1	0
"public int destroy() { ExecuteWatchdog watchdog = executor.getWatchdog(); while (!watchdog.isWatching()){ try { Thread.sleep(50); } catch (InterruptedException e) { throw new WebDriverException(e); } } watchdog.destroyProcess(); if (handler.hasResult()) { return getExitCode(); } log.info(""Process destruction entered a last-ditch phase that shouldn't happen. File an issue if you see this message""); // Give the process a chance to die naturally. quiesceFor(3, SECONDS); if (!handler.hasResult()) { log.info( ""Command failed to close cleanly. Destroying forcefully. "" + this); ProcessUtils.killProcess(snitch.getProcess()); quiesceFor(1, SECONDS); } int exitCode; if (!handler.hasResult()) { log.severe(String.format( ""Unable to kill process with PID %s: %s"", snitch.getProcess(), this)); exitCode = -1; executor.setExitValue(exitCode); } else { exitCode = getExitCode(); } postRunCleanup(); return exitCode; }"	Destroy the current command.	0	1
"protected String[] usualWindowsLauncherLocations() { return new String[] { WindowsUtils.getLocalAppDataPath() + ""\\Google\\Chrome\\Application"", WindowsUtils.getProgramFiles86Path() + ""\\Google\\Chrome\\Application"", WindowsUtils.getProgramFilesPath() + ""\\Google\\Chrome\\Application"" }; }"	Returns usual Google Chrome installation location on Windows.	0	1
private ZapTextField getTxtReverseProxyIp() { if (txtReverseProxyIp == null) { txtReverseProxyIp = new ZapTextField(); } return txtReverseProxyIp; }	This method initializes txtProxyIpSSL	0	1
public final int getColumn() { return this.bufcolumn[this.bufpos]; }	DOCUMENT ME!	1	0
private ZapTextField getTxtProxyPort() { if (txtProxyPort == null) { txtProxyPort = new ZapTextField(); } return txtProxyPort; }	This method initializes txtProxyPort	0	1
"private static Consumer<List> mongoChecker(final String... expected) { return actual -> { if (expected == null) { Assert.assertThat(""null mongo Query"", actual, CoreMatchers.nullValue()); return; } if (expected.length == 0) { CalciteAssert.assertArrayEqual(""empty Mongo query"", expected, actual.toArray(new Object[0])); return; } final BsonDocument expectedBson = BsonDocument.parse(String.join("","", expected)); final BsonDocument actualBson = BsonDocument.parse(((List<?>) actual.get(0)) .stream() .map(Objects::toString) .collect(Collectors.joining(""\n""))); // compare Bson (not string) representation if (!expectedBson.equals(actualBson)) { final JsonWriterSettings settings = JsonWriterSettings.builder().indent(true).build(); // used to pretty print Assertion error Assert.assertEquals(""expected and actual Mongo queries do not match"", expectedBson.toJson(settings), actualBson.toJson(settings)); Assert.fail(""Should have failed previously because (expected != actual) is already known""); } }; }"	Returns a function that checks that a particular MongoDB pipeline is generated to implement a query.	1	0
public TopicPublisher createPublisher(Topic topic) throws JMSException { checkClosed(); if (topic instanceof CustomDestination) { CustomDestination customDestination = (CustomDestination) topic; return customDestination.createPublisher(this); } return new ActiveMQTopicPublisher(this, ActiveMQMessageTransformation.transformDestination(topic)); }	Creates a publisher for the specified topic.	0	1
public Component[] getChildren() { ensureZOrder(); Component[] c = new Component[children.size()]; return (Component[])children.toArray(c); }	Returns an array of this SuiContainer's children.	1	0
"public boolean addFile(File sourceFile) { String filename = sourceFile.getName(); File destFile = null; String codeExtension = null; boolean replacement = false; // if the file appears to be code related, drop it // into the code folder, instead of the data folder if (filename.toLowerCase().endsWith("".class"") || filename.toLowerCase().endsWith("".jar"") || filename.toLowerCase().endsWith("".dll"") || filename.toLowerCase().endsWith("".jnilib"") || filename.toLowerCase().endsWith("".so"")) { //if (!codeFolder.exists()) codeFolder.mkdirs(); prepareCodeFolder(); destFile = new File(codeFolder, filename); } else { for (String extension : mode.getExtensions()) { String lower = filename.toLowerCase(); if (lower.endsWith(""."" + extension)) { destFile = new File(this.folder, filename); codeExtension = extension; } } if (codeExtension == null) { prepareDataFolder(); destFile = new File(dataFolder, filename); } } // check whether this file already exists if (destFile.exists()) { Object[] options = { Language.text(""prompt.ok""), Language.text(""prompt.cancel"") }; String prompt = Language.interpolate(""add_file.messages.confirm_replace"", filename); int result = JOptionPane.showOptionDialog(editor, prompt, ""Replace"", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options[0]); if (result == JOptionPane.YES_OPTION) { replacement = true; } else { return false; } } // If it's a replacement, delete the old file first, // otherwise case changes will not be preserved. // http://dev.processing.org/bugs/show_bug.cgi?id=969 if (replacement) { boolean muchSuccess = destFile.delete(); if (!muchSuccess) { Base.showWarning(Language.text(""add_file.messages.error_adding""), Language.interpolate(""add_file.messages.cannot_delete.description"", filename), null); return false; } } // make sure they aren't the same file if ((codeExtension == null) && sourceFile.equals(destFile)) { Base.showWarning(Language.text(""add_file.messages.same_file""), Language.text(""add_file.messages.same_file.description""), null); return false; } // Handles ""Add File"" when a .pde is used. For beta 1, this no longer runs // on a separate thread because it's totally unnecessary (a .pde file is // not going to be so large that it's ever required) and otherwise we have // to introduce a threading block here. // https://github.com/processing/processing/issues/3383 if (!sourceFile.equals(destFile)) { try { Base.copyFile(sourceFile, destFile); } catch (IOException e) { Base.showWarning(Language.text(""add_file.messages.error_adding""), Language.interpolate(""add_file.messages.cannot_add.description"", filename), e); return false; } } if (codeExtension != null) { SketchCode newCode = new SketchCode(destFile, codeExtension); if (replacement) { replaceCode(newCode); } else { insertCode(newCode); sortCode(); } setCurrentCode(filename); editor.header.repaint(); if (isUntitled()) { // TODO probably not necessary? problematic? // Mark the new code as modified so that the sketch is saved current.setModified(true); } } else { if (isUntitled()) { // TODO probably not necessary? problematic? // If a file has been added, mark the main code as modified so // that the sketch is properly saved. code[0].setModified(true); } } return true; }"	Add a file to the sketch.	0	1
public final boolean hasValidResults() { return getLastAction() != null; }	Returns whether we have enough valid results in order to draw a meaningful graph.	1	0
public Button getButton(String text) { return getter.getView(Button.class, text, false); }	Returns a Button which shows a given text.	0	1
"public static W3CWidget getWidget(String metadata, String shindig) throws Exception{ JSONObject gadget = null; JSONObject response = new JSONObject(metadata); JSONArray gadgets = response.getJSONArray(""gadgets""); if (gadgets.length()==0) return null; gadget = gadgets.getJSONObject(0); return new GadgetAdapter(gadget, shindig); }"	Marshall JSON metadata into a new Widget instance	1	0
private ObjectAnimator createNullAnimator(ImageView imageView) { return AnimatorUtils.ofObject(createMatrixProperty(imageView), new MatrixUtils.NullMatrixEvaluator(), MatrixUtils.IDENTITY_MATRIX, MatrixUtils.IDENTITY_MATRIX); }	Creates an Animator for ImageViews moving, changing dimensions, and/or changing android.widget.ImageView.ScaleType.	0	1
"public static String getId( final Widget widget ) { // TODO [rh] consider overriding the id when Widget#setData is called // - safer 1: in case someone tries to obtain id directly from addapter // - safer 2: changing the id after widget was initialized could be // detected and prevented // - less memory: new HashMap created per widget to hold the id // - illegal id's could be rejected immediately (close to error source) // - faster (?): only ""return getAdapter( widget ).getId();"" in here String result = ( String )widget.getData( CUSTOM_WIDGET_ID ); if( result == null ) { result = getAdapter( widget ).getId(); } return result; }"	Returns the id of the widget that is used to identify the widget on the client.	1	0
public Node parseXML(String text, Document doc) { return null; }	Parses the given XML string into a DocumentFragment of the given document.	1	0
public static String encodeValue(Value value) { if (value instanceof BNode) { // SES-2129 special treatment of blank node names to avoid problems with round-tripping. return ((BNode)value).getID(); } // for everything else we just use N-Triples serialization. return NTriplesUtil.toNTriplesString(value); }	Encodes a value for use in a URL.	1	0
private boolean isShareable() { return getRequestScope().getDictionary().isSharable(obj.getClass()); }	Checks if this persistent resource's underlying entity has the @Shareable annotation.	1	0
"private Bitmap getWidgetPreview(AppWidgetProviderInfo info) { final PackageManager packageManager = mPackageManager; String packageName = info.provider.getPackageName(); Drawable drawable = null; if (info.previewImage != 0) { drawable = packageManager.getDrawable(packageName, info.previewImage, null); if (drawable == null) { Log.w(TAG, ""Can't load icon drawable 0x"" + Integer.toHexString(info.icon) + "" for provider: "" + info.provider); } } // If we don't have a preview image, create a default one if (drawable == null) { Resources resources = mLauncher.getResources(); // Create a new bitmap to hold the widget preview int width = (int) (Math.max(mMinWidgetPreviewDim, Math.min(mMaxWidgetPreviewDim, info.minWidth)) * sScaleFactor); int height = (int) (Math.max(mMinWidgetPreviewDim, Math.min(mMaxWidgetPreviewDim, info.minHeight)) * sScaleFactor); final Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888); final Drawable background = resources.getDrawable(R.drawable.default_widget_preview); renderDrawableToBitmap(background, bitmap, 0, 0, width, height, 1.0f, 1.0f); // Draw the icon flush left try { Drawable icon = null; if (info.icon > 0) { icon = packageManager.getDrawable(packageName, info.icon, null); } if (icon == null) { icon = resources.getDrawable(R.drawable.ic_launcher_application); } final int iconSize = mMinWidgetPreviewDim / 2; final int offset = iconSize / 4; renderDrawableToBitmap(icon, null, offset, offset, iconSize, iconSize, 1.0f, 1.0f); } catch (Resources.NotFoundException e) { // if we can't find the icon, then just don't draw it } return bitmap; } else { // Scale down the preview if necessary final float imageWidth = drawable.getIntrinsicWidth(); final float imageHeight = drawable.getIntrinsicHeight(); final float aspect = (float) imageWidth / imageHeight; final int scaledWidth = (int) (Math.max(mMinWidgetPreviewDim, Math.min(mMaxWidgetPreviewDim, imageWidth)) * sScaleFactor); final int scaledHeight = (int) (Math.max(mMinWidgetPreviewDim, Math.min(mMaxWidgetPreviewDim, imageHeight)) * sScaleFactor); int width; int height; if (aspect >= 1.0f) { width = scaledWidth; height = (int) (((float) scaledWidth / imageWidth) * imageHeight); } else { height = scaledHeight; width = (int) (((float) scaledHeight / imageHeight) * imageWidth); } final Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888); renderDrawableToBitmap(drawable, bitmap, 0, 0, width, height, 1.0f, 1.0f); return bitmap; } }"	This method will extract the preview image specified by the widget developer (if it exists), otherwise, it will try to generate a default image preview with the widget's package icon.	0	1
private String checkSubElementsNullability(Type propertyType, Object value) throws HibernateException { if ( propertyType.isComponentType() ) { return checkComponentNullability( value, (CompositeType) propertyType ); } if ( propertyType.isCollectionType() ) { // persistent collections may have components final CollectionType collectionType = (CollectionType) propertyType; final Type collectionElementType = collectionType.getElementType( session.getFactory() ); if ( collectionElementType.isComponentType() ) { // check for all components values in the collection final CompositeType componentType = (CompositeType) collectionElementType; final Iterator itr = CascadingActions.getLoadedElementsIterator( session, collectionType, value ); while ( itr.hasNext() ) { final Object compositeElement = itr.next(); if ( compositeElement != null ) { return checkComponentNullability( compositeElement, componentType ); } } } } return null; }	check sub elements-nullability.	0	1
public RepositoryMethodMetadata lookupMethod(RepositoryMetadata repositoryMetadata, Method method) { return repositoryMetadata.getMethodsMetadata().get(method); }	Repository access - lookup method information for a specific Repository class.	1	0
"private static String stringify(Object obj) { if (obj instanceof DERString) { return escapeHtml(((DERString) obj).getString()); } // TODO: why not DERInteger as number? else if (obj instanceof DERInteger || obj instanceof byte[]) { return convertToHexString(obj); } else if (obj instanceof ASN1TaggedObject) { ASN1TaggedObject tagObj = (ASN1TaggedObject) obj; // Note: ""["", _not_ '[' ... return ""["" + tagObj.getTagNo() + ""] "" + stringify(tagObj.getObject()); } else if (obj instanceof ASN1Sequence) { ASN1Sequence aObj = (ASN1Sequence) obj; StringBuilder tmp = new StringBuilder(""[""); for (int i = 0, len = aObj.size(); i < len; i++) { tmp.append(stringify(aObj.getObjectAt(i))); if (i != len - 1) { tmp.append("", ""); } } return tmp.append(""]"").toString(); } else { String hex = null; try { Method method = obj.getClass().getMethod(""getOctets"", (Class[]) null); hex = convertToHexString(method.invoke(obj, (Object[]) null)); } catch (Exception e) { // Ignore } if (hex == null && obj != null) { hex = escapeHtml(obj.toString()); } return hex; } }"	Gets a string representation of the given object.	1	0
"public Document createSchemaDefinition(Map<String, Object> introspectionResult) { assertTrue(introspectionResult.get(""__schema"") != null, ""__schema expected""); Map<String, Object> schema = (Map<String, Object>) introspectionResult.get(""__schema""); Map<String, Object> queryType = (Map<String, Object>) schema.get(""queryType""); assertNotNull(queryType, ""queryType expected""); TypeName query = TypeName.newTypeName().name((String) queryType.get(""name"")).build(); boolean nonDefaultQueryName = !""Query"".equals(query.getName()); SchemaDefinition.Builder schemaDefinition = SchemaDefinition.newSchemaDefintion(); schemaDefinition.operationTypeDefinition(OperationTypeDefinition.newOperationTypeDefinition().name(""query"").type(query).build()); Map<String, Object> mutationType = (Map<String, Object>) schema.get(""mutationType""); boolean nonDefaultMutationName = false; if (mutationType != null) { TypeName mutation = TypeName.newTypeName().name((String) mutationType.get(""name"")).build(); nonDefaultMutationName = !""Mutation"".equals(mutation.getName()); schemaDefinition.operationTypeDefinition(OperationTypeDefinition.newOperationTypeDefinition().name(""mutation"").type(mutation).build()); } Map<String, Object> subscriptionType = (Map<String, Object>) schema.get(""subscriptionType""); boolean nonDefaultSubscriptionName = false; if (subscriptionType != null) { TypeName subscription = TypeName.newTypeName().name(((String) subscriptionType.get(""name""))).build(); nonDefaultSubscriptionName = !""Subscription"".equals(subscription.getName()); schemaDefinition.operationTypeDefinition(OperationTypeDefinition.newOperationTypeDefinition().name(""subscription"").type(subscription).build()); } Document.Builder document = Document.newDocument(); if (nonDefaultQueryName || nonDefaultMutationName || nonDefaultSubscriptionName) { document.definition(schemaDefinition.build()); } List<Map<String, Object>> types = (List<Map<String, Object>>) schema.get(""types""); for (Map<String, Object> type : types) { TypeDefinition typeDefinition = createTypeDefinition(type); if (typeDefinition == null) continue; document.definition(typeDefinition); } return document.build(); }"	Returns a IDL Document that reprSesents the schema as defined by the introspection result map	0	1
public WireType getWireType() { return queue.wireType(); }	Returns	1	0
public static ClassLoader defaultClassLoader() { return Thread.currentThread().getContextClassLoader(); }	Returns the Thread Context ClassLoader (TCCL).	0	1
public String registerTableOverride(String oldTable, String newTable) { return internalNameMapping.registerTableOverride(oldTable, newTable); }	Register a table override	0	1
private IDKey getIdentityKey(Object value) { return new IDKey(value); }	Get a String representation of the identity hashCode for a given	1	0
public static Log forSlf4jLogger(org.slf4j.Logger logger) { return new Log((Logger) logger); }	Returns a Log instance with the same name as the given slf4j org.slf4j.Logger instance.	0	1
public ApiResponse<Client> testClientModelWithHttpInfo(Client body) throws ApiException { okhttp3.Call localVarCall = testClientModelValidateBeforeCall(body, null, null); Type localVarReturnType = new TypeToken<Client>(){}.getType(); return localVarApiClient.execute(localVarCall, localVarReturnType); }	To test \&quot;client\&quot; model	0	1
"public static MailboxMessage<HBaseId> messageMetaFromResult(Configuration conf, Result result) { HBaseMailboxMessage message = null; Flags flags = new Flags(); List<Property> propList = new ArrayList<Property>(); KeyValue[] keys = result.raw(); String mediaType = null, subType = null; Long modSeq = null, uid, bodyOctets = null, contentOctets = null, textualLineCount = null; Date internalDate = null; int i = 0; /** it is VERY IMPORTANT that the byte arrays are kept ascending */ if (Bytes.equals(keys[i].getQualifier(), MESSAGE_BODY_OCTETS)) { bodyOctets = Bytes.toLong(keys[i].getValue()); i++; } if (Bytes.equals(keys[i].getQualifier(), MESSAGE_CONTENT_OCTETS)) { contentOctets = Bytes.toLong(keys[i].getValue()); i++; } if (Bytes.equals(keys[i].getQualifier(), MESSAGE_INTERNALDATE)) { internalDate = new Date(Bytes.toLong(keys[i].getValue())); i++; } // may be null so it will probably skip if (Bytes.equals(keys[i].getQualifier(), MESSAGE_TEXT_LINE_COUNT)) { textualLineCount = Bytes.toLong(keys[i].getValue()); i++; } if (Bytes.equals(keys[i].getQualifier(), MESSAGE_MODSEQ)) { modSeq = Bytes.toLong(keys[i].getValue()); i++; } if (Bytes.equals(keys[i].getQualifier(), MESSAGE_MEDIA_TYPE)) { mediaType = Bytes.toString(keys[i].getValue()); i++; } if (Bytes.equals(keys[i].getQualifier(), MESSAGE_SUB_TYPE)) { subType = Bytes.toString(keys[i].getValue()); i++; } // only TEXT_LINE_COUNT can be missing if message is binary if (i < 5) { throw new RuntimeException(""HBase message column names not sorted.""); } while (i < keys.length) { //get message properties if (Bytes.startsWith(keys[i].getQualifier(), PREFIX_PROP_B)) { propList.add(getProperty(keys[i].getValue())); } else if (Bytes.startsWith(keys[i].getQualifier(), PREFIX_SFLAGS_B)) { // get system flags, stored as qualifiers if (Bytes.equals(MARKER_PRESENT, keys[i].getValue())) { flags.add(systemFlagFromBytes(keys[i].getQualifier())); } } else if (Bytes.startsWith(keys[i].getQualifier(), PREFIX_UFLAGS_B)) { // get user flags, stored as value qualifier flags.add(userFlagFromBytes(keys[i].getQualifier())); } i++; } HBaseId uuid = HBaseIdFromRowKey(result.getRow()); uid = Long.MAX_VALUE - Bytes.toLong(result.getRow(), 16); PropertyBuilder props = new PropertyBuilder(propList); props.setMediaType(mediaType); props.setSubType(subType); message = new HBaseMailboxMessage(conf, uuid, internalDate, flags, contentOctets, (int) (contentOctets - bodyOctets), props); message.setUid(uid); message.setModSeq(modSeq); message.setTextualLineCount(textualLineCount); return message; }"	Creates a HBaseMessage from a Result object.	1	0
public static SchemaBuilder builder() { return SchemaBuilder.int64() .name(SCHEMA_NAME) .version(1); }	Returns a SchemaBuilder for a MicroDuration.	0	1
"private boolean searchForToggleButton(String regex, int matches) { sleeper.sleep(); inst.waitForIdleSync(); Pattern p = Pattern.compile(regex); Matcher matcher; ArrayList<ToggleButton> toggleButtonList = viewFetcher.getCurrentViews(ToggleButton.class); if(matches == 0) matches = 1; for(ToggleButton toggleButton : toggleButtonList){ matcher = p.matcher(toggleButton.getText().toString()); if(matcher.find()){ countMatches++; } if (countMatches == matches) { countMatches=0; return true; } } if (scroller.scroll(Scroller.Direction.DOWN)) { return searchForToggleButton(regex, matches); } else { if(countMatches > 0) Log.d(LOG_TAG, "" There are only "" + countMatches + "" matches of "" + regex); countMatches = 0; return false; } }"	Searches for a toggle button with the given search string and returns true if the searched toggle button is found a given number of times	1	0
public Index parseAndUpdateIndex(List<JaxbRoot<XMLEntityMappings>> mappings, Index annotationIndex) { List<XMLEntityMappings> list = new ArrayList<XMLEntityMappings>( mappings.size() ); for ( JaxbRoot<XMLEntityMappings> jaxbRoot : mappings ) { list.add( jaxbRoot.getRoot() ); } return new EntityMappingsMocker( list, annotationIndex, metadata.getServiceRegistry() ).mockNewIndex(); }	Parses the given xml configuration files and returns a updated annotation index	0	1
"public Configuration addFile(final File xmlFile) throws MappingException { log.info( ""Reading mappings from file: "" + xmlFile.getPath() ); final String name = xmlFile.getAbsolutePath(); final InputSource inputSource; try { inputSource = new InputSource( new FileInputStream( xmlFile ) ); } catch ( FileNotFoundException e ) { throw new MappingNotFoundException( ""file"", xmlFile.toString() ); } add( inputSource, ""file"", name ); return this; }"	Read mappings from a particular XML file	0	1
public boolean get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }	Analogous to #get(WithAttributes) except returning a primitive boolean.	1	0
"public Builder setHostName(String hostName) { if (hostName == null || hostName.isEmpty()) { logger.warn(""Passed in hostname is blank, not setting it""); return this; } String existingHostName = result.hostName; result.hostName = hostName; if ((existingHostName != null) && !(hostName.equals(existingHostName))) { refreshStatusPageUrl().refreshHealthCheckUrl() .refreshVIPAddress().refreshSecureVIPAddress(); } return this; }"	Sets the fully qualified hostname of this running instance.This is mostly used in constructing the java.net.URL for communicating with the instance.	0	1
public Interval overlap(ReadableInterval interval) { interval = DateTimeUtils.getReadableInterval(interval); if (overlaps(interval) == false) { return null; } long start = Math.max(getStartMillis(), interval.getStartMillis()); long end = Math.min(getEndMillis(), interval.getEndMillis()); return new Interval(start, end, getChronology()); }	Gets the overlap where this interval and that specified.	1	0
private synchronized static Supplier<Annotator> getOrCreate(AnnotatorFactory factory) { return () -> { Annotator rtn = customAnnotators.get(factory.signature()); if (rtn == null) { // Create the annotator rtn = factory.create(); // Register the annotator customAnnotators.put(factory.signature(), factory.create()); // Clean up memory if needed while (customAnnotators.size() > 10) { customAnnotators.keySet().iterator().remove(); } } return rtn; }; }	Either get a custom annotator which was recently defined, or create it if it has never been defined.	0	1
"public synchronized VisualItem getItem(String itemClass, Entity entity, boolean create) { ItemEntry entry = (ItemEntry)m_entryMap.get(itemClass); if ( entry != null ) { VisualItem item = (VisualItem)entry.itemMap.get(entity); if ( !create ) { return item; } else if ( item == null ) { item = m_ifactory.getItem(itemClass); item.init(this, itemClass, entity); addItem(entry, entity, item); } if ( item instanceof NodeItem ) ((NodeItem)item).removeAllNeighbors(); item.setDirty(0); item.setVisible(true); return item; } else { throw new IllegalArgumentException(""The input string must be a"" + "" recognized item class!""); } } //"	Requests a GraphItem of the specified item class corresponding to a given Entity, optionally creating the GraphItem if it doesn't already exist.	1	0
public Iterator<PersistentClass> getClassMappings() { return classes.values().iterator(); }	Iterate the entity mappings	0	1
public String getExportDirectory() { return this.exportDirectory; }	DOCUMENT ME!	1	0
public EurekaClient getEurekaClient() { return eurekaClient; }	Get the EurekaClient implementation.	0	1
public LookupService createLookupService() { return createLookupService(defaultEndpointUrl); }	C6reate and return a new lookup service with the default server URL.	1	0
public DateTime withFields(ReadablePartial partial) { if (partial == null) { return this; } return withMillis(getChronology().set(partial, getMillis())); }	Gets a copy of this datetime with the partial set of fields replacing those from this instance.	0	1
public String getName(long instant, Locale locale) { if (locale == null) { locale = Locale.getDefault(); } String nameKey = getNameKey(instant); if (nameKey == null) { return iID; } String name = cNameProvider.getName(locale, iID, nameKey); if (name != null) { return name; } return offsetFormatter().print(instant, this); }	Gets the long name of this datetime zone suitable for display using the specified locale.	0	1
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; // set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { // prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); // System.err.println(""At end of text making after: |"" + str + ""|""); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); // System.err.println(""prevWord is |"" + prevWord.get(CoreAnnotations.TextAnnotation.class) + ""|, its after is |"" + // prevWord.get(CoreAnnotations.AfterAnnotation.class) + ""|""); prevWordAfter.setLength(0); } return null; } } else { switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { String str = yytext(); int first = str.codePointAt(0); String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } logger.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: logger.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 75: break; case 2: { return getNext(""<"", yytext()); } case 76: break; case 3: { return getNext(); } case 77: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 78: break; case 5: { if (tokenizeNLs) { return getNext(AbstractTokenizer.NEWLINE_TOKEN, yytext()); // for tokenizing newliens } else if (invertible) { // System.err.println(""Appending newline: |"" + yytext() + ""|""); prevWordAfter.append(yytext()); } } case 79: break; case 6: { final String origTxt = yytext(); String tok = removeSoftHyphens(origTxt); if (americanize) { tok = Americanize.americanize(tok); } if (DEBUG) { logger.info(""Used {WORD} (2) to recognize "" + origTxt + "" as "" + tok + ""; probablyLeft="" + false); } return getNext(tok, origTxt); } case 80: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 81: break; case 8: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {QUOTES} (3) to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 82: break; case 9: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {SREDAUX} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 83: break; case 10: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 84: break; case 11: { return getNext("">"", yytext()); } case 85: break; case 12: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 86: break; case 13: { handleHyphenatedNumber(yytext()); if (DEBUG) { logger.info(""Used {NUMBER} to recognize "" + yytext() + "" as "" + removeFromNumber(yytext())); } return getNext(removeFromNumber(yytext()), yytext()); } case 87: break; case 14: { return handleEllipsis(yytext()); } case 88: break; case 15: { // breakByHyphens(yytext()); // this is causing fail of attempted to pushback too much! String tok = yytext(); /* A THING can contain quote like O'Malley */ String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {THING} (2) to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 89: break; case 16: { String txt = yytext(); String norm = normalizeFractions(yytext()); if (DEBUG) { logger.info(""Used {FRAC2} to recognize "" + txt + "" as "" + norm + ""; normalizeFractions="" + normalizeFractions + "", escapeForwardSlashAsterisk="" + escapeForwardSlashAsterisk); } return getNext(norm, txt); } case 90: break; case 17: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(minimallyNormalizeCurrency(yytext()), yytext()); } } case 91: break; case 18: { if (normalizeOtherBrackets) { return getNext(""-RSB-"", yytext()); } else { return getNext(); } } case 92: break; case 19: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 93: break; case 20: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 94: break; case 21: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 95: break; case 22: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 96: break; case 23: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 97: break; case 24: { if (normalizeOtherBrackets) { return getNext(""-LSB-"", yytext()); } else { return getNext(); } } case 98: break; case 25: { if (invertible) { prevWordAfter.append(yytext()); } } case 99: break; case 26: { return getNext(""\u2022"", yytext()); } case 100: break; case 27: { return getNext(""\u2122"", yytext()); } case 101: break; case 28: // general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 102: break; case 29: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(); } case 103: break; case 30: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {REDAUX} (2) to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 104: break; case 31: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {APOWORD} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 105: break; case 32: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); String norm = handleQuotes(tok, true); if (DEBUG) { logger.info(""Used {DBLQUOT} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + true); } return getNext(norm, tok); } case 106: break; case 33: { String tok = yytext(); if (DEBUG) { logger.info(""Used {PROG_LANGS} to recognize "" + tok + "" as "" + tok); } return getNext(tok, tok); } case 107: break; case 34: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 108: break; case 35: { breakByHyphens(yytext()); if (DEBUG) { logger.info(""Used {HTHING} to recognize "" + yytext() + "" as "" + removeSoftHyphens(yytext())); } return getNext(removeSoftHyphens(yytext()), yytext()); } case 109: break; case 36: // general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tok = removeSoftHyphens(origTxt); if (americanize) { tok = Americanize.americanize(tok); } if (DEBUG) { logger.info(""Used {WORD} to recognize "" + origTxt + "" as "" + tok + ""; probablyLeft="" + false); } return getNext(tok, origTxt); } case 110: break; case 37: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 111: break; case 38: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 112: break; case 39: { // this one should only match if we're basically at the end of file // since the last one matches two things, even newlines (if not tokenize per line) String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 113: break; case 40: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 114: break; case 41: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { // Extra context is to not match on ones like 'd but you do want words like ""a"" // can't have digit here because of cases like '90s String tok = yytext(); /* invert single quote - often but not always right */ String norm = handleQuotes(tok, true); if (DEBUG) { logger.info(""Used {QUOTES} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + true); } return getNext(norm, tok); } case 115: break; case 42: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {REDAUX} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 116: break; case 43: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { // Extra context is to not match on ones like 'd but you do want words like ""a"" // can't have digit here because of cases like '90s String tok = yytext(); /* invert single quote - often but not always right */ String norm = handleQuotes(tok, true); if (DEBUG) { logger.info(""Used {QUOTES} (2) to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + true); } return getNext(norm, tok); } case 117: break; case 44: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 118: break; case 45: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {SREDAUX} (2) to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 119: break; case 46: { if (splitAssimilations) { yypushback(2); } String tok = yytext(); if (DEBUG) { logger.info(""Used {ASSIMILATIONS3} to recognize "" + tok + "" as "" + tok + ""; splitAssimilations="" + splitAssimilations); } return getNext(tok, tok); } case 120: break; case 47: { String txt = yytext(); // if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space... if (strictTreebank3) { int spaceIndex = indexOfSpace(txt); if (spaceIndex >= 0) { yypushback(txt.length() - spaceIndex); return getNext(); } } if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, yytext()); } case 121: break; case 48: { return getNormalizedAmpNext(); } case 122: break; case 49: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, origTxt); } case 123: break; case 50: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space } return getNext(txt, origTxt); } case 124: break; case 51: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 125: break; case 52: // general lookahead, find correct zzMarkedPos { int zzFState = 17; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 126: break; case 53: { String txt = yytext(); String normTok = txt; if (escapeForwardSlashAsterisk) { normTok = delimit(normTok, '*'); } if (DEBUG) { logger.info(""Used {SWEARING} to recognize "" + txt + "" as "" + normTok); } return getNext(normTok, txt); } case 127: break; case 54: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {SREDAUX} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 128: break; case 55: // general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 129: break; case 56: // general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 22; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 130: break; case 57: // general lookahead, find correct zzMarkedPos { int zzFState = 18; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 19; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 131: break; case 58: // general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 132: break; case 59: // general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 21; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 133: break; case 60: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 134: break; case 61: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); breakByHyphens(tok); tok = yytext(); String norm = removeSoftHyphens(tok); if (DEBUG) { logger.info(""Used {HTHING} (2) to recognize "" + tok + "" as "" + norm); } return getNext(norm, tok); } case 135: break; case 62: { if (splitAssimilations) { yypushback(3); } String tok = yytext(); if (DEBUG) { logger.info(""Used {ASSIMILATIONS3} to recognize "" + tok + "" as "" + tok + ""; splitAssimilations="" + splitAssimilations); } return getNext(tok, tok); } case 136: break; case 63: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNormalizedAmpNext(); } case 137: break; case 64: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 9; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 138: break; case 65: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { return getNext(); } case 139: break; case 66: // general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 140: break; case 67: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 141: break; case 68: // general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 13; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 142: break; case 69: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } return getNext(txt, yytext()); } case 143: break; case 70: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4); { return getNext(); } case 144: break; case 71: // lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { return getNext(); } case 145: break; case 72: { String txt = yytext(); if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } if (DEBUG) { logger.info(""Used {PHONE} to recognize "" + yytext() + "" as "" + txt); } return getNext(txt, yytext()); } case 146: break; case 73: // general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 25; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 147: break; case 74: // general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 24; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 148: break; default: zzScanError(ZZ_NO_MATCH); } } } }"	Resumes scanning until the next regular expression is matched, the end of input is encountered or an I/O-Error occurs.	0	1
public Task<EncodedImage> get(List<CacheKey> keys, final AtomicBoolean isCancelled) { Preconditions.checkArgument(!keys.isEmpty()); for (CacheKey key : keys) { final EncodedImage pinnedImage = mStagingArea.get(key); if (pinnedImage != null) { return foundPinnedImage(key, pinnedImage); } } Task<EncodedImage> masterTask = getAsync(keys.get(0), isCancelled); if (keys.size() == 1) { return masterTask; } for (final CacheKey key : keys.subList(1, keys.size())) { masterTask = masterTask.continueWithTask( new Continuation<EncodedImage, Task<EncodedImage>>() { @Override public Task<EncodedImage> then(Task<EncodedImage> previousTask) throws Exception { // If we've got a hit, stop. If this is cancelled, stop. Otherwise, keep going. if (previousTask.isCancelled() || previousTask.getResult() != null) { return previousTask; } return getAsync(key, isCancelled); } }, mReadExecutor); } return masterTask; }	Performs key-value look up in disk cache.	1	0
"public boolean checkAlreadyExist(AccountDatabase.AccountName s) { // Query in the realm database RealmQuery<AccountDatabase> query = realm.where(AccountDatabase.class); // Checking if string equals to is exist or not query.equalTo(""name"", s.toString()); RealmResults<AccountDatabase> result1 = query.findAll(); // Here checking if count of that values is greater than zero return result1.size() > 0; }"	This function check if the selected account is already existed.	0	1
public static String jenkinsJobName(BuildConfig bc) { String namespace = bc.getMetadata().getNamespace(); String name = bc.getMetadata().getName(); return jenkinsJobName(namespace, name); }	Finds the Jenkins job for the given BuildConfig and defaultNamespace	1	0
public TregexMatcher matcher(Tree t, HeadFinder headFinder) { return matcher(t, t, null, ArrayMap.newArrayMap(), new VariableStrings(), headFinder); }	Get a TregexMatcher for this pattern on this tree.	0	1
private ConnectionJDBC getConnection() throws SQLException { return (ConnectionJDBC) statement.getConnection(); }	Returns the ConnectionJDBC2 object referenced by the #statement instance variable.	1	0
public B usingDriverExecutable(File file) { checkNotNull(file); checkExecutable(file); this.exe = file; return (B) this; }	Sets which driver executable the builder will use.	0	1
"static String substituteParamMarkers(String sql, ParamInfo[] list) { // A parameter can have at most 8 characters: "" @P"" plus at most 4 // digits plus "" "". We substract the ""?"" placeholder, that's at most // 7 extra characters needed for each parameter. char[] buf = new char[sql.length() + list.length * 7]; int bufferPtr = 0; // Output buffer pointer int start = 0; // Input string pointer for (int i = 0; i < list.length; i++) { int pos = list[i].markerPos; if (pos > 0) { sql.getChars(start, pos, buf, bufferPtr); bufferPtr += (pos - start); start = pos + 1; // Append "" @P"" buf[bufferPtr++] = ' '; buf[bufferPtr++] = '@'; buf[bufferPtr++] = 'P'; // Append parameter number String number = String.valueOf(i); number.getChars(0, number.length(), buf, bufferPtr); bufferPtr += number.length(); // Append "" "" buf[bufferPtr++] = ' '; } } if (start < sql.length()) { sql.getChars(start, sql.length(), buf, bufferPtr); bufferPtr += (sql.length() - start); } return new String(buf, 0, bufferPtr); }"	Update the SQL string and replace the &#63; markers with parameter names eg @P0, @P1 etc.	1	0
"public String fakeOuterStringSerialize(String body) throws ApiException { Object localVarPostBody = body; // create path and map variables String localVarPath = ""/fake/outer/string""; // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<String> localVarReturnType = new GenericType<String>() {}; return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	Test serialization of outer string types	0	1
public String toDefaultValue(Schema schema) { if (schema.getDefault() != null) { return schema.getDefault().toString(); } return getPropertyDefaultValue(schema); }	Return the default value of the property	0	1
public static TokenSequencePattern compile(SequencePattern.PatternExpr nodeSequencePattern) { return new TokenSequencePattern(null, nodeSequencePattern); }	Compiles a sequence of regular expression a TokenSequencePattern using the specified environment.	1	0
private boolean isBreakOnOpcode(Integer opcode) { boolean shouldBreak = false; if (config.isBreakOnPingPong()) { // break on every message type shouldBreak = true; } else { // break only on non-ping/pong boolean isPing = opcode.equals(WebSocketMessage.OPCODE_PING); boolean isPong = opcode.equals(WebSocketMessage.OPCODE_PONG); if (!isPing && !isPong) { shouldBreak = true; } } return shouldBreak; }	Check out if breakpoint should be applied on given WebSocketMessageDTO#opcode.	0	1
public static RelNode createDistinctRel(RelNode rel) { return LogicalAggregate.create(rel, ImmutableBitSet.range(rel.getRowType().getFieldCount()), null, ImmutableList.of()); }	Creates a LogicalAggregate that removes all duplicates from the result of an underlying relational expression.	0	1
public static List<SLARegistrationBean> fromJSONArray(JSONArray array) { List<SLARegistrationBean> list = new ArrayList<SLARegistrationBean>(); for (Object obj : array) { list.add(new SLARegistrationBean((JSONObject) obj)); } return list; }	Convert a JSONArray into a SLAEvent list.	1	0
public static EDateTime<Date> currentTimestamp() { return currentTimestamp(Date.class); }	Get an expression representing the current time instant as a EDateTime instance	0	1
public ReadWritableInstantFieldProperty millisOfDay() { return new ReadWritableInstantFieldProperty(this, getChronology().millisOfDay()); }	Get the millis of day property	0	1
private static long toEpochNanos(LocalDate date) { long epochDay = date.toEpochDay(); return epochDay * Conversions.NANOSECONDS_PER_DAY; }	Get the number of nanoseconds past epoch of the given java.time.LocalDateTime, java.time.LocalDate, java.time.LocalTime, java.util.Date, java.sql.Date, java.sql.Time, or java.sql.Timestamp.	1	0
public List<Pet> findPetsByTags(List<String> tags) throws ApiException { ApiResponse<List<Pet>> localVarResp = findPetsByTagsWithHttpInfo(tags); return localVarResp.getData(); }	Finds Pets by tags	0	1
"protected boolean performInitialSync() { try { delaySnapshotIfNeeded(); } catch (InterruptedException e) { logger.info(""Interrupted while awaiting initial snapshot delay""); return false; } logger.info(""Beginning initial sync of '{}' at {}"", rsName, source.lastOffset(rsName)); source.startInitialSync(replicaSet.replicaSetName()); // Set up our recorder to buffer the last record ... try { bufferedRecorder.startBuffering(); } catch (InterruptedException e) { // Do nothing so that this thread is terminated ... logger.info(""Interrupted while waiting to flush the buffer before starting an initial sync of '{}'"", rsName); return false; } // Get the current timestamp of this processor ... final long syncStart = clock.currentTimeInMillis(); // We need to copy each collection, so put the collection IDs into a queue ... final List<CollectionId> collections = primaryClient.collections(); final Queue<CollectionId> collectionsToCopy = new ConcurrentLinkedQueue<>(collections); final int numThreads = Math.min(collections.size(), context.getConnectionContext().maxNumberOfCopyThreads()); final CountDownLatch latch = new CountDownLatch(numThreads); final AtomicBoolean aborted = new AtomicBoolean(false); final AtomicInteger replicatorThreadCounter = new AtomicInteger(0); final AtomicInteger numCollectionsCopied = new AtomicInteger(); final AtomicLong numDocumentsCopied = new AtomicLong(); // And start threads to pull collection IDs from the queue and perform the copies ... logger.info(""Preparing to use {} thread(s) to sync {} collection(s): {}"", numThreads, collections.size(), Strings.join("", "", collections)); for (int i = 0; i != numThreads; ++i) { copyThreads.submit(() -> { context.configureLoggingContext(replicaSet.replicaSetName() + ""-sync"" + replicatorThreadCounter.incrementAndGet()); // Continue to pull a collection ID and copy the collection ... try { CollectionId id = null; while (!aborted.get() && (id = collectionsToCopy.poll()) != null) { long start = clock.currentTimeInMillis(); logger.info(""Starting initial sync of '{}'"", id); long numDocs = copyCollection(id, syncStart); numCollectionsCopied.incrementAndGet(); numDocumentsCopied.addAndGet(numDocs); long duration = clock.currentTimeInMillis() - start; logger.info(""Completing initial sync of {} documents from '{}' in {}"", numDocs, id, Strings.duration(duration)); } } catch (InterruptedException e) { // Do nothing so that this thread is terminated ... aborted.set(true); } finally { latch.countDown(); } }); } // Wait for all of the threads to complete ... try { latch.await(); } catch (InterruptedException e) { Thread.interrupted(); aborted.set(true); } this.copyThreads.shutdown(); // Stopping the replicator does not interrupt *our* thread but does interrupt the copy threads. // Therefore, check the aborted state here ... long syncDuration = clock.currentTimeInMillis() - syncStart; if (aborted.get()) { int remaining = collections.size() - numCollectionsCopied.get(); logger.info(""Initial sync aborted after {} with {} of {} collections incomplete"", Strings.duration(syncDuration), remaining, collections.size()); return false; } // We completed the initial sync, so record this in the source ... source.stopInitialSync(replicaSet.replicaSetName()); try { // And immediately flush the last buffered source record with the updated offset ... bufferedRecorder.stopBuffering(source.lastOffset(rsName)); } catch (InterruptedException e) { logger.info(""Interrupted while waiting for last initial sync record from replica set '{}' to be recorded"", rsName); return false; } logger.info(""Initial sync of {} collections with a total of {} documents completed in {}"", collections.size(), numDocumentsCopied.get(), Strings.duration(syncDuration)); return true; }"	Perform the initial sync of the collections in the replica set.	0	1
"public Object readObject() throws JMSException { initializeReading(); try { this.dataIn.mark(65); int type = this.dataIn.read(); if (type == -1) { throw new MessageEOFException(""reached end of data""); } if (type == MarshallingSupport.NULL) { return null; } if (type == MarshallingSupport.BIG_STRING_TYPE) { return MarshallingSupport.readUTF8(dataIn); } if (type == MarshallingSupport.STRING_TYPE) { return this.dataIn.readUTF(); } if (type == MarshallingSupport.LONG_TYPE) { return Long.valueOf(this.dataIn.readLong()); } if (type == MarshallingSupport.INTEGER_TYPE) { return Integer.valueOf(this.dataIn.readInt()); } if (type == MarshallingSupport.SHORT_TYPE) { return Short.valueOf(this.dataIn.readShort()); } if (type == MarshallingSupport.BYTE_TYPE) { return Byte.valueOf(this.dataIn.readByte()); } if (type == MarshallingSupport.FLOAT_TYPE) { return new Float(this.dataIn.readFloat()); } if (type == MarshallingSupport.DOUBLE_TYPE) { return new Double(this.dataIn.readDouble()); } if (type == MarshallingSupport.BOOLEAN_TYPE) { return this.dataIn.readBoolean() ? Boolean.TRUE : Boolean.FALSE; } if (type == MarshallingSupport.CHAR_TYPE) { return Character.valueOf(this.dataIn.readChar()); } if (type == MarshallingSupport.BYTE_ARRAY_TYPE) { int len = this.dataIn.readInt(); byte[] value = new byte[len]; this.dataIn.readFully(value); return value; } else { this.dataIn.reset(); throw new MessageFormatException(""unknown type""); } } catch (NumberFormatException mfe) { try { this.dataIn.reset(); } catch (IOException ioe) { throw JMSExceptionSupport.create(ioe); } throw mfe; } catch (EOFException e) { JMSException jmsEx = new MessageEOFException(e.getMessage()); jmsEx.setLinkedException(e); throw jmsEx; } catch (IOException e) { JMSException jmsEx = new MessageFormatException(e.getMessage()); jmsEx.setLinkedException(e); throw jmsEx; } }"	Reads an object from the stream message.	0	1
public ArrayList<Activity> getAllOpenedActivities() { ArrayList<Activity> activities = new ArrayList<Activity>(); Iterator<WeakReference<Activity>> activityStackIterator = activityStack.iterator(); while(activityStackIterator.hasNext()){ Activity activity = activityStackIterator.next().get(); if(activity!=null) activities.add(activity); } return activities; }	Returns a List of all the opened/active activities.	0	1
public AtmosphereRequest getRequest() { return atmosphereRequest; }	Return the associated HttpServletRequest	1	0
public View getActiveDecorView() { final View [] views = getWindowDecorViews(); final Activity activity = activityUtils.getCurrentActivity(false); if(views !=null && views.length > 0) { int length = views.length; for(int i = length - 1; i >= 0; i--){ if(activity.hasWindowFocus() && getCurrentViews(TextView.class,(ViewGroup) views[i]).size()==1) { return views[i]; } else if(activity.hasWindowFocus() && activity.getWindow().getDecorView().equals(views[i])){ return views[i]; } else if(!activity.hasWindowFocus() && !activity.getWindow().getDecorView().equals(views[i])){ return views[i]; } } return views[views.length-1]; } else return null; }	Returns the active DecorView.	0	1
"public Mono<BigDecimal> fakeOuterNumberSerialize(BigDecimal body) throws RestClientException { Object postBody = body; String path = UriComponentsBuilder.fromPath(""/fake/outer/number"").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { ""*/*"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<BigDecimal> returnType = new ParameterizedTypeReference<BigDecimal>() {}; return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType); }"	Test serialization of outer number types 200 - Output number	0	1
public boolean isResolvable(PicoContainer container, ComponentAdapter adapter, Class expectedType) { final Class collectionType = getCollectionType(expectedType); return collectionType != null && (emptyCollection || getResolvingAdapters(container, adapter, expectedType).length > 0); }	Test for dependency resolution of the parameter for the expected type.	1	0
public List<Library> getImportedLibraries() { return importedLibraries; }	Get the list of imported libraries.	0	1
public OracleQuery clone(Connection conn){ return new OracleQuery(conn, getTemplates(), getMetadata().clone()); }	Clone the state of this query to a new SQLQueryImpl instance with the given Connection	0	1
"public static String removeTags(String str) { return TAG_REGEXP.matcher(str).replaceAll(""""); }"	Removes all tags from the given `str`.	0	1
protected Object convertUnsignedMediumint(Column column, Field fieldDefn, Object data){ if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0; } if (data instanceof Integer) { return MySqlUnsignedIntegerConverter.convertUnsignedMediumint((int)data); } else if (data instanceof Number) { return MySqlUnsignedIntegerConverter.convertUnsignedMediumint(((Number) data).intValue()); } else { //We continue with the original converting method (integer) since we have an unsigned Medium return convertInteger(column, fieldDefn, data); } }	Convert the a value representing a Unsigned SMALLINT value to the correct Unsigned SMALLINT representation.	1	0
"public Tree transformTree(Tree t) { if (VERBOSE) { System.err.println(""Input to CoordinationTransformer: "" + t); } Tree tx = tn.transformTree(t); if (VERBOSE) { System.err.println(""After DependencyTreeTransformer: "" + tx); } if (tx == null) { return tx; } Tree tt = UCPtransform(tx); if (VERBOSE) { System.err.println(""After UCPTransformer: "" + t); } Tree ttt = CCtransform(tt); if (VERBOSE) { System.err.println(""After CCTransformer: "" + t); } Tree tttt = qp.transformTree(ttt); if (VERBOSE) { System.err.println(""After QPTreeTransformer: "" + t); } Tree ret = dates.transformTree(tttt); if (VERBOSE) { System.err.println(""After DateTreeTransformer: "" + t); } return ret; }"	Transforms t if it contains a coordination in a flat structure (CCtransform) and transforms UCP (UCPtransform).	0	1
"@SuppressWarnings(""unchecked"") public static String append(final String url, final Map<String, ?> params) { if (params == null || params.isEmpty()) return url; final StringBuilder result = new StringBuilder(url); // Add trailing slash if the base URL doesn't have any path segments. // The following test is checking for the last slash not being part of // the protocol to host separator '://'. int firstColon = url.indexOf(':'); int lastSlash = url.lastIndexOf('/'); if (firstColon + 2 == lastSlash) result.append('/'); result.append('?'); Entry<String, ?> entry; Object value; Iterator<?> iterator = params.entrySet().iterator(); entry = (Entry<String, ?>) iterator.next(); result.append(entry.getKey()); result.append('='); value = entry.getValue(); if (value != null) result.append(value); while (iterator.hasNext()) { result.append('&'); entry = (Entry<String, ?>) iterator.next(); result.append(entry.getKey()); result.append('='); value = entry.getValue(); if (value != null) result.append(value); } return result.toString(); }"	Append given parameters to base URL	1	0
public ApiResponse<Void> logoutUserWithHttpInfo() throws ApiException { okhttp3.Call localVarCall = logoutUserValidateBeforeCall(null, null); return localVarApiClient.execute(localVarCall); }	Logs out current logged in user session	0	1
public String getVerboseMessage() { return getVerboseMessage(true); }	generates the message that will be displayed to the client.	0	1
"@PreAuthorize(Constant.ACCESS_HAS_ROLE_ADMIN + "" or hasPermission(#cube, 'ADMINISTRATION') or hasPermission(#cube, 'OPERATION') or hasPermission(#cube, 'MANAGEMENT')"") public CubeInstance enableCube(CubeInstance cube) throws IOException, JobException { String cubeName = cube.getName(); RealizationStatusEnum ostatus = cube.getStatus(); if (!cube.getStatus().equals(RealizationStatusEnum.DISABLED)) { throw new InternalErrorException(""Only disabled cube can be enabled, status of "" + cubeName + "" is "" + ostatus); } if (cube.getSegments(SegmentStatusEnum.READY).size() == 0) { throw new InternalErrorException(""Cube "" + cubeName + "" dosen't contain any READY segment""); } final List<CubingJob> cubingJobs = listAllCubingJobs(cube.getName(), null, EnumSet.of(ExecutableState.READY, ExecutableState.RUNNING)); if (!cubingJobs.isEmpty()) { throw new JobException(""Enable is not allowed with a running job.""); } if (!cube.getDescriptor().calculateSignature().equals(cube.getDescriptor().getSignature())) { cube = this.releaseAllSegments(cube); } try { return getCubeManager().updateCube(cube, null, null, null, RealizationStatusEnum.READY); } catch (IOException e) { cube.setStatus(ostatus); throw e; } }"	Update a cube status from disable to ready.	0	1
public ItemPrice getItemPrice(int itemId) throws IOException { ItemPrice itemPrice = itemPrices.getIfPresent(itemId); if (itemPrice != null && itemPrice != EMPTY) { return itemPrice == NONE ? null : itemPrice; } itemPrice = itemClient.lookupItemPrice(itemId); if (itemPrice == null) { itemPrices.put(itemId, NONE); return null; } itemPrices.put(itemId, itemPrice); return itemPrice; }	Look up an item's price synchronously	0	1
public static RequestQueue newRequestQueue(IRestProtocol implRestConnection, int threadPoolSize) { return newRequestQueue(RestParser.getInstance(implRestConnection), threadPoolSize); }	Create a new request queue, using NoHttp default request executor HttpRestConnection and default response parser HttpRestParser.	1	0
private boolean isCached(Serializable collectionKey, CollectionPersister persister) { SessionImplementor session = context.getSession(); if ( session.getCacheMode().isGetEnabled() && persister.hasCache() ) { CollectionRegionAccessStrategy cache = persister.getCacheAccessStrategy(); CollectionCacheKey cacheKey = cache.generateCacheKey( collectionKey, persister, session.getFactory(), session.getTenantIdentifier() ); return CacheHelper.fromSharedCache( session, cacheKey, cache ) != null; } return false; }	Get a batch of uninitialized collection keys for a given role	0	1
public static String deprocess(String str, STextProcessor processor) { if ((str == null) || (str.length() <= 1)) return str; // make sure that LRE/PDF are added around the string STextEnvironment env = new STextEnvironment(null, false, STextEnvironment.ORIENT_UNKNOWN); if (!env.isProcessingNeeded()) return str; return STextEngine.fullToLeanText(processor, env, str, null); }	Remove directional formatting characters in the given string that were inserted by the #processTyped processTyped method.	1	0
public Expression getKey() { return key; }	Return the key with which the value will be associated.	1	0
"public JSONObject getJSONObject(String key) { Object object = this.get(key); if (object == null) { return null; } if (object instanceof JSONObject) { return (JSONObject)object; } throw new RuntimeException(""JSONObject["" + quote(key) + ""] is not a JSONObject.""); }"	Get the JSONObject value associated with a key.	0	1
public static String quote(String name) { if ( name == null || name.length() == 0 || isQuoted( name ) ) { return name; } else { return new StringBuffer( name.length() + 2 ).append('`').append( name ).append( '`' ).toString(); } }	Return a representation of the given name ensuring quoting (wrapped with '`' characters).	0	1
public static List getEditorSearchPath() { // grrrr, Arrays.asList() returns a readonly List item, which makes it difficult // to append additional items. This means we have to do this manually. // start by getting the list from the editor manager, which is returned as an // array of Strings. String[] paths = PropertyEditorManager.getEditorSearchPath(); // get a list matching the initial size...we don't always request this with the intend to append. List pathList = new ArrayList(paths.length); // now MANUALLY add each of the items in the array. for (int i = 0; i < paths.length; i++) { pathList.add(paths[i]); } return pathList; }	Gets the package names that will be searched for property editors.	1	0
public static Set<BitSet> getUniqueKeys(RelNode rel, boolean ignoreNulls) { final BuiltInMetadata.UniqueKeys metadata = rel.metadata(BuiltInMetadata.UniqueKeys.class); return metadata.getUniqueKeys(ignoreNulls); }	Determines the set of unique minimal keys for this expression, optionally ignoring nulls in the columns in the expression.	1	0
private XmlAttributeNode getScriptSourcePath(XmlTagNode node) { for (XmlAttributeNode attribute : node.getAttributes()) { if (attribute.getName().getLexeme().equals(SRC)) { return attribute; } } return null; }	Return the value of the source attribute if it exists.	1	0
public String getSearchPath() { // Java Mode doesn't need any default external jars at the moment. // This is here for Android Mode so that it can add its android.jar file. return null; }	Any modes that extend JavaMode can override this method to add additional jars to be included in the classpath for code completion and error checking	1	0
public static DateTimeFormatter tTimeNoMillis() { return Constants.ttx; }	Returns a formatter for a two digit hour of day, two digit minute of hour, two digit second of minute, and time zone offset prefixed by 'T' ('T'HH:mm:ssZZ).	0	1
"public static PsiFile findLayoutResource(PsiElement element) { if (element == null) { return null; // nothing to be used } if (!(element instanceof PsiIdentifier)) { return null; // nothing to be used } PsiElement layout = element.getParent().getFirstChild(); if (layout == null) { return null; // no file to process } if (!""R.layout"".equals(layout.getText())) { return null; // not layout file } Project project = element.getProject(); String name = String.format(""%s.xml"", element.getText()); return resolveLayoutResourceFile(element, project, name); }"	Try to find layout XML file in selected element	0	1
@Override public final TYPE next() { if (next == null) { return fromIterator.next(); } else { final TYPE result = next; next = null; return result; } }	Returns the next element of the iteration.	1	0
public Object getObject(String name) throws JMSException { initializeReading(); Object result = map.get(name); if (result instanceof UTF8Buffer) { result = result.toString(); } return result; }	Returns the value of the object with the specified name.	0	1
"private List<Long> getRcsRawContactIdFromPhoneNumber(String phoneNumber) { List<Long> contactsIds = new ArrayList<Long>(); String[] projection = { Data.RAW_CONTACT_ID }; String selection = Data.MIMETYPE + ""=? AND PHONE_NUMBERS_EQUAL("" + Phone.NUMBER + "", ?)""; String[] selectionArgs = { MIMETYPE_NUMBER, phoneNumber }; String sortOrder = Data.RAW_CONTACT_ID; Cursor cur = ctx.getContentResolver().query(Data.CONTENT_URI, projection, selection, selectionArgs, sortOrder); if (cur != null) { while (cur.moveToNext()) { long rcsRawContactId = cur.getLong(cur.getColumnIndex(Data.RAW_CONTACT_ID)); contactsIds.add(rcsRawContactId); } cur.close(); } return contactsIds; }"	Utility to find the RCS rawContactId for a specific phone number.	1	0
"static CalciteConnection getConnection(SchemaSpec schemaSpec) throws ClassNotFoundException, SQLException { Connection connection = DriverManager.getConnection(""jdbc:calcite:""); CalciteConnection calciteConnection = connection.unwrap(CalciteConnection.class); final SchemaPlus rootSchema = calciteConnection.getRootSchema(); switch (schemaSpec) { case JDBC_FOODMART: addSchema(rootSchema, schemaSpec); break; case CLONE_FOODMART: case JDBC_FOODMART_WITH_LATTICE: addSchema(rootSchema, SchemaSpec.JDBC_FOODMART); addSchema(rootSchema, schemaSpec); break; default: throw new AssertionError(""unknown schema "" + schemaSpec); } calciteConnection.setSchema(""foodmart2""); return calciteConnection; }"	Creates a connection with a given query provider.	0	1
public MenuItem addItem(SafeHtml html, ScheduledCommand cmd) { return addItem(new MenuItem(html, cmd)); }	Adds a menu item to the bar, that will fire the given command when it is selected.	1	0
public <V extends Visitor<? super X>> V visit(V visitor) { for (X x : this) { visitor.visit(x); } return visitor; }	Applies predicate to each item	1	0
"public RepositoryMetadata lookupComponent(Class<?> repositoryClass) { if (repositoriesMetadata.containsKey(repositoryClass)) { return repositoriesMetadata.get(repositoryClass); } throw new RuntimeException(""Unknown Repository class "" + repositoryClass.getName()); }"	Repository access - lookup the Repository component meta data for a specific Repository class.	1	0
"public RequestBody serialize(Object obj, String contentType) throws ApiException { if (obj instanceof byte[]) { // Binary (byte array) body parameter support. return RequestBody.create(MediaType.parse(contentType), (byte[]) obj); } else if (obj instanceof File) { // File body parameter support. return RequestBody.create(MediaType.parse(contentType), (File) obj); } else if (isJsonMime(contentType)) { String content; if (obj != null) { content = json.serialize(obj); } else { content = null; } return RequestBody.create(MediaType.parse(contentType), content); } else { throw new ApiException(""Content type \"""" + contentType + ""\"" is not supported""); } }"	Serialize the given Java object into request body string, according to the request Content-Type.	1	0
public int[] set(PartialInstant instant, int fieldIndex, int[] values, int newValue) { FieldUtils.verifyValueBounds(this, newValue, getMinimumValue(instant), getMaximumValue(instant)); values[fieldIndex] = newValue; return values; }	Sets a value in the milliseconds supplied from a human-readable, text value.	1	0
public VideoCallProvider getVideoCallProvider() { return mVideoCallProvider; }	Returns the ConnectionService.VideoCallProvider for the connection.	1	0
public TupleFilter flatFilter(int maxFlatChildrenSize) { return flattenInternal(this, maxFlatChildrenSize); }	flatten to OR-AND filter, (A AND B AND ..) OR (C AND D AND ..) OR ..	1	0
public static EBoolean startsWith(Expr<String> left, Expr<String> right) { return operationFactory.createBoolean(Ops.STARTSWITH, left, right); }	Expr : left.startsWith(right) (ignore case)	1	0
public static DocumentFactory createDocumentFactory(ServiceManager manager, Session session) { DocumentFactory factory; DocumentManager docManager = null; try { docManager = (DocumentManager) manager.lookup(DocumentManager.ROLE); factory = docManager.createDocumentIdentityMap(session); } catch (ServiceException e) { throw new RuntimeException(e); } finally { if (docManager != null) { manager.release(docManager); } } return factory; }	Creates a document identity map.	1	0
public static FxEnvironment getFilteredEnvironment() { return new FxFilteredEnvironment(getEnvironment()); }	Return a FilteredEnvironment for the calling user.	1	0
"public String toDefaultValue(Schema p) { if (p instanceof StringSchema) { StringSchema dp = (StringSchema) p; if (dp.getDefault() != null) { return ""@\"""" + dp.getDefault() + ""\""""; } } else if (p instanceof BooleanSchema) { BooleanSchema dp = (BooleanSchema) p; if (dp.getDefault() != null) { if (dp.getDefault().toString().equalsIgnoreCase(""false"")) return ""@(NO)""; else return ""@(YES)""; } } else if (p instanceof DateSchema) { // TODO } else if (p instanceof DateTimeSchema) { // TODO } else if (p instanceof NumberSchema) { NumberSchema dp = (NumberSchema) p; if (dp.getDefault() != null) { return ""@"" + dp.getDefault().toString(); } } else if (p instanceof IntegerSchema) { IntegerSchema dp = (IntegerSchema) p; if (dp.getDefault() != null) { return ""@"" + dp.getDefault().toString(); } } return null; }"	Return the default value of the property	1	0
public boolean isBuffered() { return queue.buffered(); }	Returns	1	0
public ReadableInstant withDateTimeZone(DateTimeZone newDateTimeZone) { final Chronology originalChrono = getChronology(); if (originalChrono == null) { // Without an original chronology, no new time zone can be // set. Call withMillis to allow subclass to decide if a clone // should be made or not. return withMillis(getMillis()); } return withChronology(originalChrono.withDateTimeZone(newDateTimeZone)); }	Gets a copy of this instant with a different time zone.	1	0
@Transactional(readOnly = true) @Override public int getAllCount(final String currentUser, final Set<String> userRoles, EphesoftUser ephesoftUser) { return batchInstanceDao.getAllCount(currentUser, userRoles, ephesoftUser); }	An api to return total count of batches in the batch instance table.	1	0
"public String toDefaultValue(Schema p) { if (ModelUtils.isDateSchema(p)) { // TODO } else if (ModelUtils.isDateTimeSchema(p)) { // TODO } else if (ModelUtils.isNumberSchema(p)) { if (p.getDefault() != null) { return ""@"" + p.getDefault().toString(); } } else if (ModelUtils.isIntegerSchema(p)) { if (p.getDefault() != null) { return ""@"" + p.getDefault().toString(); } } else if (ModelUtils.isStringSchema(p)) { if (p.getDefault() != null) { return ""@\"""" + (String) p.getDefault() + ""\""""; } } else if (ModelUtils.isBooleanSchema(p)) { if (p.getDefault() != null) { if (p.getDefault().toString().equalsIgnoreCase(""false"")) return ""@(NO)""; else return ""@(YES)""; } } return null; }"	Return the default value of the property	1	0
public final char readChar() throws IOException { if (this.inBuf > 0) { --this.inBuf; if (++this.bufpos == this.bufsize) { this.bufpos = 0; } return this.buffer[this.bufpos]; } if (++this.bufpos >= this.maxNextCharInd) { fillBuff(); } char c = this.buffer[this.bufpos]; updateLineColumn(c); return (c); }	DOCUMENT ME!	1	0
public static Parameter getReferencedParameter(OpenAPI openAPI, Parameter parameter) { if (parameter != null && StringUtils.isNotEmpty(parameter.get$ref())) { String name = getSimpleRef(parameter.get$ref()); Parameter referencedParameter = getParameter(openAPI, name); if(referencedParameter != null) { return referencedParameter; } } return parameter; }	If a Parameter contains a reference to an other Parameter with '$ref', returns the referenced Parameter or the actual Parameter in the other cases.	1	0
public final FacebookException getError() { return error; }	Returns information about any errors that may have occurred during the request.	1	0
private String terminalToShowWhenClosing(String handle) { int terminalClosing = terminals_.indexOfTerminal(handle); if (terminalClosing > 0) return terminals_.terminalHandleAtIndex(terminalClosing - 1); else if (terminalClosing + 1 < terminals_.terminalCount()) return terminals_.terminalHandleAtIndex(terminalClosing + 1); else return null; }	Index of terminal to show after closing indicated terminal index	1	0
public IncidentsTask createReportsTask() { return new IncidentsTask(url); }	Create report task object	1	0
public NVP<Long, Double> reset(final long newStartMs, final long newCount) { final long[] priorWindow = TIME_WINDOW_UPDATER.getAndSet(this, windowRangeFromMs(newStartMs, windowWidth)); final long priorCount = count; count = newCount; return new NVP<Long, Double>(priorWindow[1], calcRate(priorCount, windowWidth)); }	Resets the count to zero	1	0
private int[] getEnteredTime(Boolean[] enteredZeros) { int amOrPm = -1; int startIndex = 1; if (!mIs24HourMode && isTypedTimeFullyLegal()) { int keyCode = mTypedTimes.get(mTypedTimes.size() - 1); if (keyCode == getAmOrPmKeyCode(AM)) { amOrPm = AM; } else if (keyCode == getAmOrPmKeyCode(PM)){ amOrPm = PM; } startIndex = 2; } int minute = -1; int hour = -1; int second = 0; int shift = mEnableSeconds ? 2 : 0; for (int i = startIndex; i <= mTypedTimes.size(); i++) { int val = getValFromKeyCode(mTypedTimes.get(mTypedTimes.size() - i)); if (mEnableSeconds) { if (i == startIndex) { second = val; } else if (i == startIndex + 1) { second += 10*val; if (enteredZeros != null && val == 0) { enteredZeros[2] = true; } } } if (i == startIndex + shift) { minute = val; } else if (i == startIndex + shift + 1) { minute += 10*val; if (enteredZeros != null && val == 0) { enteredZeros[1] = true; } } else if (i == startIndex + shift + 2) { hour = val; } else if (i == startIndex + shift + 3) { hour += 10*val; if (enteredZeros != null && val == 0) { enteredZeros[0] = true; } } } return new int[] {hour, minute, second, amOrPm}; }	Get the currently-entered time, as integer values of the hours and minutes typed.	1	0
public int get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }	Analogous to #get(WithAttributes) except returning a primitive int.	1	0
public static String deprocess(String str) { if ((str == null) || (str.length() <= 1)) return str; STextEnvironment env = new STextEnvironment(null, false, STextEnvironment.ORIENT_UNKNOWN); if (!env.isProcessingNeeded()) return str; StringBuffer buf = new StringBuffer(); int strLen = str.length(); for (int i = 0; i < strLen; i++) { char c = str.charAt(i); switch (c) { case LRM : continue; case LRE : continue; case PDF : continue; default : buf.append(c); } } return buf.toString(); }	Remove directional formatting characters in the given string that were inserted by one of the #process process methods.	1	0
"public boolean isBoolean() { return raw.equals(""true"") || raw.equals(""false""); }"	Checks whether this ChatSection's argument can be parsed as a boolean	1	0
public static char[] union(char[]... list) { StringBuilder sb = new StringBuilder(); for (char[] characters : list) { for (int i = 0; i < list.length; i++) { if (!contains(sb, characters[i])) sb.append(list[i]); } } char[] toReturn = new char[sb.length()]; sb.getChars(0, sb.length(), toReturn, 0); Arrays.sort(toReturn); return toReturn; }	Union two character arrays.	1	0
public String getSourceTableName() { return ((source != null) ? source.getTableName() : null); }	Get the name of the table this column comes from.	1	0
public Timer getTimer(TimerDesc timerDesc) { return getTimer(timerDesc.getName(), timerDesc.getDurationUnit(), timerDesc.getTimeUnit()); }	Creates a new com.yammer.metrics.core.Timer and registers it under the given group and name, measuring elapsed time in milliseconds and invocations per second.	1	0
private boolean isCached(Serializable collectionKey, CollectionPersister persister) { if ( persister.hasCache() ) { CacheKey cacheKey = context.getSession().generateCacheKey( collectionKey, persister.getKeyType(), persister.getRole() ); return persister.getCacheAccessStrategy().get( cacheKey, context.getSession().getTimestamp() ) != null; } return false; }	Get a batch of unloaded identifiers for this class, using a slightly complex algorithm that tries to grab keys registered immediately after the given key.	1	0
public ScheduledReporter build() { ScheduledReporter reporter; switch (influxdbVersion) { case V08: Influxdb influxdb = buildInfluxdb(); reporter = (executor == null) ? new ReporterV08(registry, influxdb, clock, prefix, rateUnit, durationUnit, filter, skipIdleMetrics) : new ReporterV08(registry, influxdb, clock, prefix, rateUnit, durationUnit, filter, skipIdleMetrics, executor) ; break; default: Sender s = buildSender(); reporter = executor == null ? new MeasurementReporter(s, registry, filter, rateUnit, durationUnit, clock, tags, transformer) : new MeasurementReporter(s, registry, filter, rateUnit, durationUnit, clock, tags, transformer, executor) ; } return reporter; }	Builds a InfluxdbReporter with the given properties, sending metrics using the given Influxdb client.	1	0
public String getSubstituteExpression() { return this.substituteExpression; }	DOCUMENT ME!	1	0
"private PartitionTemplate assembleSar( final String name, final Configuration config, final Configuration assembly ) throws LoomException { final Configuration[] blockConfig = assembly.getChildren( ""block"" ); final ComponentTemplate[] blocks = buildBlocks( blockConfig, config ); final PartitionTemplate blockPartition = new PartitionTemplate( ContainerConstants.BLOCK_PARTITION, new String[]{ContainerConstants.LISTENER_PARTITION}, PartitionTemplate.EMPTY_SET, blocks ); final Configuration[] listenerConfig = assembly.getChildren( ""listener"" ); final ComponentTemplate[] listeners = buildBlockListeners( listenerConfig, config ); final PartitionTemplate listenerPartition = new PartitionTemplate( ContainerConstants.LISTENER_PARTITION, new String[ 0 ], PartitionTemplate.EMPTY_SET, listeners ); final PartitionTemplate[] partitions = new PartitionTemplate[]{blockPartition, listenerPartition}; return new PartitionTemplate( name, new String[ 0 ], partitions, ComponentTemplate.EMPTY_SET ); }"	Create a PartitionMetaData object based on specified name and assembly configuration.	1	0
"public Element writeSchema(Class javaType, Types types) throws Exception { // If an array the component type should be processed first String componentTypeName = null; Class componentType = null; if (javaType.isArray()) { String dimString = ""[]""; componentType = javaType.getComponentType(); if (componentType.isArray()) { while (componentType.isArray()) { dimString += ""[]""; componentType = componentType.getComponentType(); } } componentTypeName = types.getQNameString(types.getTypeQName(componentType)) + dimString; } // Use Types helper method to actually create the complexType return types.createArrayElement(componentTypeName); }"	Return XML schema for the specified type, suitable for insertion into the element of a WSDL document.	1	0
"public static final Weblogger getRoller() { if (rollerInstance == null) { throw new IllegalStateException(""Roller Weblogger has not been bootstrapped yet""); } return rollerInstance; }"	Accessor to the Roller Weblogger business tier.	1	0
public static List<Vulnerability> getAllVulnerabilities() { initializeIfEmpty(); return Collections.unmodifiableList(vulnerabilitiesI18NMap.getVulnerabilityList(Constant.getLocale().toString())); }	Gets an unmodifiable List containing all the Vulnerability loaded from the path Constant.VULNS_CONFIG.	1	0
private static EntityKey getOptionalObjectKey(QueryParameters queryParameters, SharedSessionContractImplementor session) { final Object optionalObject = queryParameters.getOptionalObject(); final Serializable optionalId = queryParameters.getOptionalId(); final String optionalEntityName = queryParameters.getOptionalEntityName(); if ( optionalObject != null && optionalEntityName != null ) { return session.generateEntityKey( optionalId, session.getEntityPersister( optionalEntityName, optionalObject ) ); } else { return null; } }	@param resultSet The result set from which to do the load.	0	1
"public void updatePetWithForm (Long petId, String name, String status) throws ApiException { Object postBody = null; // verify the required parameter 'petId' is set if (petId == null) { throw new ApiException(400, ""Missing the required parameter 'petId' when calling updatePetWithForm""); } // create path and map variables String path = ""/pet/{petId}"".replaceAll(""\\{format\\}"",""json"").replaceAll(""\\{"" + ""petId"" + ""\\}"", apiInvoker.escapeString(petId.toString())); // query params List<Pair> queryParams = new ArrayList<Pair>(); // header params Map<String, String> headerParams = new HashMap<String, String>(); // form params Map<String, String> formParams = new HashMap<String, String>(); String[] contentTypes = { ""application/x-www-form-urlencoded"" }; String contentType = contentTypes.length > 0 ? contentTypes[0] : ""application/json""; if (contentType.startsWith(""multipart/form-data"")) { // file uploading MultipartEntityBuilder builder = MultipartEntityBuilder.create(); if (name != null) { builder.addTextBody(""name"", ApiInvoker.parameterToString(name), ApiInvoker.TEXT_PLAIN_UTF8); } if (status != null) { builder.addTextBody(""status"", ApiInvoker.parameterToString(status), ApiInvoker.TEXT_PLAIN_UTF8); } HttpEntity httpEntity = builder.build(); postBody = httpEntity; } else { // normal form params formParams.put(""name"", ApiInvoker.parameterToString(name)); formParams.put(""status"", ApiInvoker.parameterToString(status)); } try { String response = apiInvoker.invokeAPI(basePath, path, ""POST"", queryParams, postBody, headerParams, formParams, contentType); if(response != null){ return ; } else { return ; } } catch (ApiException ex) { throw ex; } }"	@param petId ID of pet that needs to be updated	0	1
public static Area getClickbox(@Nonnull Client client, Model model, int orientation, int localX, int localY) { if (model == null) { return null; } List<Triangle> triangles = model.getTriangles().stream() .map(triangle -> triangle.rotate(orientation)) .collect(Collectors.toList()); List<Vertex> vertices = model.getVertices().stream() .map(v -> v.rotate(orientation)) .collect(Collectors.toList()); Area clickBox = get2DGeometry(client, triangles, orientation, localX, localY); Area visibleAABB = getAABB(client, vertices, orientation, localX, localY); if (visibleAABB == null || clickBox == null) { return null; } clickBox.intersect(visibleAABB); return clickBox; }	@param tileY the y-axis coordinate of the tile	1	0
public static BufferedImage alphaOffset(final Image rawImg, final float percentage) { BufferedImage image = toARGB(rawImg); final int numComponents = image.getColorModel().getNumComponents(); final float[] scales = new float[numComponents]; final float[] offsets = new float[numComponents]; Arrays.fill(scales, 1f); Arrays.fill(offsets, 0f); scales[numComponents - 1] = percentage; return offset(image, scales, offsets); }	@param percentage The ratio to modify the image's alpha component with. Values above 1 will increase transparency, and values below 1 will decrease transparency.	0	1
@Deprecated public Graph executeSparqlQuery(ConstructQuery query, TripleCollection defaultGraph) { return (Graph) executeSparqlQuery((Query) query, defaultGraph); }	@param defaultGraph the default ImmutableGraph against which to execute the query if not FROM clause is present	1	0
"private static String toString(Collection<TypedDependency> dependencies, boolean extraSep) { StringBuilder buf = new StringBuilder(); if (extraSep) { List<TypedDependency> extraDeps = new ArrayList<TypedDependency>(); for (TypedDependency td : dependencies) { if (td.extra()) { extraDeps.add(td); } else { buf.append(td.toString()).append('\n'); } } // now we print the separator for extra dependencies, and print these if there are some if (!extraDeps.isEmpty()) { buf.append(""======\n""); for (TypedDependency td : extraDeps) { buf.append(td.toString()).append('\n'); } } } else { for (TypedDependency td : dependencies) { buf.append(td.toString()).append('\n'); } } return buf.toString(); }"	@param extraSep boolean indicating whether the extra dependencies have to be printed separately, after the basic ones	0	1
"public Action timedout(AtmosphereRequest request, AtmosphereResponse response) throws IOException, ServletException { AtmosphereResourceImpl r = null; try { if (trackActiveRequest) { long l = (Long) request.getAttribute(MAX_INACTIVE); if (l == -1) { // The closedDetector closed the connection. return timedoutAction; } request.setAttribute(MAX_INACTIVE, (long) -1); } logger.debug(""Timing out the connection for request {}"", request); // Something went wrong. if (request == null || response == null) { logger.warn(""Invalid Request/Response: {}/{}"", request, response); return timedoutAction; } r = (AtmosphereResourceImpl) request.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE); if (r != null && r.getAtmosphereResourceEvent().isSuspended()) { r.getAtmosphereResourceEvent().setIsResumedOnTimeout(true); Broadcaster b = r.getBroadcaster(); if (b instanceof DefaultBroadcaster) { ((DefaultBroadcaster) b).broadcastOnResume(r); } if (request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT) != null) { r.getAtmosphereResourceEvent().setIsResumedOnTimeout( (Boolean) request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT)); } invokeAtmosphereHandler(r); } } catch (Throwable t) { logger.error(""failed to timeout resource {}"", r, t); } finally { try { if (r != null) { r.notifyListeners(); r.setIsInScope(false); r.cancel(); } } catch (Throwable t) { logger.trace(""timedout"", t); } finally { try { response.getOutputStream().close(); } catch (Throwable t) { try { response.getWriter().close(); } catch (Throwable t2) { } } if (r != null) { destroyResource(r); } } } return timedoutAction; }"	@param request the HttpServletRequest	1	0
"public int compareTo(BaseSingleFieldPeriod other) { if (other.getClass() != getClass()) { throw new ClassCastException(getClass() + "" cannot be compared to "" + other.getClass()); } int otherValue = other.getValue(); int thisValue = getValue(); if (thisValue > otherValue) { return 1; } if (thisValue < otherValue) { return -1; } return 0; }"	@param other the other period, must not be null	0	1
"public boolean supports(AuthenticationToken token) { if ( log.isInfoEnabled() ) { log.info( ""Received null AuthenticationToken. Returning false for supports(token) implementation (can't "" + ""process null tokens)."" ); } return token != null && getAuthenticationTokenClass().isAssignableFrom(token.getClass()); }"	@param tokenClass the class of the authenticationToken being submitted for authentication.	1	0
private RectF drawBoxWithShadow(Canvas c, int width, int height) { Resources res = mContext.getResources(); float shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur); float keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance); float corner = res.getDimension(R.dimen.widget_preview_corner_radius); RectF bounds = new RectF(shadowBlur, shadowBlur, width - shadowBlur, height - shadowBlur - keyShadowDistance); ShadowGenerator.drawShadow(c, bounds, Color.WHITE, shadowBlur, keyShadowDistance, corner); return bounds; }	@param preview bitmap that can be recycled	0	1
public FilterRegistration.Dynamic addFilter(String name, Class<? extends Filter> klass) { final FilterHolder holder = new FilterHolder(checkNotNull(klass)); holder.setName(name); handler.getServletHandler().addFilter(holder); return holder.getRegistration(); }	@param urlPattern the URL pattern for requests that should be handled by instances of klass	1	0
private boolean paramAppend(StringBuilder sb, String name, String value, ParameterParser parser) { boolean isEdited = false; if (name != null) { sb.append(name); isEdited = true; } if (value != null) { sb.append(parser.getDefaultKeyValueSeparator()); sb.append(value); isEdited = true; } return isEdited; }	@param name Null = not to append parameter.	0	1
public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws ApiException { return uploadFileWithRequiredFileWithHttpInfo(petId, requiredFile, additionalMetadata).getData(); }	@param file file to upload (required)	1	0
public Optional<GraphQLError> add(SDLDefinition definition) { // extensions if (definition instanceof ObjectTypeExtensionDefinition) { ObjectTypeExtensionDefinition newEntry = (ObjectTypeExtensionDefinition) definition; return defineExt(typeExtensions, newEntry, ObjectTypeExtensionDefinition::getName); } else if (definition instanceof InterfaceTypeExtensionDefinition) { InterfaceTypeExtensionDefinition newEntry = (InterfaceTypeExtensionDefinition) definition; return defineExt(interfaceTypeExtensions, newEntry, InterfaceTypeExtensionDefinition::getName); } else if (definition instanceof UnionTypeExtensionDefinition) { UnionTypeExtensionDefinition newEntry = (UnionTypeExtensionDefinition) definition; return defineExt(unionTypeExtensions, newEntry, UnionTypeExtensionDefinition::getName); } else if (definition instanceof EnumTypeExtensionDefinition) { EnumTypeExtensionDefinition newEntry = (EnumTypeExtensionDefinition) definition; return defineExt(enumTypeExtensions, newEntry, EnumTypeExtensionDefinition::getName); } else if (definition instanceof ScalarTypeExtensionDefinition) { ScalarTypeExtensionDefinition newEntry = (ScalarTypeExtensionDefinition) definition; return defineExt(scalarTypeExtensions, newEntry, ScalarTypeExtensionDefinition::getName); } else if (definition instanceof InputObjectTypeExtensionDefinition) { InputObjectTypeExtensionDefinition newEntry = (InputObjectTypeExtensionDefinition) definition; return defineExt(inputObjectTypeExtensions, newEntry, InputObjectTypeExtensionDefinition::getName); // // normal } else if (definition instanceof ScalarTypeDefinition) { ScalarTypeDefinition newEntry = (ScalarTypeDefinition) definition; return define(scalarTypes, scalarTypes, newEntry); } else if (definition instanceof TypeDefinition) { TypeDefinition newEntry = (TypeDefinition) definition; return define(types, types, newEntry); } else if (definition instanceof DirectiveDefinition) { DirectiveDefinition newEntry = (DirectiveDefinition) definition; return define(directiveDefinitions, directiveDefinitions, newEntry); } else if (definition instanceof SchemaDefinition) { SchemaDefinition newSchema = (SchemaDefinition) definition; if (schema != null) { return Optional.of(new SchemaRedefinitionError(this.schema, newSchema)); } else { schema = newSchema; } } else { return Assert.assertShouldNeverHappen(); } return Optional.empty(); }	@param definition the definition to add	0	1
"public Action timedout(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { AtmosphereResourceImpl re; long l = (Long) request.getAttribute(MAX_INACTIVE); if (l == -1) { // The closedDetector closed the connection. return timedoutAction; } request.setAttribute(MAX_INACTIVE, (long) -1); // Something went wrong. if (request == null || response == null) { logger.warn(""Invalid Request/Response: {}/{}"", request, response); return timedoutAction; } re = (AtmosphereResourceImpl) request.getAttribute(AtmosphereServlet.ATMOSPHERE_RESOURCE); if (re != null) { re.getAtmosphereResourceEvent().setIsResumedOnTimeout(true); Broadcaster b = re.getBroadcaster(); if (b instanceof DefaultBroadcaster) { ((DefaultBroadcaster)b).broadcastOnResume(re); } if (re.getRequest().getAttribute(AtmosphereServlet.RESUMED_ON_TIMEOUT) != null) { re.getAtmosphereResourceEvent().setIsResumedOnTimeout( (Boolean) re.getRequest().getAttribute(AtmosphereServlet.RESUMED_ON_TIMEOUT)); } invokeAtmosphereHandler(re); } return timedoutAction; }"	@param res the HttpServletResponse	1	0
public boolean searchWithTimeoutFor(Class<? extends TextView> viewClass, String regex, int expectedMinimumNumberOfMatches, boolean scroll, boolean visible) { final long endTime = System.currentTimeMillis() + TIMEOUT; while (System.currentTimeMillis() < endTime) { sleeper.sleep(); final boolean foundAnyMatchingView = searchFor(viewClass, regex, expectedMinimumNumberOfMatches, scroll, visible); if (foundAnyMatchingView){ return true; } } return false; }	@param viewClass what kind of View to search for, e.g. Button.class or TextView.class	0	1
public static int availablePort(int preferred) { int rtn = -1; try { rtn = tryPort(preferred); } catch (IOException ignored) { } return rtn; }	@param prefered	1	0
public synchronized <T extends AbstractTypeServerPluginContainer> T getPluginContainerByPlugin(String pluginName) { for (AbstractTypeServerPluginContainer pc : this.pluginContainers.values()) { if (null != pc.getPluginManager().getPluginEnvironment(pluginName)) { return (T) pc; } } return null; }	@param pluginKey	1	0
private boolean paramAppend(StringBuilder sb, String name, String value) { boolean isEdited = false; if (name != null) { sb.append(name); isEdited = true; } if (value != null) { sb.append('='); sb.append(value); isEdited = true; } return isEdited; }	@param sb	0	1
"private boolean scanSingleNode(Plugin plugin, StructuralNode node) { Thread thread; Plugin test; HttpMessage msg; log.debug(""scanSingleNode node plugin="" + plugin.getName() + "" node="" + node.getName()); // do not poll for isStop here to allow every plugin to run but terminate immediately. //if (isStop()) return; try { if (node == null || node.getHistoryReference() == null) { log.debug(""scanSingleNode node or href null, returning: node="" + node); return false; } if (HistoryReference.TYPE_SCANNER == node.getHistoryReference().getHistoryType()) { log.debug(""Ignoring \""scanner\"" type href""); return false; } if (!nodeInScope(node.getName())) { log.debug(""scanSingleNode node not in scope""); return false; } msg = node.getHistoryReference().getHttpMessage(); if (msg == null) { // Likely to be a temporary node log.debug(""scanSingleNode msg null""); return false; } test = plugin.getClass().newInstance(); test.setConfig(plugin.getConfig()); test.setDelayInMs(plugin.getDelayInMs()); test.setDefaultAlertThreshold(plugin.getAlertThreshold()); test.setDefaultAttackStrength(plugin.getAttackStrength()); test.setTechSet(getTechSet()); test.init(msg, this); notifyHostProgress(plugin.getName() + "": "" + msg.getRequestHeader().getURI().toString()); } catch (Exception e) { log.error(e.getMessage() + "" "" + node.getName(), e); return false; } do { if (this.isStop()) { return false; } thread = threadPool.getFreeThreadAndRun(test); if (thread == null) { Util.sleep(200); } } while (thread == null); return true; }"	@param plugin	0	1
public Order placeOrder(Order order) throws ApiException { ApiResponse<Order> resp = placeOrderWithHttpInfo(order); return resp.getData(); }	@param body order placed for purchasing the pet (required)	1	0
public RuntimeException translate(String sql, List<Object> bindings, SQLException ex) { return exceptionTranslator.translate(sql, bindings, ex); }	@param ex	0	1
public FilterBuilder addFilter(Filter filter, String urlPattern) { final FilterHolder holder = new FilterHolder(checkNotNull(filter)); final FilterBuilder builder = new FilterBuilder(holder, handler); builder.addUrlPattern(checkNotNull(urlPattern)); return builder; }	@param name the filter's name	1	0
public PMetadata getCache(PGraphics renderer) { if (cacheMap == null) return null; return cacheMap.get(renderer); }	@param parent The PGraphics object (or any object, really) associated	1	0
"private FileSelection expandSelectionFromMetadataCache(FileSelection selection, List<Path> metaFilePaths) throws IOException { // get the metadata for the root directory by reading the metadata file // parquetTableMetadata contains the metadata for all files in the selection root folder, but we need to make sure // we only select the files that are part of selection (by setting fileSet appropriately) // get (and set internal field) the metadata for the directory by reading the metadata file FileSystem processUserFileSystem = ImpersonationUtil.createFileSystem(ImpersonationUtil.getProcessUserName(), fs.getConf()); parquetTableMetadata = Metadata.readBlockMeta(processUserFileSystem, metaFilePaths, metaContext, readerConfig); if (ignoreExpandingSelection(parquetTableMetadata)) { return selection; } if (corruptDatesAutoCorrected) { ParquetReaderUtility.correctDatesInMetadataCache(this.parquetTableMetadata); } ParquetReaderUtility.transformBinaryInMetadataCache(parquetTableMetadata, readerConfig); List<FileStatus> fileStatuses = selection.getStatuses(fs); if (fileSet == null) { fileSet = new HashSet<>(); } final Path first = fileStatuses.get(0).getPath(); if (fileStatuses.size() == 1 && selection.getSelectionRoot().equals(first)) { // we are selecting all files from selection root. Expand the file list from the cache for (MetadataBase.ParquetFileMetadata file : parquetTableMetadata.getFiles()) { fileSet.add(file.getPath()); } } else if (selection.isExpandedPartial() && !selection.hadWildcard() && cacheFileRoot != null) { if (selection.wasAllPartitionsPruned()) { // if all partitions were previously pruned, we only need to read 1 file (for the schema) fileSet.add(this.parquetTableMetadata.getFiles().get(0).getPath()); } else { // we are here if the selection is in the expanded_partial state (i.e it has directories). We get the // list of files from the metadata cache file that is present in the cacheFileRoot directory and populate // the fileSet. However, this is *not* the final list of files that will be scanned in execution since the // second phase of partition pruning will apply on the files and modify the file selection appropriately. for (MetadataBase.ParquetFileMetadata file : this.parquetTableMetadata.getFiles()) { fileSet.add(file.getPath()); } } } else { // we need to expand the files from fileStatuses for (FileStatus status : fileStatuses) { Path currentCacheFileRoot = status.getPath(); if (status.isDirectory()) { // TODO [DRILL-4496] read the metadata cache files in parallel // Depending on the version of metadata this may represent more than 1 metadata file paths. List<Path> metaPaths = populateMetaPaths(currentCacheFileRoot, fs); MetadataBase.ParquetTableMetadataBase metadata = Metadata.readBlockMeta(processUserFileSystem, metaPaths, metaContext, readerConfig); if (ignoreExpandingSelection(metadata)) { return selection; } for (MetadataBase.ParquetFileMetadata file : metadata.getFiles()) { fileSet.add(file.getPath()); } } else { final Path path = Path.getPathWithoutSchemeAndAuthority(currentCacheFileRoot); fileSet.add(path); } } } if (fileSet.isEmpty()) { // no files were found, most likely we tried to query some empty sub folders logger.warn(""The table is empty but with outdated invalid metadata cache files. Please, delete them.""); return null; } List<Path> fileNames = new ArrayList<>(fileSet); // when creating the file selection, set the selection root without the URI prefix // The reason is that the file names above have been created in the form // /a/b/c.parquet and the format of the selection root must match that of the file names // otherwise downstream operations such as partition pruning can break. Path metaRootPath = Path.getPathWithoutSchemeAndAuthority(selection.getSelectionRoot()); this.selectionRoot = metaRootPath; // Use the FileSelection constructor directly here instead of the FileSelection.create() method // because create() changes the root to include the scheme and authority; In future, if create() // is the preferred way to instantiate a file selection, we may need to do something different... // WARNING: file statuses and file names are inconsistent FileSelection newSelection = new FileSelection(selection.getStatuses(fs), fileNames, metaRootPath, cacheFileRoot, selection.wasAllPartitionsPruned()); newSelection.setExpandedFully(); newSelection.setMetaContext(metaContext); return newSelection; }"	@param metaFilePath metadata cache file path	1	0
"public PumpEnactResult applyAPSRequest(APSResult request) { request.rate = applyBasalConstraints(request.rate); PumpEnactResult result; if (!isInitialized()) { result = new PumpEnactResult(); result.comment = MainApp.sResources.getString(R.string.pumpNotInitialized); result.enacted = false; result.success = false; log.debug(""applyAPSRequest: "" + MainApp.sResources.getString(R.string.pumpNotInitialized)); return result; } if (isSuspended()) { result = new PumpEnactResult(); result.comment = MainApp.sResources.getString(R.string.pumpsuspended); result.enacted = false; result.success = false; log.debug(""applyAPSRequest: "" + MainApp.sResources.getString(R.string.pumpsuspended)); return result; } if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: "" + request.toString()); if ((request.rate == 0 && request.duration == 0) || Math.abs(request.rate - getBaseBasalRate()) < getPumpDescription().basalStep) { if (isTempBasalInProgress()) { if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: cancelTempBasal()""); result = cancelTempBasal(false); } else { result = new PumpEnactResult(); result.absolute = request.rate; result.duration = 0; result.enacted = false; result.comment = ""Basal set correctly""; result.success = true; if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: Basal set correctly""); } } else if (isTempBasalInProgress() && getTempBasalRemainingMinutesFromHistory() > 5 && Math.abs(request.rate - getTempBasalAbsoluteRateHistory()) < getPumpDescription().basalStep) { result = new PumpEnactResult(); result.absolute = getTempBasalAbsoluteRateHistory(); result.duration = getTempBasalFromHistory(System.currentTimeMillis()).getPlannedRemainingMinutes(); result.enacted = false; result.comment = ""Temp basal set correctly""; result.success = true; if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: Temp basal set correctly""); } else { if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: setTempBasalAbsolute()""); result = setTempBasalAbsolute(request.rate, request.duration); } return result; }"	@param request	0	1
"protected AtmosphereHandlerWrapper map(AtmosphereRequest req) throws ServletException { String path; if (req.getPathInfo() != null) { path = req.getServletPath() + req.getPathInfo(); } else { path = req.getServletPath(); } if (path == null || path.length() <= 1) { path = ""/all""; } AtmosphereHandlerWrapper atmosphereHandlerWrapper = map(path); if (atmosphereHandlerWrapper == null) { atmosphereHandlerWrapper = map(""/all""); } if (atmosphereHandlerWrapper == null) { throw new AtmosphereMappingException(""No AtmosphereHandler maps request for "" + path); } config.getBroadcasterFactory().add(atmosphereHandlerWrapper.broadcaster, atmosphereHandlerWrapper.broadcaster.getID()); return atmosphereHandlerWrapper; }"	@param req the HttpServletResponse	1	0
public static boolean simpleMatch(Collection<String> patterns, String str) { if (patterns != null) { for (String pattern : patterns) { if (simpleMatch(pattern, str)) { return true; } } } return false; }	@param str the String to match	0	1
public static Set<ConfiguredClassHierarchy<EntityClass>> createEntityHierarchies(AnnotationsBindingContext bindingContext) { Map<ClassInfo, List<ClassInfo>> processedClassInfos = new HashMap<ClassInfo, List<ClassInfo>>(); for ( ClassInfo info : bindingContext.getIndex().getKnownClasses() ) { if ( !isEntityClass( info ) ) { continue; } if ( processedClassInfos.containsKey( info ) ) { continue; } List<ClassInfo> configuredClassList = new ArrayList<ClassInfo>(); ClassInfo tmpClassInfo = info; Class<?> clazz = bindingContext.locateClassByName( tmpClassInfo.toString() ); while ( clazz != null && !clazz.equals( Object.class ) ) { tmpClassInfo = bindingContext.getIndex().getClassByName( DotName.createSimple( clazz.getName() ) ); clazz = clazz.getSuperclass(); if ( tmpClassInfo == null ) { continue; } if ( existsHierarchyWithClassInfoAsLeaf( processedClassInfos, tmpClassInfo ) ) { List<ClassInfo> classInfoList = processedClassInfos.get( tmpClassInfo ); for ( ClassInfo tmpInfo : configuredClassList ) { classInfoList.add( tmpInfo ); processedClassInfos.put( tmpInfo, classInfoList ); } break; } else { configuredClassList.add( 0, tmpClassInfo ); processedClassInfos.put( tmpClassInfo, configuredClassList ); } } } Set<ConfiguredClassHierarchy<EntityClass>> hierarchies = new HashSet<ConfiguredClassHierarchy<EntityClass>>(); List<List<ClassInfo>> processedList = new ArrayList<List<ClassInfo>>(); for ( List<ClassInfo> classInfoList : processedClassInfos.values() ) { if ( !processedList.contains( classInfoList ) ) { hierarchies.add( ConfiguredClassHierarchy.createEntityClassHierarchy( classInfoList, bindingContext ) ); processedList.add( classInfoList ); } } return hierarchies; }	@param context the annotation binding context with access to the service registry and the annotation index	1	0
public static DownloadRequest createDownloadRequest(String url, RequestMethod requestMethod, String fileFolder, String filename, boolean isRange, boolean isDeleteOld) { return new RestDownloadRequestor(url, requestMethod, fileFolder, filename, isRange, isDeleteOld); }	@param filename Filename	0	1
static public IStructuredTextExpert getStatefulExpert(StructuredTextTypeHandler handler, StructuredTextEnvironment environment) { if (environment == null) environment = StructuredTextEnvironment.DEFAULT; return new StructuredTextImpl(handler, environment, true); }	@param environment the current environment, which may affect the behavior of the expert. This parameter may be specified as null, in which case the STextEnvironment#DEFAULT environment should be assumed.	1	0
public boolean onCollapseStart(CommonCardView viewCard) { Card card = viewCard.getCard(); if (card!=null){ String itemId = card.getId(); if (mExpandedIds.contains(itemId)) { return true; } } return false; }	@param viewCard	0	1
private static CoreLabel fromProto(CoreNLPProtos.Token proto) { CoreLabel word = new CoreLabel(); // Required fields word.setWord(proto.getWord()); // Optional fields if (proto.hasPos()) { word.setTag(proto.getPos()); } if (proto.hasValue()) { word.setValue(proto.getValue()); } if (proto.hasCategory()) { word.setCategory(proto.getCategory()); } if (proto.hasBefore()) { word.setBefore(proto.getBefore()); } if (proto.hasAfter()) { word.setAfter(proto.getAfter()); } if (proto.hasOriginalText()) { word.setOriginalText(proto.getOriginalText()); } if (proto.hasNer()) { word.setNER(proto.getNer()); } if (proto.hasLemma()) { word.setLemma(proto.getLemma()); } if (proto.hasBeginChar()) { word.setBeginPosition(proto.getBeginChar()); } if (proto.hasEndChar()) { word.setEndPosition(proto.getEndChar()); } if (proto.hasSpeaker()) { word.set(SpeakerAnnotation.class, proto.getSpeaker()); } if (proto.hasUtterance()) { word.set(UtteranceAnnotation.class, proto.getUtterance()); } if (proto.hasBeginIndex()) { word.set(BeginIndexAnnotation.class, proto.getBeginIndex()); } if (proto.hasEndIndex()) { word.set(EndIndexAnnotation.class, proto.getEndIndex()); } if (proto.hasTokenBeginIndex()) { word.set(TokenBeginAnnotation.class, proto.getTokenBeginIndex()); } if (proto.hasTokenEndIndex()) { word.set(TokenEndAnnotation.class, proto.getTokenEndIndex()); } if (proto.hasNormalizedNER()) { word.set(NormalizedNamedEntityTagAnnotation.class, proto.getNormalizedNER()); } if (proto.hasTimexValue()) { word.set(TimexAnnotation.class, fromProto(proto.getTimexValue())); } if (proto.getXmlContextCount() > 0) { word.set(XmlContextAnnotation.class, proto.getXmlContextList()); } if (proto.hasCorefClusterID()) { word.set(CorefClusterIdAnnotation.class, proto.getCorefClusterID()); } // Non-default annotators if (proto.hasGender()) { word.set(GenderAnnotation.class, proto.getGender()); } if (proto.hasTrueCase()) { word.set(TrueCaseAnnotation.class, proto.getTrueCase()); } if (proto.hasTrueCaseText()) { word.set(TrueCaseTextAnnotation.class, proto.getTrueCaseText()); } // Return return word; }	@param proto The serialized protobuf to read the CoreLabel from.	0	1
protected static TableId parse(String[] parts, int numParts, boolean useCatalogBeforeSchema) { if (numParts == 0) return null; if (numParts == 1) return new TableId(null, null, parts[0]); // table only if (numParts == 2) { if (useCatalogBeforeSchema) return new TableId(parts[0], null, parts[1]); // catalog & table only return new TableId(null, parts[0], parts[1]); // catalog & table only } return new TableId(parts[0], parts[1], parts[2]); // catalog & table only }	@param str the input string	1	0
public Client testSpecialTags(Client client, Map<String, Object> params) throws IOException { HttpResponse response = testSpecialTagsForHttpResponse(client, params); TypeReference typeRef = new TypeReference<Client>() {}; return apiClient.getObjectMapper().readValue(response.getContent(), typeRef); }	@param body client model	1	0
public static Transport createLocalTransport(URI uri) throws Exception { return createLocalTransport(uri, false); }	@param remoteTransport	0	1
public double get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }	@param attributes an object containing an AttributeMap	1	0
public BooleanExpression like(Expression<String> str){ return BooleanOperation.create(Ops.LIKE, this, str); }	@param str	0	1
public static Area getClickbox(@Nonnull Client client, Model model, int orientation, int localX, int localY) { if (model == null) { return null; } List<Triangle> triangles = model.getTriangles().stream() .map(triangle -> triangle.rotate(orientation)) .collect(Collectors.toList()); List<Vertex> vertices = model.getVertices().stream() .map(v -> v.rotate(orientation)) .collect(Collectors.toList()); Area clickBox = get2DGeometry(client, triangles, orientation, localX, localY); Area visibleAABB = getAABB(client, vertices, orientation, localX, localY); if (visibleAABB == null || clickBox == null) { return null; } clickBox.intersect(visibleAABB); return clickBox; }	@param model the model to calculate a clickbox for	0	1
public static Iterable<ProviderMetadata<?, ?, ?, ?>> boundedByIso3166Code(String iso3166Code, ApiType type) { return filter(all(), Predicates.and(ProviderPredicates.boundedByIso3166Code(iso3166Code), ProviderPredicates.type(type))); }	@param contextWrappableAs the contextWrappableAs to filter providers by	1	0
"private int constituents(Set<Constituent> constituentsSet, int left, ConstituentFactory cf, boolean charLevel, Predicate<Tree> filter, int maxDepth, int depth) { if(isPreTerminal()) return left + ((charLevel) ? firstChild().value().length() : 1); int position = left; // System.err.println(""In bracketing trees left is "" + left); // System.err.println("" label is "" + label() + // ""; num daughters: "" + children().length); Tree[] kids = children(); for (Tree kid : kids) { position = kid.constituents(constituentsSet, position, cf, charLevel, filter, maxDepth, depth + 1); // System.err.println("" position went to "" + position); } if ((filter == null || filter.test(this)) && (maxDepth < 0 || depth <= maxDepth)) { //Compute span of entire tree at the end of recursion constituentsSet.add(cf.newConstituent(left, position - 1, label(), score())); } // System.err.println("" added "" + label()); return position; }"	@param left left position to begin labeling the bracketings with	0	1
public static boolean filter(String path, Collection<String> includes, Collection<String> excludes, boolean allowPartialMatches) { includes = (includes == null ? Collections.<String> emptyList() : includes); excludes = (excludes == null ? Collections.<String> emptyList() : excludes); if (includes.isEmpty() && excludes.isEmpty()) { return true; } if (Regex.simpleMatch(excludes, path)) { return false; } boolean exactIncludeMatch = false; // true if the current position was specifically mentioned boolean pathIsPrefixOfAnInclude = false; // true if potentially a sub scope can be included if (includes.isEmpty()) { // implied match anything exactIncludeMatch = true; } else { for (String include : includes) { // check for prefix matches as well to see if we need to zero in, something like: obj1.arr1.* or *.field // note, this does not work well with middle matches, like obj1.*.obj3 if (include.charAt(0) == '*') { if (Regex.simpleMatch(include, path)) { exactIncludeMatch = true; break; } // pathIsPrefixOfAnInclude = true; // continue; } if (include.startsWith(path)) { if (include.length() == path.length()) { exactIncludeMatch = true; break; } else if (include.length() > path.length() && include.charAt(path.length()) == '.') { // include might may match deeper paths. Dive deeper. pathIsPrefixOfAnInclude = true; continue; } } if (Regex.simpleMatch(include, path)) { exactIncludeMatch = true; break; } } } // if match or part of the path (based on the passed param) if (exactIncludeMatch || (allowPartialMatches && pathIsPrefixOfAnInclude)) { return true; } return false; }	@param includes	0	1
"public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws RestClientException { Object postBody = new Object(); // verify the required parameter 'petId' is set if (petId == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'petId' when calling uploadFileWithRequiredFile""); } // verify the required parameter 'requiredFile' is set if (requiredFile == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile""); } // create path and map variables final Map<String, Object> uriVariables = new HashMap<String, Object>(); uriVariables.put(""petId"", petId); String path = UriComponentsBuilder.fromPath(""/fake/{petId}/uploadImageWithRequiredFile"").buildAndExpand(uriVariables).toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); if (additionalMetadata != null) formParams.add(""additionalMetadata"", additionalMetadata); if (requiredFile != null) formParams.add(""requiredFile"", new FileSystemResource(requiredFile)); final String[] accepts = { ""application/json"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { ""multipart/form-data"" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { ""petstore_auth"" }; ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {}; return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }"	@param file file to upload	1	0
public static double length(double x, double y, double z) { return Math.sqrt(length2(x, y, z)); }	@param y float The y component.	1	0
private long[][][] createGrid(int[][][] typeArray) throws Exception { long[][][] ids = new long[typeArray.length][][]; for (int i = 0; i < typeArray.length; i++) { // Add screen to DB long screenId = LauncherAppState.getLauncherProvider().generateNewScreenId(); ContentValues v = new ContentValues(); v.put(LauncherSettings.WorkspaceScreens._ID, screenId); v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i); getMockContentResolver().insert(LauncherSettings.WorkspaceScreens.CONTENT_URI, v); ids[i] = new long[typeArray[i].length][]; for (int y = 0; y < typeArray[i].length; y++) { ids[i][y] = new long[typeArray[i][y].length]; for (int x = 0; x < typeArray[i][y].length; x++) { if (typeArray[i][y][x] < 0) { // Empty cell ids[i][y][x] = -1; } else { ids[i][y][x] = addItem(typeArray[i][y][x], screenId, DESKTOP, x, y); } } } } return ids; }	@param typeArray A 3d array of item types. @see #addItem(int, long, long, int, int) for type definitions. The first dimension represents the screens and the next two represent the workspace grid.	0	1
"public Client testClientModel(Client client) throws ApiException { Object localVarPostBody = client; // verify the required parameter 'client' is set if (client == null) { throw new ApiException(400, ""Missing the required parameter 'client' when calling testClientModel""); } // create path and map variables String localVarPath = ""/fake""; // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { ""application/json"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { ""application/json"" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Client> localVarReturnType = new GenericType<Client>() {}; return apiClient.invokeAPI(localVarPath, ""PATCH"", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	@param body client model (required)	1	0
public Call testEndpointParametersAsync(BigDecimal number, Double _double, String string, byte[] _byte, Integer integer, Integer int32, Long int64, Float _float, byte[] binary, Date date, Date dateTime, String password, final ApiCallback<Void> callback) throws ApiException { ProgressResponseBody.ProgressListener progressListener = null; ProgressRequestBody.ProgressRequestListener progressRequestListener = null; if (callback != null) { progressListener = new ProgressResponseBody.ProgressListener() { @Override public void update(long bytesRead, long contentLength, boolean done) { callback.onDownloadProgress(bytesRead, contentLength, done); } }; progressRequestListener = new ProgressRequestBody.ProgressRequestListener() { @Override public void onRequestProgress(long bytesWritten, long contentLength, boolean done) { callback.onUploadProgress(bytesWritten, contentLength, done); } }; } Call call = testEndpointParametersCall(number, _double, string, _byte, integer, int32, int64, _float, binary, date, dateTime, password, progressListener, progressRequestListener); apiClient.executeAsync(call, callback); return call; }	@param number None (required)	0	1
public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws ApiException { ApiResponse<ModelApiResponse> resp = uploadFileWithRequiredFileWithHttpInfo(petId, requiredFile, additionalMetadata); return resp.getData(); }	@param file file to upload (required)	1	0
"public QuoteAnnotator(Properties props, boolean verbose) { USE_SINGLE = Boolean.parseBoolean(props.getProperty(""singleQuotes"", ""false"")); MAX_LENGTH = Integer.parseInt(props.getProperty(""maxLength"", ""-1"")); ASCII_QUOTES = Boolean.parseBoolean(props.getProperty(""asciiQuotes"", ""false"")); ALLOW_EMBEDDED_SAME = Boolean.parseBoolean(props.getProperty(""allowEmbeddedSame"", ""false"")); SMART_QUOTES = Boolean.parseBoolean(props.getProperty(""smartQuotes"", ""false"")); EXTRACT_UNCLOSED = Boolean.parseBoolean(props.getProperty(""extractUnclosedQuotes"", ""false"")); VERBOSE = verbose; Timing timer = null; if (VERBOSE) { timer = new Timing(); log.info(""Preparing quote annotator...""); } if (VERBOSE) { timer.stop(""done.""); } }"	@param verbose whether or not to output verbose information.	0	1
"public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws ApiException { Object localVarPostBody = new Object(); // verify the required parameter 'petId' is set if (petId == null) { throw new ApiException(400, ""Missing the required parameter 'petId' when calling uploadFileWithRequiredFile""); } // verify the required parameter 'requiredFile' is set if (requiredFile == null) { throw new ApiException(400, ""Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile""); } // create path and map variables String localVarPath = ""/fake/{petId}/uploadImageWithRequiredFile"".replaceAll(""\\{format\\}"",""json"") .replaceAll(""\\{"" + ""petId"" + ""\\}"", apiClient.escapeString(petId.toString())); // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); if (additionalMetadata != null) localVarFormParams.put(""additionalMetadata"", additionalMetadata); if (requiredFile != null) localVarFormParams.put(""requiredFile"", requiredFile); final String[] localVarAccepts = { ""application/json"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { ""multipart/form-data"" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { ""petstore_auth"" }; GenericType<ModelApiResponse> localVarReturnType = new GenericType<ModelApiResponse>() {}; return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	@param file file to upload (required)	1	0
"public double getLeadingRowCount(RexNode condition, String tabIdxName, DrillScanRelBase scanRel) { String conditionAsStr = nullConditionAsString; Map<String, StatisticsPayload> payloadMap; if ((scanRel instanceof DrillScanRel && ((DrillScanRel)scanRel).getGroupScan() instanceof DbGroupScan) || (scanRel instanceof ScanPrel && ((ScanPrel)scanRel).getGroupScan() instanceof DbGroupScan)) { if (condition == null && fullTableScanPayload != null) { return fullTableScanPayload.getLeadingRowCount(); } else if (condition != null) { conditionAsStr = convertRexToString(condition, scanRel.getRowType()); payloadMap = statsCache.get(conditionAsStr); if (payloadMap != null) { if (payloadMap.get(tabIdxName) != null) { return payloadMap.get(tabIdxName).getLeadingRowCount(); } // Unlike rowcount, leading rowcount is dependent on the index. So, if tab/idx is // not found, we are out of luck! } } } if (statsAvailable) { logger.debug(""Statistics: Leading filter row count is UNKNOWN for filter: {}"", conditionAsStr); } return ROWCOUNT_UNKNOWN; }"	@param tabIdxName - The table/index identifier	0	1
"public Task<Boolean> contains(final List<CacheKey> keys) { if (keys.isEmpty()) { return Task.forResult(false); } for (CacheKey key : keys) { EncodedImage pinnedImage = mStagingArea.get(key); if (pinnedImage != null) { pinnedImage.close(); FLog.v(TAG, ""Found image for %s in staging area"", key.toString()); mImageCacheStatsTracker.onStagingAreaHit(); return Task.forResult(true); } } Task<Boolean> masterTask = containsAsync(keys.get(0)); if (keys.size() == 1) { return masterTask; } for (final CacheKey key : keys.subList(1, keys.size())) { masterTask = masterTask.continueWithTask( new Continuation<Boolean, Task<Boolean>>() { @Override public Task<Boolean> then(Task<Boolean> previousTask) throws Exception { if (previousTask.isCancelled() || previousTask.getResult()) { return previousTask; } return containsAsync(key); } }, mReadExecutor); } return masterTask; }"	@param key	1	0
"protected Object convertSetToString(List<String> options, Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return """"; } if (data instanceof String) { // JDBC should return strings ... return data; } if (data instanceof Long) { // The binlog will contain a long with the indexes of the options in the set value ... long indexes = ((Long) data).longValue(); return convertSetValue(indexes, options); } return handleUnknownData(column, fieldDefn, data); }"	@param data the data object to be converted into an SET literal String value; never null	0	1
public static Area getClickbox(@Nonnull Client client, Model model, int orientation, int localX, int localY) { if (model == null) { return null; } List<Triangle> triangles = model.getTriangles().stream() .map(triangle -> triangle.rotate(orientation)) .collect(Collectors.toList()); List<Vertex> vertices = model.getVertices().stream() .map(v -> v.rotate(orientation)) .collect(Collectors.toList()); Area clickBox = get2DGeometry(client, triangles, orientation, localX, localY); Area visibleAABB = getAABB(client, vertices, orientation, localX, localY); if (visibleAABB == null || clickBox == null) { return null; } clickBox.intersect(visibleAABB); return clickBox; }	@param tileX the x-axis coordinate of the tile	1	0
private static ResultPoint[] findVertices180(BitMatrix matrix, boolean tryHarder) { int height = matrix.getHeight(); int width = matrix.getWidth(); int halfWidth = width >> 1; ResultPoint[] result = new ResultPoint[8]; boolean found = false; int[] counters = new int[START_PATTERN_REVERSE.length]; int rowStep = Math.max(1, height >> (tryHarder ? 9 : 7)); // Top Left for (int i = height - 1; i > 0; i -= rowStep) { int[] loc = findGuardPattern(matrix, halfWidth, i, halfWidth, true, START_PATTERN_REVERSE, counters); if (loc != null) { result[0] = new ResultPoint(loc[1], i); result[4] = new ResultPoint(loc[0], i); found = true; break; } } // Bottom Left if (found) { // Found the Top Left vertex found = false; for (int i = 0; i < height; i += rowStep) { int[] loc = findGuardPattern(matrix, halfWidth, i, halfWidth, true, START_PATTERN_REVERSE, counters); if (loc != null) { result[1] = new ResultPoint(loc[1], i); result[5] = new ResultPoint(loc[0], i); found = true; break; } } } counters = new int[STOP_PATTERN_REVERSE.length]; // Top Right if (found) { // Found the Bottom Left vertex found = false; for (int i = height - 1; i > 0; i -= rowStep) { int[] loc = findGuardPattern(matrix, 0, i, halfWidth, false, STOP_PATTERN_REVERSE, counters); if (loc != null) { result[2] = new ResultPoint(loc[0], i); result[6] = new ResultPoint(loc[1], i); found = true; break; } } } // Bottom Right if (found) { // Found the Top Right vertex found = false; for (int i = 0; i < height; i += rowStep) { int[] loc = findGuardPattern(matrix, 0, i, halfWidth, false, STOP_PATTERN_REVERSE, counters); if (loc != null) { result[3] = new ResultPoint(loc[0], i); result[7] = new ResultPoint(loc[1], i); found = true; break; } } } return found ? result : null; }	@param matrix the scanned barcode image.	0	1
public static AnnotationMirror getAnnotationMirror(Element element, String fqcn) { assert element != null; assert fqcn != null; AnnotationMirror mirror = null; for ( AnnotationMirror am : element.getAnnotationMirrors() ) { if ( isAnnotationMirrorOfType( am, fqcn ) ) { mirror = am; break; } } return mirror; }	@param clazz the annotation class to check for	1	0
public Client testSpecialTags(Client client) throws ApiException { ApiResponse<Client> resp = testSpecialTagsWithHttpInfo(client); return resp.getData(); }	@param body client model (required)	1	0
"public TableSchema create(String schemaPrefix, String envelopSchemaName, Table table, ColumnNameFilter filter, ColumnMappers mappers, CustomKeyMapper keysMapper) { if (schemaPrefix == null) { schemaPrefix = """"; } // Build the schemas ... final TableId tableId = table.id(); final String tableIdStr = tableSchemaName(tableId); final String schemaNamePrefix = schemaPrefix + tableIdStr; LOGGER.debug(""Mapping table '{}' to schemas under '{}'"", tableId, schemaNamePrefix); SchemaBuilder valSchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + "".Value"")); SchemaBuilder keySchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + "".Key"")); AtomicBoolean hasPrimaryKey = new AtomicBoolean(false); Key tableKey = new Key.Builder(table).customKeyMapper(keysMapper).build(); tableKey.keyColumns().forEach(column -> { addField(keySchemaBuilder, column, null); hasPrimaryKey.set(true); }); table.columns() .stream() .filter(column -> filter == null || filter.matches(tableId.catalog(), tableId.schema(), tableId.table(), column.name())) .forEach(column -> { ColumnMapper mapper = mappers == null ? null : mappers.mapperFor(tableId, column); addField(valSchemaBuilder, column, mapper); }); Schema valSchema = valSchemaBuilder.optional().build(); Schema keySchema = hasPrimaryKey.get() ? keySchemaBuilder.build() : null; if (LOGGER.isDebugEnabled()) { LOGGER.debug(""Mapped primary key for table '{}' to schema: {}"", tableId, SchemaUtil.asDetailedString(keySchema)); LOGGER.debug(""Mapped columns for table '{}' to schema: {}"", tableId, SchemaUtil.asDetailedString(valSchema)); } Envelope envelope = Envelope.defineSchema() .withName(schemaNameAdjuster.adjust(envelopSchemaName)) .withRecord(valSchema) .withSource(sourceInfoSchema) .build(); // Create the generators ... Function<Object[], Object> keyGenerator = createKeyGenerator(keySchema, tableId, tableKey.keyColumns()); Function<Object[], Struct> valueGenerator = createValueGenerator(valSchema, tableId, table.columns(), filter, mappers); // And the table schema ... return new TableSchema(tableId, keySchema, keyGenerator, envelope, valSchema, valueGenerator); }"	@param schemaPrefix the prefix added to the table identifier to construct the schema names; may be null if there is no prefix	0	1
public int[] indices(Collection<E> elements) { int[] indices = new int[elements.size()]; int i = 0; for (E elem : elements) { indices[i++] = indexOf(elem); } return indices; }	@param elems The list of items	1	0
protected boolean processExtensionPopupChildren(PopupMenuUtils.PopupMenuInvokerWrapper invokerWrapper) { boolean childEnable = false; for (int index = 0; index < this.getItemCount(); index++) { JMenuItem item = this.getItem(index); if (isEnableForComponent(item, invokerWrapper)) { childEnable = true; } } return childEnable; }	@param invoker the component of the invoker	1	0
public Object execute(String commandName, Map<String, ?> parameters) { Response response; if (parameters == null || parameters.size() == 0) { response = driver.execute(commandName); } else { response = driver.execute(commandName, parameters); } return response.getValue(); }	@param parameters The parameters to execute that command with	0	1
public Client call123testSpecialTags(Client body, Map<String, Object> params) throws IOException { HttpResponse response = call123testSpecialTagsForHttpResponse(body, params); TypeReference typeRef = new TypeReference<Client>() {}; return apiClient.getObjectMapper().readValue(response.getContent(), typeRef); }	@param client client model	1	0
public Configuration setCacheConcurrencyStrategy(String entityName, String concurrencyStrategy) { setCacheConcurrencyStrategy( entityName, concurrencyStrategy, entityName ); return this; }	@param clazz	1	0
"public List<String> dependencyPathBetween(int start, int end, Optional<Function<Sentence, List<String>>> selector) { // Get paths from a node to the root of the sentence LinkedList<Integer> rootToStart = new LinkedList<>(); LinkedList<Integer> rootToEnd = new LinkedList<>(); int startAncestor = start; List<Optional<Integer>> governors = sentence.governors(); Set<Integer> seenVertices = new HashSet<>(); while (startAncestor >= 0 && governors.get(startAncestor).isPresent()) { if (seenVertices.contains(startAncestor)) { // Found loopiness -- revert to BFS return loopyDependencyPathBetween(start, end, selector); } seenVertices.add(startAncestor); rootToStart.addFirst(startAncestor); startAncestor = governors.get(startAncestor).get(); } if (startAncestor == -1) { rootToStart.addFirst(-1); } int endAncestor = end; seenVertices.clear(); while (endAncestor >= 0 && governors.get(endAncestor).isPresent()) { if (seenVertices.contains(endAncestor)) { // Found loopiness -- revert to BFS return loopyDependencyPathBetween(start, end, selector); } seenVertices.add(endAncestor); rootToEnd.addFirst(endAncestor); endAncestor = governors.get(endAncestor).get(); } if (endAncestor == -1) { rootToEnd.addFirst(-1); } // Get least common node int leastCommonNodeIndex = (rootToStart.size() == 0 || rootToEnd.size() == 0 || !rootToStart.get(0).equals(rootToEnd.get(0))) ? -1 : 0; for (int i = 1; i < Math.min(rootToStart.size(), rootToEnd.size()); ++i) { if (rootToStart.get(i).equals(rootToEnd.get(i))) { leastCommonNodeIndex = i; } } // Construct the path if (leastCommonNodeIndex < 0) { return Collections.emptyList(); } List<String> path = new ArrayList<>(); Optional<List<String>> words = selector.map(x -> x.apply(sentence)); for (int i = rootToStart.size() - 1; i > leastCommonNodeIndex; --i) { final int index = i; words.ifPresent(x -> path.add(x.get(rootToStart.get(index)))); path.add(""<-"" + sentence.incomingDependencyLabel(rootToStart.get(i)).orElse(""dep"") + ""-""); } if (words.isPresent()) { path.add(words.get().get(rootToStart.get(leastCommonNodeIndex))); } for (int i = leastCommonNodeIndex + 1; i < rootToEnd.size(); ++i) { final int index = i; path.add(""-"" + sentence.incomingDependencyLabel(rootToEnd.get(i)).orElse(""dep"") + ""->""); words.ifPresent(x -> path.add(x.get(rootToEnd.get(index)))); } return path; }"	@param The type of the element we are getting.	1	0
private SQLResponse execute(String correctedSql, SQLRequest sqlRequest, Connection conn) throws Exception { Statement stat = null; ResultSet resultSet = null; Boolean isPushDown = false; List<List<String>> results = Lists.newArrayList(); List<SelectedColumnMeta> columnMetas = Lists.newArrayList(); try { // special case for prepare query. if (BackdoorToggles.getPrepareOnly()) { return getPrepareOnlySqlResponse(correctedSql, conn, isPushDown, results, columnMetas); } stat = conn.createStatement(); processStatementAttr(stat, sqlRequest); resultSet = stat.executeQuery(correctedSql); ResultSetMetaData metaData = resultSet.getMetaData(); int columnCount = metaData.getColumnCount(); // Fill in selected column meta for (int i = 1; i <= columnCount; ++i) { columnMetas.add(new SelectedColumnMeta(metaData.isAutoIncrement(i), metaData.isCaseSensitive(i), metaData.isSearchable(i), metaData.isCurrency(i), metaData.isNullable(i), metaData.isSigned(i), metaData.getColumnDisplaySize(i), metaData.getColumnLabel(i), metaData.getColumnName(i), metaData.getSchemaName(i), metaData.getCatalogName(i), metaData.getTableName(i), metaData.getPrecision(i), metaData.getScale(i), metaData.getColumnType(i), metaData.getColumnTypeName(i), metaData.isReadOnly(i), metaData.isWritable(i), metaData.isDefinitelyWritable(i))); } // fill in results while (resultSet.next()) { List<String> oneRow = Lists.newArrayListWithCapacity(columnCount); for (int i = 0; i < columnCount; i++) { oneRow.add((resultSet.getString(i + 1))); } results.add(oneRow); } } catch (SQLException sqlException) { isPushDown = PushDownUtil.doPushDownQuery(sqlRequest.getProject(), correctedSql, conn.getSchema(), results, columnMetas, sqlException); if (!isPushDown) { throw sqlException; } } finally { close(resultSet, stat, null);//conn is passed in, not my duty to close } return getSqlResponse(isPushDown, results, columnMetas); }	@param sqlRequest	0	1
public static Predicate<ColumnId> excludeColumns(String fullyQualifiedColumnNames) { return Predicates.excludes(fullyQualifiedColumnNames, ColumnId::toString); }	@param columnNames the comma-separated list of column names names to exclude; may be null or empty	1	0
public static ParquetTableMetadata_v4 getParquetTableMetadata(FileSystem fs, Path path, ParquetReaderConfig readerConfig) throws IOException { Metadata metadata = new Metadata(readerConfig); return metadata.getParquetTableMetadata(path, fs); }	@param fs file system	0	1
"public List<CodegenSecurity> fromSecurity(Map<String, SecurityScheme> securitySchemeMap) { if (securitySchemeMap == null) { return Collections.emptyList(); } List<CodegenSecurity> codegenSecurities = new ArrayList<CodegenSecurity>(securitySchemeMap.size()); for (String key : securitySchemeMap.keySet()) { final SecurityScheme securityScheme = securitySchemeMap.get(key); CodegenSecurity cs = CodegenModelFactory.newInstance(CodegenModelType.SECURITY); cs.name = key; cs.type = securityScheme.getType().toString(); cs.isCode = cs.isPassword = cs.isApplication = cs.isImplicit = false; if (SecurityScheme.Type.APIKEY.equals(securityScheme.getType())) { cs.isBasic = cs.isOAuth = false; cs.isApiKey = true; cs.keyParamName = securityScheme.getName(); cs.isKeyInHeader = securityScheme.getIn() == SecurityScheme.In.HEADER; cs.isKeyInQuery = !cs.isKeyInHeader; } else if (SecurityScheme.Type.HTTP.equals(securityScheme.getType())) { cs.isKeyInHeader = cs.isKeyInQuery = cs.isApiKey = cs.isOAuth = false; cs.isBasic = true; } else if (SecurityScheme.Type.OAUTH2.equals(securityScheme.getType())) { cs.isKeyInHeader = cs.isKeyInQuery = cs.isApiKey = cs.isBasic = false; cs.isOAuth = true; final OAuthFlows flows = securityScheme.getFlows(); if (securityScheme.getFlows() == null) { throw new RuntimeException(""missing oauth flow in "" + cs.name); } if (flows.getPassword() != null) { setOauth2Info(cs, flows.getPassword()); cs.isPassword = true; cs.flow = ""password""; } else if (flows.getImplicit() != null) { setOauth2Info(cs, flows.getImplicit()); cs.isImplicit = true; cs.flow = ""implicit""; } else if (flows.getClientCredentials() != null) { setOauth2Info(cs, flows.getClientCredentials()); cs.isApplication = true; cs.flow = ""application""; } else if (flows.getAuthorizationCode() != null) { setOauth2Info(cs, flows.getAuthorizationCode()); cs.isCode = true; cs.flow = ""accessCode""; } else { throw new RuntimeException(""Could not identify any oauth2 flow in "" + cs.name); } } codegenSecurities.add(cs); } // sort auth methods to maintain the same order Collections.sort(codegenSecurities, new Comparator<CodegenSecurity>() { @Override public int compare(CodegenSecurity one, CodegenSecurity another) { return ObjectUtils.compare(one.name, another.name); } }); // set 'hasMore' Iterator<CodegenSecurity> it = codegenSecurities.iterator(); while (it.hasNext()) { final CodegenSecurity security = it.next(); security.hasMore = it.hasNext(); } return codegenSecurities; }"	@param schemes a map of Swagger SecuritySchemeDefinition object	1	0
"public Object getCollection(Serializable key, SharedSessionContractImplementor session, Object owner) { CollectionPersister persister = getPersister( session ); final PersistenceContext persistenceContext = session.getPersistenceContext(); final EntityMode entityMode = persister.getOwnerEntityPersister().getEntityMode(); // check if collection is currently being loaded PersistentCollection collection = persistenceContext.getLoadContexts().locateLoadingCollection( persister, key ); if ( collection == null ) { // check if it is already completely loaded, but unowned collection = persistenceContext.useUnownedCollection( new CollectionKey(persister, key, entityMode) ); if ( collection == null ) { collection = persistenceContext.getCollection( new CollectionKey(persister, key, entityMode) ); if ( collection == null ) { // create a new collection wrapper, to be initialized later collection = instantiate( session, persister, key ); collection.setOwner( owner ); persistenceContext.addUninitializedCollection( persister, collection, key ); // some collections are not lazy: if ( initializeImmediately() ) { session.initializeCollection( collection, false ); } else if ( !persister.isLazy() ) { persistenceContext.addNonLazyCollection( collection ); } if ( hasHolder() ) { session.getPersistenceContext().addCollectionHolder( collection ); } } } if ( LOG.isTraceEnabled() ) { LOG.tracef( ""Created collection wrapper: %s"", MessageHelper.collectionInfoString( persister, collection, key, session ) ); } } collection.setOwner(owner); return collection.getValue(); }"	@param key The collection owner key	0	1
"private StringBuilder appendIfNotNull(StringBuilder source, String addStr, String delimiter) { if (addStr != null) { if (addStr.length() == 0) { delimiter = """"; } return source.append(addStr).append(delimiter); } return source; }"	@param appendStr The String to append	1	0
"public Action cancelled(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException { synchronized (req) { AtmosphereResourceImpl r = null; try { if (trackActiveRequest) { long l = (Long) req.getAttribute(MAX_INACTIVE); if (l == -1) { // The closedDetector closed the connection. return timedoutAction; } req.setAttribute(MAX_INACTIVE, (long) -1); } logger.debug(""Cancelling the connection for request {}"", req); r = (AtmosphereResourceImpl) req.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE); if (r != null) { r.getAtmosphereResourceEvent().setCancelled(true); invokeAtmosphereHandler(r); try { r.getResponse().sendError(503); r.getResponse().getOutputStream().close(); } catch (Throwable t) { try { r.getResponse().getWriter().close(); } catch (Throwable t2) { } } } } catch (Throwable ex) { // Something wrong happenned, ignore the exception logger.debug(""failed to cancel resource: "" + r, ex); } finally { try { if (r != null) { r.notifyListeners(); r.setIsInScope(false); r.cancel(); } } catch (Throwable t) { logger.trace(""cancel"", t); } finally { if (r != null) { destroyResource(r); } } } } return cancelledAction; }"	@param req the HttpServletRequest	1	0
public static Connection generateProxy(LogicalConnectionImpl logicalConnection) { BorrowedConnectionProxy handler = new BorrowedConnectionProxy( logicalConnection ); return ( Connection ) Proxy.newProxyInstance( getProxyClassLoader(), PROXY_INTERFACES, handler ); }	@param connectionManager The connection manager to wrap with the connection proxy.	1	0
public PendingMessageCursor getSubscriberPendingMessageCursor(Broker broker,String clientId, String name, int maxBatchSize, DurableTopicSubscription sub) { StoreDurableSubscriberCursor cursor = new StoreDurableSubscriberCursor(broker,clientId, name, maxBatchSize, sub); cursor.setImmediatePriorityDispatch(isImmediatePriorityDispatch()); return cursor; }	@param clientId	0	1
"public Lock acquirePutFromLoadLock(SharedSessionContractImplementor session, Object key, long txTimestamp) { if (trace) { log.tracef(""acquirePutFromLoadLock(%s#%s, %d)"", cache.getName(), key, txTimestamp); } boolean locked = false; PendingPutMap pending = pendingPuts.get( key ); for (;;) { try { if (pending != null) { locked = pending.acquireLock(100, TimeUnit.MILLISECONDS); if (locked) { boolean valid = false; try { if (pending.isRemoved()) { // this deals with a race between retrieving the map from cache vs. removing that // and locking the map pending.releaseLock(); locked = false; pending = null; if (trace) { log.tracef(""Record removed when waiting for the lock.""); } continue; } final PendingPut toCancel = pending.remove(session); if (toCancel != null) { valid = !toCancel.completed; toCancel.completed = true; } else { // this is a naked put if (pending.hasInvalidator()) { valid = false; } // we need this check since registerPendingPut (creating new pp) can get between invalidation // and naked put caused by the invalidation else if (pending.lastInvalidationEnd != Long.MIN_VALUE) { // if this transaction started afterQuery last invalidation we can continue valid = txTimestamp > pending.lastInvalidationEnd; } else { valid = txTimestamp > regionInvalidationTimestamp; } } return valid ? pending : null; } finally { if (!valid && pending != null) { pending.releaseLock(); locked = false; } if (trace) { log.tracef(""acquirePutFromLoadLock(%s#%s, %d) ended with %s, valid: %s"", cache.getName(), key, txTimestamp, pending, valid); } } } else { if (trace) { log.tracef(""acquirePutFromLoadLock(%s#%s, %d) failed to lock"", cache.getName(), key, txTimestamp); } // oops, we have leaked record for this owner, but we don't want to wait here return null; } } else { long regionInvalidationTimestamp = this.regionInvalidationTimestamp; if (txTimestamp <= regionInvalidationTimestamp) { if (trace) { log.tracef(""acquirePutFromLoadLock(%s#%s, %d) failed due to region invalidated at %d"", cache.getName(), key, txTimestamp, regionInvalidationTimestamp); } return null; } else { if (trace) { log.tracef(""Region invalidated at %d, this transaction started at %d"", regionInvalidationTimestamp, txTimestamp); } } PendingPut pendingPut = new PendingPut(session); pending = new PendingPutMap(pendingPut); PendingPutMap existing = pendingPuts.putIfAbsent(key, pending); if (existing != null) { pending = existing; } // continue in next loop with lock acquisition } } catch (Throwable t) { if (locked) { pending.releaseLock(); } if (t instanceof RuntimeException) { throw (RuntimeException) t; } else if (t instanceof Error) { throw (Error) t; } else { throw new RuntimeException(t); } } } }"	@param txTimestamp	0	1
public boolean searchText(String text, int minimumNumberOfMatches, boolean scroll) { return searcher.searchWithTimeoutFor(TextView.class, text, minimumNumberOfMatches, scroll); }	@param expectedMinimumNumberOfMatches the minimum number of matches expected to be found. 0 matches means that one or more matches are expected to be found	1	0
public static BooleanOperation predicate(Operator operation, Expression<?>... args) { return new BooleanOperation(operation, args); }	@param operator operator	1	0
public int compareTo(ReadablePartial partial) { // override to perform faster if (this == partial) { return 0; } if (partial instanceof LocalDate) { LocalDate other = (LocalDate) partial; if (iChronology.equals(other.iChronology)) { return (iLocalMillis < other.iLocalMillis ? -1 : (iLocalMillis == other.iLocalMillis ? 0 : 1)); } } return super.compareTo(partial); }	@param partial an object to check against	0	1
public ServiceBuilder signatureType(OAuth1SignatureType signatureType) { this.signatureType = signatureType; return this; }	@param signatureType SignatureType	1	0
"public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); final String url = buildUrl(path, queryParams); final Request.Builder reqBuilder = new Request.Builder().url(url); processHeaderParams(headerParams, reqBuilder); String contentType = (String) headerParams.get(""Content-Type""); // ensuring a default content type if (contentType == null) contentType = ""application/json""; RequestBody reqBody; if (!HttpMethod.permitsRequestBody(method)) { reqBody = null; } else if (""application/x-www-form-urlencoded"".equals(contentType)) { reqBody = buildRequestBodyFormEncoding(formParams); } else if (""multipart/form-data"".equals(contentType)) { reqBody = buildRequestBodyMultipart(formParams); } else if (body == null) { if (""DELETE"".equals(method)) { // allow calling DELETE without sending a request body reqBody = null; } else { // use an empty request body (for POST, PUT and PATCH) reqBody = RequestBody.create(MediaType.parse(contentType), """"); } } else { reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType)); } Request request = reqBuilder.method(method, reqBody).build(); return httpClient.newCall(request); }"	@param body The request body object	0	1
public View waitForView(int id, int index, int timeout, boolean scroll){ Set<View> uniqueViewsMatchingId = new HashSet<View>(); long endTime = SystemClock.uptimeMillis() + timeout; while (SystemClock.uptimeMillis() <= endTime) { sleeper.sleep(); for (View view : viewFetcher.getAllViews(false)) { Integer idOfView = Integer.valueOf(view.getId()); if (idOfView.equals(id)) { uniqueViewsMatchingId.add(view); if(uniqueViewsMatchingId.size() > index) { return view; } } } if(scroll) scroller.scroll(Scroller.DOWN); } return null; }	@param view the id of the view to wait for	0	1
public RexProgram normalize(RexBuilder rexBuilder, RexSimplify simplify) { // Normalize program by creating program builder from the program, then // converting to a program. getProgram does not need to normalize // because the builder was normalized on creation. assert isValid(Litmus.THROW, null); final RexProgramBuilder builder = RexProgramBuilder.create(rexBuilder, inputRowType, exprs, projects, condition, outputRowType, true, simplify); return builder.getProgram(false); }	@param simplify Whether to simplify (in addition to normalizing)	1	0
public Tree spliceOut(final Predicate<Tree> nodeFilter, final TreeFactory tf) { List<Tree> l = spliceOutHelper(nodeFilter, tf); if (l.isEmpty()) { return null; } else if (l.size() == 1) { return l.get(0); } // for a forest, make a new root return tf.newTreeNode((Label) null, l); }	@param nodeFilter a Filter method which returns true to mean keep this node, false to mean delete it	0	1
public Action resumed(AtmosphereRequest request, AtmosphereResponse response) throws IOException, ServletException { return action(request, response); }	@param response the HttpServletResponse	1	0
"public Action cancelled(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException { synchronized (req) { AtmosphereResourceImpl r = null; try { if (trackActiveRequest) { long l = (Long) req.getAttribute(MAX_INACTIVE); if (l == -1) { // The closedDetector closed the connection. return timedoutAction; } req.setAttribute(MAX_INACTIVE, (long) -1); } logger.debug(""Cancelling the connection for request {}"", req); r = (AtmosphereResourceImpl) req.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE); if (r != null) { r.getAtmosphereResourceEvent().setCancelled(true); invokeAtmosphereHandler(r); try { r.getResponse().sendError(503); r.getResponse().getOutputStream().close(); } catch (Throwable t) { try { r.getResponse().getWriter().close(); } catch (Throwable t2) { } } } } catch (Throwable ex) { // Something wrong happenned, ignore the exception logger.debug(""failed to cancel resource: "" + r, ex); } finally { try { if (r != null) { r.notifyListeners(); r.setIsInScope(false); r.cancel(); } } catch (Throwable t) { logger.trace(""cancel"", t); } finally { if (r != null) { destroyResource(r); } } } } return cancelledAction; }"	@param res the HttpServletResponse	1	0
public static <T> Method findMethod(Class<?> implClass, Operation<T> operation) throws NoSuchMethodException { String name = operation.getName(); Class<?>[] paramTypes = getPhysicalTypes(operation); return implClass.getMethod(name, paramTypes); }	@param methods the methods to match against	1	0
public String getShortName(long instant, Locale locale) { if (locale == null) { locale = Locale.getDefault(); } String nameKey = getNameKey(instant); if (nameKey == null) { return iID; } String name = cNameProvider.getShortName(locale, iID, nameKey); if (name != null) { return name; } return offsetFormatter().print(instant, this); }	@param millis milliseconds from 1970-01-01T00:00:00Z to get the name for	1	0
"private String runHTMLSuite(String browser, String browserURL, String suiteURL, File outputFile, long timeoutInSeconds, boolean multiWindow, String defaultLogLevel) throws IOException { outputFile.createNewFile(); if (!outputFile.canWrite()) { throw new IOException(""Can't write to outputFile: "" + outputFile.getAbsolutePath()); } long timeoutInMs = 1000l * timeoutInSeconds; if (timeoutInMs < 0) { log.warn(""Looks like the timeout overflowed, so resetting it to the maximum.""); timeoutInMs = Long.MAX_VALUE; } RemoteControlConfiguration configuration = remoteControl.getConfiguration(); remoteControl.handleHTMLRunnerResults(this); String sessionId = Long.toString(System.currentTimeMillis() % 1000000); FrameGroupCommandQueueSet.makeQueueSet( sessionId, configuration.getPortDriversShouldContact(), configuration); BrowserConfigurationOptions browserOptions = new BrowserConfigurationOptions(); configuration.copySettingsIntoBrowserOptions(browserOptions); browserOptions.setSingleWindow(!multiWindow); BrowserLauncher launcher = getBrowserLauncher(browser, sessionId, configuration, browserOptions); BrowserSessionInfo sessionInfo = new BrowserSessionInfo(sessionId, browser, browserURL, launcher, null); remoteControl.registerBrowserSession(sessionInfo); // JB: -- aren't these URLs in the wrong order according to declaration? launcher.launchHTMLSuite(suiteURL, browserURL); sleepTight(timeoutInMs); launcher.close(); remoteControl.deregisterBrowserSession(sessionInfo); if (results == null) { throw new SeleniumCommandTimedOutException(); } writeResults(outputFile); return results.getResult().toUpperCase(); }"	@param outputFile - The file to which we'll output the HTML results	0	1
protected static TableId parse(String[] parts, int numParts, boolean useCatalogBeforeSchema) { if (numParts == 0) return null; if (numParts == 1) return new TableId(null, null, parts[0]); // table only if (numParts == 2) { if (useCatalogBeforeSchema) return new TableId(parts[0], null, parts[1]); // catalog & table only return new TableId(null, parts[0], parts[1]); // catalog & table only } return new TableId(parts[0], parts[1], parts[2]); // catalog & table only }	@param delimiter the delimiter between parts	1	0
public boolean isFlagSet(int flagsToCheck) { return (flags & flagsToCheck) != 0; }	@param flag the flag to check	1	0
"public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); for(String key : queryParams.keySet()) { String value = queryParams.get(key); if (value != null){ if(b.toString().length() == 0) b.append(""?""); else b.append(""&""); b.append(escapeString(key)).append(""="").append(escapeString(value)); } } String querystring = b.toString(); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(""GET"".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (""POST"".equals(method)) { if (contentType.startsWith(""application/x-www-form-urlencoded"")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (""PUT"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (""DELETE"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, ""unknown method type "" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return """"; } } else { String message = ""error""; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { // e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }"	@param accept The request's Accept header	0	1
"private String runHTMLSuite(String browser, String browserURL, String suiteURL, File outputFile, long timeoutInSeconds, boolean multiWindow, String defaultLogLevel) throws IOException { outputFile.createNewFile(); if (!outputFile.canWrite()) { throw new IOException(""Can't write to outputFile: "" + outputFile.getAbsolutePath()); } long timeoutInMs = 1000l * timeoutInSeconds; if (timeoutInMs < 0) { log.warn(""Looks like the timeout overflowed, so resetting it to the maximum.""); timeoutInMs = Long.MAX_VALUE; } RemoteControlConfiguration configuration = remoteControl.getConfiguration(); remoteControl.handleHTMLRunnerResults(this); String sessionId = Long.toString(System.currentTimeMillis() % 1000000); FrameGroupCommandQueueSet.makeQueueSet( sessionId, configuration.getPortDriversShouldContact(), configuration); BrowserConfigurationOptions browserOptions = new BrowserConfigurationOptions(); configuration.copySettingsIntoBrowserOptions(browserOptions); browserOptions.setSingleWindow(!multiWindow); BrowserLauncher launcher = getBrowserLauncher(browser, sessionId, configuration, browserOptions); BrowserSessionInfo sessionInfo = new BrowserSessionInfo(sessionId, browser, browserURL, launcher, null); remoteControl.registerBrowserSession(sessionInfo); // JB: -- aren't these URLs in the wrong order according to declaration? launcher.launchHTMLSuite(suiteURL, browserURL); sleepTight(timeoutInMs); launcher.close(); remoteControl.deregisterBrowserSession(sessionInfo); if (results == null) { throw new SeleniumCommandTimedOutException(); } writeResults(outputFile); return results.getResult().toUpperCase(); }"	@param defaultLogLevel TODO	0	1
"public boolean isNormalized(Litmus litmus, RexBuilder rexBuilder) { final RexProgram normalizedProgram = normalize(rexBuilder, false); String normalized = normalizedProgram.toString(); String string = toString(); if (!normalized.equals(string)) { return litmus.fail(""Program is not normalized:\n"" + ""program: "" + string + ""\n"" + ""normalized: "" + normalized + ""\n""); } return litmus.succeed(); }"	@param rexBuilder Rex builder	0	1
"public boolean highlightNode(JavaEditor editor){ if (!(node instanceof SimpleName)) { return false; } SimpleName nodeName = (SimpleName) node; try { //TODO: Redundant code. See ASTGenerator.getJavaSourceCodeline() int javaLineNumber = getLineNumber(nodeName); int pdeOffs[] = editor.getErrorChecker().calculateTabIndexAndLineNumber(javaLineNumber); PlainDocument javaSource = new PlainDocument(); javaSource.insertString(0, editor.getErrorChecker().sourceCode, null); Element lineElement = javaSource.getDefaultRootElement() .getElement(javaLineNumber-1); if(lineElement == null) { Messages.log(lineNumber + "" line element null while highlighting "" + nodeName); return false; } String javaLine = javaSource.getText(lineElement.getStartOffset(), lineElement.getEndOffset() - lineElement.getStartOffset()); editor.getSketch().setCurrentCode(pdeOffs[0]); String pdeLine = editor.getLineText(pdeOffs[1]); String lookingFor = nodeName.toString(); Messages.log(lookingFor + "", "" + nodeName.getStartPosition()); Messages.log(javaLineNumber +"" JL "" + javaLine + "" LSO "" + lineElement.getStartOffset() + "","" + lineElement.getEndOffset()); Messages.log(pdeOffs[1] + "" PL "" + pdeLine); if (!javaLine.contains(lookingFor) || !pdeLine.contains(lookingFor)) { Messages.loge(""Logical error in highLightNode(). Please file a bug report.""); return false; } OffsetMatcher ofm = new OffsetMatcher(pdeLine, javaLine); int highlightStart = ofm.getPdeOffForJavaOff(nodeName.getStartPosition() - lineElement.getStartOffset(), nodeName.getLength()); if (highlightStart == -1) { Messages.loge(""Logical error in highLightNode() during offset matching. "" + ""Please file a bug report.""); return false; } int lso = editor.getTextArea().getLineStartOffset(pdeOffs[1]); highlightStart += lso; editor.setSelection(highlightStart, highlightStart + nodeName.getLength()); /* // First find the name in the java line, and marks its index Pattern toFind = Pattern.compile(""\\b"" + nodeName.toString() + ""\\b""); Matcher matcher = toFind.matcher(javaLine); int count = 0, index = 0; int lsto = lineElement.getStartOffset(); while(matcher.find()){ count++; //log(matcher.start() + lsto); if(lsto + matcher.start() == nodeName.getStartPosition()) break; } log(""count="" + count); index = 0; // find the same name in the pde line by its index and get its offsets matcher = toFind.matcher(pdeLine); while(matcher.find()){ count--; if(count == 0){ log(""Found on pde line lso: "" + matcher.start()); index = matcher.end(); break; } } log(""pde lso "" + (index - lookingFor.length())); int lso = astGenerator.editor.ta.getLineStartOffset(pdeOffs[1]); astGenerator.editor.setSelection(lso + index - lookingFor.length(), lso + index); */ return true; } catch (BadLocationException e) { Messages.loge(""BLE in highLightNode() for "" + nodeName); e.printStackTrace(); } return false; }"	@param astGenerator	1	0
private CollectionPersister getPersister(SharedSessionContractImplementor session) { return session.getFactory().getMetamodel().collectionPersister( role ); }	@param session The session from which the request is originating.	0	1
public boolean searchText(String text) { boolean found = searcher.searchWithTimeoutFor(TextView.class, search, 0, true); return found; }	@param regex the text to search for. The parameter will be interpreted as a regular expression.	1	0
public int get(long instant) { int year = iChronology.year().get(instant); // long firstWeekMillis1 = iChronology.getFirstWeekOfYearMillis(year); if (instant < firstWeekMillis1) { return iChronology.getWeeksInYear(year - 1); } long firstWeekMillis2 = iChronology.getFirstWeekOfYearMillis(year + 1); if (instant >= firstWeekMillis2) { return 1; } return (int) ((instant - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK) + 1; }	@param millis the time instant in millis to query.	1	0
"public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); for(String key : queryParams.keySet()) { String value = queryParams.get(key); if (value != null){ if(b.toString().length() == 0) b.append(""?""); else b.append(""&""); b.append(escapeString(key)).append(""="").append(escapeString(value)); } } String querystring = b.toString(); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(""GET"".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (""POST"".equals(method)) { if (contentType.startsWith(""application/x-www-form-urlencoded"")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (""PUT"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (""DELETE"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, ""unknown method type "" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return """"; } } else { String message = ""error""; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { // e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }"	@param queryParams The query parameters	0	1
public static String getTableName(String oriSql) { //æ­¤å¤åºè¯¥ä¼åä¸ºå»æsqlä¸­çæ³¨éï¼æå ¼å®¹æ³¨é String sql=null; if(oriSql.startsWith(LoadData.loadDataHint)) { sql=oriSql.substring(LoadData.loadDataHint.length()) ; } else { sql=oriSql; } int pos = 0; boolean insertFound = false; boolean intoFound = false; int tableStartIndx = -1; int tableEndIndex = -1; while (pos < sql.length()) { char ch = sql.charAt(pos); if (ch <= ' ' || ch == '(' || ch=='`') {// if (tableStartIndx > 0) { tableEndIndex = pos; break; } else { pos++; continue; } } else if (ch == 'i' || ch == 'I') { if (intoFound) { if (tableStartIndx == -1 && ch!='`') { tableStartIndx = pos; } pos++; } else if (insertFound) {// into start pos = pos + 5; intoFound = true; } else { // insert start pos = pos + 7; insertFound = true; } } else { if (tableStartIndx == -1) { tableStartIndx = pos; } pos++; } } return sql.substring(tableStartIndx, tableEndIndex); }	@param sql	0	1
private static void algC(StringBuilder sb, int m, int n, String a, String b) { int i; int j; // Step 1 if (n == 0) { // Nothing to do } else if (m == 1) { for (j = 0; j < n; j++) { if (a.charAt(0) == b.charAt(j)) { sb.append(a.charAt(0)); break; } } // Step 2 } else { i = (int)Math.floor(((double) m) / 2); // Step 3 int[] l1 = algB(i, n, a.substring(0, i), b); int[] l2 = algB(m - i, n, reverseString(a.substring(i)), reverseString(b)); // Step 4 int k = findK(l1, l2, n); // Step 5 algC(sb, i, k, a.substring(0, i), b.substring(0, k)); algC(sb, m - i, n - k, a.substring(i), b.substring(k)); } }	@param b	0	1
"public static Path relativize(Path baseDir, Path childPath) { Path fullPathWithoutSchemeAndAuthority = Path.getPathWithoutSchemeAndAuthority(childPath); Path basePathWithoutSchemeAndAuthority = Path.getPathWithoutSchemeAndAuthority(baseDir); // Since hadoop Path hasn't relativize() we use uri.relativize() to get relative path Path relativeFilePath = new Path(basePathWithoutSchemeAndAuthority.toUri() .relativize(fullPathWithoutSchemeAndAuthority.toUri())); if (relativeFilePath.isAbsolute()) { throw new IllegalStateException(String.format(""Path %s is not a subpath of %s."", basePathWithoutSchemeAndAuthority.toUri().getPath(), fullPathWithoutSchemeAndAuthority.toUri().getPath())); } return relativeFilePath; }"	@param childPath full absolute path	0	1
"private long insertData(ContentValues inputValues, boolean callerIsSyncAdapter) { final Long rawContactId = inputValues.getAsLong(Data.RAW_CONTACT_ID); if (rawContactId == null) { throw new IllegalArgumentException(Data.RAW_CONTACT_ID + "" is required""); } final String mimeType = inputValues.getAsString(Data.MIMETYPE); if (TextUtils.isEmpty(mimeType)) { throw new IllegalArgumentException(Data.MIMETYPE + "" is required""); } // The input seem valid, create a shallow copy. final ContentValues values = new ContentValues(inputValues); // Populate the relevant values before inserting the new entry into the database. replacePackageNameByPackageId(values); // Replace the mimetype by the corresponding mimetype ID. values.put(DataColumns.MIMETYPE_ID, mDbHelper.get().getMimeTypeId(mimeType)); values.remove(Data.MIMETYPE); // Insert the new entry. final SQLiteDatabase db = mDbHelper.get().getWritableDatabase(); final TransactionContext context = mTransactionContext.get(); final long dataId = getDataRowHandler(mimeType).insert(db, context, rawContactId, values); context.markRawContactDirtyAndChanged(rawContactId, callerIsSyncAdapter); context.rawContactUpdated(rawContactId); return dataId; }"	@param values the values for the new row	1	0
private boolean resolveAccount(ContentValues values, Account account) { // If either is specified then both must be specified. final String accountName = values.getAsString(RawContacts.ACCOUNT_NAME); final String accountType = values.getAsString(RawContacts.ACCOUNT_TYPE); if (!TextUtils.isEmpty(accountName) || !TextUtils.isEmpty(accountType)) { final Account valuesAccount = new Account(accountName, accountType); if (account != null && !valuesAccount.equals(account)) { return false; } account = valuesAccount; } if (account != null) { values.put(RawContacts.ACCOUNT_NAME, account.name); values.put(RawContacts.ACCOUNT_TYPE, account.type); } return true; }	@param uri the ContentValues to read from and update	1	0
public int create(Object[] row, Instant ts) throws InterruptedException { return create(row, ts, 0, 1); }	@param row the values of the row, in the same order as the columns in the Table definition in the MySqlSchema.	0	1
public boolean add(E o) { return super.add(o); }	@param e the element to add	1	0
"public SeleneseCommand handleCommandResult(String commandResult, FrameAddress incomingFrameAddress, String uniqueId) { SeleneseQueue queue; if (!SeleniumServer.isProxyInjectionMode()) { queue = getSeleneseQueue(); } else { if (incomingFrameAddress.getWindowName().equals(SELENIUM_WINDOW_NAME_UNKNOWN_POPUP)) { boolean foundFrameAddressOfUnknownPopup = false; for (FrameAddress knownFrameAddress : frameAddressToSeleneseQueue.keySet()) { // the situation being handled here: a pop-up window has either just loaded or reloaded, and therefore // doesn't know its name. It uses SELENIUM_WINDOW_NAME_UNKNOWN_POPUP as a placeholder. // Meanwhile, on the selenium server-side, a thread is waiting for this result. // // To determine if this has happened, we cycle through all of the SeleneseQueue objects, // looking for ones with a matching local frame address (e.g., top.frames[1]), is also a // pop-up, and which has a thread waiting on a result. If all of these conditions hold, // then we figure this queue is the one that we want: if (knownFrameAddress.getLocalFrameAddress().equals(incomingFrameAddress.getLocalFrameAddress()) && !knownFrameAddress.getWindowName().equals(DEFAULT_SELENIUM_WINDOW_NAME) && frameAddressToSeleneseQueue.get(knownFrameAddress).getCommandResultHolder().hasBlockedGetter()) { incomingFrameAddress = knownFrameAddress; foundFrameAddressOfUnknownPopup = true; break; } } if (!foundFrameAddressOfUnknownPopup) { SeleniumServer.log(""WARNING: unknown popup "" + incomingFrameAddress + "" was not resolved""); } } queue = getSeleneseQueue(incomingFrameAddress); } queue.setUniqueId(uniqueId); return queue.handleCommandResult(commandResult); }"	@param frameAddress - frame from which the reply came	1	0
public long add(long instant, int months) { if (months == 0) { return instant; // the easy case } // // Save time part first. // long timePart = iChronology.millisOfDay().get(instant); // // // Get this year and month. // int thisYear = iChronology.year().get(instant); int thisMonth = iChronology.getMonthOfYear(instant, thisYear); // ---------------------------------------------------------- // // Do not refactor without careful consideration. // Order of calculation is important. // int yearToUse; // Initially, monthToUse is zero-based int monthToUse = thisMonth - 1 + months; if (monthToUse >= 0) { yearToUse = thisYear + (monthToUse / MAX); monthToUse = (monthToUse % MAX) + 1; } else { yearToUse = thisYear + (monthToUse / MAX) - 1; monthToUse = Math.abs(monthToUse); int remMonthToUse = monthToUse % MAX; // Take care of the boundary condition if (remMonthToUse == 0) { remMonthToUse = MAX; } monthToUse = MAX - remMonthToUse + 1; // Take care of the boundary condition if (monthToUse == 1) { yearToUse += 1; } } // End of do not refactor. // ---------------------------------------------------------- // // Quietly force DOM to nearest sane value. // int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth); int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse); if (dayToUse > maxDay) { dayToUse = maxDay; } // // get proper date part, and return result // long datePart = iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse); return datePart + timePart; }	@param millis the time instant in millis to update.	1	0
public ApiResponse<ModelApiResponse> uploadFileWithRequiredFileWithHttpInfo(Long petId, File requiredFile, String additionalMetadata) throws ApiException { com.squareup.okhttp.Call call = uploadFileWithRequiredFileValidateBeforeCall(petId, requiredFile, additionalMetadata, null, null); Type localVarReturnType = new TypeToken<ModelApiResponse>(){}.getType(); return apiClient.execute(call, localVarReturnType); }	@param file file to upload (required)	1	0
"private boolean isKeepLock(String lockClient, String lockPath) { try { if (zkClient.checkExists().forPath(lockPath) != null) { byte[] data = zkClient.getData().forPath(lockPath); String lockServerName = new String(data, Charset.forName(""UTF-8"")); return lockServerName.equalsIgnoreCase(lockClient); } } catch (Exception e) { logger.error(""fail to get the lockClient for the path: "" + lockPath, e); } return false; }"	@param serverName the hostname of job server	1	0
public Struct update(Object before, Struct after, Struct source, Long timestamp) { Struct struct = new Struct(schema); struct.put(FieldName.OPERATION, Operation.UPDATE.code()); if (before != null) struct.put(FieldName.BEFORE, before); struct.put(FieldName.AFTER, after); if (source != null) struct.put(FieldName.SOURCE, source); if (timestamp != null) struct.put(FieldName.TIMESTAMP, timestamp); return struct; }	@param source the information about the source where the update occurred; may be null	0	1
"public static Object increment(Object version, VersionType versionType, SharedSessionContractImplementor session) { final Object next = versionType.next( version, session ); if ( LOG.isTraceEnabled() ) { LOG.tracef( ""Incrementing: %s to %s"", versionType.toLoggableString( version, session.getFactory() ), versionType.toLoggableString( next, session.getFactory() ) ); } return next; }"	@param session The originating session	0	1
"public Client testClassname(Client client) throws ApiException { Object localVarPostBody = client; // verify the required parameter 'client' is set if (client == null) { throw new ApiException(400, ""Missing the required parameter 'client' when calling testClassname""); } // create path and map variables String localVarPath = ""/fake_classname_test"".replaceAll(""\\{format\\}"",""json""); // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { ""application/json"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { ""application/json"" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { ""api_key_query"" }; GenericType<Client> localVarReturnType = new GenericType<Client>() {}; return apiClient.invokeAPI(localVarPath, ""PATCH"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	@param body client model (required)	1	0
private RectF drawBoxWithShadow(Canvas c, Paint p, int width, int height) { Resources res = mContext.getResources(); float shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur); float keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance); float corner = res.getDimension(R.dimen.widget_preview_corner_radius); RectF bounds = new RectF(shadowBlur, shadowBlur, width - shadowBlur, height - shadowBlur - keyShadowDistance); p.setColor(Color.WHITE); // Key shadow p.setShadowLayer(shadowBlur, 0, keyShadowDistance, ShadowGenerator.KEY_SHADOW_ALPHA << 24); c.drawRoundRect(bounds, corner, corner, p); // Ambient shadow p.setShadowLayer(shadowBlur, 0, 0, ColorUtils.setAlphaComponent(Color.BLACK, ShadowGenerator.AMBIENT_SHADOW_ALPHA)); c.drawRoundRect(bounds, corner, corner, p); p.clearShadowLayer(); return bounds; }	@param preview bitmap that can be recycled	0	1
public PendingMessageCursor getSubscriberPendingMessageCursor(Broker broker,String clientId, String name,int maxBatchSize, DurableTopicSubscription sub) { return new VMPendingMessageCursor(AbstractPendingMessageCursor.isPrioritizedMessageSubscriber(broker, sub)); }	@param sub	0	1
public static ParquetTableMetadata_v4 getParquetTableMetadata(FileSystem fs, Path path, ParquetReaderConfig readerConfig) throws IOException { Metadata metadata = new Metadata(readerConfig); return metadata.getParquetTableMetadata(path, fs); }	@param path path	0	1
"public static String normalizeDateString(String s, String ctxdate) { // TODO [pengqi]: need to handle basic localization (""å¨ä¸æäºæ¥å°[å «æ¥]é´"") // TODO [pengqi]: need to handle literal numeral dates (usually used in events, e.g. ""ä¸ä¸äº"" for 03-15) // TODO [pengqi]: might need to add a pattern for centuries (""ä¸ä¸çºª90å¹´ä»£"")? Pattern p; Matcher m; String ctxyear = ""XXXX"", ctxmonth = ""XX"", ctxday = ""XX""; // set up context date if (ctxdate != null) { p = Pattern.compile(""^"" + BASIC_YYYYMMDD_PATTERN + ""$""); m = p.matcher(ctxdate); if (m.find() && m.groupCount() == 3) { ctxyear = m.group(1); ctxmonth = m.group(2); ctxday = m.group(3); } } p = Pattern.compile(""^"" + BIRTH_DECADE_PATTERN + ""$""); m = p.matcher(s); if (m.find() && m.groupCount() == 1) { StringBuilder res = new StringBuilder(); res.append(normalizeYear(m.group(1), ctxyear, true).substring(0, 3) + ""X""); res.append(""-XX-XX""); return res.toString(); } p = Pattern.compile(""^"" + RELATIVE_TIME_PATTERN + ""$""); m = p.matcher(s); if (m.find() && m.groupCount() == 1) { StringBuilder res = new StringBuilder(); res.append(ctxyear); res.append(""-""); res.append(ctxmonth); res.append(""-""); res.append(normalizeMonthOrDay(m.group(1), ctxday)); return res.toString(); } p = Pattern.compile(""^"" + BASIC_YYYYMMDD_PATTERN + ""$""); m = p.matcher(s); if (m.find() && m.groupCount() == 3) { StringBuilder res = new StringBuilder(); res.append(normalizeYear(m.group(1), ctxyear)); res.append(""-""); res.append(normalizeMonthOrDay(m.group(2), ctxmonth)); res.append(""-""); res.append(normalizeMonthOrDay(m.group(3), ctxday)); return res.toString(); } p = Pattern.compile(""^"" + BASIC_MMDD_PATTERN + ""$""); m = p.matcher(s); if (m.find() && m.groupCount() == 2) { StringBuilder res = new StringBuilder(); res.append(ctxyear); res.append(""-""); res.append(normalizeMonthOrDay(m.group(1), ctxmonth)); res.append(""-""); res.append(normalizeMonthOrDay(m.group(2), ctxday)); return res.toString(); } p = Pattern.compile(""^"" + BASIC_DD_PATTERN + ""$""); m = p.matcher(s); if (m.find() && m.groupCount() == 1) { StringBuilder res = new StringBuilder(); res.append(ctxyear); res.append(""-""); res.append(ctxmonth); res.append(""-""); res.append(normalizeMonthOrDay(m.group(1), ctxday)); return res.toString(); } p = Pattern.compile(""^"" + ENGLISH_MMDDYYYY_PATTERN + ""$""); m = p.matcher(s); if (m.find() && m.groupCount() == 3) { StringBuilder res = new StringBuilder(); if (m.group(3) == null) res.append(ctxyear); else res.append(normalizeYear(m.group(3), ctxyear)); res.append(""-""); res.append(normalizeMonthOrDay(m.group(1), ctxmonth)); res.append(""-""); res.append(normalizeMonthOrDay(m.group(2), ctxday)); return res.toString(); } return s; }"	@param s Input date string	0	1
"Tuple2<Boolean, String> setFwkMetadata(String name, String sqlExpr, boolean createTable) throws SQLException { if (Boolean.getBoolean(NOAUTO_CREATE_METADATA)) return Tuple2.create(false, null); final SQLSystem sys = getServer().getSQLSystem(); final SQLSyntax syntax = sys.getSyntax(); final SQLDataSource ds = this.getDBSystemRoot().getDataSource(); synchronized (this.getTreeMutex()) { // don't refresh until after the insert, that way if the refresh triggers an access to // the metadata name will already be set to value. final boolean shouldRefresh; if (createTable && !this.contains(METADATA_TABLENAME)) { final SQLCreateMoveableTable create = getCreateMetadata(syntax); ds.execute(create.asString(getDBRoot().getName())); shouldRefresh = true; } else { shouldRefresh = false; } final Tuple2<Boolean, String> res; if (createTable || this.contains(METADATA_TABLENAME)) { // don't use SQLRowValues, cause it means getting the SQLTable and thus calling // fetchTables(), but setFwkMetadata() might itself be called by fetchTables() // furthermore SQLRowValues support only rowable tables final List<String> queries = new ArrayList<String>(); final SQLName tableName = new SQLName(this.getBase().getName(), this.getName(), METADATA_TABLENAME); final String where = "" WHERE "" + SQLBase.quoteIdentifier(""NAME"") + "" = "" + getBase().quoteString(name); queries.add(""DELETE FROM "" + tableName.quote() + where); final String returning = sys == SQLSystem.POSTGRESQL ? "" RETURNING "" + SQLBase.quoteIdentifier(""VALUE"") : """"; final String ins = syntax.getInsertOne(tableName, Arrays.asList(""NAME"", ""VALUE""), getBase().quoteString(name), sqlExpr) + returning; queries.add(ins); final List<? extends ResultSetHandler> handlers; if (returning.length() == 0) { queries.add(""SELECT "" + SQLBase.quoteIdentifier(""VALUE"") + "" FROM "" + tableName.quote() + where); handlers = Arrays.asList(null, null, SQLDataSource.SCALAR_HANDLER); } else { handlers = Arrays.asList(null, SQLDataSource.SCALAR_HANDLER); } final List<?> ress = SQLUtils.executeMultiple(getDBSystemRoot(), queries, handlers); res = Tuple2.create(true, (String) ress.get(ress.size() - 1)); } else { res = Tuple2.create(false, null); } if (shouldRefresh) this.fetchTable(METADATA_TABLENAME); return res; } }"	"@param value value of the metadata, eg ""ACME, inc""."	1	0
"public Mono<ModelApiResponse> uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws RestClientException { Object postBody = null; // verify the required parameter 'petId' is set if (petId == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'petId' when calling uploadFileWithRequiredFile""); } // verify the required parameter 'requiredFile' is set if (requiredFile == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile""); } // create path and map variables final Map<String, Object> uriVariables = new HashMap<String, Object>(); uriVariables.put(""petId"", petId); String path = UriComponentsBuilder.fromPath(""/fake/{petId}/uploadImageWithRequiredFile"").buildAndExpand(uriVariables).toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); if (additionalMetadata != null) formParams.add(""additionalMetadata"", additionalMetadata); if (requiredFile != null) formParams.add(""requiredFile"", new FileSystemResource(requiredFile)); final String[] accepts = { ""application/json"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { ""multipart/form-data"" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { ""petstore_auth"" }; ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {}; return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }"	@param petId ID of pet to update	0	1
public Client testClientModel(Client body) throws IOException { HttpResponse response = testClientModelForHttpResponse(body); TypeReference typeRef = new TypeReference<Client>() {}; return apiClient.getObjectMapper().readValue(response.getContent(), typeRef); }	@param client client model	1	0
public CaseForEqBuilder<T> when(T other){ return new CaseForEqBuilder<T>(this, new ConstantImpl<T>(other)); }	@param other	0	1
private static CoreLabel createDatum(String token, String label, int index) { CoreLabel newTok = new CoreLabel(); newTok.set(CoreAnnotations.CharAnnotation.class, token); newTok.set(CoreAnnotations.AnswerAnnotation.class, label); newTok.set(CoreAnnotations.GoldAnswerAnnotation.class, label); newTok.setIndex(index); return newTok; }	@param cl	1	0
public static RequestQueue newRequestQueue(IRestProtocol implRestConnection, int threadPoolSize) { return newRequestQueue(RestParser.getInstance(implRestConnection), threadPoolSize); }	@param implRestConnection network operating interface, The implementation of the network layer.	0	1
protected int writeImportList(PrintWriter out, List<String> imports) { return writeImportList(out, (String[]) imports.toArray(new String[0])); }	@param programImports	0	1
"public Action suspended(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { logger.debug(""(suspend) invoked:\n HttpServletRequest: {}\n HttpServletResponse: {}"", request, response); return action(request, response); }"	@param req the HttpServletRequest	1	0
"private static Consumer<List> mongoChecker(final String... expected) { return actual -> { if (expected == null) { Assert.assertThat(""null mongo Query"", actual, CoreMatchers.nullValue()); return; } if (expected.length == 0) { CalciteAssert.assertArrayEqual(""empty Mongo query"", expected, actual.toArray(new Object[0])); return; } final BsonDocument expectedBson = BsonDocument.parse(String.join("","", expected)); final BsonDocument actualBson = BsonDocument.parse(((List<?>) actual.get(0)) .stream() .map(Objects::toString) .collect(Collectors.joining(""\n""))); // compare Bson (not string) representation if (!expectedBson.equals(actualBson)) { final JsonWriterSettings settings = JsonWriterSettings.builder().indent(true).build(); // used to pretty print Assertion error Assert.assertEquals(""expected and actual Mongo queries do not match"", expectedBson.toJson(settings), actualBson.toJson(settings)); Assert.fail(""Should have failed previously because (expected != actual) is already known""); } }; }"	@param strings Expected expressions	1	0
public Object get(SharedSessionContractImplementor session, Object key, long txTimestamp) throws CacheException { if ( !region.checkValid() ) { return null; } final Object val = cache.get( key ); if ( val == null ) { putValidator.registerPendingPut(session, key, txTimestamp ); } return val; }	@param key The key of the item to be retrieved	0	1
"public static DataFileReadResult decompress(byte[] b, int[] keys) { InputStream stream = new InputStream(b); int compression = stream.readUnsignedByte(); int compressedLength = stream.readInt(); if (compressedLength < 0 || compressedLength > 1000000) throw new RuntimeException(""Invalid data""); Crc32 crc32 = new Crc32(); crc32.update(b, 0, 5); // compression + length byte[] data; int revision = -1; switch (compression) { case CompressionType.NONE: { byte[] encryptedData = new byte[compressedLength]; stream.readBytes(encryptedData, 0, compressedLength); crc32.update(encryptedData, 0, compressedLength); byte[] decryptedData = decrypt(encryptedData, encryptedData.length, keys); if (stream.remaining() >= 2) { revision = stream.readUnsignedShort(); assert revision != -1; } data = decryptedData; break; } case CompressionType.BZ2: { byte[] encryptedData = new byte[compressedLength + 4]; stream.readBytes(encryptedData); crc32.update(encryptedData, 0, encryptedData.length); byte[] decryptedData = decrypt(encryptedData, encryptedData.length, keys); if (stream.remaining() >= 2) { revision = stream.readUnsignedShort(); assert revision != -1; } stream = new InputStream(decryptedData); int decompressedLength = stream.readInt(); data = BZip2.decompress(stream.getRemaining(), compressedLength); if (data == null) { return null; } assert data.length == decompressedLength; break; } case CompressionType.GZ: { byte[] encryptedData = new byte[compressedLength + 4]; stream.readBytes(encryptedData); crc32.update(encryptedData, 0, encryptedData.length); byte[] decryptedData = decrypt(encryptedData, encryptedData.length, keys); if (stream.remaining() >= 2) { revision = stream.readUnsignedShort(); assert revision != -1; } stream = new InputStream(decryptedData); int decompressedLength = stream.readInt(); data = GZip.decompress(stream.getRemaining(), compressedLength); if (data == null) { return null; } assert data.length == decompressedLength; break; } default: throw new RuntimeException(""Unknown decompression type""); } DataFileReadResult res = new DataFileReadResult(); res.data = data; res.revision = revision; int length = revision != -1 ? b.length - 2 : b.length;; res.crc = crc32.getHash(); res.whirlpool = Whirlpool.getHash(b, length); res.compression = compression; return res; }"	@param archiveId	1	0
public Serializable generate(SharedSessionContractImplementor session, Object object) throws HibernateException { return optimizer.generate( databaseStructure.buildCallback( session ) ); }	@param incrementSize the increment size to use (after any adjustments).	1	0
private boolean paramAppend(StringBuilder sb, String name, String value, ParameterParser parser) { boolean isEdited = false; if (name != null) { sb.append(name); isEdited = true; } if (value != null) { sb.append(parser.getDefaultKeyValueSeparator()); sb.append(value); isEdited = true; } return isEdited; }	@param value null = not to append parameter value.	0	1
"private static String canonicalize(final SortedSet<QueryParameter> sortedParameters) { if (sortedParameters == null || sortedParameters.isEmpty()) { return """"; } final StringBuilder sb = new StringBuilder(100); for (QueryParameter parameter : sortedParameters) { final String name = parameter.getName().toLowerCase(); // Ignore irrelevant parameters if (IRRELEVANT_PARAMETERS.contains(name) || name.startsWith(""utm_"")) { continue; } if (sb.length() > 0) { sb.append('&'); } sb.append(parameter.getName()); if (!parameter.getValue().isEmpty()) { sb.append('='); sb.append(parameter.getValue()); } } return sb.toString(); }"	@param sortedParamMap Parameter name-value pairs in lexicographical order.	1	0
public static BroadcasterFactory buildAndReplaceDefaultfactory(Class<? extends Broadcaster> clazz, AtmosphereServlet.AtmosphereConfig c) throws InstantiationException, IllegalAccessException { factory = new DefaultBroadcasterFactory(clazz); config = c; return factory; }	@param clazz A class implementing Broadcaster	0	1
public Builder argument(UnaryOperator<GraphQLArgument.Builder> builderFunction) { GraphQLArgument.Builder builder = GraphQLArgument.newArgument(); builder = builderFunction.apply(builder); return argument(builder); }	@param builderFunction a supplier for the builder impl	0	1
"public ApiResponse<Client> testSpecialTagsWithHttpInfo(Client client) throws ApiException { Object localVarPostBody = client; // verify the required parameter 'client' is set if (client == null) { throw new ApiException(400, ""Missing the required parameter 'client' when calling testSpecialTags""); } // create path and map variables String localVarPath = ""/another-fake/dummy""; // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { ""application/json"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { ""application/json"" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Client> localVarReturnType = new GenericType<Client>() {}; return apiClient.invokeAPI(localVarPath, ""PATCH"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	@param body client model (required)	1	0
"public boolean scrollList(int listIndex, int direction, ArrayList<ListView> listViews) { int[] xy = new int[2]; ListView listView = viewFetcher.getView(ListView.class, listViews, listIndex); while (listView ==null && scrollScrollView(direction, null)) { sleeper.sleep(); listView = viewFetcher.getView(ListView.class, listViews, listIndex); } if(listView ==null) Assert.assertTrue(""No ListView with index "" + listIndex + "" is found!"", false); listView.getLocationOnScreen(xy); if (direction == DOWN) { if (listView.getLastVisiblePosition() >= listView.getCount()-1) { scrollListToLine(listView, listView.getLastVisiblePosition()); return false; } scrollListToLine(listView, listView.getLastVisiblePosition()); } else if (direction == UP) { if (listView.getFirstVisiblePosition() < 2) { scrollListToLine(listView, 0); return false; } final int lines = listView.getLastVisiblePosition() - listView.getFirstVisiblePosition(); int lineToScrollTo = listView.getFirstVisiblePosition() - lines; if(lineToScrollTo < 0) lineToScrollTo=0; scrollListToLine(listView, lineToScrollTo); } sleeper.sleep(); return true; }"	@param direction the direction to be scrolled	0	1
protected String getParameterDataType(Parameter parameter, Schema schema) { return null; }	@param property	1	0
"public Mono<ModelApiResponse> uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws RestClientException { Object postBody = null; // verify the required parameter 'petId' is set if (petId == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'petId' when calling uploadFileWithRequiredFile""); } // verify the required parameter 'requiredFile' is set if (requiredFile == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile""); } // create path and map variables final Map<String, Object> uriVariables = new HashMap<String, Object>(); uriVariables.put(""petId"", petId); String path = UriComponentsBuilder.fromPath(""/fake/{petId}/uploadImageWithRequiredFile"").buildAndExpand(uriVariables).toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); if (additionalMetadata != null) formParams.add(""additionalMetadata"", additionalMetadata); if (requiredFile != null) formParams.add(""requiredFile"", new FileSystemResource(requiredFile)); final String[] accepts = { ""application/json"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { ""multipart/form-data"" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { ""petstore_auth"" }; ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {}; return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }"	@param file file to upload	1	0
private boolean hasSingleValue(ColumnStatistics columnStatistics, long rowCount) { return columnStatistics != null && isSingleVal(columnStatistics, rowCount); }	@param columnChunkMetaData metadata to check	1	0
"public int[] add(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { if (valueToAdd == 0) { return values; } // there are more efficient algorithms than this (especially for time only fields) // trouble is when dealing with days and months, so we use this technique of // adding/removing one from the larger field at a time DateTimeField nextField = null; while (valueToAdd > 0) { int max = getMaximumValue(instant, values); long proposed = values[fieldIndex] + valueToAdd; if (proposed <= max) { values[fieldIndex] = (int) proposed; break; } if (nextField == null) { if (fieldIndex == 0) { throw new IllegalArgumentException(""Maximum value exceeded for add""); } nextField = instant.getField(fieldIndex - 1); if (getRangeDurationField() != nextField.getDurationField()) { throw new IllegalArgumentException(""Fields invalid for add""); } } valueToAdd -= (max + 1) - values[fieldIndex]; values = nextField.add(instant, fieldIndex - 1, values, 1); values[fieldIndex] = getMinimumValue(instant, values); } while (valueToAdd < 0) { int min = getMinimumValue(instant, values); long proposed = values[fieldIndex] + valueToAdd; if (proposed >= min) { values[fieldIndex] = (int) proposed; break; } if (nextField == null) { if (fieldIndex == 0) { throw new IllegalArgumentException(""Maximum value exceeded for add""); } nextField = instant.getField(fieldIndex - 1); if (getRangeDurationField() != nextField.getDurationField()) { throw new IllegalArgumentException(""Fields invalid for add""); } } valueToAdd -= (min - 1) - values[fieldIndex]; values = nextField.add(instant, fieldIndex - 1, values, -1); values[fieldIndex] = getMaximumValue(instant, values); } return set(instant, fieldIndex, values, values[fieldIndex]); // adjusts smaller fields }"	@param valueToAdd the value to add, in the units of the field	0	1
protected ReadableInstant create(long instant, Chronology chrono) { // ignore chrono if (instant == getMillis()) { return this; } return new Instant(instant); }	@param millis the new millis, from 1970-01-01T00:00:00Z	1	0
public static DownloadRequest createDownloadRequest(String url, RequestMethod requestMethod, String fileFolder, String filename, boolean isRange, boolean isDeleteOld) { return new RestDownloadRequestor(url, requestMethod, fileFolder, filename, isRange, isDeleteOld); }	@param isRange Whether the breakpoint continuingly	0	1
public static BooleanOperation booleanOperation(Operator operator, Expression<?>... args) { return predicate(operator, args); }	@param args	1	0
public static Criterion between(String propertyName, Object low, Object high) { return new BetweenExpression( propertyName, low, high ); }	@param propertyName The name of the property	0	1
"public int get(DateTimeFieldType type) { for (int i = 0, isize = size(); i < isize; i++) { if (getFieldType(i) == type) { return getValue(i); } } throw new IllegalArgumentException(""Field '"" + type + ""' is not supported""); }"	@param field a DateTimeField instance that is supported by this partial	1	0
"public int compareTo(ReadablePartial partial) { if (partial == null) { throw new IllegalArgumentException(""The instant must not be null""); } int thisValue = get(); int otherValue = partial.get(getFieldType()); if (thisValue < otherValue) { return -1; } else if (thisValue > otherValue) { return 1; } else { return 0; } }"	@param instant the instant to compare to	1	0
"private URL determineSuiteUrl(String startURL, String suiteURL) throws IOException { if (suiteURL.startsWith(""https://"") || suiteURL.startsWith(""http://"")) { return verifySuiteUrl(new URL(suiteURL)); } // Is the suiteURL a file? Path path = Paths.get(suiteURL); if (Files.exists(path)) { // Not all drivers can read files from the disk, so we need to host the suite somewhere. try (SocketLock lock = new SocketLock()) { server = new Server(); HttpConfiguration httpConfig = new HttpConfiguration(); ServerConnector http = new ServerConnector(server, new HttpConnectionFactory(httpConfig)); int port = PortProber.findFreePort(); http.setPort(port); http.setIdleTimeout(500000); server.setConnectors(new Connector[]{http}); ResourceHandler handler = new ResourceHandler(); handler.setDirectoriesListed(true); handler.setWelcomeFiles(new String[]{path.getFileName().toString(), ""index.html""}); handler.setBaseResource(new PathResource(path.toFile().getParentFile().toPath().toRealPath())); ContextHandler context = new ContextHandler(""/tests""); context.setHandler(handler); server.setHandler(context); server.start(); PortProber.waitForPortUp(port, 15, SECONDS); URL serverUrl = server.getURI().toURL(); return new URL(serverUrl.getProtocol(), serverUrl.getHost(), serverUrl.getPort(), ""/tests/""); } catch (Exception e) { throw new IOException(e); } } // Well then, it must be a URL relative to whatever the browserUrl. Probe and find out. URL browser = new URL(startURL); return verifySuiteUrl(new URL(browser, suiteURL)); }"	"@param browser - the browserString (""firefox"", ""iexplore"" or an executable path)"	0	1
"public ASTNode getASTNodeAt(int javaOffset) { Messages.log(""* getASTNodeAt""); PreprocessedSketch ps = errorCheckerService.latestResult; ASTNode node = NodeFinder.perform(ps.compilationUnit, javaOffset, 0); if (node == null) { Messages.log(""no node found""); return null; } Messages.log(""found "" + node.toString()); return node; }"	@param offset - line start nonwhitespace offset	0	1
public boolean searchToggleButton(String regex, int matches) { boolean found = searcher.searchToggleButton(regex, matches); return found; }	@param search the string to be searched. The parameter will be interpreted as a regular expression.	1	0
@CheckForNull public final SCMRevision fetch(@NonNull String thingName, @CheckForNull TaskListener listener) throws IOException, InterruptedException { return retrieve(thingName, defaultListener(listener)); }	@param revision might be a branch name, a tag name, a cryptographic hash, a revision number, etc.	1	0
public Order placeOrder(Order order, Map<String, Object> params) throws IOException { HttpResponse response = placeOrderForHttpResponse(order, params); TypeReference typeRef = new TypeReference<Order>() {}; return apiClient.getObjectMapper().readValue(response.getContent(), typeRef); }	@param body order placed for purchasing the pet	1	0
public FluentWait<T> withTimeout(Duration timeout) { this.timeout = timeout; return this; }	@param timeout The timeout duration.	0	1
"protected String getExample(Schema schema) { if (schema.getExample() != null) { return schema.getExample().toString(); } else if (ModelUtils.isDateTimeSchema(schema)) { return ""2000-01-23T04:56:07.000Z""; } else if (ModelUtils.isDateSchema(schema)) { return ""2000-01-23""; } else if (ModelUtils.isBooleanSchema(schema)) { return ""true""; } else if (ModelUtils.isNumberSchema(schema)) { if (ModelUtils.isFloatSchema(schema)) { // float return ""1.3579""; } else { // double return ""3.149""; } } else if (ModelUtils.isPasswordSchema(schema)) { return ""********""; } else if (ModelUtils.isUUIDSchema(schema)) { return ""046b6c7f-0b8a-43b9-b35d-6489e6daee91""; // do these last in case the specific types above are derived from these classes } else if (ModelUtils.isStringSchema(schema)) { return ""aeiou""; } else if (ModelUtils.isIntegerSchema(schema)) { if (ModelUtils.isLongSchema(schema)) { // long return ""123456789""; } else { //integer return ""123""; } } else { LOGGER.debug(""default example value not implemented for {}. Default to UNDEFINED_EXAMPLE_VALUE"", schema); return ""UNDEFINED_EXAMPLE_VALUE""; } }"	@param property Property to get example string for	1	0
public Client testClassname(Client client) throws ApiException { return testClassnameWithHttpInfo(client).getData(); }	@param body client model (required)	1	0
public String createFileName(URL url, String prefixSubstitute, String substituteReplacement) { File file = new File(directory_prefix + File.separator + url.getFile()); return file.getAbsolutePath().replaceAll(prefixSubstitute, substituteReplacement); }	@param url DOCUMENT ME!	1	0
public MultiIterator init(IteratorSource iteratorSource){ this.iteratorSource = iteratorSource; this.iterators = new Iterator<?>[sources.size()]; this.lastEntry = new boolean[iterators.length]; this.values = new Object[iterators.length]; return this; }	@param indexSupport	0	1
public int recordEvent(Document oplogEvent, Instant timestamp) throws InterruptedException { return recordEvent(oplogEvent, oplogEvent, timestamp, 0); }	@param oplogEvent the event; may not be null	0	1
"InputStream openSourceFile(String path) throws IOException { if (path.startsWith(""gen/"")) { // generated file? String rest = path.substring(""gen/"".length()); File fileInGenDir = new File(getGenDir(), rest); if (!fileInGenDir.isFile()) { return null; } return new BufferedInputStream(new FileInputStream(fileInGenDir)); } else { // regular source file? URL resource = recompiler.getResourceLoader().getResource(path); if (resource == null) { return null; } return resource.openStream(); } }"	@param resourceName the relative path to a resource in the module's classpath.	1	0
public int[] findDirty(Object[] currentState, Object[] previousState, Object entity, SharedSessionContractImplementor session) throws HibernateException { int[] props = TypeHelper.findDirty( entityMetamodel.getProperties(), currentState, previousState, propertyColumnUpdateable, hasUninitializedLazyProperties( entity ), session ); if ( props == null ) { return null; } else { logDirtyProperties( props ); return props; } }	@param currentState The current state of the entity (the state to be checked).	0	1
private RexNode adjustCondition(LogicalProject project, LogicalJoin semiJoin) { // create two RexPrograms -- the bottom one representing a // concatenation of the project and the RHS of the semijoin and the // top one representing the semijoin condition RexBuilder rexBuilder = project.getCluster().getRexBuilder(); RelDataTypeFactory typeFactory = rexBuilder.getTypeFactory(); RelNode rightChild = semiJoin.getRight(); // for the bottom RexProgram, the input is a concatenation of the // child of the project and the RHS of the semijoin RelDataType bottomInputRowType = SqlValidatorUtil.deriveJoinRowType( project.getInput().getRowType(), rightChild.getRowType(), JoinRelType.INNER, typeFactory, null, semiJoin.getSystemFieldList()); RexProgramBuilder bottomProgramBuilder = new RexProgramBuilder(bottomInputRowType, rexBuilder); // add the project expressions, then add input references for the RHS // of the semijoin for (Pair<RexNode, String> pair : project.getNamedProjects()) { bottomProgramBuilder.addProject(pair.left, pair.right); } int nLeftFields = project.getInput().getRowType().getFieldCount(); List<RelDataTypeField> rightFields = rightChild.getRowType().getFieldList(); int nRightFields = rightFields.size(); for (int i = 0; i < nRightFields; i++) { final RelDataTypeField field = rightFields.get(i); RexNode inputRef = rexBuilder.makeInputRef( field.getType(), i + nLeftFields); bottomProgramBuilder.addProject(inputRef, field.getName()); } RexProgram bottomProgram = bottomProgramBuilder.getProgram(); // input rowtype into the top program is the concatenation of the // project and the RHS of the semijoin RelDataType topInputRowType = SqlValidatorUtil.deriveJoinRowType( project.getRowType(), rightChild.getRowType(), JoinRelType.INNER, typeFactory, null, semiJoin.getSystemFieldList()); RexProgramBuilder topProgramBuilder = new RexProgramBuilder( topInputRowType, rexBuilder); topProgramBuilder.addIdentity(); topProgramBuilder.addCondition(semiJoin.getCondition()); RexProgram topProgram = topProgramBuilder.getProgram(); // merge the programs and expand out the local references to form // the new semijoin condition; it now references a concatenation of // the project's child and the RHS of the semijoin RexProgram mergedProgram = RexProgramBuilder.mergePrograms( topProgram, bottomProgram, rexBuilder); return mergedProgram.expandLocalRef( mergedProgram.getCondition()); }	@param project LogicalProject on the LHS of the semijoin	0	1
public static TupleMetadata expandMetadata(TupleMetadata base, ImplicitColumnManager metadataProj, int dirCount) { TupleMetadata metadataSchema = new TupleSchema(); for (ColumnMetadata col : base) { metadataSchema.addColumn(col); } for (FileMetadataColumnDefn fileColDefn : metadataProj.fileMetadataColDefns()) { metadataSchema.add(MaterializedField.create(fileColDefn.colName(), fileColDefn.dataType())); } for (int i = 0; i < dirCount; i++) { metadataSchema.add(MaterializedField.create(metadataProj.partitionName(i), PartitionColumn.dataType())); } return metadataSchema; }	@param base the table part of the expansion	0	1
public int[] findModified(Object[] old, Object[] current, Object entity, SharedSessionContractImplementor session) throws HibernateException { int[] props = TypeHelper.findModified( entityMetamodel.getProperties(), current, old, propertyColumnUpdateable, hasUninitializedLazyProperties( entity ), session ); if ( props == null ) { return null; } else { logDirtyProperties( props ); return props; } }	@param current The current state of the entity.	0	1
"ChromeResponse execute(DriverCommand driverCommand, Object... parameters) { Command command = new Command(new SessionId(""[No sessionId]""), new Context(""[No context]""), driverCommand, parameters); try { return executor.execute(command); } catch (Exception e) { if (e instanceof IllegalArgumentException || e instanceof FatalChromeException) { //These exceptions may leave the extension hung, or in an //inconsistent state, so we restart Chrome stopClient(); init(); } if (e instanceof RuntimeException) { throw (RuntimeException)e; } else { throw new WebDriverException(e); } } }"	@param commandName command to execute	1	0
public MergedSelectionSet collectFields(FieldCollectorParameters parameters, SelectionSet selectionSet) { Map<String, MergedFields> subFields = new LinkedHashMap<>(); List<String> visitedFragments = new ArrayList<>(); this.collectFields(parameters, selectionSet, visitedFragments, subFields); return newMergedSelectionSet().subFields(subFields).build(); }	@param selectionSet the selection set to collect on	0	1
"String evaluate(String url, String host) throws ScriptException { try { return (String) pacImpl.invokeFunction(""FindProxyForURL"", url, host); } catch (NoSuchMethodException | ScriptAbuseException e) { throw new ScriptException(e); } }"	@param destURL the url param of FindProxyForURL(url, host)	1	0
"public void redirectOutput(){ if (System.getenv(""REDIRECT"") == null || !System.getenv(""REDIRECT"").equals(""true"")) { return; } String DEFAULT_OUT_TARGET_FILE = JStormUtils.getLogFileName(); if (DEFAULT_OUT_TARGET_FILE == null) { DEFAULT_OUT_TARGET_FILE = ""/dev/null""; } else { DEFAULT_OUT_TARGET_FILE += "".out""; } String outputFile = ConfigExtension.getWorkerRedirectOutputFile(workerData.getStormConf()); if (outputFile == null) { outputFile = DEFAULT_OUT_TARGET_FILE; }else { try { File file = new File(outputFile); if (file.exists() == false) { PathUtils.touch(outputFile); }else { if (file.isDirectory() == true) { LOG.warn(""Failed to write "" + outputFile); outputFile = DEFAULT_OUT_TARGET_FILE; }else if (file.canWrite() == false) { LOG.warn(""Failed to write "" + outputFile); outputFile = DEFAULT_OUT_TARGET_FILE; } } }catch(Exception e) { LOG.warn(""Failed to touch "" + outputFile, e); outputFile = DEFAULT_OUT_TARGET_FILE; } } try { JStormUtils.redirectOutput(outputFile); }catch(Exception e) { LOG.warn(""Failed to redirect to "" + outputFile, e); } }"	@param port	0	1
"public Order placeOrder(Order order) throws RestClientException { Object postBody = order; // verify the required parameter 'order' is set if (order == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'order' when calling placeOrder""); } String path = UriComponentsBuilder.fromPath(""/store/order"").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { ""application/xml"", ""application/json"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<Order> returnType = new ParameterizedTypeReference<Order>() {}; return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }"	@param body order placed for purchasing the pet	1	0
"private GenericRecord deserialize(Event event, GenericRecord reuse) throws EventDeliveryException { decoder = DecoderFactory.get().binaryDecoder(event.getBody(), decoder); // no checked exception is thrown in the CacheLoader DatumReader<GenericRecord> reader = readers.getUnchecked(schema(event)); try { return reader.read(reuse, decoder); } catch (IOException ex) { throw new EventDeliveryException(""Cannot deserialize event"", ex); } }"	@param event	0	1
public static EBoolean isNotEmpty(ECollection<?> collection) { return operationFactory.createBoolean(Ops.COL_ISNOTEMPTY,(Expr<?>) collection); }	@param collection	0	1
public static MemberID parse(String memberID, boolean isClassMember) { return parse(memberID, isClassMember, null); }	@param signature the signature to parse.	1	0
public Double getNNRowCount(SchemaPath col) { // Stats might not have materialized because of errors. if (!materialized) { return null; } Long nnRowCntCol = nnRowCount.get(col); // Cap it at row count (just in case) if (nnRowCntCol != null) { return Math.min(nnRowCntCol, rowCount); } return null; }	@param col - column for which non-null rowcount is desired	0	1
public RelationalFunctionCall(Class<? extends T> type, String function, Object... args) { super(type); this.args = normalizeArgs(args); this.template = createTemplate(function, args.length); }	@param template	1	0
"public static long toMicroOfDay(Object value, boolean acceptLargeValues) { if (value instanceof Duration) { Duration duration = (Duration) value; if (!acceptLargeValues && (duration.isNegative() || duration.compareTo(ONE_DAY) > 0)) { throw new IllegalArgumentException(""Time values must be between 00:00:00 and 24:00:00 (inclusive): "" + duration); } // conversion to nanos is fine as TIME values won't exceed long range return ((Duration) value).toNanos() / 1_000; } // TODO only needed for SQL Server/Oracle, where we don't produce Duration right away; // this should go eventually, as the conversion to LocalTime is superfluous LocalTime time = Conversions.toLocalTime(value); return Math.floorDiv(time.toNanoOfDay(), Conversions.NANOSECONDS_PER_MICROSECOND); }"	@param value the local or SQL date, time, or timestamp value; may not be null	1	0
public long get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }	@param attributes an object containing an AttributeMap	1	0
public boolean waitForActivity(Class<? extends Activity> activityClass, int timeout){ final long endTime = SystemClock.uptimeMillis() + timeout; Activity currentActivity = activityUtils.getCurrentActivity(false); while(SystemClock.uptimeMillis() < endTime){ if(currentActivity != null && currentActivity.getClass().equals(activityClass)) return true; currentActivity = activityUtils.getCurrentActivity(); } return false; }	@param timeout the amount of time in milliseconds to wait	0	1
public String applyLocksToSql(String sql, LockOptions aliasedLockOptions, Map keyColumnNames) { return sql + new ForUpdateFragment( this, aliasedLockOptions, keyColumnNames ).toFragmentString(); }	@param aliasedLockOptions a map of lock options indexed by aliased table names.	1	0
public RelationalFunctionCall(Class<? extends T> type, String function, Object... args) { super(type); this.args = normalizeArgs(args); this.template = createTemplate(function, args.length); }	@param type	0	1
"public Order getOrderById (Long orderId) throws ApiException { Object localVarPostBody = null; // verify the required parameter 'orderId' is set if (orderId == null) { throw new ApiException(400, ""Missing the required parameter 'orderId' when calling getOrderById""); } // create path and map variables String localVarPath = ""/store/order/{orderId}"".replaceAll(""\\{format\\}"",""json"").replaceAll(""\\{"" + ""orderId"" + ""\\}"", apiInvoker.escapeString(orderId.toString())); // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); // header params Map<String, String> localVarHeaderParams = new HashMap<String, String>(); // form params Map<String, String> localVarFormParams = new HashMap<String, String>(); String[] localVarContentTypes = { }; String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : ""application/json""; if (localVarContentType.startsWith(""multipart/form-data"")) { // file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); localVarPostBody = localVarBuilder.build(); } else { // normal form params } try { String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, ""GET"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType); if(localVarResponse != null){ return (Order) ApiInvoker.deserialize(localVarResponse, """", Order.class); } else { return null; } } catch (ApiException ex) { throw ex; } }"	@param orderId ID of pet that needs to be fetched	0	1
"public static QName getXSIType(Parameter param) { if (param.getMIMEType() != null) { return getMIMETypeQName(param.getMIMEType()); } QName xmlType = null; TypeEntry te = param.getType(); // If the TypeEntry describes an Element, get // the referenced Type. if (te != null && te instanceof Element && te.getRefType() != null) { te = te.getRefType(); } // If the TypeEntry is a CollectionType, use // the TypeEntry representing the component Type // So for example a parameter that takes a // collection type for // <element name=""A"" type=""xsd:string"" maxOccurs=""unbounded""/> // will be // new ParameterDesc(<QName of A>, IN, // <QName of xsd:string>, // String[]) if (te != null && te instanceof CollectionType && te.getRefType() != null) { te = te.getRefType(); } if (te != null) { xmlType = te.getQName(); } return xmlType; }"	@param te is the typeEntry from the Parameters object, which represents the parameter	1	0
private boolean isAncestorOf(Object node, Object target) { if (target == null) return false; Object parent = getParent(target); if (parent == node) return true; return isAncestorOf(node, parent); }	@param object1 The first object to be tested.	1	0
public Call testEndpointParametersAsync(BigDecimal number, Double _double, String string, byte[] _byte, Integer integer, Integer int32, Long int64, Float _float, byte[] binary, Date date, Date dateTime, String password, final ApiCallback<Void> callback) throws ApiException { ProgressResponseBody.ProgressListener progressListener = null; ProgressRequestBody.ProgressRequestListener progressRequestListener = null; if (callback != null) { progressListener = new ProgressResponseBody.ProgressListener() { @Override public void update(long bytesRead, long contentLength, boolean done) { callback.onDownloadProgress(bytesRead, contentLength, done); } }; progressRequestListener = new ProgressRequestBody.ProgressRequestListener() { @Override public void onRequestProgress(long bytesWritten, long contentLength, boolean done) { callback.onUploadProgress(bytesWritten, contentLength, done); } }; } Call call = testEndpointParametersCall(number, _double, string, _byte, integer, int32, int64, _float, binary, date, dateTime, password, progressListener, progressRequestListener); apiClient.executeAsync(call, callback); return call; }	@param callback The callback to be executed when the API call finishes	0	1
"private static ObjectName asObjectName(Object componentKey) throws MalformedObjectNameException { if (componentKey == null) { throw new NullPointerException(""componentKey cannot be null""); } if (componentKey instanceof ObjectName) { return (ObjectName) componentKey; } if (componentKey instanceof Class) { Class clazz = (Class) componentKey; return new ObjectName(""picomx:type="" + clazz.getName()); } else { String text = componentKey.toString(); // Fix, so it works under WebSphere ver. 5 if (text.indexOf(':') == -1) { text = ""picomx:type="" + text; } return new ObjectName(text); } }"	@param key	1	0
public static DownloadRequest createDownloadRequest(String url, RequestMethod requestMethod, String fileFolder, String filename, boolean isRange, boolean isDeleteOld) { return new RestDownloadRequestor(url, requestMethod, fileFolder, filename, isRange, isDeleteOld); }	@param fileFloder Folder to save file	1	0
"public Client testSpecialTags(Client client) throws RestClientException { Object postBody = client; // verify the required parameter 'client' is set if (client == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'client' when calling testSpecialTags""); } String path = UriComponentsBuilder.fromPath(""/another-fake/dummy"").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { ""application/json"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { ""application/json"" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {}; return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }"	@param body client model	1	0
public static boolean canEdit(Permissions perms, Permissions user2Perms) { if(isAdmin(perms)) return true; if(isAdmin(user2Perms)) return false; return getManagementLevel(perms) > getManagementLevel(user2Perms); }	@param manager The manager user (the one accessing the application)	1	0
public final static AtmosphereRequest cloneRequest(HttpServletRequest request, boolean loadInMemory, boolean copySession, boolean isDestroyable) { Builder b; HttpServletRequest r; boolean isWrapped = false; if (AtmosphereRequest.class.isAssignableFrom(request.getClass())) { b = AtmosphereRequest.class.cast(request).b; isWrapped = true; } else { b = new Builder(); b.request(request); } b.servletPath(request.getServletPath()) .pathInfo(request.getPathInfo()) .contextPath(request.getContextPath()) .requestURI(request.getRequestURI()) .requestURL(request.getRequestURL().toString()) .method(request.getMethod()) .serverName(request.getServerName()) .serverPort(request.getServerPort()) .destroyable(isDestroyable) .session(copySession ? new FakeHttpSession(request.getSession(true)) : null); if (loadInMemory) { r = new NoOpsRequest(); if (isWrapped) { load(b.request, b); } else { load(request, b); } b.request(r); } return isWrapped ? AtmosphereRequest.class.cast(request) : b.build(); }	@param request HttpServletRequest	0	1
public List<Score> groupBy(DateUtils.TruncateField field, int firstWeekday) { computeAll(); HashMap<Timestamp, ArrayList<Double>> groups = getGroupedValues(field, firstWeekday); List<Score> scores = groupsToAvgScores(groups); Collections.sort(scores, (s1, s2) -> s2.compareNewer(s1)); return scores; }	@param from timestamp for the oldest score	0	1
private SourceRecord createSourceRecordWithTimestamp(Instant ts) { Map<String, ?> offset = Collections.singletonMap(SourceInfo.TIMESTAMP_KEY, ts.getEpochSecond()); return new SourceRecord(null, offset, null, null, null); }	@param tsSec the timestamp (in seconds) in the resulting offset.	1	0
private RectF drawBoxWithShadow(Canvas c, Paint p, int width, int height) { Resources res = mContext.getResources(); float shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur); float keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance); float corner = res.getDimension(R.dimen.widget_preview_corner_radius); RectF bounds = new RectF(shadowBlur, shadowBlur, width - shadowBlur, height - shadowBlur - keyShadowDistance); p.setColor(Color.WHITE); // Key shadow p.setShadowLayer(shadowBlur, 0, keyShadowDistance, ShadowGenerator.KEY_SHADOW_ALPHA << 24); c.drawRoundRect(bounds, corner, corner, p); // Ambient shadow p.setShadowLayer(shadowBlur, 0, 0, ColorUtils.setAlphaComponent(Color.BLACK, ShadowGenerator.AMBIENT_SHADOW_ALPHA)); c.drawRoundRect(bounds, corner, corner, p); p.clearShadowLayer(); return bounds; }	@param launcher	0	1
"public static Command<Void> setExtraHTTPHeaders(Headers headers) { Objects.requireNonNull(headers, ""headers must be set.""); return new Command<>(DOMAIN_NAME + "".setExtraHTTPHeaders"", ImmutableMap.of(""headers"", headers)); }"	@param headers Map with extra HTTP headers.	0	1
"public static String getClassName(String memberID, boolean isClassMember) { int pos = memberID.indexOf(ALT_MEMBER_SEPARATOR); // uses alternative separator, easy if (pos != -1) return memberID.substring(0, pos); pos = memberID.indexOf('('); if ( pos != -1 ) { // has a descriptor, is a method ID, strip last member part pos = memberID.lastIndexOf('.', pos); return pos != -1 ? memberID.substring(0, pos) : """"; } if (isClassMember) { // field or class name, cannot decide, assume it is a field pos = memberID.lastIndexOf('.'); return pos != -1 ? memberID.substring(0, pos) : """"; } else { // assume it is a class name return memberID; } }"	@param isClassMember If the signature is ambiguous, if true always assume that the last simple member name is a method or field, else assume it is a class name.	1	0
public static EBoolean isNotEmpty(EMap<?,?> map) { return operationFactory.createBoolean(Ops.MAP_ISNOTEMPTY,(Expr<?>) map); }	@param collection	0	1
public long set(long instant, int month) { Utils.verifyValueBounds(this, month, MIN, MAX); // int thisYear = iChronology.year().get(instant); // int thisDom = iChronology.getDayOfMonth(instant, thisYear); int maxDom = iChronology.getDaysInYearMonth(thisYear, month); if (thisDom > maxDom) { // Quietly force DOM to nearest sane value. thisDom = maxDom; } // Return newly calculated millis value return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) + iChronology.millisOfDay().get(instant); }	@param millis the time instant in millis to update.	1	0
protected SourceInfo update(Long lsn, Instant commitTime, Long txId, TableId tableId) { this.lsn = lsn; this.useconds = Conversions.toEpochMicros(commitTime); this.txId = txId; if (tableId != null && tableId.schema() != null) { this.schemaName = tableId.schema(); } if (tableId != null && tableId.table() != null) { this.tableName = tableId.table(); } return this; }	@param txId the ID of the transaction that generated the transaction; may be null if this information nis not available	0	1
"public Action timedout(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException { logger.trace(""Timing out {}"", req); if (trackActiveRequest(req) && completeLifecycle(req.resource(), false)) { config.framework().notify(Action.TYPE.TIMEOUT, req, res); } return timedoutAction; }"	@param response the AtmosphereResponse	1	0
"public static Token seek(Parser parser, String path) { // return current token if no path is given if (!StringUtils.hasText(path)) { return null; } List<String> tokens = StringUtils.tokenize(path, "".""); return seek(parser, tokens.toArray(new String[tokens.size()])); }"	@param parser	0	1
public InstantConverter removeInstantConverter(InstantConverter converter) throws SecurityException { checkAlterInstantConverters(); if (converter == null) { return null; } InstantConverter[] removed = new InstantConverter[1]; iInstantConverters = iInstantConverters.remove(converter, removed); return removed[0]; }	@param index the index to remove	1	0
public static Properties getPartitionMetadata(final HivePartition partition, final HiveTableWithColumnCache table) { final Properties properties; restoreColumns(table, partition); properties = MetaStoreUtils.getPartitionMetadata(partition, table); // SerDe expects properties from Table, but above call doesn't add Table properties. // Include Table properties in final list in order to not to break SerDes that depend on // Table properties. For example AvroSerDe gets the schema from properties (passed as second argument) for (Map.Entry<String, String> entry : table.getParameters().entrySet()) { if (entry.getKey() != null && entry.getKey() != null) { properties.put(entry.getKey(), entry.getValue()); } } return properties; }	@param table	1	0
"public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws RestClientException { Object postBody = new Object(); // verify the required parameter 'petId' is set if (petId == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'petId' when calling uploadFileWithRequiredFile""); } // verify the required parameter 'requiredFile' is set if (requiredFile == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile""); } // create path and map variables final Map<String, Object> uriVariables = new HashMap<String, Object>(); uriVariables.put(""petId"", petId); String path = UriComponentsBuilder.fromPath(""/fake/{petId}/uploadImageWithRequiredFile"").buildAndExpand(uriVariables).toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); if (additionalMetadata != null) formParams.add(""additionalMetadata"", additionalMetadata); if (requiredFile != null) formParams.add(""requiredFile"", new FileSystemResource(requiredFile)); final String[] accepts = { ""application/json"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { ""multipart/form-data"" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { ""petstore_auth"" }; ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {}; return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }"	@param additionalMetadata Additional data to pass to server	0	1
public static boolean filter(String path, Collection<String> includes, Collection<String> excludes) { includes = (includes == null ? Collections.<String> emptyList() : includes); excludes = (excludes == null ? Collections.<String> emptyList() : excludes); if (includes.isEmpty() && excludes.isEmpty()) { return true; } if (Regex.simpleMatch(excludes, path)) { return false; } boolean exactIncludeMatch = false; // true if the current position was specifically mentioned boolean pathIsPrefixOfAnInclude = false; // true if potentially a sub scope can be included if (includes.isEmpty()) { // implied match anything exactIncludeMatch = true; } else { for (String include : includes) { // check for prefix matches as well to see if we need to zero in, something like: obj1.arr1.* or *.field // note, this does not work well with middle matches, like obj1.*.obj3 if (include.charAt(0) == '*') { if (Regex.simpleMatch(include, path)) { exactIncludeMatch = true; break; } pathIsPrefixOfAnInclude = true; continue; } if (include.startsWith(path)) { if (include.length() == path.length()) { exactIncludeMatch = true; break; } else if (include.length() > path.length() && include.charAt(path.length()) == '.') { // include might may match deeper paths. Dive deeper. pathIsPrefixOfAnInclude = true; continue; } } if (Regex.simpleMatch(include, path)) { exactIncludeMatch = true; break; } } } if (!(pathIsPrefixOfAnInclude || exactIncludeMatch)) { // skip subkeys, not interesting. return false; } else if (exactIncludeMatch) { return true; } return false; }	@param includes	0	1
public boolean searchText(String regex, int matches, boolean scroll) { return searcher.searchText(regex, matches, scroll); }	@param matches the number of matches expected to be found. 0 matches means that one or more matches are expected to be found	0	1
"protected QualifiedName determineGeneratorTableName(Properties params, JdbcEnvironment jdbcEnvironment) { final String tableName = ConfigurationHelper.getString( TABLE_PARAM, params, DEF_TABLE ); if ( tableName.contains( ""."" ) ) { return QualifiedNameParser.INSTANCE.parse( tableName ); } else { // todo : need to incorporate implicit catalog and schema names final Identifier catalog = jdbcEnvironment.getIdentifierHelper().toIdentifier( ConfigurationHelper.getString( CATALOG, params ) ); final Identifier schema = jdbcEnvironment.getIdentifierHelper().toIdentifier( ConfigurationHelper.getString( SCHEMA, params ) ); return new QualifiedNameParser.NameParts( catalog, schema, jdbcEnvironment.getIdentifierHelper().toIdentifier( tableName ) ); } }"	@param dialect The dialect in effect	1	0
public Struct delete(Object before, Struct source, Instant timestamp) { Struct struct = new Struct(schema); struct.put(FieldName.OPERATION, Operation.DELETE.code()); if (before != null) { struct.put(FieldName.BEFORE, before); } if (source != null) { struct.put(FieldName.SOURCE, source); } if (timestamp != null) { struct.put(FieldName.TIMESTAMP, timestamp.toEpochMilli()); } return struct; }	@param before the state of the record before the delete; may be null	0	1
"public Client call123testSpecialTags(Client body) throws ApiException { Object localVarPostBody = body; // verify the required parameter 'body' is set if (body == null) { throw new ApiException(400, ""Missing the required parameter 'body' when calling call123testSpecialTags""); } // create path and map variables String localVarPath = ""/another-fake/dummy""; // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { ""application/json"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { ""application/json"" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Client> localVarReturnType = new GenericType<Client>() {}; return apiClient.invokeAPI(localVarPath, ""PATCH"", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	@param client client model (required)	1	0
protected boolean isNull(Object owner, SharedSessionContractImplementor session) { return false; }	@param session The orginating session.	0	1
public static TupleMetadata expandMetadata(TupleMetadata base, ImplicitColumnManager metadataProj, int dirCount) { TupleMetadata metadataSchema = new TupleSchema(); for (ColumnMetadata col : base) { metadataSchema.addColumn(col); } for (FileMetadataColumnDefn fileColDefn : metadataProj.fileMetadataColDefns()) { metadataSchema.add(MaterializedField.create(fileColDefn.colName(), fileColDefn.dataType())); } for (int i = 0; i < dirCount; i++) { metadataSchema.add(MaterializedField.create(metadataProj.partitionName(i), PartitionColumn.dataType())); } return metadataSchema; }	@param dirCount number of partition directories	0	1
"public Action suspended(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { logger.debug(""(suspend) invoked:\n HttpServletRequest: {}\n HttpServletResponse: {}"", request, response); return action(request, response); }"	@param res the HttpServletResponse	1	0
public Object get(String name) { if (bean != null) { Method method = getReadMethod(name); if (method != null) { try { return method.invoke(bean, NULL_ARGUMENTS); } catch (IllegalAccessException e) { logWarn(e); } catch (IllegalArgumentException e) { logWarn(e); } catch (InvocationTargetException e) { logWarn(e); } catch (NullPointerException e) { logWarn(e); } } } return null; }	@param name the name of the property whose value to return	0	1
public String getInitParameter(String key, String defaultValue) { String s = getInitParameter(key); if (s == null) { return defaultValue; } return s; }	@param closedAtmosphereThinkTime	1	0
public StringBuilder toStringBuilder(StringBuilder sb, boolean printOnlyLabelValue) { if (isLeaf()) { if (label() != null) { if(printOnlyLabelValue) { sb.append(label().value()); } else { sb.append(label()); } } return sb; } else { sb.append('('); if (label() != null) { if (printOnlyLabelValue) { if (value() != null) { sb.append(label().value()); } // don't print a null, just nothing! } else { sb.append(label()); } } Tree[] kids = children(); if (kids != null) { for (Tree kid : kids) { sb.append(' '); kid.toStringBuilder(sb, printOnlyLabelValue); } } return sb.append(')'); } }	@param labelFormatter Formatting routine for how to print a Label	1	0
private RectF drawBoxWithShadow(Canvas c, Paint p, int width, int height) { Resources res = mContext.getResources(); float shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur); float keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance); float corner = res.getDimension(R.dimen.widget_preview_corner_radius); RectF bounds = new RectF(shadowBlur, shadowBlur, width - shadowBlur, height - shadowBlur - keyShadowDistance); p.setColor(Color.WHITE); // Key shadow p.setShadowLayer(shadowBlur, 0, keyShadowDistance, ShadowGenerator.KEY_SHADOW_ALPHA << 24); c.drawRoundRect(bounds, corner, corner, p); // Ambient shadow p.setShadowLayer(shadowBlur, 0, 0, ColorUtils.setAlphaComponent(Color.BLACK, ShadowGenerator.AMBIENT_SHADOW_ALPHA)); c.drawRoundRect(bounds, corner, corner, p); p.clearShadowLayer(); return bounds; }	@param info information about the widget	0	1
"public static RemoteProxy getNewBasicRemoteProxy(String browser, String url, Registry registry) { RegistrationRequest req = RegistrationRequest.build(""-role"", ""webdriver""); req.getCapabilities().clear(); DesiredCapabilities capability = new DesiredCapabilities(); capability.setBrowserName(browser); req.addDesiredCapabilitiy(capability); Map<String, Object> config = new HashMap<String, Object>(); config.put(""url"", url); req.setConfiguration(config); return new RemoteProxy(req, registry); }"	@param registry	0	1
public static RuleSet getDrillBasicRules(OptimizerRulesContext optimizerRulesContext) { if (DRILL_BASIC_RULES == null) { DRILL_BASIC_RULES = new DrillRuleSet(ImmutableSet.<RelOptRule> builder().add( // // Add support for Distinct Union (by using Union-All followed by Distinct) UnionToDistinctRule.INSTANCE, // Add support for WHERE style joins. DrillFilterJoinRules.DRILL_FILTER_ON_JOIN, DrillFilterJoinRules.DRILL_JOIN, // End support for WHERE style joins. /* Filter push-down related rules */ DrillPushFilterPastProjectRule.INSTANCE, FilterSetOpTransposeRule.INSTANCE, FilterMergeRule.INSTANCE, AggregateRemoveRule.INSTANCE, ProjectRemoveRule.NAME_CALC_INSTANCE, SortRemoveRule.INSTANCE, DrillMergeProjectRule.getInstance(true, RelFactories.DEFAULT_PROJECT_FACTORY, optimizerRulesContext.getFunctionRegistry()), AggregateExpandDistinctAggregatesRule.INSTANCE, DrillReduceAggregatesRule.INSTANCE, /* Projection push-down related rules */ DrillPushProjectPastFilterRule.INSTANCE, DrillPushProjectPastJoinRule.INSTANCE, DrillPushProjIntoScan.INSTANCE, DrillProjectSetOpTransposeRule.INSTANCE, PruneScanRule.getFilterOnProject(optimizerRulesContext), PruneScanRule.getFilterOnScan(optimizerRulesContext), PruneScanRule.getFilterOnProjectParquet(optimizerRulesContext), PruneScanRule.getFilterOnScanParquet(optimizerRulesContext), /* Convert from Calcite Logical to Drill Logical Rules. */ ExpandConversionRule.INSTANCE, DrillScanRule.INSTANCE, DrillFilterRule.INSTANCE, DrillProjectRule.INSTANCE, DrillWindowRule.INSTANCE, DrillAggregateRule.INSTANCE, DrillLimitRule.INSTANCE, DrillSortRule.INSTANCE, DrillJoinRule.INSTANCE, DrillUnionAllRule.INSTANCE, DrillValuesRule.INSTANCE ) .build()); } return DRILL_BASIC_RULES; }	@param context - shared state used during planning, currently used here to gain access to the fucntion registry described above.	1	0
"public static RemoteProxy getNewBasicRemoteProxy(List<Map<String, Object>> caps, String url,Registry registry) { RegistrationRequest req = new RegistrationRequest(); req.setCapabilities(caps); Map<String, Object> config = new HashMap<String, Object>(); config.put(""url"", url); req.setConfiguration(config); return new RemoteProxy(req,registry); }"	@param url	0	1
public static int bitCount(long lng) { lng = (lng & 0x5555555555555555L) + ((lng >> 1) & 0x5555555555555555L); lng = (lng & 0x3333333333333333L) + ((lng >> 2) & 0x3333333333333333L); // adjust for 64-bit integer int i = (int) ((lng >>> 32) + lng); i = (i & 0x0F0F0F0F) + ((i >> 4) & 0x0F0F0F0F); i = (i & 0x00FF00FF) + ((i >> 8) & 0x00FF00FF); i = (i & 0x0000FFFF) + ((i >> 16) & 0x0000FFFF); return i; }	@param v the long to examine.	1	0
public boolean searchButton(String text, int minimumNumberOfMatches, boolean onlyVisible) { boolean found = searcher.searchWithTimeoutFor(Button.class, text, minimumNumberOfMatches, true, onlyVisible); return found; }	@param minimumNumberOfMatches the minimum number of matches expected to be found. 0 matches means that one or more matches are expected to be found	0	1
public ArrayList<View> getAllViews(boolean onlySufficientlyVisible) { Activity activity = activityUtils.getCurrentActivity(false); final View [] views = getWindowDecorViews(); final ArrayList<View> allViews = new ArrayList<View>(); final View [] nonDecorViews = getNonDecorViews(views); if(views !=null && views.length > 0) { if(!activity.hasWindowFocus()){ for(View view : views){ if(!activity.getWindow().getDecorView().equals(view)){ try{ addChildren(allViews,(ViewGroup) view, onlySufficientlyVisible); } catch (Exception ignored) {} } } } else{ for(View view : nonDecorViews){ try{ addChildren(allViews,(ViewGroup) view, onlySufficientlyVisible); } catch (Exception ignored) {} } try{ addChildren(allViews,(ViewGroup) getRecentDecorView(views), onlySufficientlyVisible); } catch (Exception ignored) {} } } return allViews; }	@param onlyFullyVisible if only fully visible views should be returned	1	0
public CloseableIterator<Tuple> iterate(Expression<?>... args) { return iterate(queryMixin.createProjection(args)); }	@param target	0	1
public UpdateUserOper body(User body) { reqSpec.setBody(body); return this; }	@param user (User) Updated user object (required)	1	0
"public String getLimitString(String querySqlString, boolean hasOffset) { StringBuilder sb = new StringBuilder(querySqlString.trim().toLowerCase()); int orderByIndex = sb.indexOf(""order by""); CharSequence orderby = orderByIndex > 0 ? sb.subSequence(orderByIndex, sb.length()) : ""ORDER BY CURRENT_TIMESTAMP""; // Delete the order by clause at the end of the query if (orderByIndex > 0) { sb.delete(orderByIndex, orderByIndex + orderby.length()); } // HHH-5715 bug fix replaceDistinctWithGroupBy(sb); insertRowNumberFunction(sb, orderby); // Wrap the query within a with statement: sb.insert(0, ""WITH query AS ("").append("") SELECT * FROM query ""); //sb.append(""WHERE __hibernate_row_nr__ BETWEEN "").append(offset + 1).append("" AND "").append(limit); sb.append(""WHERE __hibernate_row_nr__ BETWEEN ? AND ?""); return sb.toString(); }"	@param offset Offset of the first row to be returned by the query (zero-based)	0	1
static public Mode parseMode(CharSequence code) { // See if we can find any function in the global scope if (findInCurrentScope(FUNCTION_DECL, code) != null) { return Mode.ACTIVE; } // See if we can find any public class extending PApplet if (findInCurrentScope(PUBLIC_CLASS, code) != null) { return Mode.JAVA; } return Mode.STATIC; }	@param code code without comments	0	1
public static RequestQueue newRequestQueue(IRestProtocol implRestConnection, int threadPoolSize) { return newRequestQueue(RestParser.getInstance(implRestConnection), threadPoolSize); }	@param threadPoolSize request the number of concurrent.	0	1
"public static String getClassName(String memberID, boolean isClassMember) { int pos = memberID.indexOf(ALT_MEMBER_SEPARATOR); // uses alternative separator, easy if (pos != -1) return memberID.substring(0, pos); pos = memberID.indexOf('('); if ( pos != -1 ) { // has a descriptor, is a method ID, strip last member part pos = memberID.lastIndexOf('.', pos); return pos != -1 ? memberID.substring(0, pos) : """"; } if (isClassMember) { // field or class name, cannot decide, assume it is a field pos = memberID.lastIndexOf('.'); return pos != -1 ? memberID.substring(0, pos) : """"; } else { // assume it is a class name return memberID; } }"	@param signature the signature to parse.	1	0
"public boolean checkAlreadyExist(AccountDatabase.AccountName s) { // Query in the realm database RealmQuery<AccountDatabase> query = realm.where(AccountDatabase.class); // Checking if string equals to is exist or not query.equalTo(""name"", s.toString()); RealmResults<AccountDatabase> result1 = query.findAll(); // Here checking if count of that values is greater than zero return (result1.size() > 0) ? true : false; }"	@param s Name of the account from accountList e.g. Twitter	0	1
public int get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }	@param attributes an object containing an AttributeMap	1	0
"public boolean remove(final BaseDownloadTask willRemoveDownload, final int removeByStatus) { boolean succeed; synchronized (list) { succeed = list.remove(willRemoveDownload); } if (succeed) { // ææ¶æ¯ switch (removeByStatus) { case FileDownloadStatus.warn: willRemoveDownload.getDriver().notifyWarn(); break; case FileDownloadStatus.error: willRemoveDownload.getDriver().notifyError(); break; case FileDownloadStatus.paused: willRemoveDownload.getDriver().notifyPaused(); break; case FileDownloadStatus.completed: Throwable ex = null; try{ willRemoveDownload.getDriver().notifyBlockComplete(); }catch (Throwable e){ ex = e; } if (ex != null) { willRemoveDownload.setStatus(FileDownloadStatus.error); willRemoveDownload.setEx(ex); willRemoveDownload.getDriver().notifyError(); } else { willRemoveDownload.getDriver().notifyCompleted(); } break; } } else { FileDownloadLog.e(this, ""remove error, not exist: %s"", willRemoveDownload); } return succeed; }"	@param willRemoveDownload	0	1
"public int compareTo(ReadablePartial other) { if (this == other) { return 0; } if (size() != other.size()) { throw new ClassCastException(""ReadablePartial objects must have matching field types""); } for (int i = 0, isize = size(); i < isize; i++) { if (getFieldType(i) != other.getFieldType(i)) { throw new ClassCastException(""ReadablePartial objects must have matching field types""); } } // fields are ordered largest first for (int i = 0, isize = size(); i < isize; i++) { if (getValue(i) > other.getValue(i)) { return 1; } if (getValue(i) < other.getValue(i)) { return -1; } } return 0; }"	@param partial an object to check against	1	0
"public ApiResponse<Client> testClientModelWithHttpInfo(Client client) throws ApiException { Object localVarPostBody = client; // verify the required parameter 'client' is set if (client == null) { throw new ApiException(400, ""Missing the required parameter 'client' when calling testClientModel""); } // create path and map variables String localVarPath = ""/fake""; // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { ""application/json"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { ""application/json"" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Client> localVarReturnType = new GenericType<Client>() {}; return apiClient.invokeAPI(localVarPath, ""PATCH"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	@param body client model (required)	1	0
public static FileSelection create(List<FileStatus> statuses, List<Path> files, Path root) { return FileSelection.create(statuses, files, root, null, false); }	@param statuses list of file statuses	0	1
"public Collection<Tree> getRelatedNodes(Tree t, Tree root) { if (root.value() == null) { root.setValue(""ROOT""); // todo: cdm: it doesn't seem like this line should be here } Set<Tree> nodeList = new LinkedHashSet<Tree>(); for (TregexPattern p : targetPatterns) { // cdm: I deleted: && nodeList.isEmpty() TregexMatcher m = p.matcher(root); while (m.findAt(t)) { nodeList.add(m.getNode(""target"")); if (DEBUG) { System.err.println(""found "" + this + ""("" + t + "", "" + m.getNode(""target"") + "") using pattern "" + p); for (String nodeName : m.getNodeNames()) { if (nodeName.equals(""target"")) continue; System.err.println("" node "" + nodeName + "": "" + m.getNode(nodeName)); } } } } return nodeList; }"	@param t Target for finding dependents of t related by this GR	1	0
"public TableSchema create(String schemaPrefix, String envelopSchemaName, Table table, ColumnNameFilter filter, ColumnMappers mappers) { if (schemaPrefix == null) { schemaPrefix = """"; } // Build the schemas ... final TableId tableId = table.id(); final String tableIdStr = tableSchemaName(tableId); final String schemaNamePrefix = schemaPrefix + tableIdStr; LOGGER.debug(""Mapping table '{}' to schemas under '{}'"", tableId, schemaNamePrefix); SchemaBuilder valSchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + "".Value"")); SchemaBuilder keySchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + "".Key"")); AtomicBoolean hasPrimaryKey = new AtomicBoolean(false); table.columns().forEach(column -> { if (table.isPrimaryKeyColumn(column.name())) { // The column is part of the primary key, so ALWAYS add it to the PK schema ... addField(keySchemaBuilder, column, null); hasPrimaryKey.set(true); } if (filter == null || filter.matches(tableId.catalog(), tableId.schema(), tableId.table(), column.name())) { // Add the column to the value schema only if the column has not been filtered ... ColumnMapper mapper = mappers == null ? null : mappers.mapperFor(tableId, column); addField(valSchemaBuilder, column, mapper); } }); Schema valSchema = valSchemaBuilder.optional().build(); Schema keySchema = hasPrimaryKey.get() ? keySchemaBuilder.build() : null; if (LOGGER.isDebugEnabled()) { LOGGER.debug(""Mapped primary key for table '{}' to schema: {}"", tableId, SchemaUtil.asDetailedString(keySchema)); LOGGER.debug(""Mapped columns for table '{}' to schema: {}"", tableId, SchemaUtil.asDetailedString(valSchema)); } Envelope envelope = Envelope.defineSchema() .withName(schemaNameAdjuster.adjust(envelopSchemaName)) .withRecord(valSchema) .withSource(sourceInfoSchema) .build(); // Create the generators ... Function<Object[], Object> keyGenerator = createKeyGenerator(keySchema, tableId, table.primaryKeyColumns()); Function<Object[], Struct> valueGenerator = createValueGenerator(valSchema, tableId, table.columns(), filter, mappers); // And the table schema ... return new TableSchema(tableId, keySchema, keyGenerator, envelope, valSchema, valueGenerator); }"	@param table the table definition; may not be null	0	1
public boolean parseMoreData(final EncodedImage encodedImage) { if (mParserState == NOT_A_JPEG) { return false; } final int dataBufferSize = encodedImage.getSize(); // Is there any new data to parse? // mBytesParsed might be greater than size of dataBuffer - that happens when // we skip more data than is available to read inside doParseMoreData method if (dataBufferSize <= mBytesParsed) { return false; } final InputStream bufferedDataStream = new PooledByteArrayBufferedInputStream( encodedImage.getInputStream(), mByteArrayPool.get(BUFFER_SIZE), mByteArrayPool); try { StreamUtil.skip(bufferedDataStream, mBytesParsed); return doParseMoreData(bufferedDataStream); } catch (IOException ioe) { // Does not happen - streams returned by PooledByteBuffers do not throw IOExceptions Throwables.propagate(ioe); return false; } finally { Closeables.closeQuietly(bufferedDataStream); } }	@param dataBufferRef Next set of bytes received by the caller	1	0
"public Collection<Tree> getRelatedNodes(Tree t, Tree root) { if (root.value() == null) { root.setValue(""ROOT""); // todo: cdm: it doesn't seem like this line should be here } Set<Tree> nodeList = new LinkedHashSet<Tree>(); for (TregexPattern p : targetPatterns) { // cdm: I deleted: && nodeList.isEmpty() TregexMatcher m = p.matcher(root); while (m.findAt(t)) { nodeList.add(m.getNode(""target"")); //System.out.println(""found "" + this + ""("" + t + "", "" + m.getNode(""target"") + "") using pattern "" + p); } } return nodeList; }"	@param root The root of the Tree	0	1
"public boolean applyAPSRequest(APSResult request, Callback callback) { PumpInterface pump = getActivePump(); request.rate = applyBasalConstraints(request.rate); PumpEnactResult result; if (!pump.isInitialized()) { log.debug(""applyAPSRequest: "" + MainApp.sResources.getString(R.string.pumpNotInitialized)); if (callback != null) { callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpNotInitialized)).enacted(false).success(false)).run(); } return false; } if (pump.isSuspended()) { log.debug(""applyAPSRequest: "" + MainApp.sResources.getString(R.string.pumpsuspended)); if (callback != null) { callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpsuspended)).enacted(false).success(false)).run(); } return false; } if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: "" + request.toString()); if ((request.rate == 0 && request.duration == 0) || Math.abs(request.rate - pump.getBaseBasalRate()) < pump.getPumpDescription().basalStep) { if (isTempBasalInProgress()) { if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: cancelTempBasal()""); getCommandQueue().cancelTempBasal(false, callback); return true; } else { if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: Basal set correctly""); if (callback != null) { callback.result(new PumpEnactResult().absolute(request.rate).duration(0).enacted(false).success(true).comment(""Basal set correctly"")).run(); } return false; } } else if (isTempBasalInProgress() && getTempBasalRemainingMinutesFromHistory() > 5 && Math.abs(request.rate - getTempBasalAbsoluteRateHistory()) < pump.getPumpDescription().basalStep) { if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: Temp basal set correctly""); if (callback != null) { callback.result(new PumpEnactResult().absolute(getTempBasalAbsoluteRateHistory()).duration(getTempBasalFromHistory(System.currentTimeMillis()).getPlannedRemainingMinutes()).enacted(false).success(true).comment(""Temp basal set correctly"")).run(); } return false; } else { if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: setTempBasalAbsolute()""); getCommandQueue().tempBasalAbsolute(request.rate, request.duration, false, callback); return true; } }"	@param request	0	1
public static Properties getPartitionMetadata(final HivePartition partition, final HiveTableWithColumnCache table) { final Properties properties; restoreColumns(table, partition); properties = MetaStoreUtils.getPartitionMetadata(partition, table); // SerDe expects properties from Table, but above call doesn't add Table properties. // Include Table properties in final list in order to not to break SerDes that depend on // Table properties. For example AvroSerDe gets the schema from properties (passed as second argument) for (Map.Entry<String, String> entry : table.getParameters().entrySet()) { if (entry.getKey() != null && entry.getKey() != null) { properties.put(entry.getKey(), entry.getValue()); } } return properties; }	@param partition	1	0
public Actions release(WebElement target) { if (isBuildingActions()) { action.addAction(new ButtonReleaseAction(jsonMouse, (Locatable) target)); return this; } return moveToElement(target).release(); }	@param onElement Element to release the mouse button above.	1	0
public static Polygon getCanvasTilePoly(Client client, LocalPoint localLocation) { return getCanvasTileAreaPoly(client, localLocation, 1); }	@param localLocation local location of the tile	0	1
public boolean searchButton(String regex, int matches) { long now = System.currentTimeMillis(); final long endTime = now + TIMEOUT; while (!searchForButton(regex, matches) && now < endTime) { now = System.currentTimeMillis(); } if(now < endTime) return true; else return false; }	@param search the string to be searched. The parameter will be interpreted as a regular expression.	1	0
public static StringTemplate stringTemplate(String template, ImmutableList<?> args) { return new StringTemplate(createTemplate(template), args); }	@param args	0	1
public static byte[] readByteCode(ZipInputStream zip) throws IOException { ByteArrayOutputStream bout = new ByteArrayOutputStream(); InputStream in = new BufferedInputStream( zip ); int b; while ( ( b = in.read() ) != -1 ) { bout.write( b ); } return bout.toByteArray(); }	@param inputStream	1	0
"public String invokeAPI(String path, String method, Set<QueryParam> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); b.append(""?""); if (queryParams != null){ for (QueryParam queryParam : queryParams){ if (!queryParam.getName().isEmpty()) { b.append(escapeString(queryParam.getName())); b.append(""=""); b.append(escapeString(queryParam.getValue())); b.append(""&""); } } } String querystring = b.substring(0, b.length() - 1); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(""GET"".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (""POST"".equals(method)) { if (contentType.startsWith(""application/x-www-form-urlencoded"")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (""PUT"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (""DELETE"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, ""unknown method type "" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return """"; } } else { String message = ""error""; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { // e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }"	@param body The request body object	0	1
public int compareTo(ByteArrayWritable that) { return WritableComparator.compareBytes(this.data, this.offset, this.length, that.data, that.offset, that.length); }	@param that	1	0
protected Object suspendAndGet(Object key, FlagAdapter opt, boolean suppressTimeout) throws CacheException { Transaction tx = suspend(); try { if (suppressTimeout) return cacheAdapter.getAllowingTimeout(key); else return cacheAdapter.get(key); } finally { resume(tx); } }	@param key The key of the item to get	0	1
"public Mono<Client> testClassname(Client body) throws RestClientException { Object postBody = body; // verify the required parameter 'body' is set if (body == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'body' when calling testClassname""); } String path = UriComponentsBuilder.fromPath(""/fake_classname_test"").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { ""application/json"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { ""application/json"" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { ""api_key_query"" }; ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {}; return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }"	@param client client model	1	0
private boolean limitTranslation(Matrix transform, boolean shouldLimitX, boolean shouldLimitY) { if (!shouldLimitX && !shouldLimitY) { return false; } RectF b = mTempRect; b.set(mImageBounds); transform.mapRect(b); float offsetLeft = !shouldLimitX ? 0 : getOffset(b.left, b.right, mViewBounds.left, mViewBounds.right, mImageBounds.centerX()); float offsetTop = !shouldLimitY ? 0 : getOffset(b.top, b.bottom, mViewBounds.top, mViewBounds.bottom, mImageBounds.centerY()); if (offsetLeft != 0 || offsetTop != 0) { transform.postTranslate(offsetLeft, offsetTop); return true; } return false; }	@param limitY whether to apply the limit on the y-axis	1	0
public Object readPayload(DataInput dataIn) throws IOException{ return dataIn.readUTF(); }	@param dataIn	0	1
public Serializable generate(SharedSessionContractImplementor session, Object object) throws HibernateException { return optimizer.generate( databaseStructure.buildCallback( session ) ); }	@param initialValue The initial value.	0	1
private boolean scrollScrollView(int direction, ArrayList<ScrollView> scrollViews){ int[] xy = new int[2]; ScrollView scroll = viewFetcher.getView(ScrollView.class, scrollViews, 0); scroll.getLocationOnScreen(xy); int height = scroll.getHeight(); int to = 0; if (direction == DOWN) { to = (height); } else if (direction == UP) { to = (-height); } scrollAmount = scroll.getScrollY(); scrollScrollViewTo(scroll,0, to); if (scrollAmount == scroll.getScrollY()) { return false; } else{ return true; } }	@param direction the direction to be scrolled	0	1
private boolean limitTranslation(Matrix transform, boolean shouldLimitX, boolean shouldLimitY) { if (!shouldLimitX && !shouldLimitY) { return false; } RectF b = mTempRect; b.set(mImageBounds); transform.mapRect(b); float offsetLeft = !shouldLimitX ? 0 : getOffset(b.left, b.right, mViewBounds.left, mViewBounds.right, mImageBounds.centerX()); float offsetTop = !shouldLimitY ? 0 : getOffset(b.top, b.bottom, mViewBounds.top, mViewBounds.bottom, mImageBounds.centerY()); if (offsetLeft != 0 || offsetTop != 0) { transform.postTranslate(offsetLeft, offsetTop); return true; } return false; }	@param limitX whether to apply the limit on the x-axis	1	0
protected boolean isNull(Object owner, SharedSessionContractImplementor session) { return false; }	@param id The entity id to resolve	0	1
public TransportLogger createTransportLogger(Transport next, Logger log) throws IOException { return createTransportLogger(next, getNextId(), log, defaultLogWriterName, defaultDynamicManagement, defaultInitialBehavior, defaultJmxPort); }	@param next The next Transport layer in the Transport stack.	0	1
"Action action(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException { boolean webSocketEnabled = false; if (req.getHeaders(""Connection"") != null && req.getHeaders(""Connection"").hasMoreElements()) { String[] e = req.getHeaders(""Connection"").nextElement().toString().split("",""); for (String upgrade : e) { if (upgrade.equalsIgnoreCase(""Upgrade"")) { webSocketEnabled = true; break; } } } if (webSocketEnabled && !supportWebSocket()) { res.setStatus(501); res.addHeader(X_ATMOSPHERE_ERROR, ""Websocket protocol not supported""); res.flushBuffer(); return new Action(); } if (config.handlers().isEmpty()) { logger.error(""No AtmosphereHandler found. Make sure you define it inside META-INF/atmosphere.xml""); throw new AtmosphereMappingException(""No AtmosphereHandler found. Make sure you define it inside META-INF/atmosphere.xml""); } if (supportSession()) { // Create the session needed to support the Resume // operation from disparate requests. HttpSession session = req.getSession(true); // Do not allow times out. if (session.getMaxInactiveInterval() == DEFAULT_SESSION_TIMEOUT) { session.setMaxInactiveInterval(-1); } } req.setAttribute(FrameworkConfig.SUPPORT_SESSION, supportSession()); AtmosphereHandlerWrapper handlerWrapper = map(req); // Check Broadcaster state. If destroyed, replace it. Broadcaster b = handlerWrapper.broadcaster; if (b.isDestroyed()) { synchronized (handlerWrapper) { config.getBroadcasterFactory().remove(b, b.getID()); handlerWrapper.broadcaster = config.getBroadcasterFactory().get(b.getID()); } } AtmosphereResourceImpl resource = new AtmosphereResourceImpl(config, handlerWrapper.broadcaster, req, res, this, handlerWrapper.atmosphereHandler); req.setAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE, resource); req.setAttribute(FrameworkConfig.ATMOSPHERE_HANDLER, handlerWrapper.atmosphereHandler); try { handlerWrapper.atmosphereHandler.onRequest(resource); } catch (IOException t) { resource.onThrowable(t); throw t; } if (trackActiveRequest && resource.getAtmosphereResourceEvent().isSuspended() && req.getAttribute(FrameworkConfig.CANCEL_SUSPEND_OPERATION) == null) { req.setAttribute(MAX_INACTIVE, System.currentTimeMillis()); aliveRequests.put(req, resource); } return resource.action(); }"	@param res the HttpServletResponse	1	0
public JdbcConnection query(String query, ResultSetConsumer resultConsumer) throws SQLException { Connection conn = connection(); try (Statement statement = conn.createStatement();) { try (ResultSet resultSet = statement.executeQuery(query);) { if (resultConsumer != null) { resultConsumer.accept(resultSet); } } } return this; }	@param query the SQL query	0	1
public Index parseAndUpdateIndex(List<JaxbRoot<XMLEntityMappings>> mappings, Index annotationIndex) { for ( JaxbRoot<XMLEntityMappings> root : mappings ) { root.getRoot().toString(); } return annotationIndex; }	@param mappingFileNames the file names of the xml files to parse	1	0
"public SeleneseCommand handleCommandResult(String commandResult, FrameAddress incomingFrameAddress, String uniqueId) { SeleneseQueue queue; if (!SeleniumServer.isProxyInjectionMode()) { queue = getSeleneseQueue(); } else { if (incomingFrameAddress.getWindowName().equals(SELENIUM_WINDOW_NAME_UNKNOWN_POPUP)) { boolean foundFrameAddressOfUnknownPopup = false; for (FrameAddress knownFrameAddress : frameAddressToSeleneseQueue.keySet()) { // the situation being handled here: a pop-up window has either just loaded or reloaded, and therefore // doesn't know its name. It uses SELENIUM_WINDOW_NAME_UNKNOWN_POPUP as a placeholder. // Meanwhile, on the selenium server-side, a thread is waiting for this result. // // To determine if this has happened, we cycle through all of the SeleneseQueue objects, // looking for ones with a matching local frame address (e.g., top.frames[1]), is also a // pop-up, and which has a thread waiting on a result. If all of these conditions hold, // then we figure this queue is the one that we want: if (knownFrameAddress.getLocalFrameAddress().equals(incomingFrameAddress.getLocalFrameAddress()) && !knownFrameAddress.getWindowName().equals(DEFAULT_SELENIUM_WINDOW_NAME) && frameAddressToSeleneseQueue.get(knownFrameAddress).getCommandResultHolder().hasBlockedGetter()) { incomingFrameAddress = knownFrameAddress; foundFrameAddressOfUnknownPopup = true; break; } } if (!foundFrameAddressOfUnknownPopup) { SeleniumServer.log(""WARNING: unknown popup "" + incomingFrameAddress + "" was not resolved""); } } queue = getSeleneseQueue(incomingFrameAddress); } queue.setUniqueId(uniqueId); return queue.handleCommandResult(commandResult); }"	@param commandResult - the reply from the previous command, or null	0	1
public boolean searchWithTimeoutFor(Class<? extends TextView> viewClass, String regex, int expectedMinimumNumberOfMatches, boolean scroll) { final long endTime = System.currentTimeMillis() + TIMEOUT; while (System.currentTimeMillis() < endTime) { sleeper.sleep(); final boolean foundAnyMatchingView = searchFor(viewClass, regex, expectedMinimumNumberOfMatches, scroll); if (foundAnyMatchingView){ return true; } } return false; }	@param matches the number of matches expected to be found. 0 matches means that one or more matches are expected to be found	1	0
private RexNode adjustCondition(LogicalProject project, SemiJoin semiJoin) { // create two RexPrograms -- the bottom one representing a // concatenation of the project and the RHS of the semijoin and the // top one representing the semijoin condition RexBuilder rexBuilder = project.getCluster().getRexBuilder(); RelDataTypeFactory typeFactory = rexBuilder.getTypeFactory(); RelNode rightChild = semiJoin.getRight(); // for the bottom RexProgram, the input is a concatenation of the // child of the project and the RHS of the semijoin RelDataType bottomInputRowType = Join.deriveJoinRowType( project.getInput().getRowType(), rightChild.getRowType(), JoinRelType.INNER, typeFactory, null, semiJoin.getSystemFieldList()); RexProgramBuilder bottomProgramBuilder = new RexProgramBuilder(bottomInputRowType, rexBuilder); // add the project expressions, then add input references for the RHS // of the semijoin for (Pair<RexNode, String> pair : project.getNamedProjects()) { bottomProgramBuilder.addProject(pair.left, pair.right); } int nLeftFields = project.getInput().getRowType().getFieldCount(); List<RelDataTypeField> rightFields = rightChild.getRowType().getFieldList(); int nRightFields = rightFields.size(); for (int i = 0; i < nRightFields; i++) { final RelDataTypeField field = rightFields.get(i); RexNode inputRef = rexBuilder.makeInputRef( field.getType(), i + nLeftFields); bottomProgramBuilder.addProject(inputRef, field.getName()); } RexProgram bottomProgram = bottomProgramBuilder.getProgram(); // input rowtype into the top program is the concatenation of the // project and the RHS of the semijoin RelDataType topInputRowType = Join.deriveJoinRowType( project.getRowType(), rightChild.getRowType(), JoinRelType.INNER, typeFactory, null, semiJoin.getSystemFieldList()); RexProgramBuilder topProgramBuilder = new RexProgramBuilder( topInputRowType, rexBuilder); topProgramBuilder.addIdentity(); topProgramBuilder.addCondition(semiJoin.getCondition()); RexProgram topProgram = topProgramBuilder.getProgram(); // merge the programs and expand out the local references to form // the new semijoin condition; it now references a concatenation of // the project's child and the RHS of the semijoin RexProgram mergedProgram = RexProgramBuilder.mergePrograms( topProgram, bottomProgram, rexBuilder); return mergedProgram.expandLocalRef( mergedProgram.getCondition()); }	@param project ProjectRel on the LHS of the semijoin	1	0
"private void preparHtmlForGlobalDescription(OpenAPI openAPI) { if (openAPI.getInfo() == null) { return; } String currentDescription = openAPI.getInfo().getDescription(); if (currentDescription != null && !currentDescription.isEmpty()) { Markdown markInstance = new Markdown(); openAPI.getInfo().setDescription( markInstance.toHtml(currentDescription) ); } else { LOGGER.error(""OpenAPI object description is empty ["" + openAPI.getInfo().getTitle() + ""]""); } }"	"@param swagger The base object containing the global description through ""Info"" class"	0	1
"public void updateUser (String username, User user) throws TimeoutException, ExecutionException, InterruptedException, ApiException { Object postBody = user; // verify the required parameter 'username' is set if (username == null) { VolleyError error = new VolleyError(""Missing the required parameter 'username' when calling updateUser"", new ApiException(400, ""Missing the required parameter 'username' when calling updateUser"")); } // verify the required parameter 'user' is set if (user == null) { VolleyError error = new VolleyError(""Missing the required parameter 'user' when calling updateUser"", new ApiException(400, ""Missing the required parameter 'user' when calling updateUser"")); } // create path and map variables String path = ""/user/{username}"".replaceAll(""\\{"" + ""username"" + ""\\}"", apiInvoker.escapeString(username.toString())); // query params List<Pair> queryParams = new ArrayList<Pair>(); // header params Map<String, String> headerParams = new HashMap<String, String>(); // form params Map<String, String> formParams = new HashMap<String, String>(); String[] contentTypes = { ""application/json"" }; String contentType = contentTypes.length > 0 ? contentTypes[0] : ""application/json""; if (contentType.startsWith(""multipart/form-data"")) { // file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); HttpEntity httpEntity = localVarBuilder.build(); postBody = httpEntity; } else { // normal form params } String[] authNames = new String[] { }; try { String localVarResponse = apiInvoker.invokeAPI (basePath, path, ""PUT"", queryParams, postBody, headerParams, formParams, contentType, authNames); if (localVarResponse != null) { return ; } else { return ; } } catch (ApiException ex) { throw ex; } catch (InterruptedException ex) { throw ex; } catch (ExecutionException ex) { if (ex.getCause() instanceof VolleyError) { VolleyError volleyError = (VolleyError)ex.getCause(); if (volleyError.networkResponse != null) { throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage()); } } throw ex; } catch (TimeoutException ex) { throw ex; } }"	@param username name that need to be deleted	0	1
public boolean searchToggleButton(String regex, int matches) { long now = System.currentTimeMillis(); final long endTime = now + TIMEOUT; while (!searchForToggleButton(regex, matches) && now < endTime) { now = System.currentTimeMillis(); } if(now < endTime) return true; else return false; }	@param search the string to be searched. The parameter will be interpreted as a regular expression.	1	0
protected BroadcastAction filter(HttpServletRequest request, HttpServletResponse response, Object object) { BroadcastAction transformed = new BroadcastAction(object); for (PerRequestBroadcastFilter mf : perRequestFilters) { transformed = mf.filter(request, response, transformed.message()); if (transformed == null || transformed.action() == BroadcastAction.ACTION.ABORT) { return transformed; } } return transformed; }	@param object the broadcasted object.	0	1
"public Index parseAndUpdateIndex(Set<String> mappingFileNames, Index annotationIndex) { ClassLoaderService classLoaderService = meta.getServiceRegistry().getService( ClassLoaderService.class ); Set<InputStream> mappingStreams = new HashSet<InputStream>(); for ( String fileName : mappingFileNames ) { EntityMappings entityMappings; try { entityMappings = XmlHelper.unmarshallXml( fileName, ORM2_MAPPING_XSD, EntityMappings.class, classLoaderService ).getRoot(); } catch ( JAXBException orm2Exception ) { // if we cannot parse against orm_2_0.xsd we try orm_1_0.xsd for backwards compatibility try { entityMappings = XmlHelper.unmarshallXml( fileName, ORM1_MAPPING_XSD, EntityMappings.class, classLoaderService ).getRoot(); } catch ( JAXBException orm1Exception ) { throw new AnnotationException( ""Unable to parse xml configuration."", orm1Exception ); } } entityMappings.toString(); } return null; }"	@param annotationIndex the annotation index based on scanned annotations	0	1
"private int scanURL(String url, User user, int maxChildren) throws ApiException { log.debug(""API Spider scanning url: "" + url); URI startURI; try { // Try to build uri startURI = new URI(url, true); } catch (URIException e) { throw new ApiException(ApiException.Type.BAD_FORMAT); } SiteNode startNode = Model.getSingleton().getSession().getSiteTree().findNode(startURI); String scheme = startURI.getScheme(); if (scheme == null || (!scheme.equalsIgnoreCase(""http"") && !scheme.equalsIgnoreCase(""https""))) { throw new ApiException(ApiException.Type.BAD_FORMAT); } Target target = new Target(startNode); target.setRecurse(true); Object[] objs = null; if (maxChildren > 0) { // Add the filters to filter on maximum number of children MaxChildrenFetchFilter maxChildrenFetchFilter = new MaxChildrenFetchFilter(); maxChildrenFetchFilter.setMaxChildren(maxChildren); maxChildrenFetchFilter.setModel(extension.getModel()); MaxChildrenParseFilter maxChildrenParseFilter = new MaxChildrenParseFilter(); maxChildrenParseFilter.setMaxChildren(maxChildren); maxChildrenParseFilter.setModel(extension.getModel()); objs = new Object[] { maxChildrenFetchFilter, maxChildrenParseFilter }; } return extension.startScan(target.getDisplayName(), target, user, objs); }"	@param url the url to start the spider scan	0	1
"static String formatSQLParsingError(String sql, DrillSqlParseException ex) { final String sqlErrorMessageHeader = ""SQL Query: ""; final SqlParserPos pos = ex.getPos(); if (pos != null) { int issueLineNumber = pos.getLineNum() - 1; // recalculates to base 0 int issueColumnNumber = pos.getColumnNum() - 1; // recalculates to base 0 int messageHeaderLength = sqlErrorMessageHeader.length(); // If the issue happens on the first line, header width should be calculated alongside with the sql query int shiftLength = (issueLineNumber == 0) ? issueColumnNumber + messageHeaderLength : issueColumnNumber; StringBuilder sb = new StringBuilder(); String[] lines = sql.split(DrillParserUtil.EOL); for (int i = 0; i < lines.length; i++) { sb.append(lines[i]); if (i == issueLineNumber) { sb .append(DrillParserUtil.EOL) .append(StringUtils.repeat(' ', shiftLength)) .append(""^""); } if (i < lines.length - 1) { sb.append(DrillParserUtil.EOL); } } sql = sb.toString(); } return sqlErrorMessageHeader + sql; }"	@param pos the position of the error	1	0
"public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); for(String key : queryParams.keySet()) { String value = queryParams.get(key); if (value != null){ if(b.toString().length() == 0) b.append(""?""); else b.append(""&""); b.append(escapeString(key)).append(""="").append(escapeString(value)); } } String querystring = b.toString(); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(""GET"".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (""POST"".equals(method)) { if (contentType.startsWith(""application/x-www-form-urlencoded"")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (""PUT"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (""DELETE"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, ""unknown method type "" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return """"; } } else { String message = ""error""; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { // e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }"	@param path The sub-path of the HTTP URL	0	1
private HiscoreLookup getCorrectLookupFor(final ChatMessage chatMessage) { final String player; final HiscoreEndpoint ironmanStatus; if (chatMessage.getType().equals(ChatMessageType.PRIVATE_MESSAGE_SENT)) { player = client.getLocalPlayer().getName(); ironmanStatus = hiscoreEndpoint; } else { player = sanitize(chatMessage.getName()); if (player.equals(client.getLocalPlayer().getName())) { // Get ironman status from for the local player ironmanStatus = hiscoreEndpoint; } else { // Get ironman status from their icon in chat ironmanStatus = getHiscoreEndpointByName(chatMessage.getName()); } } return new HiscoreLookup(player, ironmanStatus); }	@param setMessage chat message	1	0
"private static Method getMethod(Class<?> clazz, String attributeName) { try { char string[] = attributeName.toCharArray(); string[0] = Character.toUpperCase( string[0] ); String casedAttributeName = new String( string ); try { return clazz.getDeclaredMethod( ""get"" + casedAttributeName ); } catch ( NoSuchMethodException e ) { return clazz.getDeclaredMethod( ""is"" + casedAttributeName ); } } catch ( NoSuchMethodException e ) { return null; } }"	@param clazz The class to check.	0	1
public Action resumed(AtmosphereRequest request, AtmosphereResponse response) throws IOException, ServletException { return action(request, response); }	@param request the HttpServletRequest	1	0
"public Collection<String> getCandidateEIPs(String myInstanceId, String myZone) { if (myZone == null) { myZone = ""us-east-1d""; } Collection<String> eipCandidates = (DiscoveryManager.getInstance() .getEurekaClientConfig().shouldUseDnsForFetchingServiceUrls() ? getEIPsForZoneFromDNS(myZone) : getEIPsForZoneFromConfig(myZone)); if (eipCandidates == null || eipCandidates.size() == 0) { throw new RuntimeException( ""Could not get any elastic ips from the EIP pool for zone :"" + myZone); } return eipCandidates; }"	@param myPublicIP the public ip of this instance	0	1
public IntervalConverter removeIntervalConverter(IntervalConverter converter) throws SecurityException { checkAlterIntervalConverters(); if (converter == null) { return null; } IntervalConverter[] removed = new IntervalConverter[1]; iIntervalConverters = iIntervalConverters.remove(converter, removed); return removed[0]; }	@param index the index to remove	1	0
"public Index parseAndUpdateIndex(Set<String> mappingFileNames, Index annotationIndex) { ClassLoaderService classLoaderService = meta.getServiceRegistry().getService( ClassLoaderService.class ); Set<InputStream> mappingStreams = new HashSet<InputStream>(); for ( String fileName : mappingFileNames ) { EntityMappings entityMappings; try { entityMappings = XmlHelper.unmarshallXml( fileName, ORM2_MAPPING_XSD, EntityMappings.class, classLoaderService ).getRoot(); } catch ( JAXBException orm2Exception ) { // if we cannot parse against orm_2_0.xsd we try orm_1_0.xsd for backwards compatibility try { entityMappings = XmlHelper.unmarshallXml( fileName, ORM1_MAPPING_XSD, EntityMappings.class, classLoaderService ).getRoot(); } catch ( JAXBException orm1Exception ) { throw new AnnotationException( ""Unable to parse xml configuration."", orm1Exception ); } } entityMappings.toString(); } return null; }"	@param mappings list of XMLEntityMappings created from the specified orm xml files	1	0
protected String setEscapedParameter(HttpMessage message, String param, String value) { return variant.setEscapedParameter(message, originalPair, param, value); }	@param msg	1	0
public static RuleSet getDrillUserConfigurableLogicalRules(OptimizerRulesContext optimizerRulesContext) { PlannerSettings ps = optimizerRulesContext.getPlannerSettings(); // This list is used to store rules that can be turned on an off // by user facing planning options Builder userConfigurableRules = ImmutableSet.<RelOptRule>builder(); if (ps.isConstantFoldingEnabled()) { // TODO - DRILL-2218 userConfigurableRules.add(ReduceExpressionsRule.PROJECT_INSTANCE); userConfigurableRules.add(DrillReduceExpressionsRule.FILTER_INSTANCE_DRILL); userConfigurableRules.add(DrillReduceExpressionsRule.CALC_INSTANCE_DRILL); } return new DrillRuleSet(userConfigurableRules.build()); }	@param queryContext - used to get the list of planner settings, other rules may also in the future need to get other query state from this, such as the available list of UDFs (as is used by the DrillMergeProjectRule created in getDrillBasicRules())	1	0
public ApiResponse<Void> testEndpointParametersWithHttpInfo(BigDecimal number, Double _double, String string, byte[] _byte, Integer integer, Integer int32, Long int64, Float _float, byte[] binary, Date date, Date dateTime, String password) throws ApiException { Call call = testEndpointParametersCall(number, _double, string, _byte, integer, int32, int64, _float, binary, date, dateTime, password, null, null); return apiClient.execute(call); }	@param _float None (optional)	0	1
public ArrayList filterContent(String key) { return this.of.filter(key); }	@param prefix the Filter prefix	1	0
public static DownloadQueue newDownloadQueue() { return newDownloadQueue(2); }	@param context ApplicationContext	0	1
protected RelRoot trimUnusedFields(RelRoot root) { final SqlToRelConverter converter = getSqlToRelConverter( getSqlValidator(), catalogReader); converter.setTrimUnusedFields(shouldTrim(root.rel)); final boolean ordered = !root.collation.getFieldCollations().isEmpty(); final boolean dml = SqlKind.DML.contains(root.kind); return root.withRel(converter.trimUnusedFields(dml || ordered, root.rel)); }	@param rootRel Relational expression that is at the root of the tree	1	0
public WebElement searchForWebElement(final By by, int minimumNumberOfMatches, int timeout, boolean scroll){ if(minimumNumberOfMatches < 1){ minimumNumberOfMatches = 1; } List<WebElement> viewsFromScreen = webUtils.getCurrentWebElements(by); addViewsToList (webElements, viewsFromScreen); return getViewFromList(webElements, minimumNumberOfMatches); }	@param match if multiple objects match the text, this determines which one will be clicked	1	0
public int getMaximumValue(ReadablePartial instant, int[] values) { return getMaximumValue(instant); }	@param instant the partial instant to query	0	1
"public static int readVInt(DrillBuf buffer, int start, int end) { long n = readVLong(buffer, start, end); if ((n > Integer.MAX_VALUE) || (n < Integer.MIN_VALUE)) { throw new NumberFormatException(""Value "" + n + "" too long to fit in integer""); } return (int)n; }"	@param buffer ByteBuf to read from	1	0
public Call buildCall(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException { Request request = buildRequest(path, method, queryParams, collectionQueryParams, body, headerParams, formParams, authNames, callback); return httpClient.newCall(request); }	@param collectionQueryParams The collection query parameters	0	1
public static int getTileHeight(Client client, int localX, int localY, int plane) { int sceneX = localX >> LOCAL_COORD_BITS; int sceneY = localY >> LOCAL_COORD_BITS; if (sceneX >= 0 && sceneY >= 0 && sceneX <= 103 && sceneY <= 103) { byte[][][] tileSettings = client.getTileSettings(); int[][][] tileHeights = client.getTileHeights(); int var5 = plane; if (plane < 3 && (tileSettings[1][sceneX][sceneY] & 2) == 2) { var5 = plane + 1; } int var6 = localX & 127; int var7 = localY & 127; int var8 = var6 * tileHeights[var5][sceneX + 1][sceneY] + (128 - var6) * tileHeights[var5][sceneX][sceneY] >> 7; int var9 = tileHeights[var5][sceneX][sceneY + 1] * (128 - var6) + var6 * tileHeights[var5][sceneX + 1][sceneY + 1] >> 7; return (128 - var7) * var8 + var7 * var9 >> 7; } return 0; }	@param x the ground coordinate on the x axis	1	0
public Call updatePetWithFormAsync(Long petId, String name, String status, final ApiCallback<Void> callback) throws ApiException { ProgressResponseBody.ProgressListener progressListener = null; ProgressRequestBody.ProgressRequestListener progressRequestListener = null; if (callback != null) { progressListener = new ProgressResponseBody.ProgressListener() { @Override public void update(long bytesRead, long contentLength, boolean done) { callback.onDownloadProgress(bytesRead, contentLength, done); } }; progressRequestListener = new ProgressRequestBody.ProgressRequestListener() { @Override public void onRequestProgress(long bytesWritten, long contentLength, boolean done) { callback.onUploadProgress(bytesWritten, contentLength, done); } }; } Call call = updatePetWithFormCall(petId, name, status, progressListener, progressRequestListener); apiClient.executeAsync(call, callback); return call; }	@param status Updated status of the pet (optional)	0	1
"protected long copyCollection(CollectionId collectionId, Instant timestamp) throws InterruptedException { AtomicLong docCount = new AtomicLong(); primaryClient.executeBlocking(""sync '"" + collectionId + ""'"", primary -> { docCount.set(copyCollection(primary, collectionId, timestamp)); }); return docCount.get(); }"	@param collectionId the identifier of the collection to be copied; may not be null	0	1
public static int numberOfLeadingZeros(long lng) { lng |= lng >> 1; lng |= lng >> 2; lng |= lng >> 4; lng |= lng >> 8; lng |= lng >> 16; lng |= lng >> 32; return bitCount(~lng); }	@param v the long to examine.	1	0
"public List<String> dependencyPathBetween(int start, int end, Optional<Function<Sentence, List<String>>> selector) { // Get paths from a node to the root of the sentence LinkedList<Integer> rootToStart = new LinkedList<>(); LinkedList<Integer> rootToEnd = new LinkedList<>(); int startAncestor = start; List<Optional<Integer>> governors = sentence.governors(); Set<Integer> seenVertices = new HashSet<>(); while (startAncestor >= 0 && governors.get(startAncestor).isPresent()) { if (seenVertices.contains(startAncestor)) { // Found loopiness -- revert to BFS return loopyDependencyPathBetween(start, end, selector); } seenVertices.add(startAncestor); rootToStart.addFirst(startAncestor); startAncestor = governors.get(startAncestor).get(); } if (startAncestor == -1) { rootToStart.addFirst(-1); } int endAncestor = end; seenVertices.clear(); while (endAncestor >= 0 && governors.get(endAncestor).isPresent()) { if (seenVertices.contains(endAncestor)) { // Found loopiness -- revert to BFS return loopyDependencyPathBetween(start, end, selector); } seenVertices.add(endAncestor); rootToEnd.addFirst(endAncestor); endAncestor = governors.get(endAncestor).get(); } if (endAncestor == -1) { rootToEnd.addFirst(-1); } // Get least common node int leastCommonNodeIndex = (rootToStart.size() == 0 || rootToEnd.size() == 0 || !rootToStart.get(0).equals(rootToEnd.get(0))) ? -1 : 0; for (int i = 1; i < Math.min(rootToStart.size(), rootToEnd.size()); ++i) { if (rootToStart.get(i).equals(rootToEnd.get(i))) { leastCommonNodeIndex = i; } } // Construct the path if (leastCommonNodeIndex < 0) { return Collections.emptyList(); } List<String> path = new ArrayList<>(); Optional<List<String>> words = selector.map(x -> x.apply(sentence)); for (int i = rootToStart.size() - 1; i > leastCommonNodeIndex; --i) { final int index = i; words.ifPresent(x -> path.add(x.get(rootToStart.get(index)))); path.add(""<-"" + sentence.incomingDependencyLabel(rootToStart.get(i)).orElse(""dep"") + ""-""); } if (words.isPresent()) { path.add(words.get().get(rootToStart.get(leastCommonNodeIndex))); } for (int i = leastCommonNodeIndex + 1; i < rootToEnd.size(); ++i) { final int index = i; path.add(""-"" + sentence.incomingDependencyLabel(rootToEnd.get(i)).orElse(""dep"") + ""->""); words.ifPresent(x -> path.add(x.get(rootToEnd.get(index)))); } return path; }"	@param span The span of the sentence to find the mode element in. This must be entirely contained in the sentence.	1	0
public static Point getCanvasImageLocation(Client client, Graphics2D graphics, LocalPoint localLocation, BufferedImage image, int zOffset) { int plane = client.getPlane(); Point p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset); if (p == null) { return null; } int xOffset = p.getX() - image.getWidth() / 2; int yOffset = p.getY() - image.getHeight() / 2; return new Point(xOffset, yOffset); }	@param graphics	0	1
"public int[] add(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { if (valueToAdd == 0) { return values; } // there are more efficient algorithms than this (especially for time only fields) // trouble is when dealing with days and months, so we use this technique of // adding/removing one from the larger field at a time DateTimeField nextField = null; while (valueToAdd > 0) { int max = getMaximumValue(instant, values); long proposed = values[fieldIndex] + valueToAdd; if (proposed <= max) { values[fieldIndex] = (int) proposed; break; } if (nextField == null) { if (fieldIndex == 0) { throw new IllegalArgumentException(""Maximum value exceeded for add""); } nextField = instant.getField(fieldIndex - 1); if (getRangeDurationField() != nextField.getDurationField()) { throw new IllegalArgumentException(""Fields invalid for add""); } } valueToAdd -= (max + 1) - values[fieldIndex]; values = nextField.add(instant, fieldIndex - 1, values, 1); values[fieldIndex] = getMinimumValue(instant, values); } while (valueToAdd < 0) { int min = getMinimumValue(instant, values); long proposed = values[fieldIndex] + valueToAdd; if (proposed >= min) { values[fieldIndex] = (int) proposed; break; } if (nextField == null) { if (fieldIndex == 0) { throw new IllegalArgumentException(""Maximum value exceeded for add""); } nextField = instant.getField(fieldIndex - 1); if (getRangeDurationField() != nextField.getDurationField()) { throw new IllegalArgumentException(""Fields invalid for add""); } } valueToAdd -= (min - 1) - values[fieldIndex]; values = nextField.add(instant, fieldIndex - 1, values, -1); values[fieldIndex] = getMaximumValue(instant, values); } return set(instant, fieldIndex, values, values[fieldIndex]); // adjusts smaller fields }"	@param values the values of the partial instant which should be updated	0	1
"private boolean searchForToggleButton(String regex, int matches) { sleeper.sleep(); inst.waitForIdleSync(); Pattern p = Pattern.compile(regex); Matcher matcher; ArrayList<ToggleButton> toggleButtonList = viewFetcher.getCurrentViews(ToggleButton.class); if(matches == 0) matches = 1; for(ToggleButton toggleButton : toggleButtonList){ matcher = p.matcher(toggleButton.getText().toString()); if(matcher.find()){ countMatches++; } if (countMatches == matches) { countMatches=0; return true; } } if (scroller.scroll(Scroller.Direction.DOWN)) { return searchForToggleButton(regex, matches); } else { if(countMatches > 0) Log.d(LOG_TAG, "" There are only "" + countMatches + "" matches of "" + regex); countMatches = 0; return false; } }"	@param search the string to be searched. The parameter will be interpreted as a regular expression.	1	0
"public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); for(String key : queryParams.keySet()) { String value = queryParams.get(key); if (value != null){ if(b.toString().length() == 0) b.append(""?""); else b.append(""&""); b.append(escapeString(key)).append(""="").append(escapeString(value)); } } String querystring = b.toString(); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(""GET"".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (""POST"".equals(method)) { if (contentType.startsWith(""application/x-www-form-urlencoded"")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (""PUT"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (""DELETE"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, ""unknown method type "" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return """"; } } else { String message = ""error""; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { // e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }"	"@param method The request method, one of ""GET"", ""POST"", ""PUT"", and ""DELETE"""	0	1
public int get(long instant) { // Get an initial estimate of the year, and the millis value that // represents the start of that year. Then verify estimate and fix if // necessary. int year; long unitMillis = getDurationUnitMillis(); if (instant >= 0) { year = 1970 + (int) (instant / unitMillis); } else { year = 1970 + (int) ((instant - unitMillis + 1) / unitMillis); } long yearStart = iChronology.getYearMillis(year); if ((yearStart ^ instant) < 0) { // Sign mismatch, operation overflowed. return getOverflow(instant); } long diff = instant - yearStart; if (diff < 0) { // Subtract one year to fix estimate. year--; } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) { // One year may need to be added to fix estimate. long oneYear; if (iChronology.isLeapYear(year)) { oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L; } else { oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L; } yearStart += oneYear; if ((yearStart ^ instant) < 0) { // Sign mismatch, operation overflowed. return getOverflow(instant); } if (yearStart <= instant) { // Didn't go too far, so actually add one year. year++; } } return year; }	@param millis the time instant in millis to query.	1	0
public int delete(Object[] row, Instant ts) throws InterruptedException { return delete(row, ts, 0, 1); }	@param ts the timestamp for this row	0	1
public Query createQuery(Expr<?>[] args){ queryMixin.addToProjection(args); String queryString = toString(); logQuery(queryString); return createQuery(queryString, queryMixin.getMetadata().getModifiers()); }	@param expr	1	0
long getLoad(MigratableHandler handler) { return handlerLoadCounter.get(handler); }	@param pipeline	1	0
private boolean hasSingleValue(ColumnStatistics columnStatistics, long rowCount) { return columnStatistics != null && isSingleVal(columnStatistics, rowCount); }	@param rowCount rows count in column chunk	0	1
private boolean isAncestorOf(Object object1, Object object2) { if (object2 == null) return false; Object parent = getParent(object2); if (parent == object1) return true; return isAncestorOf(object1, parent); }	@param target The target node.	1	0
protected int writeImportList(PrintWriter out, List<String> imports) { return writeImportList(out, (String[]) imports.toArray(new String[0])); }	@param codeFolderImports	0	1
"public OuterComposite fakeOuterCompositeSerialize(OuterComposite body) throws ApiException { Object localVarPostBody = body; // create path and map variables String localVarPath = ""/fake/outer/composite""; // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { ""*/*"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<OuterComposite> localVarReturnType = new GenericType<OuterComposite>() {}; return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	@param outerComposite Input composite as post body (optional)	1	0
public static GrammaticalRelation valueOf(String s, Collection<GrammaticalRelation> values, Lock readValuesLock) { readValuesLock.lock(); try { for (GrammaticalRelation reln : values) { if (reln.toString().equals(s)) return reln; } } finally { readValuesLock.unlock(); } return null; }	@param values The set of GrammaticalRelations to look for it among.	0	1
"public ApiResponse<Order> placeOrderWithHttpInfo(Order order) throws ApiException { Object localVarPostBody = order; // verify the required parameter 'order' is set if (order == null) { throw new ApiException(400, ""Missing the required parameter 'order' when calling placeOrder""); } // create path and map variables String localVarPath = ""/store/order""; // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { ""application/xml"", ""application/json"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Order> localVarReturnType = new GenericType<Order>() {}; return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	@param body order placed for purchasing the pet (required)	1	0
public boolean onExpandStart(CommonCardView viewCard) { Card card = viewCard.getCard(); if (card!=null){ String itemId = card.getId(); if (!mExpandedIds.contains(itemId)) { return true; } } return false; }	@param viewCard	0	1
"public String invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); b.append(""?""); if (queryParams != null){ for (Pair queryParam : queryParams){ if (!queryParam.getName().isEmpty()) { b.append(escapeString(queryParam.getName())); b.append(""=""); b.append(escapeString(queryParam.getValue())); b.append(""&""); } } } String querystring = b.substring(0, b.length() - 1); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(""GET"".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (""POST"".equals(method)) { if (contentType.startsWith(""application/x-www-form-urlencoded"")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (""PUT"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (""DELETE"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, ""unknown method type "" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return """"; } } else { String message = ""error""; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { // e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }"	@param contentType The request's Content-Type header	0	1
"static OptiqConnection getConnection(SchemaSpec schemaSpec) throws ClassNotFoundException, SQLException { Class.forName(""net.hydromatic.optiq.jdbc.Driver""); Connection connection = DriverManager.getConnection(""jdbc:optiq:""); OptiqConnection optiqConnection = connection.unwrap(OptiqConnection.class); final SchemaPlus rootSchema = optiqConnection.getRootSchema(); switch (schemaSpec) { case JDBC_FOODMART: addSchema(rootSchema, schemaSpec); break; case CLONE_FOODMART: case JDBC_FOODMART_WITH_LATTICE: addSchema(rootSchema, SchemaSpec.JDBC_FOODMART); addSchema(rootSchema, schemaSpec); break; default: throw new AssertionError(""unknown schema "" + schemaSpec); } optiqConnection.setSchema(""foodmart2""); return optiqConnection; }"	"@param withClone Whether to create a ""foodmart2"" schema as in-memory clone"	1	0
public boolean scrollList(int listIndex, Direction direction, ArrayList<ListView> listViews) { int[] xy = new int[2]; final ListView listView = getView(ListView.class, listViews, listIndex); listView.getLocationOnScreen(xy); while (xy[1] + 20 > activityUtils.getCurrentActivity(false) .getWindowManager().getDefaultDisplay().getHeight()) { scrollScrollView(direction, null); listView.getLocationOnScreen(xy); } if (direction == Direction.DOWN) { if (listView.getLastVisiblePosition() >= listView.getCount() - 1) return false; scrollListToLine(listView, listView.getLastVisiblePosition()+1); } else if (direction == Direction.UP) { if (listView.getFirstVisiblePosition() < 2) return false; final int lines = (listView.getLastVisiblePosition()+1)-(listView.getFirstVisiblePosition()); int lineToScrollTo = listView.getFirstVisiblePosition() - lines; if(lineToScrollTo < 0) lineToScrollTo=0; scrollListToLine(listView, lineToScrollTo); } sleeper.sleep(); return true; }	@param direction the direction to be scrolled	0	1
public static BooleanExpression fuzzyLike(Path<String> path, String value, int maxEdits) { Term term = new Term(path.getMetadata().getName(), value); return new QueryElement(new FuzzyQuery(term, maxEdits)); }	@param minimumSimilarity	1	0
public boolean getInitParameter(String key, boolean defaultValue) { String s = getInitParameter(key); if (s == null) { return defaultValue; } return Boolean.valueOf(s); }	@param defaultValue	0	1
public int get(long instant) { // 1970-01-01 is day of week 4, Thursday. long daysSince19700101; if (instant >= 0) { daysSince19700101 = instant / DateTimeConstants.MILLIS_PER_DAY; } else { daysSince19700101 = (instant - (DateTimeConstants.MILLIS_PER_DAY - 1)) / DateTimeConstants.MILLIS_PER_DAY; if (daysSince19700101 < -3) { return 7 + (int) ((daysSince19700101 + 4) % 7); } } return 1 + (int) ((daysSince19700101 + 3) % 7); }	@param millis the time instant in millis to query	1	0
"public void updatePetWithForm (Long petId, String name, String status) throws TimeoutException, ExecutionException, InterruptedException, ApiException { Object postBody = null; // verify the required parameter 'petId' is set if (petId == null) { VolleyError error = new VolleyError(""Missing the required parameter 'petId' when calling updatePetWithForm"", new ApiException(400, ""Missing the required parameter 'petId' when calling updatePetWithForm"")); } // create path and map variables String path = ""/pet/{petId}"".replaceAll(""\\{"" + ""petId"" + ""\\}"", apiInvoker.escapeString(petId.toString())); // query params List<Pair> queryParams = new ArrayList<Pair>(); // header params Map<String, String> headerParams = new HashMap<String, String>(); // form params Map<String, String> formParams = new HashMap<String, String>(); String[] contentTypes = { ""application/x-www-form-urlencoded"" }; String contentType = contentTypes.length > 0 ? contentTypes[0] : ""application/json""; if (contentType.startsWith(""multipart/form-data"")) { // file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); if (name != null) { localVarBuilder.addTextBody(""name"", ApiInvoker.parameterToString(name), ApiInvoker.TEXT_PLAIN_UTF8); } if (status != null) { localVarBuilder.addTextBody(""status"", ApiInvoker.parameterToString(status), ApiInvoker.TEXT_PLAIN_UTF8); } HttpEntity httpEntity = localVarBuilder.build(); postBody = httpEntity; } else { // normal form params formParams.put(""name"", ApiInvoker.parameterToString(name)); formParams.put(""status"", ApiInvoker.parameterToString(status)); } String[] authNames = new String[] { ""petstore_auth"" }; try { String localVarResponse = apiInvoker.invokeAPI (basePath, path, ""POST"", queryParams, postBody, headerParams, formParams, contentType, authNames); if (localVarResponse != null) { return ; } else { return ; } } catch (ApiException ex) { throw ex; } catch (InterruptedException ex) { throw ex; } catch (ExecutionException ex) { if (ex.getCause() instanceof VolleyError) { VolleyError volleyError = (VolleyError)ex.getCause(); if (volleyError.networkResponse != null) { throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage()); } } throw ex; } catch (TimeoutException ex) { throw ex; } }"	@param name Updated name of the pet	0	1
public static EBoolean endsWith(Expr<String> left, Expr<String> right) { return operationFactory.createBoolean(Ops.ENDSWITH, left, right); }	@param right	0	1
public float distanceTo(float x, float y, float z) { final float a = this.x - x; final float b = this.y - y; final float c = this.z - z; return (float) Math.sqrt(a * a + b * b + c * c); }	@param double z The point z coordinate.	1	0
public int bind(PreparedStatement statement, QueryParameters qp, SharedSessionContractImplementor session, int position) throws SQLException { Type type = qp.getPositionalParameterTypes()[hqlPosition]; Object value = qp.getPositionalParameterValues()[hqlPosition]; type.nullSafeSet( statement, value, position, session ); return type.getColumnSpan( session.getFactory() ); }	@param position The position from which to start binding value(s).	0	1
public Object buildResultRow(Object[] data, ResultSet resultSet, boolean hasTransformer, SharedSessionContractImplementor session) throws SQLException, HibernateException { final Object[] resultRow = buildResultRow( data, resultSet, session ); if ( hasTransformer ) { return resultRow; } else { return resultRow.length == 1 ? resultRow[0] : resultRow; } }	@param hasTransformer Does this query have an associated org.hibernate.transform.ResultTransformer	0	1
private ScanProgressActionIcon getScanProgressAction(Point point) { int column = table.columnAtPoint(point); if (column == NOT_FOUND) { return null; } int row = table.rowAtPoint(point); if (row == NOT_FOUND) { return null; } Object value = table.getValueAt(row, column); if (value instanceof ScanProgressActionIcon) { return (ScanProgressActionIcon)value; } return null; }	@param e	1	0
static public IStructuredTextExpert getStatefulExpert(StructuredTextTypeHandler handler, StructuredTextEnvironment environment) { if (environment == null) environment = StructuredTextEnvironment.DEFAULT; return new StructuredTextImpl(handler, environment, true); }	@param handler the type handler instance. It may have been obtained using STextTypeHandlerFactory#getHandler(String) or by instantiating a type handler.	1	0
public static Point getCanvasSpriteLocation(Client client, Graphics2D graphics, LocalPoint localLocation, SpritePixels sprite, int zOffset) { int plane = client.getPlane(); Point p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset); if (p == null) { return null; } int xOffset = p.getX() - sprite.getWidth() / 2; int yOffset = p.getY() - sprite.getHeight() / 2; return new Point(xOffset, yOffset); }	@param client	0	1
"public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); final String url = buildUrl(path, queryParams); final Request.Builder reqBuilder = new Request.Builder().url(url); processHeaderParams(headerParams, reqBuilder); String contentType = (String) headerParams.get(""Content-Type""); // ensuring a default content type if (contentType == null) contentType = ""application/json""; RequestBody reqBody; if (!HttpMethod.permitsRequestBody(method)) { reqBody = null; } else if (""application/x-www-form-urlencoded"".equals(contentType)) { reqBody = buildRequestBodyFormEncoding(formParams); } else if (""multipart/form-data"".equals(contentType)) { reqBody = buildRequestBodyMultipart(formParams); } else if (body == null) { if (""DELETE"".equals(method)) { // allow calling DELETE without sending a request body reqBody = null; } else { // use an empty request body (for POST, PUT and PATCH) reqBody = RequestBody.create(MediaType.parse(contentType), """"); } } else { reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType)); } Request request = reqBuilder.method(method, reqBody).build(); return httpClient.newCall(request); }"	@param formParams The form parameters	0	1
"public String invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); b.append(""?""); if (queryParams != null){ for (Pair queryParam : queryParams){ if (!queryParam.getName().isEmpty()) { b.append(escapeString(queryParam.getName())); b.append(""=""); b.append(escapeString(queryParam.getValue())); b.append(""&""); } } } String querystring = b.substring(0, b.length() - 1); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(""GET"".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (""POST"".equals(method)) { if (contentType.startsWith(""application/x-www-form-urlencoded"")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (""PUT"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (""DELETE"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, ""unknown method type "" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return """"; } } else { String message = ""error""; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { // e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }"	@param authNames The authentications to apply	0	1
"public Action timedout(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException { logger.trace(""Timing out {}"", req); if (trackActiveRequest(req) && completeLifecycle(req.resource(), false)) { config.framework().notify(Action.TYPE.TIMEOUT, req, res); } return timedoutAction; }"	@param request the AtmosphereRequest	1	0
"public static UserAuthenticator createAuthenticator(final DrillConfig config, ScanResult scan) throws DrillbitStartupException { final String authImplConfigured = config.getString(USER_AUTHENTICATOR_IMPL); if (Strings.isNullOrEmpty(authImplConfigured)) { throw new DrillbitStartupException(String.format(""Invalid value '%s' for BOOT option '%s'"", authImplConfigured, USER_AUTHENTICATOR_IMPL)); } final Collection<Class<? extends UserAuthenticator>> authImpls = scan.getImplementations(UserAuthenticator.class); for(Class<? extends UserAuthenticator> clazz : authImpls) { final UserAuthenticatorTemplate template = clazz.getAnnotation(UserAuthenticatorTemplate.class); if (template == null) { logger.warn(""{} doesn't have {} annotation. Skipping."", clazz.getCanonicalName(), UserAuthenticatorTemplate.class); continue; } if (Strings.isNullOrEmpty(template.type())) { logger.warn(""{} annotation doesn't have valid type field for UserAuthenticator implementation {}. Skipping.."", UserAuthenticatorTemplate.class, clazz.getCanonicalName()); continue; } if (template.type().equalsIgnoreCase(authImplConfigured)) { Constructor<?> validConstructor = null; for (Constructor<?> c : clazz.getConstructors()) { if (c.getParameterTypes().length == 0) { validConstructor = c; break; } } if (validConstructor == null) { logger.warn(""Skipping UserAuthenticator implementation class '{}' since it doesn't "" + ""implement a constructor [{}()]"", clazz.getCanonicalName(), clazz.getName()); continue; } // Instantiate authenticator and initialize it try { final UserAuthenticator authenticator = clazz.newInstance(); authenticator.setup(config); return authenticator; } catch(IllegalArgumentException | IllegalAccessException | InstantiationException e) { throw new DrillbitStartupException( String.format(""Failed to create and initialize the UserAuthenticator class '%s'"", clazz.getCanonicalName()), e); } } } String errMsg = String.format(""Failed to find the implementation of '%s' for type '%s'"", UserAuthenticator.class.getCanonicalName(), authImplConfigured); logger.error(errMsg); throw new DrillbitStartupException(errMsg); }"	@param config DrillConfig containing BOOT options.	0	1
private RexProgram createProgram(Filter filterRel) { RexProgramBuilder programBuilder = new RexProgramBuilder( filterRel.getRowType(), filterRel.getCluster().getRexBuilder()); programBuilder.addIdentity(); programBuilder.addCondition(filterRel.getCondition()); return programBuilder.getProgram(); }	@param filterRel the FilterRel	1	0
"public OuterComposite fakeOuterCompositeSerialize(OuterComposite body) throws RestClientException { Object postBody = body; String path = UriComponentsBuilder.fromPath(""/fake/outer/composite"").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { ""*/*"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<OuterComposite> returnType = new ParameterizedTypeReference<OuterComposite>() {}; return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }"	@param outerComposite Input composite as post body	1	0
"public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws ApiException { Object localVarPostBody = null; // verify the required parameter 'petId' is set if (petId == null) { throw new ApiException(400, ""Missing the required parameter 'petId' when calling uploadFileWithRequiredFile""); } // verify the required parameter 'requiredFile' is set if (requiredFile == null) { throw new ApiException(400, ""Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile""); } // create path and map variables String localVarPath = ""/fake/{petId}/uploadImageWithRequiredFile"" .replaceAll(""\\{"" + ""petId"" + ""\\}"", apiClient.escapeString(petId.toString())); // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); if (additionalMetadata != null) localVarFormParams.put(""additionalMetadata"", additionalMetadata); if (requiredFile != null) localVarFormParams.put(""requiredFile"", requiredFile); final String[] localVarAccepts = { ""application/json"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { ""multipart/form-data"" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { ""petstore_auth"" }; GenericType<ModelApiResponse> localVarReturnType = new GenericType<ModelApiResponse>() {}; return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	@param petId ID of pet to update (required)	0	1
private static String findValidPath(EnvVar... vars) { for (EnvVar var : vars) { String path; if (var.mIsSysProp) { path = checkPath(System.getProperty(var.mName)); if (path != null) { return path; } } if (var.mIsEnvVar) { path = checkPath(System.getenv(var.mName)); if (path != null) { return path; } } } return null; }	@param names	1	0
"public OuterComposite fakeOuterCompositeSerialize(OuterComposite outerComposite) throws ApiException { Object localVarPostBody = outerComposite; // create path and map variables String localVarPath = ""/fake/outer/composite"".replaceAll(""\\{format\\}"",""json""); // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { ""*/*"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<OuterComposite> localVarReturnType = new GenericType<OuterComposite>() {}; return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	@param body Input composite as post body (optional)	1	0
"public Client call123testSpecialTags(Client body) throws RestClientException { Object postBody = body; // verify the required parameter 'body' is set if (body == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'body' when calling call123testSpecialTags""); } String path = UriComponentsBuilder.fromPath(""/another-fake/dummy"").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { ""application/json"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { ""application/json"" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {}; return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }"	@param client client model	1	0
"public List<TypedDependency> typedDependenciesCCprocessed(boolean includeExtras) { List<TypedDependency> tdl = typedDependencies(false); // Adds stuff to the basic dependencies. // We don't want to simply call typedDependencies with // ""includeExtras"" because the collapseDependencies method may add // the extras in a way that makes more logical sense. For // example, the English dependencies, when CC processed, have more // nsubjs than they originally do. If we wait until that occurs // to add xsubj for xcomp dependencies, we get better coverage. if (includeExtras) { getTreeDeps(root(), tdl, new NoPunctTypedDependencyFilter(puncFilter)); } collapseDependencies(tdl, true, includeExtras); return tdl; }"	"@param includeExtras If true, the list of typed dependencies returned may include ""extras"", such as controlled subject links."	0	1
"public void updateUser (String username, User user) throws ApiException { Object localVarPostBody = user; // verify the required parameter 'username' is set if (username == null) { throw new ApiException(400, ""Missing the required parameter 'username' when calling updateUser""); } // verify the required parameter 'user' is set if (user == null) { throw new ApiException(400, ""Missing the required parameter 'user' when calling updateUser""); } // create path and map variables String localVarPath = ""/user/{username}"".replaceAll(""\\{format\\}"",""json"").replaceAll(""\\{"" + ""username"" + ""\\}"", apiInvoker.escapeString(username.toString())); // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); // header params Map<String, String> localVarHeaderParams = new HashMap<String, String>(); // form params Map<String, String> localVarFormParams = new HashMap<String, String>(); String[] localVarContentTypes = { ""application/json"" }; String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : ""application/json""; if (localVarContentType.startsWith(""multipart/form-data"")) { // file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); localVarPostBody = localVarBuilder.build(); } else { // normal form params } try { String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, ""PUT"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType); if(localVarResponse != null){ return ; } else { return ; } } catch (ApiException ex) { throw ex; } }"	@param body Updated user object	1	0
"public void updatePet (Pet pet) throws ApiException { Object localVarPostBody = pet; // verify the required parameter 'pet' is set if (pet == null) { throw new ApiException(400, ""Missing the required parameter 'pet' when calling updatePet""); } // create path and map variables String localVarPath = ""/pet"".replaceAll(""\\{format\\}"",""json""); // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); // header params Map<String, String> localVarHeaderParams = new HashMap<String, String>(); // form params Map<String, String> localVarFormParams = new HashMap<String, String>(); String[] localVarContentTypes = { }; String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : ""application/json""; if (localVarContentType.startsWith(""multipart/form-data"")) { // file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); localVarPostBody = localVarBuilder.build(); } else { // normal form params } try { String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, ""PUT"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType); if(localVarResponse != null){ return ; } else { return ; } } catch (ApiException ex) { throw ex; } }"	@param body Pet object that needs to be added to the store	1	0
public PendingMessageCursor getSubscriberPendingMessageCursor(String clientId, String name, Store tmpStorage, int maxBatchSize, Subscription sub) { return new VMPendingMessageCursor(); }	@param maxBatchSize	0	1
public WebElement searchForWebElement(final By by, int minimumNumberOfMatches, int timeout, boolean scroll){ if(minimumNumberOfMatches < 1){ minimumNumberOfMatches = 1; } List<WebElement> viewsFromScreen = webUtils.getCurrentWebElements(by); addViewsToList (webElements, viewsFromScreen); return getViewFromList(webElements, minimumNumberOfMatches); }	@param scroll true if scrolling should be performed	0	1
"public boolean isASGEnabled(InstanceInfo instanceInfo) { CacheKey cacheKey = new CacheKey(getAccountId(instanceInfo, accountId), instanceInfo.getASGName()); asgCache.refresh(cacheKey); Boolean result = asgCache.getIfPresent(cacheKey); if (result != null) { return result; } else { logger.warn(""Cache value for asg {} does not exist yet"", cacheKey.asgName); return true; } }"	@param asgName - The name of the ASG	1	0
public boolean determineSize(long recordsReadInCurrentPass) throws IOException { if (readPage()) { return true; } if (processPageData((int) recordsReadInCurrentPass)) { return true; } return checkVectorCapacityReached(); }	@param recordsReadInCurrentPass	0	1
public int delete(Object[] row, Instant ts, int rowNumber, int numberOfRows) throws InterruptedException { return converter.delete(source, row, rowNumber, numberOfRows, includedColumns, ts, consumer); }	@param ts the timestamp for this row	0	1
"public Request buildRequest(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); final String url = buildUrl(path, queryParams, collectionQueryParams); final Request.Builder reqBuilder = new Request.Builder().url(url); processHeaderParams(headerParams, reqBuilder); String contentType = (String) headerParams.get(""Content-Type""); // ensuring a default content type if (contentType == null) { contentType = ""application/json""; } RequestBody reqBody; if (!HttpMethod.permitsRequestBody(method)) { reqBody = null; } else if (""application/x-www-form-urlencoded"".equals(contentType)) { reqBody = buildRequestBodyFormEncoding(formParams); } else if (""multipart/form-data"".equals(contentType)) { reqBody = buildRequestBodyMultipart(formParams); } else if (body == null) { if (""DELETE"".equals(method)) { // allow calling DELETE without sending a request body reqBody = null; } else { // use an empty request body (for POST, PUT and PATCH) reqBody = RequestBody.create(MediaType.parse(contentType), """"); } } else { reqBody = serialize(body, contentType); } // Associate callback with request (if not null) so interceptor can // access it when creating ProgressResponseBody reqBuilder.tag(callback); Request request = null; if (callback != null && reqBody != null) { ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, callback); request = reqBuilder.method(method, progressRequestBody).build(); } else { request = reqBuilder.method(method, reqBody).build(); } return request; }"	@param progressRequestListener Progress request listener	1	0
protected SourceInfo update(Long lsn, Instant commitTime, Long txId, TableId tableId) { this.lsn = lsn; this.useconds = Conversions.toEpochMicros(commitTime); this.txId = txId; if (tableId != null && tableId.schema() != null) { this.schemaName = tableId.schema(); } if (tableId != null && tableId.table() != null) { this.tableName = tableId.table(); } return this; }	@param lsn the position in the server WAL for a particular event; may be null indicating that this information is not available	0	1
"public boolean applyAPSRequest(APSResult request, Callback callback) { PumpInterface pump = getActivePump(); request.rate = applyBasalConstraints(request.rate); PumpEnactResult result; if (!pump.isInitialized()) { log.debug(""applyAPSRequest: "" + MainApp.sResources.getString(R.string.pumpNotInitialized)); if (callback != null) { callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpNotInitialized)).enacted(false).success(false)).run(); } return false; } if (pump.isSuspended()) { log.debug(""applyAPSRequest: "" + MainApp.sResources.getString(R.string.pumpsuspended)); if (callback != null) { callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpsuspended)).enacted(false).success(false)).run(); } return false; } if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: "" + request.toString()); if ((request.rate == 0 && request.duration == 0) || Math.abs(request.rate - pump.getBaseBasalRate()) < pump.getPumpDescription().basalStep) { if (isTempBasalInProgress()) { if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: cancelTempBasal()""); getCommandQueue().cancelTempBasal(false, callback); return true; } else { if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: Basal set correctly""); if (callback != null) { callback.result(new PumpEnactResult().absolute(request.rate).duration(0).enacted(false).success(true).comment(""Basal set correctly"")).run(); } return false; } } else if (isTempBasalInProgress() && Math.abs(request.rate - getTempBasalAbsoluteRateHistory()) < pump.getPumpDescription().basalStep) { if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: Temp basal set correctly""); if (callback != null) { callback.result(new PumpEnactResult().absolute(getTempBasalAbsoluteRateHistory()).duration(getTempBasalFromHistory(System.currentTimeMillis()).getPlannedRemainingMinutes()).enacted(false).success(true).comment(""Temp basal set correctly"")).run(); } return false; } else { if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: setTempBasalAbsolute()""); getCommandQueue().tempBasalAbsolute(request.rate, request.duration, false, callback); return true; } }"	@param request	0	1
public Struct delete(Object before, Struct source, Instant timestamp) { Struct struct = new Struct(schema); struct.put(FieldName.OPERATION, Operation.DELETE.code()); if (before != null) { struct.put(FieldName.BEFORE, before); } if (source != null) { struct.put(FieldName.SOURCE, source); } if (timestamp != null) { struct.put(FieldName.TIMESTAMP, timestamp.toEpochMilli()); } return struct; }	@param timestamp the timestamp for this message; may be null	0	1
public static GrammaticalRelation valueOf(String s, Collection<GrammaticalRelation> values) { for (GrammaticalRelation reln : values) { if (reln.toString().equals(s)) return reln; } return null; }	@param map The map from string to GrammaticalRelation	1	0
public static boolean canEdit(Permissions perms, Permissions user2Perms) { if(isAdmin(perms)) return true; if(isAdmin(user2Perms)) return false; return getManagementLevel(perms) > getManagementLevel(user2Perms); }	@param toEdit The user to be edited	1	0
public List<String> generateCreationCommands(Metadata metadata, boolean createNamespaces, Dialect dialect) { final ArrayList<String> commands = new ArrayList<String>(); doCreation( metadata, createNamespaces, dialect, new Target() { @Override public boolean acceptsImportScriptActions() { return true; } @Override public void prepare() { } @Override public void accept(String action) { commands.add( action ); } @Override public void release() { } } ); return commands; }	@param dialect Allow explicitly passing the Dialect to use.	0	1
private RexProgram createProgram(Filter filterRel) { RexProgramBuilder programBuilder = new RexProgramBuilder( filterRel.getRowType(), filterRel.getCluster().getRexBuilder()); programBuilder.addIdentity(); programBuilder.addCondition(filterRel.getCondition()); return programBuilder.getProgram(); }	@param filterRel the FilterRel	1	0
protected void coordinateSharedCacheCleanup(SharedSessionContractImplementor session) { final BulkOperationCleanupAction action = new BulkOperationCleanupAction( session, getCustomQuery().getQuerySpaces() ); if ( session.isEventSource() ) { ( (EventSource) session ).getActionQueue().addAction( action ); } else { action.getAfterTransactionCompletionProcess().doAfterTransactionCompletion( true, session ); } }	@param ps The prepared statement to which to bind the parameter values.	0	1
"public void createUser (User user) throws TimeoutException, ExecutionException, InterruptedException, ApiException { Object postBody = user; // verify the required parameter 'user' is set if (user == null) { VolleyError error = new VolleyError(""Missing the required parameter 'user' when calling createUser"", new ApiException(400, ""Missing the required parameter 'user' when calling createUser"")); } // create path and map variables String path = ""/user""; // query params List<Pair> queryParams = new ArrayList<Pair>(); // header params Map<String, String> headerParams = new HashMap<String, String>(); // form params Map<String, String> formParams = new HashMap<String, String>(); String[] contentTypes = { ""application/json"" }; String contentType = contentTypes.length > 0 ? contentTypes[0] : ""application/json""; if (contentType.startsWith(""multipart/form-data"")) { // file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); HttpEntity httpEntity = localVarBuilder.build(); postBody = httpEntity; } else { // normal form params } String[] authNames = new String[] { }; try { String localVarResponse = apiInvoker.invokeAPI (basePath, path, ""POST"", queryParams, postBody, headerParams, formParams, contentType, authNames); if (localVarResponse != null) { return ; } else { return ; } } catch (ApiException ex) { throw ex; } catch (InterruptedException ex) { throw ex; } catch (ExecutionException ex) { if (ex.getCause() instanceof VolleyError) { VolleyError volleyError = (VolleyError)ex.getCause(); if (volleyError.networkResponse != null) { throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage()); } } throw ex; } catch (TimeoutException ex) { throw ex; } }"	@param body Created user object	1	0
"public CalciteSchema createSnapshot(SchemaVersion version) { Preconditions.checkArgument(this.isRoot(), ""must be root schema""); return snapshot(null, version); }"	@param now The current time in millis, as returned by System#currentTimeMillis()	1	0
"public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws RestClientException { Object postBody = new Object(); // verify the required parameter 'petId' is set if (petId == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'petId' when calling uploadFileWithRequiredFile""); } // verify the required parameter 'requiredFile' is set if (requiredFile == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile""); } // create path and map variables final Map<String, Object> uriVariables = new HashMap<String, Object>(); uriVariables.put(""petId"", petId); String path = UriComponentsBuilder.fromPath(""/fake/{petId}/uploadImageWithRequiredFile"").buildAndExpand(uriVariables).toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); if (additionalMetadata != null) formParams.add(""additionalMetadata"", additionalMetadata); if (requiredFile != null) formParams.add(""requiredFile"", new FileSystemResource(requiredFile)); final String[] accepts = { ""application/json"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { ""multipart/form-data"" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { ""petstore_auth"" }; ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {}; return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }"	@param petId ID of pet to update	0	1
public Call buildCall(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException { Request request = buildRequest(path, method, queryParams, collectionQueryParams, body, headerParams, formParams, authNames, callback); return httpClient.newCall(request); }	@param progressRequestListener Progress request listener	1	0
private List<SourceLocation> createAbsoluteLocations(GraphQLError relativeError, MergedFields fields) { Optional<SourceLocation> baseLocation = Optional.ofNullable(fields.getSingleField().getSourceLocation()); // if (!fields.isEmpty()) { // baseLocation = Optional.ofNullable(fields.get(0).getSourceLocation()); // } else { // baseLocation = Optional.empty(); // } // relative error empty path should yield an absolute error with the base path if (relativeError.getLocations() != null && relativeError.getLocations().isEmpty()) { return baseLocation.map(Collections::singletonList).orElse(null); } return Optional.ofNullable( relativeError.getLocations()) .map(locations -> locations.stream() .map(l -> baseLocation .map(base -> new SourceLocation( base.getLine() + l.getLine(), base.getColumn() + l.getColumn())) .orElse(null)) .collect(Collectors.toList())) .map(Collections::unmodifiableList) .orElse(null); }	@param relativeError relative error	0	1
"public String toExampleValue(Schema schema) { if (schema.getExample() != null) { return schema.getExample().toString(); } if (ModelUtils.isBooleanSchema(schema)) { return ""null""; } else if (ModelUtils.isDateSchema(schema)) { return ""null""; } else if (ModelUtils.isDateTimeSchema(schema)) { return ""null""; } else if (ModelUtils.isNumberSchema(schema)) { return ""null""; } else if (ModelUtils.isIntegerSchema(schema)) { return ""null""; } else if (ModelUtils.isStringSchema(schema)) { return ""null""; } else if (ModelUtils.isObjectSchema(schema)) { return ""null""; } else { return ""null""; } }"	@param p Swagger property object	1	0
public List<String> get(Path key) { Integer index = keyToIndexMapper.get(key); if (index == null) { return Collections.emptyList(); } return partitionValues.get(index); }	@param key mapper key	0	1
File getBaseDir(final File file1, final File file2) { if (file1 == null || file2 == null) { return null; } final Iterator bases = getParents(file1).iterator(); final Iterator fileParents = getParents(file2.getAbsoluteFile()).iterator(); File result = null; while (bases.hasNext() && fileParents.hasNext()) { File next = (File) bases.next(); if (next.equals(fileParents.next())) { result = next; } else { break; } } return result; }	@param file the file for which the new base directory should be returned.	1	0
"protected FieldValueInfo completeField(ExecutionContext executionContext, ExecutionStrategyParameters parameters, FetchedValue fetchedValue) { Field field = parameters.getField().getSingleField(); GraphQLObjectType parentType = (GraphQLObjectType) parameters.getExecutionStepInfo().getUnwrappedNonNullType(); GraphQLFieldDefinition fieldDef = getFieldDef(executionContext.getGraphQLSchema(), parentType, field); ExecutionStepInfo executionStepInfo = createExecutionStepInfo(executionContext, parameters, fieldDef); Instrumentation instrumentation = executionContext.getInstrumentation(); InstrumentationFieldCompleteParameters instrumentationParams = new InstrumentationFieldCompleteParameters(executionContext, parameters, fieldDef, executionStepInfo, fetchedValue); InstrumentationContext<ExecutionResult> ctxCompleteField = instrumentation.beginFieldComplete( instrumentationParams ); GraphQLCodeRegistry codeRegistry = executionContext.getGraphQLSchema().getCodeRegistry(); Map<String, Object> argumentValues = valuesResolver.getArgumentValues(codeRegistry, fieldDef.getArguments(), field.getArguments(), executionContext.getVariables()); NonNullableFieldValidator nonNullableFieldValidator = new NonNullableFieldValidator(executionContext, executionStepInfo); ExecutionStrategyParameters newParameters = parameters.transform(builder -> builder.executionStepInfo(executionStepInfo) .arguments(argumentValues) .source(fetchedValue.getFetchedValue()) .localContext(fetchedValue.getLocalContext()) .nonNullFieldValidator(nonNullableFieldValidator) ); log.debug(""'{}' completing field '{}'..."", executionContext.getExecutionId(), executionStepInfo.getPath()); FieldValueInfo fieldValueInfo = completeValue(executionContext, newParameters); CompletableFuture<ExecutionResult> executionResultFuture = fieldValueInfo.getFieldValue(); ctxCompleteField.onDispatched(executionResultFuture); executionResultFuture.whenComplete(ctxCompleteField::onCompleted); return fieldValueInfo; }"	@param parameters contains the parameters holding the fields to be executed and source object	0	1
public static List<Integer> getSubListIndex(Object[] tofind, Object[] tokens){ if(tofind.length > tokens.length) return null; List<Integer> allIndices = new ArrayList<Integer>(); boolean matched = false; int index = -1; int lastUnmatchedIndex = 0; for(int i = 0 ; i < tokens.length;){ for(int j = 0; j < tofind.length ;){ if(tofind[j].equals(tokens[i])){ index = i; i++; j++; if(j == tofind.length) { matched = true; break; } }else{ j = 0; i = lastUnmatchedIndex +1; lastUnmatchedIndex = i; index = -1; if(lastUnmatchedIndex == tokens.length) break; } if(i >= tokens.length){ index = -1; break; } } if(i == tokens.length || matched){ if(index >= 0) //index = index - l1.length + 1; allIndices.add(index - tofind.length + 1); matched = false; lastUnmatchedIndex = index; //break; } } //get starting point return allIndices; }	@param l2	1	0
static Folder fromXml(Context context) { return (Folder) LayoutInflater.from(context).inflate(R.layout.user_folder, null); }	@param context The application's context.	0	1
public boolean searchText(String regex, int matches) { boolean found = searcher.searchText(regex, matches, true); return found; }	@param search the string to be searched. The parameter will be interpreted as a regular expression.	1	0
"public RepositoryMetadata lookupComponent(Class<?> repositoryClass) { if (repositoriesMetadata.containsKey(repositoryClass)) { return repositoriesMetadata.get(repositoryClass); } throw new RuntimeException(""Unknown Repository class "" + repositoryClass.getName()); }"	@param repoClass The Repository class to lookup the method for	1	0
public static StringTemplate stringTemplate(String template, ImmutableList<?> args) { return new StringTemplate(createTemplate(template), args); }	@param template	0	1
"public CodegenModel fromModel(String name, Schema schema, Map<String, Schema> allDefinitions) { if (typeAliases == null) { // Only do this once during first call typeAliases = getAllAliases(allDefinitions); } CodegenModel m = CodegenModelFactory.newInstance(CodegenModelType.MODEL); if (reservedWords.contains(name)) { m.name = escapeReservedWord(name); } else { m.name = name; } m.title = escapeText(schema.getTitle()); m.description = escapeText(schema.getDescription()); m.unescapedDescription = schema.getDescription(); m.classname = toModelName(name); m.classVarName = toVarName(name); m.classFilename = toModelFilename(name); m.modelJson = Json.pretty(schema); m.externalDocumentation = schema.getExternalDocs(); if (schema.getExtensions() != null && !schema.getExtensions().isEmpty()) { m.getVendorExtensions().putAll(schema.getExtensions()); } m.isAlias = typeAliases.containsKey(name); m.discriminator = schema.getDiscriminator(); if (schema.getXml() != null) { m.xmlPrefix = schema.getXml().getPrefix(); m.xmlNamespace = schema.getXml().getNamespace(); m.xmlName = schema.getXml().getName(); } if (ModelUtils.isArraySchema(schema)) { m.isArrayModel = true; m.arrayModelType = fromProperty(name, schema).complexType; addParentContainer(m, name, schema); } else if (schema instanceof ComposedSchema) { final ComposedSchema composed = (ComposedSchema) schema; Map<String, Schema> properties = new LinkedHashMap<String, Schema>(); List<String> required = new ArrayList<String>(); Map<String, Schema> allProperties; List<String> allRequired; if (supportsInheritance || supportsMixins) { allProperties = new LinkedHashMap<String, Schema>(); allRequired = new ArrayList<String>(); m.allVars = new ArrayList<CodegenProperty>(); int modelImplCnt = 0; // only one inline object allowed in a ComposedModel for (Schema innerModel : composed.getAllOf()) { if (m.discriminator == null) { m.discriminator = schema.getDiscriminator(); } if (innerModel.getXml() != null) { m.xmlPrefix = innerModel.getXml().getPrefix(); m.xmlNamespace = innerModel.getXml().getNamespace(); m.xmlName = innerModel.getXml().getName(); } if (modelImplCnt++ > 1) { LOGGER.warn(""More than one inline schema specified in allOf:. Only the first one is recognized. All others are ignored.""); break; // only one ModelImpl with discriminator allowed in allOf } } } else { allProperties = null; allRequired = null; } // parent model final String parentName = getParentName(composed, allDefinitions); final Schema parent = StringUtils.isBlank(parentName) ? null : allDefinitions.get(parentName); List<Schema> interfaces = getInterfaces(composed); // interfaces (intermediate models) if (interfaces != null) { if (m.interfaces == null) m.interfaces = new ArrayList<String>(); for (Schema interfaceSchema : interfaces) { if (StringUtils.isBlank(interfaceSchema.get$ref())) { continue; } Schema refSchema = null; String ref = getSimpleRef(interfaceSchema.get$ref()); if (allDefinitions != null) { refSchema = allDefinitions.get(ref); } final String modelName = toModelName(ref); m.interfaces.add(modelName); addImport(m, modelName); if (allDefinitions != null && refSchema != null) { if (!supportsMixins && !supportsInheritance) { addProperties(properties, required, refSchema, allDefinitions); } if (supportsInheritance) { addProperties(allProperties, allRequired, refSchema, allDefinitions); } } } } if (parent != null) { m.parentSchema = parentName; m.parent = toModelName(parentName); addImport(m, m.parent); if (allDefinitions != null && !allDefinitions.isEmpty()) { if (supportsInheritance) { addProperties(allProperties, allRequired, parent, allDefinitions); } else { addProperties(properties, required, parent, allDefinitions); } } } // child model (properties owned by the model itself) Schema child = null; if (composed.getAllOf() != null && !composed.getAllOf().isEmpty()) { for (Schema component : composed.getAllOf()) { if (component.get$ref() == null) { child = component; } } } if (child != null) { addProperties(properties, required, child, allDefinitions); if (supportsInheritance) { addProperties(allProperties, allRequired, child, allDefinitions); } } addVars(m, properties, required, allProperties, allRequired); // TODO //} else if (schema instanceof RefModel) { } else { m.dataType = getSchemaType(schema); if (schema.getEnum() != null && !schema.getEnum().isEmpty()) { m.isEnum = true; // comment out below as allowableValues is not set in post processing model enum m.allowableValues = new HashMap<String, Object>(); m.allowableValues.put(""values"", schema.getEnum()); } if (ModelUtils.isMapSchema(schema)) { addAdditionPropertiesToCodeGenModel(m, schema); } addVars(m, schema.getProperties(), schema.getRequired()); } if (m.vars != null) { for (CodegenProperty prop : m.vars) { postProcessModelProperty(m, prop); } } LOGGER.debug(""debugging fromModel return: "" + m); return m; }"	@param allDefinitions a map of all Swagger models from the spec	1	0
public PendingMessageCursor getSubscriberPendingMessageCursor(String clientId, String name, Store tmpStorage, int maxBatchSize, Subscription sub) { return new FilePendingMessageCursor(name, tmpStorage); }	@param clientId	0	1
protected SourceInfo update(Long lsn, Instant commitTime, Long txId, TableId tableId) { this.lsn = lsn; this.useconds = Conversions.toEpochMicros(commitTime); this.txId = txId; if (tableId != null && tableId.schema() != null) { this.schemaName = tableId.schema(); } if (tableId != null && tableId.table() != null) { this.tableName = tableId.table(); } return this; }	@param tableId the table that should be included in the source info; may be null	0	1
public Task<Boolean> contains(final CacheKey key) { if (containsSync(key)) { return Task.forResult(true); } return containsAsync(key); }	@param keys	1	0
"public Builder field(UnaryOperator<GraphQLFieldDefinition.Builder> builderFunction) { assertNotNull(builderFunction, ""builderFunction can't be null""); GraphQLFieldDefinition.Builder builder = GraphQLFieldDefinition.newFieldDefinition(); builder = builderFunction.apply(builder); return field(builder); }"	@param builderFunction a supplier for the builder impl	0	1
"public DrillBuf retain(BufferAllocator target) { if (isEmpty) { return this; } if (BaseAllocator.DEBUG) { historicalLog.recordEvent(""retain(%s)"", target.getName()); } final BufferLedger otherLedger = this.ledger.getLedgerForAllocator(target); return otherLedger.newDrillBuf(offset, length, null); }"	@param allocator The target allocator to create an association with.	1	0
public List<String> generateCreationCommands(Metadata metadata, boolean createNamespaces, Dialect dialect) { final ArrayList<String> commands = new ArrayList<String>(); doCreation( metadata, createNamespaces, dialect, new Target() { @Override public boolean acceptsImportScriptActions() { return true; } @Override public void prepare() { } @Override public void accept(String action) { commands.add( action ); } @Override public void release() { } } ); return commands; }	@param metadata The metadata for which to generate the creation commands.	0	1
protected boolean filter(String name) { if (name == null) return false; // Looking up the package String packageName = null; int pos = name.lastIndexOf('.'); if (pos != -1) packageName = name.substring(0, pos); else return false; for (int i = 0; i < packageTriggers.length; i++) { if (packageName.startsWith(packageTriggers[i])) return true; } return super.filter(name); }	@param name class name	0	1
"public static long toNanoOfDay(Object value, boolean acceptLargeValues) { if (value instanceof Duration) { Duration duration = (Duration) value; if (!acceptLargeValues && (duration.isNegative() || duration.compareTo(ONE_DAY) > 0)) { throw new IllegalArgumentException(""Time values must be between 00:00:00 and 24:00:00 (inclusive): "" + duration); } return ((Duration) value).toNanos(); } // TODO only needed for SQL Server/Oracle, where we don't produce Duration right away; // this should go eventually, as the conversion to LocalTime is superfluous LocalTime time = Conversions.toLocalTime(value); return time.toNanoOfDay(); }"	@param value the local or SQL date, time, or timestamp value; may not be null	1	0
"private static String toString(Collection<TypedDependency> dependencies, boolean extraSep) { StringBuilder buf = new StringBuilder(); if (extraSep) { List<TypedDependency> extraDeps = new ArrayList<TypedDependency>(); for (TypedDependency td : dependencies) { if (td.extra()) { extraDeps.add(td); } else { buf.append(td.toString()).append('\n'); } } // now we print the separator for extra dependencies, and print these if there are some if (!extraDeps.isEmpty()) { buf.append(""======\n""); for (TypedDependency td : extraDeps) { buf.append(td.toString()).append('\n'); } } } else { for (TypedDependency td : dependencies) { buf.append(td.toString()).append('\n'); } } return buf.toString(); }"	@param dependencies The TypedDependencies to print	0	1
public boolean searchText(String text, int minimumNumberOfMatches, boolean scroll, boolean onlyVisible) { return searcher.searchWithTimeoutFor(TextView.class, text, minimumNumberOfMatches, scroll, onlyVisible); }	@param visible true if only texts visible on the screen should be searched	1	0
public PendingMessageCursor getSubscriberPendingMessageCursor(Broker broker,String clientId, String name, int maxBatchSize, DurableTopicSubscription sub) { StoreDurableSubscriberCursor cursor = new StoreDurableSubscriberCursor(broker,clientId, name, maxBatchSize, sub); cursor.setImmediatePriorityDispatch(isImmediatePriorityDispatch()); return cursor; }	@param sub	0	1
public PendingMessageCursor getSubscriberPendingMessageCursor(String clientId, String name, Store tmpStorage, int maxBatchSize, Subscription sub) { return new VMPendingMessageCursor(); }	@param tmpStorage	0	1
public String getAsText(ReadablePartial partial, Locale locale) { return getAsText(partial, partial.get(this), locale); }	@param locale the locale to use for selecting a text symbol, null for default	0	1
public static FileMetadata getFileMetadata(Collection<RowGroupMetadata> rowGroups) { if (rowGroups.isEmpty()) { return null; } List<StatisticsHolder> fileStatistics = new ArrayList<>(); fileStatistics.add(new StatisticsHolder<>(TableStatisticsKind.ROW_COUNT.mergeStatistics(rowGroups), TableStatisticsKind.ROW_COUNT)); RowGroupMetadata rowGroupMetadata = rowGroups.iterator().next(); TupleMetadata schema = rowGroupMetadata.getSchema(); Set<SchemaPath> columns = rowGroupMetadata.getColumnsStatistics().keySet(); MetadataInfo metadataInfo = MetadataInfo.builder().type(MetadataType.FILE).build(); return FileMetadata.builder() .tableInfo(rowGroupMetadata.getTableInfo()) .metadataInfo(metadataInfo) .path(rowGroupMetadata.getPath()) .schema(schema) .columnsStatistics(TableMetadataUtils.mergeColumnsStatistics(rowGroups, columns, PARQUET_COLUMN_STATISTICS)) .metadataStatistics(fileStatistics) .build(); }	@param rowGroups list of RowGroupMetadata to be merged	1	0
public static BufferedImage alphaOffset(final Image rawImg, final int offset) { BufferedImage image = toARGB(rawImg); final float offsetFloat = (float) offset; final int numComponents = image.getColorModel().getNumComponents(); final float[] scales = new float[numComponents]; final float[] offsets = new float[numComponents]; Arrays.fill(scales, 1f); Arrays.fill(offsets, 0f); offsets[numComponents - 1] = offsetFloat; return offset(image, scales, offsets); }	@param image The image to be made more or less transparent.	1	0
"public String invokeAPI(String path, String method, Set<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); b.append(""?""); if (queryParams != null){ for (Pair queryParam : queryParams){ if (!queryParam.getName().isEmpty()) { b.append(escapeString(queryParam.getName())); b.append(""=""); b.append(escapeString(queryParam.getValue())); b.append(""&""); } } } String querystring = b.substring(0, b.length() - 1); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(""GET"".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (""POST"".equals(method)) { if (contentType.startsWith(""application/x-www-form-urlencoded"")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (""PUT"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (""DELETE"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, ""unknown method type "" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return """"; } } else { String message = ""error""; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { // e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }"	@param contentType The request's Content-Type header	0	1
"static public IStructuredTextExpert getExpert(String type, StructuredTextEnvironment environment) { IStructuredTextExpert expert; if (environment == null) environment = StructuredTextEnvironment.DEFAULT; synchronized (sharedExperts) { Map experts = (Map) sharedExperts.get(type); if (experts == null) { experts = new HashMap(); // environment -> expert sharedExperts.put(type, experts); } expert = (IStructuredTextExpert) experts.get(environment); if (expert == null) { StructuredTextTypeHandler handler = StructuredTextTypeHandlerFactory.getHandler(type); if (handler == null) throw new IllegalArgumentException(""Invalid type argument""); //$NON-NLS-1$ expert = new StructuredTextImpl(handler, environment, false); experts.put(type, expert); } } return expert; }"	@param environment the current environment, which may affect the behavior of the expert. This parameter may be specified as null, in which case the STextEnvironment#DEFAULT environment should be assumed.	1	0
"public int recordEvent(Document oplogEvent, Document masterEvent, Instant timestamp, long txOrder) throws InterruptedException { source.opLogEvent(replicaSetName, oplogEvent, masterEvent, txOrder); final Struct sourceValue = source.struct(); final Map<String, ?> offset = source.lastOffset(replicaSetName); Document patchObj = oplogEvent.get(""o"", Document.class); // Updates have an 'o2' field, since the updated object in 'o' might not have the ObjectID ... Object o2 = oplogEvent.get(""o2""); String objId = o2 != null ? idObjToJson(o2) : idObjToJson(patchObj); assert objId != null; Operation operation = OPERATION_LITERALS.get(oplogEvent.getString(""op"")); return createRecords(sourceValue, offset, operation, objId, patchObj, timestamp); }"	@param txOrder order of event in transaction; 0 for non-transactional event	0	1
"public static DataFileReadResult decompress(byte[] b, int[] keys) { InputStream stream = new InputStream(b); int compression = stream.readUnsignedByte(); int compressedLength = stream.readInt(); if (compressedLength < 0 || compressedLength > 1000000) throw new RuntimeException(""Invalid data""); Crc32 crc32 = new Crc32(); crc32.update(b, 0, 5); // compression + length byte[] data; int revision = -1; switch (compression) { case CompressionType.NONE: { byte[] encryptedData = new byte[compressedLength]; stream.readBytes(encryptedData, 0, compressedLength); crc32.update(encryptedData, 0, compressedLength); byte[] decryptedData = decrypt(encryptedData, encryptedData.length, keys); if (stream.remaining() >= 2) { revision = stream.readUnsignedShort(); assert revision != -1; } data = decryptedData; break; } case CompressionType.BZ2: { byte[] encryptedData = new byte[compressedLength + 4]; stream.readBytes(encryptedData); crc32.update(encryptedData, 0, encryptedData.length); byte[] decryptedData = decrypt(encryptedData, encryptedData.length, keys); if (stream.remaining() >= 2) { revision = stream.readUnsignedShort(); assert revision != -1; } stream = new InputStream(decryptedData); int decompressedLength = stream.readInt(); data = BZip2.decompress(stream.getRemaining(), compressedLength); if (data == null) { return null; } assert data.length == decompressedLength; break; } case CompressionType.GZ: { byte[] encryptedData = new byte[compressedLength + 4]; stream.readBytes(encryptedData); crc32.update(encryptedData, 0, encryptedData.length); byte[] decryptedData = decrypt(encryptedData, encryptedData.length, keys); if (stream.remaining() >= 2) { revision = stream.readUnsignedShort(); assert revision != -1; } stream = new InputStream(decryptedData); int decompressedLength = stream.readInt(); data = GZip.decompress(stream.getRemaining(), compressedLength); if (data == null) { return null; } assert data.length == decompressedLength; break; } default: throw new RuntimeException(""Unknown decompression type""); } DataFileReadResult res = new DataFileReadResult(); res.data = data; res.revision = revision; int length = revision != -1 ? b.length - 2 : b.length;; res.crc = crc32.getHash(); res.whirlpool = Whirlpool.getHash(b, length); res.compression = compression; return res; }"	@param size expected size of file	1	0
"public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); final String url = buildUrl(path, queryParams); final Request.Builder reqBuilder = new Request.Builder().url(url); processHeaderParams(headerParams, reqBuilder); String contentType = (String) headerParams.get(""Content-Type""); // ensuring a default content type if (contentType == null) contentType = ""application/json""; RequestBody reqBody; if (!HttpMethod.permitsRequestBody(method)) { reqBody = null; } else if (""application/x-www-form-urlencoded"".equals(contentType)) { reqBody = buildRequestBodyFormEncoding(formParams); } else if (""multipart/form-data"".equals(contentType)) { reqBody = buildRequestBodyMultipart(formParams); } else if (body == null) { if (""DELETE"".equals(method)) { // allow calling DELETE without sending a request body reqBody = null; } else { // use an empty request body (for POST, PUT and PATCH) reqBody = RequestBody.create(MediaType.parse(contentType), """"); } } else { reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType)); } Request request = null; if(progressRequestListener != null) { ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, progressRequestListener); request = reqBuilder.method(method, progressRequestBody).build(); } else { request = reqBuilder.method(method, reqBody).build(); } return httpClient.newCall(request); }"	"@param method The request method, one of ""GET"", ""HEAD"", ""OPTIONS"", ""POST"", ""PUT"", ""PATCH"" and ""DELETE"""	0	1
public Future<HttpResponse> executeAsync(Executor executor) { FutureTask<HttpResponse> future = new FutureTask<HttpResponse>(new Callable<HttpResponse>() { public HttpResponse call() throws Exception { return execute(); } }); executor.execute(future); return future; }	@param exec An executor to run the synchronous HttpRequest	1	0
public long resolve(long baseMillis, DateTimeZone zone) { Chronology chrono = iChronology.withZone(zone); long millis = baseMillis; millis = chrono.hourOfDay().set(millis, getValue(HOUR_OF_DAY)); millis = chrono.minuteOfHour().set(millis, getValue(MINUTE_OF_HOUR)); millis = chrono.secondOfMinute().set(millis, getValue(SECOND_OF_MINUTE)); millis = chrono.millisOfSecond().set(millis, getValue(MILLIS_OF_SECOND)); return millis; }	@param baseMillis source of missing fields	0	1
private static boolean containsItem(Collection<String> itemCollection, String item) { return itemCollection.contains(item.toLowerCase()); }	@param key - Key to search for.	1	0
public Single<Void> rxUpdateUser(String username, User user) { return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> { delegate.updateUser(username, user, fut); })); }	@param username name that need to be deleted (required)	0	1
"public static BroadcasterFactory buildAndReplaceDefaultfactory(Class<? extends Broadcaster> clazz, AtmosphereConfig c) throws InstantiationException, IllegalAccessException { factory = new DefaultBroadcasterFactory(clazz, ""NEVER"", c); return factory; }"	@param clazz A class implementing Broadcaster	0	1
protected int addToolBarElements(JToolBar toolBar, Location location, int gridX) { return gridX; }	@param loc the current location where elements can be added	1	0
static ColTypeInfo of(MessageType schema, Type type, String[] path, int depth, List<OriginalType> parentTypes) { if (type.isPrimitive()) { PrimitiveType primitiveType = (PrimitiveType) type; int precision = 0; int scale = 0; if (primitiveType.getDecimalMetadata() != null) { precision = primitiveType.getDecimalMetadata().getPrecision(); scale = primitiveType.getDecimalMetadata().getScale(); } int repetitionLevel = schema.getMaxRepetitionLevel(path); int definitionLevel = schema.getMaxDefinitionLevel(path); return new ColTypeInfo(type.getOriginalType(), parentTypes, precision, scale, repetitionLevel, definitionLevel); } Type t = ((GroupType) type).getType(path[depth]); if (!t.isPrimitive()) { OriginalType originalType = t.getOriginalType(); if (originalType == OriginalType.MAP && !ParquetReaderUtility.isLogicalMapType(t.asGroupType())) { originalType = null; } parentTypes.add(originalType); } return of(schema, t, path, depth + 1, parentTypes); }	@param length the length of the row group	0	1
"public Action timedout(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { AtmosphereResourceImpl re; long l = (Long) request.getAttribute(MAX_INACTIVE); if (l == -1) { // The closedDetector closed the connection. return timedoutAction; } request.setAttribute(MAX_INACTIVE, (long) -1); // Something went wrong. if (request == null || response == null) { logger.warn(""Invalid Request/Response: {}/{}"", request, response); return timedoutAction; } re = (AtmosphereResourceImpl) request.getAttribute(AtmosphereServlet.ATMOSPHERE_RESOURCE); if (re != null) { re.getAtmosphereResourceEvent().setIsResumedOnTimeout(true); Broadcaster b = re.getBroadcaster(); if (b instanceof DefaultBroadcaster) { ((DefaultBroadcaster)b).broadcastOnResume(re); } if (re.getRequest().getAttribute(AtmosphereServlet.RESUMED_ON_TIMEOUT) != null) { re.getAtmosphereResourceEvent().setIsResumedOnTimeout( (Boolean) re.getRequest().getAttribute(AtmosphereServlet.RESUMED_ON_TIMEOUT)); } invokeAtmosphereHandler(re); } return timedoutAction; }"	@param req the HttpServletRequest	1	0
private RexNode convertUsing(SqlValidatorNamespace leftNamespace, SqlValidatorNamespace rightNamespace, List<String> nameList) { final List<RexNode> list = Lists.newArrayList(); for (String name : nameList) { List<RexNode> operands = new ArrayList<>(); int offset = 0; for (SqlValidatorNamespace n : ImmutableList.of(leftNamespace, rightNamespace)) { final RelDataType rowType = n.getRowType(); final RelDataTypeField field = catalogReader.field(rowType, name); operands.add(rexBuilder.makeInputRef(field.getType(), offset + field.getIndex())); offset += rowType.getFieldList().size(); } list.add(rexBuilder.makeCall(SqlStdOperatorTable.EQUALS, operands)); } return RexUtil.composeConjunction(rexBuilder, list, false); }	@param leftRel Left input to the join	1	0
public static int numberOfLeadingZeros(long v) { // After Hacker's Delight, Figure 5-6 if (v < 0) { return 0; } if (v == 0) { return 64; } // On a 64-bit VM, the two previous tests should probably be replaced by // if (v <= 0) return ((int) (~v >> 57)) & 64; int n = 1; int i = (int) (v >>> 32); if (i == 0) { n += 32; i = (int) v; } if (i >> 16 == 0) { n += 16; i <<= 16; } if (i >> 24 == 0) { n += 8; i <<= 8; } if (i >> 28 == 0) { n += 4; i <<= 4; } if (i >> 30 == 0) { n += 2; i <<= 2; } return n - (i >>> 31); }	@param lng the long to examine.	1	0
public BufferedImage getImage(int itemId, int quantity, boolean stackable) { try { return itemImages.get(new ImageKey(itemId, quantity, stackable)); } catch (ExecutionException ex) { return null; } }	@param quantity	0	1
"public void redirectOutput(){ if (System.getenv(""REDIRECT"") == null || !System.getenv(""REDIRECT"").equals(""true"")) { return; } String DEFAULT_OUT_TARGET_FILE = JStormUtils.getLogFileName(); if (DEFAULT_OUT_TARGET_FILE == null) { DEFAULT_OUT_TARGET_FILE = ""/dev/null""; } else { DEFAULT_OUT_TARGET_FILE += "".out""; } String outputFile = ConfigExtension.getWorkerRedirectOutputFile(workerData.getStormConf()); if (outputFile == null) { outputFile = DEFAULT_OUT_TARGET_FILE; }else { try { File file = new File(outputFile); if (file.exists() == false) { PathUtils.touch(outputFile); }else { if (file.isDirectory() == true) { LOG.warn(""Failed to write "" + outputFile); outputFile = DEFAULT_OUT_TARGET_FILE; }else if (file.canWrite() == false) { LOG.warn(""Failed to write "" + outputFile); outputFile = DEFAULT_OUT_TARGET_FILE; } } }catch(Exception e) { LOG.warn(""Failed to touch "" + outputFile, e); outputFile = DEFAULT_OUT_TARGET_FILE; } } try { JStormUtils.redirectOutput(outputFile); }catch(Exception e) { LOG.warn(""Failed to redirect to "" + outputFile, e); } }"	@param worker_id	0	1
"public ApiResponse<Boolean> fakeOuterBooleanSerializeWithHttpInfo(Boolean body) throws ApiException { Object localVarPostBody = body; // create path and map variables String localVarPath = ""/fake/outer/boolean""; // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { ""*/*"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {}; return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	@param booleanPostBody Input boolean as post body (optional)	1	0
public PendingMessageCursor getSubscriberPendingMessageCursor(Broker broker,String name,int maxBatchSize,Subscription subs) { return new VMPendingMessageCursor(AbstractPendingMessageCursor.isPrioritizedMessageSubscriber(broker, subs)); }	@param broker	0	1
"public static LdapContext createPathContext( LdapContext authorityContext, String[] pathTokens) throws NamingException { for (int i = 1; i < (pathTokens.length); i++) { String subContext = CN + ""="" + pathTokens[i]; authorityContext = (LdapContext) createSubContext( authorityContext, subContext, null ); } return authorityContext; }"	@param ldapContext the dir context	1	0
"public static BroadcasterFactory buildAndReplaceDefaultfactory(Class<? extends Broadcaster> clazz, AtmosphereConfig c) throws InstantiationException, IllegalAccessException { factory = new DefaultBroadcasterFactory(clazz, ""NEVER"", c); return factory; }"	@param c An instance of AtmosphereServlet.AtmosphereConfig	0	1
"protected Connection getConnection(IBasicRequest request) { Logger.d(""--------------Request start--------------""); Headers responseHeaders = new HttpHeaders(); InputStream inputStream = null; Exception exception = null; HttpURLConnection urlConnection = null; String url = request.url(); try { if (!NetUtil.isNetworkAvailable()) throw new NetworkError(""The network is not available, please check the network. The requested url is: "" + url); // MalformedURLException, IOException, ProtocolException, UnknownHostException, SocketTimeoutException urlConnection = createConnectionAndWriteData(request); Logger.d(""-------Response start-------""); int responseCode = urlConnection.getResponseCode(); responseHeaders = parseResponseHeaders(new URI(request.url()), responseCode, urlConnection.getResponseMessage(), urlConnection.getHeaderFields()); // handle body if (responseCode == 301 || responseCode == 302 || responseCode == 303 || responseCode == 307) { Connection redirectConnection = handleRedirect(request, responseHeaders); responseHeaders = redirectConnection.responseHeaders(); inputStream = redirectConnection.serverStream(); exception = redirectConnection.exception(); } else if (hasResponseBody(request.getRequestMethod(), responseCode)) { inputStream = getServerStream(responseCode, responseHeaders.getContentEncoding(), urlConnection); } Logger.d(""-------Response end-------""); } catch (MalformedURLException e) { exception = new URLError(""The url is malformed: "" + url + "".""); } catch (UnknownHostException e) { exception = new UnKnownHostError(""Hostname can not be resolved: "" + url + "".""); } catch (SocketTimeoutException e) { exception = new TimeoutError(""Request time out: "" + url + "".""); } catch (Exception e) { exception = e; } finally { if (exception != null) Logger.e(exception); } Logger.d(""--------------Request finish--------------""); return new Connection(urlConnection, responseHeaders, inputStream, exception); }"	@param request ImplServerRequest.	1	0
"public boolean isUpToDate(Set<Serializable> spaces, Long timestamp, SharedSessionContractImplementor session) throws CacheException { final boolean stats = factory != null && factory.getStatistics().isStatisticsEnabled(); for ( Serializable space : spaces ) { final Long lastUpdate = getLastUpdateTimestampForSpace( space, session ); if ( lastUpdate == null ) { if ( stats ) { factory.getStatistics().updateTimestampsCacheMiss(); } //the last update timestamp was lost from the cache //(or there were no updates since startup!) //updateTimestamps.put( space, new Long( updateTimestamps.nextTimestamp() ) ); //result = false; // safer } else { if ( DEBUG_ENABLED ) { LOG.debugf( ""[%s] last update timestamp: %s"", space, lastUpdate + "", result set timestamp: "" + timestamp ); } if ( stats ) { factory.getStatistics().updateTimestampsCacheHit(); } if ( lastUpdate >= timestamp ) { return false; } } } return true; }"	@param timestamp The timestamp against which to check.	0	1
"private boolean searchForToggleButton(String regex, int matches) { sleeper.sleep(); inst.waitForIdleSync(); Pattern p = Pattern.compile(regex); Matcher matcher; ArrayList<ToggleButton> toggleButtonList = viewFetcher.getCurrentViews(ToggleButton.class); if(matches == 0) matches = 1; for(ToggleButton toggleButton : toggleButtonList){ matcher = p.matcher(toggleButton.getText().toString()); if(matcher.find()){ countMatches++; } if (countMatches == matches) { countMatches=0; return true; } } if (scroller.scroll(Scroller.Direction.DOWN)) { return searchForToggleButton(regex, matches); } else { if(countMatches > 0) Log.d(LOG_TAG, "" There are only "" + countMatches + "" matches of "" + regex); countMatches = 0; return false; } }"	@param matches the number of matches expected to be found. 0 matches means that one or more matches are expected to be found	0	1
public ScrollableResults scroll(ScrollMode mode, Expression<?> expr) { Query query = createQuery(expr); reset(); return query.scroll(mode); }	@param mode	0	1
public boolean searchButton(String regex, int matches) { boolean found = searcher.searchButton(regex, matches); return found; }	@param search the string to be searched. The parameter will be interpreted as a regular expression.	1	0
"public Object getCollection(Serializable key, SharedSessionContractImplementor session, Object owner, Boolean overridingEager) { CollectionPersister persister = getPersister( session ); final PersistenceContext persistenceContext = session.getPersistenceContext(); final EntityMode entityMode = persister.getOwnerEntityPersister().getEntityMode(); // check if collection is currently being loaded PersistentCollection collection = persistenceContext.getLoadContexts().locateLoadingCollection( persister, key ); if ( collection == null ) { // check if it is already completely loaded, but unowned collection = persistenceContext.useUnownedCollection( new CollectionKey(persister, key, entityMode) ); if ( collection == null ) { collection = persistenceContext.getCollection( new CollectionKey(persister, key, entityMode) ); if ( collection == null ) { // create a new collection wrapper, to be initialized later collection = instantiate( session, persister, key ); collection.setOwner( owner ); persistenceContext.addUninitializedCollection( persister, collection, key ); // some collections are not lazy: boolean eager = overridingEager != null ? overridingEager : !persister.isLazy(); if ( initializeImmediately() ) { session.initializeCollection( collection, false ); } else if ( eager ) { persistenceContext.addNonLazyCollection( collection ); } if ( hasHolder() ) { session.getPersistenceContext().addCollectionHolder( collection ); } } } if ( LOG.isTraceEnabled() ) { LOG.tracef( ""Created collection wrapper: %s"", MessageHelper.collectionInfoString( persister, collection, key, session ) ); } } collection.setOwner(owner); return collection.getValue(); }"	@param session The session from which the request is originating.	0	1
"public static IType createType(IASTDeclarator declarator) { IASTDeclSpecifier declSpec = null; IASTNode node = declarator.getParent(); while( node instanceof IASTDeclarator ){ declarator = (IASTDeclarator) node; node = node.getParent(); } if( node instanceof IASTParameterDeclaration ) declSpec = ((IASTParameterDeclaration) node).getDeclSpecifier(); else if( node instanceof IASTSimpleDeclaration ) declSpec = ((IASTSimpleDeclaration)node).getDeclSpecifier(); else if( node instanceof IASTFunctionDefinition ) declSpec = ((IASTFunctionDefinition)node).getDeclSpecifier(); else if( node instanceof IASTTypeId ) declSpec = ((IASTTypeId)node).getDeclSpecifier(); boolean isParameter = ( node instanceof IASTParameterDeclaration || node.getParent() instanceof ICASTKnRFunctionDeclarator ); IType type = null; //C99 6.7.5.3-12 The storage class specifier for a parameter declaration is ignored unless the declared parameter is one of the //members of the parameter type list for a function definition. if( isParameter && node.getParent().getParent() instanceof IASTFunctionDefinition ){ type = createBaseType( declSpec ); } else { type = createType( declSpec ); } type = createType( type, declarator ); if( isParameter ) { //C99: 6.7.5.3-7 a declaration of a parameter as ""array of type"" shall be adjusted to ""qualified pointer to type"", where the //type qualifiers (if any) are those specified within the [ and ] of the array type derivation if( type instanceof IArrayType ){ CArrayType at = (CArrayType) type; type = new CQualifiedPointerType( at.getType(), at.getModifier() ); } else if( type instanceof IFunctionType ) { //-8 A declaration of a parameter as ""function returning type"" shall be adjusted to ""pointer to function returning type"" type = new CPointerType( type ); } } return type; }"	@param name the IASTName whose IType will be created	1	0
@Override public int onReceiveLiquid(int type,int vol, byte side) { if(type == this.type) { int rejectedVolume = Math.max((this.getStoredLiquid(type) + vol) - this.capacity, 0); this.liquidStored = vol - rejectedVolume; return rejectedVolume; } return vol; }	@param watts - The amount of watt this block recieved	1	0
"public static StandardProperty buildStandardProperty(AttributeBinding property, boolean lazyAvailable) { final Type type = property.getHibernateTypeDescriptor().getExplicitType(); // we need to dirty check collections, since they can cause an owner // version number increment // we need to dirty check many-to-ones with not-found=""ignore"" in order // to update the cache (not the database), since in this case a null // entity reference can lose information boolean alwaysDirtyCheck = type.isAssociationType() && ( (AssociationType) type ).isAlwaysDirtyChecked(); if ( property.isSimpleValue() ) { SimpleAttributeBinding simpleProperty = ( SimpleAttributeBinding ) property; return new StandardProperty( simpleProperty.getAttribute().getName(), simpleProperty.getNodeName(), type, lazyAvailable && simpleProperty.isLazy(), simpleProperty.isInsertable(), simpleProperty.isUpdatable(), simpleProperty.getGeneration() == PropertyGeneration.INSERT || simpleProperty.getGeneration() == PropertyGeneration.ALWAYS, simpleProperty.getGeneration() == PropertyGeneration.ALWAYS, simpleProperty.isNullable(), alwaysDirtyCheck || simpleProperty.isUpdatable(), simpleProperty.isOptimisticLockable(), // TODO: get cascadeStyle from simpleProperty when HHH-6355 is fixed; for now, assume NONE //simpleProperty.getCascadeStyle(), CascadeStyle.NONE, // TODO: get fetchMode() from simpleProperty when HHH-6357 is fixed; for now, assume FetchMode.DEFAULT //simpleProperty.getFetchMode() FetchMode.DEFAULT ); } else { PluralAttributeBinding pluralProperty = ( PluralAttributeBinding ) property; return new StandardProperty( pluralProperty.getAttribute().getName(), pluralProperty.getNodeName(), type, lazyAvailable && pluralProperty.isLazy(), // TODO: fix this when HHH-6356 is fixed; for now assume PluralAttributeBinding is updatable and insertable // pluralProperty.isInsertable(), //pluralProperty.isUpdatable(), true, true, false, false, pluralProperty.isNullable(), // TODO: fix this when HHH-6356 is fixed; for now assume PluralAttributeBinding is updatable and insertable //alwaysDirtyCheck || pluralProperty.isUpdatable(), true, pluralProperty.isOptimisticLocked(), // TODO: get cascadeStyle from property when HHH-6355 is fixed; for now, assume NONE //pluralProperty.getCascadeStyle(), CascadeStyle.NONE, // TODO: get fetchMode() from simpleProperty when HHH-6357 is fixed; for now, assume FetchMode.DEFAULT //pluralProperty.getFetchMode() FetchMode.DEFAULT ); } }"	@param lazyAvailable Is property lazy loading currently available.	0	1
"private String validateBrowserString(String inputString, RemoteControlConfiguration configuration) throws IllegalArgumentException { String browserString = inputString; if (configuration.getForcedBrowserMode() != null) { browserString = configuration.getForcedBrowserMode(); log.info(""overriding browser mode w/ forced browser mode setting: "" + browserString); } if (SeleniumServer.isProxyInjectionMode() && browserString.equals(""*iexplore"")) { log.warn(""running in proxy injection mode, but you used a *iexplore browser string; this is "" + ""almost surely inappropriate, so I'm changing it to *piiexplore...""); browserString = ""*piiexplore""; } else if (SeleniumServer.isProxyInjectionMode() && browserString.equals(""*firefox"")) { log.warn(""running in proxy injection mode, but you used a *firefox browser string; this is "" + ""almost surely inappropriate, so I'm changing it to *pifirefox...""); browserString = ""*pifirefox""; } if (null == browserString) { throw new IllegalArgumentException(""browser string may not be null""); } return browserString; }"	@param inputString the input browser string	0	1
private static Uri getSharedPreferenceUri(Context context , int preferenceId) { String uriString = getSharedPreferences(context).getString(context.getString(preferenceId), null); if (uriString == null) return null; return Uri.parse(uriString); }	@param preferenceId the id of the shared preference.	0	1
protected SourceInfo update(Long lsn, Long useconds, Long txId) { this.lsn = lsn; this.useconds = useconds; this.txId = txId; return this; }	@param useconds the commit time (in microseconds since epoch) of the transaction that generated the event; may be null indicating that this information is not available	0	1
protected EntityInfo getEntityInfo(EnversService enversService, String entityName) { EntityConfiguration entCfg = enversService.getEntitiesConfigurations().get( entityName ); boolean isRelationAudited = true; if ( entCfg == null ) { // a relation marked as RelationTargetAuditMode.NOT_AUDITED entCfg = enversService.getEntitiesConfigurations().getNotVersionEntityConfiguration( entityName ); isRelationAudited = false; } final Class entityClass = ReflectionTools.loadClass( entCfg.getEntityClassName(), enversService.getClassLoaderService() ); return new EntityInfo( entityClass, entityName, isRelationAudited ); }	@param entityName Entity name.	0	1
public Client testClientModel(Client body) throws ApiException { return testClientModelWithHttpInfo(body).getData(); }	@param client client model (required)	1	0
"public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); for(String key : queryParams.keySet()) { String value = queryParams.get(key); if (value != null){ if(b.toString().length() == 0) b.append(""?""); else b.append(""&""); b.append(escapeString(key)).append(""="").append(escapeString(value)); } } String querystring = b.toString(); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(""GET"".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (""POST"".equals(method)) { if (contentType.startsWith(""application/x-www-form-urlencoded"")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (""PUT"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (""DELETE"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, ""unknown method type "" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return """"; } } else { String message = ""error""; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { // e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }"	@param authNames The authentications to apply	0	1
public ServletBuilder addServlet(Servlet servlet, String urlPattern) { final ServletHolder holder = new NonblockingServletHolder(checkNotNull(servlet)); final ServletBuilder builder = new ServletBuilder(holder, handler); builder.addUrlPattern(checkNotNull(urlPattern)); return builder; }	@param name the servlet's name	1	0
public static List<Integer> getSubListIndex(Object[] tofind, Object[] tokens, Predicate<Pair> matchingFunction){ if(tofind.length > tokens.length) return null; List<Integer> allIndices = new ArrayList<>(); boolean matched = false; int index = -1; int lastUnmatchedIndex = 0; for(int i = 0 ; i < tokens.length;){ for(int j = 0; j < tofind.length ;){ if(matchingFunction.test(new Pair(tofind[j], tokens[i]))){ index = i; i++; j++; if(j == tofind.length) { matched = true; break; } }else{ j = 0; i = lastUnmatchedIndex +1; lastUnmatchedIndex = i; index = -1; if(lastUnmatchedIndex == tokens.length) break; } if(i >= tokens.length){ index = -1; break; } } if(i == tokens.length || matched){ if(index >= 0) //index = index - l1.length + 1; allIndices.add(index - tofind.length + 1); matched = false; lastUnmatchedIndex = index; //break; } } //get starting point return allIndices; }	@param tofind array you want to find in tokens	0	1
"public ChatProtocol onMessage(ChatProtocol message) throws IOException { if (!users.containsKey(message.getAuthor())) { users.put(message.getAuthor(), message.getUuid()); return new ChatProtocol(message.getAuthor(), "" entered room "" + chatroomName, users.keySet(), factory.lookupAll()); } if (message.getMessage().contains(""disconnecting"")) { users.remove(message.getAuthor()); return new ChatProtocol(message.getAuthor(), "" disconnected from room "" + chatroomName, users.keySet(), factory.lookupAll()); } message.setUsers(users.keySet()); logger.info(""{} just send {}"", message.getAuthor(), message.getMessage()); return message; }"	@param message an instance of Message	1	0
private RectF drawBoxWithShadow(Canvas c, int width, int height) { Resources res = mContext.getResources(); float shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur); float keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance); float corner = res.getDimension(R.dimen.widget_preview_corner_radius); RectF bounds = new RectF(shadowBlur, shadowBlur, width - shadowBlur, height - shadowBlur - keyShadowDistance); ShadowGenerator.drawShadow(c, bounds, Color.WHITE, shadowBlur, keyShadowDistance, corner); return bounds; }	@param preScaledWidthOut return the width of the returned bitmap	0	1
public boolean searchForEditText(String regex, boolean scroll) { inst.waitForIdleSync(); Pattern p = Pattern.compile(regex); Matcher matcher; ArrayList<EditText> editTextList = viewFetcher.getCurrentViews(EditText.class); for(EditText editText : editTextList){ matcher = p.matcher(editText.getText().toString()); if (matcher.find()) { return true; } } if (scroll && scroller.scroll(Scroller.Direction.DOWN)) return searchForEditText(regex, scroll); else return false; }	@param scroll set to true if scrolling should be performed	0	1
protected EntityInfo getEntityInfo(EnversService enversService, String entityName) { EntityConfiguration entCfg = enversService.getEntitiesConfigurations().get( entityName ); boolean isRelationAudited = true; if ( entCfg == null ) { // a relation marked as RelationTargetAuditMode.NOT_AUDITED entCfg = enversService.getEntitiesConfigurations().getNotVersionEntityConfiguration( entityName ); isRelationAudited = false; } final Class entityClass = ReflectionTools.loadClass( entCfg.getEntityClassName(), enversService.getClassLoaderService() ); return new EntityInfo( entityClass, entityName, isRelationAudited ); }	@param verCfg Audit configuration.	1	0
public Struct update(Object before, Struct after, Struct source, Instant timestamp) { Struct struct = new Struct(schema); struct.put(FieldName.OPERATION, Operation.UPDATE.code()); if (before != null) { struct.put(FieldName.BEFORE, before); } struct.put(FieldName.AFTER, after); if (source != null) { struct.put(FieldName.SOURCE, source); } if (timestamp != null) { struct.put(FieldName.TIMESTAMP, timestamp.toEpochMilli()); } return struct; }	@param before the state of the record before the update; may be null	0	1
public RexLiteral makeNullLiteral(RelDataType type) { if (!type.isNullable()) { type = typeFactory.createTypeWithNullability(type, true); } return (RexLiteral) makeCast(type, constantNull()); }	@param typeName Type to cast NULL to	1	0
public static boolean isNotTransient(String entityName, Object entity, Boolean assumed, SharedSessionContractImplementor session) { if ( entity instanceof HibernateProxy ) { return true; } if ( session.getPersistenceContext().isEntryFor( entity ) ) { return true; } // todo : shouldnt assumed be revered here? return !isTransient( entityName, entity, assumed, session ); }	@param assumed The assumed return value, if avoiding database hit is desired	0	1
public SqlTester getTester() { return new SqlTesterImpl(new AdvisorTesterFactory()); }	@param list List	0	1
"public Client testClassname(Client client) throws RestClientException { Object postBody = client; // verify the required parameter 'client' is set if (client == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'client' when calling testClassname""); } String path = UriComponentsBuilder.fromPath(""/fake_classname_test"").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { ""application/json"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { ""application/json"" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { ""api_key_query"" }; ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {}; return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }"	@param body client model	1	0
public String runHTMLSuite(String browser, String browserURL, String HTMLSuite, File outputFile, int timeoutInSeconds, boolean multiWindow) throws IOException { long timeoutInMs = 1000 * timeoutInSeconds; server.handleHTMLRunnerResults(this); BrowserLauncherFactory blf = new BrowserLauncherFactory(server); String sessionId = Long.toString(System.currentTimeMillis() % 1000000); BrowserLauncher launcher = blf.getBrowserLauncher(browser, sessionId, null); launcher.launchHTMLSuite(HTMLSuite, browserURL, multiWindow); long now = System.currentTimeMillis(); long end = now + timeoutInMs; while (results == null && System.currentTimeMillis() < end) { AsyncExecute.sleepTight(500); } launcher.close(); if (results == null) { throw new SeleniumCommandTimedOutException(); } if (outputFile != null) { FileWriter fw = new FileWriter(outputFile); results.write(fw); fw.close(); } return results.getResult().toUpperCase(); }	@param multiWindow TODO	0	1
"public TableSchema create(String schemaPrefix, String envelopSchemaName, Table table, ColumnNameFilter filter, ColumnMappers mappers) { if (schemaPrefix == null) { schemaPrefix = """"; } // Build the schemas ... final TableId tableId = table.id(); final String tableIdStr = tableSchemaName(tableId); final String schemaNamePrefix = schemaPrefix + tableIdStr; LOGGER.debug(""Mapping table '{}' to schemas under '{}'"", tableId, schemaNamePrefix); SchemaBuilder valSchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + "".Value"")); SchemaBuilder keySchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + "".Key"")); AtomicBoolean hasPrimaryKey = new AtomicBoolean(false); table.columns().forEach(column -> { if (table.isPrimaryKeyColumn(column.name())) { // The column is part of the primary key, so ALWAYS add it to the PK schema ... addField(keySchemaBuilder, column, null); hasPrimaryKey.set(true); } if (filter == null || filter.matches(tableId.catalog(), tableId.schema(), tableId.table(), column.name())) { // Add the column to the value schema only if the column has not been filtered ... ColumnMapper mapper = mappers == null ? null : mappers.mapperFor(tableId, column); addField(valSchemaBuilder, column, mapper); } }); Schema valSchema = valSchemaBuilder.optional().build(); Schema keySchema = hasPrimaryKey.get() ? keySchemaBuilder.build() : null; if (LOGGER.isDebugEnabled()) { LOGGER.debug(""Mapped primary key for table '{}' to schema: {}"", tableId, SchemaUtil.asDetailedString(keySchema)); LOGGER.debug(""Mapped columns for table '{}' to schema: {}"", tableId, SchemaUtil.asDetailedString(valSchema)); } Envelope envelope = Envelope.defineSchema() .withName(schemaNameAdjuster.adjust(envelopSchemaName)) .withRecord(valSchema) .withSource(sourceInfoSchema) .build(); // Create the generators ... Function<Object[], Object> keyGenerator = createKeyGenerator(keySchema, tableId, table.primaryKeyColumns()); Function<Object[], Struct> valueGenerator = createValueGenerator(valSchema, tableId, table.columns(), filter, mappers); // And the table schema ... return new TableSchema(tableId, keySchema, keyGenerator, envelope, valSchema, valueGenerator); }"	@param mappers the mapping functions for columns; may be null if none of the columns are to be mapped to different values	0	1
public static List<Integer> getSubListIndex(Object[] tofind, Object[] tokens){ if(tofind.length > tokens.length) return null; List<Integer> allIndices = new ArrayList<Integer>(); boolean matched = false; int index = -1; int lastUnmatchedIndex = 0; for(int i = 0 ; i < tokens.length;){ for(int j = 0; j < tofind.length ;){ if(tofind[j].equals(tokens[i])){ index = i; i++; j++; if(j == tofind.length) { matched = true; break; } }else{ j = 0; i = lastUnmatchedIndex +1; lastUnmatchedIndex = i; index = -1; if(lastUnmatchedIndex == tokens.length) break; } if(i >= tokens.length){ index = -1; break; } } if(i == tokens.length || matched){ if(index >= 0) //index = index - l1.length + 1; allIndices.add(index - tofind.length + 1); matched = false; lastUnmatchedIndex = index; //break; } } //get starting point return allIndices; }	@param l1 array you want to find in l2	1	0
"public List<NamespaceVO> findNampspaces(String appId, Env env, String clusterName) { List<NamespaceDTO> namespaces = groupAPI.findGroupsByAppAndCluster(appId, env, clusterName); if (namespaces == null || namespaces.size() == 0) { return Collections.EMPTY_LIST; } List<NamespaceVO> namespaceVOs = new LinkedList<>(); for (NamespaceDTO namespace : namespaces) { NamespaceVO namespaceVO = null; try { namespaceVO = parseNamespace(appId, env, clusterName, namespace); namespaceVOs.add(namespaceVO); } catch (Exception e) { logger.error(""parse namespace error. app id:{}, env:{}, clusterName:{}, namespace:{}"", appId, env, clusterName, namespace.getNamespaceName(), e); return namespaceVOs; } } return namespaceVOs; }"	@param appId	0	1
public ScrollableResults scroll(ScrollMode mode, Expression<?> expr1, Expression<?> expr2, Expression<?>... rest) { Query query = createQuery(expr1, expr2, rest); reset(); return query.scroll(mode); }	@param expr1	0	1
"public TableSchema create(String schemaPrefix, String envelopSchemaName, Table table, ColumnNameFilter filter, ColumnMappers mappers, CustomKeyMapper keysMapper) { if (schemaPrefix == null) { schemaPrefix = """"; } // Build the schemas ... final TableId tableId = table.id(); final String tableIdStr = tableSchemaName(tableId); final String schemaNamePrefix = schemaPrefix + tableIdStr; LOGGER.debug(""Mapping table '{}' to schemas under '{}'"", tableId, schemaNamePrefix); SchemaBuilder valSchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + "".Value"")); SchemaBuilder keySchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + "".Key"")); AtomicBoolean hasPrimaryKey = new AtomicBoolean(false); Key tableKey = new Key.Builder(table).customKeyMapper(keysMapper).build(); tableKey.keyColumns().forEach(column -> { addField(keySchemaBuilder, column, null); hasPrimaryKey.set(true); }); table.columns() .stream() .filter(column -> filter == null || filter.matches(tableId.catalog(), tableId.schema(), tableId.table(), column.name())) .forEach(column -> { ColumnMapper mapper = mappers == null ? null : mappers.mapperFor(tableId, column); addField(valSchemaBuilder, column, mapper); }); Schema valSchema = valSchemaBuilder.optional().build(); Schema keySchema = hasPrimaryKey.get() ? keySchemaBuilder.build() : null; if (LOGGER.isDebugEnabled()) { LOGGER.debug(""Mapped primary key for table '{}' to schema: {}"", tableId, SchemaUtil.asDetailedString(keySchema)); LOGGER.debug(""Mapped columns for table '{}' to schema: {}"", tableId, SchemaUtil.asDetailedString(valSchema)); } Envelope envelope = Envelope.defineSchema() .withName(schemaNameAdjuster.adjust(envelopSchemaName)) .withRecord(valSchema) .withSource(sourceInfoSchema) .build(); // Create the generators ... Function<Object[], Object> keyGenerator = createKeyGenerator(keySchema, tableId, tableKey.keyColumns()); Function<Object[], Struct> valueGenerator = createValueGenerator(valSchema, tableId, table.columns(), filter, mappers); // And the table schema ... return new TableSchema(tableId, keySchema, keyGenerator, envelope, valSchema, valueGenerator); }"	@param mappers the mapping functions for columns; may be null if none of the columns are to be mapped to different values	0	1
"private int getJavadocOffset(TypeDeclaration td){ // TODO: This isn't perfect yet. Class \n \n \n className still breaks it.. :'( List<ASTNode> list= td.modifiers(); list = td.modifiers(); SimpleName sn = (SimpleName) getNode(); int lineNum = getLineNumber(sn); log(""SN ""+sn + "", "" + lineNum); for (ASTNode astNode : list) { if(getLineNumber(astNode) == lineNum) { log(""first node in that line "" + astNode); log(""diff "" + (sn.getStartPosition() - astNode.getStartPosition())); return (astNode.getStartPosition()); } } if(td.getJavadoc() != null){ log(""diff "" + (td.getJavadoc().getStartPosition() + td.getJavadoc().getLength() + 1)); return (td.getJavadoc().getStartPosition() + td.getJavadoc().getLength() + 1); } log(""getJavadocOffset(TypeDeclaration td) ""+sn + "", found nothing. Meh.""); return 0; }"	@param fd	1	0
public Client testClientModel(Client client) throws ApiException { ApiResponse<Client> resp = testClientModelWithHttpInfo(client); return resp.getData(); }	@param body client model (required)	1	0
public boolean isConnected(HistoryReference handshakeRef) { int historyId = handshakeRef.getHistoryId(); synchronized (wsProxies) { for (Entry<Integer, WebSocketProxy> entry : wsProxies.entrySet()) { WebSocketProxy proxy = entry.getValue(); if (historyId == proxy.getHandshakeReference().getHistoryId()) { return proxy.isConnected(); } } } return false; }	@param handshakeMessage	1	0
"public static int toMilliOfDay(Object value, boolean acceptLargeValues) { if (value instanceof Duration) { Duration duration = (Duration) value; if (!acceptLargeValues && (duration.isNegative() || duration.compareTo(ONE_DAY) > 0)) { throw new IllegalArgumentException(""Time values must be between 00:00:00 and 24:00:00 (inclusive): "" + duration); } // int conversion is ok for the range of TIME return (int) ((Duration) value).toMillis(); } // TODO only needed for SQL Server/Oracle, where we don't produce Duration right away; // this should go eventually, as the conversion to LocalTime is superfluous LocalTime time = Conversions.toLocalTime(value); long micros = Math.floorDiv(time.toNanoOfDay(), Conversions.NANOSECONDS_PER_MILLISECOND); assert Math.abs(micros) < Integer.MAX_VALUE; return (int) micros; }"	@param value the local or SQL date, time, or timestamp value; may not be null	1	0
private static void algC(StringBuilder sb, int m, int n, String a, String b) { int i; int j; // Step 1 if (n == 0) { // Nothing to do } else if (m == 1) { for (j = 0; j < n; j++) { if (a.charAt(0) == b.charAt(j)) { sb.append(a.charAt(0)); break; } } // Step 2 } else { i = (int)Math.floor(((double) m) / 2); // Step 3 int[] l1 = algB(i, n, a.substring(0, i), b); int[] l2 = algB(m - i, n, reverseString(a.substring(i)), reverseString(b)); // Step 4 int k = findK(l1, l2, n); // Step 5 algC(sb, i, k, a.substring(0, i), b.substring(0, k)); algC(sb, m - i, n - k, a.substring(i), b.substring(k)); } }	@param a	0	1
"public static String getConsoleIconPath(DesiredCapabilities cap, GridRegistry registry) { String name = consoleIconName(cap, registry); String path = ""org/openqa/grid/images/""; InputStream in = Thread.currentThread().getContextClassLoader() .getResourceAsStream(path + name + "".png""); if (in == null) { return null; } return ""/grid/resources/"" + path + name + "".png""; }"	@param registry - Registry	1	0
public static DateTimeComparator getInstance(DateTimeFieldType lowerLimit, DateTimeFieldType upperLimit) { if (lowerLimit == null && upperLimit == null) { return ALL_INSTANCE; } if (lowerLimit == DateTimeFieldType.dayOfYear() && upperLimit == null) { return DATE_INSTANCE; } if (lowerLimit == null && upperLimit == DateTimeFieldType.dayOfYear()) { return TIME_INSTANCE; } return new DateTimeComparator(lowerLimit, upperLimit); }	@param lowerLimit inclusive lower limit for fields to be compared, null means no limit	0	1
public Client call123testSpecialTags(Client body) throws ApiException { return call123testSpecialTagsWithHttpInfo(body).getData(); }	@param client client model (required)	1	0
"public Boolean fakeOuterBooleanSerialize(Boolean body) throws ApiException { Object localVarPostBody = body; // create path and map variables String localVarPath = ""/fake/outer/boolean""; // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { ""*/*"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {}; return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	@param booleanPostBody Input boolean as post body (optional)	1	0
public Activity getCurrentActivity(int pause) { if(pause > 0){ RobotiumUtils.sleep(pause); inst.waitForIdleSync(); } Boolean found = false; if (activityMonitor != null) { if (activityMonitor.getLastActivity() != null) activity = activityMonitor.getLastActivity(); } for(Activity storedActivity : activityList){ if (storedActivity.getClass().getName().equals( activity.getClass().getName())) found = true; } if (found) return activity; else { activityList.add(activity); return activity; } }	@param paus the time to paus	1	0
ScrollQuery scan(String query, BytesArray body, ScrollReader reader) throws IOException { String[] scrollInfo = client.scan(query, body); String scrollId = scrollInfo[0]; long totalSize = Long.parseLong(scrollInfo[1]); return new ScrollQuery(this, scrollId, totalSize, reader); }	@param reader scroll reader	0	1
public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, Map<String, Object> params) throws IOException { HttpResponse response = uploadFileWithRequiredFileForHttpResponse(petId, requiredFile, params); TypeReference typeRef = new TypeReference<ModelApiResponse>() {}; return apiClient.getObjectMapper().readValue(response.getContent(), typeRef); }	@param file file to upload	1	0
private BufferedImage loadImage(int itemId, int quantity, boolean stackable) { SpritePixels sprite = client.createItemSprite(itemId, quantity, 1, SpritePixels.DEFAULT_SHADOW_COLOR, stackable ? 1 : 0, false); return sprite.toBufferedImage(); }	@param itemId	0	1
"public static Path locate(String... paths) { Preconditions.checkArgument(paths.length > 0); return Stream.of(paths) .map(path -> Paths.get(path)) .filter(path -> Files.exists(path)) .findFirst() .map(path -> path.toAbsolutePath()) .orElseGet(() -> { Path root = findProjectRoot(); return Stream.of(paths) .map(path -> { Path needle = root.resolve(path); return Files.exists(needle) ? needle : null; }) .filter(Objects::nonNull) .findFirst().orElseThrow(() -> new WebDriverException(new FileNotFoundException( String.format(""Could not find any of %s in the project"", Stream.of(paths).collect(Collectors.joining("","")))))); }); }"	@param path path to file to locate from root of project	1	0
"private ParquetTableMetadata_v4 getParquetTableMetadata(Path path, FileSystem fs) throws IOException { FileStatus fileStatus = fs.getFileStatus(path); Stopwatch watch = logger.isDebugEnabled() ? Stopwatch.createStarted() : null; List<FileStatus> fileStatuses = new ArrayList<>(); if (fileStatus.isFile()) { fileStatuses.add(fileStatus); } else { // the thing we need!? fileStatuses.addAll(DrillFileSystemUtil.listFiles(fs, path, true)); } if (watch != null) { logger.debug(""Took {} ms to get file statuses"", watch.elapsed(TimeUnit.MILLISECONDS)); watch.reset(); watch.start(); } Map<FileStatus, FileSystem> fileStatusMap = fileStatuses.stream() .collect( java.util.stream.Collectors.toMap( Function.identity(), s -> fs, (oldFs, newFs) -> newFs, LinkedHashMap::new)); ParquetTableMetadata_v4 metadata_v4 = getParquetTableMetadata(fileStatusMap); if (watch != null) { logger.debug(""Took {} ms to read file metadata"", watch.elapsed(TimeUnit.MILLISECONDS)); watch.stop(); } return metadata_v4; }"	@param path the path of the directory	0	1
public List<Sentence> sentences(Properties props) { if (sentences == null) { // Get annotators Annotator tokenizer = (props == EMPTY_PROPS || props == SINGLE_SENTENCE_DOCUMENT) ? defaultTokenize : AnnotatorFactories.tokenize(props, backend).create(); Annotator ssplit = (props == EMPTY_PROPS || props == SINGLE_SENTENCE_DOCUMENT) ? defaultSSplit : AnnotatorFactories.sentenceSplit(props, backend).create(); // Annotate Annotation ann = new Annotation(this.impl.getText()); tokenizer.annotate(ann); ssplit.annotate(ann); // Grok results // (docid) if (ann.containsKey(CoreAnnotations.DocIDAnnotation.class)) { impl.setDocID(ann.get(CoreAnnotations.DocIDAnnotation.class)); } // (sentences) List<CoreMap> sentences = ann.get(CoreAnnotations.SentencesAnnotation.class); this.sentences = new ArrayList<>(sentences.size()); for (CoreMap sentence : sentences) { //Sentence sent = new Sentence(this, sentence); Sentence sent = new Sentence(this, this.serializer.toProtoBuilder(sentence), sentence.get(CoreAnnotations.TextAnnotation.class), defaultProps); this.sentences.add(sent); this.impl.addSentence(sent.serialize()); } } return sentences; }	@param props The properties to use in the edu.stanford.nlp.pipeline.WordsToSentencesAnnotator.	0	1
public Action suspended(AtmosphereRequest request, AtmosphereResponse response) throws IOException, ServletException { return action(request, response); }	@param response the HttpServletResponse	1	0
public static RelationTriple fromProto(CoreNLPProtos.RelationTriple proto, Annotation doc, int sentenceIndex) { if (Thread.interrupted()) { throw new RuntimeInterruptedException(); } // Get the spans for the extraction List<CoreLabel> subject = proto.getSubjectTokensList().stream().map(loc -> doc.get(SentencesAnnotation.class).get(loc.getSentenceIndex()).get(TokensAnnotation.class).get(loc.getTokenIndex()) ).collect(Collectors.toList()); List<CoreLabel> relation; if (proto.getRelationTokensCount() == 0) { // If we don't have a real span for the relation, make a dummy word relation = Collections.singletonList(new CoreLabel(new Word(proto.getRelation()))); } else { relation = proto.getRelationTokensList().stream().map(loc -> doc.get(SentencesAnnotation.class).get(loc.getSentenceIndex()).get(TokensAnnotation.class).get(loc.getTokenIndex()) ).collect(Collectors.toList()); } List<CoreLabel> object = proto.getObjectTokensList().stream().map(loc -> doc.get(SentencesAnnotation.class).get(loc.getSentenceIndex()).get(TokensAnnotation.class).get(loc.getTokenIndex()) ).collect(Collectors.toList()); // Create the extraction RelationTriple extraction; double confidence = proto.getConfidence(); if (proto.hasTree()) { SemanticGraph tree = fromProto( proto.getTree(), doc.get(SentencesAnnotation.class).get(sentenceIndex).get(TokensAnnotation.class), doc.get(DocIDAnnotation.class), Optional.of(doc)); extraction = new RelationTriple.WithTree(subject, relation, object, tree, confidence); } else { extraction = new RelationTriple(subject, relation, object, confidence); } // Tweak the extraction if (proto.hasIstmod()) { extraction.istmod(proto.getIstmod()); } if (proto.hasPrefixBe()) { extraction.isPrefixBe(proto.getPrefixBe()); } if (proto.hasSuffixBe()) { extraction.isSuffixBe(proto.getSuffixBe()); } if (proto.hasSuffixOf()) { extraction.isSuffixOf(proto.getSuffixOf()); } // Return return extraction; }	@param docid The id of the document we are de-serializing.	1	0
"private boolean scrollScrollView(final ScrollView view, int direction){ if(view == null){ Log.e(TAG, ""ScrollView was null""); return false; } int height = view.getHeight(); height--; int scrollTo = -1; if (direction == DOWN) { scrollTo = height; } else if (direction == UP) { scrollTo = -height; } int originalY = view.getScrollY(); final int scrollAmount = scrollTo; inst.runOnMainSync(new Runnable(){ public void run(){ view.scrollBy(0, scrollAmount); } }); if (originalY == view.getScrollY()) { return false; } else{ return true; } }"	@param direction the direction to be scrolled	0	1
public Object getCache(PGraphics renderer) { if (cacheMap == null) return null; return cacheMap.get(renderer); }	@param parent The PGraphics object (or any object, really) associated	1	0
public boolean searchToggleButton(String regex, int expectedMinimumNumberOfMatches) { boolean found = searcher.searchWithTimeoutFor(ToggleButton.class, regex, expectedMinimumNumberOfMatches, true); return found; }	@param regex the text to search for. The parameter will be interpreted as a regular expression.	0	1
"public TableSchema create(String schemaPrefix, String envelopSchemaName, Table table, ColumnNameFilter filter, ColumnMappers mappers, KeyMapper keysMapper) { if (schemaPrefix == null) { schemaPrefix = """"; } // Build the schemas ... final TableId tableId = table.id(); final String tableIdStr = tableSchemaName(tableId); final String schemaNamePrefix = schemaPrefix + tableIdStr; LOGGER.debug(""Mapping table '{}' to schemas under '{}'"", tableId, schemaNamePrefix); SchemaBuilder valSchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + "".Value"")); SchemaBuilder keySchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + "".Key"")); AtomicBoolean hasPrimaryKey = new AtomicBoolean(false); Key tableKey = new Key.Builder(table).customKeyMapper(keysMapper).build(); tableKey.keyColumns().forEach(column -> { addField(keySchemaBuilder, column, null); hasPrimaryKey.set(true); }); table.columns() .stream() .filter(column -> filter == null || filter.matches(tableId.catalog(), tableId.schema(), tableId.table(), column.name())) .forEach(column -> { ColumnMapper mapper = mappers == null ? null : mappers.mapperFor(tableId, column); addField(valSchemaBuilder, column, mapper); }); Schema valSchema = valSchemaBuilder.optional().build(); Schema keySchema = hasPrimaryKey.get() ? keySchemaBuilder.build() : null; if (LOGGER.isDebugEnabled()) { LOGGER.debug(""Mapped primary key for table '{}' to schema: {}"", tableId, SchemaUtil.asDetailedString(keySchema)); LOGGER.debug(""Mapped columns for table '{}' to schema: {}"", tableId, SchemaUtil.asDetailedString(valSchema)); } Envelope envelope = Envelope.defineSchema() .withName(schemaNameAdjuster.adjust(envelopSchemaName)) .withRecord(valSchema) .withSource(sourceInfoSchema) .build(); // Create the generators ... Function<Object[], Object> keyGenerator = createKeyGenerator(keySchema, tableId, tableKey.keyColumns()); Function<Object[], Struct> valueGenerator = createValueGenerator(valSchema, tableId, table.columns(), filter, mappers); // And the table schema ... return new TableSchema(tableId, keySchema, keyGenerator, envelope, valSchema, valueGenerator); }"	@param table the table definition; may not be null	0	1
"public ApiResponse<Client> call123testSpecialTagsWithHttpInfo(Client body) throws ApiException { Object localVarPostBody = body; // verify the required parameter 'body' is set if (body == null) { throw new ApiException(400, ""Missing the required parameter 'body' when calling call123testSpecialTags""); } // create path and map variables String localVarPath = ""/another-fake/dummy""; // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { ""application/json"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { ""application/json"" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Client> localVarReturnType = new GenericType<Client>() {}; return apiClient.invokeAPI(localVarPath, ""PATCH"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	@param client client model (required)	1	0
public List<String> generateCreationCommands(Metadata metadata, boolean createNamespaces, Dialect dialect) { final ArrayList<String> commands = new ArrayList<String>(); doCreation( metadata, createNamespaces, dialect, new Target() { @Override public boolean acceptsImportScriptActions() { return true; } @Override public void prepare() { } @Override public void accept(String action) { commands.add( action ); } @Override public void release() { } } ); return commands; }	@param createSchemas Should the schema(s) actually be created as well ( CREATE SCHEMA)?	1	0
public boolean searchText(String regex, int matches, boolean scroll) { return searcher.searchText(regex, matches, scroll); }	@param search the string to be searched. The parameter will be interpreted as a regular expression.	1	0
protected ArrayList<Timestamp> getTransitions(Timestamp beginning, int[] checks) { ArrayList<Timestamp> list = new ArrayList<>(); Timestamp current = beginning; list.add(current); for (int i = 1; i < checks.length; i++) { current = current.plus(1); int j = checks.length - i - 1; if ((checks[j + 1] == 0 && checks[j] > 0)) list.add(current); if ((checks[j + 1] > 0 && checks[j] == 0)) list.add(current.minus(1)); } if (list.size() % 2 == 1) list.add(current); return list; }	@param checks the checkmarks, ordered by decresing timestamp	0	1
"public static long toMicroOfDay(Object value, boolean acceptLargeValues) { if (value instanceof Duration) { Duration duration = (Duration) value; if (!acceptLargeValues && (duration.isNegative() || duration.compareTo(ONE_DAY) > 0)) { throw new IllegalArgumentException(""Time values must be between 00:00:00 and 24:00:00 (inclusive): "" + duration); } // conversion to nanos is fine as TIME values won't exceed long range return ((Duration) value).toNanos() / 1_000; } // TODO only needed for SQL Server/Oracle, where we don't produce Duration right away; // this should go eventually, as the conversion to LocalTime is superfluous LocalTime time = Conversions.toLocalTime(value); return Math.floorDiv(time.toNanoOfDay(), Conversions.NANOSECONDS_PER_MICROSECOND); }"	@param adjuster the optional component that adjusts the local date value before obtaining the epoch day; may be null if no adjustment is necessary	1	0
public static VersionProperty buildVersionProperty(SimpleAttributeBinding property, boolean lazyAvailable) { String mappedUnsavedValue = ( (KeyValue) property.getValue() ).getNullValue(); VersionValue unsavedValue = UnsavedValueFactory.getUnsavedVersionValue( mappedUnsavedValue, getGetter( property ), ( VersionType ) property.getHibernateTypeDescriptor().getExplicitType(), getConstructor( property.getEntityBinding() ) ); boolean lazy = lazyAvailable && property.isLazy(); return new VersionProperty( property.getAttribute().getName(), property.getNodeName(), property.getHibernateTypeDescriptor().getExplicitType(), lazy, property.isInsertable(), property.isUpdatable(), property.getGeneration() == PropertyGeneration.INSERT || property.getGeneration() == PropertyGeneration.ALWAYS, property.getGeneration() == PropertyGeneration.ALWAYS, property.isNullable(), property.isUpdatable() && !lazy, property.isOptimisticLockable(), // TODO: get cascadeStyle from property when HHH-6355 is fixed; for now, assume NONE //property.getCascadeStyle(), CascadeStyle.NONE, unsavedValue ); }	@param lazyAvailable Is property lazy loading currently available.	0	1
"public Action timedout(AtmosphereRequest request, AtmosphereResponse response) throws IOException, ServletException { AtmosphereResourceImpl r = null; try { if (trackActiveRequest) { long l = (Long) request.getAttribute(MAX_INACTIVE); if (l == -1) { // The closedDetector closed the connection. return timedoutAction; } request.setAttribute(MAX_INACTIVE, (long) -1); } logger.debug(""Timing out the connection for request {}"", request); // Something went wrong. if (request == null || response == null) { logger.warn(""Invalid Request/Response: {}/{}"", request, response); return timedoutAction; } r = (AtmosphereResourceImpl) request.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE); if (r != null && r.getAtmosphereResourceEvent().isSuspended()) { r.getAtmosphereResourceEvent().setIsResumedOnTimeout(true); Broadcaster b = r.getBroadcaster(); if (b instanceof DefaultBroadcaster) { ((DefaultBroadcaster) b).broadcastOnResume(r); } if (request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT) != null) { r.getAtmosphereResourceEvent().setIsResumedOnTimeout( (Boolean) request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT)); } invokeAtmosphereHandler(r); } } catch (Throwable t) { logger.error(""failed to timeout resource {}"", r, t); } finally { try { if (r != null) { r.notifyListeners(); r.setIsInScope(false); r.cancel(); } } catch (Throwable t) { logger.trace(""timedout"", t); } finally { try { response.getOutputStream().close(); } catch (Throwable t) { try { response.getWriter().close(); } catch (Throwable t2) { } } if (r != null) { destroyResource(r); } } } return timedoutAction; }"	@param response the HttpServletResponse	1	0
public void setInto(ReadWritableTimePeriod duration, Object object) { duration.setTimePeriod((ReadableDuration) object); }	@param object the object to convert, must not be null	0	1
"public static int toMilliOfDay(Object value, boolean acceptLargeValues) { if (value instanceof Duration) { Duration duration = (Duration) value; if (!acceptLargeValues && (duration.isNegative() || duration.compareTo(ONE_DAY) > 0)) { throw new IllegalArgumentException(""Time values must be between 00:00:00 and 24:00:00 (inclusive): "" + duration); } // int conversion is ok for the range of TIME return (int) ((Duration) value).toMillis(); } // TODO only needed for SQL Server/Oracle, where we don't produce Duration right away; // this should go eventually, as the conversion to LocalTime is superfluous LocalTime time = Conversions.toLocalTime(value); long micros = Math.floorDiv(time.toNanoOfDay(), Conversions.NANOSECONDS_PER_MILLISECOND); assert Math.abs(micros) < Integer.MAX_VALUE; return (int) micros; }"	@param adjuster the optional component that adjusts the local date value before obtaining the epoch day; may be null if no adjustment is necessary	1	0
"private JSONObject httpMessageToJSON(HttpMessage msg) { JSONObject ja = new JSONObject(); ja.put(""id"", msg.getHistoryRef().getHistoryId()); ja.put(""cookieParams"", XMLStringUtil.escapeControlChrs(msg.getCookieParamsAsString())); ja.put(""note"", msg.getNote()); ja.put(""requestHeader"", XMLStringUtil.escapeControlChrs(msg.getRequestHeader().toString())); ja.put(""requestBody"", XMLStringUtil.escapeControlChrs(msg.getRequestBody().toString())); ja.put(""responseHeader"", XMLStringUtil.escapeControlChrs(msg.getResponseHeader().toString())); if (HttpHeader.GZIP.equals(msg.getResponseHeader().getHeader(HttpHeader.CONTENT_ENCODING))) { // Uncompress gziped content try { ByteArrayInputStream bais = new ByteArrayInputStream(msg.getResponseBody().getBytes()); GZIPInputStream gis = new GZIPInputStream(bais); InputStreamReader isr = new InputStreamReader(gis); BufferedReader br = new BufferedReader(isr); StringBuilder sb = new StringBuilder(); String line = null; while ((line = br.readLine()) != null) { sb.append(line); } br.close(); isr.close(); gis.close(); bais.close(); ja.put(""responseBody"", XMLStringUtil.escapeControlChrs(sb.toString())); } catch (IOException e) { //this.log.error(e.getMessage(), e); System.out.println(e); } } else { ja.put(""responseBody"", XMLStringUtil.escapeControlChrs(msg.getResponseBody().toString())); } return ja; }"	@param hm	1	0
"public String getLimitString(String querySqlString, boolean hasOffset) { StringBuilder sb = new StringBuilder(querySqlString.trim().toLowerCase()); int orderByIndex = sb.indexOf(""order by""); CharSequence orderby = orderByIndex > 0 ? sb.subSequence(orderByIndex, sb.length()) : ""ORDER BY CURRENT_TIMESTAMP""; // Delete the order by clause at the end of the query if (orderByIndex > 0) { sb.delete(orderByIndex, orderByIndex + orderby.length()); } // HHH-5715 bug fix replaceDistinctWithGroupBy(sb); insertRowNumberFunction(sb, orderby); // Wrap the query within a with statement: sb.insert(0, ""WITH query AS ("").append("") SELECT * FROM query ""); //sb.append(""WHERE __hibernate_row_nr__ BETWEEN "").append(offset + 1).append("" AND "").append(limit); sb.append(""WHERE __hibernate_row_nr__ BETWEEN ? AND ?""); return sb.toString(); }"	@param limit Maximum number of rows to be returned by the query	0	1
"public Boolean fakeOuterBooleanSerialize(Boolean booleanPostBody) throws RestClientException { Object postBody = booleanPostBody; String path = UriComponentsBuilder.fromPath(""/fake/outer/boolean"").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { ""*/*"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<Boolean> returnType = new ParameterizedTypeReference<Boolean>() {}; return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }"	@param body Input boolean as post body	1	0
public PendingMessageCursor getSubscriberPendingMessageCursor(Broker broker,String clientId, String name, int maxBatchSize, DurableTopicSubscription sub) { StoreDurableSubscriberCursor cursor = new StoreDurableSubscriberCursor(broker,clientId, name, maxBatchSize, sub); cursor.setImmediatePriorityDispatch(isImmediatePriorityDispatch()); return cursor; }	@param maxBatchSize	0	1
"public void addPet (Pet pet) throws ApiException { Object localVarPostBody = pet; // verify the required parameter 'pet' is set if (pet == null) { throw new ApiException(400, ""Missing the required parameter 'pet' when calling addPet""); } // create path and map variables String localVarPath = ""/pet"".replaceAll(""\\{format\\}"",""json""); // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); // header params Map<String, String> localVarHeaderParams = new HashMap<String, String>(); // form params Map<String, String> localVarFormParams = new HashMap<String, String>(); String[] localVarContentTypes = { }; String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : ""application/json""; if (localVarContentType.startsWith(""multipart/form-data"")) { // file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); localVarPostBody = localVarBuilder.build(); } else { // normal form params } try { String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, ""POST"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType); if(localVarResponse != null){ return ; } else { return ; } } catch (ApiException ex) { throw ex; } }"	@param body Pet object that needs to be added to the store	1	0
"public Builder field(UnaryOperator<GraphQLInputObjectField.Builder> builderFunction) { assertNotNull(builderFunction, ""builderFunction should not be null""); GraphQLInputObjectField.Builder builder = GraphQLInputObjectField.newInputObjectField(); builder = builderFunction.apply(builder); return field(builder); }"	@param builderFunction a supplier for the builder impl	0	1
public int getOffsetFromLocal(long instantLocal) { return getOffset(instantLocal - getOffset(instantLocal)); }	@param millisLocal the millisecond instant, relative to this time zone, to get the offset for	1	0
"public ArrayList<TextView> clickInList(int line, int index, boolean longClick, int time) { line--; if(line < 0) line = 0; boolean foundList = waiter.waitForView(ListView.class, index); if (!foundList) Assert.assertTrue(""No ListView with index "" + index + "" is available!"", false); ArrayList<View> views = new ArrayList<View>(); final ListView listView = viewFetcher.getView(ListView.class, null, index); if(listView == null) Assert.assertTrue(""ListView is null!"", false); View view = listView.getChildAt(line); if(view != null){ views = viewFetcher.getViews(view, true); views = RobotiumUtils.removeInvisibleViews(views); clickOnScreen(view, longClick, time); } return RobotiumUtils.filterViews(TextView.class, views); }"	@param index the index of the list. E.g. Index 1 if two lists are available	0	1
"public static long safeMultiply(long val1, int val2) { switch (val2) { case -1: if (val1 == Long.MIN_VALUE) { throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2); } return -val1; case 0: return 0L; case 1: return val1; } long total = val1 * val2; if (total / val2 != val1) { throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2); } return total; }"	@param scalar the second value	1	0
public long addWrapped(long instant, int months) { return set(instant, Utils.getWrappedValue(get(instant), months, MIN, MAX)); }	@param months the months to add (can be negative).	0	1
"public String invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); b.append(""?""); if (queryParams != null){ for (Pair queryParam : queryParams){ if (!queryParam.getName().isEmpty()) { b.append(escapeString(queryParam.getName())); b.append(""=""); b.append(escapeString(queryParam.getValue())); b.append(""&""); } } } String querystring = b.substring(0, b.length() - 1); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(""GET"".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (""POST"".equals(method)) { if (contentType.startsWith(""application/x-www-form-urlencoded"")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (""PUT"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (""DELETE"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, ""unknown method type "" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return """"; } } else { String message = ""error""; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { // e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }"	@param headerParams The header parameters	0	1
"public Collection<Tree> getRelatedNodes(Tree t, Tree root) { if (root.value() == null) { root.setValue(""ROOT""); // todo: cdm: it doesn't seem like this line should be here } Set<Tree> nodeList = new LinkedHashSet<Tree>(); for (TregexPattern p : targetPatterns) { // cdm: I deleted: && nodeList.isEmpty() TregexMatcher m = p.matcher(root); while (m.findAt(t)) { nodeList.add(m.getNode(""target"")); if (DEBUG) { System.err.println(""found "" + this + ""("" + t + "", "" + m.getNode(""target"") + "") using pattern "" + p); for (String nodeName : m.getNodeNames()) { if (nodeName.equals(""target"")) continue; System.err.println("" node "" + nodeName + "": "" + m.getNode(nodeName)); } } } } return nodeList; }"	@param t Target for finding dependents of t related by this GR	1	0
public int[] addInField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { int current = values[fieldIndex]; int wrapped = FieldUtils.getWrappedValue (current, valueToAdd, getMinimumValue(instant), getMaximumValue(instant)); return set(instant, fieldIndex, values, wrapped); // adjusts smaller fields }	@param instant the partial instant	0	1
protected RuntimeException handleAccessDeniedException(AccessDeniedException originalException) { ExceptionToCatchEvent exceptionToCatchEvent = new ExceptionToCatchEvent(originalException); this.beanManager.fireEvent(exceptionToCatchEvent); //the next step won't happen per default since ExceptionHandlerBroadcaster will throw the exception, //because BeforeAccessDeniedExceptionHandler calls #throwOriginal //but allows to suppress it via deactivating BeforeAccessDeniedExceptionHandler //(or a 2nd @BeforeHandles method which overrules the default behavior //(if needed) if (!exceptionToCatchEvent.isHandled()) { throw originalException; } return null; }	@param ade The previously thrown exception representing a authorization check failure.	1	0
"public Client testClientModel(Client client) throws RestClientException { Object postBody = client; // verify the required parameter 'client' is set if (client == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'client' when calling testClientModel""); } String path = UriComponentsBuilder.fromPath(""/fake"").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { ""application/json"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { ""application/json"" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {}; return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }"	@param body client model	1	0
public boolean searchWithTimeoutFor(Class<? extends TextView> viewClass, String regex, int expectedMinimumNumberOfMatches, boolean scroll) { final long endTime = System.currentTimeMillis() + TIMEOUT; while (System.currentTimeMillis() < endTime) { sleeper.sleep(); final boolean foundAnyMatchingView = searchFor(viewClass, regex, expectedMinimumNumberOfMatches, scroll); if (foundAnyMatchingView){ return true; } } return false; }	@param scroll whether scrolling should be performed	0	1
"public String getTypeName(int code, long length, int precision, int scale) throws HibernateException { String result = typeNames.get( code, length, precision, scale ); if ( result == null ) { throw new HibernateException( ""No type mapping for java.sql.Types code: "" + code + "", length: "" + length ); } return result; }"	@param code The java.sql.Types typecode	0	1
"protected FieldValueInfo completeField(ExecutionContext executionContext, ExecutionStrategyParameters parameters, FetchedValue fetchedValue) { Field field = parameters.getField().getSingleField(); GraphQLObjectType parentType = (GraphQLObjectType) parameters.getExecutionStepInfo().getUnwrappedNonNullType(); GraphQLFieldDefinition fieldDef = getFieldDef(executionContext.getGraphQLSchema(), parentType, field); ExecutionStepInfo executionStepInfo = createExecutionStepInfo(executionContext, parameters, fieldDef); Instrumentation instrumentation = executionContext.getInstrumentation(); InstrumentationFieldCompleteParameters instrumentationParams = new InstrumentationFieldCompleteParameters(executionContext, parameters, fieldDef, executionStepInfo, fetchedValue); InstrumentationContext<ExecutionResult> ctxCompleteField = instrumentation.beginFieldComplete( instrumentationParams ); GraphQLCodeRegistry codeRegistry = executionContext.getGraphQLSchema().getCodeRegistry(); Map<String, Object> argumentValues = valuesResolver.getArgumentValues(codeRegistry, fieldDef.getArguments(), field.getArguments(), executionContext.getVariables()); NonNullableFieldValidator nonNullableFieldValidator = new NonNullableFieldValidator(executionContext, executionStepInfo); ExecutionStrategyParameters newParameters = parameters.transform(builder -> builder.executionStepInfo(executionStepInfo) .arguments(argumentValues) .source(fetchedValue.getFetchedValue()) .localContext(fetchedValue.getLocalContext()) .nonNullFieldValidator(nonNullableFieldValidator) ); log.debug(""'{}' completing field '{}'..."", executionContext.getExecutionId(), executionStepInfo.getPath()); FieldValueInfo fieldValueInfo = completeValue(executionContext, newParameters); CompletableFuture<ExecutionResult> executionResultFuture = fieldValueInfo.getFieldValue(); ctxCompleteField.onDispatched(executionResultFuture); executionResultFuture.whenComplete(ctxCompleteField::onCompleted); return fieldValueInfo; }"	@param fetchedValue the fetched raw value	0	1
public FilterRegistration.Dynamic addFilter(String name, Filter filter) { final FilterHolder holder = new FilterHolder(checkNotNull(filter)); holder.setName(name); handler.getServletHandler().addFilter(holder); return holder.getRegistration(); }	@param urlPattern the URL pattern for requests that should be handled by filter	1	0
public static RequestQueue newRequestQueue(int threadPoolSize) { RequestQueue requestQueue = new RequestQueue(HttpRestConnection.getInstance(getContext()), threadPoolSize); requestQueue.start(); return requestQueue; }	@param context ApplicationContext	0	1
public boolean searchToggleButton(String regex, int expectedMinimumNumberOfMatches) { boolean found = searcher.searchWithTimeoutFor(ToggleButton.class, regex, expectedMinimumNumberOfMatches, true); return found; }	@param matches the number of matches expected to be found. 0 matches means that one or more matches are expected to be found	1	0
"public Boolean fakeOuterBooleanSerialize(Boolean body) throws ApiException { Object localVarPostBody = body; // create path and map variables String localVarPath = ""/fake/outer/boolean"".replaceAll(""\\{format\\}"",""json""); // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { ""*/*"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {}; return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	@param booleanPostBody Input boolean as post body (optional)	1	0
public OuterComposite fakeOuterCompositeSerialize(OuterComposite outerComposite) throws IOException { HttpResponse response = fakeOuterCompositeSerializeForHttpResponse(outerComposite); TypeReference typeRef = new TypeReference<OuterComposite>() {}; return apiClient.getObjectMapper().readValue(response.getContent(), typeRef); }	@param body Input composite as post body	1	0
public PMetadata getCache(PGraphics renderer) { return g.getCache(renderer); }	@param parent The PGraphics object (or any object, really) associated	1	0
"static public IStructuredTextExpert getExpert(String type, StructuredTextEnvironment environment) { IStructuredTextExpert expert; if (environment == null) environment = StructuredTextEnvironment.DEFAULT; synchronized (sharedExperts) { Map experts = (Map) sharedExperts.get(type); if (experts == null) { experts = new HashMap(); // environment -> expert sharedExperts.put(type, experts); } expert = (IStructuredTextExpert) experts.get(environment); if (expert == null) { StructuredTextTypeHandler handler = StructuredTextTypeHandlerFactory.getHandler(type); if (handler == null) throw new IllegalArgumentException(""Invalid type argument""); //$NON-NLS-1$ expert = new StructuredTextImpl(handler, environment, false); experts.put(type, expert); } } return expert; }"	@param type the identifier for the required type handler. This identifier may be one of those listed in STextTypeHandlerFactory or it may be have been registered by a plug-in.	1	0
public static ParquetTableMetadata_v4 getParquetTableMetadata(FileSystem fs, Path path, ParquetReaderConfig readerConfig) throws IOException { Metadata metadata = new Metadata(readerConfig); return metadata.getParquetTableMetadata(path, fs); }	@param readerConfig parquet reader configuration	0	1
public boolean waitForText(String text, int expectedMinimumNumberOfMatches, long timeout) { return robotiumUtils.waitForText(text, expectedMinimumNumberOfMatches, timeout); }	@param matches the number of matches of text that must be shown. 0 means any number of matches	1	0
private ImmutableBitSet factorBitmap(ImmutableBitSet fieldRefBitmap) { ImmutableBitSet.Builder factorRefBitmap = ImmutableBitSet.builder(); for (int field : fieldRefBitmap) { int factor = findRef(field); factorRefBitmap.set(factor); } return factorRefBitmap.build(); }	@param fieldRefBitmap bitmap representing fields referenced	0	1
public Response syncSendPacket(Command command, int timeout) throws JMSException { if (isClosed()) { throw new ConnectionClosedException(); } else { if (command.isMessage() && flowControlSleepTime > 0) { try { Thread.sleep(flowControlSleepTime); } catch (InterruptedException e) { } } try { Response response = this.transport.request(command,timeout); if (response.isException()) { ExceptionResponse er = (ExceptionResponse) response; if (er.getException() instanceof JMSException) throw (JMSException) er.getException(); else throw JMSExceptionSupport.create(er.getException()); } return response; } catch (IOException e) { throw JMSExceptionSupport.create(e); } } }	@param command	0	1
public PortletContainer createContainer( String containerName, RequiredContainerServices requiredServices) throws PortletContainerException { return createContainer(containerName, requiredServices, new DefaultOptionalContainerServices()); }	@param services	1	0
public static RelNode swap(Join join, boolean swapOuterJoins) { final JoinRelType joinType = join.getJoinType(); if (!swapOuterJoins && joinType != JoinRelType.INNER) { return null; } final RexBuilder rexBuilder = join.getCluster().getRexBuilder(); final RelDataType leftRowType = join.getLeft().getRowType(); final RelDataType rightRowType = join.getRight().getRowType(); final VariableReplacer variableReplacer = new VariableReplacer(rexBuilder, leftRowType, rightRowType); final RexNode oldCondition = join.getCondition(); RexNode condition = variableReplacer.go(oldCondition); // NOTE jvs 14-Mar-2006: We preserve attribute semiJoinDone after the // swap. This way, we will generate one semijoin for the original // join, and one for the swapped join, and no more. This // doesn't prevent us from seeing any new combinations assuming // that the planner tries the desired order (semijoins after swaps). Join newJoin = join.copy(join.getTraitSet(), condition, join.getRight(), join.getLeft(), joinType.swap(), join.isSemiJoinDone()); final List<RexNode> exps = RelOptUtil.createSwappedJoinExprs(newJoin, join, true); return RelOptUtil.createProject( newJoin, exps, join.getRowType().getFieldNames(), true); }	@param join join to be swapped	0	1
public Activity getCurrentActivity(boolean shouldSleepFirst) { if(shouldSleepFirst){ RobotiumUtils.sleep(); inst.waitForIdleSync(); } Boolean found = false; if (activityMonitor != null) { if (activityMonitor.getLastActivity() != null) activity = activityMonitor.getLastActivity(); } for(Activity storedActivity : activityList){ if (storedActivity.getClass().getName().equals( activity.getClass().getName())) found = true; } if (found) return activity; else { activityList.add(activity); return activity; } }	@param pause the time to pause in milliseconds	1	0
public static Configuration from(Map<String, String> properties) { Map<String, String> props = new HashMap<>(); if (properties != null) props.putAll(properties); return new Configuration() { @Override public String getString(String key) { return properties.get(key); } @Override public Set<String> keys() { return properties.keySet(); } @Override public String toString() { return props.toString(); } }; }	@param properties the properties; may be null or empty	0	1
public WebDriver frame(final String nameOrIdOrIndex) { try { // 1.) try to find frame in current window ... currentWindow = findFrame(currentWindow, nameOrIdOrIndex); } catch (NoSuchFrameException ignored) { // 2.) try to find frame in top window ... final WebWindow topWindow = currentWindow.getTopWindow(); currentWindow = findFrame(topWindow, nameOrIdOrIndex); } return HtmlUnitDriver.this; }	@param name Frame index, name or a concatenation of frame identifiers that uniquely point to a specific frame.	1	0
public JoinSequence createJoinSequence(boolean implicit, AssociationType associationType, String tableAlias, JoinType joinType, String[] columns) { JoinSequence joinSequence = createJoinSequence(); joinSequence.setUseThetaStyle( implicit ); // Implicit joins use theta style (WHERE pk = fk), explicit joins use JOIN (after from) joinSequence.addJoin( associationType, tableAlias, joinType, columns ); return joinSequence; }	@param columns The columns making up the condition of the join.	0	1
public static By cssSelector(final String cssSelector) { return new ByCssSelector(cssSelector); }	@param selector CSS expression.	1	0
"public boolean remove(final BaseDownloadTask willRemoveDownload, final int removeByStatus) { boolean succeed; synchronized (list) { succeed = list.remove(willRemoveDownload); } if (succeed) { // ææ¶æ¯ switch (removeByStatus) { case FileDownloadStatus.warn: willRemoveDownload.getDriver().notifyWarn(); break; case FileDownloadStatus.error: willRemoveDownload.getDriver().notifyError(); break; case FileDownloadStatus.paused: willRemoveDownload.getDriver().notifyPaused(); break; case FileDownloadStatus.completed: Throwable ex = null; try{ willRemoveDownload.getDriver().notifyBlockComplete(); }catch (Throwable e){ ex = e; } if (ex != null) { willRemoveDownload.setStatus(FileDownloadStatus.error); willRemoveDownload.setEx(ex); willRemoveDownload.getDriver().notifyError(); } else { willRemoveDownload.getDriver().notifyCompleted(); } break; } } else { FileDownloadLog.e(this, ""remove error, not exist: %s"", willRemoveDownload); } return succeed; }"	@param removeByStatus must remove by status com.liulishuo.filedownloader.model.FileDownloadStatus#warn com.liulishuo.filedownloader.model.FileDownloadStatus#paused com.liulishuo.filedownloader.model.FileDownloadStatus#completed com.liulishuo.filedownloader.model.FileDownloadStatus#error	0	1
public int compareTo(ReadableDuration other) { long thisMillis = this.getMillis(); long otherMillis = other.getMillis(); // cannot do (thisMillis - otherMillis) as it can overflow if (thisMillis < otherMillis) { return -1; } if (thisMillis > otherMillis) { return 1; } return 0; }	@param obj a duration to check against	1	0
public Struct read(Object record, Struct source, Instant timestamp) { Struct struct = new Struct(schema); struct.put(FieldName.OPERATION, Operation.READ.code()); struct.put(FieldName.AFTER, record); if (source != null) { struct.put(FieldName.SOURCE, source); } if (timestamp != null) { struct.put(FieldName.TIMESTAMP, timestamp.toEpochMilli()); } return struct; }	@param source the information about the source that was read; may be null	0	1
"String evaluate(String url, String host) throws ScriptException { try { return (String) pacImpl.invokeFunction(""FindProxyForURL"", url, host); } catch (NoSuchMethodException | ScriptAbuseException e) { throw new ScriptException(e); } }"	@param destHost the host param of FindProxyForURL(url, host)	1	0
private SQLResponse execute(String correctedSql, SQLRequest sqlRequest) throws Exception { Connection conn = null; Statement stat = null; ResultSet resultSet = null; Boolean isPushDown = false; List<List<String>> results = Lists.newArrayList(); List<SelectedColumnMeta> columnMetas = Lists.newArrayList(); try { conn = cacheService.getOLAPDataSource(sqlRequest.getProject()).getConnection(); // special case for prepare query. if (BackdoorToggles.getPrepareOnly()) { return getPrepareOnlySqlResponse(correctedSql, conn, isPushDown, results, columnMetas); } stat = conn.createStatement(); processStatementAttr(stat, sqlRequest); resultSet = stat.executeQuery(correctedSql); ResultSetMetaData metaData = resultSet.getMetaData(); int columnCount = metaData.getColumnCount(); // Fill in selected column meta for (int i = 1; i <= columnCount; ++i) { columnMetas.add(new SelectedColumnMeta(metaData.isAutoIncrement(i), metaData.isCaseSensitive(i), metaData.isSearchable(i), metaData.isCurrency(i), metaData.isNullable(i), metaData.isSigned(i), metaData.getColumnDisplaySize(i), metaData.getColumnLabel(i), metaData.getColumnName(i), metaData.getSchemaName(i), metaData.getCatalogName(i), metaData.getTableName(i), metaData.getPrecision(i), metaData.getScale(i), metaData.getColumnType(i), metaData.getColumnTypeName(i), metaData.isReadOnly(i), metaData.isWritable(i), metaData.isDefinitelyWritable(i))); } // fill in results while (resultSet.next()) { List<String> oneRow = Lists.newArrayListWithCapacity(columnCount); for (int i = 0; i < columnCount; i++) { oneRow.add((resultSet.getString(i + 1))); } results.add(oneRow); } } catch (SQLException sqlException) { isPushDown = PushDownUtil.doPushDownQuery(sqlRequest.getProject(), correctedSql, results, columnMetas, sqlException); } finally { close(resultSet, stat, conn); } return getSqlResponse(isPushDown, results, columnMetas); }	@param correctedSql	0	1
public String getTypeDeclaration(Schema schema) { String oasType = getSchemaType(schema); if (typeMapping.containsKey(oasType)) { return typeMapping.get(oasType); } return oasType; }	@param p Swagger Property object	1	0
public static Criterion between(String propertyName, Object low, Object high) { return new BetweenExpression( propertyName, low, high ); }	@param lo The low value	1	0
public Call updatePetWithFormAsync(Long petId, String name, String status, final ApiCallback<Void> callback) throws ApiException { ProgressResponseBody.ProgressListener progressListener = null; ProgressRequestBody.ProgressRequestListener progressRequestListener = null; if (callback != null) { progressListener = new ProgressResponseBody.ProgressListener() { @Override public void update(long bytesRead, long contentLength, boolean done) { callback.onDownloadProgress(bytesRead, contentLength, done); } }; progressRequestListener = new ProgressRequestBody.ProgressRequestListener() { @Override public void onRequestProgress(long bytesWritten, long contentLength, boolean done) { callback.onUploadProgress(bytesWritten, contentLength, done); } }; } Call call = updatePetWithFormCall(petId, name, status, progressListener, progressRequestListener); apiClient.executeAsync(call, callback); return call; }	@param petId ID of pet that needs to be updated (required)	0	1
public static BooleanOperation predicate(Operator operation, Expression<?>... args) { return new BooleanOperation(operation, args); }	@param args operation arguments	1	0
"public String invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); b.append(""?""); if (queryParams != null){ for (Pair queryParam : queryParams){ if (!queryParam.getName().isEmpty()) { b.append(escapeString(queryParam.getName())); b.append(""=""); b.append(escapeString(queryParam.getValue())); b.append(""&""); } } } String querystring = b.substring(0, b.length() - 1); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(""GET"".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (""POST"".equals(method)) { if (contentType.startsWith(""application/x-www-form-urlencoded"")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (""PUT"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (""DELETE"".equals(method)) { if (""application/x-www-form-urlencoded"".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, ""unknown method type "" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return """"; } } else { String message = ""error""; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { // e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }"	@param accept The request's Accept header	0	1
public static boolean isTransient(String entityName, Object entity, Boolean assumed, SharedSessionContractImplementor session) { if ( entity == LazyPropertyInitializer.UNFETCHED_PROPERTY ) { // an unfetched association can only point to // an entity that already exists in the db return false; } // let the interceptor inspect the instance to decide Boolean isUnsaved = session.getInterceptor().isTransient( entity ); if ( isUnsaved != null ) { return isUnsaved; } // let the persister inspect the instance to decide final EntityPersister persister = session.getEntityPersister( entityName, entity ); isUnsaved = persister.isTransient( entity, session ); if ( isUnsaved != null ) { return isUnsaved; } // we use the assumed value, if there is one, to avoid hitting // the database if ( assumed != null ) { return assumed; } // hit the database, afterQuery checking the session cache for a snapshot final Object[] snapshot = session.getPersistenceContext().getDatabaseSnapshot( persister.getIdentifier( entity, session ), persister ); return snapshot == null; }	@param entity The entity instance	0	1
public Tree apply(List<? extends HasWord> lst) { return parse(lst); }	@param words The input sentence (a List of words)	1	0
protected void coordinateSharedCacheCleanup(SharedSessionContractImplementor session) { final BulkOperationCleanupAction action = new BulkOperationCleanupAction( session, getCustomQuery().getQuerySpaces() ); if ( session.isEventSource() ) { ( (EventSource) session ).getActionQueue().addAction( action ); } else { action.getAfterTransactionCompletionProcess().doAfterTransactionCompletion( true, session ); } }	@param namedParams The named query parameters specified by the application.	0	1
public Struct update(Object before, Struct after, Struct source, Long timestamp) { Struct struct = new Struct(schema); struct.put(FieldName.OPERATION, Operation.UPDATE.code()); if (before != null) struct.put(FieldName.BEFORE, before); struct.put(FieldName.AFTER, after); if (source != null) struct.put(FieldName.SOURCE, source); if (timestamp != null) struct.put(FieldName.TIMESTAMP, timestamp); return struct; }	@param timestamp the timestamp for this message; may be null	0	1
"public Action resumed(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { logger.debug(""(resumed) invoked:\n HttpServletRequest: {}\n HttpServletResponse: {}"", request, response); return action(request, response); }"	@param req the HttpServletRequest	1	0
"public boolean isNormalized(Litmus litmus, RexBuilder rexBuilder) { final RexProgram normalizedProgram = normalize(rexBuilder, false); String normalized = normalizedProgram.toString(); String string = toString(); if (!normalized.equals(string)) { return litmus.fail(""Program is not normalized:\n"" + ""program: "" + string + ""\n"" + ""normalized: "" + normalized + ""\n""); } return litmus.succeed(); }"	@param fail Whether to throw an assertion error if not in canonical form	1	0
protected String determineValueColumnName(Properties params, JdbcEnvironment jdbcEnvironment) { final String name = ConfigurationHelper.getString( VALUE_COLUMN_PARAM, params, DEF_VALUE_COLUMN ); return jdbcEnvironment.getIdentifierHelper().toIdentifier( name ).render( jdbcEnvironment.getDialect() ); }	@param dialect The dialect in effect	1	0
"public String toDefaultValue(Schema p) { if (p instanceof StringSchema) { StringSchema dp = (StringSchema) p; if (dp.getDefault() != null) { return ""@\"""" + dp.getDefault() + ""\""""; } } else if (p instanceof BooleanSchema) { BooleanSchema dp = (BooleanSchema) p; if (dp.getDefault() != null) { if (dp.getDefault().toString().equalsIgnoreCase(""false"")) return ""@(NO)""; else return ""@(YES)""; } } else if (p instanceof DateSchema) { // TODO } else if (p instanceof DateTimeSchema) { // TODO } else if (p instanceof NumberSchema) { NumberSchema dp = (NumberSchema) p; if (dp.getDefault() != null) { return ""@"" + dp.getDefault().toString(); } } else if (p instanceof IntegerSchema) { IntegerSchema dp = (IntegerSchema) p; if (dp.getDefault() != null) { return ""@"" + dp.getDefault().toString(); } } return null; }"	@param p Swagger property object	1	0
"public Request buildRequest(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); final String url = buildUrl(path, queryParams, collectionQueryParams); final Request.Builder reqBuilder = new Request.Builder().url(url); processHeaderParams(headerParams, reqBuilder); String contentType = (String) headerParams.get(""Content-Type""); // ensuring a default content type if (contentType == null) { contentType = ""application/json""; } RequestBody reqBody; if (!HttpMethod.permitsRequestBody(method)) { reqBody = null; } else if (""application/x-www-form-urlencoded"".equals(contentType)) { reqBody = buildRequestBodyFormEncoding(formParams); } else if (""multipart/form-data"".equals(contentType)) { reqBody = buildRequestBodyMultipart(formParams); } else if (body == null) { if (""DELETE"".equals(method)) { // allow calling DELETE without sending a request body reqBody = null; } else { // use an empty request body (for POST, PUT and PATCH) reqBody = RequestBody.create(MediaType.parse(contentType), """"); } } else { reqBody = serialize(body, contentType); } // Associate callback with request (if not null) so interceptor can // access it when creating ProgressResponseBody reqBuilder.tag(callback); Request request = null; if (callback != null && reqBody != null) { ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, callback); request = reqBuilder.method(method, progressRequestBody).build(); } else { request = reqBuilder.method(method, reqBody).build(); } return request; }"	"@param method The request method, one of ""GET"", ""HEAD"", ""OPTIONS"", ""POST"", ""PUT"", ""PATCH"" and ""DELETE"""	0	1
"public BroadcastAction filter(Object originalMessage, Object o) { if (o instanceof String){ String message = (String)o; try { // Avoid re-broadcasting if (!receivedMessages.remove(message)) { publisher.send(session.createTextMessage(message)); } } catch (JMSException ex) { logger.log(Level.WARNING, """", ex); } return new BroadcastAction(message); } else { return new BroadcastAction(o); } }"	@param o the message to broadcast.	0	1
"private static RestClient connect(List<HttpHost> hosts, String pathPrefix) { Objects.requireNonNull(hosts, ""hosts or coordinates""); Preconditions.checkArgument(!hosts.isEmpty(), ""no ES hosts specified""); RestClientBuilder builder = RestClient.builder(hosts.toArray(new HttpHost[hosts.size()])); if (pathPrefix != null && !pathPrefix.isEmpty()) { builder.setPathPrefix(pathPrefix); } return builder.build(); }"	@param hosts list of ES HTTP Hosts to connect to	0	1
public static SDOGeometry join(SDOGeometry[] sdoElements) { final SDOGeometry sdoCollection = new SDOGeometry(); if ( sdoElements == null || sdoElements.length == 0 ) { sdoCollection.setGType( new SDOGType( 2, 0, TypeGeometry.COLLECTION ) ); } else { final SDOGeometry firstElement = sdoElements[0]; final int dim = firstElement.getGType().getDimension(); final int lrsDim = firstElement.getGType().getLRSDimension(); sdoCollection.setGType( new SDOGType( dim, lrsDim, TypeGeometry.COLLECTION ) ); int ordinatesOffset = 1; for ( int i = 0; i < sdoElements.length; i++ ) { final ElemInfo element = sdoElements[i].getInfo(); final Double[] ordinates = sdoElements[i].getOrdinates().getOrdinateArray(); if ( element != null && element.getSize() > 0 ) { final int shift = ordinatesOffset - element.getOrdinatesOffset( 0 ); shiftOrdinateOffset( element, shift ); sdoCollection.addElement( element ); sdoCollection.addOrdinates( ordinates ); ordinatesOffset += ordinates.length; } } } return sdoCollection; }	@param SDOElements	1	0
public int compareTo(ReadableInstant other) { if (this == other) { return 0; } long otherMillis = other.getMillis(); long thisMillis = getMillis(); // cannot do (thisMillis - otherMillis) as can overflow if (thisMillis == otherMillis) { return 0; } if (thisMillis < otherMillis) { return -1; } else { return 1; } }	@param instant a readable instant to check against	1	0
public boolean waitForText(String text, int minimumNumberOfMatches, long timeout, boolean scroll) { return robotiumUtils.waitForText(text, minimumNumberOfMatches, timeout, scroll); }	@param expectedMinimumNumberOfMatches the minimum number of matches of text that must be shown. 0 means any number of matches	1	0
"private URL determineSuiteUrl(String startURL, String suiteURL) throws IOException { if (suiteURL.startsWith(""https://"") || suiteURL.startsWith(""http://"")) { return verifySuiteUrl(new URL(suiteURL)); } // Is the suiteURL a file? Path path = Paths.get(suiteURL); if (Files.exists(path)) { // Not all drivers can read files from the disk, so we need to host the suite somewhere. try (SocketLock lock = new SocketLock()) { server = new Server(); HttpConfiguration httpConfig = new HttpConfiguration(); ServerConnector http = new ServerConnector(server, new HttpConnectionFactory(httpConfig)); int port = PortProber.findFreePort(); http.setPort(port); http.setIdleTimeout(500000); server.setConnectors(new Connector[]{http}); ResourceHandler handler = new ResourceHandler(); handler.setDirectoriesListed(true); handler.setWelcomeFiles(new String[]{path.getFileName().toString(), ""index.html""}); handler.setBaseResource(new PathResource(path.toFile().getParentFile().toPath().toRealPath())); ContextHandler context = new ContextHandler(""/tests""); context.setHandler(handler); server.setHandler(context); server.start(); PortProber.waitForPortUp(port, 15, SECONDS); URL serverUrl = server.getURI().toURL(); return new URL(serverUrl.getProtocol(), serverUrl.getHost(), serverUrl.getPort(), ""/tests/""); } catch (Exception e) { throw new IOException(e); } } // Well then, it must be a URL relative to whatever the browserUrl. Probe and find out. URL browser = new URL(startURL); return verifySuiteUrl(new URL(browser, suiteURL)); }"	@param browserURL - the start URL for the browser	1	0
"public boolean highlightNode(ASTGenerator astGenerator){ if (!(Node instanceof SimpleName)) { return false; } SimpleName nodeName = (SimpleName) Node; try { //TODO: Redundant code. See ASTGenerator.getJavaSourceCodeline() int javaLineNumber = getLineNumber(nodeName); int pdeOffs[] = astGenerator.errorCheckerService .calculateTabIndexAndLineNumber(javaLineNumber); PlainDocument javaSource = new PlainDocument(); javaSource.insertString(0, astGenerator.errorCheckerService.sourceCode, null); Element lineElement = javaSource.getDefaultRootElement() .getElement(javaLineNumber-1); if(lineElement == null) { Messages.log(lineNumber + "" line element null while highlighting "" + nodeName); return false; } String javaLine = javaSource.getText(lineElement.getStartOffset(), lineElement.getEndOffset() - lineElement.getStartOffset()); astGenerator.editor.getSketch().setCurrentCode(pdeOffs[0]); String pdeLine = astGenerator.editor.getLineText(pdeOffs[1]); String lookingFor = nodeName.toString(); Messages.log(lookingFor + "", "" + nodeName.getStartPosition()); Messages.log(javaLineNumber +"" JL "" + javaLine + "" LSO "" + lineElement.getStartOffset() + "","" + lineElement.getEndOffset()); Messages.log(pdeOffs[1] + "" PL "" + pdeLine); if (!javaLine.contains(lookingFor) || !pdeLine.contains(lookingFor)) { Messages.loge(""Logical error in highLightNode(). Please file a bug report.""); return false; } OffsetMatcher ofm = new OffsetMatcher(pdeLine, javaLine); int highlightStart = ofm.getPdeOffForJavaOff(nodeName.getStartPosition() - lineElement.getStartOffset(), nodeName.getLength()); if (highlightStart == -1) { Messages.loge(""Logical error in highLightNode() during offset matching. "" + ""Please file a bug report.""); return false; } int lso = astGenerator.editor.getTextArea().getLineStartOffset(pdeOffs[1]); highlightStart += lso; astGenerator.editor.setSelection(highlightStart, highlightStart + nodeName.getLength()); /* // First find the name in the java line, and marks its index Pattern toFind = Pattern.compile(""\\b"" + nodeName.toString() + ""\\b""); Matcher matcher = toFind.matcher(javaLine); int count = 0, index = 0; int lsto = lineElement.getStartOffset(); while(matcher.find()){ count++; //log(matcher.start() + lsto); if(lsto + matcher.start() == nodeName.getStartPosition()) break; } log(""count="" + count); index = 0; // find the same name in the pde line by its index and get its offsets matcher = toFind.matcher(pdeLine); while(matcher.find()){ count--; if(count == 0){ log(""Found on pde line lso: "" + matcher.start()); index = matcher.end(); break; } } log(""pde lso "" + (index - lookingFor.length())); int lso = astGenerator.editor.ta.getLineStartOffset(pdeOffs[1]); astGenerator.editor.setSelection(lso + index - lookingFor.length(), lso + index); */ return true; } catch (BadLocationException e) { Messages.loge(""BLE in highLightNode() for "" + nodeName); e.printStackTrace(); } return false; }"	@param editor	1	0
public <V extends Visitor<? super X>> V visit(V visitor) { for (X x : this) { visitor.visit(x); } return visitor; }	@param predicate Visitor to apply	1	0
"public long getMessageCount(String destinationName) { if (null == brokerService) { throw new IllegalStateException(""BrokerService has not yet been created - was before() called?""); } // TODO: Figure out how to do this for Topics Destination destination = getDestination(destinationName); if (destination == null) { throw new RuntimeException(""Failed to find destination: "" + destinationName); } // return destination.getMessageStore().getMessageCount(); return destination.getDestinationStatistics().getMessages().getCount(); }"	@param fullDestinationName the full name of the JMS Destination	1	0
public boolean searchText(String text, int minimumNumberOfMatches) { boolean found = searcher.searchWithTimeoutFor(TextView.class, text, minimumNumberOfMatches, true); return found; }	@param expectedMinimumNumberOfMatches the minimum number of matches expected to be found. 0 matches means that one or more matches are expected to be found	1	0
public List<WebElement> apply(WebDriver driver) { WebElement current = findElement(parent, driver); List<WebElement> allChildren = current.findElements(childLocator); // The original code only checked the first element. Fair enough. if (!allChildren.isEmpty() && allChildren.get(0).isDisplayed()) { return allChildren; } return null; }	"@param sub_locator used to find child element. For example td By.xpath(""./tr/td"")"	1	0
public Single<Void> rxUpdateUser(String username, User user) { return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> { delegate.updateUser(username, user, fut); })); }	@param body Updated user object (required)	1	0
public boolean searchText(String regex, int matches, boolean scroll) { long now = System.currentTimeMillis(); final long endTime = now + TIMEOUT; while (!searchForText(regex, matches, scroll) && now < endTime) { now = System.currentTimeMillis(); } if(now < endTime) return true; else return false; }	@param search the string to be searched. The parameter will be interpreted as a regular expression.	1	0
public DurationConverter removeDurationConverter(DurationConverter converter) throws SecurityException { checkAlterDurationConverters(); if (converter == null) { return null; } DurationConverter[] removed = new DurationConverter[1]; iDurationConverters = iDurationConverters.remove(converter, removed); return removed[0]; }	@param index the index to remove	1	0
public boolean searchForEditTextWithTimeout(String regex) { long now = System.currentTimeMillis(); final long endTime = now + TIMEOUT; while (!searchForEditText(regex, true) && now < endTime) { sleeper.sleep(); now = System.currentTimeMillis(); } return searchForEditText(regex, true); }	@param search the search string to be searched	1	0
public boolean isSelected(final ToolItem toolItem) { boolean selectionState = Display.syncExec(new ResultRunnable<Boolean>() { @Override public Boolean run() { return toolItem.getSelection(); } }); return selectionState; }	@param w given widget	1	0
public Client testClientModel(Client client, Map<String, Object> params) throws IOException { HttpResponse response = testClientModelForHttpResponse(client, params); TypeReference typeRef = new TypeReference<Client>() {}; return apiClient.getObjectMapper().readValue(response.getContent(), typeRef); }	@param body client model	1	0
public static Granularity extractGranularity(RexNode node) { final int flagIndex; switch (node.getKind()) { case EXTRACT: flagIndex = 0; break; case FLOOR: flagIndex = 1; break; default: return null; } final RexCall call = (RexCall) node; if (call.operands.size() != 2) { return null; } final RexLiteral flag = (RexLiteral) call.operands.get(flagIndex); final TimeUnitRange timeUnit = (TimeUnitRange) flag.getValue(); if (timeUnit == null) { return null; } switch (timeUnit) { case YEAR: return Granularity.YEAR; case QUARTER: return Granularity.QUARTER; case MONTH: return Granularity.MONTH; case WEEK: return Granularity.WEEK; case DAY: return Granularity.DAY; case HOUR: return Granularity.HOUR; case MINUTE: return Granularity.MINUTE; case SECOND: return Granularity.SECOND; default: return null; } }	@param call the function call	1	0
public final File getGeneratedOutput() throws CurnException { return hasGeneratedOutput() ? outputFile : null; }	@return an open input stream, or null if no suitable output was produced	1	0
@Override public String toString() { return annotations.toString(); }	@return The string representation as a comma-separated list of simple annotation names.	1	0
"public static Schema unaliasSchema(Map<String, Schema> allSchemas, Schema schema) { if (allSchemas == null || allSchemas.isEmpty()) { LOGGER.warn(""allSchemas cann't be null/empty in unaliasSchema. Returned 'schema'""); return schema; } if (schema != null && StringUtils.isNotEmpty(schema.get$ref())) { Schema ref = allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())); if (ref == null) { LOGGER.warn(""{} is not defined"", schema.get$ref()); return schema; } else if (isStringSchema(ref) && (ref.getEnum() != null && !ref.getEnum().isEmpty())) { // top-level enum class return schema; } else if (isArraySchema(ref) || isComposedSchema(ref)) { // array def should be created as models return schema; } else if (isMapSchema(ref)) { if (ref.getProperties() != null && !ref.getProperties().isEmpty()) // has properties return schema; // treat it as model else { // treat it as a typical map /* TODO unalias the map item if it's an alias if (ref.getAdditionalProperties() != null) { Schema innerSchema = (Schema) ref.getAdditionalProperties(); if (StringUtils.isNotEmpty(innerSchema.get$ref())) { // map item is a ref to something else //Schema unaliasInnerSchema = unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(innerSchema.get$ref()))); //ref.setAdditionalProperties(unaliasInnerSchema); } }*/ return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()))); } } else if (isObjectSchema(ref)) { // model return schema; } else { return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()))); } } return schema; }"	@return actual schema	0	1
"public AsyncSupport newCometSupport(final Class<? extends AsyncSupport> targetClass) { try { return (AsyncSupport) targetClass.getDeclaredConstructor(new Class[]{AtmosphereConfig.class}) .newInstance(config); } catch (final Exception e) { logger.warn(""Failed to create AsyncSupport class: {}, error: {}"", targetClass, e); return null; // All callers are expected to handle null return value } }"	@return an instance of the specified class	1	0
public ExecutionInfo getParent() { return parentInfo; }	@return the parent type information	0	1
public TwitterTokenStream getDefaultTokenStream() { return tokenizationStream; }	@return {@code TokenStream} to tokenize the text	1	0
"protected Object convertSetToString(List<String> options, Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return """"; } if (data instanceof String) { // JDBC should return strings ... return data; } if (data instanceof Long) { // The binlog will contain a long with the indexes of the options in the set value ... long indexes = ((Long) data).longValue(); return convertSetValue(column, indexes, options); } return handleUnknownData(column, fieldDefn, data); }"	@return the converted value, or null if the conversion could not be made and the column allows nulls	0	1
public boolean isButtonOverflowVisible() { return mIsButtonOverflowVisible; }	@return <code>true</code> if the button is visible and Popup Menu is assigned.	1	0
public ICursor getCursor() { return cursor; }	@return the {@link Cursor} backing this SquidCursor	1	0
public boolean setTaskCompleted(List<FileDownloadTaskAtom> taskAtomList) { return FileDownloadServiceProxy.getImpl().setTaskCompleted(taskAtomList); }	@return Whether is successful to set the task completed. If the path not exist will be false; If the length of the file in path is not equal to totalBytes will be false; If the task with url and path is downloading will be false. Otherwise will be true.	1	0
private ParquetTableMetadata_v4 getParquetTableMetadata(Map<FileStatus, FileSystem> fileStatusMap) throws IOException { Metadata_V4.MetadataSummary tableMetadataSummary = new Metadata_V4.MetadataSummary(SUPPORTED_VERSIONS.last().toString(), DrillVersionInfo.getVersion(), new ArrayList<>()); ParquetTableMetadata_v4 tableMetadata = new ParquetTableMetadata_v4(tableMetadataSummary); List<ParquetFileAndRowCountMetadata> parquetFileAndRowCountMetadata = getParquetFileMetadata_v4(tableMetadata, fileStatusMap, true, null); List<ParquetFileMetadata_v4> parquetFileMetadata = new ArrayList<>(); for (ParquetFileAndRowCountMetadata fileAndGlobalMetadata : parquetFileAndRowCountMetadata) { parquetFileMetadata.add(fileAndGlobalMetadata.getFileMetadata()); } tableMetadata.assignFiles(parquetFileMetadata); return tableMetadata; }	@return parquet table metadata object	0	1
public Iterable<AttributeBinding> getAttributeBindingClosure() { // TODO: update size to account for joins Iterable<AttributeBinding> iterable; if ( superEntityBinding != null ) { List<Iterable<AttributeBinding>> iterables = new ArrayList<Iterable<AttributeBinding>>( 2 ); iterables.add( superEntityBinding.getAttributeBindingClosure() ); iterables.add( attributeBindings() ); iterable = new JoinedIterable<AttributeBinding>( iterables ); } else { iterable = attributeBindings(); } return iterable; }	@return The attribute bindings.	0	1
@Override public Clip getAggregation() { return Clip.of(aggregate); }	@return a List of the combined {@link BulletRecord} so far. The List has a size that is at most the maximum specified by the {@link Aggregation}.	1	0
public ImageView getImage(int index) { return getView(ImageView.class, index); }	@return the ImageView with a specified index or null if index is invalid	0	1
private Color invertBgColor() { if (currentColor_.defaultColor()) { if (!inverted_) clazzes_.add(INVERSE_BG_STYLE); return new Color(); } else if (currentColor_.isExtended()) { clazzes_.add(Color.clazzForColorIndex(currentColor_.code(), true)); return new Color(true, currentColor_.code()); } else if (currentColor_.code() >= FOREGROUND_MIN && currentColor_.code() <= FOREGROUND_MAX) { int newBg = currentColor_.code() + (BACKGROUND_MIN - FOREGROUND_MIN); clazzes_.add(BACKGROUND_STYLE + Integer.toString(newBg - BACKGROUND_MIN)); return new Color(false, newBg); } else { int newBg = currentColor_.code() + (BACKGROUND_INTENSE_MIN - FOREGROUND_INTENSE_MIN); clazzes_.add(BACKGROUND_STYLE + Integer.toString(newBg + NUM - BACKGROUND_INTENSE_MIN)); return new Color(false, newBg); } }	@return new background color based on the supplied foreground color	1	0
protected Project getRightChild(RelOptRuleCall call) { return call.rel(2); }	@return ProjectRel corresponding to the right child	1	0
public final AudioInputStream getSoundChallenge() { return this.challenge; }	@return a Line	1	0
public static long getLongInRange(long minValue, long maxValue) { return (long) (getDoubleInRange(minValue - 0.5, maxValue + 0.5 - (1 / Long.MAX_VALUE)) + 0.5); }	@return A long/Long value between min and max value (included).	0	1
protected Object convertBoolean(Column column, Field fieldDefn, Object data) { return convertValue(column, fieldDefn, data, false, (r) -> { if (data instanceof Boolean) { r.deliver(data); } else if (data instanceof Short) { r.deliver(((Short) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE); } else if (data instanceof Integer) { r.deliver(((Integer) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE); } else if (data instanceof Long) { r.deliver(((Long) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE); } }); }	@return the converted value, or null if the conversion could not be made and the column allows nulls	0	1
public Group[] getGroups() { Item[] items = super.getItems(); Group[] groups = new Group[items.length]; for (int i = NUM; i < groups.length; i++) { groups[i] = (Group) items[i]; } return groups; }	@return an <code>Iterator</code>	1	0
public MetadataBuilder getMetadataBuilder(StandardServiceRegistry serviceRegistry) { MetadataBuilderImpl defaultBuilder = new MetadataBuilderImpl( this, serviceRegistry ); return getCustomBuilderOrDefault( defaultBuilder ); }	@return The built metadata.	0	1
public List<I> joinWithTimeout() { if (timeout < 0) { join(); return new ArrayList<>(); } // Make blocking calls to the last processes that are running if ( ! threadPool.isShutdown()) { try { List<I> leftover = null; int i; for (i = nThreads; i > 0; --i) { if (idleProcessors.poll(timeout, TimeUnit.MILLISECONDS) == null) { leftover = shutdownNow(); break; } } // if the poll hit a timeout, retake the remaining processors // so join() can guarantee the threads are finished if (i > 0) { for ( ; i > leftover.size(); --i) { idleProcessors.take(); } return leftover; } else { threadPool.shutdown(); // Sanity check. The threadpool should be done after iterating over // the processors. threadPool.awaitTermination(10, TimeUnit.SECONDS); } } catch (InterruptedException e) { throw new RuntimeInterruptedException(e); } } return new ArrayList<>(); }	@return a list of jobs which had never been started if timeout was reached, or null if that did not happen.	1	0
protected final Iterator<SyntaxTreeNode> elements() { return _contents.iterator(); }	@return An Enumeration of all child nodes of this node.	1	0
"public static SchemaBuilder builder() { return SchemaBuilder.struct() .name(LOGICAL_NAME) .version(1) .doc(""Geometry (POINT)"") .field(X_FIELD, Schema.FLOAT64_SCHEMA) .field(Y_FIELD, Schema.FLOAT64_SCHEMA) .field(WKB_FIELD, Schema.OPTIONAL_BYTES_SCHEMA) .field(SRID_FIELD, Schema.OPTIONAL_INT32_SCHEMA); }"	@return the schema builder	0	1
public static HashMap getXmlRpcWorkflowInstancePage(WorkflowInstancePage page) { HashMap pageHash = new HashMap(); pageHash.put(STR, String.valueOf(page.getTotalPages())); pageHash.put(STR, String.valueOf(page.getPageNum())); pageHash.put(STR, String.valueOf(page.getPageSize())); pageHash.put(STR, getXmlRpcWorkflowInstances(page.getPageWorkflows())); return pageHash; }	@return A {@link Hashtable} representation of a {@link WorkflowInstancePage}.	1	0
public List<TestSuite> getSuite() { return this.testSuites; }	@return the parsed Test Suite or null if no Test Suite was found.	1	0
public void offer(T item, double incrementCount) { Counter<T> counterNode = counterMap.get(item); if (counterNode == null) { counterNode = new Counter<T>(item, incrementCount); counterMap.put(item, counterNode); counterList.add(counterNode); } else { counterNode.setCount(counterNode.getCount() + incrementCount); } ordered = false; }	@return false if item was already in the stream summary, true otherwise	0	1
@SuppressWarnings(STR) public static String append(final String url, final Map<String, ?> params) { if (params == null || params.isEmpty()) return url; final StringBuilder result = new StringBuilder(url); int firstColon = url.indexOf(STR); int lastSlash = url.lastIndexOf(STR); if (firstColon + NUM == lastSlash) result.append(STR); result.append(STR); Entry<String, ?> entry; Object value; Iterator<?> iterator = params.entrySet().iterator(); entry = (Entry<String, ?>) iterator.next(); result.append(entry.getKey()); result.append(STR); value = entry.getValue(); if (value != null) result.append(value); while (iterator.hasNext()) { result.append(STR); entry = (Entry<String, ?>) iterator.next(); result.append(entry.getKey()); result.append(STR); value = entry.getValue(); if (value != null) result.append(value); } return result.toString(); }	@return URL with query params	1	0
public static Set<String> getDeclaredInstanceFields(Class<?> clazz) { List<Class<? extends Annotation>> excludedAnnotations = new ArrayList<Class<? extends Annotation>>(); excludedAnnotations.add(PodamExclude.class); return getDeclaredInstanceFields(clazz, excludedAnnotations); }	@return Set of a class declared field names.	0	1
public static List<CmdLineOptionValidator.Result> validate(CmdLineArgs cmdLineArgs) { Validate.notNull(cmdLineArgs); List<CmdLineOptionValidator.Result> results = Lists.newArrayList(); for (CmdLineOptionInstance optionInst : cmdLineArgs.getSpecifiedOptions()) { results.addAll(CmdLineUtils.validate(optionInst)); } return results; }	@return The {@link CmdLineOptionInstance}s which failed validation.	1	0
public static double logAdd(double lx, double ly) { double max, negDiff; if (lx > ly) { max = lx; negDiff = ly - lx; } else { max = ly; negDiff = lx - ly; } return (max == Double.NEGATIVE_INFINITY || negDiff < -LOGTOLERANCE) ? max : // max + Math.log(1 + Math.exp(negDiff)); }	@return log(exp(lx) + exp(ly))	0	1
public ModuleJarClassLoader getLoader() { return loader; }	@return ModuleClassLoader	1	0
public static DateTimeFormatter tTimeNoMillis() { return Constants.ttx; }	@return a formatter for 'T'HH:mm:ssZZ	0	1
public boolean hasReminder() { return reminder != null; }	@return true if habit has reminder	1	0
public List<SqlTypeName> getTypeNames() { switch (this) { case CHARACTER: return SqlTypeName.charTypes; case BINARY: return SqlTypeName.binaryTypes; case NUMERIC: return SqlTypeName.numericTypes; case DATE: return ImmutableList.of(SqlTypeName.DATE); case TIME: return ImmutableList.of(SqlTypeName.TIME); case TIMESTAMP: return ImmutableList.of(SqlTypeName.TIMESTAMP); case BOOLEAN: return SqlTypeName.booleanTypes; case INTERVAL_YEAR_MONTH: return ImmutableList.of(SqlTypeName.INTERVAL_YEAR_MONTH); case INTERVAL_DAY_TIME: return ImmutableList.of(SqlTypeName.INTERVAL_DAY_TIME); case STRING: return SqlTypeName.stringTypes; case APPROXIMATE_NUMERIC: return SqlTypeName.approxTypes; case EXACT_NUMERIC: return SqlTypeName.exactTypes; case INTEGER: return SqlTypeName.intTypes; case DATETIME: return SqlTypeName.datetimeTypes; case DATETIME_INTERVAL: return SqlTypeName.intervalTypes; case MULTISET: return ImmutableList.of(SqlTypeName.MULTISET); case ARRAY: return ImmutableList.of(SqlTypeName.ARRAY); case MAP: return ImmutableList.of(SqlTypeName.MAP); case NULL: return ImmutableList.of(SqlTypeName.NULL); case ANY: return SqlTypeName.allTypes; case CURSOR: return ImmutableList.of(SqlTypeName.CURSOR); case COLUMN_LIST: return ImmutableList.of(SqlTypeName.COLUMN_LIST); default: throw new IllegalArgumentException(); } }	@return collection of SqlTypeNames included in this family	0	1
public GremlinPipeline<S, Map<String, Object>> map() { return this.add(new PropertyMapPipe()); }	@return the extended FluentPipeline	1	0
"public static String findReg() { if (reg != null) return reg; File systemRoot = findSystemRoot(); File regExe = new File(systemRoot, ""system32/reg.exe""); if (regExe.exists()) { reg = regExe.getAbsolutePath(); return reg; } regExe = new File(""c:\\ntreskit""); if (regExe.exists()) { reg = regExe.getAbsolutePath(); return reg; } regExe = AsyncExecute.whichExec(""reg.exe""); if (regExe != null && regExe.exists()) { reg = regExe.getAbsolutePath(); return reg; } System.err.println(""OS Version: "" + System.getProperty(""os.version"")); throw new RuntimeException(""Couldn't find reg.exe!\n"" + ""Please download it from Microsoft and install it in a standard location.\n"" + ""See here for details: http://wiki.openqa.org/display/SRC/Windows+Registry+Support""); }"	"@return the exact path to reg.exe, or just the string ""reg"" if it couldn't be found (in which case you can pass that to exec to try to run it from the path)"	0	1
public static Method findGetMethod(Field field, boolean throwExceptions) throws IllegalArgumentException { Method fieldGetMethod; if (Locale.ENGLISH.equals(Locale.getDefault())) { fieldGetMethod = findMethodFromNames(field, true, throwExceptions, methodFromField(field, STR, null), methodFromField(field, STR, null)); } else { fieldGetMethod = findMethodFromNames(field, true, throwExceptions, methodFromField(field, STR, null), methodFromField(field, STR, Locale.ENGLISH), methodFromField(field, STR, null), methodFromField(field, STR, Locale.ENGLISH)); } if (fieldGetMethod == null) { return null; } if (fieldGetMethod.getReturnType() != field.getType()) { if (throwExceptions) { throw new IllegalArgumentException(STR + fieldGetMethod.getName() + STR + field.getType()); } else { return null; } } return fieldGetMethod; }	@return Get method or null if none found.	1	0
public synchronized long getAcceptedTime() { return acceptedTime; }	@return when the work has ben accepted.	1	0
private boolean areViewsIdentical(View firstView, View secondView){ if(firstView.getId() != secondView.getId() || !firstView.getClass().isAssignableFrom(secondView.getClass())){ return false; } if (firstView.getParent() != null && firstView.getParent() instanceof View && secondView.getParent() != null && secondView.getParent() instanceof View) { return areViewsIdentical((View) firstView.getParent(), (View) secondView.getParent()); } else { return true; } }	@return true if views are equal	0	1
public List<InstanceInfo> getInstancesByVirtualHostName(String virtualHostName) { return Optional.ofNullable(this.virtualHostNameAppMap.get(virtualHostName.toUpperCase(Locale.ROOT))) .map(VipIndexSupport::getVipList) .map(AtomicReference::get) .orElseGet(Collections::emptyList); }	@return list of instances.	0	1
public Builder host(String host) { this.host = host; return this; }	@return ping host	1	0
@SuppressWarnings(STR) public ObjectName getExchangeObjectName(String virtualHostName, String exchange) { AllObjects allObject = new AllObjects(_mbsc); allObject.querystring = STR + virtualHostName + STR + exchange + STR; Set<ObjectName> objectNames = allObject.returnObjects(); _test.assertNotNull(STR, objectNames); _test.assertEquals(STR + exchange + STR, NUM, objectNames.size()); ObjectName objectName = objectNames.iterator().next(); _test.getLogger().info(STR + objectName); return objectName; }	@return the ObjectName for the given exchange on the test VirtualHost.	1	0
public static char[] union(char[]... list) { StringBuilder sb = new StringBuilder(); for (char[] characters : list) { for (int i = NUM; i < list.length; i++) { if (!contains(sb, characters[i])) sb.append(list[i]); } } char[] toReturn = new char[sb.length()]; sb.getChars(NUM, sb.length(), toReturn, NUM); Arrays.sort(toReturn); return toReturn; }	@return the char[]	1	0
public FeatureService createFeatureService() { return createFeatureService(defaultEndpointUrl); }	@return a new feature service with the default server URL	1	0
public static ActiveMQConnectionFactory createConnectionFactoryWithoutHA(JMSFactoryType jmsFactoryType, final TransportConfiguration... transportConfigurations) { ActiveMQConnectionFactory factory = null; if (jmsFactoryType.equals(JMSFactoryType.CF)) { factory = new ActiveMQJMSConnectionFactory(false, transportConfigurations); } else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_CF)) { factory = new ActiveMQQueueConnectionFactory(false, transportConfigurations); } else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_CF)) { factory = new ActiveMQTopicConnectionFactory(false, transportConfigurations); } else if (jmsFactoryType.equals(JMSFactoryType.XA_CF)) { factory = new ActiveMQXAConnectionFactory(false, transportConfigurations); } else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_XA_CF)) { factory = new ActiveMQXAQueueConnectionFactory(false, transportConfigurations); } else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_XA_CF)) { factory = new ActiveMQXATopicConnectionFactory(false, transportConfigurations); } return factory; }	@return the HornetQConnectionFactory	1	0
public ExtensionHandler getExtensionHandler() { return generatorContext.getExtensionHandler(); }	@return the extension handler used by this SVGGraphics2D instance	1	0
"public static ExpectedCondition<Boolean> titleContains(final String title) { return new ExpectedCondition<Boolean>() { private String currentTitle = """"; public Boolean apply(WebDriver driver) { currentTitle = driver.getTitle(); return currentTitle != null && currentTitle.contains(title); } @Override public String toString() { return String.format(""title to contain \""%s\"". Current title: \""%s\"""", title, currentTitle); } }; }"	@return true when the title matches, false otherwise	0	1
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 6: { return getEllipsis(); } case 8: break; case 4: { return getNext(false); } case 9: break; case 7: { if ( ! removeProMarker) { return getNext(false); } } case 10: break; case 2: { return getNewline(); } case 11: break; case 5: { return getNext(true); } case 12: break; case 3: { } case 13: break; case 1: { System.err.printf(""Untokenizable: %s%n"", yytext()); return getNext(true); } case 14: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }"	@return the next token	0	1
public MetricFilter getFilter() { final StringMatchingStrategy stringMatchingStrategy = getUseRegexFilters() ? REGEX_STRING_MATCHING_STRATEGY : DEFAULT_STRING_MATCHING_STRATEGY; return new MetricFilter() { @Override public boolean matches(final String name, final Metric metric) { // Include the metric if its name is not excluded and its name is included // Where, by default, with no includes setting, all names are included. return !stringMatchingStrategy.containsMatch(getExcludes(), name) && (getIncludes().isEmpty() || stringMatchingStrategy.containsMatch(getIncludes(), name)); } }; }	@return the filter for selecting metrics based on the configured excludes/includes.	0	1
public Object getProperty(String name) { if (name == null || !isPropertySupported(name)) throw new IllegalArgumentException(); return callProperties.get(name); }	@return Object value of the property - or null	1	0
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 35: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, yytext()); } case 50: break; case 8: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 51: break; case 19: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 52: break; case 47: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; // try to work around an apparent jflex bug where it // gets a space at the token end by getting // wrong the length of the trailing context. while (yylength() > 0) { char last = yycharat(yylength()-1); if (last == ' ' || last == '\t' || (last >= '\n' && last <= '\r' || last == '\u0085')) { yypushback(1); } else { break; } } if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 53: break; case 15: { return handleQuotes(yytext(), false); } case 54: break; case 32: // lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), false); } case 55: break; case 24: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 56: break; case 30: // lookahead expression with fixed lookahead length yypushback(1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 57: break; case 44: // lookahead expression with fixed lookahead length yypushback(1); { return getNormalizedAmpNext(); } case 58: break; case 31: { return getNormalizedAmpNext(); } case 59: break; case 34: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, yytext()); } case 60: break; case 48: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 4; { return getNext(); } case 61: break; case 40: // lookahead expression with fixed lookahead length yypushback(2); { return getNext(); } case 62: break; case 38: // general lookahead, find correct zzMarkedPos { int zzFState = 13; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 12; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 63: break; case 37: // general lookahead, find correct zzMarkedPos { int zzFState = 11; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 12; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 64: break; case 4: { return getNext(); } case 65: break; case 21: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(); } case 66: break; case 46: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } return getNext(txt, yytext()); } case 67: break; case 23: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, origTxt); } case 68: break; case 6: { if (normalizeOtherBrackets) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 69: break; case 7: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 70: break; case 28: // general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 71: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 72: break; case 43: { yypushback(2) ; return getNext(); } case 73: break; case 25: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 74: break; case 18: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 75: break; case 49: { String txt = yytext(); if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 76: break; case 45: { yypushback(3) ; return getNext(); } case 77: break; case 22: // lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), true); } case 78: break; case 2: { if (normalizeOtherBrackets) { return getNext(openparen, yytext()); } else { return getNext(); } } case 79: break; case 36: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 80: break; case 20: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 81: break; case 17: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 82: break; case 11: { return handleEllipsis(yytext()); } case 83: break; case 33: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 1; { /* invert quote - often but not always right */ return handleQuotes(yytext(), true); } case 84: break; case 13: { return normalizeFractions(yytext()); } case 85: break; case 14: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(); } } case 86: break; case 41: // general lookahead, find correct zzMarkedPos { int zzFState = 9; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 10; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 87: break; case 10: { if (invertible) { prevWordAfter.append(yytext()); } } case 88: break; case 3: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 89: break; case 42: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 90: break; case 12: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 91: break; case 27: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 92: break; case 9: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 93: break; case 29: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 94: break; case 26: { // this one should only match if we're basically at the end of file // since the last one matches two things, even newlines String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 95: break; case 1: { String str = yytext(); int first = str.charAt(0); String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } LOGGER.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: LOGGER.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 96: break; case 39: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 97: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 98: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }"	@return the next token	0	1
public int decodable(QpidByteBuffer in) { return (in.remaining() >= NUM) ? NUM : NUM - in.remaining(); }	@return true if we have enough data to decode the PI frame fully, false if more data is required	1	0
"private ZapMenuItem getMenuHelpAbout() { if (menuHelpAbout == null) { menuHelpAbout = new ZapMenuItem(""menu.help.about""); menuHelpAbout.addActionListener(new java.awt.event.ActionListener() { @Override public void actionPerformed(java.awt.event.ActionEvent e) { AboutDialog dialog = new AboutDialog(View.getSingleton().getMainFrame(), true); dialog.setVisible(true); } }); } return menuHelpAbout; }"	@return javax.swing.JMenuItem	1	0
"public HBaseResponse getHTableInfo(String tableName) throws IOException { HBaseResponse hr = htableInfoCache.getIfPresent(tableName); if (null != hr) { return hr; } hr = new HBaseResponse(); if (""hbase"".equals(getConfig().getMetadataUrl().getScheme())) { try { // use reflection to isolate NoClassDef errors when HBase is not available hr = (HBaseResponse) Class.forName(""org.apache.kylin.rest.service.HBaseInfoUtil"")// .getMethod(""getHBaseInfo"", new Class[] { String.class, KylinConfig.class })// .invoke(null, tableName, this.getConfig()); } catch (Throwable e) { throw new IOException(e); } } htableInfoCache.put(tableName, hr); return hr; }"	@return The HBaseResponse object contains table size, region count. null if error happens	0	1
public WireType getWireType() { return queue.wireType(); }	@return the wireType	1	0
@Override public int hashCode() { int hash = NUM; hash = hash * NUM + Double.valueOf(getRank()).hashCode(); hash = hash * NUM + mUrlDevice.hashCode(); hash = hash * NUM + mPwsResult.hashCode(); return hash; }	@return 42.	1	0
public Debugger getDebugger() { return debugger; }	@return the debugger controller object	0	1
public LockMode getAliasSpecificLockMode(String alias) { if ( aliasSpecificLockModes == null ) { return null; } return (LockMode) aliasSpecificLockModes.get( alias ); }	@return The explicit lock mode for that alias.	0	1
public String getMatches() { StringBuilder sb = new StringBuilder(); for (int i = NUM, sz = list.getModel().getSize(); i < sz; i++) { Tree t = ((TreeFromFile) list.getModel().getElementAt(i)).getTree(); sb.append(t.pennString()); sb.append(STR); } return sb.toString(); }	@return StringBuffer filled with the penn treebank forms of all trees in the matches panel	1	0
"public static boolean hasPermissions(Context context, String... perms) { // Always return true for SDK < M, let the system deal with the permissions if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) { Log.w(TAG, ""hasPermissions: API version < M, returning true by default""); return true; } for (String perm : perms) { boolean hasPerm = (ContextCompat.checkSelfPermission(context, perm) == PackageManager.PERMISSION_GRANTED); if (!hasPerm) { return false; } } return true; }"	@return true if all permissions are already granted, false if at least one permission is not yet granted.	0	1
public Short getShort(AttributeMetadata attributeMetadata) { return (short)getInteger(Short.MAX_VALUE); }	@return A short/Short value.	0	1
protected AuthenticationInfo doMultiRealmAuthentication(Collection<? extends Realm> realms, AuthenticationToken token) { ModularAuthenticationStrategy strategy = getModularAuthenticationStrategy(); AuthenticationInfo aggregate = strategy.beforeAllAttempts(realms, token); if (log.isDebugEnabled()) { log.debug(STR + realms.size() + STR); } for (Realm realm : realms) { if (realm.supports(token)) { if (log.isDebugEnabled()) { log.debug(STR + token + STR + STR + realm + STR); } AuthenticationInfo info = null; Throwable t = null; try { info = realm.getAuthenticationInfo(token); } catch (Throwable throwable) { t = throwable; if (log.isTraceEnabled()) { String msg = STR + realm + STR; log.trace(msg, t); } } aggregate = strategy.afterAttempt(realm, token, info, aggregate, t); } else { if (log.isDebugEnabled()) { log.debug(STR + realm + STR + STR + token + STR); } } } aggregate = strategy.afterAllAttempts(token, aggregate); return aggregate; }	@return an aggregated Account instance representing account data across all the successfully consulted realms.	1	0
public Double getNdv(SchemaPath col) { // Stats might not have materialized because of errors. if (!materialized) { return null; } Long ndvCol = ndv.get(col); // Ndv estimation techniques like HLL may over-estimate, hence cap it at rowCount if (ndvCol != null) { return (double) Math.min(ndvCol, rowCount); } return null; }	@return approximate count distinct of the column, if available. NULL otherwise.	0	1
"public static Value astFromValue(Object value, GraphQLType type) { if (value == null) { return null; } if (isNonNull(type)) { return handleNonNull(value, (GraphQLNonNull) type); } // Convert JavaScript array to GraphQL list. If the GraphQLType is a list, but // the value is not an array, convert the value using the list's item type. if (isList(type)) { return handleList(value, (GraphQLList) type); } // Populate the fields of the input object by creating ASTs from each value // in the JavaScript object according to the fields in the input type. if (type instanceof GraphQLInputObjectType) { return handleInputObject(value, (GraphQLInputObjectType) type); } if (!(type instanceof GraphQLScalarType || type instanceof GraphQLEnumType)) { throw new AssertException(""Must provide Input Type, cannot use: "" + type.getClass()); } // Since value is an internally represented value, it must be serialized // to an externally represented value before converting into an AST. final Object serialized = serialize(type, value); if (isNullish(serialized)) { return null; } // Others serialize based on their corresponding JavaScript scalar types. if (serialized instanceof Boolean) { return BooleanValue.newBooleanValue().value((Boolean) serialized).build(); } String stringValue = serialized.toString(); // numbers can be Int or Float values. if (serialized instanceof Number) { return handleNumber(stringValue); } if (serialized instanceof String) { // Enum types use Enum literals. if (type instanceof GraphQLEnumType) { return EnumValue.newEnumValue().name(stringValue).build(); } // ID types can use Int literals. if (type == Scalars.GraphQLID && stringValue.matches(""^[0-9]+$"")) { return IntValue.newIntValue().value(new BigInteger(stringValue)).build(); } // String types are just strings but JSON'ised return StringValue.newStringValue().value(stringValue).build(); } throw new AssertException(""'Cannot convert value to AST: "" + serialized); }"	@return a grapql language ast Value	1	0
public static boolean isWebpNativelySupported(ImageFormat webpFormat) { switch (webpFormat) { case WEBP_SIMPLE: // Simple WebPs are supported on Android 4.0+ return Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH; case WEBP_LOSSLESS: case WEBP_EXTENDED: case WEBP_EXTENDED_WITH_ALPHA: return WebpSupportStatus.sIsExtendedWebpSupported; case WEBP_ANIMATED: return false; default: Preconditions.checkArgument(false); return false; } }	@return true if given type of WebP is supported natively by the framework	0	1
public Menu getControlMenu(final Control c) { Menu controlMenu = ControlHandler.getInstance().getMenu(c); if (controlMenu == null) { throw new CoreLayerException(c.getClass() + STR); } return controlMenu; }	@return menu placed under specified control	1	0
public static String addPropertiesToURI(URI uri, Map<String, String> properties) throws Exception { return addPropertiesToURI(uri.toString(), properties); }	@return uri with properties on	1	0
private boolean isZoomed() { return mNormalizedScale != 1; }	@return true if image is zoomed	0	1
"protected static boolean shouldInjectOnCreateView(String name) { return false; // && Character.isLowerCase(name.charAt(0)) && !name.startsWith(""com.android"") && !name.equals(""fragment""); }"	@return true if name begins with a lowercase character (indicating a package) and it doesn't start with com.android	0	1
public SortedSet<String> getUsedNames() { return Collections.unmodifiableSortedSet(mUsedNames); }	@return A list of all of the names that have already been used.	1	0
public DateTimeFormatterBuilder appendClockhourOfHalfday(final int minDigits) { return appendDecimal(iChronoUTC.clockhourOfHalfday(), minDigits, 2); }	@return this DateTimeFormatterBuilder	0	1
public String getHandle() { if (consoleProcess_ == null) { return terminalHandle_; } return consoleProcess_.getProcessInfo().getHandle(); }	@return Opaque string handle for this terminal instance, or null if terminal has never been attached to a process	1	0
public AggregateCall copy(List<Integer> args, int filterArg) { // ignoring collation is error-prone return copy(args, filterArg, collation); }	@return AggregateCall that suits new inputs and GROUP BY columns	0	1
private static boolean returnsJustFirstInput(RelNode joinRel) { // SemiJoin, CorrelateSemiJoin, CorrelateAntiJoin: right fields are not returned return (joinRel instanceof Join && !((Join) joinRel).getJoinType().projectsRight()) || (joinRel instanceof Correlate && !((Correlate) joinRel).getJoinType().projectsRight()); }	@return whether at least one filter was pushed	0	1
public boolean remove(Tag tag) { return mSelectedTopics.remove(tag); }	@return boolean Returns a boolean to indicate whether the operation was successful.	1	0
public int getIndexOf(Object object) { int index = tableModel.getUsers().indexOf(object); if (index < 0 && customUsers != null) return ArrayUtils.indexOf(customUsers, object); return index; }	@return The index of the specified element in the model's item list.	1	0
public long get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }	@return the value of this attribute if this attribute is present in the map. Otherwise {@link #getDefaultValue()}	1	0
public Map<String, Integer> parameters() { HashMap<String, Integer> values = new HashMap<>(); values.put(STR, this.x); values.put(STR, this.y); values.put(STR, this.z); return Collections.unmodifiableMap(values); }	@return returns all axis mapped to an ImmutableMap	1	0
public Definition emit(Class cls, String allowedMethods) throws Exception { this.cls = cls; this.allowedMethods = allowedMethods; String name = cls.getName(); name = name.substring(name.lastIndexOf(STR) + NUM); setServiceName(name); return emit(); }	@return WSDL <code>Document</code>	1	0
public boolean isValid(boolean fail) { if (!super.isValid(fail)) { assert !fail; return false; } if (!RexUtil.compatibleTypes( exps, getRowType(), true)) { assert !fail; return false; } RexChecker checker = new RexChecker( getInput().getRowType(), fail); for (RexNode exp : exps) { exp.accept(checker); } if (checker.getFailureCount() > 0) { assert !fail; return false; } if (!Util.isDistinct(rowType.getFieldNames())) { assert !fail : rowType; return false; } //CHECKSTYLE: IGNORE 1 if (false && !Util.isDistinct( Functions.adapt( exps, new Function1<RexNode, Object>() { public Object apply(RexNode a0) { return a0.toString(); } }))) { // Projecting the same expression twice is usually a bad idea, // because it may create expressions downstream which are equivalent // but which look different. We can't ban duplicate projects, // because we need to allow // // SELECT a, b FROM c UNION SELECT x, x FROM z assert !fail : exps; return false; } return true; }	@return List of (expression, name) pairs	0	1
private List<Long> getRcsRawContactIdFromPhoneNumber(String phoneNumber) { List<Long> contactsIds = new ArrayList<Long>(); String[] projection = { Data.RAW_CONTACT_ID }; String selection = Data.MIMETYPE + STR + Phone.NUMBER + STR; String[] selectionArgs = { MIMETYPE_NUMBER, phoneNumber }; String sortOrder = Data.RAW_CONTACT_ID; Cursor cur = ctx.getContentResolver().query(Data.CONTENT_URI, projection, selection, selectionArgs, sortOrder); if (cur != null) { while (cur.moveToNext()) { long rcsRawContactId = cur.getLong(cur.getColumnIndex(Data.RAW_CONTACT_ID)); contactsIds.add(rcsRawContactId); } cur.close(); } return contactsIds; }	@return contactId, if not found INVALID_ID is returned	1	0
public Single<Bitmap> cropAsSingle(final Uri sourceUri) { return Single.fromCallable(new Callable<Bitmap>() { @Override public Bitmap call() throws Exception { if (sourceUri != null) mSourceUri = sourceUri; return cropImage(); } }).doOnSubscribe(new Consumer<Disposable>() { @Override public void accept(@NonNull Disposable disposable) throws Exception { mIsCropping.set(true); } }).doFinally(new Action() { @Override public void run() throws Exception { mIsCropping.set(false); } }); }	@return Single of cropping image	0	1
"private boolean waitUntilResume(Runnable run, boolean deletePreviousRunnables) { if (mPaused) { Log.i(TAG, ""Deferring update until onResume""); if (deletePreviousRunnables) { while (mBindOnResumeCallbacks.remove(run)) { } } mBindOnResumeCallbacks.add(run); return true; } else { return false; } }"	@return true if we are currently paused. The caller might be able to skip some work	1	0
static public ContentionManager getContentionManager() { return cm; }	@return the invoking thread's contention manager	1	0
public int track(IProgressMonitor monitor) throws CoreException, OperationCanceledException { long currentTime = System.currentTimeMillis(); long totalTime = currentTime + timeout; CloudFoundryServerBehaviour behaviour = cloudServer.getBehaviour(); String appName = appModule.getDeployedApplicationName(); printlnToConsole(NLS.bind(Messages.ApplicationInstanceStartingTracker_STARTING_TRACKING, appName), appModule); int state = IServer.STATE_UNKNOWN; while (state != IServer.STATE_STARTED && state != IServer.STATE_STOPPED && currentTime < totalTime) { if (monitor != null && monitor.isCanceled()) { String error = NLS.bind(Messages.ApplicationInstanceStartingTracker_APPLICATION_CHECK_CANCELED, appName); printlnToConsole(error, appModule); throw new OperationCanceledException(error); } CloudApplication cloudApp = behaviour.getCloudApplication(appName, monitor); ApplicationStats applicationStats = behaviour.getApplicationStats(appName, monitor); if (cloudApp == null) { String error = NLS.bind(Messages.ApplicationInstanceStartingTracker_APPLICATION_NOT_EXISTS, appName); printlnToConsole(error, appModule); throw CloudErrorUtil.toCoreException(error); } else { state = CloudFoundryApplicationModule.getCloudState(cloudApp, applicationStats); try { Thread.sleep(WAIT_TIME); } catch (InterruptedException e) { } currentTime = System.currentTimeMillis(); } } String runningStateMessage = state == IServer.STATE_STARTED ? NLS.bind(Messages.ApplicationInstanceStartingTracker_APPLICATION_IS_RUNNING, appName) : NLS.bind(Messages.ApplicationInstanceStartingTracker_APPLICATION_IS_NOT_RUNNING, appName); printlnToConsole(runningStateMessage, appModule); return state; }	@return One of the following application running states: {@link IServer#STATE_STARTED}, {@link IServer#STATE_STARTING}, {@link IServer#STATE_STOPPED}, {@link IServer#STATE_STOPPING}, {@link IServer#STATE_UNKNOWN}	1	0
public Double getAverageRowSize(RelNode rel) { for (;;) { try { return sizeHandler.averageRowSize(rel, this); } catch (JaninoRelMetadataProvider.NoHandler e) { sizeHandler = metadataProvider.revise(e.relClass, BuiltInMetadata.Size.DEF); } } }	@return average size of a row, in bytes, or null if not known	0	1
protected Object convertTimeToNanosPastMidnight(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0L; // return epoch } try { return NanoTime.toNanoOfDay(data); } catch (IllegalArgumentException e) { return handleUnknownData(column, fieldDefn, data); } }	@return the converted value, or null if the conversion could not be made	1	0
public Iterable<RelNode> getRels() { return new Iterable<RelNode>() { public Iterator<RelNode> iterator() { return Linq4j.asEnumerable(set.rels) .where( new Predicate1<RelNode>() { public boolean apply(RelNode v1) { return v1.getTraitSet().subsumes(traitSet); } }) .iterator(); } }; }	@return all the rels in the subset	0	1
public DateTime setCopy(int value) { return iInstant.withMillis(iField.set(iInstant.getMillis(), value)); }	@return a copy of the DateTime with the field value changed	0	1
public RepositoryMethodMetadata lookupMethod(RepositoryMetadata repositoryMetadata, Method method) { return repositoryMetadata.getMethodsMetadata().get(method); }	@return A {@link RepositoryMethodMetadataInitializer} corresponding to the method parameter.	1	0
"public String toString() { return String.format(""%s:%s:%s%s%s%s"", path, volume.getPath(), accessMode.toString(), secMode != SELContext.none ? "","" + secMode.toString() : """", noCopy != null ? "",nocopy"" : """", propagationMode != PropagationMode.DEFAULT_MODE ? "","" + propagationMode.toString() : """"); }"	@return a string representation of this Bind	0	1
public static HashMap getXmlRpcWorkflow(Workflow w) { HashMap workflow = new HashMap(); workflow.put(STR, w.getId()); workflow.put(STR, w.getName() != null ? w.getName() : STR); workflow.put(STR, getXmlRpcWorkflowTasks(w.getTasks())); workflow.put(STR, getXmlRpcWorkflowConditions(w.getConditions())); return workflow; }	@return A {@link Hashtable} representation of a {@link Workflow}.	1	0
"public static RelNode qualifyPartitionCol(RelNode input, List<String> partitionColumns) { final RelDataType inputRowType = input.getRowType(); final List<RexNode> colRefStarExprs = Lists.newArrayList(); final List<String> colRefStarNames = Lists.newArrayList(); final RexBuilder builder = input.getCluster().getRexBuilder(); final int originalFieldSize = inputRowType.getFieldCount(); for (final String col : partitionColumns) { final RelDataTypeField field = inputRowType.getField(col, false, false); if (field == null) { throw UserException.validationError() .message(""Partition column %s is not in the SELECT list of CTAS!"", col) .build(logger); } else { if (SchemaPath.DYNAMIC_STAR.equals(field.getName())) { colRefStarNames.add(col); final List<RexNode> operands = Lists.newArrayList(); operands.add(new RexInputRef(field.getIndex(), field.getType())); operands.add(builder.makeLiteral(col)); final RexNode item = builder.makeCall(SqlStdOperatorTable.ITEM, operands); colRefStarExprs.add(item); } } } if (colRefStarExprs.isEmpty()) { return input; } else { final List<String> names = new AbstractList<String>() { @Override public String get(int index) { if (index < originalFieldSize) { return inputRowType.getFieldNames().get(index); } else { return colRefStarNames.get(index - originalFieldSize); } } @Override public int size() { return originalFieldSize + colRefStarExprs.size(); } }; final List<RexNode> refs = new AbstractList<RexNode>() { @Override public int size() { return originalFieldSize + colRefStarExprs.size(); } @Override public RexNode get(int index) { if (index < originalFieldSize) { return RexInputRef.of(index, inputRowType.getFieldList()); } else { return colRefStarExprs.get(index - originalFieldSize); } } }; return DrillRelFactories.LOGICAL_BUILDER .create(input.getCluster(), null) .push(input) .projectNamed(refs, names, true) .build(); } }"	@return : 1) the original RelNode input, if all partition columns are in select list of CTAS 2) a New Project, if a partition column is resolved to column in select list 3) validation error, if partition column is not resolved.	0	1
public int getClientY() { if (null != details) { return details.getClientY(); } else { return -NUM; } }	@return The mouse cursor y position	1	0
public static double min(double... vector) { double min = Double.POSITIVE_INFINITY; for (double x : vector) { if (x < min) { min = x; } } return min; }	@return The minimum value in an array.	0	1
@GET public Set<CassandraInstance> findAll() { return service.findAll(); }	@return the list of Cassandra instances	1	0
private HttpPanelResponse getResponsePanel() { if (responsePanel == null) { responsePanel = new HttpPanelResponse(false, extension, httpMessage); } return responsePanel; }	@return org.parosproxy.paros.view.HttpPanel	0	1
public LocalTime withMaximumValue() { return setCopy(getMaximumValue()); }	@return a copy of the LocalTime with this field set to its maximum	0	1
public String[] checkAllWords(String words) { List<String> misspelledWords = new ArrayList<String>(); StringWordTokenizer tokenizer = new StringWordTokenizer(words); while (tokenizer.hasMoreWords()) { String word = tokenizer.nextWord(); if (!isWordCorrect(word, tokenizer.isNewSentence())) { misspelledWords.add(word); } } return misspelledWords.toArray(new String[NUM]); }	@return string array of misspelt words	1	0
public String getInitParameter(String name) { try { String value = framework.getServletConfig().getInitParameter(name); if (value == null) { value = framework.getServletContext().getInitParameter(name); } return value; } catch (Throwable ex) { return null; } }	@return the list of init params defined in web.xml or application.xml	1	0
"public ExecutionStepInfo changeTypeWithPreservedNonNull(GraphQLType newType) { assertTrue(!GraphQLTypeUtil.isNonNull(newType), ""newType can't be non null""); if (isNonNullType()) { return new ExecutionStepInfo(GraphQLNonNull.nonNull(newType), fieldDefinition, field, path, this.parent, arguments, directives); } else { return new ExecutionStepInfo(newType, fieldDefinition, field, path, this.parent, arguments, directives); } }"	@return a new type info with the same	0	1
public List<FxType> getDerivedTypes() { return Collections.unmodifiableList(derivedTypes); }	@return Iterator of all derived types	1	0
protected Object convertBit(Column column, Field fieldDefn, Object data) { return convertValue(column, fieldDefn, data, false, (r) -> { if (data instanceof Boolean) { r.deliver(data); } else if (data instanceof Short) { r.deliver(((Short) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE); } else if (data instanceof Integer) { r.deliver(((Integer) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE); } else if (data instanceof Long) { r.deliver(((Long) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE); } else if (data instanceof BitSet) { BitSet value = (BitSet) data; r.deliver(value.get(0)); } }); }	@return the converted value, or null if the conversion could not be made and the column allows nulls	0	1
public List<BreakpointMessageInterface> getBreakpointsEnabledList() { if (mode.equals(Mode.safe)) { return new ArrayList<>(); } return getBreakpointsModel().getBreakpointsEnabledList(); }	@return list of enabled breakpoints	0	1
public boolean preloadBundle(Bundle bundle) { return true; }	@return true: can launch bundle, false: otherwise	1	0
"public String toString() { return port + ""/"" + protocol.toString(); }"	@return a string representation of this ExposedPort	0	1
public VariationService createVariationService() { return createVariationService(defaultEndpointUrl); }	@return a new variation service with the default server URL	1	0
public ParameterMetadata getSQLParameterMetadata(final String query) { ParameterMetadata value = parameterMetadataCache.get( query ); if ( value == null ) { value = buildParameterMetadata( query ); parameterMetadataCache.putIfAbsent( query, value ); } return value; }	@return The parameter metadata	0	1
protected int getCustomColumnIndex(int columnIndex) { Integer customColumnIndex = cacheColumnIdxToIdxCustomColumnsOnly.get(columnIndex); if (customColumnIndex != null) { return customColumnIndex; } return -1; }	@return the custom column index as if no default columns existed or -1 if not a custom column.	0	1
public static Color fromObject(@Nonnull final Object object) { int i = object.hashCode(); float h = (i % 360) / 360f; return Color.getHSBColor(h, 1, 1); }	@return color	0	1
public ParameterList getBodyParams() { return bodyParams; }	@return a map containing the body parameters.	1	0
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; // set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { System.err.printf(""Untokenizable: %s%n"", yytext()); return getNext(true); } case 9: break; case 2: { return getNewline(); } case 10: break; case 3: { } case 11: break; case 4: { return getNext(false); } case 12: break; case 5: { return getNext(true); } case 13: break; case 6: { return getEllipsis(); } case 14: break; case 7: { if (! removeProMarker) return getNext(false); } case 15: break; case 8: { if (removeProMarker) { if ( ! removeSegMarker) { return getNext(""-"", yytext()); } } else { return getNext(false); } } case 16: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }"	@return the next token	0	1
public Collection<OsmPrimitive> allPrimitives() { return Collections.unmodifiableCollection(allPrimitives); }	@return A collection containing all primitives of the dataset. The data is ordered after: first come nodes, then ways, then relations. Ordering in between the categories is not guaranteed.	1	0
public SqlSelect getSourceSelect() { return sourceSelect; }	@return the source SELECT for the data to be updated	0	1
public Collection<TableGrant> getTableGrants(TableIdentifier table) { Collection<TableGrant> result = new HashSet<TableGrant>(); ResultSet rs = null; try { TableIdentifier tbl = table.createCopy(); tbl.adjustCase(this.dbConnection); rs = this.metaData.getTablePrivileges(tbl.getCatalog(), tbl.getSchema(), tbl.getTableName()); while (rs.next()) { String from = rs.getString(NUM); String to = rs.getString(NUM); String what = rs.getString(NUM); boolean grantable = StringUtil.stringToBool(rs.getString(NUM)); TableGrant grant = new TableGrant(to, what, grantable); result.add(grant); } } catch (Exception e) { LogMgr.logError(STR, STR, e); } finally { try { rs.close(); } catch (Throwable th) { } } return result; }	@return a DataStore which contains the grant information.	1	0
public int[] getPartialValues(ReadablePartial fieldSource, Object object, Chronology chrono, DateTimeFormatter parser) { long millis = parser.withChronology(chrono).parseMillis((String) object); return chrono.get(fieldSource, millis); }	@return the array of field values that match the fieldSource, must be non-null valid	0	1
public Package getRuleSet() { return this.pkg; }	@return The ruleSet	1	0
public URL getRoot() { return rootUrl; }	@return Returns a IPath	1	0
public double getRotZ() { return Math.toDegrees(mOrientation.getRotationZ()); }	@return double The pitch Euler angle.	1	0
private AvaticaServerConfiguration buildSpnegoConfiguration(Builder b) { final String principal = b.kerberosPrincipal; final String realm = b.kerberosRealm; final DoAsRemoteUserCallback callback = b.remoteUserCallback; return new AvaticaServerConfiguration() { @Override public AuthenticationType getAuthenticationType() { return AuthenticationType.SPNEGO; } @Override public String getKerberosRealm() { return realm; } @Override public String getKerberosPrincipal() { return principal; } @Override public boolean supportsImpersonation() { return null != callback; } @Override public <T> T doAsRemoteUser(String remoteUserName, String remoteAddress, Callable<T> action) throws Exception { return callback.doAsRemoteUser(remoteUserName, remoteAddress, action); } @Override public String[] getAllowedRoles() { return null; } @Override public String getHashLoginServiceRealm() { return null; } @Override public String getHashLoginServiceProperties() { return null; } }; }	@return A configuration instance.	0	1
protected static Serializable deserializeTimestampV2(int meta, ByteArrayInputStream inputStream) throws IOException { long epochSecond = bigEndianLong(inputStream.read(4), 0, 4); int nanoSeconds = deserializeFractionalSecondsInNanos(meta, inputStream); return ZonedDateTime.ofInstant(Instant.ofEpochSecond(epochSecond, nanoSeconds), ZoneId.systemDefault()); }	@return the OffsetDateTime object	0	1
"public String getResourceManagerId() throws JMSException { waitForBrokerInfo(); if( brokerInfo==null ) throw new JMSException(""Connection failed before Broker info was received.""); return brokerInfo.getBrokerId().getBrokerId(); }"	@return Returns the resourceManagerId.	0	1
public static String deprocess(String str) { if ((str == null) || (str.length() <= NUM)) return str; STextEnvironment env = new STextEnvironment(null, false, STextEnvironment.ORIENT_UNKNOWN); if (!env.isProcessingNeeded()) return str; StringBuffer buf = new StringBuffer(); int strLen = str.length(); for (int i = NUM; i < strLen; i++) { char c = str.charAt(i); switch(c) { case LRM: continue; case LRE: continue; case PDF: continue; default: buf.append(c); } } return buf.toString(); }	@return string with no directional formatting characters.	1	0
public APIResult validate(HttpServletRequest request, String type, Boolean skipDryRun) { try { return validate(request.getInputStream(), type, skipDryRun); } catch (IOException e) { LOG.error(STR, request, e); throw FalconWebException.newException(e, Response.Status.BAD_REQUEST); } }	@return APIResule -Succeeded or Failed	1	0
public DateTime withMinimumValue() { try { return setCopy(getMinimumValue()); } catch (RuntimeException ex) { if (IllegalInstantException.isIllegalInstant(ex)) { // subtracting MILLIS_PER_DAY is not perfect, but will work in almost all situations long afterGap = getChronology().getZone().nextTransition(getMillis() - DateTimeConstants.MILLIS_PER_DAY); return new DateTime(afterGap, getChronology()); } throw ex; } }	@return a copy of the DateTime with this field set to its minimum	0	1
public boolean isProfileReadOnly() { return profileReadOnly && !isManagementView() && getProfileName() != null; }	@return false if the object is currently assigned to an mbean or if it is not read only	1	0
"protected Tree determineNonTrivialHead(Tree t, Tree parent) { String motherCat = tlp.basicCategory(t.label().value()); if (DEBUG) { System.err.println(""At "" + motherCat + "", my parent is "" + parent); } if (motherCat.equals(""SBARQ"")) { // TODO: if we have it set to keep copula as the head, should we // forget about these relations and just return the copula? for (TregexPattern pattern : headOfCopulaTregex) { TregexMatcher matcher = pattern.matcher(t); if (matcher.matchesAt(t)) { return matcher.getNode(""head""); } } // if none of the above patterns match, use the standard method } // do VPs with auxiliary as special case if ((motherCat.equals(""VP"") || motherCat.equals(""SQ"") || motherCat.equals(""SINV""))) { Tree[] kids = t.children(); // try to find if there is an auxiliary verb if (DEBUG) { System.err.println(""Semantic head finder: at VP""); System.err.println(""Class is "" + t.getClass().getName()); t.pennPrint(System.err); //System.err.println(""hasVerbalAuxiliary = "" + hasVerbalAuxiliary(kids, verbalAuxiliaries)); } // looks for auxiliaries if (hasVerbalAuxiliary(kids, verbalAuxiliaries, true) || hasPassiveProgressiveAuxiliary(kids)) { // String[] how = new String[] {""left"", ""VP"", ""ADJP"", ""NP""}; // Including NP etc seems okay for copular sentences but is // problematic for other auxiliaries, like 'he has an answer' // But maybe doing ADJP is fine! String[] how = { ""left"", ""VP"", ""ADJP"" }; Tree pti = traverseLocate(kids, how, false); if (DEBUG) { System.err.println(""Determined head (case 1) for "" + t.value() + "" is: "" + pti); } if (pti != null) { return pti; // } else { // System.err.println(""------""); // System.err.println(""SemanticHeadFinder failed to reassign head for""); // t.pennPrint(System.err); // System.err.println(""------""); } } // looks for copular verbs if (hasVerbalAuxiliary(kids, copulars, false) && ! isExistential(t, parent) && ! isWHQ(t, parent)) { String[] how; if (motherCat.equals(""SQ"")) { how = new String[]{""right"", ""VP"", ""ADJP"", ""NP"", ""WHADJP"", ""WHNP""}; } else { how = new String[]{""left"", ""VP"", ""ADJP"", ""NP"", ""WHADJP"", ""WHNP""}; } Tree pti = traverseLocate(kids, how, false); // don't allow a temporal to become head if (pti != null && pti.label() != null && pti.label().value().contains(""-TMP"")) { pti = null; } // In SQ, only allow an NP to become head if there is another one to the left (then it's probably predicative) if (motherCat.equals(""SQ"") && pti != null && pti.label() != null && pti.label().value().startsWith(""NP"")) { boolean foundAnotherNp = false; for (Tree kid : kids) { if (kid == pti) { break; } else if (kid.label() != null && kid.label().value().startsWith(""NP"")) { foundAnotherNp = true; break; } } if ( ! foundAnotherNp) { pti = null; } } if (DEBUG) { System.err.println(""Determined head (case 2) for "" + t.value() + "" is: "" + pti); } if (pti != null) { return pti; } else { if (DEBUG) { System.err.println(""------""); System.err.println(""SemanticHeadFinder failed to reassign head for""); t.pennPrint(System.err); System.err.println(""------""); } } } } Tree hd = super.determineNonTrivialHead(t, parent); /* ---- // This should now be handled at the AbstractCollinsHeadFinder level, so see if we can comment this out // Heuristically repair punctuation heads Tree[] hdChildren = hd.children(); if (hdChildren != null && hdChildren.length > 0 && hdChildren[0].isLeaf()) { if (tlp.isPunctuationWord(hdChildren[0].label().value())) { Tree[] tChildren = t.children(); if (DEBUG) { System.err.printf(""head is punct: %s\n"", hdChildren[0].label()); } for (int i = tChildren.length - 1; i >= 0; i--) { if (!tlp.isPunctuationWord(tChildren[i].children()[0].label().value())) { hd = tChildren[i]; if (DEBUG) { System.err.printf(""New head of %s is %s%n"", hd.label(), hd.children()[0].label()); } break; } } } } */ if (DEBUG) { System.err.println(""Determined head (case 3) for "" + t.value() + "" is: "" + hd); } return hd; }"	@return The parse tree that is the head	0	1
public Float getTopValue() { return topValue; }	@return The value of the 'top' CSS-attribute	1	0
public List<UserItems> get() { return mUserItemList != null ? Collections.unmodifiableList(mUserItemList) : null; }	@return Unmodifiable user item list, or null.	0	1
"public String knownGtidSet() { AtomicReference<String> gtidSetStr = new AtomicReference<String>(); try { jdbc.query(""SHOW MASTER STATUS"", rs -> { if (rs.next() && rs.getMetaData().getColumnCount() > 4) { gtidSetStr.set(rs.getString(5));// GTID set, may be null, blank, or contain a GTID set } }); } catch (SQLException e) { throw new ConnectException(""Unexpected error while connecting to MySQL and looking at GTID mode: "", e); } String result = gtidSetStr.get(); return result != null ? result : """"; }"	@return the string representation of MySQL's GTID sets.	1	0
private List<BatchResponse> handleBatchRequests(final List<BatchRequest> requestList, final UriInfo uriInfo) { final List<BatchResponse> responseList = new ArrayList<>(requestList.size()); final List<BatchRequestNode> batchRequestNodes = this.resolutionHelper.getDependingRequests(requestList); checkList.clear(); if(batchRequestNodes.isEmpty()) { final BatchResponse response = new BatchResponse(); ErrorInfo ex = ErrorHandler.handler(new ClientDetailsNotFoundException()); response.setStatusCode(500); response.setBody(ex.getMessage()); responseList.add(response) ; return responseList ; } for (BatchRequestNode rootNode : batchRequestNodes) { final BatchRequest rootRequest = rootNode.getRequest(); final CommandStrategy commandStrategy = this.strategyProvider.getCommandStrategy(CommandContext .resource(rootRequest.getRelativeUrl()).method(rootRequest.getMethod()).build()); final BatchResponse rootResponse = commandStrategy.execute(rootRequest, uriInfo); responseList.add(rootResponse); responseList.addAll(this.processChildRequests(rootNode, rootResponse, uriInfo)); } Collections.sort(responseList, new Comparator<BatchResponse>() { @Override public int compare(BatchResponse source, BatchResponse testee) { return source.getRequestId().compareTo(testee.getRequestId()); } }); checkList = responseList; return responseList; }	@return List	0	1
public SendFileTransfer dccSendFile(File file, User reciever, int timeout) throws IOException { return dccHandler.sendFile(file, reciever, timeout); }	@return The DccFileTransfer that can be used to monitor this transfer.	1	0
"public String getMatchedSentences() { StringBuilder sb = new StringBuilder(); for (int i = 0, sz = list.getModel().getSize(); i < sz; i++) { String t = list.getModel().getElementAt(i).getLabel().getText(); sb.append(t); sb.append(""\n""); } return sb.toString(); }"	@return StringBuffer filled with the plain text form of all sentences in the matches panel	1	0
protected AsyncSupport resolveMultipleNativeSupportConflict(final List<Class<? extends AsyncSupport>> available) { final StringBuilder b = new StringBuilder(STR); for (Class<? extends AsyncSupport> cs : available) { b.append((cs != null) ? cs.getCanonicalName() : STR).append(STR); } b.append(STR + available.get(NUM)); logger.warn(STR, b.toString()); return newCometSupport(available.get(NUM)); }	@return a CometSupport instance	1	0
"public static long getLocalExpires(Headers responseHeaders) { final long now = System.currentTimeMillis(); final long date = responseHeaders.getDate(); final long expires = responseHeaders.getExpiration(); long maxAge = 0; long staleWhileRevalidate = 0; String cacheControl = responseHeaders.getCacheControl(); if (!TextUtils.isEmpty(cacheControl)) { StringTokenizer tokens = new StringTokenizer(cacheControl, "",""); while (tokens.hasMoreTokens()) { String token = tokens.nextToken().trim().toLowerCase(Locale.getDefault()); if ((token.equals(""no-cache"") || token.equals(""no-store""))) { return 0; } else if (token.startsWith(""max-age="")) { maxAge = Long.parseLong(token.substring(8)); } else if (token.startsWith(""must-revalidate"")) { return 0; } else if (token.startsWith(""stale-while-revalidate="")) { staleWhileRevalidate = Long.parseLong(token.substring(23)); } } } long localExpire = now;// Local expires time of cache. // If must-revalidate, It must be from the server to validate expired. // Have CacheControl. if (!TextUtils.isEmpty(cacheControl)) { localExpire = now + maxAge * 1000; if (staleWhileRevalidate > 0) localExpire += staleWhileRevalidate * 1000; } // If the server through control the cache Expires. if (localExpire <= now && expires > date) { localExpire = now + (expires - date); } return localExpire; }"	@return Time corresponding milliseconds.	0	1
public final List<ModuleReference> getDependentModulesRecursively(final ModuleReference ref) throws Exception { return getDependentModulesRecursively(ref, new ArrayList<ModuleReference>()); }	@return the modules needing <code>id</code> (excluding it), in uninstallation order (i.e. the first item isn't depended on).	1	0
"public Pet getPetById (Long petId) throws ApiException { Object postBody = null; // verify the required parameter 'petId' is set if (petId == null) { throw new ApiException(400, ""Missing the required parameter 'petId' when calling getPetById""); } // create path and map variables String path = ""/pet/{petId}"".replaceAll(""\\{format\\}"",""json"") .replaceAll(""\\{"" + ""petId"" + ""\\}"", apiClient.escapeString(petId.toString())); // query params List<Pair> queryParams = new ArrayList<Pair>(); Map<String, String> headerParams = new HashMap<String, String>(); Map<String, Object> formParams = new HashMap<String, Object>(); final String[] accepts = { ""application/json"", ""application/xml"" }; final String accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final String contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { ""petstore_auth"", ""api_key"" }; TypeRef returnType = new TypeRef<Pet>() {}; return apiClient.invokeAPI(path, ""GET"", queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }"	@return Pet	0	1
public View waitForView(View view, int timeout, boolean scroll, boolean checkIsShown){ if(view == null) return null; long endTime = SystemClock.uptimeMillis() + timeout; while (SystemClock.uptimeMillis() < endTime) { final boolean foundAnyMatchingView = searcher.searchFor(view); if(checkIsShown && foundAnyMatchingView && !view.isShown()){ sleeper.sleep(); View identicalView = viewFetcher.getIdenticalView(view); if(identicalView != null && !view.equals(identicalView)){ view = identicalView; } continue; } if (foundAnyMatchingView){ return view; } if(scroll) scroller.scrollDown(); sleeper.sleep(); } return null; }	@return true if view is shown and false if it is not shown before the timeout	0	1
public float getReal() { return (float) getFirstValue(); }	@return item in given position	1	0
public Throwable getException() { return getCause(); }	@return the nested exception or <code>null</code> if there is no nested exception.	1	0
"private AutoInstallsLayout createWorkspaceLoaderFromAppRestriction(AppWidgetHost widgetHost) { // UserManager.getApplicationRestrictions() requires minSdkVersion >= 18 if (!Utilities.ATLEAST_JB_MR2) { return null; } Context ctx = getContext(); UserManager um = (UserManager) ctx.getSystemService(Context.USER_SERVICE); Bundle bundle = um.getApplicationRestrictions(ctx.getPackageName()); if (bundle == null) { return null; } String packageName = bundle.getString(RESTRICTION_PACKAGE_NAME); if (packageName != null) { try { Resources targetResources = ctx.getPackageManager() .getResourcesForApplication(packageName); return AutoInstallsLayout.get(ctx, packageName, targetResources, widgetHost, mOpenHelper); } catch (NameNotFoundException e) { Log.e(TAG, ""Target package for restricted profile not found"", e); return null; } } return null; }"	@return the loader if the restrictions are set and the resource exists; null otherwise.	0	1
public int getCurrenButtonsCount() { int number = soloView.getCurrenButtonsCount(); return number; }	@return the number of buttons in the current activity	0	1
public int getTerminalCount() { return activeTerminalToolbarButton_.terminalCount(); }	@return number of terminals hosted by the pane	1	0
public DateTimeField getField(int index) { DateTimeField[] fields = iFields; if (fields != null) { return fields[index]; } else { return getField(index, getChronology()); } }	@return the field	0	1
private byte[] marshalAggregatorValues(long superstep) { if (superstep == INPUT_SUPERSTEP) { return new byte[NUM]; } ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); DataOutputStream output = new DataOutputStream(outputStream); for (Entry<String, AggregatorWrapper<Writable>> entry : getAggregatorMap().entrySet()) { if (entry.getValue().isChanged()) { try { output.writeUTF(entry.getKey()); entry.getValue().getCurrentAggregatedValue().write(output); } catch (IOException e) { throw new IllegalStateException(STR + STR + entry.getKey(), e); } } } if (LOG.isInfoEnabled()) { LOG.info(STR); } return outputStream.toByteArray(); }	@return JSON array of the aggreagtor values	1	0
public MethodInfo createMethod(MemberID memberID, String[] argNames) { return createMethod(memberID, argNames, null); }	@return the new method or an existing method with that signature.	1	0
public LookupService createLookupService() { return createLookupService(defaultEndpointUrl); }	@return a new lookup service with the default server URL	1	0
public boolean searchText(String regex, int matches, boolean scroll) { return searcher.searchText(regex, matches, scroll); }	@return true if search string is found a given number of times and false if the search string is not found	1	0
private String getConfigurationTable(Connection con) { try { if (StorageManager.getStorageImpl(con.getMetaData().getDatabaseProductName()).requiresConfigSchema()) { if (DatabaseConst.getConfigSchema().endsWith(STR)) return DatabaseConst.getConfigSchema() + TBL_GLOBAL_CONFIG; else return DatabaseConst.getConfigSchema() + STR + TBL_GLOBAL_CONFIG; } } catch (SQLException e) { LOG.warn(e); } return TBL_GLOBAL_CONFIG; }	@return global configuration table name including the correct escaped schema	1	0
public Lock readLock() { return getGraph().getLock().readLock(); }	@return a ReadLock if the underlying Graph is a LockableMGraph it returns its lock, otherwise null	1	0
public static InetAddress guessPrimaryNetworkAddress(boolean preferIPv4) throws SocketException { final Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces(); if (interfaces != null) { for (NetworkInterface interf : Collections.list(interfaces)) { if (!interf.isLoopback() && interf.isUp()) { for (InetAddress addr : Collections.list(interf.getInetAddresses())) { if (preferIPv4 && addr instanceof Inet4Address) { return addr; } if (!preferIPv4 && addr instanceof Inet6Address) { return addr; } } } } } return InetAddress.getLoopbackAddress(); }	@return The primary {@link java.net.InetAddress} of the primary network interface or the loopback address as fallback.	1	0
public List<ScoredObject<Tree>> getKBestParses(int k) { if (parseSkipped) { return null; } if (bparser != null && parseSucceeded) { //The getKGoodParses seems to be broken, so just return the best parse Tree binaryTree = bparser.getBestParse(); Tree tree = debinarizer.transformTree(binaryTree); if (op.nodePrune) { NodePruner np = new NodePruner(pparser, debinarizer); tree = np.prune(tree); } tree = subcategoryStripper.transformTree(tree); restoreOriginalWords(tree); double score = dparser.getBestScore(); ScoredObject<Tree> so = new ScoredObject<>(tree, score); List<ScoredObject<Tree>> trees = new ArrayList<>(1); trees.add(so); return trees; } else if (pparser != null && pparser.hasParse() && fallbackToPCFG) { return this.getKBestPCFGParses(k); } else if (dparser != null && dparser.hasParse()) { // && fallbackToDG // The dependency parser doesn't support k-best parse extraction, so just // return the best parse Tree tree = this.getBestDependencyParse(true); double score = dparser.getBestScore(); ScoredObject<Tree> so = new ScoredObject<>(tree, score); List<ScoredObject<Tree>> trees = new ArrayList<>(1); trees.add(so); return trees; } else { throw new NoSuchParseException(); } }	@return A list of scored trees	0	1
public static SecretFixtures using(SecretJooqDao secretJooqDao) { return new SecretFixtures(secretJooqDao); }	@return builds a fixture-making object using the given SecretDAO	1	0
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; // set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { // prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); // System.err.println(""At end of text making after: |"" + str + ""|""); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); // System.err.println(""prevWord is |"" + prevWord.get(CoreAnnotations.TextAnnotation.class) + ""|, its after is |"" + // prevWord.get(CoreAnnotations.AfterAnnotation.class) + ""|""); prevWordAfter.setLength(0); } return null; } } else { switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { String str = yytext(); int first = str.codePointAt(0); String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } logger.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: logger.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 73: break; case 2: { return getNext(""<"", yytext()); } case 74: break; case 3: { return getNext(); } case 75: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 76: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns } else if (invertible) { // System.err.println(""Appending newline: |"" + yytext() + ""|""); prevWordAfter.append(yytext()); } } case 77: break; case 6: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 78: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 79: break; case 8: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {QUOTES} (2) to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 80: break; case 9: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {SREDAUX} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 81: break; case 10: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 82: break; case 11: { return getNext("">"", yytext()); } case 83: break; case 12: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 84: break; case 13: { handleHyphenatedNumber(yytext()); if (DEBUG) { logger.info(""Used {NUMBER} to recognize "" + yytext() + "" as "" + removeFromNumber(yytext())); } return getNext(removeFromNumber(yytext()), yytext()); } case 85: break; case 14: { return handleEllipsis(yytext()); } case 86: break; case 15: { // breakByHyphens(yytext()); // this is causing fail of attempted to pushback too much! String tok = yytext(); /* A THING can contain quote like O'Malley */ String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {THING} (2) to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 87: break; case 16: { return normalizeFractions(yytext()); } case 88: break; case 17: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(minimallyNormalizeCurrency(yytext()), yytext()); } } case 89: break; case 18: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 90: break; case 19: { if (normalizeOtherBrackets) { return getNext(""-RSB-"", yytext()); } else { return getNext(); } } case 91: break; case 20: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 92: break; case 21: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 93: break; case 22: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 94: break; case 23: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 95: break; case 24: { if (normalizeOtherBrackets) { return getNext(""-LSB-"", yytext()); } else { return getNext(); } } case 96: break; case 25: { if (invertible) { prevWordAfter.append(yytext()); } } case 97: break; case 26: { return getNext(""\u2022"", yytext()); } case 98: break; case 27: { return getNext(""\u2122"", yytext()); } case 99: break; case 28: // general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 100: break; case 29: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(); } case 101: break; case 30: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {REDAUX} (2nd) to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 102: break; case 31: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {APOWORD} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 103: break; case 32: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); String norm = handleQuotes(tok, true); if (DEBUG) { logger.info(""Used {DBLQUOT} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + true); } return getNext(norm, tok); } case 104: break; case 33: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 105: break; case 34: { breakByHyphens(yytext()); if (DEBUG) { logger.info(""Used {HTHING} to recognize "" + yytext() + "" as "" + removeSoftHyphens(yytext())); } return getNext(removeSoftHyphens(yytext()), yytext()); } case 106: break; case 35: // general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 107: break; case 36: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 108: break; case 37: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 109: break; case 38: { // this one should only match if we're basically at the end of file // since the last one matches two things, even newlines (if not tokenize per line) String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 110: break; case 39: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 111: break; case 40: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { String tok = yytext(); /* invert single quote - often but not always right */ String norm = handleQuotes(tok, true); if (DEBUG) { logger.info(""Used {QUOTES} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + true); } return getNext(norm, tok); } case 112: break; case 41: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {REDAUX} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 113: break; case 42: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 114: break; case 43: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {SREDAUX} (2nd) to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 115: break; case 44: { String txt = yytext(); // if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space... if (strictTreebank3) { int spaceIndex = indexOfSpace(txt); if (spaceIndex >= 0) { yypushback(txt.length() - spaceIndex); return getNext(); } } if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, yytext()); } case 116: break; case 45: { return getNormalizedAmpNext(); } case 117: break; case 46: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, origTxt); } case 118: break; case 47: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space } return getNext(txt, origTxt); } case 119: break; case 48: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 120: break; case 49: { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 121: break; case 50: // general lookahead, find correct zzMarkedPos { int zzFState = 17; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 122: break; case 51: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {SREDAUX} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 123: break; case 52: // lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 124: break; case 53: // general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 125: break; case 54: // general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 22; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 126: break; case 55: // general lookahead, find correct zzMarkedPos { int zzFState = 18; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 19; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 127: break; case 56: // general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 128: break; case 57: // general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 21; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 129: break; case 58: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 130: break; case 59: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); breakByHyphens(tok); tok = yytext(); String norm = removeSoftHyphens(tok); if (DEBUG) { logger.info(""Used {HTHING} (2) to recognize "" + tok + "" as "" + norm); } return getNext(norm, tok); } case 131: break; case 60: { if (splitAssimilations) { yypushback(3) ; return getNext(); } else { return getNext(); } } case 132: break; case 61: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNormalizedAmpNext(); } case 133: break; case 62: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 9; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 134: break; case 63: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { return getNext(); } case 135: break; case 64: // general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 136: break; case 65: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 137: break; case 66: // general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 13; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 138: break; case 67: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } return getNext(txt, yytext()); } case 139: break; case 68: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4); { return getNext(); } case 140: break; case 69: // lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { return getNext(); } case 141: break; case 70: { String txt = yytext(); if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } if (DEBUG) { logger.info(""Used {PHONE} to recognize "" + yytext() + "" as "" + txt); } return getNext(txt, yytext()); } case 142: break; case 71: // general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 25; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 143: break; case 72: // general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 24; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 144: break; default: zzScanError(ZZ_NO_MATCH); } } } }"	@return the next token	0	1
"public Mono<Client> call123testSpecialTags(Client body) throws RestClientException { Object postBody = body; // verify the required parameter 'body' is set if (body == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'body' when calling call123testSpecialTags""); } String path = UriComponentsBuilder.fromPath(""/another-fake/dummy"").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { ""application/json"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { ""application/json"" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {}; return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType); }"	@return Client	0	1
"public String loginUser (String username, String password) throws ApiException { Object postBody = null; byte[] postBinaryBody = null; // create path and map variables String path = ""/user/login"".replaceAll(""\\{format\\}"",""json""); // query params List<Pair> queryParams = new ArrayList<Pair>(); Map<String, String> headerParams = new HashMap<String, String>(); Map<String, Object> formParams = new HashMap<String, Object>(); queryParams.addAll(apiClient.parameterToPairs("""", ""username"", username)); queryParams.addAll(apiClient.parameterToPairs("""", ""password"", password)); final String[] accepts = { ""application/json"", ""application/xml"" }; final String accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final String contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; TypeRef returnType = new TypeRef<String>() {}; return apiClient.invokeAPI(path, ""GET"", queryParams, postBody, postBinaryBody, headerParams, formParams, accept, contentType, authNames, returnType); }"	@return String	0	1
public LSN restart() throws BabuDBException { if (!this.stopped) throw new BabuDBException(ErrorCode.IO_ERROR, STR); databaseManager.reset(); dbCheckptr = new CheckpointerImpl(this); LSN dbLsn = null; LSN zero = new LSN(NUM, NUM); for (Database dbRaw : databaseManager.getDatabaseList()) { DatabaseImpl db = (DatabaseImpl) dbRaw; LSN onDisk = db.getLSMDB().getOndiskLSN(); if (dbLsn == null && !onDisk.equals(zero)) dbLsn = onDisk; else if (dbLsn != null) { if (!onDisk.equals(zero) && !dbLsn.equals(onDisk)) throw new RuntimeException(STR + dbLsn.toString() + STR + db.getLSMDB().getOndiskLSN().toString()); } } if (dbLsn == null) { dbLsn = new LSN(NUM, NUM); } else { dbLsn = new LSN(dbLsn.getViewId(), dbLsn.getSequenceNo() + NUM); } Logging.logMessage(Logging.LEVEL_INFO, this, STR); LSN nextLSN = replayLogs(dbLsn); if (dbLsn.compareTo(nextLSN) > NUM) { nextLSN = dbLsn; } Logging.logMessage(Logging.LEVEL_INFO, this, STR + nextLSN); try { logger = new DiskLogger(configuration.getDbLogDir(), nextLSN.getViewId(), nextLSN.getSequenceNo() + NUM, configuration.getSyncMode(), configuration.getPseudoSyncWait(), configuration.getMaxQueueLength() * configuration.getNumThreads()); logger.start(); } catch (IOException ex) { throw new BabuDBException(ErrorCode.IO_ERROR, STR, ex); } worker = new LSMDBWorker[configuration.getNumThreads()]; for (int i = NUM; i < configuration.getNumThreads(); i++) { worker[i] = new LSMDBWorker(logger, i, (configuration.getPseudoSyncWait() > NUM), configuration.getMaxQueueLength(), replicationManager); worker[i].start(); } dbCheckptr.init(logger, configuration.getCheckInterval(), configuration.getMaxLogfileSize()); dbCheckptr.start(); Logging.logMessage(Logging.LEVEL_INFO, this, STR + STR + BABUDB_VERSION + STR); this.stopped = false; return new LSN(nextLSN.getViewId(), nextLSN.getSequenceNo()); }	@return the latest loaded LSN.	1	0
"public String getEval(String script) { script = String.format(""return eval(%s);"", script); return String.valueOf(((JavascriptExecutor) driver).executeScript(script)); }"	@return the results of evaluating the snippet	0	1
public static MatchFinder anyOf(final MatchFinder... finders) { return new MatchFinder() { @Override public boolean matches(UiElement element) { for (MatchFinder finder : finders) { if (finder.matches(element)) { return true; } } return false; } @Override public String toString() { return STR + Joiner.on(STR).join(finders) + STR; } }; }	@return a matcher that is the logical disjunction of given matchers	1	0
public Integer getMinLength() { return minLength; }	@return the minimum length of the string.	1	0
public ArrayList<ScrollView> getCurrentScrollViews() { return getCurrentViews(ScrollView.class); }	@return a List of the ScrollViews contained in the current Activity	0	1
public String getName() { return StringUtils.removeEnd(path.getFileName().toString(), VAULT_FILE_EXTENSION); }	@return Directory name without preceeding path components	1	0
public int compareTo(IndexedWord w) { if (this.equals(IndexedWord.NO_WORD)) { if (w.equals(IndexedWord.NO_WORD)) { return 0; } else { return -1; } } if (w.equals(IndexedWord.NO_WORD)) { return 1; } String docID = this.getString(CoreAnnotations.DocIDAnnotation.class); int docComp = docID.compareTo(w.getString(CoreAnnotations.DocIDAnnotation.class)); if (docComp != 0) return docComp; int sentComp = sentIndex() - w.sentIndex(); if (sentComp != 0) return sentComp; int indexComp = index() - w.index(); if (indexComp != 0) return indexComp; return copyCount() - w.copyCount(); }	@return Whether this is less than w or not in the ordering	0	1
public JoinInfo analyzeCondition() { return joinInfo; }	@return Analyzed join condition	0	1
public ProjectItem getChild(String text) { String[] childPath = new String[path.length + NUM]; System.arraycopy(path, NUM, childPath, NUM, path.length); childPath[childPath.length - NUM] = text; return project.getProjectItem(childPath); }	@return project item with specified text without decorators	1	0
"protected Object convertPoint(Column column, Field fieldDefn, Object data) { return convertValue(column, fieldDefn, data, (Supplier<?>)() -> Point.createValue(fieldDefn.schema(), 0, 0), (r) -> { final Schema schema = fieldDefn.schema(); if (data instanceof PGpoint) { PGpoint pgPoint = (PGpoint) data; r.deliver(Point.createValue(schema, pgPoint.x, pgPoint.y)); } else if (data instanceof String) { String dataString = data.toString(); try { PGpoint pgPoint = new PGpoint(dataString); r.deliver(Point.createValue(schema, pgPoint.x, pgPoint.y)); } catch (SQLException e) { logger.warn(""Error converting the string '{}' to a PGPoint type for the column '{}'"", dataString, column); } } else if (data instanceof PgProto.Point) { r.deliver(Point.createValue(schema, ((PgProto.Point) data).getX(), ((PgProto.Point) data).getY())); } }); }"	@return a value which will be used by Connect to represent the actual point value	0	1
public static Hours parseHours(String periodStr) { throw ExceptionUtils.unsupportedInGwt(); // if (periodStr == null) { // return Hours.ZERO; // } // Period p = PARSER.parsePeriod(periodStr); // return Hours.hours(p.getHours()); }	@return the period in hours	0	1
public Table removeTable(TableId tableId) { return lock.write(() -> { changes.add(tableId); return tablesByTableId.remove(tableId); }); }	@return the existing table definition that was removed, or null if there was no prior table definition	0	1
public final String getAccessToken() { synchronized (this.lock) { return (this.tokenInfo == null) ? null : this.tokenInfo.getToken(); } }	@return the access token String.	1	0
"public String toDefaultValue(Schema p) { if (ModelUtils.isDateSchema(p)) { // TODO } else if (ModelUtils.isDateTimeSchema(p)) { // TODO } else if (ModelUtils.isNumberSchema(p)) { if (p.getDefault() != null) { return ""@"" + p.getDefault().toString(); } } else if (ModelUtils.isIntegerSchema(p)) { if (p.getDefault() != null) { return ""@"" + p.getDefault().toString(); } } else if (ModelUtils.isStringSchema(p)) { if (p.getDefault() != null) { return ""@\"""" + (String) p.getDefault() + ""\""""; } } else if (ModelUtils.isBooleanSchema(p)) { if (p.getDefault() != null) { if (p.getDefault().toString().equalsIgnoreCase(""false"")) return ""@(NO)""; else return ""@(YES)""; } } return null; }"	@return string presentation of the default value of the property	1	0
public int getStack(int k) { int nStack = getStackSize(); return (k >= 0 && k < nStack) ? stack.get(nStack - 1 - k) : Config.NONEXIST; }	@return Sentence index or CONST#NONEXIST if stack doesn't have an element at this index	1	0
"public ServerAddress address() { return execute(""get replica set primary"", primary -> { ReplicaSetStatus rsStatus = primary.getReplicaSetStatus(); if (rsStatus != null) { return rsStatus.getMaster(); } else { return null; } }); }"	@return the address of the replica set's primary node, or null if there is currently no primary	0	1
private String buildAddVideoSdpProposal() { if (logger.isActivated()) { logger.debug(STR); } try { String ntpTime = SipUtils.constructNTPtime(System.currentTimeMillis()); String ipAddress = getDialogPath().getSipStack().getLocalIpAddress(); getAudioPlayer().getLocalRtpPort(); String audioSdp = AudioSdpBuilder.buildSdpOffer(getAudioPlayer().getSupportedAudioCodecs(), getAudioPlayer().getLocalRtpPort()); String videoSdp; videoSdp = VideoSdpBuilder.buildSdpOfferWithOrientation(getVideoPlayer().getSupportedVideoCodecs(), getVideoPlayer().getLocalRtpPort()); return STR + SipUtils.CRLF + STR + ntpTime + STR + ntpTime + STR + SdpUtils.formatAddressType(ipAddress) + SipUtils.CRLF + STR + SipUtils.CRLF + STR + SdpUtils.formatAddressType(ipAddress) + SipUtils.CRLF + STR + SipUtils.CRLF + audioSdp + STR + SipUtils.CRLF + videoSdp + STR + SipUtils.CRLF; } catch (RemoteException e) { if (logger.isActivated()) { logger.error(STR, e); } handleError(new IPCallError(IPCallError.UNEXPECTED_EXCEPTION, e.getMessage())); return null; } }	@return sdp content	1	0
private static boolean isStylusButtonPressed(MotionEvent event) { return event.getToolType(0) == MotionEvent.TOOL_TYPE_STYLUS && ((event.getButtonState() & MotionEvent.BUTTON_SECONDARY) == MotionEvent.BUTTON_SECONDARY); }	@return Whether a stylus button press occurred.	0	1
public Observable<Connectivity> observeNetworkConnectivity(final Context context) { final IntentFilter filter = new IntentFilter(); filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION); return Observable.create(new Observable.OnSubscribe<Connectivity>() { @Override public void call(final Subscriber<? super Connectivity> subscriber) { final BroadcastReceiver receiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { subscriber.onNext(Connectivity.create(context)); } }; context.registerReceiver(receiver, filter); subscriber.add(unsubscribeInUiThread(new Action0() { @Override public void call() { context.unregisterReceiver(receiver); } })); } }).defaultIfEmpty(Connectivity.create()); }	@return RxJava Observable with ConnectivityStatus	1	0
public String toString() { if (connString == null) { String wrappedString; try { wrappedString = getRealConnection().toString(); } catch (SQLException e) { wrappedString = STR; } connString = this.getClass().getName() + STR + this.hashCode() + STR + wrappedString; } return connString; }	@return unique string representation of the underlying physical connection	1	0
public QueryBuilder newSubQueryBuilder(String entityName, String alias) { return new QueryBuilder( entityName, alias, aliasCounter, paramCounter, sessionFactory ); }	@return A sub-query builder for the given entity, with the given alias. The sub-query can be later used as a value of a parameter.	0	1
public static DefaultMetaBroadcaster metaBroadcaster() { return metaBroadcaster; }	@return the {@link org.atmosphere.cpr.MetaBroadcaster}	1	0
public Vector<String> getHeaders(String name) { Vector<String> v = mHeaderFields.get(name.toUpperCase()); return v; }	@return a vector holding the value as string.	0	1
public Env getApolloEnv() { return EnvUtils.transformEnv(Foundation.server().getEnvType()); }	@return the env	1	0
public TextView waitForText(String text, int expectedMinimumNumberOfMatches, long timeout, boolean scroll) { return waitForText(TextView.class, text, expectedMinimumNumberOfMatches, timeout, scroll, false, true); }	@return true if text is found and false if it is not found before the timeout	0	1
public Observable<ConnectivityStatus> observeConnectivity(final Context context) { final IntentFilter filter = new IntentFilter(); filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION); return Observable.create(new Observable.OnSubscribe<ConnectivityStatus>() { @Override public void call(final Subscriber<? super ConnectivityStatus> subscriber) { final BroadcastReceiver receiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { final ConnectivityStatus newStatus = getConnectivityStatus(context, checkInternet); // we need to perform check below, // because after going off-line, onReceive() is called twice if (newStatus != status) { status = newStatus; subscriber.onNext(newStatus); } } }; context.registerReceiver(receiver, filter); subscriber.add(unsubscribeInUiThread(new Action0() { @Override public void call() { context.unregisterReceiver(receiver); } })); } }).defaultIfEmpty(ConnectivityStatus.OFFLINE); }	@return RxJava Observable with ConnectivityStatus	0	1
@NonNull public static Calendar getInstance() { return Calendar.getInstance(Locale.getDefault()); }	@return a new Calendar instance with the date set to today. Time set to zero.	1	0
private String checkSubElementsNullability(Type propertyType, Object value) throws HibernateException { if ( propertyType.isComponentType() ) { return checkComponentNullability( value, (CompositeType) propertyType ); } if ( propertyType.isCollectionType() ) { // persistent collections may have components final CollectionType collectionType = (CollectionType) propertyType; final Type collectionElementType = collectionType.getElementType( session.getFactory() ); if ( collectionElementType.isComponentType() ) { // check for all components values in the collection final CompositeType componentType = (CompositeType) collectionElementType; final Iterator itr = CascadingActions.getLoadedElementsIterator( session, collectionType, value ); while ( itr.hasNext() ) { final Object compositeElement = itr.next(); if ( compositeElement != null ) { return checkComponentNullability( compositeElement, componentType ); } } } } return null; }	@return property path	0	1
private int executeSUCommands(String[] commands) throws EShellExecException { int ret = NUM; File rootFolder = new File(mRootOfWorkPath); File workingFolder = new File(rootFolder, TEMP_FOLDER); String workingFolderPath = workingFolder.getAbsolutePath(); if (!workingFolder.exists() && !workingFolder.mkdir()) { throw (new EShellExecException(STR)); } broadcastProgress(NUM, STR + workingFolder.getAbsolutePath()); try { Utils.extractExecutableAsset(this, ANDROID_BOOTMGR, workingFolderPath, true); Utils.extractExecutableAsset(this, ANDROID_LOOP_MOUNT, workingFolderPath, true); Utils.extractExecutableAsset(this, ARCHIVE_MASTER_ASC, workingFolderPath, false); Utils.extractExecutableAsset(this, ARCHIVE_MASTER, workingFolderPath, false); Utils.extractExecutableAsset(this, BUSYBOX, workingFolderPath, true); Utils.extractExecutableAsset(this, GPG, workingFolderPath, true); Utils.extractExecutableAsset(this, TAR, workingFolderPath, true); Utils.extractExecutableAsset(this, UPDATE_SCRIPT, workingFolderPath, true); Utils.extractExecutableAsset(this, U_REBOOT_APP_ASC, workingFolderPath, false); Utils.extractExecutableAsset(this, U_REBOOT_APP, workingFolderPath, false); Utils.extractExecutableAsset(this, UPGRADECHECKER, workingFolderPath, true); } catch (IOException e) { throw (new EShellExecException(STR)); } mWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, STR); try { Process process = Runtime.getRuntime().exec(STR, null, workingFolder); DataOutputStream os = new DataOutputStream(process.getOutputStream()); os.writeBytes(STR); os.writeBytes(STR); os.writeBytes(String.format(STR, workingFolder.getAbsolutePath())); os.writeBytes(String.format(STR, workingFolder.getAbsolutePath())); for (String cmd : commands) { Log.d(TAG, STR + cmd + STR); os.writeBytes(cmd + STR); os.writeBytes(STR); } os.writeBytes(String.format(STR, workingFolder.getAbsolutePath())); os.writeBytes(STR); os.flush(); int read = NUM; byte[] buff = new byte[NUM]; InputStream is = process.getInputStream(); InputStream es = process.getErrorStream(); boolean running = true; boolean scriptExecuted = false; do { while (is.available() > NUM) { read = is.read(buff); if (read <= NUM) { break; } scriptExecuted = true; String seg = new String(buff, NUM, read); Log.i(TAG, STR + seg); broadcastProgress(-NUM, seg); } while (es.available() > NUM) { read = es.read(buff); if (read <= NUM) { break; } scriptExecuted = true; String seg = new String(buff, NUM, read); if (seg.startsWith(STR)) { mTotalSize += PROGRESS_MKSWAP_ADJUSTMENT + PROGRESS_SWAP_CREATION_ADJUSTMENT; } else { mProgress++; if (mTotalSize > NUM && mLastSignalledProgress < (mProgress * NUM / mTotalSize)) { mLastSignalledProgress = (int) (mProgress * NUM / mTotalSize); broadcastProgress(mLastSignalledProgress, null); } } Log.i(TAG, STR + seg); } try { ret = process.exitValue(); Log.d(TAG, STR + ret); if (!scriptExecuted) { throw new EShellExecException(STR); } running = false; } catch (IllegalThreadStateException e) { try { Thread.sleep(NUM); } catch (Exception ex) { } } } while (running); } catch (IOException e) { throw (new EShellExecException(STR + e.getMessage())); } finally { if (mWakeLock != null && mWakeLock.isHeld()) { mWakeLock.release(); } } return ret; }	@return 0 for success and -1 for fail	1	0
protected Object convertInteger(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0; } if (data instanceof Integer) return data; if (data instanceof Number) { Number value = (Number) data; return new Integer(value.intValue()); } if (data instanceof Boolean) { return ((Boolean) data).booleanValue() ? INTEGER_TRUE : INTEGER_FALSE; } return handleUnknownData(column, fieldDefn, data); }	@return the converted value, or null if the conversion could not be made	1	0
public boolean equals(Object obj) { if (this == obj) { return true; } if (obj != null && getClass() == obj.getClass()) { BasicChronology chrono = (BasicChronology) obj; return getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() && getZone().equals(chrono.getZone()); } return false; }	@return true if equal	0	1
public boolean canShare() { if (this.getShareContent() == null) { return false; } final AccessToken accessToken = AccessToken.getCurrentAccessToken(); if (accessToken == null) { return false; } final Set<String> permissions = accessToken.getPermissions(); if (permissions == null || !permissions.contains(STR)) { Log.w(TAG, STR + STR); } return true; }	@return true if the current access token has the publish_actions permission, false otherwise.	1	0
public DateTime parseDateTime(String text) { DateTimeParser parser = requireParser(); Chronology chrono = selectChronology(null); DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear); int newPos = parser.parseInto(bucket, text, 0); if (newPos >= 0) { if (newPos >= text.length()) { long millis = bucket.computeMillis(true, text); if (iOffsetParsed && bucket.getOffset() != null) { int parsedOffset = bucket.getOffset(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); chrono = chrono.withZone(parsedZone); } else if (bucket.getZone() != null) { chrono = chrono.withZone(bucket.getZone()); } DateTime dt = new DateTime(millis, chrono); if (iZone != null) { dt = dt.withZone(iZone); } return dt; } } else { newPos = ~newPos; } throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos)); }	@return the parsed date-time, never null	0	1
public static boolean exceedsMaxCount() { final long maxTestCount = HostConfig.getMaxTestCount(); return (maxTestCount > NUM) && (mTestCount >= maxTestCount); }	@return If reached, return true; else, return false.	1	0
public ArrayList<View> getViews() { try { return ensureArrayListOrNull(viewFetcher.getViews()); } catch (Exception e) { e.printStackTrace(); return null; } }	@return a List of the Views located in the current Activity	0	1
public Element[] getComponentsMetadata() throws ParseException { Element[] components = m_elements[NUM].getElements(STR); Element[] composites = m_elements[NUM].getElements(STR); Element[] all = new Element[components.length + composites.length]; int l = NUM; for (int i = NUM; i < components.length; i++) { all[l] = components[i]; l++; } for (int i = NUM; i < composites.length; i++) { all[l] = composites[i]; l++; } return all; }	@return the component metadata.	1	0
public final int getPeekHeight() { return mPeekHeightAuto ? PEEK_HEIGHT_AUTO : mPeekHeight; }	@return The height of the collapsed bottom sheet.	1	0
Tuple2<Boolean, String> setFwkMetadata(String name, String sqlExpr, boolean createTable) throws SQLException { if (Boolean.getBoolean(NOAUTO_CREATE_METADATA)) return Tuple2.create(false, null); final SQLSystem sys = getServer().getSQLSystem(); final SQLSyntax syntax = sys.getSyntax(); final SQLDataSource ds = this.getDBSystemRoot().getDataSource(); synchronized (this.getTreeMutex()) { final boolean shouldRefresh; if (createTable && !this.contains(METADATA_TABLENAME)) { final SQLCreateMoveableTable create = getCreateMetadata(syntax); ds.execute(create.asString(getDBRoot().getName())); shouldRefresh = true; } else { shouldRefresh = false; } final Tuple2<Boolean, String> res; if (createTable || this.contains(METADATA_TABLENAME)) { final List<String> queries = new ArrayList<String>(); final SQLName tableName = new SQLName(this.getBase().getName(), this.getName(), METADATA_TABLENAME); final String where = STR + SQLBase.quoteIdentifier(STR) + STR + getBase().quoteString(name); queries.add(STR + tableName.quote() + where); final String returning = sys == SQLSystem.POSTGRESQL ? STR + SQLBase.quoteIdentifier(STR) : STR; final String ins = syntax.getInsertOne(tableName, Arrays.asList(STR, STR), getBase().quoteString(name), sqlExpr) + returning; queries.add(ins); final List<? extends ResultSetHandler> handlers; if (returning.length() == NUM) { queries.add(STR + SQLBase.quoteIdentifier(STR) + STR + tableName.quote() + where); handlers = Arrays.asList(null, null, SQLDataSource.SCALAR_HANDLER); } else { handlers = Arrays.asList(null, SQLDataSource.SCALAR_HANDLER); } final List<?> ress = SQLUtils.executeMultiple(getDBSystemRoot(), queries, handlers); res = Tuple2.create(true, (String) ress.get(ress.size() - NUM)); } else { res = Tuple2.create(false, null); } if (shouldRefresh) this.fetchTable(METADATA_TABLENAME); return res; } }	@return <code>true</code> if the value was set, <code>false</code> otherwise.	1	0
public byte get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }	@return the value of this attribute if this attribute is present in the map. Otherwise {@link #getDefaultValue()}	1	0
public OutEdges<I, E> unwrap() { if (currentEdge != null) { newEdges.add(currentEdge); currentEdge = null; } while (oldEdgesIterator.hasNext()) { newEdges.add(oldEdgesIterator.next()); } return newEdges; }	@return The new {@link VertexEdges} data structure.	1	0
"public String getName() { return name == null ? ""null"" : name.toUpperCase(); }"	@return the name	0	1
"private boolean zzRefill() throws java.io.IOException { /* first: make room (if you can) */ if (zzStartRead > 0) { zzEndRead += zzFinalHighSurrogate; zzFinalHighSurrogate = 0; System.arraycopy(zzBuffer, zzStartRead, zzBuffer, 0, zzEndRead-zzStartRead); /* translate stored positions */ zzEndRead-= zzStartRead; zzCurrentPos-= zzStartRead; zzMarkedPos-= zzStartRead; zzStartRead = 0; } /* is the buffer big enough? */ if (zzCurrentPos >= zzBuffer.length - zzFinalHighSurrogate) { /* if not: blow it up */ char newBuffer[] = new char[zzBuffer.length*2]; System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length); zzBuffer = newBuffer; zzEndRead += zzFinalHighSurrogate; zzFinalHighSurrogate = 0; } /* fill the buffer with new input */ int requested = zzBuffer.length - zzEndRead; int numRead = zzReader.read(zzBuffer, zzEndRead, requested); /* not supposed to occur according to specification of java.io.Reader */ if (numRead == 0) { throw new java.io.IOException(""Reader returned 0 characters. See JFlex examples for workaround.""); } if (numRead > 0) { zzEndRead += numRead; /* If numRead == requested, we might have requested to few chars to encode a full Unicode character. We assume that a Reader would otherwise never return half characters. */ if (numRead == requested) { if (Character.isHighSurrogate(zzBuffer[zzEndRead - 1])) { --zzEndRead; zzFinalHighSurrogate = 1; } } /* potentially more input available */ return false; } /* numRead < 0 ==> end of stream */ return true; }"	@return false, iff there was new input.	0	1
private synchronized static Supplier<Annotator> getOrCreate(String name, Properties props, Supplier<Annotator> annotator) { customAnnotators.register(name, props, Lazy.of(annotator)); return () -> customAnnotators.get(name); }	@return An annotator created by that factory.	1	0
public StringExpression substring(Expression<Integer> beginIndex, Expression<Integer> endIndex) { return StringOperation.create(Ops.SUBSTR_2ARGS, mixin, beginIndex, endIndex); }	@return this.substring(beginIndex, endIndex)	0	1
protected HttpSessionsSite getHttpSessionsSite(String site, boolean createIfNeeded) { if (sessions == null) { if (!createIfNeeded) return null; sessions = new HashMap<>(); } HttpSessionsSite hss = sessions.get(site); if (hss == null) { if (!createIfNeeded) return null; hss = new HttpSessionsSite(this, site); sessions.put(site, hss); } return hss; }	@return the http sessions site container	1	0
"public AggIterOutcome outputCurrentBatch() { // Handle the case of an EMIT with an empty batch if ( handleEmit && ( batchHolders == null || batchHolders[0].size() == 0 ) ) { lastBatchOutputCount = 0; // empty allocateOutgoing(0); for (VectorWrapper<?> v : outgoing) { v.getValueVector().getMutator().setValueCount(0); } outgoing.getContainer().setRecordCount(0); // When returning the last outgoing batch (following an incoming EMIT), then replace OK with EMIT this.outcome = IterOutcome.EMIT; handleEmit = false; // finish handling EMIT if ( outBatchIndex != null ) { outBatchIndex[0] = 0; // reset, for the next EMIT } return AggIterOutcome.AGG_EMIT; } // when incoming was an empty batch, just finish up if ( schema == null ) { logger.trace(""Incoming was empty; output is an empty batch.""); this.outcome = IterOutcome.NONE; // no records were read allFlushed = true; return AggIterOutcome.AGG_NONE; } // Initialization (covers the case of early output) ArrayList<BatchHolder> currPartition = batchHolders[earlyPartition]; int currOutBatchIndex = outBatchIndex[earlyPartition]; int partitionToReturn = earlyPartition; if ( ! earlyOutput ) { // Update the next partition to return (if needed) // skip fully returned (or spilled) partitions while (nextPartitionToReturn < numPartitions) { // // If this partition was spilled - spill the rest of it and skip it // if ( isSpilled(nextPartitionToReturn) ) { spillAPartition(nextPartitionToReturn); // spill the rest SpilledPartition sp = new SpilledPartition(); sp.spillFile = spillFiles[nextPartitionToReturn]; sp.spilledBatches = spilledBatchesCount[nextPartitionToReturn]; sp.cycleNum = cycleNum; // remember the current cycle sp.origPartn = nextPartitionToReturn; // for debugging / filename sp.prevOrigPartn = originalPartition; // for debugging / filename spilledPartitionsList.add(sp); reinitPartition(nextPartitionToReturn); // free the memory try { spillSet.close(writers[nextPartitionToReturn]); } catch (IOException ioe) { throw UserException.resourceError(ioe) .message(""IO Error while closing output stream"") .build(logger); } writers[nextPartitionToReturn] = null; } else { currPartition = batchHolders[nextPartitionToReturn]; currOutBatchIndex = outBatchIndex[nextPartitionToReturn]; // If curr batch (partition X index) is not empty - proceed to return it if (currOutBatchIndex < currPartition.size() && 0 != currPartition.get(currOutBatchIndex).getNumPendingOutput()) { break; } } nextPartitionToReturn++; // else check next partition } // if passed the last partition - either done or need to restart and read spilled partitions if (nextPartitionToReturn >= numPartitions) { // The following ""if"" is probably never used; due to a similar check at the end of this method if ( spilledPartitionsList.isEmpty() ) { // and no spilled partitions allFlushed = true; this.outcome = IterOutcome.NONE; if ( is2ndPhase && spillSet.getWriteBytes() > 0 ) { stats.setLongStat(Metric.SPILL_MB, // update stats - total MB spilled (int) Math.round(spillSet.getWriteBytes() / 1024.0D / 1024.0)); } return AggIterOutcome.AGG_NONE; // then return NONE } // Else - there are still spilled partitions to process - pick one and handle just like a new incoming buildComplete = false; // go back and call doWork() again handlingSpills = true; // beginning to work on the spill files // pick a spilled partition; set a new incoming ... SpilledPartition sp = spilledPartitionsList.remove(0); // Create a new ""incoming"" out of the spilled partition spill file newIncoming = new SpilledRecordbatch(sp.spillFile, sp.spilledBatches, context, schema, oContext, spillSet); originalPartition = sp.origPartn; // used for the filename logger.trace(""Reading back spilled original partition {} as an incoming"",originalPartition); // Initialize .... new incoming, new set of partitions try { initializeSetup(newIncoming); } catch (Exception e) { throw new RuntimeException(e); } // update the cycle num if needed // The current cycle num should always be one larger than in the spilled partition if ( cycleNum == sp.cycleNum ) { cycleNum = 1 + sp.cycleNum; stats.setLongStat(Metric.SPILL_CYCLE, cycleNum); // update stats // report first spill or memory stressful situations if ( cycleNum == 1 ) { logger.info(""Started reading spilled records ""); } if ( cycleNum == 2 ) { logger.info(""SECONDARY SPILLING ""); } if ( cycleNum == 3 ) { logger.warn(""TERTIARY SPILLING ""); } if ( cycleNum == 4 ) { logger.warn(""QUATERNARY SPILLING ""); } if ( cycleNum == 5 ) { logger.warn(""QUINARY SPILLING ""); } } if ( EXTRA_DEBUG_SPILL ) { logger.debug(""Start reading spilled partition {} (prev {}) from cycle {} (with {} batches). More {} spilled partitions left."", sp.origPartn, sp.prevOrigPartn, sp.cycleNum, sp.spilledBatches, spilledPartitionsList.size()); } return AggIterOutcome.AGG_RESTART; } partitionToReturn = nextPartitionToReturn ; } // get the number of records in the batch holder that are pending output int numPendingOutput = currPartition.get(currOutBatchIndex).getNumPendingOutput(); // The following accounting is for logging, metrics, etc. rowsInPartition += numPendingOutput ; if ( ! handlingSpills ) { rowsNotSpilled += numPendingOutput; } else { rowsSpilledReturned += numPendingOutput; } if ( earlyOutput ) { rowsReturnedEarly += numPendingOutput; } allocateOutgoing(numPendingOutput); currPartition.get(currOutBatchIndex).outputValues(outStartIdxHolder, outNumRecordsHolder); int numOutputRecords = outNumRecordsHolder.value; if (EXTRA_DEBUG_1) { logger.debug(""After output values: outStartIdx = {}, outNumRecords = {}"", outStartIdxHolder.value, outNumRecordsHolder.value); } this.htables[partitionToReturn].outputKeys(currOutBatchIndex, this.outContainer, outStartIdxHolder.value, outNumRecordsHolder.value, numPendingOutput); // set the value count for outgoing batch value vectors for (VectorWrapper<?> v : outgoing) { v.getValueVector().getMutator().setValueCount(numOutputRecords); } this.outcome = IterOutcome.OK; if ( EXTRA_DEBUG_SPILL && is2ndPhase ) { logger.debug(""So far returned {} + SpilledReturned {} total {} (spilled {})"",rowsNotSpilled,rowsSpilledReturned, rowsNotSpilled+rowsSpilledReturned, rowsSpilled); } lastBatchOutputCount = numOutputRecords; outBatchIndex[partitionToReturn]++; // if just flushed the last batch in the partition if (outBatchIndex[partitionToReturn] == currPartition.size()) { if ( EXTRA_DEBUG_SPILL ) { logger.debug(""HashAggregate: {} Flushed partition {} with {} batches total {} rows"", earlyOutput ? ""(Early)"" : """", partitionToReturn, outBatchIndex[partitionToReturn], rowsInPartition); } rowsInPartition = 0; // reset to count for the next partition // deallocate memory used by this partition, and re-initialize reinitPartition(partitionToReturn); if ( earlyOutput ) { if ( EXTRA_DEBUG_SPILL ) { logger.debug(""HASH AGG: Finished (early) re-init partition {}, mem allocated: {}"", earlyPartition, allocator.getAllocatedMemory()); } outBatchIndex[earlyPartition] = 0; // reset, for next time earlyOutput = false ; // done with early output } else if ( handleEmit ) { // When returning the last outgoing batch (following an incoming EMIT), then replace OK with EMIT this.outcome = IterOutcome.EMIT; handleEmit = false; // finished handling EMIT outBatchIndex[partitionToReturn] = 0; // reset, for the next EMIT return AggIterOutcome.AGG_EMIT; } else if ( (partitionToReturn + 1 == numPartitions) && spilledPartitionsList.isEmpty() ) { // last partition ? allFlushed = true; // next next() call will return NONE logger.trace(""HashAggregate: All batches flushed.""); // cleanup my internal state since there is nothing more to return this.cleanup(); } } return AggIterOutcome.AGG_OK; }"	@return iteration outcome (e.g., OK, NONE ...)	0	1
"public ApiResponse uploadFile (Long petId, String additionalMetadata, File file) throws ApiException { Object postBody = null; // verify the required parameter 'petId' is set if (petId == null) { throw new ApiException(400, ""Missing the required parameter 'petId' when calling uploadFile""); } // create path and map variables String path = ""/pet/{petId}/uploadImage"".replaceAll(""\\{format\\}"",""json"").replaceAll(""\\{"" + ""petId"" + ""\\}"", apiInvoker.escapeString(petId.toString())); // query params List<Pair> queryParams = new ArrayList<Pair>(); // header params Map<String, String> headerParams = new HashMap<String, String>(); // form params Map<String, String> formParams = new HashMap<String, String>(); String[] contentTypes = { ""multipart/form-data"" }; String contentType = contentTypes.length > 0 ? contentTypes[0] : ""application/json""; if (contentType.startsWith(""multipart/form-data"")) { // file uploading MultipartEntityBuilder builder = MultipartEntityBuilder.create(); if (additionalMetadata != null) { builder.addTextBody(""additionalMetadata"", ApiInvoker.parameterToString(additionalMetadata), ApiInvoker.TEXT_PLAIN_UTF8); } if (file != null) { builder.addBinaryBody(""file"", file); } HttpEntity httpEntity = builder.build(); postBody = httpEntity; } else { // normal form params formParams.put(""additionalMetadata"", ApiInvoker.parameterToString(additionalMetadata)); } try { String response = apiInvoker.invokeAPI(basePath, path, ""POST"", queryParams, postBody, headerParams, formParams, contentType); if(response != null){ return (ApiResponse) ApiInvoker.deserialize(response, """", ApiResponse.class); } else { return null; } } catch (ApiException ex) { throw ex; } }"	@return void	1	0
public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) { return appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2); }	@return this DateTimeFormatterBuilder	0	1
public boolean scrollUp(){ return scroller.scroll(Scroller.Direction.UP); }	@return true if more scrolling can be done and false if it is at the top of the screen	0	1
private Timepoint roundToValidTime(Timepoint newSelection, int currentItemShowing) { switch(currentItemShowing) { case HOUR_INDEX: return mController.roundToNearest(newSelection, null); case MINUTE_INDEX: return mController.roundToNearest(newSelection, Timepoint.TYPE.HOUR); default: return mController.roundToNearest(newSelection, Timepoint.TYPE.MINUTE); } }	@return Timepoint - the rounded value	0	1
public static ModuleConfig getModuleConfig(PageContext pageContext) { ModuleConfig moduleConfig = (ModuleConfig) pageContext.getRequest().getAttribute(Globals.MODULE_KEY); if (moduleConfig == null) { moduleConfig = (ModuleConfig) pageContext.getServletContext().getAttribute(Globals.MODULE_KEY); } return moduleConfig; }	@return the ApplicationConfig object	1	0
Folder getOpenFolder() { CellLayout currentScreen = (CellLayout) getChildAt(mCurrentScreen); int count = currentScreen.getChildCount(); for (int i = 0; i < count; i++) { View child = currentScreen.getChildAt(i); CellLayout.LayoutParams lp = (CellLayout.LayoutParams) child.getLayoutParams(); if (lp.cellHSpan == 4 && lp.cellVSpan == 4 && child instanceof Folder) { return (Folder) child; } } return null; }	@return The open folder on the current screen, or null if there is none	0	1
public int getBuffer(int k) { return (k >= NUM && k < getBufferSize()) ? buffer.get(k) : Config.NONEXIST; }	@return Sentence index or {@link CONST#NONEXIST} if stack doesn't have an element at this index	1	0
public boolean findCellForSpan(int[] cellXY, int spanX, int spanY) { if (cellXY == null) { cellXY = new int[2]; } return mOccupied.findVacantCell(cellXY, spanX, spanY); }	@return True if a vacant cell of the specified dimension was found, false otherwise.	0	1
public Builder hasArgs() { numberOfArgs = Option.UNLIMITED_VALUES; return this; }	@return boolean flag indicating if multiple values are allowed	1	0
"public Collection<Tree> getRelatedNodes(Tree t, Tree root) { if (root.value() == null) { root.setValue(""ROOT""); // todo: cdm: it doesn't seem like this line should be here } Set<Tree> nodeList = new LinkedHashSet<Tree>(); for (TregexPattern p : targetPatterns) { // cdm: I deleted: && nodeList.isEmpty() TregexMatcher m = p.matcher(root); while (m.findAt(t)) { nodeList.add(m.getNode(""target"")); //System.out.println(""found "" + this + ""("" + t + "", "" + m.getNode(""target"") + "") using pattern "" + p); } } return nodeList; }"	@return A Collection of dependent nodes to which t bears this GR	1	0
public double getExtraDouble(String key) throws JSONException { return mExtraData.getDouble(key); }	@return The stored value or null if it doesn't exist in specified form.	1	0
@SuppressWarnings(STR) public static <T, N extends TreeNode<T>> String toString(final N root) { final Function<N, String> toString; if (root instanceof Node<?>) { final Node<?> node = (Node<?>) root; toString = (Function<N, String>) node.toStringFunction(); } else { toString = new Function<N, String>() { @Override public String apply(final N input) { return Objects.firstNonNull(input.getData(), STR).toString(); } }; } return toString(root, toString); }	@return the node as a string	1	0
private int invoke_calculateBufferSize(int tdsVersion, int packetSize) { Class[] classes = new Class[] { int.class, int.class }; Object[] objects = new Object[] { new Integer(tdsVersion), new Integer(packetSize) }; return ((Integer) invokeStaticMethod(Support.class, STR, classes, objects)).intValue(); }	@return Result of calling {@link SharedNamedPipe#calculateBufferSize(int, int)}.	1	0
public static ClusterFixtureBuilder bareBuilder(BaseDirTestWatcher dirTestWatcher) { return new ClusterFixtureBuilder(dirTestWatcher); }	@return a fixture builder with no default properties set	0	1
private BigDecimal getCurrentCostPriceLL(MPPProductBOM bom, MCostElement element) { log.info(STR + element.getCostElementType()); BigDecimal costPriceLL = Env.ZERO; if (bom == null) return costPriceLL; for (MPPProductBOMLine bomline : bom.getLines()) { MProduct component = MProduct.get(getCtx(), bomline.getM_Product_ID()); for (MCost cost : getCosts(component, element.getCostElementType())) { BigDecimal qtyPercentage = bomline.getQtyBatch().divide(Env.ONEHUNDRED, NUM, BigDecimal.ROUND_UP); BigDecimal qtyBOM = bomline.getQtyBOM(); BigDecimal scrapDec = bomline.getScrap().divide(Env.ONEHUNDRED, NUM, BigDecimal.ROUND_UP); BigDecimal qtyTotal = Env.ZERO; if (bomline.isQtyPercentage()) { qtyTotal = qtyPercentage.divide(Env.ONE.subtract(scrapDec), NUM, BigDecimal.ROUND_HALF_UP); } else { qtyTotal = qtyBOM.divide(Env.ONE.subtract(scrapDec), NUM, BigDecimal.ROUND_HALF_UP); } BigDecimal costPrice = cost.getCurrentCostPrice().add(cost.getCurrentCostPriceLL()); costPriceLL = costPriceLL.add(costPrice.multiply(qtyTotal)); log.info(STR + element.getName() + STR + costPriceLL + STR + qtyPercentage + STR + qtyBOM); } } return costPriceLL; }	@return CurrentCostPriceLL Sum Current Cost Price Level Low for this Cost Element Type	1	0
public Material asMaterialFromName() { return Material.getMaterial(raw.toUpperCase()); }	@return The material whose name is the same as the raw arg, or null if no material has that name	1	0
public boolean searchButton(String text) { return searcher.searchWithTimeoutFor(Button.class, text, 0, true, false); }	@return true if a Button with the given text is found and false if it is not found	0	1
"public String[] getAllWindowIds() { return getAttributeFromAllWindows(""id""); }"	@return the IDs of all windows that the browser knows about.	0	1
public final boolean isPosOnAdView(final int pos) { return isOnAdView(pos); }	@return yes or no	1	0
"public String getTypeDeclaration(Schema p) { String schemaType = getSchemaType(p); if (schemaType != null) { schemaType = schemaType.replace(""-"", ""_""); } if (ModelUtils.isArraySchema(p)) { ArraySchema ap = (ArraySchema) p; Schema inner = ap.getItems(); return getTypeDeclaration(inner) + ""_Vectors.Vector""; } if (ModelUtils.isMapSchema(p)) { Schema inner = (Schema) p.getAdditionalProperties(); String name = getTypeDeclaration(inner) + ""_Map""; if (name.startsWith(""Swagger."")) { return name; } else { return ""Swagger."" + name; } } if (typeMapping.containsKey(schemaType)) { return typeMapping.get(schemaType); } // LOGGER.info(""Swagger type "" + schemaType); if (languageSpecificPrimitives.contains(schemaType)) { return schemaType; } String modelType = toModelName(schemaType).replace(""-"", ""_""); if (ModelUtils.isStringSchema(p) || ModelUtils.isFileSchema(p) || languageSpecificPrimitives.contains(modelType)) { return modelType; } return modelPackage + "".Models."" + modelType; }"	@return a string value used as the `dataType` field for model templates, `returnType` for api templates	0	1
static boolean isNewStyleColumn(Common.ColumnValue column) { return column.hasField(HAS_ARRAY_VALUE_DESCRIPTOR) || column.hasField(SCALAR_VALUE_DESCRIPTOR); }	@return True if the message is the new style, false otherwise.	0	1
public DateTimeFormatterBuilder appendDayOfYear(int minDigits) { return appendDecimal(DateTimeFieldType.dayOfYear(), minDigits, 3); }	@return this DateTimeFormatterBuilder	0	1
public boolean isDelicious() { return this.isBaked() || this.isBoiled(); }	@return true if this potato is delicious, false if otherwise	0	1
protected LdapDirectoryInfo performAuthentication(String username, char[] password) { if (searchBase == null) { throw new IllegalStateException(STR); } if (url == null) { throw new IllegalStateException(STR); } if (principalSuffix != null) { username = username + principalSuffix; } Hashtable<String, String> env = new Hashtable<String, String>(NUM); env.put(Context.SECURITY_AUTHENTICATION, authentication); env.put(Context.SECURITY_PRINCIPAL, username); env.put(Context.SECURITY_CREDENTIALS, new String(password)); env.put(Context.INITIAL_CONTEXT_FACTORY, contextFactory); env.put(Context.PROVIDER_URL, url); env.put(Context.REFERRAL, refferal); if (log.isDebugEnabled()) { log.debug(STR + env + STR); } LdapContext ctx = null; try { ctx = new InitialLdapContext(env, null); return getLdapDirectoryInfo(username, ctx); } catch (javax.naming.AuthenticationException e) { throw new IncorrectCredentialException(STR, e); } catch (NamingException e) { throw new AuthenticationException(STR, e); } finally { try { if (ctx != null) { ctx.close(); } } catch (NamingException e) { if (log.isErrorEnabled()) { log.error(STR, e); } } } }	@return the results of the active directory search.	1	0
public boolean start() { if (isReleased()) throw new IllegalStateException(STR); return nativeStart(); }	@return true the serive is started	1	0
public Iterator<Table> getTableMappings() { return tables.values().iterator(); }	@return Iterator of the table mappings currently contained in the configuration.	0	1
@SuppressWarnings(STR) public ObjectName getQueueObjectName(String virtualHostName, String queue) { AllObjects allObject = new AllObjects(_mbsc); allObject.querystring = STR + virtualHostName + STR + queue + STR; Set<ObjectName> objectNames = allObject.returnObjects(); _test.assertNotNull(STR, objectNames); _test.assertEquals(STR + allObject.querystring + STR, NUM, objectNames.size()); ObjectName objectName = objectNames.iterator().next(); _test.getLogger().info(STR + objectName); return objectName; }	@return the ObjectName for the given exchange on the test VirtualHost.	1	0
public boolean[] getSlew() { boolean[] data = new boolean[NUM]; String answer = this.getData(STR, STR, STR); data[NUM] = (!answer.equals(STR)); answer = this.getData(STR, STR, STR); data[NUM] = (!answer.equals(STR)); answer = this.getData(STR, STR, STR); data[NUM] = (!answer.equals(STR)); return data; }	@return true if Fast Slew is on, false if not	1	0
protected int getInSubqueryThreshold() { return config.getInSubqueryThreshold(); }	@return threshold, default #IN_SUBQUERY_THRESHOLD	1	0
public static Builder newSchema(GraphQLSchema existingSchema) { return new Builder() .query(existingSchema.getQueryType()) .mutation(existingSchema.getMutationType()) .subscription(existingSchema.getSubscriptionType()) .fieldVisibility(existingSchema.getFieldVisibility()) .clearAdditionalTypes() .clearDirectives() .additionalDirectives(existingSchema.directives) .additionalTypes(existingSchema.additionalTypes); }	@return a new schema builder	0	1
public String getAuthorizationUrl(String state, Map<String, String> additionalParams, PKCE pkce) { return createAuthorizationUrlBuilder() .state(state) .additionalParams(additionalParams) .pkce(pkce) .build(); }	@return the URL where you should redirect your users	1	0
"public static String tripleToString(RelationTriple extraction, String docid, CoreMap sentence) { switch (FORMAT) { case REVERB: return extraction.toReverbString(docid, sentence); case OLLIE: return extraction.confidenceGloss() + "": ("" + extraction.subjectGloss() + ""; "" + extraction.relationGloss() + ""; "" + extraction.objectGloss() + "")""; case DEFAULT: return extraction.toString(); case QA_SRL: return extraction.toQaSrlString(sentence); default: throw new IllegalStateException(""Format is not implemented: "" + FORMAT); } }"	@return A String representation of the triple.	0	1
@ManagedAttribute(description = STR) public long getNewPeriodCount() { return newPeriodCount.longValue(); }	@return the newPeriodCount	1	0
"public Applications getApplications(String serviceUrl) { try { EurekaHttpResponse<Applications> response = clientConfig.getRegistryRefreshSingleVipAddress() == null ? eurekaTransport.queryClient.getApplications() : eurekaTransport.queryClient.getVip(clientConfig.getRegistryRefreshSingleVipAddress()); if (response.getStatusCode() == 200) { logger.debug(PREFIX + appPathIdentifier + "" - refresh status: "" + response.getStatusCode()); return response.getEntity(); } logger.error(PREFIX + appPathIdentifier + "" - was unable to refresh its cache! status = "" + response.getStatusCode()); } catch (Throwable th) { logger.error(PREFIX + appPathIdentifier + "" - was unable to refresh its cache! status = "" + th.getMessage(), th); } return null; }"	@return - The registry information containing all applications.	0	1
"public Service<Vault> createLockAllService(Collection<Vault> vaults, boolean forced) { Iterator<Vault> iter = ImmutableList.copyOf(vaults).iterator(); ScheduledService<Vault> service = new ScheduledService<>() { @Override protected Task<Vault> createTask() { assert Platform.isFxApplicationThread(); if (iter.hasNext()) { return new LockVaultTask(iter.next(), forced); } else { cancel(); return new IllegalStateTask(""This task should never be executed.""); } } }; service.setExecutor(executorService); return service; }"	@return Service that tries to lock all given vaults	1	0
public String getContent() { //return node.getTextContent(); // requires Android 2.2 StringBuilder buffer = new StringBuilder(); NodeList childList = node.getChildNodes(); for (int i = 0; i < childList.getLength(); i++) { Node child = childList.item(i); if (child.getNodeType() == Node.TEXT_NODE) { // skip non-text nodes buffer.append(child.getNodeValue()); } } return buffer.toString(); }	@return the content.	0	1
public synchronized IConfigurationElement[] getContainerConfigurations(String containerid, String[] containerPaths) { if (contributions == null) processProxyContributionExtensionPoint(); return (IConfigurationElement[]) contributions.containerPathContributions.getContributors(containerid, containerPaths); }	@return Array of configuration elements or <code>null</code> if this container has no contributions.	1	0
public String toDefaultValue(Schema schema) { if (schema.getDefault() != null) { return schema.getDefault().toString(); } return getPropertyDefaultValue(schema); }	@return string presentation of the default value of the property	0	1
public static CacheEntity parseCacheHeaders(Headers responseHeaders, byte[] responseBody) { CacheEntity cacheEntity = new CacheEntity(); cacheEntity.setData(responseBody); cacheEntity.setLocalExpire(getLocalExpires(responseHeaders)); cacheEntity.setResponseHeaders(responseHeaders); return cacheEntity; }	@return Cache entity.	1	0
protected Object convertTimeToMicrosPastMidnight(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0L; // return epoch } try { return MicroTime.toMicroOfDay(data); } catch (IllegalArgumentException e) { return handleUnknownData(column, fieldDefn, data); } }	@return the converted value, or null if the conversion could not be made	1	0
"public static String versionName() { return ""1.0.2""; }"	@return String.	0	1
"protected Tree determineNonTrivialHead(Tree t, Tree parent) { String motherCat = tlp.basicCategory(t.label().value()); if (DEBUG) { System.err.println(""At "" + motherCat + "", my parent is "" + parent); } // do VPs with auxiliary as special case if ((motherCat.equals(""VP"") || motherCat.equals(""SQ"") || motherCat.equals(""SINV""))) { Tree[] kids = t.children(); // try to find if there is an auxiliary verb if (DEBUG) { System.err.println(""Semantic head finder: at VP""); System.err.println(""Class is "" + t.getClass().getName()); t.pennPrint(System.err); //System.err.println(""hasVerbalAuxiliary = "" + hasVerbalAuxiliary(kids, verbalAuxiliaries)); } // looks for auxiliaries if (hasVerbalAuxiliary(kids, verbalAuxiliaries) || hasPassiveProgressiveAuxiliary(kids, passiveAuxiliaries)) { // String[] how = new String[] {""left"", ""VP"", ""ADJP"", ""NP""}; // Including NP etc seems okay for copular sentences but is // problematic for other auxiliaries, like 'he has an answer' // But maybe doing ADJP is fine! String[] how = { ""left"", ""VP"", ""ADJP"" }; Tree pti = traverseLocate(kids, how, false); if (DEBUG) { System.err.println(""Determined head (case 1) for "" + t.value() + "" is: "" + pti); } if (pti != null) { return pti; } else { // System.err.println(""------""); // System.err.println(""SemanticHeadFinder failed to reassign head for""); // t.pennPrint(System.err); // System.err.println(""------""); } } // looks for copular verbs if (hasVerbalAuxiliary(kids, copulars) && ! isExistential(t, parent) && ! isWHQ(t, parent)) { String[] how; if (motherCat.equals(""SQ"")) { how = new String[]{""right"", ""VP"", ""ADJP"", ""NP"", ""WHADJP"", ""WHNP""}; } else { how = new String[]{""left"", ""VP"", ""ADJP"", ""NP"", ""WHADJP"", ""WHNP""}; } Tree pti = traverseLocate(kids, how, false); // don't allow a temporal to become head if (pti != null && pti.label() != null && pti.label().value().contains(""-TMP"")) { pti = null; } // In SQ, only allow an NP to become head if there is another one to the left (then it's probably predicative) if (motherCat.equals(""SQ"") && pti != null && pti.label() != null && pti.label().value().startsWith(""NP"")) { boolean foundAnotherNp = false; for (Tree kid : kids) { if (kid == pti) { break; } else if (kid.label() != null && kid.label().value().startsWith(""NP"")) { foundAnotherNp = true; break; } } if ( ! foundAnotherNp) { pti = null; } } if (DEBUG) { System.err.println(""Determined head (case 2) for "" + t.value() + "" is: "" + pti); } if (pti != null) { return pti; } else { if (DEBUG) { System.err.println(""------""); System.err.println(""SemanticHeadFinder failed to reassign head for""); t.pennPrint(System.err); System.err.println(""------""); } } } } Tree hd = super.determineNonTrivialHead(t, parent); // Heuristically repair punctuation heads Tree[] hdChildren = hd.children(); if (hdChildren != null && hdChildren.length > 0 && hdChildren[0].isLeaf()) { if (tlp.isPunctuationWord(hdChildren[0].label().value())) { Tree[] tChildren = t.children(); if (DEBUG) { System.err.printf(""head is punct: %s\n"", hdChildren[0].label()); } for (int i = tChildren.length - 1; i >= 0; i--) { if (!tlp.isPunctuationWord(tChildren[i].children()[0].label().value())) { hd = tChildren[i]; if (DEBUG) { System.err.printf(""New head: %s %s"", hd.label(), hd.children()[0].label()); } break; } } } } if (DEBUG) { System.err.println(""Determined head (case 3) for "" + t.value() + "" is: "" + hd); } return hd; }"	@return The parse tree that is the head	0	1
public static int[] getViewToHeaderPosition(JTextArea view, int start, int end) { validateView(view); validateStartEnd(start, end); if (!isValidStartEndForLength(start, end, view.getDocument().getLength())) { return INVALID_POSITION; } return getViewToHeaderPositionImpl(view, start, end); }	@return the positions offset for the header	1	0
"public String toEnumVarName(String value, String datatype) { String modified; if (value.length() == 0) { modified = ""EMPTY""; } else { modified = value; modified = sanitizeKotlinSpecificNames(modified); } switch (getEnumPropertyNaming()) { case original: // NOTE: This is provided as a last-case allowance, but will still result in reserved words being escaped. modified = value; break; case camelCase: // NOTE: Removes hyphens and underscores modified = camelize(modified, true); break; case PascalCase: // NOTE: Removes hyphens and underscores String result = camelize(modified); modified = titleCase(result); break; case snake_case: // NOTE: Removes hyphens modified = underscore(modified); break; case UPPERCASE: modified = modified.toUpperCase(); break; } if (reservedWords.contains(modified)) { return escapeReservedWord(modified); } return modified; }"	@return the sanitized variable name for enum	0	1
"private ZapTextArea getTxtOutput() { if (txtOutput == null) { txtOutput = new ZapTextArea(); txtOutput.setEditable(false); txtOutput.setLineWrap(true); txtOutput.setFont(new java.awt.Font(""Dialog"", java.awt.Font.PLAIN, 12)); txtOutput.setName(""""); txtOutput.addMouseListener(new java.awt.event.MouseAdapter() { public void mousePressed(java.awt.event.MouseEvent e) { if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0) { // right mouse button View.getSingleton().getPopupMenu().show(e.getComponent(), e.getX(), e.getY()); } } }); } return txtOutput; }"	@return javax.swing.JTextArea	1	0
"public Pet getPetById(Long petId) throws ApiException { Object localVarPostBody = null; // verify the required parameter 'petId' is set if (petId == null) { throw new ApiException(400, ""Missing the required parameter 'petId' when calling getPetById""); } // create path and map variables String localVarPath = ""/pet/{petId}"" .replaceAll(""\\{"" + ""petId"" + ""\\}"", apiClient.escapeString(petId.toString())); // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, String> localVarCookieParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { ""application/xml"", ""application/json"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { ""api_key"" }; GenericType<Pet> localVarReturnType = new GenericType<Pet>() {}; return apiClient.invokeAPI(localVarPath, ""GET"", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	@return Pet	0	1
protected RelNode trimUnusedFields(RelNode rootRel) { final SqlToRelConverter converter = getSqlToRelConverter( getSqlValidator(), catalogReader); converter.setTrimUnusedFields(shouldTrim(rootRel)); return converter.trimUnusedFields(ordered, rootRel); }	@return Trimmed relational expression	0	1
public Expression getKey() { return key; }	@return the key with which the value will be associated	1	0
ScrollQuery scanLimit(String query, BytesArray body, long limit, ScrollReader reader) { return new ScrollQuery(this, query, body, limit, reader); }	@return a scroll query	0	1
List<ContextPanelFactory> getContextPanelFactories() { return unmodifiableList(contextPanelFactories); }	@return an unmodifiable List containing the added ContextPanelFactorys, never null.	0	1
public int getSeconds() { return getPeriodType().getIndexedField(this, PeriodType.SECOND_INDEX); }	@return the number of seconds in the period, zero if unsupported	0	1
public android.telecom.Connection.VideoProvider getVideoProvider() { return mVideoProvider; }	@return The {@link android.telecomm.Connection.VideoProvider}.	1	0
@NonNull protected List<Action> retrieveActions(@NonNull SCMSourceEvent event, @NonNull TaskListener listener) throws IOException, InterruptedException { return Collections.emptyList(); }	@return the map of {@link Action} instances to persist, keyed by the class of action. Keys with {@code null} values indicate actions that should be removed if present.	1	0
static public IStructuredTextExpert getStatefulExpert(StructuredTextTypeHandler handler, StructuredTextEnvironment environment) { if (environment == null) environment = StructuredTextEnvironment.DEFAULT; return new StructuredTextImpl(handler, environment, true); }	@return the ISTextExpert instance.	1	0
public <T> HttpResponse<T> doGet(HttpRequest httpRequest, final Class<T> responseType) { Function<String, T> convertResponse = new Function<String, T>() { @Override public T apply(String input) { return gson.fromJson(input, responseType); } }; return doGetWithSerializeFunction(httpRequest, convertResponse); }	@return the http response	1	0
public ErrorLevel getLevel() { return level; }	@return a VirErrorLevel	1	0
"private Annotation getDocument(Properties props, HttpExchange httpExchange) throws IOException, ClassNotFoundException { String inputFormat = props.getProperty(""inputFormat"", ""text""); String date = props.getProperty(""date""); switch (inputFormat) { case ""text"": // The default encoding by the HTTP standard is ISO-8859-1, but most // real users of CoreNLP would likely assume UTF-8 by default. String defaultEncoding = this.strict ? ""ISO-8859-1"" : ""UTF-8""; // Get the encoding Headers h = httpExchange.getRequestHeaders(); String encoding; if (h.containsKey(""Content-type"")) { String[] charsetPair = Arrays.asList(h.getFirst(""Content-type"").split("";"")).stream() .map(x -> x.split(""="")) .filter(x -> x.length > 0 && ""charset"".equals(x[0])) .findFirst().orElse(new String[]{""charset"", defaultEncoding}); if (charsetPair.length == 2) { encoding = charsetPair[1]; } else { encoding = defaultEncoding; } } else { encoding = defaultEncoding; } String text = IOUtils.slurpReader(IOUtils.encodedInputStreamReader(httpExchange.getRequestBody(), encoding)); text = URLDecoder.decode(text, encoding).trim(); // TODO(chaganty): URLdecode string. // Read the annotation Annotation annotation = new Annotation(text); // Set the date (if provided) if (date != null) { annotation.set(CoreAnnotations.DocDateAnnotation.class, date); } return annotation; case ""serialized"": String inputSerializerName = props.getProperty(""inputSerializer"", ProtobufAnnotationSerializer.class.getName()); AnnotationSerializer serializer = MetaClass.create(inputSerializerName).createInstance(); Pair<Annotation, InputStream> pair = serializer.read(httpExchange.getRequestBody()); return pair.first; default: throw new IOException(""Could not parse input format: "" + inputFormat); } }"	@return An Annotation representing the read document.	0	1
protected Object convertBigInt(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0L; } if (data instanceof Long) return data; if (data instanceof Number) { Number value = (Number) data; return new Long(value.longValue()); } if (data instanceof Boolean) { return ((Boolean) data).booleanValue() ? LONG_TRUE : LONG_FALSE; } return handleUnknownData(column, fieldDefn, data); }	@return the converted value, or null if the conversion could not be made	1	0
"public DictionaryInfo trySaveNewDict(Dictionary<?> newDict, DictionaryInfo newDictInfo) throws IOException { initDictInfo(newDict, newDictInfo); if (KylinConfig.getInstanceFromEnv().isGrowingDictEnabled()) { DictionaryInfo largestDictInfo = findLargestDictInfo(newDictInfo); if (largestDictInfo != null) { largestDictInfo = getDictionaryInfo(largestDictInfo.getResourcePath()); Dictionary<?> largestDictObject = largestDictInfo.getDictionaryObject(); if (largestDictObject.contains(newDict)) { logger.info(""dictionary content "" + newDict + "", is contained by dictionary at "" + largestDictInfo.getResourcePath()); return largestDictInfo; } else if (newDict.contains(largestDictObject)) { logger.info(""dictionary content "" + newDict + "" is by far the largest, save it""); return saveNewDict(newDictInfo); } else { logger.info(""merge dict and save...""); return mergeDictionary(Lists.newArrayList(newDictInfo, largestDictInfo)); } } else { logger.info(""first dict of this column, save it directly""); return saveNewDict(newDictInfo); } } else { logger.info(""Growing dict is not enabled""); String dupDict = checkDupByContent(newDictInfo, newDict); if (dupDict != null) { logger.info(""Identical dictionary content, reuse existing dictionary at "" + dupDict); return getDictionaryInfo(dupDict); } return saveNewDict(newDictInfo); } }"	@return may return another dict that is a super set of the input	0	1
public double valueSum() { // We want the exp(log-sum-exp), for stability // This rearranges to exp(a)*(sum-exp) double max = 0.0; for (int[] assignment : this) { double v = getAssignmentLogValue(assignment); if (v > max) { max = v; } } double sumExp = 0.0; for (int[] assignment : this) { sumExp += Math.exp(getAssignmentLogValue(assignment) - max); } return sumExp * Math.exp(max); }	@return the sum of all values for all assignments to the TableFactor	0	1
public static <T, N extends TreeNode<T>> String toString(final N inputNode, final Function<N, String> toString) { final StringBuilder builder = new StringBuilder(); depthFirst(inputNode, new TreeVisitor<N>() { final Set<Integer> depths = Sets.newHashSet(); @SuppressWarnings(STR) @Override public void onNode(final int depth, final N node) { if (!isRoot(node) && !isLeaf(node) && !isLastChild(node)) { this.depths.add(depth); } else { this.depths.remove(depth); } builder.append(indent(depth)); final String nodeString = toString.apply(node); builder.append(STR).append(nodeString).append(Strings2.NEW_LINE); } private String indent(final int depth) { final StringBuilder b = new StringBuilder(); for (int i = NUM; i < depth; i++) { if (this.depths.contains(Integer.valueOf(i))) { b.append(STR); } else { b.append(STR); } } return b.toString(); } }); return builder.toString(); }	@return the node as a string	1	0
protected ReadableInstant create(long instant, Chronology chrono) { // ignore chrono if (instant == getMillis()) { return this; } return new Instant(instant); }	@return a new instance of this class	0	1
public static DateTimeFormatter dateHourMinuteSecondFraction() { return Constants.dhmsf; }	@return a formatter for yyyy-MM-dd'T'HH:mm:ss.SSS	0	1
protected Problem findProblem(int line) { List<Problem> problems = findProblems(line); for (Problem p : problems) { if (p.isError()) return p; } return problems.isEmpty() ? null : problems.get(0); }	@return the Problem for the most relevant error or warning on 'line', defaulting to the first.	1	0
public CompositeData[] browse() throws OpenDataException{ return broker.browse(this); }	@return messages	0	1
public static Treepath getNextSibling(Treepath treepath) { if (treepath.getHeight() < NUM) { throw new IllegalArgumentException(STR); } final Tree treeToMove = treepath.getBottom(); final Tree parent = treepath.getTreeAtHeight(NUM); for (int i = NUM; i < parent.getChildCount() - NUM; i++) { final Tree child = parent.getChildAt(i); if (child == treeToMove) { return Treepath.create(treepath.getParent(), parent.getChildAt(i + NUM)); } } throw new IllegalArgumentException(STR); }	@return non-null if sibling was found, null otherwise.	1	0
public static CacheMode getById(int id) throws FxNotFoundException { for (CacheMode mode : CacheMode.values()) { if (mode.id == id) return mode; } throw new FxNotFoundException(STR, id); }	@return CACHE_MODE the type	1	0
public static EDecimal<Double> random(){ if (random == null){ random = ODecimal.create(Double.class, MathOps.RANDOM); } return random; }	@return random()	0	1
public int toStatusCode(Throwable thrown) { if (thrown == null) { return SUCCESS; } else if (thrown instanceof InvalidCookieDomainException) { return INVALID_COOKIE_DOMAIN; } else if (thrown instanceof UnableToSetCookieException) { return UNABLE_TO_SET_COOKIE; } else if (thrown instanceof NoSuchWindowException) { return NO_SUCH_WINDOW; } else if (thrown instanceof InvalidSelectorException) { return INVALID_SELECTOR_ERROR; } else if (thrown instanceof NoSuchElementException) { return NO_SUCH_ELEMENT; } else if (thrown instanceof NoSuchFrameException) { return NO_SUCH_FRAME; } else if (thrown instanceof StaleElementReferenceException) { return STALE_ELEMENT_REFERENCE; } else if (thrown instanceof ElementNotVisibleException) { return ELEMENT_NOT_VISIBLE; } else if (thrown instanceof InvalidElementStateException) { return INVALID_ELEMENT_STATE; } else if (thrown instanceof XPathLookupException) { return XPATH_LOOKUP_ERROR; } else if (thrown instanceof TimeoutException) { return ASYNC_SCRIPT_TIMEOUT; } else if (thrown instanceof InvalidCoordinatesException) { return INVALID_ELEMENT_COORDINATES; } else if (thrown instanceof ImeNotAvailableException) { return IME_NOT_AVAILABLE; } else if (thrown instanceof ImeActivationFailedException) { return IME_ENGINE_ACTIVATION_FAILED; } else if (thrown instanceof NoAlertPresentException) { return NO_ALERT_PRESENT; } else { return UNHANDLED_ERROR; } }	@return The corresponding status code for the given thrown error.	0	1
public InstrumentationExecutionParameters withNewState(InstrumentationState instrumentationState) { return new InstrumentationExecutionParameters(this.getExecutionInput(), this.schema, instrumentationState); }	@return a new parameters object with the new state	0	1
public T sum() { return sum; }	@return long total of values seen	1	0
static boolean isAllNulls(Statistics stat, long rowCount) { return stat.isNumNullsSet() && stat.getNumNulls() == rowCount; }	@return True if all rows are null in the parquet file False if at least one row is not null.	0	1
protected RecordCommitter buildRecordCommitter(OffsetStorageWriter offsetWriter, SourceTask task, Duration commitTimeout) { return new RecordCommitter() { @Override public synchronized void markProcessed(SourceRecord record) throws InterruptedException { task.commitRecord(record); recordsSinceLastCommit += 1; offsetWriter.offset(record.sourcePartition(), record.sourceOffset()); } @Override public synchronized void markBatchFinished() { maybeFlush(offsetWriter, offsetCommitPolicy, commitTimeout, task); } }; }	@return the new recordCommitter to be used for a given batch	0	1
public ApiResponse<ApiResponse> uploadFileWithHttpInfo(Long petId, String additionalMetadata, File file) throws ApiException { Call call = uploadFileCall(petId, additionalMetadata, file, null, null); Type localVarReturnType = new TypeToken<ApiResponse>(){}.getType(); return apiClient.execute(call, localVarReturnType); }	@return ApiResponse	0	1
"public ConcurrentSecondLevelCacheStatisticsImpl getSecondLevelCacheStatistics(String regionName) { ConcurrentSecondLevelCacheStatisticsImpl stat = secondLevelCacheStatistics.get( regionName ); if ( stat == null ) { if ( sessionFactory == null ) { return null; } final EntityRegionAccessStrategy entityRegionAccess = sessionFactory.getCache().getEntityRegionAccess( regionName ); final CollectionRegionAccessStrategy collectionRegionAccess = sessionFactory.getCache().getCollectionRegionAccess( regionName ); if ( entityRegionAccess == null && collectionRegionAccess == null ) { final QueryCache queryCache = sessionFactory.getCache().getQueryCache( regionName ); if ( queryCache == null ) { return null; } final Region region = queryCache.getRegion(); if ( region == null ) { throw new IllegalArgumentException( ""Could not resolve region name ["" + regionName + ""]"" ); } stat = new ConcurrentSecondLevelCacheStatisticsImpl( region, null, null ); } else { final Region region = entityRegionAccess != null ? entityRegionAccess.getRegion() : collectionRegionAccess.getRegion(); stat = new ConcurrentSecondLevelCacheStatisticsImpl( region, entityRegionAccess, collectionRegionAccess ); } ConcurrentSecondLevelCacheStatisticsImpl previous; if ( ( previous = secondLevelCacheStatistics.putIfAbsent( regionName, stat ) ) != null ) { stat = previous; } } return stat; }"	@return SecondLevelCacheStatistics	1	0
private static ArrayList<Uri> getTreeUris(Context context) { ArrayList<Uri> uris = new ArrayList<Uri>(); Uri uri1 = getSharedPreferenceUri(context, R.string.preference_internal_uri_extsdcard_photos); if (uri1 != null) uris.add(uri1); return uris; }	@return The tree URIs.	0	1
public Object get(long timeout, String key) throws TimeoutException { SynchronizationObject<CachedData[]> sync = setupGet(key); waitForNotNull(timeout, sync); CachedData[] rvContainer = sync.get(); assert rvContainer.length == NUM; Object rv = null; if (rvContainer[NUM] != null) { rv = transcoder.decode(rvContainer[NUM]); } return rv; }	@return a map of the values (for each value that exists)	1	0
"public static Schema unaliasSchema(OpenAPI openAPI, Schema schema) { Map<String, Schema> allSchemas = getSchemas(openAPI); if (allSchemas == null || allSchemas.isEmpty()) { // skip the warning as the spec can have no model defined //LOGGER.warn(""allSchemas cannot be null/empty in unaliasSchema. Returned 'schema'""); return schema; } if (schema != null && StringUtils.isNotEmpty(schema.get$ref())) { Schema ref = allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())); if (ref == null) { LOGGER.warn(""{} is not defined"", schema.get$ref()); return schema; } else if (ref.getEnum() != null && !ref.getEnum().isEmpty()) { // top-level enum class return schema; } else if (isArraySchema(ref)) { if (generateAliasAsModel) { return schema; // generate a model extending array } else { return unaliasSchema(openAPI, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()))); } } else if (isComposedSchema(ref)) { return schema; } else if (isMapSchema(ref)) { if (ref.getProperties() != null && !ref.getProperties().isEmpty()) // has at least one property return schema; // treat it as model else { if (generateAliasAsModel) { return schema; // generate a model extending map } else { // treat it as a typical map return unaliasSchema(openAPI, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()))); } } } else if (isObjectSchema(ref)) { // model if (ref.getProperties() != null && !ref.getProperties().isEmpty()) { // has at least one property return schema; } else { // free form object (type: object) return unaliasSchema(openAPI, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()))); } } else { return unaliasSchema(openAPI, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()))); } } return schema; }"	@return actual schema	0	1
private boolean testContentType(final IFile file, String contentTypeId, boolean isKindOfUsed) { final String expectedValue = contentTypeId.trim(); IContentType actualContentType = null; try { IContentDescription contentDescription = file.getContentDescription(); if (contentDescription != null) { actualContentType = contentDescription.getContentType(); } } catch (CoreException e) { Policy.log(IStatus.ERROR, STR, e); } if (actualContentType != null) { if (isKindOfUsed) { return actualContentType.isKindOf(Platform.getContentTypeManager().getContentType(expectedValue)); } return expectedValue.equals(actualContentType.getId()); } return false; }	@return <code>true</code> iff the best matching content type has an identifier that matches <code>contentTypeId</code>; <code>false</code> otherwise.	1	0
"private EntityMetamodel getDeclarerEntityMetamodel(AbstractIdentifiableType<?> ownerType) { final Type.PersistenceType persistenceType = ownerType.getPersistenceType(); if ( persistenceType == Type.PersistenceType.ENTITY ) { return context.getSessionFactory() .getMetamodel() .entityPersister( ownerType.getTypeName() ) .getEntityMetamodel(); } else if ( persistenceType == Type.PersistenceType.MAPPED_SUPERCLASS ) { PersistentClass persistentClass = context.getPersistentClassHostingProperties( (MappedSuperclassTypeImpl<?>) ownerType ); return context.getSessionFactory() .getMetamodel() .entityPersister( persistentClass.getClassName() ) .getEntityMetamodel(); } else { throw new AssertionFailure( ""Cannot get the metamodel for PersistenceType: "" + persistenceType ); } }"	@return The built attribute descriptor	0	1
public JSONObject getExtraJSONObject(String key) throws JSONException { return mExtraData.getJSONObject(key); }	@return The stored value or null if it doesn't exist in specified form.	1	0
public BooleanExpression startsWith(Expression<String> str) { return BooleanOperation.create(Ops.STARTS_WITH, mixin, str); }	@return this.startsWith(str)	0	1
public double getBalance(World world) { if (!Config.multiWorld) return getBalance(CurrencyHandler.getCurrency(Config.currencyDefault, true)); return getBalance(CurrencyHandler.getCurrency(Config.currencyDefault, true), world); }	@return The balance	1	0
public String preprocess(String buildPath) throws RunnerException { return preprocess(buildPath, new PdePreprocessor()); }	@return null if compilation failed, main class name if not	0	1
"public static ExecutorService getMessageDispatcher(final AtmosphereConfig config, final String name) { final boolean shared = config.framework().isShareExecutorServices(); useForkJoinPool = config.getInitParameter(ApplicationConfig.USE_FORJOINPOOL, true); if (!shared || config.properties().get(BROADCASTER_THREAD_POOL) == null) { int numberOfMessageProcessingThread = DEFAULT_MESSAGE_THREAD; String s = config.getInitParameter(ApplicationConfig.BROADCASTER_MESSAGE_PROCESSING_THREADPOOL_MAXSIZE); if (s != null) { numberOfMessageProcessingThread = Integer.parseInt(s); } if (shared && numberOfMessageProcessingThread == 1) { logger.warn(""Not enough numberOfMessageProcessingThread for a shareable thread pool {}, "" + ""Setting it to a newCachedThreadPool"", numberOfMessageProcessingThread); numberOfMessageProcessingThread = -1; } AbstractExecutorService messageService; logger.trace(""Max number of DispatchOp {}"", numberOfMessageProcessingThread == -1 ? ""Unlimited"" : numberOfMessageProcessingThread); if (numberOfMessageProcessingThread == -1) { messageService = !useForkJoinPool ? (ThreadPoolExecutor) Executors.newCachedThreadPool(new AtmosphereThreadFactory(shared, name + ""-DispatchOp-"")) : new org.atmosphere.util.ForkJoinPool(); } else { messageService = (ThreadPoolExecutor) Executors.newFixedThreadPool(numberOfMessageProcessingThread, new AtmosphereThreadFactory(shared, name + ""-DispatchOp-"")); } keepAliveThreads(messageService, config); if (shared) { config.properties().put(BROADCASTER_THREAD_POOL, messageService); } return messageService; } else { return (ExecutorService) config.properties().get(BROADCASTER_THREAD_POOL); } }"	@return ExecutorService	0	1
public Set<Warning> getWarnings() { return Collections.unmodifiableSet(project.getWarnings(packageName)); }	@return all warnings of this package	1	0
private File[] getProjectFiles(File directory) { return directory.listFiles(new FileFilter() { public boolean accept(File file) { return (file.isFile() && file.getName().endsWith(STR)); } }); }	@return project files in that directory, sorted alphabetically.	1	0
public GremlinPipeline<S, Edge> E() { return this.add(new EdgesPipe()); }	@return the extended FluentPipeline	1	0
public PortletContainer createContainer(String containerName, RequiredContainerServices requiredServices) throws PortletContainerException { return createContainer(containerName, requiredServices, new DefaultOptionalContainerServices()); }	@return newly created PortletContainer	1	0
"public Action timedout(AtmosphereRequest request, AtmosphereResponse response) throws IOException, ServletException { AtmosphereResourceImpl r = null; try { SessionTimeoutSupport.restoreTimeout(request); if (trackActiveRequest) { long l = (Long) request.getAttribute(MAX_INACTIVE); if (l == -1) { // The closedDetector closed the connection. return timedoutAction; } request.setAttribute(MAX_INACTIVE, (long) -1); } logger.debug(""Timing out the connection for request {}"", request); // Something went wrong. if (request == null || response == null) { logger.warn(""Invalid Request/Response: {}/{}"", request, response); return timedoutAction; } r = (AtmosphereResourceImpl) request.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE); if (r != null && r.getAtmosphereResourceEvent().isSuspended()) { r.getAtmosphereResourceEvent().setIsResumedOnTimeout(true); Broadcaster b = r.getBroadcaster(); if (b instanceof DefaultBroadcaster) { ((DefaultBroadcaster) b).broadcastOnResume(r); } if (request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT) != null) { r.getAtmosphereResourceEvent().setIsResumedOnTimeout( (Boolean) request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT)); } invokeAtmosphereHandler(r); } } catch (Throwable t) { logger.error(""failed to timeout resource {}"", r, t); } finally { config.framework().notify(Action.TYPE.TIMEOUT, request, response); try { if (r != null) { r.notifyListeners(); r.setIsInScope(false); r.cancel(); } } catch (Throwable t) { logger.trace(""timedout"", t); } finally { try { response.getOutputStream().close(); } catch (Throwable t) { try { response.getWriter().close(); } catch (Throwable t2) { } } if (r != null) { destroyResource(r); } } } return timedoutAction; }"	@return action the Action operation.	0	1
public ByteBuf getContent() { return this.facade.getContent(); }	@return a Buffer holding the bytes contained in this message.	1	0
public Options includeDirectives(boolean flag) { return new Options(this.includeIntrospectionTypes, this.includeScalars, this.includeExtendedScalars, this.includeSchemaDefinition, flag, this.useAstDefinitions, this.comparatorRegistry); }	@return new instance of options	0	1
public ReporterData getSingleData(Xref idc) { List<ReporterData> dlist = data.get(idc); if (dlist != null && dlist.size() > NUM) return dlist.get(NUM); return null; }	@return a {@link Data} instance that contains the cached data	1	0
public Maps getMaps() { setApiKey(METHOD_GET, SEGMENT_MAPS); return fromString(client.get(SEGMENT_MAPS), Maps.class); }	@return A list containing all the maps	1	0
static List<String> parseCategories(String categoryStr) { List<String> outgoing = new ArrayList<String>(); if (categoryStr != null) { String[] listing = PApplet.trim(PApplet.split(categoryStr, ',')); for (String category : listing) { if (validCategories.contains(category)) { category = translateCategory(category); outgoing.add(category); } } } if (outgoing.size() == 0) { return defaultCategory(); } return outgoing; }	"@return the list of categories that this contribution is part of (e.g. ""Typography / Geometry""). ""Unknown"" if the category null."	0	1
public static String jenkinsJobName(String namespace, String buildConfigName) { return namespace + STR + buildConfigName; }	@return the jenkins job name for the given namespace and build config name and default namesapce	1	0
public DateTime roundHalfCeilingCopy() { DateTime instant = iInstant; return (DateTime)instant.withMillis(iField.roundHalfCeiling(instant.getMillis())); }	@return a copy of the DateTime with the field value changed	0	1
"public Pet getPetById(Long petId) throws ApiException { Object localVarPostBody = null; // verify the required parameter 'petId' is set if (petId == null) { throw new ApiException(400, ""Missing the required parameter 'petId' when calling getPetById""); } // create path and map variables String localVarPath = ""/pet/{petId}"" .replaceAll(""\\{"" + ""petId"" + ""\\}"", apiClient.escapeString(petId.toString())); // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { ""application/xml"", ""application/json"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { ""api_key"" }; GenericType<Pet> localVarReturnType = new GenericType<Pet>() {}; return apiClient.invokeAPI(localVarPath, ""GET"", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	@return Pet	0	1
"public Boolean fakeOuterBooleanSerialize(Boolean body) throws ApiException { Object localVarPostBody = body; // create path and map variables String localVarPath = ""/fake/outer/boolean""; // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {}; return apiClient.invokeAPI(localVarPath, ""POST"", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	@return Boolean	0	1
static boolean hasNoNulls(Statistics stat) { return stat.getNumNulls() <= NUM; }	@return True if the parquet file has nulls False if the parquet file hasn't nulls.	1	0
protected String readAnnouncement(File file) throws MojoExecutionException { InputStreamReader reader = null; FileInputStream inputStream = null; try { inputStream = new FileInputStream(file); if (StringUtils.isEmpty(templateEncoding)) { templateEncoding = ReaderFactory.FILE_ENCODING; getLog().warn(STR + templateEncoding + STR); } reader = new InputStreamReader(inputStream, templateEncoding); return IOUtil.toString(reader); } catch (FileNotFoundException fnfe) { throw new MojoExecutionException(STR + file); } catch (UnsupportedEncodingException uee) { throw new MojoExecutionException(STR + templateEncoding + STR); } catch (IOException ioe) { throw new MojoExecutionException(STR, ioe); } finally { IOUtil.close(inputStream); IOUtil.close(reader); } }	@return fileReader Return the FileReader	1	0
public static double logSum(double[] logInputs, int fromIndex, int afterIndex, int stride) { if (logInputs.length == 0) throw new IllegalArgumentException(); if (fromIndex >= 0 && afterIndex < logInputs.length && fromIndex >= afterIndex) return Double.NEGATIVE_INFINITY; int maxIdx = fromIndex; double max = logInputs[fromIndex]; for (int i = fromIndex + stride; i < afterIndex; i += stride) { double d = logInputs[i]; if (d > max) { maxIdx = i; max = d; } } double intermediate = 0.0; double cutoff = max - SloppyMath.LOGTOLERANCE; // we avoid rearranging the array and so test indices each time! for (int i = fromIndex; i < afterIndex; i += stride) { double d = logInputs[i]; if (i != maxIdx && d > cutoff) { intermediate += Math.exp(d - max); } } return intermediate != 0 ? max + Math.log(1.0 + intermediate) : max; }	@return @literal log(x1 + ... + xn)	0	1
public File getSinkFile() { return queue.file(); }	@return the sinkFile	1	0
@Transactional(readOnly = true) @Override public int getCount(final List<BatchInstanceStatus> batchInstStatusList, final List<BatchPriority> batchPriorities, final boolean isCurrUsrNotReq, final String currentUser, final Set<String> userRoles, EphesoftUser ephesoftUser) { return batchInstanceDao.getCount(batchInstStatusList, batchPriorities, isCurrUsrNotReq, userRoles, currentUser, ephesoftUser); }	@return the count satisfying the above requirements	1	0
public JSONRequest toArray(int count, int page, String name) { return new JSONRequest(StringUtil.getString(name) + KEY_ARRAY, this.setCount(count).setPage(page)); }	@return {@link #toArray(int, int, String, boolean)}	1	0
protected Object convertSmallInt(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return SHORT_FALSE; } if (data instanceof Short) return data; if (data instanceof Number) { Number value = (Number) data; return new Short(value.shortValue()); } if (data instanceof Boolean) { return NumberConversions.getShort((Boolean) data); } if (data instanceof String) { return Short.parseShort((String) data); } return handleUnknownData(column, fieldDefn, data); }	@return the converted value, or null if the conversion could not be made and the column allows nulls	0	1
public static QName getXSIType(Parameter param) { if (param.getMIMEType() != null) { return getMIMETypeQName(param.getMIMEType()); } QName xmlType = null; TypeEntry te = param.getType(); if (te != null && te instanceof Element && te.getRefType() != null) { te = te.getRefType(); } if (te != null && te instanceof CollectionType && te.getRefType() != null) { te = te.getRefType(); } if (te != null) { xmlType = te.getQName(); } return xmlType; }	@return the QName of the type	1	0
public static EventProcessingFailureHandlingMode parse(String value) { if (value == null) { return null; } value = value.trim(); for (EventProcessingFailureHandlingMode option : EventProcessingFailureHandlingMode.values()) { if (option.getValue().equalsIgnoreCase(value)) { return option; } } return null; }	@return the matching option, or null if no match is found and the non-null default is invalid	1	0
"public Client build() { if ((environment == null) && (executorService == null) && (objectMapper == null)) { throw new IllegalStateException(""Must have either an environment or both "" + ""an executor service and an object mapper""); } if (environment == null) { return build(executorService, objectMapper); } return build(environment.getLifecycleEnvironment() .managedExecutorService(""jersey-client-%d"", configuration.getMinThreads(), configuration.getMaxThreads(), 60, TimeUnit.SECONDS), environment.getObjectMapperFactory().build()); }"	@return a fully-configured Client	0	1
public Date getCreateDate() { return this.createDate; }	@return java.util.Date	1	0
public NVP<Long, Double> reset(final long newStartMs, final long newCount) { final long[] priorWindow = TIME_WINDOW_UPDATER.getAndSet(this, windowRangeFromMs(newStartMs, windowWidth)); final long priorCount = count; count = newCount; return new NVP<Long, Double>(priorWindow[NUM], calcRate(priorCount, windowWidth)); }	@return the prior count	1	0
public MColorSchema getColorSchema() { return MColorSchema.get(getCtx(), getPA_ColorSchema_ID()); }	@return the color schema, or null if the measure targer is 0	1	0
public Label newLabelFromString(String labelStr) { int first = labelStr.indexOf(divider); int second = labelStr.lastIndexOf(divider); if (first == second) { return new WordLemmaTag(labelStr.substring(0, first), Morphology.lemmaStatic(labelStr.substring(0, first), labelStr.substring(first + 1)), labelStr.substring(first + 1)); } else if (first >= 0) { return new WordLemmaTag(labelStr.substring(0, first), labelStr.substring(first + 1, second), labelStr.substring(second + 1)); } else { return new WordLemmaTag(labelStr); } }	@return The new WordLemmaTag	0	1
public ConcurrentHashMap<String, String> getSubToSuperMap() { return subToSuperMap; }	@return HashMap of {@link ProductType} ids mapped to their parent id	1	0
protected Object convertTimeToMillisPastMidnightAsDate(Column column, Field fieldDefn, Object data) { if ( data == null ) return null; try { return new java.util.Date(Time.toMilliOfDay(data)); } catch (IllegalArgumentException e) { return handleUnknownData(column, fieldDefn, data); } }	@return the converted value, or null if the conversion could not be made	0	1
@ManagedAttribute(description = STR) public boolean getRunning() { return running.get(); }	@return the running	1	0
public MColor getColor() { if (m_vo.AD_Color_ID == NUM) return null; MColor mc = new MColor(m_vo.ctx, m_vo.AD_Color_ID, null); return mc; }	@return AdempiereColor or null	1	0
"public Configuration addCacheableFile(File xmlFile) throws MappingException { File cachedFile = determineCachedDomFile( xmlFile ); try { return addCacheableFileStrictly( xmlFile ); } catch ( SerializationException e ) { log.warn( ""Could not deserialize cache file: "" + cachedFile.getPath() + "" : "" + e ); } catch ( FileNotFoundException e ) { log.warn( ""I/O reported cached file could not be found : "" + cachedFile.getPath() + "" : "" + e ); } final String name = xmlFile.getAbsolutePath(); final InputSource inputSource; try { inputSource = new InputSource( new FileInputStream( xmlFile ) ); } catch ( FileNotFoundException e ) { throw new MappingNotFoundException( ""file"", xmlFile.toString() ); } log.info( ""Reading mappings from file: "" + xmlFile ); XmlDocument metadataXml = add( inputSource, ""file"", name ); try { log.debug( ""Writing cache file for: "" + xmlFile + "" to: "" + cachedFile ); SerializationHelper.serialize( ( Serializable ) metadataXml.getDocumentTree(), new FileOutputStream( cachedFile ) ); } catch ( SerializationException e ) { log.warn( ""Could not write cached file: "" + cachedFile, e ); } catch ( FileNotFoundException e ) { log.warn( ""I/O reported error writing cached file : "" + cachedFile.getPath(), e ); } return this; }"	@return this (for method chaining purposes)	0	1
"public static String normalizeDateString(String s, String ctxdate) { // TODO [pengqi]: need to handle basic localization (""å¨ä¸æäºæ¥å°[å «æ¥]é´"") // TODO [pengqi]: need to handle literal numeral dates (usually used in events, e.g. ""ä¸ä¸äº"" for 03-15) // TODO [pengqi]: might need to add a pattern for centuries (""ä¸ä¸çºª90å¹´ä»£"")? Pattern p; Matcher m; String ctxyear = ""XXXX"", ctxmonth = ""XX"", ctxday = ""XX""; // set up context date if (ctxdate != null) { p = Pattern.compile(""^"" + BASIC_YYYYMMDD_PATTERN + ""$""); m = p.matcher(ctxdate); if (m.find() && m.groupCount() == 3) { ctxyear = m.group(1); ctxmonth = m.group(2); ctxday = m.group(3); } } p = Pattern.compile(""^"" + BIRTH_DECADE_PATTERN + ""$""); m = p.matcher(s); if (m.find() && m.groupCount() == 1) { StringBuilder res = new StringBuilder(); res.append(normalizeYear(m.group(1), ctxyear, true).substring(0, 3) + ""X""); res.append(""-XX-XX""); return res.toString(); } p = Pattern.compile(""^"" + RELATIVE_TIME_PATTERN + ""$""); m = p.matcher(s); if (m.find() && m.groupCount() == 1) { StringBuilder res = new StringBuilder(); res.append(ctxyear); res.append(""-""); res.append(ctxmonth); res.append(""-""); res.append(normalizeMonthOrDay(m.group(1), ctxday)); return res.toString(); } p = Pattern.compile(""^"" + BASIC_YYYYMMDD_PATTERN + ""$""); m = p.matcher(s); if (m.find() && m.groupCount() == 3) { StringBuilder res = new StringBuilder(); res.append(normalizeYear(m.group(1), ctxyear)); res.append(""-""); res.append(normalizeMonthOrDay(m.group(2), ctxmonth)); res.append(""-""); res.append(normalizeMonthOrDay(m.group(3), ctxday)); return res.toString(); } p = Pattern.compile(""^"" + BASIC_MMDD_PATTERN + ""$""); m = p.matcher(s); if (m.find() && m.groupCount() == 2) { StringBuilder res = new StringBuilder(); res.append(ctxyear); res.append(""-""); res.append(normalizeMonthOrDay(m.group(1), ctxmonth)); res.append(""-""); res.append(normalizeMonthOrDay(m.group(2), ctxday)); return res.toString(); } p = Pattern.compile(""^"" + BASIC_DD_PATTERN + ""$""); m = p.matcher(s); if (m.find() && m.groupCount() == 1) { StringBuilder res = new StringBuilder(); res.append(ctxyear); res.append(""-""); res.append(ctxmonth); res.append(""-""); res.append(normalizeMonthOrDay(m.group(1), ctxday)); return res.toString(); } p = Pattern.compile(""^"" + ENGLISH_MMDDYYYY_PATTERN + ""$""); m = p.matcher(s); if (m.find() && m.groupCount() == 3) { StringBuilder res = new StringBuilder(); if (m.group(3) == null) res.append(ctxyear); else res.append(normalizeYear(m.group(3), ctxyear)); res.append(""-""); res.append(normalizeMonthOrDay(m.group(1), ctxmonth)); res.append(""-""); res.append(normalizeMonthOrDay(m.group(2), ctxday)); return res.toString(); } return s; }"	@return Normalized Timex expression of the input date string	0	1
private int measureHeight(int measureSpec) { float result = 0; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); if (specMode == MeasureSpec.EXACTLY) { //We were told how big to be result = specSize; } else { //Calculate the text bounds Rect bounds = new Rect(); bounds.bottom = (int) (mPaintText.descent()-mPaintText.ascent()); result = bounds.bottom - bounds.top + mFooterLineHeight; if (mFooterIndicatorStyle != IndicatorStyle.None) { result += mFooterIndicatorHeight + mFooterIndicatorPadding; } } return (int)result; }	@return The height of the view, honoring constraints from measureSpec	0	1
public int removeActiveMessage() { return removeMessage(currentPage); }	@return true if a message was removed, false otherwise.	1	0
public Actions moveByOffset(int xOffset, int yOffset) { if (isBuildingActions()) { action.addAction(new MoveToOffsetAction(jsonMouse, null, xOffset, yOffset)); } return tick( defaultMouse.createPointerMove(Duration.ofMillis(200), Origin.pointer(), xOffset, yOffset)); }	@return A self reference.	0	1
protected PingResult parse(int exitValue, List<String> outLines, List<String> errLines) { PingResult info = new PingResult(); Pattern roundTripTimePat = Pattern.compile(RTT_REG_EX); Pattern transmitReceivePat = Pattern.compile(TRANSMITTED_RECEIVED_REG_EX); Pattern noRouteToHostPat = Pattern.compile(NO_ROUTE_TO_HOST_REG_EX); Pattern unknownHostPat = Pattern.compile(UNKNOWN_HOST_REG_EX); info.setHost(getHost()); switch(exitValue) { case NUM: for (String line : outLines) { Matcher matcher = roundTripTimePat.matcher(line); if (matcher.find()) { info.setRTTMin(Double.parseDouble(matcher.group(NUM))); info.setRTTAvg(Double.parseDouble(matcher.group(NUM))); info.setRTTMax(Double.parseDouble(matcher.group(NUM))); info.setRTTMDev(Double.parseDouble(matcher.group(NUM))); } } for (String line : outLines) { Matcher matcher = transmitReceivePat.matcher(line); if (matcher.find()) { info.setTransmitted(Integer.parseInt(matcher.group(NUM))); info.setReceived(Integer.parseInt(matcher.group(NUM))); } } if (info.getReceived() == NUM) { info.setStatus(ServiceStatus.FAIL); } else { info.setStatus(ServiceStatus.SUCCESS); } break; case NUM: case NUM: case NUM: for (String line : outLines) { Matcher matcher = transmitReceivePat.matcher(line); if (matcher.find()) { info.setTransmitted(Integer.parseInt(matcher.group(NUM))); info.setReceived(Integer.parseInt(matcher.group(NUM))); } } for (String line : errLines) { Matcher matcher = unknownHostPat.matcher(line); if (matcher.find()) { info.setMessage(matcher.group(NUM)); } } info.setStatus(ServiceStatus.FAIL); break; default: assert false : STR; } return info; }	@return {@link PingInfo}	1	0
public Response syncSendPacket(Command command) throws JMSException { return syncSendPacket(command, 0); }	@return the broker Response for the given Command.	0	1
"public static Binding parse(String serialized) throws IllegalArgumentException { try { if (serialized.isEmpty()) { return new Binding(); } String[] parts = serialized.split("":""); switch (parts.length) { case 2: { return new Binding(parts[0], Integer.valueOf(parts[1])); } case 1: { return parts[0].contains(""."") ? new Binding(parts[0]) : new Binding(Integer.valueOf(parts[0])); } default: { throw new IllegalArgumentException(); } } } catch (Exception e) { throw new IllegalArgumentException(""Error parsing Binding '"" + serialized + ""'""); } }"	@return a Binding matching the specification	0	1
public long getConnectAttemptTimeout() { return wireFormat.getConnectAttemptTimeout(); }	@return the timeout value used to fail a connection if no CONNECT frame read.	0	1
public int getDrawQueue() { return drawQueueType; }	@return the current DrawQueue object for this Scene	1	0
public SortedMap<String, String> getOriginTabContentsAsStrings(final Origin selectedColumn) { openTab(Tab.ORIGIN); return mapTableCellsKeyValue(String.class, getVisibleTableRows(true, false), selectedColumn.column); }	@return a map of the first two columns. (first column => second column)	1	0
public int hashCode() { // must be to fulfil ReadableInstant contract return ((int) (getMillis() ^ (getMillis() >>> 32))) + (getChronology().hashCode()); }	@return a suitable hash code	0	1
"public ArrayList<TextView> clickInList(int line, int index) { line--; if(line < 0) line = 0; boolean foundList = waiter.waitForView(ListView.class, index); if (!foundList) Assert.assertTrue(""No ListView with index "" + index + "" is available!"", false); ArrayList<View> views = new ArrayList<View>(); final ListView listView = viewFetcher.getView(ListView.class, null, index); if(listView == null) Assert.assertTrue(""ListView is null!"", false); View view = listView.getChildAt(line); if(view != null){ views = viewFetcher.getViews(view, true); views = RobotiumUtils.removeInvisibleViews(views); clickOnScreen(getClickableView(views)); } return RobotiumUtils.filterViews(TextView.class, views); }"	@return an ArrayList of the TextViews located in the list line	0	1
"private Bitmap getWidgetPreview(AppWidgetProviderInfo info) { final PackageManager packageManager = mPackageManager; String packageName = info.provider.getPackageName(); Drawable drawable = null; if (info.previewImage != 0) { drawable = packageManager.getDrawable(packageName, info.previewImage, null); if (drawable == null) { Log.w(TAG, ""Can't load icon drawable 0x"" + Integer.toHexString(info.icon) + "" for provider: "" + info.provider); } } // If we don't have a preview image, create a default one if (drawable == null) { Resources resources = mLauncher.getResources(); // Create a new bitmap to hold the widget preview int width = (int) (Math.max(mMinWidgetPreviewDim, Math.min(mMaxWidgetPreviewDim, info.minWidth)) * sScaleFactor); int height = (int) (Math.max(mMinWidgetPreviewDim, Math.min(mMaxWidgetPreviewDim, info.minHeight)) * sScaleFactor); final Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888); final Drawable background = resources.getDrawable(R.drawable.default_widget_preview); renderDrawableToBitmap(background, bitmap, 0, 0, width, height, 1.0f, 1.0f); // Draw the icon flush left try { Drawable icon = null; if (info.icon > 0) { icon = packageManager.getDrawable(packageName, info.icon, null); } if (icon == null) { icon = resources.getDrawable(R.drawable.ic_launcher_application); } final int iconSize = mMinWidgetPreviewDim / 2; final int offset = iconSize / 4; renderDrawableToBitmap(icon, null, offset, offset, iconSize, iconSize, 1.0f, 1.0f); } catch (Resources.NotFoundException e) { // if we can't find the icon, then just don't draw it } return bitmap; } else { // Scale down the preview if necessary final float imageWidth = drawable.getIntrinsicWidth(); final float imageHeight = drawable.getIntrinsicHeight(); final float aspect = (float) imageWidth / imageHeight; final int scaledWidth = (int) (Math.max(mMinWidgetPreviewDim, Math.min(mMaxWidgetPreviewDim, imageWidth)) * sScaleFactor); final int scaledHeight = (int) (Math.max(mMinWidgetPreviewDim, Math.min(mMaxWidgetPreviewDim, imageHeight)) * sScaleFactor); int width; int height; if (aspect >= 1.0f) { width = scaledWidth; height = (int) (((float) scaledWidth / imageWidth) * imageHeight); } else { height = scaledHeight; width = (int) (((float) scaledHeight / imageHeight) * imageWidth); } final Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888); renderDrawableToBitmap(drawable, bitmap, 0, 0, width, height, 1.0f, 1.0f); return bitmap; } }"	@return the drawable that will be used and sized in the ImageView to represent the widget	1	0
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; // set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { String str = yytext(); int first = str.charAt(0); String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } LOGGER.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: LOGGER.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 55: break; case 2: { return getNext(""<"", yytext()); } case 56: break; case 3: { return getNext(); } case 57: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 58: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 59: break; case 6: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 60: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 61: break; case 8: { return handleQuotes(yytext(), false); } case 62: break; case 9: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 63: break; case 10: { return getNext("">"", yytext()); } case 64: break; case 11: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 65: break; case 12: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 66: break; case 13: { return handleEllipsis(yytext()); } case 67: break; case 14: { return normalizeFractions(yytext()); } case 68: break; case 15: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(); } } case 69: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 70: break; case 17: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 71: break; case 18: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 72: break; case 19: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 73: break; case 20: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 74: break; case 21: { if (normalizeOtherBrackets) { return getNext(""-RSB-"", yytext()); } else { return getNext(); } } case 75: break; case 22: { if (normalizeOtherBrackets) { return getNext(""-LSB-"", yytext()); } else { return getNext(); } } case 76: break; case 23: { if (invertible) { prevWordAfter.append(yytext()); } } case 77: break; case 24: // general lookahead, find correct zzMarkedPos { int zzFState = 13; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 78: break; case 25: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(); } case 79: break; case 26: // lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), true); } case 80: break; case 27: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, origTxt); } case 81: break; case 28: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 82: break; case 29: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 83: break; case 30: // general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 84: break; case 31: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 85: break; case 32: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 86: break; case 33: { // this one should only match if we're basically at the end of file // since the last one matches two things, even newlines String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 87: break; case 34: // lookahead expression with fixed lookahead length yypushback(1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 88: break; case 35: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 1; { /* invert quote - often but not always right */ return handleQuotes(yytext(), true); } case 89: break; case 36: // lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), false); } case 90: break; case 37: { return getNormalizedAmpNext(); } case 91: break; case 38: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, yytext()); } case 92: break; case 39: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, yytext()); } case 93: break; case 40: // general lookahead, find correct zzMarkedPos { int zzFState = 16; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 17; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 94: break; case 41: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 95: break; case 42: { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 96: break; case 43: // general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 97: break; case 44: // general lookahead, find correct zzMarkedPos { int zzFState = 9; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 10; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { // try to work around an apparent jflex bug where it // gets a space at the token end by getting // wrong the length of the trailing context. while (yylength() > 0) { char last = yycharat(yylength()-1); if (last == ' ' || last == '\t' || (last >= '\n' && last <= '\r' || last == '\u0085')) { yypushback(1); } else { break; } } return getNext(); } case 98: break; case 45: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 99: break; case 46: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 100: break; case 47: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { // try to work around an apparent jflex bug where it // gets a space at the token end by getting // wrong the length of the trailing context. while (yylength() > 0) { char last = yycharat(yylength()-1); if (last == ' ' || last == '\t' || (last >= '\n' && last <= '\r' || last == '\u0085')) { yypushback(1); } else { break; } } String s; if (yylength() == 2) { // ""I."", etc. yypushback(1); // return a period next time; s = yytext(); // return the word without the final period } else if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); // return the word without the final period } else { s = yytext(); // return the word WITH the final period yypushback(1); // (redpulication:) also return a period for next time } return getNext(s, yytext()); } case 101: break; case 48: // lookahead expression with fixed lookahead length yypushback(2); { return getNext(); } case 102: break; case 49: // general lookahead, find correct zzMarkedPos { int zzFState = 11; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 12; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 103: break; case 50: { if (splitAssimilations) { yypushback(3) ; return getNext(); } else { return getNext(); } } case 104: break; case 51: // lookahead expression with fixed lookahead length yypushback(1); { return getNormalizedAmpNext(); } case 105: break; case 52: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } return getNext(txt, yytext()); } case 106: break; case 53: // lookahead expression with fixed lookahead length yypushback(4); { return getNext(); } case 107: break; case 54: { String txt = yytext(); if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 108: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }"	@return the next token	0	1
@Deprecated public Command getCommand() { Command rtnVal; if (command == null) { rtnVal = null; } else if (command instanceof Command) { rtnVal = (Command) command; } else { rtnVal = new Command() { @Override public void execute() { if (command != null) { command.execute(); } } }; } return rtnVal; }	@return this item's command, or <code>null</code> if none exists	1	0
public static boolean reinstateAutoIncrement(String colName, String tableId, StringBuffer colDef) throws SQLException { getAutoIncStmt.setString(NUM, dblook.stripQuotes(colName)); getAutoIncStmt.setString(NUM, tableId); ResultSet autoIncCols = getAutoIncStmt.executeQuery(); if (autoIncCols.next()) { long start = autoIncCols.getLong(NUM); if (!autoIncCols.wasNull()) { colDef.append(STR); colDef.append(autoIncCols.getObject(NUM) == null ? STR : STR); colDef.append(STR); colDef.append(autoIncCols.getLong(NUM)); colDef.append(STR); colDef.append(autoIncCols.getLong(NUM)); colDef.append(STR); return true; } } return false; }	@return The DDL for all autoincrement columns has been written to the received string buffer. **	1	0
static public IStructuredTextExpert getStatefulExpert(String type) { return getStatefulExpert(type, StructuredTextEnvironment.DEFAULT); }	@return the ISTextExpert instance.	1	0
public User getOwner() { return owner; }	@return Valid {@link Person}	1	0
@ApiModelProperty(required = true, value = STR) public String getIn() { return in; }	@return InEnum in	1	0
"private IterOutcome produceOutputBatch() { boolean isLeftProcessed = false; // Try to fully pack the outgoing container while (!isOutgoingBatchFull()) { final int previousOutputCount = outputIndex; // invoke the runtime generated method to emit records in the output batch for each leftJoinIndex crossJoinAndOutputRecords(); // We have produced some records in outgoing container, hence there must be a match found for left record if (outputIndex > previousOutputCount) { // Need this extra flag since there can be left join case where for current leftJoinIndex it receives a right // batch with data, then an empty batch and again another empty batch with EMIT outcome. If we just use // outputIndex then we will loose the information that few rows for leftJoinIndex is already produced using // first right batch matchedRecordFound = true; } // One right batch might span across multiple output batch. So rightIndex will be moving sum of all the // output records for this record batch until it's fully consumed. // // Also it can be so that one output batch can contain records from 2 different right batch hence the // rightJoinIndex should move by number of records in output batch for current right batch only. rightJoinIndex += outputIndex - previousOutputCount; final boolean isRightProcessed = rightJoinIndex == -1 || rightJoinIndex >= right.getRecordCount(); // Check if above join to produce output was based on empty right batch or // it resulted in right side batch to be fully consumed. In this scenario only if rightUpstream // is EMIT then increase the leftJoinIndex. // Otherwise it means for the given right batch there is still some record left to be processed. if (isRightProcessed) { if (rightUpstream == EMIT) { if (!matchedRecordFound && JoinRelType.LEFT == popConfig.getJoinType()) { // copy left side in case of LEFT join emitLeft(leftJoinIndex, outputIndex, 1); ++outputIndex; } ++leftJoinIndex; // Reset matchedRecord for next left index record matchedRecordFound = false; } // Release vectors of right batch. This will happen for both rightUpstream = EMIT/OK VectorAccessibleUtilities.clear(right); rightJoinIndex = -1; } // Check if previous left record was last one, then set leftJoinIndex to -1 isLeftProcessed = leftJoinIndex >= left.getRecordCount(); if (isLeftProcessed) { leftJoinIndex = -1; VectorAccessibleUtilities.clear(left); } // Check if output batch still has some space if (!isOutgoingBatchFull()) { // Check if left side still has records or not if (isLeftProcessed) { // The current left batch was with EMIT/OK_NEW_SCHEMA outcome, then return output to downstream layer before // getting next batch if (leftUpstream == EMIT || leftUpstream == OK_NEW_SCHEMA) { break; } else { logger.debug(""Output batch still has some space left, getting new batches from left and right""); // Get both left batch and the right batch and make sure indexes are properly set leftUpstream = processLeftBatch(); // output batch is not empty and we have new left batch with OK_NEW_SCHEMA or terminal outcome if (processLeftBatchInFuture) { logger.debug(""Received left batch with outcome {} such that we have to return the current outgoing "" + ""batch and process the new batch in subsequent next call"", leftUpstream); // We should return the current output batch with OK outcome and don't reset the leftUpstream finalizeOutputContainer(); return OK; } // If left batch received a terminal outcome then don't call right batch if (isTerminalOutcome(leftUpstream)) { finalizeOutputContainer(); return leftUpstream; } // If we have received the left batch with EMIT outcome and is empty then we should return previous output // batch with EMIT outcome if ((leftUpstream == EMIT || leftUpstream == OK_NEW_SCHEMA) && left.getRecordCount() == 0) { isLeftProcessed = true; break; } // Update the batch memory manager to use new left incoming batch updateMemoryManager(LEFT_INDEX); } } // If we are here it means one of the below: // 1) Either previous left batch was not fully processed and it came with OK outcome. There is still some space // left in outgoing batch so let's get next right batch. // 2) OR previous left & right batch was fully processed and it came with OK outcome. There is space in outgoing // batch. Now we have got new left batch with OK outcome. Let's get next right batch // 3) OR previous left & right batch was fully processed and left came with OK outcome. Outgoing batch is // empty since all right batches were empty for all left rows. Now we got another non-empty left batch with // OK_NEW_SCHEMA. rightUpstream = processRightBatch(); if (rightUpstream == OK_NEW_SCHEMA) { leftUpstream = (leftUpstream != EMIT) ? OK : leftUpstream; rightUpstream = OK; finalizeOutputContainer(); return OK_NEW_SCHEMA; } if (isTerminalOutcome(rightUpstream)) { finalizeOutputContainer(); return rightUpstream; } // Update the batch memory manager to use new right incoming batch updateMemoryManager(RIGHT_INDEX); // If OK_NEW_SCHEMA is seen only on non empty left batch but not on right batch, then we should setup schema in // output container based on new left schema and old right schema. If schema change failed then return STOP // downstream if (leftUpstream == OK_NEW_SCHEMA && isLeftProcessed) { if (!handleSchemaChange()) { return STOP; } // Since schema has change so we have new empty vectors in output container hence allocateMemory for them allocateVectors(); } } } // output batch is full to its max capacity finalizeOutputContainer(); // Check if output batch was full and left was fully consumed or not. Since if left is not consumed entirely // but output batch is full, then if the left batch came with EMIT outcome we should send this output batch along // with OK outcome not with EMIT. Whereas if output is full and left is also fully consumed then we should send // EMIT outcome. if (leftUpstream == EMIT && isLeftProcessed) { logger.debug(""Sending current output batch with EMIT outcome since left is received with EMIT and is fully "" + ""consumed in output batch""); return EMIT; } if (leftUpstream == OK_NEW_SCHEMA) { // return output batch with OK_NEW_SCHEMA and reset the state to OK logger.debug(""Sending current output batch with OK_NEW_SCHEMA and resetting the left outcome to OK for next set"" + "" of batches""); leftUpstream = OK; return OK_NEW_SCHEMA; } return OK; }"	@return - IterOutcome to be send along with output batch to downstream operator	0	1
public static AbstractSchema getTemporaryWorkspace(SchemaPlus defaultSchema, DrillConfig config) { String temporarySchema = config.getString(ExecConstants.DEFAULT_TEMPORARY_WORKSPACE); List<String> temporarySchemaPath = Lists.newArrayList(temporarySchema); SchemaPlus schema = findSchema(defaultSchema, temporarySchemaPath); return schema == null ? null : unwrapAsDrillSchemaInstance(schema); }	@return default temporary workspace	1	0
"public void uploadFile (Long petId, String additionalMetadata, File file) throws TimeoutException, ExecutionException, InterruptedException, ApiException { Object postBody = null; // verify the required parameter 'petId' is set if (petId == null) { VolleyError error = new VolleyError(""Missing the required parameter 'petId' when calling uploadFile"", new ApiException(400, ""Missing the required parameter 'petId' when calling uploadFile"")); } // create path and map variables String path = ""/pet/{petId}/uploadImage"".replaceAll(""\\{format\\}"",""json"").replaceAll(""\\{"" + ""petId"" + ""\\}"", apiInvoker.escapeString(petId.toString())); // query params List<Pair> queryParams = new ArrayList<Pair>(); // header params Map<String, String> headerParams = new HashMap<String, String>(); // form params Map<String, String> formParams = new HashMap<String, String>(); String[] contentTypes = { ""multipart/form-data"" }; String contentType = contentTypes.length > 0 ? contentTypes[0] : ""application/json""; if (contentType.startsWith(""multipart/form-data"")) { // file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); if (additionalMetadata != null) { localVarBuilder.addTextBody(""additionalMetadata"", ApiInvoker.parameterToString(additionalMetadata), ApiInvoker.TEXT_PLAIN_UTF8); } if (file != null) { localVarBuilder.addBinaryBody(""file"", file); } HttpEntity httpEntity = localVarBuilder.build(); postBody = httpEntity; } else { // normal form params formParams.put(""additionalMetadata"", ApiInvoker.parameterToString(additionalMetadata)); } String[] authNames = new String[] { ""petstore_auth"" }; try { String localVarResponse = apiInvoker.invokeAPI (basePath, path, ""POST"", queryParams, postBody, headerParams, formParams, contentType, authNames); if (localVarResponse != null) { return ; } else { return ; } } catch (ApiException ex) { throw ex; } catch (InterruptedException ex) { throw ex; } catch (ExecutionException ex) { if (ex.getCause() instanceof VolleyError) { VolleyError volleyError = (VolleyError)ex.getCause(); if (volleyError.networkResponse != null) { throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage()); } } throw ex; } catch (TimeoutException ex) { throw ex; } }"	@return ApiResponse	1	0
public BufferedImage getImage() { if (!isReady()) { return null; } long t1 = 0; long t2 = 0; if (asynchronous) { return updater.getImage(); } else { // get image t1 = System.currentTimeMillis(); BufferedImage image = new WebcamReadImageTask(driver, device).getImage(); t2 = System.currentTimeMillis(); if (image == null) { return null; } // calculate FPS // +1 to avoid division by zero fps = (4 * fps + 1000 / (t2 - t1 + 1)) / 5; // notify webcam listeners about new image available updater.notifyWebcamImageObtained(this, image); return image; } }	@return Captured image or null if webcam is closed or disposed by JVM	0	1
protected static Serializable deserializeTimestamp(ByteArrayInputStream inputStream) throws IOException { long epochSecond = inputStream.readLong(4); int nanoSeconds = 0; // no fractional seconds return ZonedDateTime.ofInstant(Instant.ofEpochSecond(epochSecond, nanoSeconds), ZoneId.systemDefault()); }	@return the OffsetDateTime object	0	1
long getFieldValue(ReadablePeriod period) { PeriodType type; if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) { type = null; // Don't need to check if supported. } else { type = period.getPeriodType(); } int value; switch (iFieldType) { default: return Long.MAX_VALUE; case 1: if (type != null && type.years().isSupported() == false) { return Long.MAX_VALUE; } value = period.getYears(); break; case 2: if (type != null && type.months().isSupported() == false) { return Long.MAX_VALUE; } value = period.getMonths(); break; case 3: if (type != null && type.weeks().isSupported() == false) { return Long.MAX_VALUE; } value = period.getWeeks(); break; case 4: if (type != null && type.days().isSupported() == false) { return Long.MAX_VALUE; } value = period.getDays(); break; case 5: if (type != null && type.hours().isSupported() == false) { return Long.MAX_VALUE; } value = period.getHours(); break; case 6: if (type != null && type.minutes().isSupported() == false) { return Long.MAX_VALUE; } value = period.getMinutes(); break; case 7: if (type != null && type.seconds().isSupported() == false) { return Long.MAX_VALUE; } value = period.getSeconds(); break; case 8: if (type != null && type.millis().isSupported() == false) { return Long.MAX_VALUE; } value = period.getMillis(); break; case 9: // drop through case 10: if (type != null && type.seconds().isSupported() == false && type.millis().isSupported() == false) { return Long.MAX_VALUE; } value = period.getSeconds() * DateTimeConstants.MILLIS_PER_SECOND + period.getMillis(); break; } if (value == 0 && iPrintZeroSetting == PRINT_ZERO_RARELY) { return Long.MAX_VALUE; } return value; }	@return negative value if nothing to print, otherwise lower 32 bits is signed int value.	1	0
public boolean isNull(RexNode expr) { switch (expr.getKind()) { case LITERAL: return ((RexLiteral) expr).getValue2() == null; case LOCAL_REF: RexLocalRef inputRef = (RexLocalRef) expr; return isNull(exprs.get(inputRef.index)); case CAST: return isNull(((RexCall) expr).operands.get(0)); default: return false; } }	@return Whether expression always evaluates to null	0	1
"private int externalToInternalRow(int extRow) { if (extRow < -mActiveTranscriptRows || extRow > mScreenRows) { String errorMessage = ""externalToInternalRow ""+ extRow + "" "" + mScreenRows + "" "" + mActiveTranscriptRows; Log.e(TAG, errorMessage); throw new IllegalArgumentException(errorMessage); } if (extRow >= 0) { return (mScreenFirstRow + extRow) % mTotalRows; } else { if (-extRow > mScreenFirstRow) { return mTotalRows + mScreenFirstRow + extRow; } else { return mScreenFirstRow + extRow; } } }"	@return The row corresponding to the input argument in the private coordinate system.	0	1
public static Type<?> valueOf(String name) { return ModTheMod.getGame().getTypeManager().getType(name); }	@return The {@link Type}.	1	0
public List<Pet> findPetsByTags(List<String> tags) throws ApiException { ApiResponse<List<Pet>> resp = findPetsByTagsWithHttpInfo(tags); return resp.getData(); }	@return List	0	1
protected CoreLabel fromProto(CoreNLPProtos.Token proto) { CoreLabel word = new CoreLabel(); // Required fields word.setWord(proto.getWord()); // Optional fields if (proto.hasPos()) { word.setTag(proto.getPos()); } if (proto.hasValue()) { word.setValue(proto.getValue()); } if (proto.hasCategory()) { word.setCategory(proto.getCategory()); } if (proto.hasBefore()) { word.setBefore(proto.getBefore()); } if (proto.hasAfter()) { word.setAfter(proto.getAfter()); } if (proto.hasOriginalText()) { word.setOriginalText(proto.getOriginalText()); } if (proto.hasNer()) { word.setNER(proto.getNer()); } if (proto.hasLemma()) { word.setLemma(proto.getLemma()); } if (proto.hasBeginChar()) { word.setBeginPosition(proto.getBeginChar()); } if (proto.hasEndChar()) { word.setEndPosition(proto.getEndChar()); } if (proto.hasSpeaker()) { word.set(SpeakerAnnotation.class, proto.getSpeaker()); } if (proto.hasUtterance()) { word.set(UtteranceAnnotation.class, proto.getUtterance()); } if (proto.hasBeginIndex()) { word.set(BeginIndexAnnotation.class, proto.getBeginIndex()); } if (proto.hasEndIndex()) { word.set(EndIndexAnnotation.class, proto.getEndIndex()); } if (proto.hasTokenBeginIndex()) { word.set(TokenBeginAnnotation.class, proto.getTokenBeginIndex()); } if (proto.hasTokenEndIndex()) { word.set(TokenEndAnnotation.class, proto.getTokenEndIndex()); } if (proto.hasNormalizedNER()) { word.set(NormalizedNamedEntityTagAnnotation.class, proto.getNormalizedNER()); } if (proto.hasTimexValue()) { word.set(TimexAnnotation.class, fromProto(proto.getTimexValue())); } if (proto.hasHasXmlContext() && proto.getHasXmlContext()) { word.set(XmlContextAnnotation.class, proto.getXmlContextList()); } if (proto.hasCorefClusterID()) { word.set(CorefClusterIdAnnotation.class, proto.getCorefClusterID()); } if (proto.hasAnswer()) { word.set(AnswerAnnotation.class, proto.getAnswer()); } // Non-default annotators if (proto.hasGender()) { word.set(GenderAnnotation.class, proto.getGender()); } if (proto.hasTrueCase()) { word.set(TrueCaseAnnotation.class, proto.getTrueCase()); } if (proto.hasTrueCaseText()) { word.set(TrueCaseTextAnnotation.class, proto.getTrueCaseText()); } // Return return word; }	@return A CoreMap, representing a sentence as stored in the protocol buffer (and therefore missing some fields)	1	0
"public String getTypeDeclaration(Schema p) { if (ModelUtils.isArraySchema(p)) { ArraySchema ap = (ArraySchema) p; Schema inner = ap.getItems(); return ""["" + getTypeDeclaration(inner) + ""]""; } else if (ModelUtils.isMapSchema(p)) { Schema inner = (Schema) p.getAdditionalProperties(); return ""%{optional(String.t) => "" + getTypeDeclaration(inner) + ""}""; } else if (ModelUtils.isPasswordSchema(p)) { return ""String.t""; } else if (ModelUtils.isEmailSchema(p)) { return ""String.t""; } else if (ModelUtils.isByteArraySchema(p)) { return ""binary()""; } else if (ModelUtils.isUUIDSchema(p)) { return ""String.t""; } else if (ModelUtils.isDateSchema(p)) { return ""Date.t""; } else if (ModelUtils.isDateTimeSchema(p)) { return ""DateTime.t""; } else if (ModelUtils.isObjectSchema(p)) { // How to map it? return super.getTypeDeclaration(p); } else if (ModelUtils.isIntegerSchema(p)) { return ""integer()""; } else if (ModelUtils.isNumberSchema(p)) { return ""float()""; } else if (ModelUtils.isBinarySchema(p)) { return ""binary()""; } else if (ModelUtils.isBooleanSchema(p)) { return ""boolean()""; } else if (!StringUtils.isEmpty(p.get$ref())) { // model // How to map it? return super.getTypeDeclaration(p); } else if (ModelUtils.isFileSchema(p)) { return ""String.t""; } else if (ModelUtils.isStringSchema(p)) { return ""String.t""; } return super.getTypeDeclaration(p); }"	@return a string value used as the `dataType` field for model templates, `returnType` for api templates	0	1
"public GraphQLInputType buildDirectiveInputType(Value value) { if (value instanceof NullValue) { return Scalars.GraphQLString; } if (value instanceof FloatValue) { return Scalars.GraphQLFloat; } if (value instanceof StringValue) { return Scalars.GraphQLString; } if (value instanceof IntValue) { return Scalars.GraphQLInt; } if (value instanceof BooleanValue) { return Scalars.GraphQLBoolean; } return assertShouldNeverHappen(""Directive values of type '%s' are not supported yet"", value.getClass().getName()); }"	@return a graphql input type	0	1
protected Point getPositionInScreen(View view) { if (getParent() == null) { return new Point(); } ViewGroup parent; try { parent = (ViewGroup) view.getParent(); } catch (Exception e) { return new Point(); } if (parent == null) { return new Point(); } Point point = getPositionInScreen(parent); point.offset((int) view.getX(), (int) view.getY()); return point; }	@return PointF determining position of the passed in view inside all of its ViewParents.	1	0
public static EntityMode parse(String entityMode) { if ( entityMode == null ) { return POJO; } if ( MAP.externalName.equalsIgnoreCase( entityMode ) ) { return MAP; } return valueOf( entityMode.toUpperCase( Locale.ENGLISH ) ); }	@return The appropriate entity mode; null for incoming entityMode param is treated by returning #POJO.	0	1
public static <T extends CharSequence> T notEmpty(final T chars, final String message, final Object... values) { if (chars == null) { throw new NullPointerException(String.format(message, values)); } if (chars.length() == NUM) { throw new IllegalArgumentException(String.format(message, values)); } return chars; }	@return the validated collection (never {@code null} method for chaining)	1	0
private CollectionPersister getPersister(SharedSessionContractImplementor session) { return getPersister( session.getFactory() ); }	@return The underlying collection persister	0	1
public int toOrdinal() { return this.opCode; }	@return a byte representing this operation.	1	0
private boolean isBackupCompatible(Journal oldState) { DeviceProfieData currentProfile = mDeviceProfileData; DeviceProfieData oldProfile = oldState.profile; if (oldProfile == null || oldProfile.desktopCols == 0) { // Profile info is not valid, ignore the check. return true; } boolean isHotseatCompatible = false; if (currentProfile.allappsRank >= oldProfile.hotseatCount) { isHotseatCompatible = true; mHotseatShift = 0; } if ((currentProfile.allappsRank >= oldProfile.allappsRank) && ((currentProfile.hotseatCount - currentProfile.allappsRank) >= (oldProfile.hotseatCount - oldProfile.allappsRank))) { // There is enough space on both sides of the hotseat. isHotseatCompatible = true; mHotseatShift = currentProfile.allappsRank - oldProfile.allappsRank; } if (!isHotseatCompatible) { return false; } if ((currentProfile.desktopCols >= oldProfile.desktopCols) && (currentProfile.desktopRows >= oldProfile.desktopRows)) { return true; } if ((oldProfile.desktopCols - currentProfile.desktopCols <= 1) && (oldProfile.desktopRows - currentProfile.desktopRows <= 1)) { // Allow desktop migration when row and/or column count contracts by 1. migrationCompatibleProfileData = initDeviceProfileData(mIdp); migrationCompatibleProfileData.desktopCols = oldProfile.desktopCols; migrationCompatibleProfileData.desktopRows = oldProfile.desktopRows; return true; } return false; }	@return true if the backup corresponding to oldstate can be successfully applied to this device.	0	1
protected Writer openTestLog() throws Exception { File testClassDir = new File( getTestlogRoot(), ReflectUtil.getUnqualifiedClassName(getClass())); testClassDir.mkdirs(); File testLogFile = new File( testClassDir, testCaseName); return new OutputStreamWriter( openTestLogOutputStream(testLogFile), StandardCharsets.UTF_8); }	@return Writer for log file, which caller should use as a destination for test output to be diffed	0	1
public static float convertDpToPixel(float dp, Context context) { float scale = context.getResources().getDisplayMetrics().density; return dp * scale + 0.5f; }	@return A float value to represent px equivalent to dp depending on device density	0	1
"public List<Pet> findPetsByStatus (List<String> status) throws ApiException { Object localVarPostBody = null; // create path and map variables String localVarPath = ""/pet/findByStatus"".replaceAll(""\\{format\\}"",""json""); // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); // header params Map<String, String> localVarHeaderParams = new HashMap<String, String>(); // form params Map<String, String> localVarFormParams = new HashMap<String, String>(); localVarQueryParams.addAll(ApiInvoker.parameterToPairs(""multi"", ""status"", status)); String[] localVarContentTypes = { }; String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : ""application/json""; if (localVarContentType.startsWith(""multipart/form-data"")) { // file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); localVarPostBody = localVarBuilder.build(); } else { // normal form params } try { String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, ""GET"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType); if(localVarResponse != null){ return (List<Pet>) ApiInvoker.deserialize(localVarResponse, ""array"", Pet.class); } else { return null; } } catch (ApiException ex) { throw ex; } }"	@return List	0	1
public static GitlabRepositoryName create(final String url) { LOGGER.log(Level.FINE, STR, url); for (Pattern p : URL_PATTERNS) { Matcher m = p.matcher(url.trim()); if (m.matches()) { LOGGER.log(Level.FINE, STR, m); GitlabRepositoryName ret = new GitlabRepositoryName(m.group(NUM), m.group(NUM), m.group(NUM)); LOGGER.log(Level.FINE, STR, ret); return ret; } } LOGGER.log(Level.WARNING, STR, url); return null; }	@return parsed {@link GitHubRepositoryName} or null if it cannot be parsed from the specified URL	1	0
public List<SqlValidatorNamespace> getChildren() { return Lists.transform(children, ScopeChild.NAMESPACE_FN); }	@return list of child namespaces	0	1
public Vector<QueueItem> getQueue() { return queue; }	@return Returns the queue.	0	1
public static KeyNamePair[] getKeyNamePairs(String sql, boolean optional) { return getKeyNamePairs(sql, optional, (Object[]) null); }	@return array of key name pairs	1	0
"private boolean scrollScrollView(final ScrollView view, int direction){ if(view == null){ Log.e(TAG, ""ScrollView was null""); return false; } int height = view.getHeight(); height--; int scrollTo = -1; if (direction == DOWN) { scrollTo = height; } else if (direction == UP) { scrollTo = -height; } int originalY = view.getScrollY(); final int scrollAmount = scrollTo; inst.runOnMainSync(new Runnable(){ public void run(){ view.scrollBy(0, scrollAmount); } }); if (originalY == view.getScrollY()) { return false; } else{ return true; } }"	@return true if more scrolling can be done	1	0
"public ArrayList<TextView> clickInList(int line, int index) { if(config.commandLogging){ Log.d(config.commandLoggingTag, ""clickInList(""+line+"", ""+index+"")""); } return clicker.clickInList(line, index, 0, false, 0); }"	@return an ArrayList of the TextView objects located in the list line	0	1
static StringList parseImports(StringDict properties) { StringList outgoing = new StringList(); String importStr = properties.get(IMPORTS_PROPERTY); if (importStr != null) { String[] importList = PApplet.trim(PApplet.split(importStr, ',')); for (String importName : importList) { if (!importName.isEmpty()) { outgoing.append(importName); } } } return (outgoing.size() > 0) ? outgoing : null; }	@return the list of imports that this contribution (library) contains.	1	0
protected boolean scanTo(char c) { for (; cursor < length; cursor++) { switch(expr[cursor]) { case STR: case STR: cursor = captureStringLiteral(expr[cursor], expr, cursor, expr.length); default: if (expr[cursor] == c) { return false; } } } return true; }	@return true if end of char[] is reached, false is the character is encountered.	1	0
public boolean isHighWaterMark() { return (getDispatchedQueueSize() - prefetchExtension.get()) >= (info.getPrefetchSize() * .9); }	@return true when 10% or less room is left for dispatching messages	0	1
public Options includeScalarTypes(boolean flag) { return new Options(this.includeIntrospectionTypes, flag, this.includeExtendedScalars, this.includeSchemaDefinition, this.includeDirectives, this.useAstDefinitions, this.descriptionsAsHashComments, this.comparatorRegistry); }	@return options	0	1
"private Node parseTo(Set<Class<? extends TokenNode>> stopSet, TokenNode forWhat) { ImmutableList.Builder<Node> nodeList = ImmutableList.builder(); while (true) { Node currentNode = currentNode(); if (stopSet.contains(currentNode.getClass())) { break; } if (currentNode instanceof EofNode) { throw new ParseException( ""Reached end of file while parsing "" + forWhat.name(), forWhat.resourceName, forWhat.lineNumber); } Node parsed; if (currentNode instanceof TokenNode) { parsed = parseTokenNode(); } else { parsed = currentNode; nextNode(); } nodeList.add(parsed); } return Node.cons(forWhat.resourceName, forWhat.lineNumber, nodeList.build()); }"	@return a Node that is the concatenation of the parsed subtrees	0	1
public CardViewWrapper getCardView() { return mCardView; }	@return the complete View component	0	1
public DateTimeFormatterBuilder appendCenturyOfEra(int minDigits, int maxDigits) { return appendSignedDecimal(DateTimeFieldType.centuryOfEra(), minDigits, maxDigits); }	@return this DateTimeFormatterBuilder	0	1
public List<String> getReservedAndKeyWords() { ensureReservedAndKeyWords(); return reservedWordsList; }	@return an of SQL reserved and keywords	0	1
"public File getDefaultSketchbookFolder() throws Exception { return new File(System.getProperty(""user.home""), ""sketchbook""); }"	"@return if not overridden, a folder named ""sketchbook"" in user.dir."	1	0
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; // set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { String str = yytext(); int first = str.charAt(0); String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } LOGGER.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: LOGGER.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 35: break; case 2: { if (normalizeOtherBrackets) { return getNext(openparen, yytext()); } else { return getNext(); } } case 36: break; case 3: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 37: break; case 4: { return getNext(); } case 38: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 39: break; case 6: { if (normalizeOtherBrackets) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 40: break; case 7: { final String origTxt = yytext(); return getNext (asciiQuotes(origTxt), origTxt); } case 41: break; case 8: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 42: break; case 9: { if (invertible) { prevWordAfter.append(yytext()); } } case 43: break; case 10: { return handleEllipsis(yytext()); } case 44: break; case 11: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { String origTxt = yytext(); return getNext(asciiDash(origTxt), origTxt); } } case 45: break; case 12: { return normalizeFractions(yytext()); } case 46: break; case 13: { final String origTxt = yytext(); return getNext(asciiQuotes(origTxt), origTxt); } case 47: break; case 14: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 48: break; case 15: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 49: break; case 16: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 50: break; case 17: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 51: break; case 18: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 52: break; case 19: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(); } case 53: break; case 20: { final String origTxt = yytext(); return getNext(origTxt, origTxt, CONTR_ANNOTATION); } case 54: break; case 21: { final String origTxt = yytext(); return getNext(origTxt, origTxt, VB_PRON_ANNOTATION); } case 55: break; case 22: // general lookahead, find correct zzMarkedPos { int zzFState = 1; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 2; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 56: break; case 23: { if (!noSGML) { return getNext(); } } case 57: break; case 24: { final String origTxt = yytext(); return getNext(asciiQuotes(asciiDash(origTxt)), origTxt, COMPOUND_ANNOTATION); } case 58: break; case 25: { // this one should only match if we're basically at the end of file // since the last one matches two things, even newlines String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 59: break; case 26: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 60: break; case 27: { final String origTxt = yytext(); return getNext(asciiQuotes(asciiDash(origTxt)), origTxt); } case 61: break; case 28: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 62: break; case 29: { return getNormalizedAmpNext(); } case 63: break; case 30: // lookahead expression with fixed lookahead length yypushback(2); { return getNext(); } case 64: break; case 31: // general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 65: break; case 32: { yypushback(3) ; return getNext(); } case 66: break; case 33: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } return getNext(txt, yytext()); } case 67: break; case 34: { String txt = yytext(); if (normalizeParentheses) { txt = txt.replaceAll(""\\("", openparen); txt = txt.replaceAll(""\\)"", closeparen); } return getNext(txt, yytext()); } case 68: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }"	@return the next token	0	1
"protected Transport createTransport() throws JMSException { try { URI connectBrokerUL = brokerURL; String scheme = brokerURL.getScheme(); if (scheme == null) { throw new IOException(""Transport not scheme specified: ["" + brokerURL + ""]""); } if (scheme.equals(""auto"")) { connectBrokerUL = new URI(brokerURL.toString().replace(""auto"", ""tcp"")); } else if (scheme.equals(""auto+ssl"")) { connectBrokerUL = new URI(brokerURL.toString().replace(""auto+ssl"", ""ssl"")); } else if (scheme.equals(""auto+nio"")) { connectBrokerUL = new URI(brokerURL.toString().replace(""auto+nio"", ""nio"")); } else if (scheme.equals(""auto+nio+ssl"")) { connectBrokerUL = new URI(brokerURL.toString().replace(""auto+nio+ssl"", ""nio+ssl"")); } return TransportFactory.connect(connectBrokerUL); } catch (Exception e) { throw JMSExceptionSupport.create(""Could not create Transport. Reason: "" + e, e); } }"	@return The newly created Transport.	0	1
public static boolean canEdit(Permissions perms, Permissions user2Perms) { if (isAdmin(perms)) return true; if (isAdmin(user2Perms)) return false; return getManagementLevel(perms) > getManagementLevel(user2Perms); }	@return Whether the first user can modify the second	1	0
public DateTimeField minuteOfHour() { return UnsupportedDateTimeField.getInstance(DateTimeFieldType.minuteOfHour(), minutes()); }	@return DateTimeField or UnsupportedDateTimeField if unsupported	0	1
"private ZapTextArea getTxtPattern() { if (txtPattern == null) { txtPattern = new ZapTextArea(); txtPattern.setLineWrap(true); txtPattern.setFont(new java.awt.Font(""Courier New"", java.awt.Font.PLAIN, 12)); txtPattern.addMouseListener(new java.awt.event.MouseAdapter() { public void mousePressed(java.awt.event.MouseEvent e) { if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0) { // right // mouse // button view.getPopupMenu().show(e.getComponent(), e.getX(), e.getY()); } } }); } return txtPattern; }"	@return javax.swing.JTextField	1	0
public RepositoryMetadata lookupComponent(Class<?> repositoryClass) { if (repositoriesMetadata.containsKey(repositoryClass)) { return repositoriesMetadata.get(repositoryClass); } throw new RuntimeException(STR + repositoryClass.getName()); }	@return A {@link RepositoryMetadataInitializer} corresponding to the repoClass parameter.	1	0
public HttpPanelResponse getResponsePanel() { if (responsePanel == null) { responsePanel = new HttpPanelResponse(false, extension); } return responsePanel; }	@return org.parosproxy.paros.view.HttpPanel	0	1
public long getDifferenceAsLong(ReadableInstant instant) { if (instant == null) { return getField().getDifferenceAsLong(getReadableInstant().getMillis(), DateTimeUtils.currentTimeMillis()); } return getField().getDifferenceAsLong(getReadableInstant().getMillis(), instant.getMillis()); }	@return the difference in the units of this field	0	1
public int distanceTo(WorldPoint other) { return distanceTo(new WorldArea(other, NUM, NUM)); }	@return Returns the distance	1	0
public List<LogRecord> getLogRecords(SessionId sessionId) throws IOException { LogFile logFile = sessionToLogFileMap.get(sessionId); if (logFile == null) { return new ArrayList<>(); } List<LogRecord> logRecords = new ArrayList<>(); try { logFile.openLogReader(); ObjectInputStream logObjInStream = logFile.getLogReader(); LogRecord tmpLogRecord; while (null != (tmpLogRecord = (LogRecord) logObjInStream .readObject())) { logRecords.add(tmpLogRecord); } } catch (IOException | ClassNotFoundException ex) { logFile.closeLogReader(); return logRecords; } logFile.closeLogReader(); return logRecords; }	@return A List of LogRecord objects, which can be null.	0	1
private static Analytics initializeAnalytics() throws Exception { // Authorization. Credential credential = authorize(); // Set up and return Google Analytics API client. return new Analytics.Builder(HTTP_TRANSPORT, JSON_FACTORY, credential) .setApplicationName(APPLICATION_NAME) .setHttpRequestInitializer(credential) .build(); }	@return An initialized Analytics service object.	0	1
public int getMinimumValue() { return getField().getMinimumValue(getReadableInstant().getMillis()); }	@return the minimum value	0	1
@Deprecated public ImmutableGraph executeSparqlQuery(ConstructQuery query, Graph defaultGraph) { return (ImmutableGraph) executeSparqlQuery((Query) query, defaultGraph); }	@return the resulting Graph	1	0
public InetAddress getNumericalAddress() { return address; }	@return the address of the sender as a long.	1	0
"public Client testClientModel(Client body) throws ApiException { Object localVarPostBody = body; // verify the required parameter 'body' is set if (body == null) { throw new ApiException(400, ""Missing the required parameter 'body' when calling testClientModel""); } // create path and map variables String localVarPath = ""/fake""; // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { ""application/json"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { ""application/json"" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Client> localVarReturnType = new GenericType<Client>() {}; return apiClient.invokeAPI(localVarPath, ""PATCH"", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	@return Client	0	1
public static ProcessHandle removeWorkflowExecutionHandle(String modelCode) { LOGGER.trace(STR, modelCode); ProcessHandle handle = workflowExecutionHandles.remove(modelCode); LOGGER.trace(STR, modelCode, handle); return handle; }	@return the removed handle if it was present before the invocation of this method, null otherwise	1	0
static String getType1Message(final String host, final String domain) { // For compatibility reason do not include domain and host in type 1 message //return new Type1Message(domain, host).getResponse(); return TYPE_1_MESSAGE; }	@return String the message to add to the HTTP request header.	0	1
public int getIndicatorCount() { return 0; }	@return number of indicator fields	1	0
"Collection<EBoolean> stringMatchingFilters(EString expr, EString other, String knownValue){ return Arrays.<EBoolean>asList( expr.eq(other), expr.eq(knownValue), expr.ne(other), expr.ne(knownValue), expr.equalsIgnoreCase(other), expr.equalsIgnoreCase(knownValue), expr.lower().eq(other.lower()), expr.upper().eq(other.upper()), expr.lower().eq(knownValue.toLowerCase()), expr.upper().eq(knownValue.toUpperCase()), expr.charAt(0).eq(other.charAt(0)), expr.endsWith(other), expr.endsWith(knownValue), expr.endsWith(knownValue.substring(1)), expr.endsWith(other,false), expr.endsWith(knownValue,false), expr.endsWith(knownValue.substring(1),false), expr.startsWith(other), expr.startsWith(knownValue), expr.startsWith(knownValue.substring(0,1)), expr.startsWith(other,false), expr.startsWith(knownValue,false), expr.startsWith(knownValue.substring(0,1),false), expr.indexOf(knownValue).eq(0), // expr.lastIndexOf(knownValue).eq(0), expr.contains(other), expr.contains(knownValue), expr.contains(knownValue.substring(0,1)), expr.contains(knownValue.substring(1,2)), other.startsWith(expr), other.endsWith(expr), other.contains(expr), expr.substring(0,1).eq(other.substring(0,1)), expr.substring(1).eq(other.substring(1)), expr.substring(0,1).eq(knownValue.substring(0,1)), expr.substring(1).eq(knownValue.substring(1)), expr.like(knownValue), other.like(knownValue), expr.like(knownValue.substring(0,1)+""%""), expr.like(""%""+knownValue.substring(1)), expr.like(""%""+knownValue.substring(1,2)+""%""), expr.matches(knownValue.substring(0,1)+"".*""), expr.matches("".*""+knownValue.substring(1)), expr.matches("".*""+knownValue.substring(1,2)+"".*"") ); }"	@return the collection	0	1
public List<RelDataType> collectOperandTypes() { return new AbstractList<RelDataType>() { public RelDataType get(int index) { return getOperandType(index); } public int size() { return getOperandCount(); } }; }	@return collected array	1	0
protected boolean checkUsingModifiedFlag(Audited aud) { return globalCfg.hasSettingForUsingModifiedFlag() ? globalCfg.isUsingModifiedFlag() : aud.usingModifiedFlag(); }	@return False if this property is not audited.	0	1
protected long getTimeout(Session session) { return session.getTimeout(); }	@return the time in seconds the specified session may remain idle before expiring.	1	0
public boolean equals(Object obj) { if (this == obj) { return true; } if (obj instanceof GJChronology) { GJChronology chrono = (GJChronology) obj; return iCutoverMillis == chrono.iCutoverMillis && getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() && getZone().equals(chrono.getZone()); } return false; }	@return true if equal	0	1
public int compare(Object lhsObj, Object rhsObj) { InstantConverter conv = ConverterManager.getInstance().getInstantConverter(lhsObj); Chronology lhsChrono = conv.getChronology(lhsObj, (Chronology) null); long lhsMillis = conv.getInstantMillis(lhsObj, lhsChrono); // handle null==null and other cases where objects are the same // but only do this after checking the input is valid if (lhsObj == rhsObj) { return 0; } conv = ConverterManager.getInstance().getInstantConverter(rhsObj); Chronology rhsChrono = conv.getChronology(rhsObj, (Chronology) null); long rhsMillis = conv.getInstantMillis(rhsObj, rhsChrono); if (iLowerLimit != null) { lhsMillis = iLowerLimit.getField(lhsChrono).roundFloor(lhsMillis); rhsMillis = iLowerLimit.getField(rhsChrono).roundFloor(rhsMillis); } if (iUpperLimit != null) { lhsMillis = iUpperLimit.getField(lhsChrono).remainder(lhsMillis); rhsMillis = iUpperLimit.getField(rhsChrono).remainder(rhsMillis); } if (lhsMillis < rhsMillis) { return -1; } else if (lhsMillis > rhsMillis) { return 1; } else { return 0; } }	@return zero if order does not matter, negative value if lhsObj &lt; rhsObj, positive value otherwise.	0	1
public Collection<TypedDependency> typedDependencies() { return typedDependencies(Extras.NONE); }	@return The typed dependencies of this grammatical structure	0	1
public Map getFields() { return m_fields; }	@return the field hashmap [field_name, type].	1	0
public static GraphicalModel readFromStream(InputStream stream) throws IOException { return readFromProto(GraphicalModelProto.GraphicalModel.parseDelimitedFrom(stream)); }	@return a new graphical model	0	1
public boolean parseRepositoryXml() throws MojoExecutionException { File fout = new File(m_repositoryXml); if (!fout.exists()) { Document doc = m_documentBuilder.newDocument(); Date d = new Date(); d.setTime(System.currentTimeMillis()); Element root = doc.createElement(STR); root.setAttribute(STR, m_format.format(d)); root.setAttribute(STR, STR); try { writeToFile(m_repositoryXml, root); } catch (MojoExecutionException e) { e.printStackTrace(); throw new MojoExecutionException(STR); } } m_repositoryDoc = parseFile(m_repositoryXml, m_documentBuilder); return (null != m_repositoryDoc); }	@return 0 if the bundle is already in the descriptor, else -1	1	0
public int read(Object[] row, long ts, int rowNumber, int numberOfRows) throws InterruptedException { return converter.read(source, row, rowNumber, numberOfRows, includedColumns, ts, consumer); }	@return the number of records produced; will be 0 or more	0	1
private Point computePopupLocation(int snapPosition) { if (fPopup == null || fPopup.isDisposed()) return null; switch(snapPosition) { case SNAP_POSITION_LOWER_RIGHT: { StyledText eWidget = fEditor.getViewer().getTextWidget(); Rectangle eBounds = eWidget.getClientArea(); Point eLowerRight = eWidget.toDisplay(eBounds.x + eBounds.width, eBounds.y + eBounds.height); Point pSize = getExtent(); return new Point(eLowerRight.x - pSize.x - NUM, eLowerRight.y - pSize.y - NUM); } case SNAP_POSITION_UNDER_RIGHT_FIELD: case SNAP_POSITION_OVER_RIGHT_FIELD: { LinkedPosition position = fRenameLinkedMode.getCurrentLinkedPosition(); if (position == null) return null; ISourceViewer viewer = fEditor.getViewer(); ITextViewerExtension5 viewer5 = (ITextViewerExtension5) viewer; int widgetOffset = viewer5.modelOffset2WidgetOffset(position.offset + position.length); StyledText textWidget = viewer.getTextWidget(); Point pos = textWidget.getLocationAtOffset(widgetOffset); Point pSize = getExtent(); if (snapPosition == SNAP_POSITION_OVER_RIGHT_FIELD) { pos.y -= pSize.y + GAP; } else { pos.y += textWidget.getLineHeight(widgetOffset) + GAP; } pos.x += GAP; Point dPos = textWidget.toDisplay(pos); Rectangle displayBounds = textWidget.getDisplay().getClientArea(); Rectangle dPopupRect = Geometry.createRectangle(dPos, pSize); Geometry.moveInside(dPopupRect, displayBounds); return new Point(dPopupRect.x, dPopupRect.y); } case SNAP_POSITION_UNDER_LEFT_FIELD: case SNAP_POSITION_OVER_LEFT_FIELD: default: { LinkedPosition position = fRenameLinkedMode.getCurrentLinkedPosition(); if (position == null) return null; ISourceViewer viewer = fEditor.getViewer(); ITextViewerExtension5 viewer5 = (ITextViewerExtension5) viewer; int widgetOffset = viewer5.modelOffset2WidgetOffset(position.offset); StyledText textWidget = viewer.getTextWidget(); Point pos = textWidget.getLocationAtOffset(widgetOffset); Point pSize = getExtent(); pSize.y += HAH + NUM; pos.x -= HAO; if (snapPosition == SNAP_POSITION_OVER_LEFT_FIELD) { pos.y -= pSize.y; } else { pos.y += textWidget.getLineHeight(widgetOffset); } Point dPos = textWidget.toDisplay(pos); Rectangle displayBounds = textWidget.getDisplay().getClientArea(); Rectangle dPopupRect = Geometry.createRectangle(dPos, pSize); Geometry.moveInside(dPopupRect, displayBounds); return new Point(dPopupRect.x, dPopupRect.y); } } }	@returns the location in display coordinates or <code>null</code> iff unchanged	1	0
public String toBooleanGetter(String name) { return getterAndSetterCapitalize(name); }	@return getter name based on naming convention	1	0
public Client testSpecialTags(Client body) throws ApiException { return testSpecialTagsWithHttpInfo(body).getData(); }	@return Client	0	1
"public static ErrorInfo handler(final RuntimeException exception) { if (exception instanceof AbstractPlatformResourceNotFoundException) { final PlatformResourceNotFoundExceptionMapper mapper = new PlatformResourceNotFoundExceptionMapper(); final String errorBody = jsonHelper .toJson(mapper.toResponse((AbstractPlatformResourceNotFoundException) exception).getEntity()); return new ErrorInfo(404, 1001, errorBody); } else if (exception instanceof UnsupportedParameterException) { final UnsupportedParameterExceptionMapper mapper = new UnsupportedParameterExceptionMapper(); final String errorBody = jsonHelper.toJson(mapper.toResponse((UnsupportedParameterException) exception).getEntity()); return new ErrorInfo(400, 2001, errorBody); } else if (exception instanceof PlatformApiDataValidationException) { final PlatformApiDataValidationExceptionMapper mapper = new PlatformApiDataValidationExceptionMapper(); final String errorBody = jsonHelper.toJson(mapper.toResponse((PlatformApiDataValidationException) exception).getEntity()); return new ErrorInfo(400, 2002, errorBody); } else if (exception instanceof PlatformDataIntegrityException) { final PlatformDataIntegrityExceptionMapper mapper = new PlatformDataIntegrityExceptionMapper(); final String errorBody = jsonHelper.toJson(mapper.toResponse((PlatformDataIntegrityException) exception).getEntity()); return new ErrorInfo(403, 3001, errorBody); } else if (exception instanceof LinkedAccountRequiredException) { final PlatformDomainRuleExceptionMapper mapper = new PlatformDomainRuleExceptionMapper(); final String errorBody = jsonHelper.toJson(mapper.toResponse((LinkedAccountRequiredException) exception).getEntity()); return new ErrorInfo(403, 3002, errorBody); } else if (exception instanceof MultiDisbursementDataRequiredException) { final PlatformDomainRuleExceptionMapper mapper = new PlatformDomainRuleExceptionMapper(); final String errorBody = jsonHelper.toJson(mapper.toResponse((MultiDisbursementDataRequiredException) exception).getEntity()); return new ErrorInfo(403, 3003, errorBody); } else if (exception instanceof TransactionException) { return new ErrorInfo(400, 4001, ""{\""Exception\"": "" + exception.getMessage()+""}""); } else if (exception instanceof PlatformInternalServerException) { final PlatformInternalServerExceptionMapper mapper = new PlatformInternalServerExceptionMapper(); final String errorBody = jsonHelper.toJson(mapper.toResponse((PlatformInternalServerException) exception).getEntity()); return new ErrorInfo(500, 5001, errorBody); }else if(exception instanceof NonTransientDataAccessException) { return new ErrorInfo(400, 4001, ""{\""Exception\"": "" + exception.getMessage()+""}""); } return new ErrorInfo(500, 9999, ""{\""Exception\"": "" + exception.toString() + ""}""); }"	@return ErrorInfo	0	1
public Integer[] getVersions() { return vers; }	@return iterator for all available versions	1	0
"private boolean reconcileAndLogDifference(Applications delta, String reconcileHashCode) throws Throwable { logger.warn(""The Reconcile hashcodes do not match, client : {}, server : {}. Getting the full registry"", reconcileHashCode, delta.getAppsHashCode()); Applications serverApps = this.fetchRemoteRegistry(false); applications.set(serverApps); applicationsDelta.set(serverApps); logger.warn(""The Reconcile hashcodes after complete sync up, client : {}, server : {}."", getApplications().getReconcileHashCode(), delta.getAppsHashCode()); return true; }"	@return - response	0	1
public String getUserAccountName() { return ((username != null) ? username : ANONYMOUS_USER); }	"@return The user account name. ""&lt;anonymous&gt;"" is returned if {@link #setUserAccountName(String)} was never called."	1	0
"public JSONArray getJSONArray(String key) { Object object = this.get(key); if (object == null) { return null; } if (object instanceof JSONArray) { return (JSONArray)object; } throw new RuntimeException(""JSONObject["" + quote(key) + ""] is not a JSONArray.""); }"	@return A JSONArray which is the value.	1	0
"public AST handleIdentifierError(Token token, RecognitionException ex) throws RecognitionException, TokenStreamException { // If the token can tell us if it could be an identifier... if ( token instanceof HqlToken ) { HqlToken hqlToken = ( HqlToken ) token; // ... and the token could be an identifer and the error is // a mismatched token error ... if ( hqlToken.isPossibleID() && ( ex instanceof MismatchedTokenException ) ) { MismatchedTokenException mte = ( MismatchedTokenException ) ex; // ... and the expected token type was an identifier, then: if ( mte.expecting == HqlTokenTypes.IDENT ) { // Use the token as an identifier. reportWarning( ""Keyword '"" + token.getText() + ""' is being interpreted as an identifier due to: "" + mte.getMessage() ); // Add the token to the AST. ASTPair currentAST = new ASTPair(); token.setType( HqlTokenTypes.WEIRD_IDENT ); astFactory.addASTChild( currentAST, astFactory.create( token ) ); consume(); return currentAST.root; } } // if } // if // Otherwise, handle the error normally. return super.handleIdentifierError( token, ex ); }"	@return AST - The new AST.	0	1
public LoggingConfiguration getLoggingConfiguration() { return loggingConfiguration; }	@return logging-specific configuration parameters	0	1
protected Object convertNumeric(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return NumberConversions.BIGDECIMAL_ZERO; } BigDecimal decimal = null; if (data instanceof BigDecimal) decimal = (BigDecimal) data; else if (data instanceof Boolean) decimal = NumberConversions.getBigDecimal((Boolean) data); else if (data instanceof Short) decimal = new BigDecimal(((Short) data).intValue()); else if (data instanceof Integer) decimal = new BigDecimal(((Integer) data).intValue()); else if (data instanceof Long) decimal = BigDecimal.valueOf(((Long) data).longValue()); else if (data instanceof Float) decimal = BigDecimal.valueOf(((Float) data).doubleValue()); else if (data instanceof Double) decimal = BigDecimal.valueOf(((Double) data).doubleValue()); else { return handleUnknownData(column, fieldDefn, data); } return decimal; }	@return the converted value, or null if the conversion could not be made and the column allows nulls	0	1
public DataType parse(TokenStream stream, Consumer<Collection<ParsingException>> errorHandler) { if (stream.hasNext()) { // Look for all patterns that begin with the first token ... Collection<DataTypePattern> matchingPatterns = patterns.get(stream.peek()); if (matchingPatterns != null) { // At least one registered type begins with the first token, so go through them all in order ... ErrorCollector errors = new ErrorCollector(); Marker mostReadMarker = null; DataType mostReadType = null; Marker marker = stream.mark(); for (DataTypePattern pattern : matchingPatterns) { DataType result = pattern.match(stream, errors::record); if (result != null) { // We found a match, so record it if it is better than our previous best ... if (!stream.hasNext()) { // There's no more to read, so we should be done ... return result; } Marker endMarker = stream.mark(); if (mostReadMarker == null || endMarker.compareTo(mostReadMarker) > 0) { mostReadMarker = endMarker; mostReadType = result; } } stream.rewind(marker); // always, even in the case of success } if (mostReadType != null) { // We've found at least one, so advance the stream to the end of what was consumed by that data type // and return the type that consumes the most of the stream ... stream.advance(mostReadMarker); return mostReadType; } // We still haven't found a data type ... errors.send(errorHandler); } } // Ultimately did not find a match ... return null; }	@return the data type if one was found, or null if none were found	0	1
public String getLocation() { return getFirstValue(HEAD_KEY_LOCATION); }	@return Location.	0	1
public InstrumentationFieldCompleteParameters withNewState(InstrumentationState instrumentationState) { return new InstrumentationFieldCompleteParameters( this.executionContext, executionStrategyParameters, this.fieldDef, this.typeInfo, this.fetchedValue, instrumentationState); }	@return a new parameters object with the new state	0	1
"protected Destination getDestinationFromURI(WebClient client, HttpServletRequest request) throws JMSException { String uri = request.getPathInfo(); if (uri == null) return null; // replace URI separator with JMS destination separator if (uri.startsWith(""/"")) { uri = uri.substring(1); if (uri.length()==0) return null; } uri = uri.replace('/', '.'); System.err.println(""destination uri=""+uri); return getDestination(client, request, uri); }"	@return the destination to use for the current request using the relative URI from where this servlet was invoked as the destination name	0	1
public ResultSet executeQuery(String sql) throws SQLException { if (type == ResultSet.TYPE_FORWARD_ONLY && concurrency == ResultSet.CONCUR_READ_ONLY) { ResultSet rs = internalExecuteQuery(sql); if (rs != null) return rs; else throw new SQLException(STR); } else return new freetds.CursorResultSet(this, sql); }	@return a ResulSet that contains the data produced by the query	1	0
"public Action doCometSupport(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException { if (isDestroyed.get()) return Action.CANCELLED; Action a = null; try { configureRequestResponse(req, res); a = asyncSupport.service(req, res); } catch (IllegalStateException ex) { boolean isJBoss = ex.getMessage().startsWith(""JBoss failed""); if (ex.getMessage() != null && (ex.getMessage().startsWith(""Tomcat failed"") || isJBoss)) { if (!isFilter) { logger.warn(""Failed using comet support: {}, error: {} Is the NIO or APR Connector enabled?"", asyncSupport.getClass().getName(), ex.getMessage()); } logger.error(""If you have more than one Connector enabled, make sure they both use the same protocol, "" + ""e.g NIO/APR or HTTP for all. If not, {} will be used and cannot be changed."", BlockingIOCometSupport.class.getName(), ex); AsyncSupport current = asyncSupport; asyncSupport = asyncSupport.supportWebSocket() && !isJBoss ? new Tomcat7BIOSupportWithWebSocket(config) : new BlockingIOCometSupport(config); if (current instanceof AsynchronousProcessor) { ((AsynchronousProcessor) current).shutdown(); } asyncSupport.init(config.getServletConfig()); logger.warn(""Using "" + asyncSupport.getClass().getName()); a = asyncSupport.service(req, res); } else { logger.error(""AtmosphereFramework exception"", ex); throw ex; } } finally { if (a != null) { notify(a.type(), req, res); } if (!externalizeDestroy) { if (req != null && a != null && a.type() != Action.TYPE.SUSPEND) { req.destroy(); res.destroy(); notify(Action.TYPE.DESTROYED, req, res); } } } return a; }"	@return an Action	0	1
private static YearClass categorizeByYear(Context c) { ArrayList<YearClass> componentYears = new ArrayList<YearClass>(); conditionallyAdd(componentYears, YearClass.fromNumberOfCores()); conditionallyAdd(componentYears, YearClass.fromClockSpeed()); conditionallyAdd(componentYears, YearClass.fromRamTotal(c)); if (componentYears.isEmpty()) return YearClass.CLASS_UNKNOWN; Collections.sort(componentYears); if ((componentYears.size() & NUM) == NUM) { return componentYears.get(componentYears.size() / NUM); } else { int baseIndex = componentYears.size() / NUM - NUM; int averageRoundedDown = componentYears.get(baseIndex).mIntValue + (componentYears.get(baseIndex + NUM).mIntValue - componentYears.get(baseIndex).mIntValue) / NUM; return YearClass.fromIntValue(averageRoundedDown); } }	@return The year when this device would have been considered top-of-the-line.	1	0
public String findInContent(String content) { // First check for a simple exact occurrence for (BoyerMooreMatcher matcher : strings) { if (matcher.findInContent(content) >= 0) return matcher.getPattern(); } // Then check for a regex occurrence Matcher matcher; for (Pattern pattern : patterns) { matcher = pattern.matcher(content); if (matcher.find()) { return matcher.group(); } } // No match found return null return null; }	@return the found occurrence or null if no match has been done	0	1
public PeriodParser toParser() { if (iNotParser) { return null; } return toFormatter().getParser(); }	@return the newly created parser	1	0
public TregexMatcher matcher(Tree t, HeadFinder headFinder) { return matcher(t, t, null, ArrayMap.newArrayMap(), new VariableStrings(), headFinder); }	@return a TregexMatcher	0	1
public Throwable getCause() { return super.getCause(); }	@return The cause of this exception or <code>null</code> if no cause was specified.	1	0
public static FactorTable getFactorTable(double[][] weights, int[][] data, Index[] labelIndices, int numClasses) { CliquePotentialFunction cliquePotentialFunc = new LinearCliquePotentialFunction(weights); return getFactorTable(data, labelIndices, numClasses, cliquePotentialFunc); }	@return a new CRFCliqueTree for the weights on the data	0	1
public BlankNodeOrIri convertNonLiteral(Node node) { if (node == null) { throw new IllegalArgumentException(STR); } if (node.isBlank()) { return convertJenaNode2TriaBlankNode(node); } if (node.isURI()) { return convertJenaUri2UriRef(node); } throw new RuntimeException(STR + node + STR); }	@return BNode if it is a Blank Node otherwise a UriRef	1	0
public static DateTimeFormatter weekDate() { return Constants.wwd; }	@return a formatter for xxxx-'W'ww-e	0	1
protected ComponentTemplate getMetaData(final Object entry) { return (ComponentTemplate) entry; }	@return the ComponentMetaData	1	0
public static final TwitterTokenStream of(TwitterTokenStream... streams) { return new TokenStreamAggregator(streams); }	@return an aggregated TokenStream	1	0
public DateTimeFormatterBuilder appendDayOfYear(final int minDigits) { return appendDecimal(iChronoUTC.dayOfYear(), minDigits, 3); }	@return this DateTimeFormatterBuilder	0	1
protected BroadcasterConfig createBroadcasterConfig(AtmosphereConfig config){ return new BroadcasterConfig(config.framework().broadcasterFilters, config); }	@return an instance of BroadcasterConfig	0	1
public InstrumentationDeferredFieldParameters withNewState(InstrumentationState instrumentationState) { return new InstrumentationDeferredFieldParameters( this.getExecutionContext(), this.executionStrategyParameters, this.getField(), this.getExecutionStepInfo(), instrumentationState); }	@return a new parameters object with the new state	0	1
"public static ParquetFilterPredicate buildParquetFilterPredicate(LogicalExpression expr, final Set<LogicalExpression> constantBoundaries, UdfUtilities udfUtilities) { LogicalExpression logicalExpression = expr.accept(new ParquetFilterBuilder(udfUtilities), constantBoundaries); if (logicalExpression instanceof ParquetFilterPredicate) { return (ParquetFilterPredicate) logicalExpression; } logger.debug(""Logical expression {} was not qualified for filter push down"", logicalExpression); return null; }"	@return logical expression	1	0
public boolean waitForDialogToOpen(long timeout) { return dialogUtils.waitForDialogToOpen(timeout, true); }	@return true if the android.app.Dialog is opened before the timeout and false if it is not opened	0	1
public Builder hasArg() { return hasArg(true); }	@return boolean flag indicating if an argument is required	1	0
public static Blob generateProxy(InputStream stream, long length) { return new BlobProxy( stream, length ); }	@return The generated proxy.	1	0
private boolean canCombine(RelNode input, boolean nullGenerating) { return input instanceof MultiJoin && !((MultiJoin) input).isFullOuterJoin() && !((MultiJoin) input).containsOuter() && !nullGenerating; }	@return true if the input can be combined into a parent MultiJoinRel	1	0
public ClassFieldAccessor getFieldAccessor() { return this.accessor; }	@return Returns the field accessor	1	0
"public boolean dispatchDataChangeEvent(T dataCollectionId, ChangeRecordEmitter changeRecordEmitter) throws InterruptedException { try { boolean handled = false; if (!filter.isIncluded(dataCollectionId)) { LOGGER.trace(""Filtered data change event for {}"", dataCollectionId); eventListener.onFilteredEvent(""source = "" + dataCollectionId); } else { DataCollectionSchema dataCollectionSchema = schema.schemaFor(dataCollectionId); // TODO handle as per inconsistent schema info option if (dataCollectionSchema == null) { final Optional<DataCollectionSchema> replacementSchema = inconsistentSchemaHandler.handle(dataCollectionId, changeRecordEmitter); if (!replacementSchema.isPresent()) { return false; } dataCollectionSchema = replacementSchema.get(); } changeRecordEmitter.emitChangeRecords(dataCollectionSchema, new Receiver() { @Override public void changeRecord(DataCollectionSchema schema, Operation operation, Object key, Struct value, OffsetContext offset) throws InterruptedException { transactionMonitor.dataEvent(dataCollectionId, offset, key, value); eventListener.onEvent(dataCollectionId, offset, key, value); streamingReceiver.changeRecord(schema, operation, key, value, offset); } }); handled = true; } heartbeat.heartbeat( changeRecordEmitter.getOffset().getPartition(), changeRecordEmitter.getOffset().getOffset(), this::enqueueHeartbeat); return handled; } catch (Exception e) { switch (connectorConfig.getEventProcessingFailureHandlingMode()) { case FAIL: LOGGER.error( ""Error while processing event at offset {}"", changeRecordEmitter.getOffset().getOffset()); throw e; case WARN: LOGGER.warn( ""Error while processing event at offset {}"", changeRecordEmitter.getOffset().getOffset()); break; case IGNORE: LOGGER.debug( ""Error while processing event at offset {}"", changeRecordEmitter.getOffset().getOffset()); break; } return false; } }"	@return true if an event was dispatched (i.e. sent to the message broker), false otherwise.	0	1
"public HashSet<String> updateDBIcons(UserHandleCompat user, List<LauncherActivityInfoCompat> apps) { mIconDb.updateSystemStateString(mContext); long userSerial = mUserManager.getSerialNumberForUser(user); PackageManager pm = mContext.getPackageManager(); HashMap<String, PackageInfo> pkgInfoMap = new HashMap<String, PackageInfo>(); for (PackageInfo info : pm.getInstalledPackages(PackageManager.GET_UNINSTALLED_PACKAGES)) { pkgInfoMap.put(info.packageName, info); } HashMap<ComponentName, LauncherActivityInfoCompat> componentMap = new HashMap<>(); for (LauncherActivityInfoCompat app : apps) { componentMap.put(app.getComponentName(), app); } Cursor c = mIconDb.getReadableDatabase().query(IconDB.TABLE_NAME, new String[] {IconDB.COLUMN_ROWID, IconDB.COLUMN_COMPONENT, IconDB.COLUMN_LAST_UPDATED, IconDB.COLUMN_VERSION, IconDB.COLUMN_SYSTEM_STATE}, IconDB.COLUMN_USER + "" = ? "", new String[] {Long.toString(userSerial)}, null, null, null); final int indexComponent = c.getColumnIndex(IconDB.COLUMN_COMPONENT); final int indexLastUpdate = c.getColumnIndex(IconDB.COLUMN_LAST_UPDATED); final int indexVersion = c.getColumnIndex(IconDB.COLUMN_VERSION); final int rowIndex = c.getColumnIndex(IconDB.COLUMN_ROWID); final int systemStateIndex = c.getColumnIndex(IconDB.COLUMN_SYSTEM_STATE); HashSet<Integer> itemsToRemove = new HashSet<Integer>(); HashSet<String> updatedPackages = new HashSet<String>(); while (c.moveToNext()) { String cn = c.getString(indexComponent); ComponentName component = ComponentName.unflattenFromString(cn); PackageInfo info = pkgInfoMap.get(component.getPackageName()); if (info == null) { itemsToRemove.add(c.getInt(rowIndex)); continue; } if ((info.applicationInfo.flags & ApplicationInfo.FLAG_IS_DATA_ONLY) != 0) { // Application is not present continue; } long updateTime = c.getLong(indexLastUpdate); int version = c.getInt(indexVersion); LauncherActivityInfoCompat app = componentMap.remove(component); if (version == info.versionCode && updateTime == info.lastUpdateTime && TextUtils.equals(mIconDb.mSystemState, c.getString(systemStateIndex))) { continue; } if (app == null) { itemsToRemove.add(c.getInt(rowIndex)); continue; } ContentValues values = updateCacheAndGetContentValues(app, true); mIconDb.getWritableDatabase().update(IconDB.TABLE_NAME, values, IconDB.COLUMN_COMPONENT + "" = ? AND "" + IconDB.COLUMN_USER + "" = ?"", new String[] {cn, Long.toString(userSerial)}); updatedPackages.add(component.getPackageName()); } c.close(); if (!itemsToRemove.isEmpty()) { mIconDb.getWritableDatabase().delete(IconDB.TABLE_NAME, IconDB.COLUMN_ROWID + "" IN ( "" + TextUtils.join("", "", itemsToRemove) +"" )"", null); } // Insert remaining apps. if (!componentMap.isEmpty()) { mWorkerHandler.post(new SerializedIconAdditionTask(userSerial, pkgInfoMap, componentMap.values())); } return updatedPackages; }"	@return The set of packages for which icons have updated.	0	1
private static CoreMap fromProto(CoreNLPProtos.Sentence proto) { CoreMap sentence = new ArrayCoreMap(); // Required fields sentence.set(TokenBeginAnnotation.class, proto.getTokenOffsetBegin()); sentence.set(TokenEndAnnotation.class, proto.getTokenOffsetEnd()); // Optional fields if (proto.hasSentenceIndex()) { sentence.set(SentenceIndexAnnotation.class, proto.getSentenceIndex()); } if (proto.hasCharacterOffsetBegin()) { sentence.set(CharacterOffsetBeginAnnotation.class, proto.getCharacterOffsetBegin()); } if (proto.hasCharacterOffsetEnd()) { sentence.set(CharacterOffsetEndAnnotation.class, proto.getCharacterOffsetEnd()); } if (proto.hasParseTree()) { sentence.set(TreeAnnotation.class, fromProto(proto.getParseTree())); } // Non-default fields if (proto.hasHasRelationAnnotations() && proto.getHasRelationAnnotations()) { // set entities List<EntityMention> entities = new ArrayList<EntityMention>(); for (CoreNLPProtos.Entity entity : proto.getEntityList()) { entities.add(fromProto(entity, sentence)); } sentence.set(EntityMentionsAnnotation.class, entities); // set relations List<RelationMention> relations = new ArrayList<RelationMention>(); for (CoreNLPProtos.Relation relation : proto.getRelationList()) { relations.add(fromProto(relation, sentence)); } sentence.set(RelationMentionsAnnotation.class, relations); } // Return return sentence; }	@return A CoreLabel, missing the fields that are not stored in the CoreLabel protobuf.	1	0
public float get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }	@return the value of this attribute if this attribute is present in the map. Otherwise {@link #getDefaultValue()}	1	0
"public WebDriver augment(WebDriver driver) { // TODO(simon): We should really add a ""SelfDescribing"" interface for this if (!(driver instanceof RemoteWebDriver)) { return driver; } Map<String, ?> capabilities = ((RemoteWebDriver) driver).getCapabilities().asMap(); CompoundHandler handler = new CompoundHandler((RemoteWebDriver) driver); for (Map.Entry<String, ?> capablityName : capabilities.entrySet()) { AugmenterProvider augmenter = augmentors.get(capablityName.getKey()); if (augmenter == null) { continue; } Object value = capablityName.getValue(); if (value instanceof Boolean && !((Boolean) value).booleanValue()) { continue; } handler.addCapabilityHander(augmenter.getDescribedInterface(), augmenter.getImplementation(value)); } if (handler.isNeedingApplication()) { // Gather the existing interfaces Set<Class<?>> interfaces = new HashSet<Class<?>>(); interfaces.addAll(handler.getInterfaces()); interfaces.addAll(getInterfacesFrom(driver.getClass())); Enhancer enhancer = new Enhancer(); enhancer.setInterfaces(interfaces.toArray(new Class<?>[interfaces.size()])); enhancer.setCallback(handler); enhancer.setSuperclass(driver.getClass()); RemoteWebDriver remote = (RemoteWebDriver) enhancer.create(); remote.setCommandExecutor(((RemoteWebDriver) driver).getCommandExecutor()); remote.setElementConverter(((RemoteWebDriver) driver).getElementConverter()); return remote; } return driver; }"	@return A class implementing the described interfaces.	0	1
protected IListFrame createListFrame(SQLElement elem) { return null; }	@return the frame to be displayed.	1	0
private Color invertFgColor() { if (currentBgColor_.defaultColor()) { if (!inverted_) clazzes_.add(INVERSE_FG_STYLE); return new Color(); } else if (currentBgColor_.isExtended()) { clazzes_.add(Color.clazzForColorIndex(currentBgColor_.code(), false)); return new Color(true, currentBgColor_.code()); } else if (currentBgColor_.code() >= BACKGROUND_MIN && currentBgColor_.code() <= BACKGROUND_MAX) { int newFg = currentBgColor_.code() - (BACKGROUND_MIN - FOREGROUND_MIN); clazzes_.add(FOREGROUND_STYLE + Integer.toString(newFg - FOREGROUND_MIN)); return new Color(false, newFg); } else { int newFg = currentBgColor_.code() - (BACKGROUND_INTENSE_MIN - FOREGROUND_INTENSE_MIN); clazzes_.add(FOREGROUND_STYLE + Integer.toString(newFg + NUM - FOREGROUND_INTENSE_MIN)); return new Color(false, newFg); } }	@return new foreground color based on the supplied background color	1	0
public final double getValue(long timestamp) { compute(timestamp, timestamp); Score s = getComputedByTimestamp(timestamp); if (s == null) throw new IllegalStateException(); return s.getValue(); }	@return score for that day	1	0
public int[] set(PartialInstant instant, int fieldIndex, int[] values, int newValue) { FieldUtils.verifyValueBounds(this, newValue, getMinimumValue(instant), getMaximumValue(instant)); values[fieldIndex] = newValue; return values; }	@return the updated milliseconds	1	0
public Builder withSpnego(String principal, String realm) { return this.withSpnego(principal, realm, null); }	@return this	0	1
public String getMatchedSentences() { StringBuilder sb = new StringBuilder(); for (int i = NUM, sz = list.getModel().getSize(); i < sz; i++) { String t = list.getModel().getElementAt(i).getLabel().getText(); sb.append(t); sb.append(STR); } return sb.toString(); }	@return StringBuffer filled with the plain text form of all sentences in the matches panel	1	0
public MergedSelectionSet collectFields(FieldCollectorParameters parameters, SelectionSet selectionSet) { Map<String, MergedFields> subFields = new LinkedHashMap<>(); List<String> visitedFragments = new ArrayList<>(); this.collectFields(parameters, selectionSet, visitedFragments, subFields); return newMergedSelectionSet().subFields(subFields).build(); }	@return a map of the sub field selections	0	1
"static TopicSelector<TableId> defaultSelector(String prefix, String heartbeatPrefix) { return TopicSelector.defaultSelector(prefix, heartbeatPrefix, ""."", (t, pref, delimiter) -> String.join(delimiter, pref, t.catalog(), t.table())); }"	@return the topic selector; never null	0	1
public boolean waitForText(String text, int minimumNumberOfMatches, long timeout) { return robotiumUtils.waitForText(text, minimumNumberOfMatches, timeout); }	@return true if text is found and false if it is not found before the timeout	1	0
public Collection getDistancesMap(Group run, String year) { IWContext iwc = IWContext.getInstance(); Map disMap = new LinkedHashMap(); Collection distances = null; Collection type = new ArrayList(); type.add(IWMarathonConstants.GROUP_TYPE_RUN_DISTANCE); Iterator yearsIter = getYears(run).iterator(); while (yearsIter.hasNext()) { Group y = (Group) yearsIter.next(); if (y.getName().equals(year)) { try { distances = getGroupBiz(iwc).getChildGroupsRecursiveResultFiltered(y, type, true); } catch (Exception e) { distances = null; } } } return distances; }	@return Map of all distances for a specific run on a specific year	1	0
public static String getShortClassName(Object o) { String name = o.getClass().getName(); int index = name.lastIndexOf('.'); if (index >= 0) { name = name.substring(index + 1); } return name; }	@return The name of the class minus a package name, for example ArrayList	0	1
private boolean isSameText() { ArrayList<TextView> textViewList = soloView.getCurrentTextViews(null); int size = textViewList.size(); int constant = 0; if (size > 2) constant = 2; else constant = size; if (checkTextView != null && !checkTextView.getText().equals( textViewList.get(size - constant).getText())) { checkTextView = textViewList.get(size - constant); return false; } else if (checkTextView == null) { checkTextView = textViewList.get(size - constant); return false; } else return true; }	@return true if no more scrolling can be done	1	0
public ArrayList<Activity> getAllOpenedActivities() { return activitiyUtils.getAllOpenedActivities(); }	@return an ArrayList of all the opened/active activities	0	1
public org.apache.poi.ss.usermodel.Workbook transformXLS(InputStream is, Map beanParams) throws ParsePropertyException, InvalidFormatException { org.apache.poi.ss.usermodel.Workbook hssfWorkbook = null; try { hssfWorkbook = WorkbookFactory.create(is); transformWorkbook(hssfWorkbook, beanParams); } catch (IOException e) { e.printStackTrace(); } return hssfWorkbook; }	@return new {@link HSSFWorkbook} generated by inserting beans into corresponding excel template	1	0
public Boolean asBoolean() { return Boolean.valueOf(arg); }	@return This ChatSection's value parsed as a boolean. If the value of the ChatSection isn't a valid boolean, false is returned	1	0
public Category getCategory() { if (payload != null) { return payload.category; } return null; }	@return The category	1	0
public SessionFactory getSessionFactory() { return daoTest.getSessionFactory(); }	@return SessionFactory with an open session.	0	1
public static long toEpochMicros(Object value) { LocalDateTime dateTime = Conversions.toLocalDateTime(value); long epochNanos = Conversions.toEpochNanos(dateTime); return Math.floorDiv(epochNanos, Conversions.NANOSECONDS_PER_MICROSECOND); }	@return the epoch microseconds	0	1
"private boolean optimize(Visitor optimizer, boolean performInline) { int optimizeCount = 0; final UseCounter useCounter = new UseCounter(); for (Statement statement : statements) { if (statement instanceof DeclarationStatement && performInline) { DeclarationStatement decl = (DeclarationStatement) statement; useCounter.map.put(decl.parameter, new Slot()); } // We are added only counters up to current statement. // It is fine to count usages as the latter declarations cannot be used // in more recent statements. if (!useCounter.map.isEmpty()) { statement.accept(useCounter); } } final Map<ParameterExpression, Expression> subMap = new IdentityHashMap<ParameterExpression, Expression>( useCounter.map.size()); final SubstituteVariableVisitor visitor = new SubstituteVariableVisitor( subMap); final ArrayList<Statement> oldStatements = new ArrayList<Statement>( statements); statements.clear(); for (Statement oldStatement : oldStatements) { if (oldStatement instanceof DeclarationStatement) { DeclarationStatement statement = (DeclarationStatement) oldStatement; final Slot slot = useCounter.map.get(statement.parameter); int count = slot == null ? 100 : slot.count; if (count > 1 && isSafeForReuse(statement) && isSimpleExpression(statement.initializer)) { // Inline simple final constants count = 1; } if (statement.parameter.name.startsWith(""_"")) { // Don't inline variables whose name begins with ""_"". This // is a hacky way to prevent inlining. E.g. // final int _count = collection.size(); // foo(collection); // return collection.size() - _count; count = 100; } if (statement.initializer instanceof NewExpression && ((NewExpression) statement.initializer).memberDeclarations != null) { // Don't inline anonymous inner classes. Janino gets // confused referencing variables from deeply nested // anonymous classes. count = 100; } Expression normalized = normalizeDeclaration(statement); expressionForReuse.remove(normalized); switch (count) { case 0: // Only declared, never used. Throw away declaration. break; case 1: // declared, used once. inline it. subMap.put(statement.parameter, normalized); break; default: Statement beforeOptimize = oldStatement; if (!subMap.isEmpty()) { oldStatement = oldStatement.accept(visitor); // remap } oldStatement = oldStatement.accept(optimizer); if (beforeOptimize != oldStatement) { ++optimizeCount; } if (oldStatement != OptimizeVisitor.EMPTY_STATEMENT) { if (oldStatement instanceof DeclarationStatement) { addExpresisonForReuse((DeclarationStatement) oldStatement); } statements.add(oldStatement); } break; } } else { Statement beforeOptimize = oldStatement; if (!subMap.isEmpty()) { oldStatement = oldStatement.accept(visitor); // remap } oldStatement = oldStatement.accept(optimizer); if (beforeOptimize != oldStatement) { ++optimizeCount; } if (oldStatement != OptimizeVisitor.EMPTY_STATEMENT) { statements.add(oldStatement); } } } return optimizeCount > 0; }"	@return if any optimizations were made or not	1	0
public Session createSession(boolean transacted,int acknowledgeMode) throws JMSException{ checkClosedOrFailed(); ensureConnectionInfoSent(); boolean doSessionAsync=alwaysSessionAsync||sessions.size()>0||transacted ||acknowledgeMode==Session.CLIENT_ACKNOWLEDGE; return new ActiveMQSession(this,getNextSessionId(),(transacted?Session.SESSION_TRANSACTED :(acknowledgeMode==Session.SESSION_TRANSACTED?Session.AUTO_ACKNOWLEDGE:acknowledgeMode)), asyncDispatch,alwaysSessionAsync); }	@return a newly created session	0	1
public ApiResponse<Order> getOrderByIdWithHttpInfo(Long orderId) throws ApiException { okhttp3.Call localVarCall = getOrderByIdValidateBeforeCall(orderId, null, null); Type localVarReturnType = new TypeToken<Order>(){}.getType(); return localVarApiClient.execute(localVarCall, localVarReturnType); }	@return ApiResponse&lt;Order&gt;	0	1
public int getSessionState() { return ServerApiUtils.getSessionState(session); }	@return State (-1: not started, 0: pending, 1: canceled, 2: established, 3: terminated)	1	0
public boolean equals(Object o) { if (this == o) { return true; } if (!(o instanceof FiltersAggregation)) { return false; } FiltersAggregation rhs = (FiltersAggregation) o; return new EqualsBuilder() .append(getCountList(), rhs.getCountList()) .append(getCounts(), rhs.getCounts()) .isEquals(); }	@return A map filter names to associated counts	0	1
"public static IdentifierProperty buildIdentifierProperty(EntityBinding mappedEntity, IdentifierGenerator generator) { final SimpleAttributeBinding property = mappedEntity.getEntityIdentifier().getValueBinding(); // TODO: the following will cause an NPE with ""virtual"" IDs; how should they be set? final String mappedUnsavedValue = property.getUnsavedValue(); final Type type = property.getHibernateTypeDescriptor().getExplicitType(); IdentifierValue unsavedValue = UnsavedValueFactory.getUnsavedIdentifierValue( mappedUnsavedValue, getGetter( property ), type, getConstructor( mappedEntity ) ); if ( property == null ) { // this is a virtual id property... return new IdentifierProperty( type, mappedEntity.getEntityIdentifier().isEmbedded(), mappedEntity.getEntityIdentifier().isIdentifierMapper(), unsavedValue, generator ); } else { return new IdentifierProperty( property.getAttribute().getName(), property.getNodeName(), type, mappedEntity.getEntityIdentifier().isEmbedded(), unsavedValue, generator ); } }"	@return The appropriate IdentifierProperty definition.	0	1
protected String getBaseURL() { return this.extendGetBaseUrl(new StringBuilder(this.baseUrl)).toString(); }	"@return the base URL with no final ""/""."	1	0
protected Object convertRowId(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return ByteBuffer.wrap(new byte[0]); } if (data instanceof java.sql.RowId) { java.sql.RowId row = (java.sql.RowId) data; return ByteBuffer.wrap(row.getBytes()); } return handleUnknownData(column, fieldDefn, data); }	@return the converted value, or null if the conversion could not be made	1	0
"public String toString() { long millis = getMillis(); StringBuffer buf = new StringBuffer(); buf.append(""PT""); FormatUtils.appendUnpaddedInteger(buf, millis / 1000); long part = Math.abs(millis % 1000); if (part > 0) { buf.append('.'); FormatUtils.appendPaddedInteger(buf, part, 3); } buf.append('S'); return buf.toString(); }"	@return the value as an ISO8601 string	0	1
public boolean isBoolean() { return raw.equals(STR) || raw.equals(STR); }	@return Whether this ChatSection's argument can be parsed as a boolean	1	0
public boolean searchText(String search, int matches) { long now = System.currentTimeMillis(); final long endTime = now + TIMEOUT; while (!searchForText(search, matches) && now < endTime) { RobotiumUtils.sleep(PAUS); now = System.currentTimeMillis(); } return searchForText(search, matches); }	@return true if search string is found a given number of times and false if the search string is not found	0	1
public static EventProcessingFailureHandlingMode parse(String value) { if (value == null) { return null; } value = value.trim(); for (EventProcessingFailureHandlingMode option : EventProcessingFailureHandlingMode.values()) { if (option.getValue().equalsIgnoreCase(value)) { return option; } } return null; }	@return the matching option, or null if no match is found and the non-null default is invalid	1	0
"public Response processBrokerInfo(BrokerInfo info) { if (info.isSlaveBroker()) { //stream messages from this broker (the master) to //the slave MutableBrokerFilter parent = (MutableBrokerFilter) broker.getAdaptor(MutableBrokerFilter.class); masterBroker = new MasterBroker(parent, transport); masterBroker.startProcessing(); log.info(""Slave Broker "" + info.getBrokerName() + "" is attached""); } // We only expect to get one broker info command per connection if( this.brokerInfo!=null ) { log.warn(""Unexpected extra broker info command received: ""+info); } this.brokerInfo = info; broker.addBroker(this, info); return null; }"	@return true if the Connection needs to stop	0	1
public boolean getExtraBoolean(String key) throws JSONException { return mExtraData.getBoolean(key); }	@return The stored value or null if it doesn't exist in specified form.	1	0
public Iterable<DocumentRequest> getDocumentRequests() { return documentRequests; }	@return a non-null object iterating over no nulls.	1	0
"public Score score(List<Collection<TypedDependency>> system) { int parserCnt = 0; int goldCnt = 0; int correctAttachment = 0; int correctUnlabeledAttachment = 0; int labelCnt = 0; int labelCorrect = 0; ClassicCounter<String> unlabeledErrorCounts = new ClassicCounter<String>(); ClassicCounter<String> labeledErrorCounts = new ClassicCounter<String>(); //System.out.println(""Gold size: ""+ goldDeps.size() + "" System size: ""+system.size()); for (int i = 0; i < system.size(); i++) { List<Set<TypedDependency>> l = toSets(system.get(i)); if (ignorePunc) { removeHeadsAssignedToPunc(l.get(0)); removeHeadsAssignedToPunc(l.get(1)); } parserCnt += l.get(0).size(); goldCnt += goldDeps.get(i).size(); l.get(0).retainAll(goldDeps.get(i)); //System.out.println(""UGold: ""+goldDepsUnlabeled.get(i)+""\n""); //System.out.println(""USys: ""+l.get(1)+""\n""); l.get(1).retainAll(goldDepsUnlabeled.get(i)); correctAttachment += l.get(0).size(); correctUnlabeledAttachment += l.get(1).size(); labelCnt += l.get(1).size(); labelCorrect += l.get(0).size(); //System.out.println(""""+i+"" Acc: ""+(l.get(0).size())/(double)localCnt+"" ""+l.get(0).size()+""/""+localCnt); // identify errors List<Set<TypedDependency>> errl = toSets(system.get(i)); errl.get(0).removeAll(goldDeps.get(i)); errl.get(1).removeAll(goldDepsUnlabeled.get(i)); Map<String,String> childCorrectWithLabel = new HashMap<String,String>(); Map<String,String> childCorrectWithOutLabel = new HashMap<String,String>(); for (TypedDependency goldDep: goldDeps.get(i)) { //System.out.print(goldDep); String sChild = goldDep.dep().label().toString().replaceFirst(""-[^-]*$"", """"); String prefixLabeled = """"; String prefixUnlabeled = """"; if (childCorrectWithLabel.containsKey(sChild)) { prefixLabeled = childCorrectWithLabel.get(sChild)+"", ""; prefixUnlabeled = childCorrectWithOutLabel.get(sChild)+"", ""; } childCorrectWithLabel.put(sChild, prefixLabeled + goldDep.reln()+""(""+goldDep.gov().label().toString().replaceFirst(""-[^-]*$"", """")+"", ""+sChild+"")""); childCorrectWithOutLabel.put(sChild, prefixUnlabeled + ""dep(""+goldDep.gov().label().toString().replaceFirst(""-[^-]*$"", """")+"", ""+sChild+"")""); } for (TypedDependency labeledError: errl.get(0)) { String sChild = labeledError.dep().label().toString().replaceFirst(""-[^-]*$"", """"); String sGov = labeledError.gov().label().toString().replaceFirst(""-[^-]*$"", """"); labeledErrorCounts.incrementCount(labeledError.reln().toString()+""(""+sGov+"", ""+sChild+"") <= ""+childCorrectWithLabel.get(sChild)); } for (TypedDependency unlabeledError: errl.get(1)) { String sChild = unlabeledError.dep().label().toString().replaceFirst(""-[^-]*$"", """"); String sGov = unlabeledError.gov().label().toString().replaceFirst(""-[^-]*$"", """"); unlabeledErrorCounts.incrementCount(""dep(""+sGov+"", ""+sChild+"") <= ""+childCorrectWithOutLabel.get(sChild)); } } return new Score(parserCnt, goldCnt, correctAttachment, correctUnlabeledAttachment, labelCnt, labelCorrect, labeledErrorCounts, unlabeledErrorCounts); }"	@return a triple consisting of (labeled attachment, unlabeled attachment, label accuracy)	0	1
public Complex getComplex() { return get(); }	@return item in given position	1	0
public long getColumnValueCount(SchemaPath column) { ColumnStatistics<?> columnStats = getTableMetadata().getColumnStatistics(column); ColumnStatistics<?> nonInterestingColStats = columnStats == null ? getNonInterestingColumnsMetadata().getColumnStatistics(column) : null; long tableRowCount; if (columnStats != null) { tableRowCount = TableStatisticsKind.ROW_COUNT.getValue(getTableMetadata()); } else if (nonInterestingColStats != null) { tableRowCount = TableStatisticsKind.ROW_COUNT.getValue(getNonInterestingColumnsMetadata()); columnStats = nonInterestingColStats; } else if (hasNestedStatsForColumn(column, getTableMetadata()) || hasNestedStatsForColumn(column, getNonInterestingColumnsMetadata())) { // When statistics for nested field exists, this is complex column which is present in table. // But its nested fields statistics can't be used to extract tableRowCount for this column. // So NO_COLUMN_STATS returned here to avoid problems described in DRILL-7491. return Statistic.NO_COLUMN_STATS; } else { return 0; // returns 0 if the column doesn't exist in the table. } Long nulls = ColumnStatisticsKind.NULLS_COUNT.getFrom(columnStats); if (nulls == null || Statistic.NO_COLUMN_STATS == nulls || Statistic.NO_COLUMN_STATS == tableRowCount) { return Statistic.NO_COLUMN_STATS; } else { return tableRowCount - nulls; } }	@return column value count	0	1
public BufferedReader open(final String fileName) { BufferedReader reader; try { reader = new BufferedReader(new FileReader(fileName)); } catch (FileNotFoundException e) { return (null); } return (reader); }	@return Status.OK, if all went well; Status.FILE_NOT_FOUND_ERR if file not found.	1	0
"public Client build(String name) { if ((environment == null) && (executorService == null) && (objectMapper == null)) { throw new IllegalStateException(""Must have either an environment or both "" + ""an executor service and an object mapper""); } if (environment == null) { return build(executorService, objectMapper, validator, name); } return build(environment.getLifecycleEnvironment() .executorService(""jersey-client-"" + name + ""-%d"") .minThreads(configuration.getMinThreads()) .maxThreads(configuration.getMaxThreads()) .build(), environment.getObjectMapper(), environment.getValidator(), name); }"	@return a fully-configured Client	0	1
public EString substring(int beginIndex, int endIndex) { return OString.create(Ops.SUBSTR_2ARGS, this, ENumber.create(beginIndex), ENumber.create(endIndex)); }	@return this.substring(beginIndex, endIndex)	0	1
public static RelDataTypeField lookupField(final RelDataType rowType, String columnName) { final RelDataTypeField[] fields = rowType.getFields(); for (int i = NUM; i < fields.length; i++) { RelDataTypeField field = fields[i]; if (field.getName().equals(columnName)) { return field; } } return null; }	@return Ordinal of field, or -1 if not found	1	0
public Order placeOrder(Order order) throws ApiException { return placeOrderWithHttpInfo(order).getData(); }	@return Order	0	1
public static List<Integer> getSubListIndex(Object[] l1, Object[] l2){ if(l1.length > l2.length) return null; List<Integer> allIndices = new ArrayList<Integer>(); boolean matched = false; int index = -1; int lastUnmatchedIndex = 0; for(int i = 0 ; i < l2.length;){ for(int j = 0; j < l1.length ;){ if(l1[j].equals(l2[i])){ index = i; i++; j++; if(j == l1.length) { matched = true; break; } }else{ j = 0; i = lastUnmatchedIndex +1; lastUnmatchedIndex = i; index = -1; if(lastUnmatchedIndex == l2.length) break; } if(i >= l2.length){ index = -1; break; } } if(i == l2.length || matched){ if(index >= 0) //index = index - l1.length + 1; allIndices.add(index - l1.length + 1); matched = false; lastUnmatchedIndex = index; //break; } } //get starting point return allIndices; }	@return starting index of the sublist	0	1
public String getKDCList(String realm) throws KrbException { if (realm == null) { realm = getDefaultRealm(); } Exception cause = null; String kdcs = getDefault(STR, realm); if (kdcs == null) { kdcs = java.security.AccessController.doPrivileged(new java.security.PrivilegedAction<String>() { @Override public String run() { String osname = System.getProperty(STR); if (osname.startsWith(STR)) { String logonServer = System.getenv(STR); if (logonServer != null && logonServer.startsWith(STR)) { logonServer = logonServer.substring(NUM); } return logonServer; } return null; } }); } if (kdcs == null) { KrbException ke = new KrbException(STR); if (cause != null) { ke.initCause(cause); } throw ke; } return kdcs; }	@return the list of KDCs	1	0
"public Instant timestampOfLsn(Lsn lsn) throws SQLException { final String query = ""SELECT sys.fn_cdc_map_lsn_to_time(?)""; if (lsn.getBinary() == null) { return null; } return prepareQueryAndMap(query, statement -> { statement.setBytes(1, lsn.getBinary()); }, singleResultMapper(rs -> { final Timestamp ts = rs.getTimestamp(1); final Instant ret = (ts == null) ? null : ts.toInstant(); LOGGER.trace(""Timestamp of lsn {} is {}"", lsn, ret); return ret; }, ""LSN to timestamp query must return exactly one value"")); }"	@return time when the commit was recorded into the database log	0	1
public Integer getHttpDaemonPort() { return port; }	@return a value greater than 0.	1	0
public int size() { return applications.stream().mapToInt(Application::size).sum(); }	@return a weakly consistent size of the number of instances in all the applications	0	1
public boolean isMirrored() { if (!fMirroringEnabled) return false; Object property = getProperty(MIRRORED); return property instanceof Boolean && (Boolean) property; }	@return true if the left and right side of the viewer are mirrored. Default is false.	1	0
public ArrayList<ErrorMsg> getErrors() { return _parser.getErrors(); }	@return A Vector containing all compile error messages	1	0
"static boolean implementsMethod(TypeElement clazz, MethodSpec method, Types typeUtils) { ExecutableElement methodOnClass = getMethodOnClass(clazz, method, typeUtils); if (methodOnClass == null) { return false; } Element implementingClass = methodOnClass.getEnclosingElement(); if (implementingClass.getSimpleName().toString().equals(""Object"")) { // Don't count default implementations on Object class return false; } Set<Modifier> modifiers = methodOnClass.getModifiers(); return !modifiers.contains(Modifier.ABSTRACT); }"	@return True if the clazz (or one of its superclasses) implements the given method. Returns false if the method doesn't exist anywhere in the class hierarchy or it is abstract.	1	0
"public String getValue(String locator) { return (String) seleneseMethods.get(""getValue"").apply(driver, locator); }"	"@return the element value, or ""on/off"" for checkbox/radio elements"	0	1
"private ZapTextArea getDefaultOutput() { if (defaultOutput == null) { defaultOutput = new ZapTextArea(); defaultOutput.setEditable(false); defaultOutput.setLineWrap(true); defaultOutput.setFont(new java.awt.Font(""Dialog"", java.awt.Font.PLAIN, 12)); defaultOutput.setName(""""); defaultOutput.append(Constant.messages.getString(""alerts.label.defaultMessage"")); } return defaultOutput; }"	@return javax.swing.JTextArea	1	0
long insertOpenCell(double latitude, double longitude, int mcc, int mnc, int lac, int cellID, int avgSigStr, int range, int samples, int isGPSexact, String RAT) { ContentValues cellIDValues = new ContentValues(); cellIDValues.put(STR, latitude); cellIDValues.put(STR, longitude); cellIDValues.put(STR, mcc); cellIDValues.put(STR, mnc); cellIDValues.put(STR, lac); cellIDValues.put(STR, cellID); cellIDValues.put(STR, avgSigStr); cellIDValues.put(STR, range); cellIDValues.put(STR, samples); cellIDValues.put(STR, isGPSexact); cellIDValues.put(STR, RAT); if (openCellExists(cellID)) { Log.v(TAG, mTAG + STR + cellID); return NUM; } else { return mDb.insert(OPENCELLID_TABLE, null, cellIDValues); } }	@return row id or -1 if error TODO: Is this where CSV data is populating the opencellid table?	1	0
public boolean needCache() { return RequestMethod.GET == getRequestMethod(); }	@return random code	0	1
public String getConnectedServer(AccessToken accessToken, String node) { AgentMgtDao agentMgtDao = new AgentMgtDao(); return agentMgtDao.getConnectedServer(accessToken.getId(), node); }	@return Connected Node	1	0
public View waitForView(View view, int timeout, boolean scroll, boolean checkIsShown){ if(view == null) return null; long endTime = SystemClock.uptimeMillis() + timeout; while (SystemClock.uptimeMillis() < endTime) { sleeper.sleep(); final boolean foundAnyMatchingView = searcher.searchFor(view); if (foundAnyMatchingView){ return view; } if(checkIsShown && view != null && view.isShown()){ return view; } View identicalView = viewFetcher.getIdenticalView(view); if(identicalView != null && !view.equals(identicalView)){ view = identicalView; continue; } if(scroll) scroller.scrollDown(); } return null; }	@return true if view is shown and false if it is not shown before the timeout	0	1
public final SQLRow getSelectedRow() { if (this.isEmpty()) { return null; } else { final IComboSelectionItem o = this.getValue(); final SQLRowAccessor r = o.getRow(); if (r != null) { return r.asRow(); } else { return new SQLRow(this.getForeignTable(), o.getId()); } } }	@return a SQLRow (non fetched) or <code>null</code>.	1	0
public static String export() { RequestLog current = RLOG.get(); record(new Durations(current.aggregateDurations())); record(new Threads(current.threadIds)); return LogFormatterProvider.getInstance().format(current.info); }	@return log object as a JSON formatted string	1	0
private static Gobbling gobble(Treepath<SyntacticTree> gobbleStart, int indentation) { Preconditions.checkArgument(gobbleStart.getTreeAtEnd().isOneOf(_PLACEHOLDER_)); Treepath<SyntacticTree> start = gobbleStart; do { if (TreepathTools.hasNextSibling(start)) { final Treepath<SyntacticTree> next = TreepathTools.getNextSibling(start); if (isRawItem(next)) { final Treepath<SyntacticTree> minusNext = TreepathTools.removeNextSibling(start); return new Gobbling(minusNext, makeEmbeddedListItem(next), indentation); } else { final SyntacticTree nextTree = next.getTreeAtEnd(); if (nextTree.isOneOf(WHITESPACE_, LINE_BREAK_)) { start = TreepathTools.removeNextSibling(start); if (nextTree.isOneOf(WHITESPACE_)) { indentation = getWhitespaceLength(next); } continue; } } } return new Gobbling(start); } while (true); }	@return null if {@code gobbleStart} was null, or a {@code Gobbling} object containing the result of the gobble. {@code Gobbling#treepathMinusGobbled} still refers to the _PLACEHOLDER_ but some separators and one raw item have been removed. {@code Gobbling#gobbledTree} is the result of the gobbling	1	0
Node getAssignedValue() { return (parent.getType() == Token.FUNCTION) ? parent : NodeUtil.getAssignedValue(getNameNode()); }	@return For an assignment or variable declaration return the assigned value, otherwise null.	1	0
"public String toExampleValue(Schema p) { if (ModelUtils.isStringSchema(p)) { if (p.getExample() != null) { return ""\"""" + p.getExample().toString() + ""\""""; } } else if (ModelUtils.isBooleanSchema(p)) { if (p.getExample() != null) { return p.getExample().toString(); } } else if (ModelUtils.isDateSchema(p)) { // TODO } else if (ModelUtils.isDateTimeSchema(p)) { // TODO } else if (ModelUtils.isNumberSchema(p)) { if (p.getExample() != null) { return p.getExample().toString(); } } else if (ModelUtils.isIntegerSchema(p)) { if (p.getExample() != null) { return p.getExample().toString(); } } return null; }"	@return string presentation of the example value of the property	0	1
public OptionalLong lastOffsetTxOrder(String replicaSetName) { Position existing = positionsByReplicaSetName.get(replicaSetName); return existing != null ? existing.getTxOrder() : OptionalLong.empty(); }	@return the tx order of the transaction in progress or 0 in case of non-transactional event	0	1
public Value valueFor(String unescapedTag) { Value value = attributes.get(Tag.from(escapeTag(unescapedTag), false)); return value == null ? Value.NULL_VALUE : value; }	@return the <code>Entry</code> for the given unescaped tag.	1	0
"public boolean next() throws SQLException { if ( ! initialSchemaLoaded ) { throw new IllegalStateException( ""next() called but loadInitialSchema() was not called"" ); } assert afterFirstBatch : ""afterFirstBatch still false in next()""; if ( afterLastRow ) { // We're already after end of rows/records--just report that after end. return false; } else if ( returnTrueForNextCallToNext ) { ++currentRowNumber; // We have a deferred ""not after end"" to report--reset and report that. returnTrueForNextCallToNext = false; return true; } else { accessors.clearLastColumnIndexedInRow(); boolean res = nextRowInternally(); if (res) { ++ currentRowNumber; } return res; } }"	@return whether cursor is positioned at a row (false when after end of results)	0	1
public MediaList getMediaList() { synchronized (this) { if (mMediaList != null) { mMediaList.retain(); return mMediaList; } } final MediaList mediaList = new MediaList(this); synchronized (this) { mMediaList = mediaList; mMediaList.retain(); return mMediaList; } }	@return MediaList, Should NOT be released.	1	0
public EurekaInstanceConfig getEurekaInstanceConfig() { return eurekaInstanceConfig.get(); }	@return the instance of EurekaInstanceConfig this instance was initialized with.	0	1
public static SqlTypeFamily getFamilyForJdbcType(int jdbcType) { return JDBC_TYPE_TO_FAMILY.get(jdbcType); }	@return containing family	0	1
public final DBCompareColExpr in(Collection<?> values) { if (values == null || values.isEmpty()) return cmp(DBCmpType.EQUAL, null); return cmp(DBCmpType.IN, values); }	@return the new DBCompareColExpr object	1	0
protected Object convertUnsignedTinyint(Column column, Field fieldDefn, Object data){ return convertValue(column, fieldDefn, data, (short)0, (r) -> { if (data instanceof Short) { r.deliver(MySqlUnsignedIntegerConverter.convertUnsignedTinyint((short)data)); } else if (data instanceof Number) { r.deliver(MySqlUnsignedIntegerConverter.convertUnsignedTinyint(((Number)data).shortValue())); } else { //We continue with the original converting method (smallint) since we have an unsigned Tinyint r.deliver(convertSmallInt(column, fieldDefn, data)); } }); }	@return the converted value, or null if the conversion could not be made and the column allows nulls	0	1
public Queue createQueue(String queueName) throws JMSException { checkClosed(); if (queueName.startsWith(ActiveMQDestination.TEMP_DESTINATION_NAME_PREFIX)) { return new ActiveMQTempQueue(queueName); } return new ActiveMQQueue(queueName); }	@return a Queue with the given name	0	1
public synchronized List<ColumnIdentifier> getColumns(TableIdentifier tbl) { String schema = getSchemaToUse(tbl.getSchema()); TableIdentifier toSearch = tbl.createCopy(); toSearch.adjustCase(dbConnection); if (toSearch.getSchema() == null) { toSearch.setSchema(schema); } List<ColumnIdentifier> cols = this.objects.get(toSearch); if (cols == null) { try { TableDefinition def = dbConnection.getMetadata().getTableDefinition(toSearch); addTable(def); } catch (SQLException sql) { LogMgr.logWarning(STR, STR, sql); return null; } } if (retrieveOraclePublicSynonyms && toSearch.getSchema() != null && cols == null) { toSearch.setSchema(null); toSearch.setType(null); cols = this.objects.get(toSearch); if (cols == null) { this.getTables(STR); cols = this.objects.get(toSearch); } } if (CollectionUtil.isEmpty(cols)) { TableIdentifier tblToUse = null; if (objects.containsKey(toSearch)) { tblToUse = findEntry(toSearch); } else { tblToUse = this.dbConnection.getMetadata().findObject(toSearch); } try { cols = this.dbConnection.getMetadata().getTableColumns(tblToUse); } catch (Throwable e) { LogMgr.logError(STR, STR + tblToUse, e); cols = null; } if (tblToUse != null && CollectionUtil.isNonEmpty(cols)) { this.objects.put(tblToUse, cols); } } return Collections.unmodifiableList(cols); }	@return a List with {@link workbench.db.ColumnIdentifier} objects	1	0
boolean recordRead(int bufferIndex, Node<K, V> node) { final AtomicLong counter = readBufferWriteCount()[bufferIndex]; final long writeCount = counter.get(); final int index = (int) (writeCount & READ_BUFFER_INDEX_MASK); AtomicReference<Node<K, V>> slot = readBuffers()[bufferIndex][index]; if (slot.get() != null) { return false; } else if (slot.compareAndSet(null, node)) { counter.lazySet(writeCount + NUM); } return true; }	@return the number of writes on the chosen read buffer	1	0
public ImmutableDFA buildDFA() { if (_cachedInstance == null) { if (initialState != null) { _cachedInstance = new ImmutableDFA(); _cachedInstance.transitions = new HashMap<State, Map<Object, State>>(transitions); _cachedInstance.initialState = initialState; } } return _cachedInstance; }	@return an instance of ImmutableDFA; null if the builder haven't got enough data to create a valid ImmutableDFA instance.	1	0
public String createSessionId(final String sessionId, final String memcachedId) { if (memcachedId == null) { return sessionId; } final int idx = sessionId.indexOf(STR); if (idx < NUM) { return sessionId + STR + memcachedId; } else { return sessionId.substring(NUM, idx) + STR + memcachedId + sessionId.substring(idx); } }	@return the sessionId which now contains the memcachedId.	1	0
"private boolean reconcileAndLogDifference(Applications delta, String reconcileHashCode) throws Throwable { logger.warn(""The Reconcile hashcodes do not match, client : {}, server : {}. Getting the full registry"", reconcileHashCode, delta.getAppsHashCode()); long currentGeneration = fetchRegistryGeneration.get(); Applications serverApps = this.fetchRemoteRegistry(false); if (serverApps == null) { logger.error(""The application is null for some reason. Not storing this information""); return false; } if (fetchRegistryGeneration.compareAndSet(currentGeneration, currentGeneration + 1)) { applications.set(serverApps); applicationsDelta.set(serverApps); logger.warn(""The Reconcile hashcodes after complete sync up, client : {}, server : {}."", getApplications().getReconcileHashCode(), delta.getAppsHashCode()); return true; }else { logger.warn(""Not setting the applications map as another thread has advanced the update generation""); return true; // still return true } }"	@return - response	0	1
"public static TimeExtractionFunction createExtractFromGranularity(Granularity granularity) { switch (granularity) { case DAY: return new TimeExtractionFunction(""d"", null, ""UTC"", Locale.getDefault().toLanguageTag()); case MONTH: return new TimeExtractionFunction(""M"", null, ""UTC"", Locale.getDefault().toLanguageTag()); case YEAR: return new TimeExtractionFunction(""yyyy"", null, ""UTC"", Locale.getDefault().toLanguageTag()); case WEEK: return new TimeExtractionFunction(""w"", null, ""UTC"", Locale.getDefault().toLanguageTag()); default: throw new IllegalArgumentException(""Granularity ["" + granularity + ""] is not supported""); } }"	@return the time extraction function or null if granularity is not supported	1	0
"private String buildQuery2(String expression) { // ""values (1 < 5)"" // becomes // ""select p0 < p1 from (values (1, 5)) as t(p0, p1)"" SqlNode x; final String sql = ""values ("" + expression + "")""; try { x = parseQuery(sql); } catch (SqlParseException e) { throw new RuntimeException(e); } final Collection<SqlNode> literalSet = new LinkedHashSet<SqlNode>(); x.accept( new SqlShuttle() { private final List<SqlOperator> ops = ImmutableList.<SqlOperator>of( SqlStdOperatorTable.literalChainOperator, SqlStdOperatorTable.localTimeFunc, SqlStdOperatorTable.localTimestampFunc, SqlStdOperatorTable.currentTimeFunc, SqlStdOperatorTable.currentTimestampFunc); @Override public SqlNode visit(SqlLiteral literal) { if (!isNull(literal) && literal.getTypeName() != SqlTypeName.SYMBOL) { literalSet.add(literal); } return literal; } @Override public SqlNode visit(SqlCall call) { final SqlOperator operator = call.getOperator(); if (operator == SqlStdOperatorTable.castFunc && isNull(call.getOperandList().get(0))) { literalSet.add(call); return call; } else if (ops.contains(operator)) { // ""Argument to function 'LOCALTIME' must be a // literal"" return call; } else { return super.visit(call); } } private boolean isNull(SqlNode sqlNode) { return sqlNode instanceof SqlLiteral && ((SqlLiteral) sqlNode).getTypeName() == SqlTypeName.NULL; } }); final List<SqlNode> nodes = new ArrayList<SqlNode>(literalSet); Collections.sort( nodes, new Comparator<SqlNode>() { public int compare(SqlNode o1, SqlNode o2) { final SqlParserPos pos0 = o1.getParserPosition(); final SqlParserPos pos1 = o2.getParserPosition(); int c = -Utilities.compare( pos0.getLineNum(), pos1.getLineNum()); if (c != 0) { return c; } return -Utilities.compare( pos0.getColumnNum(), pos1.getColumnNum()); } }); String sql2 = sql; final List<Pair<String, String>> values = new ArrayList<Pair<String, String>>(); int p = 0; for (SqlNode literal : nodes) { final SqlParserPos pos = literal.getParserPosition(); final int start = SqlParserUtil.lineColToIndex( sql, pos.getLineNum(), pos.getColumnNum()); final int end = SqlParserUtil.lineColToIndex( sql, pos.getEndLineNum(), pos.getEndColumnNum()) + 1; String param = ""p"" + (p++); values.add(Pair.of(sql2.substring(start, end), param)); sql2 = sql2.substring(0, start) + param + sql2.substring(end); } if (values.isEmpty()) { values.add(Pair.of(""1"", ""p0"")); } return ""select "" + sql2.substring(""values ("".length(), sql2.length() - 1) + "" from (values ("" + Util.commaList(Pair.left(values)) + "")) as t("" + Util.commaList(Pair.right(values)) + "")""; }"	@return Query that evaluates a scalar expression	0	1
"public static Serializable get(ResultSet rs, String identifier, Type type, Dialect dialect) throws SQLException, IdentifierGenerationException { if ( ResultSetIdentifierConsumer.class.isInstance( type ) ) { return ( (ResultSetIdentifierConsumer) type ).consumeIdentifier( rs ); } if ( CustomType.class.isInstance( type ) ) { final CustomType customType = (CustomType) type; if ( ResultSetIdentifierConsumer.class.isInstance( customType.getUserType() ) ) { return ( (ResultSetIdentifierConsumer) customType.getUserType() ).consumeIdentifier( rs ); } } ResultSetMetaData resultSetMetaData = null; int columnCount = 1; try { resultSetMetaData = rs.getMetaData(); columnCount = resultSetMetaData.getColumnCount(); } catch (Exception e) { //Oracle driver will throw NPE } Class clazz = type.getReturnedClass(); if ( columnCount == 1 ) { if ( clazz == Long.class ) { return rs.getLong( 1 ); } else if ( clazz == Integer.class ) { return rs.getInt( 1 ); } else if ( clazz == Short.class ) { return rs.getShort( 1 ); } else if ( clazz == String.class ) { return rs.getString( 1 ); } else if ( clazz == BigInteger.class ) { return rs.getBigDecimal( 1 ).setScale( 0, BigDecimal.ROUND_UNNECESSARY ).toBigInteger(); } else if ( clazz == BigDecimal.class ) { return rs.getBigDecimal( 1 ).setScale( 0, BigDecimal.ROUND_UNNECESSARY ); } else { throw new IdentifierGenerationException( ""unrecognized id type : "" + type.getName() + "" -> "" + clazz.getName() ); } } else { try { return extractIdentifier( rs, identifier, type, clazz ); } catch (SQLException e) { if ( StringHelper.isQuoted( identifier, dialect ) ) { return extractIdentifier( rs, StringHelper.unquote( identifier, dialect ), type, clazz ); } throw e; } } }"	@return The extracted value.	0	1
public ParameterList getQueryStringParams() { try { ParameterList result = new ParameterList(); String queryString = new URL(url).getQuery(); result.addQuerystring(queryString); result.addAll(querystringParams); return result; } catch (MalformedURLException mue) { throw new OAuthException(STR, mue); } }	@return a map containing the query string parameters	1	0
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; // set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { String str = yytext(); int first = str.charAt(0); String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } logger.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: logger.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 67: break; case 2: { return getNext(""<"", yytext()); } case 68: break; case 3: { return getNext(); } case 69: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 70: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 71: break; case 6: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 72: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 73: break; case 8: { return handleQuotes(yytext(), false); } case 74: break; case 9: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 75: break; case 10: { return getNext("">"", yytext()); } case 76: break; case 11: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 77: break; case 12: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 78: break; case 13: { return handleEllipsis(yytext()); } case 79: break; case 14: { return normalizeFractions(yytext()); } case 80: break; case 15: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(); } } case 81: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 82: break; case 17: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 83: break; case 18: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 84: break; case 19: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 85: break; case 20: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 86: break; case 21: { if (normalizeOtherBrackets) { return getNext(""-RSB-"", yytext()); } else { return getNext(); } } case 87: break; case 22: { if (normalizeOtherBrackets) { return getNext(""-LSB-"", yytext()); } else { return getNext(); } } case 88: break; case 23: { if (invertible) { prevWordAfter.append(yytext()); } } case 89: break; case 24: { return getNext(""\u2022"", yytext()); } case 90: break; case 25: { return getNext(""\u2122"", yytext()); } case 91: break; case 26: // general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 92: break; case 27: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(); } case 93: break; case 28: // lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), true); } case 94: break; case 29: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 95: break; case 30: { breakByHyphens(yytext()); return getNext(removeSoftHyphens(yytext()), yytext()); } case 96: break; case 31: // general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 97: break; case 32: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 98: break; case 33: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 99: break; case 34: { // this one should only match if we're basically at the end of file // since the last one matches two things, even newlines (if not tokenize per line) String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 100: break; case 35: // lookahead expression with fixed lookahead length yypushback(1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 101: break; case 36: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 1; { /* invert quote - often but not always right */ return handleQuotes(yytext(), true); } case 102: break; case 37: // lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), false); } case 103: break; case 38: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 104: break; case 39: { String txt = yytext(); // if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space... if (strictTreebank3) { int spaceIndex = indexOfSpace(txt); if (spaceIndex >= 0) { yypushback(txt.length() - spaceIndex); String newText = yytext(); return getNext(newText, newText); } } if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, txt); } case 105: break; case 40: { return getNormalizedAmpNext(); } case 106: break; case 41: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, origTxt); } case 107: break; case 42: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space } return getNext(txt, origTxt); } case 108: break; case 43: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 109: break; case 44: { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 110: break; case 45: // general lookahead, find correct zzMarkedPos { int zzFState = 17; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 111: break; case 46: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 3; { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 112: break; case 47: // general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 113: break; case 48: // general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 22; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 114: break; case 49: // general lookahead, find correct zzMarkedPos { int zzFState = 18; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 19; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 115: break; case 50: // general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 116: break; case 51: // general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 21; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 117: break; case 52: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 118: break; case 53: // lookahead expression with fixed lookahead length yypushback(1); { breakByHyphens(yytext()); return getNext(removeSoftHyphens(yytext()), yytext()); } case 119: break; case 54: { if (splitAssimilations) { yypushback(3) ; return getNext(); } else { return getNext(); } } case 120: break; case 55: // lookahead expression with fixed lookahead length yypushback(1); { return getNormalizedAmpNext(); } case 121: break; case 56: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 9; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 122: break; case 57: // lookahead expression with fixed lookahead length yypushback(2); { return getNext(); } case 123: break; case 58: // general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 124: break; case 59: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 125: break; case 60: // general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 13; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 126: break; case 61: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } return getNext(txt, yytext()); } case 127: break; case 62: // lookahead expression with fixed lookahead length yypushback(4); { return getNext(); } case 128: break; case 63: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 3; { return getNext(); } case 129: break; case 64: { String txt = yytext(); if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 130: break; case 65: // general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 25; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 131: break; case 66: // general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 24; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 132: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }"	@return the next token	0	1
public Date getTimeStamp() { return timeStamp; }	"@return a string of the format ""Thu Oct 18 20:21:13 2001"""	1	0
public static Schema getOutputValueSchema(Configuration conf) { String schemaString = conf.get(CONF_OUTPUT_VALUE_SCHEMA); return schemaString != null ? new Schema.Parser().parse(schemaString) : null; }	@return The job output value schema, or null if not set.	0	1
public DateTime roundHalfCeilingCopy() { DateTime instant = iInstant; return instant.withMillis(iField.roundHalfCeiling(instant.getMillis())); }	@return a copy of the DateTime with the field value changed	0	1
public OuterComposite fakeOuterCompositeSerialize(OuterComposite body) throws RestClientException { return fakeOuterCompositeSerializeWithHttpInfo(body).getBody(); }	@return OuterComposite	0	1
public Sentence caseless() { return new Sentence(this.docFn, impl.build(), Document.CASELESS_PROPS); }	@return This same sentence, but with the default properties swapped out.	1	0
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; // set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { String str = yytext(); int first = str.charAt(0); String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } LOGGER.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: LOGGER.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 37: break; case 2: { if (normalizeOtherBrackets) { return getNext(openparen, yytext()); } else { return getNext(); } } case 38: break; case 3: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 39: break; case 4: { return getNext(); } case 40: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 41: break; case 6: { if (normalizeOtherBrackets) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 42: break; case 7: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 43: break; case 8: { if (invertible) { prevWordAfter.append(yytext()); } } case 44: break; case 9: { return handleEllipsis(yytext()); } case 45: break; case 10: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { String origTxt = yytext(); return getNext(handleDash(origTxt), origTxt); } } case 46: break; case 11: { return normalizeFractions(yytext()); } case 47: break; case 12: { final String origTxt = yytext(); return getNext(handleQuotes(origTxt), origTxt); } case 48: break; case 13: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 49: break; case 14: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 50: break; case 15: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 51: break; case 16: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 52: break; case 17: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 53: break; case 18: { return getNext(""\u2022"", yytext()); } case 54: break; case 19: { return getNext(""\u2122"", yytext()); } case 55: break; case 20: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(); } case 56: break; case 21: { final String origTxt = yytext(); return getNext(origTxt, origTxt, CONTR_ANNOTATION); } case 57: break; case 22: { final String origTxt = yytext(); return getNext(origTxt, origTxt, VB_PRON_ANNOTATION); } case 58: break; case 23: // general lookahead, find correct zzMarkedPos { int zzFState = 1; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 2; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 59: break; case 24: { if (!noSGML) { return getNext(); } } case 60: break; case 25: { final String origTxt = yytext(); return getNext (handleQuotes(origTxt), origTxt); } case 61: break; case 26: { final String origTxt = yytext(); return getNext(handleQuotes(handleDash(origTxt)), origTxt, COMPOUND_ANNOTATION); } case 62: break; case 27: { // this one should only match if we're basically at the end of file // since the last one matches two things, even newlines String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 63: break; case 28: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 64: break; case 29: { final String origTxt = yytext(); return getNext(handleQuotes(handleDash(origTxt)), origTxt); } case 65: break; case 30: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 66: break; case 31: { return getNormalizedAmpNext(); } case 67: break; case 32: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { return getNext(); } case 68: break; case 33: // general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 69: break; case 34: { yypushback(3) ; return getNext(); } case 70: break; case 35: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } return getNext(txt, yytext()); } case 71: break; case 36: { String txt = yytext(); if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 72: break; default: zzScanError(ZZ_NO_MATCH); } } } }"	@return the next token	0	1
public VContextMenu getContextMenu() { if (contextMenu == null) { contextMenu = new VContextMenu(); DOM.setElementProperty(contextMenu.getElement(), STR, STR); } return contextMenu; }	@return IContextMenu object	1	0
public AvroCollector getCollector(String namedOutput, Reporter reporter) throws IOException { return getCollector(namedOutput, null, reporter,namedOutput,null); }	@return the output collector for the given named output	0	1
protected Set<String> populateWhat(Set<String> what) throws Exception { checkOption(what); if (what.contains(WHAT_HELP)) throw new Exception(STR + whatHelp()); if (!what.contains(WHAT_CLIENT) && !what.contains(WHAT_SERVER) && !what.contains(WHAT_BOTH)) { what.add(WHAT_BOTH); what.add(WHAT_CLIENT); what.add(WHAT_SERVER); } else if (what.contains(WHAT_BOTH)) { what.add(WHAT_CLIENT); what.add(WHAT_SERVER); } else if (what.contains(WHAT_CLIENT) && what.contains(WHAT_SERVER)) { what.add(WHAT_BOTH); } Assertion.check((what.contains(WHAT_CLIENT) && !what.contains(WHAT_SERVER) && !what.contains(WHAT_BOTH)) || (!what.contains(WHAT_CLIENT) && what.contains(WHAT_SERVER) && !what.contains(WHAT_BOTH)) || (what.contains(WHAT_CLIENT) && what.contains(WHAT_SERVER) && what.contains(WHAT_BOTH)), STR); if (!what.contains(WHAT_ALL) && !what.contains(WHAT_NONE) && !what.contains(WHAT_INTF) && !what.contains(WHAT_MAIN) && !what.contains(WHAT_IMPL)) { what.add(WHAT_INTF); } if (what.contains(WHAT_ALL)) { what.add(WHAT_INTF); what.add(WHAT_MAIN); what.add(WHAT_IMPL); what.remove(WHAT_ALL); what.remove(WHAT_NONE); } if (what.contains(WHAT_NONE)) { what.remove(WHAT_INTF); what.remove(WHAT_MAIN); what.remove(WHAT_IMPL); what.remove(WHAT_NONE); } return what; }	@return what modified to account for all, both, and none options.	1	0
public static ChatMessageType of(int type) { return CHAT_MESSAGE_TYPES.getOrDefault(type, UNKNOWN); }	@return appropriate message type, or #UNKNOWN	0	1
public static String formatOtherKey(String fullName) { return formatKey(fullName, false, true, false, false); }	@return {@link #formatKey(String, boolean, boolean, boolean)} formatAt = true, formatColon = false, formatHyphen = false, firstCase = false	1	0
protected Object convertBit(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return false; } if (data instanceof Boolean) return data; if (data instanceof Short) return ((Short) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE; if (data instanceof Integer) return ((Integer) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE; if (data instanceof Long) return ((Long) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE; return handleUnknownData(column, fieldDefn, data); }	@return the converted value, or null if the conversion could not be made	1	0
"public int get(DateTimeField field) { for (int i = 0, isize = getFieldSize(); i < isize; i++) { if (getField(i) == field) { return getValue(i); } } throw new IllegalArgumentException(""Field '"" + field + ""' is not supported""); }"	@return the value of that field	0	1
public DurationType getDurationType(Object object, boolean precise) { ReadableTimePeriod period = (ReadableTimePeriod) object; if (precise) { if (period.getDurationType().isPrecise()) { return period.getDurationType(); } else { return DurationType.getPreciseAllType(); } } return period.getDurationType(); }	@return the duration type from the readable duration	0	1
@NonNull public static InstantRunVerifierStatus verifyMethod(MethodNode method) { VerifierMethodVisitor mv = new VerifierMethodVisitor(method); method.accept(mv); return mv.incompatibleChange.or(InstantRunVerifierStatus.COMPATIBLE); }	@return a {@link IncompatibleChange} instance or null if the method is not making any blacklisted calls.	1	0
public AspectRatio inverse() { //noinspection SuspiciousNameCombination return AspectRatio.of(mY, mX); }	@return The inverse of this AspectRatio.	0	1
public Object getResult() { return this.result; }	@return A {@link Presentable} object.	1	0
"public static long toNanoOfDay(Object value, boolean acceptLargeValues) { if (value instanceof Duration) { Duration duration = (Duration) value; if (!acceptLargeValues && (duration.isNegative() || duration.compareTo(ONE_DAY) > 0)) { throw new IllegalArgumentException(""Time values must be between 00:00:00 and 24:00:00 (inclusive): "" + duration); } return ((Duration) value).toNanos(); } // TODO only needed for SQL Server/Oracle, where we don't produce Duration right away; // this should go eventually, as the conversion to LocalTime is superfluous LocalTime time = Conversions.toLocalTime(value); return time.toNanoOfDay(); }"	@return the nanoseconds past midnight	1	0
public BigDecimal fakeOuterNumberSerialize(BigDecimal body) throws ApiException { ApiResponse<BigDecimal> localVarResp = fakeOuterNumberSerializeWithHttpInfo(body); return localVarResp.getData(); }	@return BigDecimal	0	1
Problem findProblem(int line) { int currentTab = getSketch().getCurrentCodeIndex(); return problems.stream() .filter(p -> p.getTabIndex() == currentTab) .filter(p -> { int pStartLine = p.getLineNumber(); int pEndOffset = p.getStopOffset(); int pEndLine = textarea.getLineOfOffset(pEndOffset); return line >= pStartLine && line <= pEndLine; }) .findFirst() .orElse(null); }	@return the Problem for the most relevant error or warning on 'line', defaults to the first error, if there are no errors first warning.	1	0
public AsyncFile getBinary() { return binary; }	@return binary	0	1
static Drawable maybeApplyLeafRounding(@Nullable Drawable drawable, @Nullable RoundingParams roundingParams, Resources resources) { if (drawable == null || roundingParams == null || roundingParams.getRoundingMethod() != RoundingParams.RoundingMethod.BITMAP_ONLY) { return drawable; } if (drawable instanceof ForwardingDrawable) { DrawableParent parent = findDrawableParentForLeaf((ForwardingDrawable) drawable); Drawable child = parent.setDrawable(sEmptyDrawable); child = applyLeafRounding(child, roundingParams, resources); parent.setDrawable(child); return drawable; } else { return applyLeafRounding(drawable, roundingParams, resources); } }	@return the wrapping rounded drawable, or the original drawable if the wrapping didn't take place or it took place on a drawable's child	1	0
private Object readResolve() { if (iChronology == null) { return new LocalDate(iLocalMillis, ISOChronology.getInstanceUTC()); } if (DateTimeZone.UTC.equals(iChronology.getZone()) == false) { return new LocalDate(iLocalMillis, iChronology.withUTC()); } return this; }	@return the resolved object, not null	0	1
public static boolean isTextBasedContentType(String contentType) { return contentType != null && (contentType.startsWith(STR) || contentType.startsWith(STR)); }	@return whether it is text	1	0
public static Builder builder() { return new Builder(); }	@return The newly built Configuration.	1	0
public DateTimeField yearOfCentury() { return UnsupportedDateTimeField.getInstance(DateTimeFieldType.yearOfCentury(), years()); }	@return DateTimeField or UnsupportedDateTimeField if unsupported	0	1
private ColumnDescriptor getColumn(int columnIndex) { Tree tree = viewer.getTree(); TreeColumn column = tree.getColumn(columnIndex); ColumnDescriptor descriptor = (ColumnDescriptor) column.getData(); return descriptor; }	@return The ContextColumn object describing the column.	1	0
public GraphQLSchema build() { return buildImpl(false); }	@return the built schema	0	1
public IBuildConfiguration[] getBuildConfigurations(IProject project, boolean makeCopy) { IBuildConfiguration[] configs = cachedBuildConfigs; if (configs != null && !project.equals(configs[NUM].getProject())) configs = null; if (configs == null) { if (configNames.length == NUM) configs = new IBuildConfiguration[] { new BuildConfiguration(project) }; else { configs = new IBuildConfiguration[configNames.length]; for (int i = NUM; i < configs.length; i++) configs[i] = new BuildConfiguration(project, configNames[i]); } cachedBuildConfigs = configs; } return makeCopy ? (IBuildConfiguration[]) configs.clone() : configs; }	@return the project configurations of an empty array if none exist.	1	0
public String getInputTag() { final TagView inputTagView = getInputTagView(); if (inputTagView != null) { return inputTagView.getText().toString(); } return null; }	@return The INPUT state tag or null if none.	1	0
public synchronized static String hashPassword(long accountId, String password) { try { return sha1Hash(getBytes(STR + accountId + password)); } catch (NoSuchAlgorithmException e) { throw new FxCreateException(STR).asRuntimeException(); } }	@return a hashed version of the passed-in String	1	0
protected ReactGateway createReactGateway() { return new ReactGateway(this, isDebug(), this::createReactNativeHost); }	@return a singleton ReactGateway	0	1
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; // set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { String str = yytext(); int first = str.codePointAt(0); String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } logger.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: logger.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 67: break; case 2: { return getNext(""<"", yytext()); } case 68: break; case 3: { return getNext(); } case 69: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 70: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 71: break; case 6: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 72: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 73: break; case 8: { return handleQuotes(yytext(), false); } case 74: break; case 9: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 75: break; case 10: { return getNext("">"", yytext()); } case 76: break; case 11: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 77: break; case 12: { handleHyphenatedNumber(yytext()); return getNext(removeFromNumber(yytext()), yytext()); } case 78: break; case 13: { return handleEllipsis(yytext()); } case 79: break; case 14: { return normalizeFractions(yytext()); } case 80: break; case 15: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(minimallyNormalizeCurrency(yytext()), yytext()); } } case 81: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 82: break; case 17: { if (normalizeOtherBrackets) { return getNext(""-RSB-"", yytext()); } else { return getNext(); } } case 83: break; case 18: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 84: break; case 19: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 85: break; case 20: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 86: break; case 21: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 87: break; case 22: { if (normalizeOtherBrackets) { return getNext(""-LSB-"", yytext()); } else { return getNext(); } } case 88: break; case 23: { if (invertible) { prevWordAfter.append(yytext()); } } case 89: break; case 24: { return getNext(""\u2022"", yytext()); } case 90: break; case 25: { return getNext(""\u2122"", yytext()); } case 91: break; case 26: // general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 92: break; case 27: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(); } case 93: break; case 28: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return handleQuotes(yytext(), true); } case 94: break; case 29: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 95: break; case 30: { breakByHyphens(yytext()); return getNext(removeSoftHyphens(yytext()), yytext()); } case 96: break; case 31: // general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 97: break; case 32: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 98: break; case 33: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 99: break; case 34: { // this one should only match if we're basically at the end of file // since the last one matches two things, even newlines (if not tokenize per line) String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 100: break; case 35: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 101: break; case 36: // lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 1); { /* invert quote - often but not always right */ return handleQuotes(yytext(), true); } case 102: break; case 37: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return handleQuotes(yytext(), false); } case 103: break; case 38: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 104: break; case 39: { String txt = yytext(); // if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space... if (strictTreebank3) { int spaceIndex = indexOfSpace(txt); if (spaceIndex >= 0) { yypushback(txt.length() - spaceIndex); String newText = yytext(); return getNext(newText, newText); } } if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, txt); } case 105: break; case 40: { return getNormalizedAmpNext(); } case 106: break; case 41: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, origTxt); } case 107: break; case 42: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space } return getNext(txt, origTxt); } case 108: break; case 43: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 109: break; case 44: { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 110: break; case 45: // general lookahead, find correct zzMarkedPos { int zzFState = 17; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 111: break; case 46: // lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 112: break; case 47: // general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 113: break; case 48: // general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 22; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 114: break; case 49: // general lookahead, find correct zzMarkedPos { int zzFState = 18; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 19; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 115: break; case 50: // general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 116: break; case 51: // general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 21; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 117: break; case 52: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 118: break; case 53: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { breakByHyphens(yytext()); return getNext(removeSoftHyphens(yytext()), yytext()); } case 119: break; case 54: { if (splitAssimilations) { yypushback(3) ; return getNext(); } else { return getNext(); } } case 120: break; case 55: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNormalizedAmpNext(); } case 121: break; case 56: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 9; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 122: break; case 57: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { return getNext(); } case 123: break; case 58: // general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 124: break; case 59: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 125: break; case 60: // general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 13; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 126: break; case 61: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } return getNext(txt, yytext()); } case 127: break; case 62: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4); { return getNext(); } case 128: break; case 63: // lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { return getNext(); } case 129: break; case 64: { String txt = yytext(); if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 130: break; case 65: // general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 25; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 131: break; case 66: // general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 24; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 132: break; default: zzScanError(ZZ_NO_MATCH); } } } }"	@return the next token	0	1
"public static String[] decodeArray(String encoded) { if (encoded.isEmpty()) return EMPTY_STRING_ARRAY; char[] chars = encoded.trim().toCharArray(); //--Parse the String // (state) char quoteCloseChar = (char) 0; List<String> terms = new ArrayList<>(); StringBuilder current = new StringBuilder(); //(start/stop overhead) int start = 0; int end = chars.length; if(chars[0] == '('){ start += 1; end -= 1; if(chars[end] != ')') throw new IllegalArgumentException(""Unclosed paren in encoded array: "" + encoded); } if(chars[0] == '['){ start += 1; end -= 1; if(chars[end] != ']') throw new IllegalArgumentException(""Unclosed bracket in encoded array: "" + encoded); } if(chars[0] == '{'){ start += 1; end -= 1; if(chars[end] != '}') throw new IllegalArgumentException(""Unclosed bracket in encoded array: "" + encoded); } // (finite state automaton) for (int i=start; i<end; i++) { if (chars[i] == '\r') { // Ignore funny windows carriage return continue; } else if (quoteCloseChar != 0) { //(case: in quotes) if(chars[i] == quoteCloseChar){ quoteCloseChar = (char) 0; }else{ current.append(chars[i]); } } else if(chars[i] == '\\'){ //(case: escaped character) if(i == chars.length - 1) throw new IllegalArgumentException(""Last character of encoded array is escape character: "" + encoded); current.append(chars[i+1]); i += 1; } else { //(case: normal) if (chars[i] == '""') { quoteCloseChar = '""'; } else if(chars[i] == '\'') { quoteCloseChar = '\''; } else if(chars[i] == ',' || chars[i] == ';' || chars[i] == ' ' || chars[i] == '\t' || chars[i] == '\n') { //break if (current.length() > 0) { terms.add(current.toString().trim()); } current = new StringBuilder(); } else { current.append(chars[i]); } } } //--Return if (current.length() > 0) { terms.add(current.toString().trim()); } return terms.toArray(EMPTY_STRING_ARRAY); }"	@return A String array corresponding to the encoded array	0	1
"public boolean onKeyDown(int keyCode, KeyEvent event) { if (LOG_KEY_EVENTS) { Log.w(TAG, ""onKeyDown "" + keyCode); } if (handleControlKey(keyCode, true)) { return true; } else if (handleFnKey(keyCode, true)) { return true; } else if (isSystemKey(keyCode, event)) { if (! isInterceptedSystemKey(keyCode) ) { // Don't intercept the system keys return super.onKeyDown(keyCode, event); } } // Translate the keyCode into an ASCII character. try { mKeyListener.keyDown(keyCode, event, getKeypadApplicationMode()); } catch (IOException e) { // Ignore I/O exceptions } return true; }"	@return Whether the event was handled.	0	1
@Processor @OAuthProtected @OAuthInvalidateAccessTokenOn(exception = OAuthTokenExpiredException.class) @Paged public PagingDelegate<TaskList> getTaskLists(final PagingConfiguration pagingConfiguration) throws IOException { return new TokenBasedPagingDelegate<TaskList>() { @Override protected List<TaskList> doGetPage() throws IOException { TaskLists list = client.tasklists().list().setMaxResults(new Long(pagingConfiguration.getFetchSize())).setPageToken(this.getPageToken()).execute(); this.setPageToken(list.getNextPageToken()); return TaskList.valueOf(list.getItems(), TaskList.class); } }; }	@return a list with instances of {@link org.mule.module.google.task.model.TaskList}	1	0
public GremlinPipeline<S, Vertex> outV() { return this.add(new OutVertexPipe()); }	@return the extended FluentPipeline	1	0
private Set<Alert> getAlertNodes() { if (!isMultiSelect()) { return extAlert.getAlertPanel().getSelectedAlert(); } return extAlert.getAlertPanel().getSelectedAlerts(); }	@return true if the menu item supports multiple selected alerts, false otherwise.	0	1
protected Object convertReal(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0.0f; } if (data instanceof Float) return data; if (data instanceof Number) { Number value = (Number) data; return new Float(value.floatValue()); } if (data instanceof Boolean) { return ((Boolean) data).booleanValue() ? FLOAT_TRUE : FLOAT_FALSE; } return handleUnknownData(column, fieldDefn, data); }	@return the converted value, or null if the conversion could not be made	1	0
public static Field create(String name, String description) { return new Field(name, description, null, null); }	@return the field; never null	0	1
"public String getCookie() { StringBuilder builder = new StringBuilder(); for (Cookie c : driver.manage().getCookies()) { builder.append(c.toString()); builder.append(""; ""); } return builder.toString(); }"	@return all cookies of the current page under test	0	1
private ZapTextField getTxtProxyChainName() { if (txtProxyChainName == null) { txtProxyChainName = new ZapTextField(); } return txtProxyChainName; }	@return javax.swing.JTextField	1	0
"static public String[] parseSketchSize(String code, boolean fussy) { // This matches against any uses of the size() function, whether numbers // or variables or whatever. This way, no warning is shown if size() isn't // actually used in the applet, which is the case especially for anyone // who is cutting/pasting from the reference. // String scrubbed = scrubComments(sketch.getCode(0).getProgram()); // String[] matches = PApplet.match(scrubbed, SIZE_REGEX); // String[] matches = PApplet.match(scrubComments(code), SIZE_REGEX); // Get everything inside the parens for the size() method String[] contents = PApplet.match(scrubComments(code), SIZE_CONTENTS_REGEX); if (contents != null) { //String[] matches = split on commas, but not commas inside quotes StringList args = breakCommas(contents[1]); String width = args.get(0); String height = args.get(1); String renderer = (args.size() >= 3) ? args.get(2) : null; String path = (args.size() >= 4) ? args.get(3) : null; boolean badSize = false; // Trying to remember why we wanted to allow people to use displayWidth // as the height or displayHeight as the width, but maybe it's for // making a square sketch window? Not going to if (width.equals(""screenWidth"") || width.equals(""screenHeight"") || height.equals(""screenHeight"") || height.equals(""screenWidth"")) { final String message = ""The screenWidth and screenHeight variables\n"" + ""are named displayWidth and displayHeight\n"" + ""in this release of Processing.""; Base.showWarning(""Time for a quick update"", message, null); return null; } if (!width.equals(""displayWidth"") && !width.equals(""displayHeight"") && PApplet.parseInt(width, -1) == -1) { badSize = true; } if (!height.equals(""displayWidth"") && !height.equals(""displayHeight"") && PApplet.parseInt(height, -1) == -1) { badSize = true; } if (badSize && fussy) { // found a reference to size, but it didn't seem to contain numbers final String message = ""The size of this applet could not automatically\n"" + ""be determined from your code. Use only numeric\n"" + ""values (not variables) for the size() command.\n"" + ""See the size() reference for an explanation.""; Base.showWarning(""Could not find sketch size"", message, null); // new Exception().printStackTrace(System.out); return null; } // Remove additional space 'round the renderer if (renderer != null) { renderer = renderer.trim(); if (renderer.length() == 0) { // if empty, set null renderer = null; } } // Same for the file name if (path != null) { path = path.trim(); if (path.length() == 0) { path = null; } } return new String[] { contents[0], width, height, renderer, path }; } // not an error, just no size() specified return new String[] { null, null, null, null, null }; }"	@return null if there was an error, otherwise an array (might contain some/all nulls)	0	1
public static Method findSetMethod(Field field, boolean throwExceptions) throws IllegalArgumentException { Method fieldSetMethod; if (Locale.ENGLISH.equals(Locale.getDefault())) { fieldSetMethod = findMethodFromNames(field, false, throwExceptions, methodFromField(field, STR, null)); } else { fieldSetMethod = findMethodFromNames(field, false, throwExceptions, methodFromField(field, STR, null), methodFromField(field, STR, Locale.ENGLISH)); } if (fieldSetMethod == null) { return null; } if (fieldSetMethod.getReturnType() != void.class) { if (throwExceptions) { throw new IllegalArgumentException(STR + fieldSetMethod.getName() + STR + fieldSetMethod.getReturnType() + STR); } else { return null; } } return fieldSetMethod; }	@return Set method or null if none found.	1	0
public static BooleanTemplate booleanTemplate(Template template, ImmutableList<?> args) { return new BooleanTemplate(template, args); }	@return template expression	0	1
public int getExtraInt(String key) throws JSONException { return mExtraData.getInt(key); }	@return The stored value or null if it doesn't exist in specified form.	1	0
public static String getId(final Widget widget) { String result = (String) widget.getData(CUSTOM_WIDGET_ID); if (result == null) { result = getAdapter(widget).getId(); } return result; }	@return the id	1	0
"private Notification makeNotification() { JSONObject settings = BackgroundMode.getSettings(); Context context = getApplicationContext(); String pkgName = context.getPackageName(); Intent intent = context.getPackageManager() .getLaunchIntentForPackage(pkgName); Notification.Builder notification = new Notification.Builder(context) .setContentTitle(settings.optString(""title"", """")) .setContentText(settings.optString(""text"", """")) .setOngoing(true) .setSmallIcon(getIconResId()); if (intent != null && settings.optBoolean(""resume"")) { PendingIntent contentIntent = PendingIntent.getActivity( context, NOTIFICATION_ID, intent, PendingIntent.FLAG_UPDATE_CURRENT); notification.setContentIntent(contentIntent); } return notification.build(); }"	@return A local ongoing notification which pending intent is bound to the main activity.	0	1
@Restricted(DoNotUse.class) @Deprecated @NonNull public List<? extends Action> getAllActions() { return Collections.emptyList(); }	@return a list of all actions associated with this branch (by default, an unmodifiable list searching {@link TransientActionFactory}s)	1	0
@Processor @OAuthProtected @OAuthInvalidateAccessTokenOn(exception = OAuthTokenExpiredException.class) @Paged public PagingDelegate<Comment> listComments(final String fileId, @Optional @Default(STR) final boolean includeDeleted, @Optional @Default(STR) final int maxResults, @Optional final String updatedMin, final PagingConfiguration pagingConfiguration) throws IOException { return new TokenBasedPagingDelegate<Comment>() { @Override protected List<Comment> doGetPage() throws IOException { CommentList response = client.comments().list(fileId).setIncludeDeleted(includeDeleted).setMaxResults(maxResults).setPageToken(this.getPageToken()).setUpdatedMin(updatedMin).execute(); this.setPageToken(response.getNextPageToken()); return Comment.valueOf(response.getItems(), Comment.class); } }; }	@return a list with instances of {@link org.mule.module.google.drive.model.Comment}	1	0
public ImmutableGraph parse(InputStream serializedGraph, String formatIdentifier) throws UnsupportedFormatException { return parse(serializedGraph, formatIdentifier, null); }	@return the graph read from the stream	1	0
public TreeGraphNode headWordNode() { TreeGraphNode hwn = safeCast(label.get(TreeCoreAnnotations.HeadWordAnnotation.class)); if (hwn == null || (hwn.treeGraph() != null && !(hwn.treeGraph().equals(this.treeGraph())))) { return null; } return hwn; }	@return the node containing the head word for this node	0	1
public static Integer toEpochDay(Object value) { if ( value == null ) return null; return (int)Conversions.toLocalDate(value).toEpochDay(); }	@return the microseconds past midnight	1	0
public int getCommitTime() { return commitTime; }	@return time, expressed as milliseconds since the epoch.	1	0
public CyclicCoreLabel label() { return label; }	@return the label of the node	0	1
"public static String getReconcileHashCode(TreeMap<String, AtomicInteger> instanceCountMap) { String reconcileHashCode = """"; for (Map.Entry<String, AtomicInteger> mapEntry : instanceCountMap .entrySet()) { reconcileHashCode = reconcileHashCode + mapEntry.getKey() + STATUS_DELIMITER + mapEntry.getValue().get() + STATUS_DELIMITER; } return reconcileHashCode; }"	@return the internal hash code representation indicating the information about the instances.	1	0
"public String toDefaultValueWithParam(String name, Property p) { return "" = data."" + name + "";""; }"	@return string presentation of the default value of the property	0	1
public final int querySingleInt(String sqlCmd, Connection conn) { return querySingleInt(sqlCmd, null, NUM, conn); }	@return the result as a int value, if no result the int value 0	1	0
public ResourceTestRule build() { return new ResourceTestRule(buildResource()); }	@return a new {@link ResourceTestRule}	1	0
"protected static String buildMessage(String msg) { StackTraceElement caller = new Throwable().fillInStackTrace().getStackTrace()[2]; return new StringBuilder() .append(caller.getFileName()) .append(""."") .append(caller.getMethodName()) .append(""(): "") .append(msg).toString(); }"	@return Message String	0	1
public long getResponseContentLength() { String contentLengthString = responseHeaders.getFirst(Headers.CONTENT_LENGTH); if (contentLengthString == null) { return -NUM; } return Long.parseLong(contentLengthString); }	@return The content length of the response, or <code>null</code> if it has not been set	1	0
public String fixIdentifierCaseSensitve(String identifier) { try { List<String> databases = listDatabasesWithCache(); for (String database : databases) { if (identifier.equalsIgnoreCase(database)) { return database; } } List<String> tables = listTables(); for (String table : tables) { if (identifier.equalsIgnoreCase(table)) { return table; } } List<String> columns = listColumns(); for (String column : columns) { if (identifier.equalsIgnoreCase(column)) { return column; } } } catch (Exception e) { throw new IllegalStateException(e); } return identifier; }	@return identifier with case sensitive	0	1
"public String getSelectedIndex(String selectLocator) { return (String) seleneseMethods.get(""getSelectedIndex"").apply(driver, selectLocator); }"	@return the selected option index in the specified select drop-down	0	1
@Override public XbinResult token(String token, String callback) { if (StringUtils.isNotBlank(callback)) { return XbinResult.ok(callback); } try { String user = jedisClient.get(USER_SESSION + token); if (StringUtils.isNotBlank(user)) { return XbinResult.ok(user); } } catch (Exception e) { logger.error(STR); } return XbinResult.build(NUM, STR); }	"@return { status: 200 //200 400 token 500 msg: ""OK"" // token. data: {""username"":""xbin""} // }"	1	0
public TwitterTokenStream duplicate() { DuplicatedTokenStream duplicate = new DuplicatedTokenStream(inputStream); duplicatedStreams.add(duplicate); return duplicate; }	@return a duplicated TokenStream	1	0
"public Mono<User> getUserByName(String username) throws RestClientException { Object postBody = null; // verify the required parameter 'username' is set if (username == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, ""Missing the required parameter 'username' when calling getUserByName""); } // create path and map variables final Map<String, Object> pathParams = new HashMap<String, Object>(); pathParams.put(""username"", username); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { ""application/xml"", ""application/json"" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<User> returnType = new ParameterizedTypeReference<User>() {}; return apiClient.invokeAPI(""/user/{username}"", HttpMethod.GET, pathParams, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType); }"	@return User	0	1
private boolean hasSingleValue(ColumnStatistics columnStatistics, long rowCount) { return columnStatistics != null && isSingleVal(columnStatistics, rowCount); }	@return true if column has single value	0	1
public HttpServletRequest getRequest() { return this.request; }	@return the request to use. Cannot be null.	0	1
public static HashMap getXmlRpcWorkflowInstance(WorkflowInstance wInst) { HashMap workflowInstance = new HashMap(); workflowInstance.put(STR, wInst.getCurrentTaskId()); workflowInstance.put(STR, wInst.getStatus()); workflowInstance.put(STR, wInst.getId()); workflowInstance.put(STR, getXmlRpcWorkflow(wInst.getWorkflow())); workflowInstance.put(STR, wInst.getStartDateTimeIsoStr() != null ? wInst.getStartDateTimeIsoStr() : STR); workflowInstance.put(STR, wInst.getEndDateTimeIsoStr() != null ? wInst.getEndDateTimeIsoStr() : STR); workflowInstance.put(STR, wInst.getCurrentTaskStartDateTimeIsoStr() != null ? wInst.getCurrentTaskStartDateTimeIsoStr() : STR); workflowInstance.put(STR, wInst.getCurrentTaskEndDateTimeIsoStr() != null ? wInst.getCurrentTaskEndDateTimeIsoStr() : STR); workflowInstance.put(STR, wInst.getSharedContext() != null ? wInst.getSharedContext().getMap() : new HashMap()); workflowInstance.put(STR, wInst.getPriority() != null ? String.valueOf(wInst.getPriority().getValue()) : String.valueOf(Priority.getDefault().getValue())); return workflowInstance; }	@return A {@link Hashtable} representation of a {@link WorkflowInstance}.	1	0
public ZapTextField getTxtPattern() { if (txtPattern == null) { txtPattern = new ZapTextField(); } return txtPattern; }	@return javax.swing.JTextField	1	0
private Way getWayForNode(Node n) { Way way = null; for (Way w : Main.ds.ways) { int i = w.nodes.indexOf(n); if (i == -NUM) continue; if (i == NUM || i == w.nodes.size() - NUM) { if (way != null) return null; way = w; } } return way; }	@return If the node is part of exactly one way, return this. <code>null</code> otherwise.	1	0
List<String> getTempFiles() { List<String> tempFiles = new ArrayList<String>(); for (Entry<ManagedFile, FilePath> entry : file2Path.entrySet()) { boolean noTargetGiven = StringUtils.isBlank(entry.getKey().targetLocation); if (noTargetGiven) { tempFiles.add(entry.getValue().getRemote()); } } return tempFiles; }	@return a list of temp files	1	0
private SourceRange getResultRange(String identPattern) { int offset = resultCode.indexOf(identPattern); assertThat(offset).describedAs(identPattern + STR + resultCode).isPositive(); String identifier = identPattern.substring(NUM, NOT_IDENTIFIER_MATCHER.indexIn(identPattern)); return new SourceRange(offset, identifier.length()); }	"@return the {@link SourceRange} of ""wordPattern"" in {@link #resultCode}."	1	0
@NonNull protected List<Action> retrieveActions(@NonNull SCMRevision revision, @NonNull SCMHeadEvent event, @NonNull TaskListener listener) throws IOException, InterruptedException { return Collections.emptyList(); }	@return the map of {@link Action} instances to persist, keyed by the class of action. Keys with {@code null} values indicate actions that should be removed if present.	1	0
public ApiResponse<Void> updatePetWithFormWithHttpInfo(Long petId, String name, String status) throws ApiException { okhttp3.Call localVarCall = updatePetWithFormValidateBeforeCall(petId, name, status, null, null); return localVarApiClient.execute(localVarCall); }	@return ApiResponse&lt;Void&gt;	0	1
public static MatchFinder allOf(final MatchFinder... finders) { return new MatchFinder() { @Override public boolean matches(UiElement element) { for (MatchFinder finder : finders) { if (!finder.matches(element)) { return false; } } return true; } @Override public String toString() { return STR + Joiner.on(STR).join(finders) + STR; } }; }	@return a matcher that is the logical conjunction of given matchers	1	0
"public static ApiResponseSet<String> httpMessageToSet(int historyId, int historyType, HttpMessage msg) { Map<String, String> map = new HashMap<>(); map.put(""id"", String.valueOf(historyId)); map.put(""type"", String.valueOf(historyType)); map.put(""timestamp"", String.valueOf(msg.getTimeSentMillis())); map.put(""rtt"", String.valueOf(msg.getTimeElapsedMillis())); map.put(""cookieParams"", msg.getCookieParamsAsString()); map.put(""note"", msg.getNote()); map.put(""requestHeader"", msg.getRequestHeader().toString()); map.put(""requestBody"", msg.getRequestBody().toString()); map.put(""responseHeader"", msg.getResponseHeader().toString()); if (HttpHeader.GZIP.equals(msg.getResponseHeader().getHeader(HttpHeader.CONTENT_ENCODING))) { // Uncompress gziped content try (ByteArrayInputStream bais = new ByteArrayInputStream(msg.getResponseBody().getBytes()); GZIPInputStream gis = new GZIPInputStream(bais); InputStreamReader isr = new InputStreamReader(gis); BufferedReader br = new BufferedReader(isr);) { StringBuilder sb = new StringBuilder(); String line = null; while ((line = br.readLine()) != null) { sb.append(line); } map.put(""responseBody"", sb.toString()); } catch (IOException e) { LOGGER.error(""Unable to uncompress gzip content: "" + e.getMessage(), e); map.put(""responseBody"", msg.getResponseBody().toString()); } } else { map.put(""responseBody"", msg.getResponseBody().toString()); } List<String> tags = Collections.emptyList(); try { tags = HistoryReference.getTags(historyId); } catch (DatabaseException e) { LOGGER.warn(""Failed to obtain the tags for message with ID "" + historyId, e); } return new HttpMessageResponseSet(map, tags); }"	@return the ApiResponseSet with the ID, type and the HTTP message	0	1
private int updateRedundancy() { int numBucketHosts = getNumInitializedBuckets(); if (!isClosed()) { redundancyTracker.updateStatistics(numBucketHosts); } return numBucketHosts; }	@return current number of hosts for this bucket	1	0
public DateTime setCopy(int value) { DateTime instant = iInstant; return (DateTime)instant.withMillis(iField.set(instant.getMillis(), value)); }	@return a copy of the DateTime with the field value changed	0	1
public static <T extends CharSequence> T validIndex(final T chars, final int index, final String message, final Object... values) { Validate.notNull(chars); if (index < NUM || index >= chars.length()) { throw new IndexOutOfBoundsException(String.format(message, values)); } return chars; }	@return the validated collection (never {@code null} for chaining)	1	0
"public static String getProgramFilesPath() { return getEnvVarPath(""ProgramFiles"", ""C:\\Program Files""); }"	@return the path to the Windows Program Files	0	1
@SuppressWarnings(STR) public static Triple<Treebank, Treebank, Treebank> getAnnotatedBinaryTreebankFromTreebank(Treebank trainTreebank, Treebank secondaryTreebank, Treebank tuneTreebank, Options op) { TreebankLangParserParams tlpParams = op.tlpParams; TreebankLanguagePack tlp = tlpParams.treebankLanguagePack(); if (op.testOptions.verbose) { PrintWriter pwErr = tlpParams.pw(System.err); pwErr.print(STR); pwErr.println(trainTreebank.textualSummary(tlp)); if (secondaryTreebank != null) { pwErr.print(STR); pwErr.println(secondaryTreebank.textualSummary(tlp)); } } System.err.print(STR); TreeAnnotatorAndBinarizer binarizer = buildTrainBinarizer(op); CompositeTreeTransformer trainTransformer = buildTrainTransformer(op, binarizer); Treebank wholeTreebank; if (secondaryTreebank == null) { wholeTreebank = trainTreebank; } else { wholeTreebank = new CompositeTreebank(trainTreebank, secondaryTreebank); } if (op.trainOptions.selectiveSplit) { op.trainOptions.splitters = ParentAnnotationStats.getSplitCategories(wholeTreebank, op.trainOptions.tagSelectiveSplit, NUM, op.trainOptions.selectiveSplitCutOff, op.trainOptions.tagSelectiveSplitCutOff, tlp); removeDeleteSplittersFromSplitters(tlp, op); if (op.testOptions.verbose) { List<String> list = new ArrayList<String>(op.trainOptions.splitters); Collections.sort(list); System.err.println(STR + list); } } if (op.trainOptions.selectivePostSplit) { TreeTransformer myTransformer = new TreeAnnotator(tlpParams.headFinder(), tlpParams, op); wholeTreebank = wholeTreebank.transform(myTransformer); op.trainOptions.postSplitters = ParentAnnotationStats.getSplitCategories(wholeTreebank, true, NUM, op.trainOptions.selectivePostSplitCutOff, op.trainOptions.tagSelectivePostSplitCutOff, tlp); if (op.testOptions.verbose) { System.err.println(STR + op.trainOptions.postSplitters); } } if (op.trainOptions.hSelSplit) { int ptt = op.trainOptions.printTreeTransformations; op.trainOptions.printTreeTransformations = NUM; binarizer.setDoSelectiveSplit(false); for (Tree tree : wholeTreebank) { trainTransformer.transformTree(tree); } binarizer.setDoSelectiveSplit(true); op.trainOptions.printTreeTransformations = ptt; } trainTreebank = trainTreebank.transform(trainTransformer); if (secondaryTreebank != null) { secondaryTreebank = secondaryTreebank.transform(trainTransformer); } if (op.trainOptions.printAnnotatedStateCounts) { binarizer.printStateCounts(); } if (op.trainOptions.printAnnotatedRuleCounts) { binarizer.printRuleCounts(); } if (tuneTreebank != null) { tuneTreebank = tuneTreebank.transform(trainTransformer); } Timing.tick(STR); if (op.testOptions.verbose) { binarizer.dumpStats(); } return new Triple<>(trainTreebank, secondaryTreebank, tuneTreebank); }	@return a pair of binaryTrainTreebank,binaryTuneTreebank.	1	0
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 38: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, yytext()); } case 55: break; case 43: // general lookahead, find correct zzMarkedPos { int zzFState = 9; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 10; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { // try to work around an apparent jflex bug where it // gets a space at the token end by getting // wrong the length of the trailing context. while (yylength() > 0) { char last = yycharat(yylength()-1); if (last == ' ' || last == '\t' || (last >= '\n' && last <= '\r' || last == '\u0085')) { yypushback(1); } else { break; } } return getNext(); } case 56: break; case 11: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 57: break; case 19: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 58: break; case 8: { return handleQuotes(yytext(), false); } case 59: break; case 35: // lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), false); } case 60: break; case 27: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 61: break; case 33: // lookahead expression with fixed lookahead length yypushback(1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 62: break; case 49: // lookahead expression with fixed lookahead length yypushback(1); { return getNormalizedAmpNext(); } case 63: break; case 36: { return getNormalizedAmpNext(); } case 64: break; case 23: { if (invertible) { prevWordAfter.append(yytext()); } } case 65: break; case 37: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, yytext()); } case 66: break; case 53: // lookahead expression with fixed lookahead length yypushback(4); { return getNext(); } case 67: break; case 46: // lookahead expression with fixed lookahead length yypushback(2); { return getNext(); } case 68: break; case 42: // general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 69: break; case 41: // general lookahead, find correct zzMarkedPos { int zzFState = 16; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 17; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 70: break; case 40: // general lookahead, find correct zzMarkedPos { int zzFState = 13; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 71: break; case 3: { return getNext(); } case 72: break; case 24: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(); } case 73: break; case 51: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } return getNext(txt, yytext()); } case 74: break; case 26: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, origTxt); } case 75: break; case 6: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 76: break; case 29: // general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 77: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 78: break; case 2: { return getNext(""<"", yytext()); } case 79: break; case 30: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 80: break; case 18: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 81: break; case 54: { String txt = yytext(); if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 82: break; case 50: { yypushback(3) ; return getNext(); } case 83: break; case 25: // lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), true); } case 84: break; case 39: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 85: break; case 21: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 86: break; case 17: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 87: break; case 13: { return handleEllipsis(yytext()); } case 88: break; case 34: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 1; { /* invert quote - often but not always right */ return handleQuotes(yytext(), true); } case 89: break; case 14: { return normalizeFractions(yytext()); } case 90: break; case 15: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(); } } case 91: break; case 47: // general lookahead, find correct zzMarkedPos { int zzFState = 11; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 12; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 92: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 93: break; case 9: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 94: break; case 45: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 95: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 96: break; case 28: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 97: break; case 48: { if (keepAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 98: break; case 20: { if (normalizeOtherBrackets) { return getNext(""-RSB-"", yytext()); } else { return getNext(); } } case 99: break; case 12: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 100: break; case 31: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 101: break; case 10: { return getNext("">"", yytext()); } case 102: break; case 32: { // this one should only match if we're basically at the end of file // since the last one matches two things, even newlines String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 103: break; case 22: { if (normalizeOtherBrackets) { return getNext(""-LSB-"", yytext()); } else { return getNext(); } } case 104: break; case 52: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { // try to work around an apparent jflex bug where it // gets a space at the token end by getting // wrong the length of the trailing context. while (yylength() > 0) { char last = yycharat(yylength()-1); if (last == ' ' || last == '\t' || (last >= '\n' && last <= '\r' || last == '\u0085')) { yypushback(1); } else { break; } } String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 105: break; case 1: { String str = yytext(); int first = str.charAt(0); String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } LOGGER.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: LOGGER.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 106: break; case 44: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 107: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 108: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }"	@return the next token	0	1
private String getHostname(final InetAddress remote) throws FirewallException { FutureTask<String> lookup = new FutureTask<String>(new Callable<String>() { public String call() { return remote.getCanonicalHostName(); } }); DNS_LOOKUP.execute(lookup); try { return lookup.get(DNS_TIMEOUT, TimeUnit.MILLISECONDS); } catch (Exception e) { return null; } finally { lookup.cancel(true); } }	@return the hostname, null if not found or takes longer than 30s to find	1	0
"public static GrammaticalRelation getAcl(String aclString) { /* Check for nmod subtypes which are not stored in the `nmods` map. */ if (aclString.equals(""relcl"")) { return RELATIVE_CLAUSE_MODIFIER; } GrammaticalRelation result = acls.get(aclString); if (result == null) { synchronized(acls) { result = acls.get(aclString); if (result == null) { result = new GrammaticalRelation(Language.UniversalEnglish, ""acl"", ""acl_preposition"", CLAUSAL_MODIFIER, aclString); acls.put(aclString, result); threadSafeAddRelation(result); } } } return result; }"	@return A grammatical relation for this preposition	0	1
public static List<SLARegistrationBean> fromJSONArray(JSONArray array) { List<SLARegistrationBean> list = new ArrayList<SLARegistrationBean>(); for (Object obj : array) { list.add(new SLARegistrationBean((JSONObject) obj)); } return list; }	@return the corresponding SLA event list.	1	0
public FlyoutFragment getTrashFragment() { return mTrashFragment; }	@return The currently attached {@link TrashFragment}.	1	0
public TimeOfDay setCopy(int value) { int[] newValues = iTimeOfDay.getValues(); newValues = getField().set(iTimeOfDay, iFieldIndex, newValues, value); return new TimeOfDay(iTimeOfDay, newValues); }	@return a copy of the TimeOfDay with the field value changed	0	1
static Folder fromXml(Launcher launcher) { return (Folder) LayoutInflater.from(launcher).inflate(R.layout.user_folder, launcher.getDragLayer(), false); }	@return A new UserFolder.	0	1
public BooleanDataValue XMLExists(SqlXmlUtil sqlxUtil) throws StandardException { if (this.isNull()) { return SQLBoolean.unknownTruthValue(); } if (SanityManager.DEBUG) { SanityManager.ASSERT(sqlxUtil != null, STR); } try { return new SQLBoolean(sqlxUtil.evalXQExpression(this)); } catch (Exception xe) { if (xe instanceof StandardException) throw (StandardException) xe; else { throw StandardException.newException(SQLState.LANG_UNEXPECTED_XML_EXCEPTION, xe); } } }	@return True if the received query expression matches at least one node in the received XML value; unknown if either the query expression or the xml value is null; false otherwise.	1	0
"public List<SpiderParser> getParsers(HttpMessage message) { // If parsing of robots.txt is enabled, try to see if it's necessary if (spider.getSpiderParam().isParseRobotsTxt()) { // Get the path of the file String path = null; try { path = message.getRequestHeader().getURI().getPath(); log.debug(""Getting parsers for "" + path); } catch (URIException e) { } // If it's a robots.txt file if (path != null && path.equalsIgnoreCase(""/robots.txt"")) { log.info(""Parsing a robots.txt resource...""); SpiderParser parser = new SpiderRobotstxtParser(spider.getSpiderParam()); parser.addSpiderParserListener(this); List<SpiderParser> robotsParsers = new LinkedList<>(); robotsParsers.add(parser); return robotsParsers; } } // If the response is a HTTP redirect message if (HttpStatusCode.isRedirection(message.getResponseHeader().getStatusCode())) { log.info(""Parsing a HTTP Redirect message...""); SpiderRedirectParser parser = new SpiderRedirectParser(); parser.addSpiderParserListener(this); List<SpiderParser> redirectParsers = new LinkedList<>(); redirectParsers.add(parser); return redirectParsers; } // If it reached this point, it is definitely text if (message.getResponseHeader().isHtml()) { return htmlParsers; } else if (message.getResponseHeader().isXml()) { return xmlParsers; } else { // Parsing non-HTML text resource. return txtParsers; } }"	@return the parser	0	1
public Property centuryOfEra() { return new Property(this, getChronology().centuryOfEra()); }	@return the year of era property	0	1
public static BinaryVisitor<String, Writer> write() { return new Write(); }	@return a {@link BinaryPredicate} that will call {@code write(x)} on the {@link java.io.Writer} {@code y}	1	0
"public Client build(String name) { if ((environment == null) && (executorService == null) && (objectMapper == null)) { throw new IllegalStateException(""Must have either an environment or both "" + ""an executor service and an object mapper""); } if (environment == null) { return build(executorService, objectMapper, name); } return build(environment.getLifecycleEnvironment() .managedExecutorService(""jersey-client-%d"", configuration.getMinThreads(), configuration.getMaxThreads(), 60, TimeUnit.SECONDS), environment.getObjectMapper(), name); }"	@return a fully-configured Client	0	1
public boolean searchToggleButton(String search, int matches) { long now = System.currentTimeMillis(); final long endTime = now + TIMEOUT; while (!searchForToggleButton(search, matches) && now < endTime) { RobotiumUtils.sleep(PAUS); now = System.currentTimeMillis(); } return searchForToggleButton(search, matches); }	@return true if a toggle button with the given text is found a given number of times and false if it is not found	0	1
"protected FieldValueInfo completeField(ExecutionContext executionContext, ExecutionStrategyParameters parameters, Object fetchedValue) { Field field = parameters.getField().get(0); GraphQLObjectType parentType = parameters.getTypeInfo().castType(GraphQLObjectType.class); GraphQLFieldDefinition fieldDef = getFieldDef(executionContext.getGraphQLSchema(), parentType, field); ExecutionTypeInfo fieldTypeInfo = fieldTypeInfo(parameters, fieldDef); Instrumentation instrumentation = executionContext.getInstrumentation(); InstrumentationFieldCompleteParameters instrumentationParams = new InstrumentationFieldCompleteParameters(executionContext, parameters, fieldDef, fieldTypeInfo, fetchedValue); InstrumentationContext<ExecutionResult> ctxCompleteField = instrumentation.beginFieldComplete( instrumentationParams ); GraphqlFieldVisibility fieldVisibility = executionContext.getGraphQLSchema().getFieldVisibility(); Map<String, Object> argumentValues = valuesResolver.getArgumentValues(fieldVisibility, fieldDef.getArguments(), field.getArguments(), executionContext.getVariables()); NonNullableFieldValidator nonNullableFieldValidator = new NonNullableFieldValidator(executionContext, fieldTypeInfo); ExecutionStrategyParameters newParameters = parameters.transform(builder -> builder.typeInfo(fieldTypeInfo) .arguments(argumentValues) .source(fetchedValue) .nonNullFieldValidator(nonNullableFieldValidator) ); log.debug(""'{}' completing field '{}'..."", executionContext.getExecutionId(), fieldTypeInfo.getPath()); FieldValueInfo fieldValueInfo = completeValue(executionContext, newParameters); CompletableFuture<ExecutionResult> executionResultFuture = fieldValueInfo.getFieldValue(); ctxCompleteField.onDispatched(executionResultFuture); executionResultFuture.whenComplete(ctxCompleteField::onCompleted); return fieldValueInfo; }"	@return an ExecutionResult	1	0
public DateTimeFormatterBuilder appendYearOfCentury(int minDigits, int maxDigits) { return appendDecimal(DateTimeFieldType.yearOfCentury(), minDigits, maxDigits); }	@return this DateTimeFormatterBuilder	0	1
public int getStack(int k) { int nStack = getStackSize(); return (k >= NUM && k < nStack) ? stack.get(nStack - NUM - k) : Config.NONEXIST; }	@return Sentence index or {@link CONST#NONEXIST} if stack doesn't have an element at this index	1	0
public boolean equals(Object o) { return this == o || o instanceof CallingConvention && ordinal == ((CallingConvention) o).ordinal; }	@return true if they are equal, false otherwise	0	1
boolean findCellForSpan(int[] cellXY, int spanX, int spanY) { // return the span represented by the CellInfo only there is no view there // (this.cell == null) and there is enough space if (this.cell == null && this.spanX >= spanX && this.spanY >= spanY) { if (cellXY != null) { cellXY[0] = cellX; cellXY[1] = cellY; } return true; } int startX = 0; if (intersectX >= 0) { startX = Math.max(startX, intersectX - (spanX - 1)); } int endX = mCountX - (spanX - 1); if (intersectX >= 0) { endX = Math.min(endX, intersectX + (spanX - 1)); } int startY = 0; if (intersectY >= 0) { startY = Math.max(startY, intersectY - (spanY - 1)); } int endY = mCountY - (spanY - 1); if (intersectY >= 0) { endY = Math.min(endY, intersectY + (spanY - 1)); } for (int x = startX; x < endX + 1; x++) { inner: for (int y = startY; y < endY; y++) { for (int i = 0; i < spanX; i++) { for (int j = 0; j < spanY; j++) { if (mOccupied[x + i][y + j]) { // small optimization: we can skip to below the row we just found // an occupied cell y += j; continue inner; } } } if (cellXY != null) { cellXY[0] = x; cellXY[1] = y; } return true; } } return false; }	@return True if a vacant cell of the specified dimension was found, false otherwise.	0	1
public static Project createAFProject(File file) { return createProject(file, AF); }	@return the created project, or null if file was not writable.	1	0
public static <T> T getObject(Heap heap, JsonValue name, Class<T> type) throws HeapException { if (name.isNull()) { return null; } return getRequiredObject(heap, name, type); }	@return the specified heap object.	1	0
private static String literalValue(RexLiteral literal) { Object value = literal.getValue2(); return String.valueOf(value); }	@return String representation of the literal	0	1
private synchronized static Supplier<Annotator> getOrCreate(AnnotatorFactory factory) { return () -> { Annotator rtn = customAnnotators.get(factory.signature()); if (rtn == null) { // Create the annotator rtn = factory.create(); // Register the annotator customAnnotators.put(factory.signature(), factory.create()); // Clean up memory if needed while (customAnnotators.size() > 10) { customAnnotators.keySet().iterator().remove(); } } return rtn; }; }	@return An annotator as specified by the given name and properties.	1	0
@Deprecated public List<WorkflowCondition> getConditions() { List<WorkflowCondition> allConds = new Vector<WorkflowCondition>(); allConds.addAll(preConditions); allConds.addAll(this.postConditions); return allConds; }	@return the conditions	1	0
public ComponentType introspect(Class<?> implClass) throws ConfigurationLoadException { ComponentType compType = factory.createComponentType(); return introspect(implClass, compType); }	@return ComponentInfo representing the implementation type metadata	1	0
public ArrayList<GridView> getCurrentGridViews() { return getCurrentViews(GridView.class); }	@return a List of the GridViews contained in the current Activity	0	1
"public PeriodType withMonthsRemoved() { return withFieldRemoved(1, ""NoMonths""); }"	@return a new period type that supports the original set of fields except months	0	1
public boolean isInMeleeDistance(WorldPoint other) { return isInMeleeDistance(new WorldArea(other, NUM, NUM)); }	@return Returns true if it is in melee distance	1	0
public static long asLong(byte[] bytes) { return asLong(bytes, 0); }	@return The long	0	1
public Node parseXML(String text, Document doc) { return null; }	@return The document fragment or null on error.	1	0
"protected String fillAliasInSelectClause(StringBuilder sb) { final List<String> aliases = new LinkedList<String>(); final int startPos = shallowIndexOf( sb, SELECT_WITH_SPACE, 0 ); int endPos = shallowIndexOfWord( sb, FROM, startPos ); int nextComa = startPos; int prevComa = startPos; int unique = 0; boolean selectsMultipleColumns = false; while ( nextComa != -1 ) { prevComa = nextComa; nextComa = shallowIndexOf( sb, "","", nextComa ); if ( nextComa > endPos ) { break; } if ( nextComa != -1 ) { String expression = sb.substring( prevComa, nextComa ); if ( selectsMultipleColumns( expression ) ) { selectsMultipleColumns = true; } else { String alias = getAlias( expression ); if ( alias == null ) { // Inserting alias. It is unlikely that we would have to add alias, but just in case. alias = StringHelper.generateAlias( ""page"", unique ); sb.insert( nextComa, "" as "" + alias ); ++unique; nextComa += ( "" as "" + alias ).length(); } aliases.add( alias ); } ++nextComa; } } // Processing last column. endPos = shallowIndexOfWord( sb, FROM, startPos ); // Refreshing end position, because we might have inserted new alias. String expression = sb.substring( prevComa, endPos ); if ( selectsMultipleColumns( expression ) ) { selectsMultipleColumns = true; } else { String alias = getAlias( expression ); if ( alias == null ) { // Inserting alias. It is unlikely that we would have to add alias, but just in case. alias = StringHelper.generateAlias( ""page"", unique ); sb.insert( endPos - 1, "" as "" + alias ); } aliases.add( alias ); } // In case of '*' or '{table}.*' expressions adding an alias breaks SQL syntax, returning '*'. return selectsMultipleColumns ? ""*"" : StringHelper.join( "", "", aliases.iterator() ); }"	@return List of aliases separated with comas.	1	0
protected TheInnerClass newTheInnerClass( ) { return this.injectMembers(new TheInnerClass()); }	@return an instance of the inner class, at runtime the generated subclass (or replacement) of the template inner class	0	1
public AvaticaHandler getHandler(Service service, Driver.Serialization serialization) { return getHandler(service, serialization, NoopMetricsSystemConfiguration.getInstance()); }	@return The Handler.	1	0
"public AsyncSupport newCometSupport(final Class<? extends AsyncSupport> targetClass) { try { return (AsyncSupport) targetClass.getDeclaredConstructor(new Class[]{AtmosphereConfig.class}) .newInstance(config); } catch (final Exception e) { logger.error(""Failed to create AsyncSupportt class: {}, error: {}"", targetClass, e); Throwable cause = e.getCause(); if (cause != null) { logger.error(""Real error: {}, error: {}"", targetClass, cause); } logger.error(""Switching to BlockingIO""); return new BlockingIOCometSupport(config); } }"	@return an instance of the specified class or null if the class cannot be instantiated	0	1
public static RelNode swap(JoinRelBase join, boolean swapOuterJoins) { final JoinRelType joinType = join.getJoinType(); if (!swapOuterJoins && joinType != JoinRelType.INNER) { return null; } final RexBuilder rexBuilder = join.getCluster().getRexBuilder(); final RelDataType leftRowType = join.getLeft().getRowType(); final RelDataType rightRowType = join.getRight().getRowType(); final VariableReplacer variableReplacer = new VariableReplacer(rexBuilder, leftRowType, rightRowType); final RexNode oldCondition = join.getCondition(); RexNode condition = variableReplacer.go(oldCondition); // NOTE jvs 14-Mar-2006: We preserve attribute semiJoinDone after the // swap. This way, we will generate one semijoin for the original // join, and one for the swapped join, and no more. This // doesn't prevent us from seeing any new combinations assuming // that the planner tries the desired order (semijoins after swaps). JoinRelBase newJoin = join.copy(join.getTraitSet(), condition, join.getRight(), join.getLeft(), joinType.swap()); final List<RexNode> exps = RelOptUtil.createSwappedJoinExprs(newJoin, join, true); return CalcRel.createProject( newJoin, exps, join.getRowType().getFieldNames(), true); }	@return swapped join if swapping possible; else null	0	1
public static SlidrInterface attach(final Activity activity, final int statusBarColor1, final int statusBarColor2) { ViewGroup decorView = (ViewGroup) activity.getWindow().getDecorView(); View oldScreen = decorView.getChildAt(NUM); decorView.removeViewAt(NUM); final SliderPanel panel = new SliderPanel(activity, oldScreen); panel.setId(R.id.slidable_panel); panel.addView(oldScreen); decorView.addView(panel, NUM); panel.setOnPanelSlideListener(new SliderPanel.OnPanelSlideListener() { private final ArgbEvaluator mEvaluator = new ArgbEvaluator(); @Override public void onClosed() { activity.finish(); activity.overridePendingTransition(NUM, NUM); } @Override public void onOpened() { } @Override public void onSlideChange(float percent) { if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) { int newColor = (int) mEvaluator.evaluate(percent, statusBarColor1, statusBarColor2); activity.getWindow().setStatusBarColor(newColor); } } }); SlidrInterface slidrInterface = new SlidrInterface() { @Override public void lock() { panel.lock(); } @Override public void unlock() { panel.unlock(); } }; return slidrInterface; }	@return a {@link com.r0adkll.slidableactivity.SlideLockInterface} that allows the user to lock/unlock the sliding mechanism for whatever purpose.	1	0
public Boolean fakeOuterBooleanSerialize(Boolean booleanPostBody) throws ApiException { return fakeOuterBooleanSerializeWithHttpInfo(booleanPostBody).getData(); }	@return Boolean	0	1
"public static List<RelHint> getRelHint(HintStrategyTable hintStrategies, SqlNodeList sqlHints) { if (sqlHints == null || sqlHints.size() == 0) { return ImmutableList.of(); } final ImmutableList.Builder<RelHint> relHints = ImmutableList.builder(); for (SqlNode node : sqlHints) { assert node instanceof SqlHint; final SqlHint sqlHint = (SqlHint) node; final String hintName = sqlHint.getName(); final List<Integer> inheritPath = new ArrayList<>(); RelHint relHint; switch (sqlHint.getOptionFormat()) { case EMPTY: relHint = RelHint.of(inheritPath, hintName); break; case LITERAL_LIST: case ID_LIST: relHint = RelHint.of(inheritPath, hintName, sqlHint.getOptionList()); break; case KV_LIST: relHint = RelHint.of(inheritPath, hintName, sqlHint.getOptionKVPairs()); break; default: throw new AssertionError(""Unexpected hint option format""); } if (hintStrategies.validateHint(relHint)) { // Skips the hint if the validation fails. relHints.add(relHint); } } return relHints.build(); }"	@return the RelHint list	0	1
public Env getApolloEnv() { return EnvUtils.transformEnv(Foundation.server().getEnvType()); }	@return the env	1	0
public boolean hasLoadingCollectionEntries() { return ( collectionLoadContexts != null && !collectionLoadContexts.isEmpty() ); }	@return True if we currently hold state pertaining to loading collections; false otherwise.	0	1
public Integer getMaxLength() { return maxLength; }	@return the maximum length of the string.	1	0
public Double getEnumNumber() { if (enumNumber == null) { return null; } return enumNumber.value(); }	@return enumNumber	0	1
public static ValueAnimator createValueAnimator(Drawable drawable) { if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) { return null; } if (drawable instanceof AnimatedDrawable2) { return AnimatedDrawable2ValueAnimatorHelper.createValueAnimator((AnimatedDrawable2) drawable); } return null; }	@return the animator to use	0	1
public Bundle getActivityLaunchOptions(Launcher launcher, View v) { if (hasControlRemoteAppTransitionPermission()) { try { RemoteAnimationRunnerCompat runner = new LauncherAnimationRunner(mLauncher) { @Override public void onAnimationStart(RemoteAnimationTargetCompat[] targets, Runnable finishedCallback) { // Post at front of queue ignoring sync barriers to make sure it gets // processed before the next frame. postAtFrontOfQueueAsynchronously(v.getHandler(), () -> { mAnimator = new AnimatorSet(); setCurrentAnimator(mAnimator); mAnimator.play(getLauncherAnimators(v)); mAnimator.play(getWindowAnimators(v, targets)); mAnimator.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { // Reset launcher to normal state v.setVisibility(View.VISIBLE); ((ViewGroup) mDragLayer.getParent()).removeView(mFloatingView); mDragLayer.setAlpha(1f); mDragLayer.setTranslationY(0f); View appsView = mLauncher.getAppsView(); appsView.setAlpha(1f); appsView.setTranslationY(0f); finishedCallback.run(); } }); mAnimator.start(); // Because t=0 has the app icon in its original spot, we can skip the // first frame and have the same movement one frame earlier. mAnimator.setCurrentPlayTime(REFRESH_RATE_MS); }); } }; return ActivityOptionsCompat.makeRemoteAnimation( new RemoteAnimationAdapterCompat(runner, 500, 380)).toBundle(); } catch (NoClassDefFoundError e) { // Gracefully fall back to default launch options if the user's platform doesn't // have the latest changes. } } return getDefaultActivityLaunchOptions(launcher, v); }	@return ActivityOptions with remote animations that controls how the window of the opening targets are displayed.	1	0
public static ValueType decode(final char c) { final ValueType v = decodeByInt.get(c); return v == null ? DIRECTED : v; }	@return the decoded ValueType or {@link #X} if the char does not map to a ValueType	1	0
static Stream<Arguments> prepareParameters(final IntBinaryOperator resultCalc) { final List<Arguments> testData = new ArrayList<>(); for (int i = -NUM; i < NUM; i++) { for (int j = -NUM; j < NUM; j++) { testData.add(Arguments.of(new NumberExpression(i), new NumberExpression(j), resultCalc.applyAsInt(i, j))); } } return testData.stream(); }	@return A data set with test entries	1	0
"public static boolean supportsRefCursors(DatabaseMetaData meta) { // Standard JDBC REF_CURSOR support was not added until Java 8, so we need to use reflection to attempt to // access these fields/methods... try { return (Boolean) meta.getClass().getMethod( ""supportsRefCursors"" ).invoke( null ); } catch (NoSuchMethodException e) { log.trace( ""JDBC DatabaseMetaData class does not define supportsRefCursors method..."" ); } catch (Exception e) { log.debug( ""Unexpected error trying to gauge level of JDBC REF_CURSOR support : "" + e.getMessage() ); } return false; }"	@return true if the metadata indicates that the driver defines REF_CURSOR support	0	1
protected Object convertDouble(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0.0d; } if (data instanceof Double) return data; if (data instanceof Number) { Number value = (Number) data; return new Double(value.doubleValue()); } if (data instanceof Boolean) { return ((Boolean) data).booleanValue() ? DOUBLE_TRUE : DOUBLE_FALSE; } return handleUnknownData(column, fieldDefn, data); }	@return the converted value, or null if the conversion could not be made	1	0
"private DbObjectBase findDbEntry(PumpHistoryEntry treatment, List<? extends DbObjectBase> entriesFromHistory) { long proposedTime = DateTimeUtil.toMillisFromATD(treatment.atechDateTime); //proposedTime += (this.pumpTime.timeDifference * 1000); if (doubleBolusDebug) LOG.debug(""DoubleBolusDebug: findDbEntry Treatment={}, FromDb={}"", treatment, gson.toJson(entriesFromHistory)); if (entriesFromHistory.size() == 0) { if (doubleBolusDebug) LOG.debug(""DoubleBolusDebug: findDbEntry Treatment={}, FromDb=null"", treatment); return null; } else if (entriesFromHistory.size() == 1) { if (doubleBolusDebug) LOG.debug(""DoubleBolusDebug: findDbEntry Treatment={}, FromDb={}. Type=SingleEntry"", treatment, entriesFromHistory.get(0)); // TODO: Fix db code // if difference is bigger than 2 minutes we discard entry long maxMillisAllowed = DateTimeUtil.getMillisFromATDWithAddedMinutes(treatment.atechDateTime, 2); if (doubleBolusDebug) LOG.debug(""DoubleBolusDebug: findDbEntry maxMillisAllowed={}, AtechDateTime={} (add 2 minutes). "", maxMillisAllowed, treatment.atechDateTime); if (entriesFromHistory.get(0).getDate() > maxMillisAllowed) { if (doubleBolusDebug) LOG.debug(""DoubleBolusDebug: findDbEntry entry filtered out, returning null. ""); return null; } return entriesFromHistory.get(0); } for (int min = 0; min < 2; min += 1) { for (int sec = 0; sec <= 50; sec += 10) { if (min == 1 && sec == 50) { sec = 59; } int diff = (sec * 1000); List<DbObjectBase> outList = new ArrayList<>(); for (DbObjectBase treatment1 : entriesFromHistory) { if ((treatment1.getDate() > proposedTime - diff) && (treatment1.getDate() < proposedTime + diff)) { outList.add(treatment1); } } if (outList.size() == 1) { if (doubleBolusDebug) LOG.debug(""DoubleBolusDebug: findDbEntry Treatment={}, FromDb={}. Type=EntrySelected, AtTimeMin={}, AtTimeSec={}"", treatment, entriesFromHistory.get(0), min, sec); return outList.get(0); } if (min == 0 && sec == 10 && outList.size() > 1) { if (isLogEnabled()) LOG.error(""Too many entries (with too small diff): (timeDiff=[min={},sec={}],count={},list={})"", min, sec, outList.size(), gson.toJson(outList)); if (doubleBolusDebug) LOG.debug(""DoubleBolusDebug: findDbEntry Error - Too many entries (with too small diff): (timeDiff=[min={},sec={}],count={},list={})"", min, sec, outList.size(), gson.toJson(outList)); } } } return null; }"	@return DbObject from AAPS (if found)	0	1
public ResultSetMetaData getMetaData() throws SQLException { try { debugCodeCall(STR); checkClosed(); ResultInterface result = command.getMetaData(); if (result == null) { return null; } int id = getNextId(TraceObject.RESULT_SET_META_DATA); if (debug()) { debugCodeAssign(STR, TraceObject.RESULT_SET_META_DATA, id); debugCodeCall(STR); } JdbcResultSetMetaData meta = new JdbcResultSetMetaData(null, this, result, session.getTrace(), id); return meta; } catch (Throwable e) { throw logAndConvert(e); } }	@return null as the method is not supported	1	0
public Q addFetchGroup(String fetchGroupName) { fetchGroups.add(fetchGroupName); return queryMixin.getSelf(); }	@return the current object	0	1
@Deprecated public long getNumBytesUploaded() { return totalBytesServerReceived; }	@return the number of bytes uploaded	1	0
"public String toModelName(final String name) { String result = camelize(sanitizeName(name)); if (!StringUtils.isEmpty(modelNamePrefix)) { result = modelNamePrefix + ""_"" + result; } // model name cannot use reserved keyword, e.g. return if (isReservedWord(name)) { String modelName = ""Model_"" + result; LOGGER.warn(name + "" (reserved word) cannot be used as model name. Renamed to "" + modelName); return modelName; } // model name starts with number if (result.matches(""^\\d.*"")) { String modelName = ""Model_"" + result; // e.g. 200Response => Model_200Response (after camelize) LOGGER.warn(name + "" (model name starts with number) cannot be used as model name. Renamed to "" + modelName); return modelName; } if (languageSpecificPrimitives.contains(result)) { String modelName = ""Model_"" + result; LOGGER.warn(name + "" (model name matches existing language type) cannot be used as a model name. Renamed to "" + modelName); return modelName; } if (!StringUtils.isEmpty(modelNameSuffix)) { result = result + ""_"" + modelNameSuffix; } return result; }"	@return capitalized model name	0	1
protected Iterator<JobLocation> getAllScheduledJobs(Transaction tx) throws IOException { return new Iterator<JobLocation>() { final Iterator<Map.Entry<Long, List<JobLocation>>> mapIterator = index.iterator(tx); Iterator<JobLocation> iterator; @Override public boolean hasNext() { while (iterator == null || !iterator.hasNext()) { if (!mapIterator.hasNext()) { break; } iterator = new ArrayList<>(mapIterator.next().getValue()).iterator(); } return iterator != null && iterator.hasNext(); } @Override public JobLocation next() { return iterator.next(); } }; }	@return a list of all referenced Location values for this JobSchedulerImpl	1	0
public static LoopBound calculateWCA(String wcaA) throws BadAnnotationException { int ai = wcaA.indexOf(STR); if (ai != -NUM) { String annotString = wcaA.substring(ai + STR.length()); if (annotString.indexOf(STR) < NUM) return null; Pattern pattern1 = Pattern.compile(STR); Pattern pattern2 = Pattern.compile(STR); Matcher matcher1 = pattern1.matcher(annotString); if (matcher1.matches()) { int ub = Integer.parseInt(matcher1.group(NUM)); int lb = (matcher1.group(NUM).equals(STR)) ? ub : NUM; return new LoopBound(lb, ub); } Matcher matcher2 = pattern2.matcher(annotString); if (matcher2.matches()) { int lb = Integer.parseInt(matcher2.group(NUM)); int ub = Integer.parseInt(matcher2.group(NUM)); return new LoopBound(lb, ub); } throw new BadAnnotationException(STR + annotString); } return null; }	@return the loop bound limit or -1 if no annotation was found or the annotation was erroneous	1	0
"public boolean isWifiConnected(Context context) { if (context != null) { ConnectivityManager mConnectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE); if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) { Network[] networks = mConnectivityManager.getAllNetworks(); for (Network network : networks) { NetworkInfo networkInfo = mConnectivityManager.getNetworkInfo(network); if (networkInfo != null && networkInfo.getType() == ConnectivityManager.TYPE_WIFI) return networkInfo.isAvailable() && networkInfo.isConnected(); } } else { @SuppressWarnings(""deprecation"") NetworkInfo mWiFiNetworkInfo = mConnectivityManager.getNetworkInfo(ConnectivityManager.TYPE_WIFI); return mWiFiNetworkInfo != null && mWiFiNetworkInfo.isAvailable() && mWiFiNetworkInfo.isConnected(); } } return false; }"	@return Open return true, close returns false	0	1
public long getMillis(long value) { return FieldUtils.safeMultiply(value, getUnitMillis()); }	@return the milliseconds that the field represents, which may be negative	0	1
protected SqlStatementLogger sqlStatementLogger() { return sqlStatementLogger; }	@return The underlying JDBC services.	0	1
"protected Configuration doConfigure(InputStream stream, String resourceName) throws HibernateException { try { List errors = new ArrayList(); Document document = xmlHelper.createSAXReader( resourceName, errors, entityResolver ) .read( new InputSource( stream ) ); if ( errors.size() != 0 ) { throw new MappingException( ""invalid configuration"", (Throwable) errors.get( 0 ) ); } doConfigure( document ); } catch (DocumentException e) { throw new HibernateException( ""Could not parse configuration: "" + resourceName, e ); } finally { try { stream.close(); } catch (IOException ioe) { log.warn( ""could not close input stream for: "" + resourceName, ioe ); } } return this; }"	@return A configuration configured via the stream	1	0
private String saveScriptAndForward(String id, String name, String comment, String script, boolean nonAdministerUsing, String originCatalogName, String originId, Parameter[] parameters) throws IOException { script = script == null ? STR : script; if (StringUtils.isEmpty(id)) { throw new IllegalArgumentException(STR); } final String displayName = name == null ? id : name; final String finalFileName = fixFileName(originCatalogName, id); File newScriptFile = new File(getScriptDirectory(), finalFileName); Writer writer = new FileWriter(newScriptFile); writer.write(script); writer.close(); Script newScript = null; if (!StringUtils.isEmpty(originId)) { newScript = new Script(finalFileName, displayName, comment, true, originCatalogName, originId, new SimpleDateFormat(STR).format(new Date()), parameters); } else { newScript = new Script(finalFileName, displayName, comment, nonAdministerUsing, parameters); } ScriptlerConfiguration cfg = getConfiguration(); cfg.addOrReplace(newScript); cfg.save(); return finalFileName; }	@return the final name of the saved script	1	0
public boolean isNullGenerating(int factIdx) { return joinTypes.get(factIdx).isOuterJoin(); }	@return whether or not the factor corresponds to a null-generating factor in a left or right outer join	0	1
public JSONArray getExtraJSONArray(String key) throws JSONException { return mExtraData.getJSONArray(key); }	@return The stored value or null if it doesn't exist in specified form.	1	0
public static InternetObservingSettings create() { return new Builder().build(); }	@return settings with default parameters	0	1
private static String getValue(RDFTerm resource) { if (resource instanceof IRI) { return ((IRI) resource).getUnicodeString(); } else if (resource instanceof Literal) { return ((Literal) resource).getLexicalForm(); } else { return resource.toString(); } }	@return returns the unicode string of an UriRef or the lexical form of a Literal or the return value of a toString() on a BNode	1	0
public Order placeOrder(Order body) throws ApiException { Call call = placeOrderCall(body); Type returnType = new TypeToken<Order>(){}.getType(); return apiClient.execute(call, returnType); }	@return Order	0	1
public int getRotation() { Double angle = new Integer(currentRotation).doubleValue() / new Integer(Settings.getHandlerRotation()).doubleValue(); angle *= NUM; return angle.intValue(); }	@return Value between 0 and 2000	1	0
public boolean isAggregator() { return false; }	@return whether this operator is an aggregator	0	1
protected int getVersion() { return VCardConfig.VERSION_21; }	@return {@link VCardConfig#FLAG_V21}	1	0
public String toString() { return ISOPeriodFormat.getInstance().standard().print(toPeriod()); }	@return the value as an ISO8601 string	0	1
static public boolean isCompatible(Base base, StringDict props) { String currentIdentifier = base.getActiveEditor().getMode().getIdentifier(); StringList compatibleList = parseModeList(props); if (compatibleList.size() == 0) { return true; // if no mode specified, assume compatible everywhere } for (String c : compatibleList) { if (c.equals(currentIdentifier)) { return true; } } return false; }	@return true if compatible with the Mode of the currently active editor	1	0
@Deprecated public List<String> readScopes() { return SENTINEL_EMPTY_SCOPES; }	@return the allowed read scopes	1	0
public List<TaggedWord> apply(List<? extends HasWord> in) { TestSentence testSentence = new TestSentence(this); return testSentence.tagSentence(in, false); }	@return A Sentence of TaggedWord	0	1
public static AbstractSchema getTemporaryWorkspace(SchemaPlus defaultSchema, DrillConfig config) { String temporarySchema = config.getString(ExecConstants.DEFAULT_TEMPORARY_WORKSPACE); List<String> temporarySchemaPath = Lists.newArrayList(temporarySchema); SchemaPlus schema = findSchema(defaultSchema, temporarySchemaPath); return schema == null ? null : unwrapAsDrillSchemaInstance(schema); }	@return default temporary workspace	1	0
public AccessType getAccessType() { if (isPublic()) { return AccessType.ACC_PUBLIC; } if (isPrivate()) { return AccessType.ACC_PRIVATE; } if (isProtected()) { return AccessType.ACC_PROTECTED; } return AccessType.ACC_PACKAGE; }	@return one of {@link #ACC_PRIVATE}, {@link #ACC_PROTECTED}, {@link #ACC_PACKAGE} or {@link #ACC_PUBLIC}.	1	0
public List<HostAuthentication> getListAuth() { return listAuth; }	@return Returns the listAuth.	0	1
public DirectRowSet rowSet() throws RpcException { // Ignore all but the first non-empty batch. QueryDataBatch dataBatch = null; for (QueryDataBatch batch : results()) { if (dataBatch == null && batch.getHeader().getRowCount() != 0) { dataBatch = batch; } else { batch.release(); } } // No results? if (dataBatch == null) { return null; } // Unload the batch and convert to a row set. final RecordBatchLoader loader = new RecordBatchLoader(client.allocator()); try { loader.load(dataBatch.getHeader().getDef(), dataBatch.getData()); dataBatch.release(); VectorContainer container = loader.getContainer(); container.setRecordCount(loader.getRecordCount()); return DirectRowSet.fromContainer(container); } catch (SchemaChangeException e) { throw new IllegalStateException(e); } }	@return a row set that represents the first batch returned from the query	0	1
protected Object convertDouble(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0.0d; } if (data instanceof Double) return data; if (data instanceof Number) { // Includes BigDecimal and other numeric values ... Number value = (Number) data; return Double.valueOf(value.doubleValue()); } if (data instanceof SpecialValueDecimal) { return ((SpecialValueDecimal)data).toDouble(); } if (data instanceof Boolean) { return NumberConversions.getDouble((Boolean) data); } return handleUnknownData(column, fieldDefn, data); }	@return the converted value, or null if the conversion could not be made and the column allows nulls	0	1
public Domain getDom() throws ErrorException { throw new ErrorException(STR); }	@return VirDomain object	1	0
public String getSource() { int pos = source.lastIndexOf(STR); if (pos != -NUM) { return source.substring(pos + NUM); } else { return source; } }	@return the source.	1	0
public Property weekyear() { return new Property(this, getChronology().weekyear()); }	@return the year of a week based year property	0	1
"private static File findBinary(String... binaryNames) { final String[] paths = System.getenv(""PATH"").split(File.pathSeparator); for (String binaryName : binaryNames) { for (String path : paths) { File file = new File(path, binaryName); if (file.exists()) { return file; } if (Platform.getCurrent().is(Platform.WINDOWS)) { File exe = new File(path, binaryName + "".exe""); if (exe.exists()) { return exe; } } } } return null; }"	@return the first binary found matching that name.	0	1
@Action(value = STR) public String execute() throws Exception { if (statusMessage == null || statusMessage.trim().length() == NUM) { request.setAttribute(STR, STR); return STR; } SASFHelper helper = SASFStaticHelper.getHelper(request); SocialAuthManager manager = helper.getAuthManager(); AuthProvider provider = null; if (manager != null) { provider = manager.getCurrentAuthProvider(); } if (provider != null) { try { provider.updateStatus(statusMessage); request.setAttribute(STR, STR); return STR; } catch (SocialAuthException e) { request.setAttribute(STR, e.getMessage()); e.printStackTrace(); } } return STR; }	@return ActionForward where the action should flow	1	0
public boolean add(Tag tag) { return isCategoryValid(tag.getCategory()) && mSelectedTopics.add(tag); }	@return boolean Returns a boolean to indicate whether the operation was successful.	1	0
public RelNode decorrelate(SqlNode query, RelNode rootRel) { if (!enableDecorrelation()) { return rootRel; } final RelNode result = decorrelateQuery(rootRel); if (result != rootRel) { checkConvertedType(query, result); } return result; }	@return New root relational expression after decorrelation	0	1
"public boolean getBoolean(String name, boolean defaultValue) { String value = getString(name); return (value != null) && (value.equals(""1"") || value.toLowerCase().equals(""true"")); }"	@return the value, or defaultValue if the attribute does not exist.	0	1
public boolean searchButton(String text, int minimumNumberOfMatches, boolean onlyVisible) { return searcher.searchWithTimeoutFor(Button.class, text, minimumNumberOfMatches, true, onlyVisible); }	@return true if a Button with the given text is found a given number of times and false if it is not found	0	1
public boolean dependsOn(Collection<AddOn> addOns) { if (dependencies == null || dependencies.getAddOns().isEmpty()) { return false; } for (AddOn addOn : addOns) { if (dependsOn(addOn)) { return true; } } return false; }	@return {@code true} if it depends on the given add-on, {@code false} otherwise.	1	0
public static GrammaticalRelation valueOf(Object o) { if (o instanceof GrammaticalRelation) { return (GrammaticalRelation) o; } else if (o instanceof String) { return valueOf((String) o); } else { return null; } }	@return The EnglishGrammaticalRelation with that name	0	1
public static Builder create() { return new Builder() { private Properties props = new Properties(); @Override public Builder with(String key, String value) { props.setProperty(key, value); return this; } @Override public Builder withDefault(String key, String value) { if (!props.containsKey(key)) { props.setProperty(key, value); } return this; } @Override public Builder apply(Consumer<Builder> function) { function.accept(this); return this; } @Override public JdbcConfiguration build() { return JdbcConfiguration.adapt(Configuration.from(props)); } @Override public String toString() { return props.toString(); } }; }	@return the configuration builder	0	1
public String getAuthorizationUrl(Map<String, String> additionalParams) { return createAuthorizationUrlBuilder() .additionalParams(additionalParams) .build(); }	@return url	1	0
public RedeliveryPolicy getRedeliveryPolicy() throws JMSException { return redeliveryPolicyMap.getDefaultEntry(); }	@return Returns the RedeliveryPolicy.	0	1
"protected Object defaultValue(Field field) throws IOException { JsonNode defaultJsonValue = field.defaultValue(); if (defaultJsonValue == null) { throw new AvroRuntimeException(""Field "" + field + "" not set and has no default value""); } if (defaultJsonValue.isNull() && (field.schema().getType() == Type.NULL || (field.schema().getType() == Type.UNION && field.schema().getTypes().get(0).getType() == Type.NULL))) { return null; } // Get the default value Object defaultValue = null; // First try to get the default value from cache: ConcurrentMap<Integer, Object> defaultSchemaValues = DEFAULT_VALUE_CACHE.get(schema.getFullName()); if (defaultSchemaValues == null) { DEFAULT_VALUE_CACHE.putIfAbsent(schema.getFullName(), new ConcurrentHashMap<Integer, Object>(fields.length)); defaultSchemaValues = DEFAULT_VALUE_CACHE.get(schema.getFullName()); } defaultValue = defaultSchemaValues.get(field.pos()); // If not cached, get the default Java value by encoding the default JSON // value and then decoding it: if (defaultValue == null) { ByteArrayOutputStream baos = new ByteArrayOutputStream(); encoder = EncoderFactory.get().binaryEncoder(baos, encoder); ResolvingGrammarGenerator.encode( encoder, field.schema(), defaultJsonValue); encoder.flush(); decoder = DecoderFactory.get().binaryDecoder( baos.toByteArray(), decoder); defaultValue = data.createDatumReader( field.schema()).read(null, decoder); defaultSchemaValues.putIfAbsent(field.pos(), defaultValue); } // Make a deep copy of the default value so that subsequent mutations // will not affect the default value cache: return data.deepCopy(field.schema(), defaultValue); }"	@return the default value associated with the given field, or null if none is specified in the schema.	0	1
public final Entity getEntity() { return entity; }	@return The entity as an input stream.	1	0
"public int yylex() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; // set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { if (DBG) System.err.printf(""Accepting |%s|%n"", yytext()); return ACCEPT; } case 4: break; case 2: { return IGNORE; } case 5: break; case 3: { if (DBG) System.err.printf(""Ignoring |%s|%n"", yytext()); return IGNORE; } case 6: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; return YYEOF; } else { zzScanError(ZZ_NO_MATCH); } } } }"	@return the next token	0	1
"public SessionFactory buildSessionFactory() throws HibernateException { log.debug( ""Preparing to build session factory with filters : "" + filterDefinitions ); secondPassCompile(); if ( ! metadataSourceQueue.isEmpty() ) { log.warn( ""mapping metadata cache was not completely processed"" ); } enableLegacyHibernateValidator(); enableBeanValidation(); enableHibernateSearch(); validate(); Environment.verifyProperties( properties ); Properties copy = new Properties(); copy.putAll( properties ); ConfigurationHelper.resolvePlaceHolders( copy ); Settings settings = buildSettings( copy ); return new SessionFactoryImpl( this, mapping, settings, getInitializedEventListeners(), sessionFactoryObserver ); }"	@return The build SessionFactory	0	1
public Remote getPort(QName portName, Class proxyInterface) throws ServiceException { Remote stub = getGeneratedStub(portName, proxyInterface); return stub != null ? stub : getPort(null, portName, proxyInterface); }	@return java.rmi.Remote ...	1	0
public boolean clearReference() { return sScheduler.clearReference(this); }	@return true if the handler wants to stay alive.	0	1
protected Object convertNumeric(Column column, Field fieldDefn, Object data) { return convertDecimal(column, fieldDefn, data); }	@return the converted value, or null if the conversion could not be made and the column allows nulls	0	1
"public String toVarName(String name) { if (reservedWords.contains(name)) { return escapeReservedWord(name); } else if (((CharSequence) name).chars().anyMatch(character -> specialCharReplacements.keySet().contains( """" + ((char) character)))) { return escapeSpecialCharacters(name, null, null); } else { return name; } }"	@return the sanitized variable name	0	1
public List<MediaType> selectHeaderAccept(String[] accepts) { if (accepts.length == 0) { return null; } for (String accept : accepts) { MediaType mediaType = MediaType.parseMediaType(accept); if (isJsonMime(mediaType)) { return Collections.singletonList(mediaType); } } return MediaType.parseMediaTypes(StringUtils.arrayToCommaDelimitedString(accepts)); }	@return List The list of MediaTypes to use for the Accept header	0	1
public static String asJson(Object object) throws IOException { return JSON.writeValueAsString(object); }	@return {@code object} as a JSON AST node	1	0
public Set<TSentryRole> getTSentryRolesByGroupName(final Set<String> groupNames, final boolean checkAllGroups) throws Exception { if (groupNames.isEmpty()) { return Collections.emptySet(); } return tm.executeTransaction(new TransactionBlock<Set<TSentryRole>>() { @Override public Set<TSentryRole> execute(PersistenceManager pm) throws Exception { pm.setDetachAllOnCommit(false); Set<String> roleNames = new HashSet<>(NUM); Set<TSentryRole> result = new HashSet<>(NUM); for (String group : groupNames) { if (group == null) { List<MSentryRole> roles = getAllRoles(pm); for (MSentryRole role : roles) { result.add(convertToTSentryRole(role)); } return result; } String trimmedGroup = group.trim(); Query query = pm.newQuery(MSentryGroup.class); query.setFilter(STR); query.setUnique(true); MSentryGroup mGroup = (MSentryGroup) query.execute(trimmedGroup); if (mGroup != null) { for (MSentryRole role : mGroup.getRoles()) { String roleName = role.getRoleName(); if (roleNames.add(roleName)) { result.add(convertToTSentryRole(role)); } } } else if (!checkAllGroups) { throw noSuchGroup(trimmedGroup); } query.closeAll(); } return result; } }); }	@return : Set of thrift sentry role objects	1	0
public ServiceReference getServiceReference() { return m_ps.getServiceReference(); }	@return the service reference (null if the service is unregistred).	1	0
public ConciseSet evaluate(TupleFilter filter) { if (filter == null) return null; if (filter instanceof LogicalTupleFilter) return evalLogical((LogicalTupleFilter) filter); if (filter instanceof CompareTupleFilter) return evalCompare((CompareTupleFilter) filter); if (filter instanceof ConstantTupleFilter) { if (!filter.evaluate(null, null)) { return new ConciseSet(); } } return null; // unable to evaluate }	@return a set of records that match the filter; or null if filter is null or unable to evaluate	0	1
static public IStructuredTextExpert getExpert(String type, StructuredTextEnvironment environment) { IStructuredTextExpert expert; if (environment == null) environment = StructuredTextEnvironment.DEFAULT; synchronized (sharedExperts) { Map experts = (Map) sharedExperts.get(type); if (experts == null) { experts = new HashMap(); sharedExperts.put(type, experts); } expert = (IStructuredTextExpert) experts.get(environment); if (expert == null) { StructuredTextTypeHandler handler = StructuredTextTypeHandlerFactory.getHandler(type); if (handler == null) throw new IllegalArgumentException(STR); expert = new StructuredTextImpl(handler, environment, false); experts.put(type, expert); } } return expert; }	@return the ISTextExpert instance.	1	0
public static MerkleTreeLeaf parseMerkleTreeLeaf(InputStream in) { int version = (int) readNumber(in, CTConstants.VERSION_LENGTH); if (version != Ct.Version.V1.getNumber()) { throw new SerializationException(String.format(STR, version)); } int leafType = (int) readNumber(in, NUM); if (leafType != Ct.MerkleLeafType.TIMESTAMPED_ENTRY_VALUE) { throw new SerializationException(String.format(STR, leafType)); } return new MerkleTreeLeaf(Ct.Version.valueOf(version), Ct.MerkleLeafType.valueOf(leafType), parseTimestampedEntry(in)); }	@return Built {@link Ct.MerkleTreeLeaf}.	1	0
public Actions release(WebElement target) { if (isBuildingActions()) { action.addAction(new ButtonReleaseAction(jsonMouse, (Locatable) target)); } return moveInTicks(target, 0, 0).tick(defaultMouse.createPointerUp(LEFT.asArg())); }	@return A self reference.	0	1
public IncidentsTask createReportsTask() { return new IncidentsTask(url); }	@return The report task	1	0
public T setMinDecodeIntervalMs(int intervalMs) { mMinDecodeIntervalMs = intervalMs; return getThis(); }	@return this builder	0	1
public T caseCustomersType(CustomersType object) { return null; }	@return the result of interpretting the object as an instance of '<em>sType</em>'.	1	0
public long getId() { return id; }	@return integer id	0	1
public DateTimeFormatterBuilder appendTimeZoneShortName() { return append0(new TimeZonePrinter(true), null); }	@return this DateTimeFormatterBuilder	0	1
public static boolean isBlank(String... originalStrArray) { if (null == originalStrArray || NUM == originalStrArray.length) return true; for (int i = NUM; i < originalStrArray.length; i++) { if (isBlank(originalStrArray[i])) return true; } return false; }	@return true or false;	1	0
"public boolean searchForText(String regex, int matches, boolean scroll) { sleeper.sleep(); inst.waitForIdleSync(); Pattern p = Pattern.compile(regex); Matcher matcher; ArrayList<TextView> textViewList = viewFetcher.getCurrentViews(TextView.class); if(matches == 0) matches = 1; for(TextView textView : textViewList){ matcher = p.matcher(textView.getText().toString()); if(matcher.find()){ countMatches++; } if (countMatches == matches) { countMatches=0; return true; } } if (scroll && scroller.scroll(Scroller.Direction.DOWN)) { return searchForText(regex, matches, scroll); } else { if (countMatches > 0) Log.d(LOG_TAG, "" There are only "" + countMatches + "" matches of "" + regex); countMatches=0; return false; } }"	@return true if search string is found a given number of times and false if the search string is not found	1	0
public boolean equals(Object obj) { if (this == obj) { return true; } if (obj instanceof PeriodType == false) { return false; } PeriodType other = (PeriodType) obj; return (Arrays.equals(iTypes, other.iTypes)); }	@return true if equal	0	1
public static SummaryEntry[] querySummaries(Variations variationPatterns, String scenarioPattern) { return getDefault().internalQuerySummaries(variationPatterns, scenarioPattern); }	@return array of SummaryEntries	1	0
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; // set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { String str = yytext(); int first = str.codePointAt(0); String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } logger.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: logger.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 67: break; case 2: { return getNext(""<"", yytext()); } case 68: break; case 3: { return getNext(); } case 69: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 70: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 71: break; case 6: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 72: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 73: break; case 8: { return handleQuotes(yytext(), false); } case 74: break; case 9: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 75: break; case 10: { return getNext("">"", yytext()); } case 76: break; case 11: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 77: break; case 12: { handleHyphenatedNumber(yytext()); return getNext(removeFromNumber(yytext()), yytext()); } case 78: break; case 13: { return handleEllipsis(yytext()); } case 79: break; case 14: { return normalizeFractions(yytext()); } case 80: break; case 15: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(minimallyNormalizeCurrency(yytext()), yytext()); } } case 81: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 82: break; case 17: { if (normalizeOtherBrackets) { return getNext(""-RSB-"", yytext()); } else { return getNext(); } } case 83: break; case 18: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 84: break; case 19: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 85: break; case 20: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 86: break; case 21: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 87: break; case 22: { if (normalizeOtherBrackets) { return getNext(""-LSB-"", yytext()); } else { return getNext(); } } case 88: break; case 23: { if (invertible) { prevWordAfter.append(yytext()); } } case 89: break; case 24: { return getNext(""\u2022"", yytext()); } case 90: break; case 25: { return getNext(""\u2122"", yytext()); } case 91: break; case 26: // general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 92: break; case 27: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(); } case 93: break; case 28: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return handleQuotes(yytext(), true); } case 94: break; case 29: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 95: break; case 30: { breakByHyphens(yytext()); return getNext(removeSoftHyphens(yytext()), yytext()); } case 96: break; case 31: // general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 97: break; case 32: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 98: break; case 33: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 99: break; case 34: { // this one should only match if we're basically at the end of file // since the last one matches two things, even newlines (if not tokenize per line) String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 100: break; case 35: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 101: break; case 36: // lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 1); { /* invert quote - often but not always right */ return handleQuotes(yytext(), true); } case 102: break; case 37: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return handleQuotes(yytext(), false); } case 103: break; case 38: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 104: break; case 39: { String txt = yytext(); // if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space... if (strictTreebank3) { int spaceIndex = indexOfSpace(txt); if (spaceIndex >= 0) { yypushback(txt.length() - spaceIndex); String newText = yytext(); return getNext(newText, newText); } } if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, txt); } case 105: break; case 40: { return getNormalizedAmpNext(); } case 106: break; case 41: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, origTxt); } case 107: break; case 42: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space } return getNext(txt, origTxt); } case 108: break; case 43: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 109: break; case 44: { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 110: break; case 45: // general lookahead, find correct zzMarkedPos { int zzFState = 17; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 111: break; case 46: // lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 112: break; case 47: // general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 113: break; case 48: // general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 22; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 114: break; case 49: // general lookahead, find correct zzMarkedPos { int zzFState = 18; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 19; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 115: break; case 50: // general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 116: break; case 51: // general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 21; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 117: break; case 52: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 118: break; case 53: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { breakByHyphens(yytext()); return getNext(removeSoftHyphens(yytext()), yytext()); } case 119: break; case 54: { if (splitAssimilations) { yypushback(3) ; return getNext(); } else { return getNext(); } } case 120: break; case 55: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNormalizedAmpNext(); } case 121: break; case 56: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 9; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 122: break; case 57: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { return getNext(); } case 123: break; case 58: // general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 124: break; case 59: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 125: break; case 60: // general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 13; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 126: break; case 61: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } return getNext(txt, yytext()); } case 127: break; case 62: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4); { return getNext(); } case 128: break; case 63: // lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { return getNext(); } case 129: break; case 64: { String txt = yytext(); if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 130: break; case 65: // general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 25; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 131: break; case 66: // general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 24; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 132: break; default: zzScanError(ZZ_NO_MATCH); } } } }"	@return the next token	0	1
@Override public Refactoring getParent() { return this.parent; }	@return EmfRefactoring supported by the controller.	1	0
public <V extends Visitor<? super X>> V visit(V visitor) { for (X x : this) { visitor.visit(x); } return visitor; }	@return {@code predicate}	1	0
"public Object convert(Column column, String value) { if (value == null) { return value; } // boolean is also TINYINT(1) if (""TINYINT"".equals(column.typeName())) { if (""true"".equalsIgnoreCase(value) || ""false"".equalsIgnoreCase(value)) { return convertToBoolean(value); } } switch (column.jdbcType()) { case Types.DATE: return convertToLocalDate(column, value); case Types.TIMESTAMP: return convertToLocalDateTime(column, value); case Types.TIMESTAMP_WITH_TIMEZONE: return convertToTimestamp(column, value); case Types.TIME: return convertToDuration(column, value); case Types.BOOLEAN: return convertToBoolean(value); case Types.BIT: return convertToBits(column, value); case Types.NUMERIC: case Types.DECIMAL: return convertToDecimal(column, value); case Types.FLOAT: case Types.DOUBLE: case Types.REAL: return convertToDouble(value); } return value; }"	@return value converted to a Java type	0	1
private String prepareQueryString(String groupPath, String jobName, Properties options) { List<NameValuePair> parameters = new ArrayList<NameValuePair>(); parameters.add(new BasicNameValuePair(STR, groupPath)); parameters.add(new BasicNameValuePair(STR, jobName)); if (options != null) { for (Entry<Object, Object> option : options.entrySet()) { parameters.add(new BasicNameValuePair(STR + option.getKey(), String.valueOf(option.getValue()))); } } return URLEncodedUtils.format(parameters, HTTP.UTF_8); }	@return an array of {@link NameValuePair}, won't be null or empty (at least 2 entries : group and job)	1	0
"public boolean addFile(File sourceFile) { String filename = sourceFile.getName(); File destFile = null; String codeExtension = null; boolean replacement = false; // if the file appears to be code related, drop it // into the code folder, instead of the data folder if (filename.toLowerCase().endsWith("".class"") || filename.toLowerCase().endsWith("".jar"") || filename.toLowerCase().endsWith("".dll"") || filename.toLowerCase().endsWith("".jnilib"") || filename.toLowerCase().endsWith("".so"")) { //if (!codeFolder.exists()) codeFolder.mkdirs(); prepareCodeFolder(); destFile = new File(codeFolder, filename); } else { for (String extension : getExtensions()) { String lower = filename.toLowerCase(); if (lower.endsWith(""."" + extension)) { destFile = new File(this.folder, filename); codeExtension = extension; } } if (codeExtension == null) { prepareDataFolder(); destFile = new File(dataFolder, filename); } } // check whether this file already exists if (destFile.exists()) { Object[] options = { ""OK"", ""Cancel"" }; String prompt = ""Replace the existing version of "" + filename + ""?""; int result = JOptionPane.showOptionDialog(editor, prompt, ""Replace"", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options[0]); if (result == JOptionPane.YES_OPTION) { replacement = true; } else { return false; } } // If it's a replacement, delete the old file first, // otherwise case changes will not be preserved. // http://dev.processing.org/bugs/show_bug.cgi?id=969 if (replacement) { boolean muchSuccess = destFile.delete(); if (!muchSuccess) { Base.showWarning(""Error adding file"", ""Could not delete the existing '"" + filename + ""' file."", null); return false; } } // make sure they aren't the same file if ((codeExtension == null) && sourceFile.equals(destFile)) { Base.showWarning(""You can't fool me"", ""This file has already been copied to the\n"" + ""location from which where you're trying to add it.\n"" + ""I ain't not doin nuthin'."", null); return false; } // in case the user is ""adding"" the code in an attempt // to update the sketch's tabs if (!sourceFile.equals(destFile)) { try { Base.copyFile(sourceFile, destFile); } catch (IOException e) { Base.showWarning(""Error adding file"", ""Could not add '"" + filename + ""' to the sketch."", e); return false; } } if (codeExtension != null) { SketchCode newCode = new SketchCode(destFile, codeExtension); if (replacement) { replaceCode(newCode); } else { insertCode(newCode); sortCode(); } setCurrentCode(filename); editor.header.repaint(); if (editor.untitled) { // TODO probably not necessary? problematic? // Mark the new code as modified so that the sketch is saved current.setModified(true); } } else { if (editor.untitled) { // TODO probably not necessary? problematic? // If a file has been added, mark the main code as modified so // that the sketch is properly saved. code[0].setModified(true); } } return true; }"	@return true if successful.	0	1
private boolean isCached(Serializable collectionKey, CollectionPersister persister) { if ( persister.hasCache() ) { CacheKey cacheKey = context.getSession().generateCacheKey( collectionKey, persister.getKeyType(), persister.getRole() ); return persister.getCacheAccessStrategy().get( cacheKey, context.getSession().getTimestamp() ) != null; } return false; }	@return an array of identifiers, of length batchSize (possibly padded with nulls)	1	0
private XmlAttributeNode getScriptSourcePath(XmlTagNode node) { for (XmlAttributeNode attribute : node.getAttributes()) { if (attribute.getName().getLexeme().equals(SRC)) { return attribute; } } return null; }	@return the source path or {@code null} if not defined	1	0
public static final Weblogger getRoller() { if (rollerInstance == null) { throw new IllegalStateException(STR); } return rollerInstance; }	@return Roller An instance of Roller.	1	0
public TraversalControl visitDocument(Document node, TraverserContext<Node> context) { Document changedNode = node.transform(builder -> { List<Definition> definitions = sort(node.getDefinitions(), comparingDefinitions()); builder.definitions(definitions); }); return changeNode(context, changedNode); }	@return a new sorted node (because graphql.language.Nodes are immutable)	0	1
@Override public int hashCode() { int hash = NUM; hash = hash * NUM + ((mGroupId == null) ? NUM : mGroupId.hashCode()); hash = hash * NUM + mPwPairs.hashCode(); return hash; }	@return 42.	1	0
public String getSynonymSource(String anOwner, String aSynonym) { if (this.synonymReader == null) return STR; String result = null; try { result = this.synonymReader.getSynonymSource(this.dbConnection.getSqlConnection(), anOwner, aSynonym); } catch (Exception e) { result = STR; } return result; }	@return the SQL to create the synonym. If the DBMS is not Oracle an empty String	1	0
public static FlushMode interpretExternalSetting(String externalName) { return FlushModeTypeHelper.interpretExternalSetting( externalName ); }	@return The interpreted FlushMode value.	0	1
public String[] createText(MilStd2525TacticalGraphic graphic) { String[] result; String functionId = graphic.getFunctionId(); if (CircularFireSupportArea.FUNCTION_ID_TARGET.equals(functionId)) { result = new String[] { graphic.getText() }; } else { boolean useSeparateTimeLabel = this.isShowSeparateTimeLabel(functionId); String mainText = this.createMainText(graphic, functionId, !useSeparateTimeLabel); if (useSeparateTimeLabel) { String timeText = this.createTimeRangeText(graphic); result = new String[] { mainText, timeText }; } else { result = new String[] { mainText }; } } return result; }	@return Label text.	1	0
public static Map mapOfSize(int size) { return new HashMap( determineProperSizing( size ), LOAD_FACTOR ); }	@return The sized map.	0	1
protected TokenResponse executeRefreshToken() throws IOException { if (refreshToken == null) { return null; } return new RefreshTokenRequest(transport, jsonFactory, new GenericUrl(tokenServerEncodedUrl), refreshToken).setClientAuthentication(clientAuthentication).setRequestInitializer(requestInitializer).execute(); }	@return whether a new access token was successfully retrieved	1	0
"public List<Lattice> addQuery(RelNode r) { // Push filters into joins and towards leaves final HepPlanner planner = new HepPlanner(PROGRAM, null, true, null, RelOptCostImpl.FACTORY); planner.setRoot(r); final RelNode r2 = planner.findBestExp(); final Query q = new Query(space); final Frame frame = frame(q, r2); if (frame == null) { return ImmutableList.of(); } final AttributedDirectedGraph<TableRef, StepRef> g = AttributedDirectedGraph.create(new StepRef.Factory()); final Multimap<Pair<TableRef, TableRef>, IntPair> map = LinkedListMultimap.create(); for (TableRef tableRef : frame.tableRefs) { g.addVertex(tableRef); } for (Hop hop : frame.hops) { map.put(Pair.of(hop.source.t, hop.target.t), IntPair.of(hop.source.c, hop.target.c)); } for (Map.Entry<Pair<TableRef, TableRef>, Collection<IntPair>> e : map.asMap().entrySet()) { final TableRef source = e.getKey().left; final TableRef target = e.getKey().right; final StepRef stepRef = q.stepRef(source, target, ImmutableList.copyOf(e.getValue())); g.addVertex(stepRef.source()); g.addVertex(stepRef.target()); g.addEdge(stepRef.source(), stepRef.target(), stepRef.step, stepRef.ordinalInQuery); } // If the join graph is cyclic, we can't use it. final Set<TableRef> cycles = new CycleDetector<>(g).findCycles(); if (!cycles.isEmpty()) { return ImmutableList.of(); } // Translate the query graph to mutable nodes final Map<TableRef, MutableNode> nodes = new IdentityHashMap<>(); final Map<List, MutableNode> nodesByParent = new HashMap<>(); final List<MutableNode> rootNodes = new ArrayList<>(); for (TableRef tableRef : TopologicalOrderIterator.of(g)) { final List<StepRef> edges = g.getInwardEdges(tableRef); final MutableNode node; switch (edges.size()) { case 0: node = new MutableNode(tableRef.table); rootNodes.add(node); break; case 1: final StepRef edge = edges.get(0); final MutableNode parent = nodes.get(edge.source()); final List key = ImmutableList.of(parent, tableRef.table, edge.step.keys); final MutableNode existingNode = nodesByParent.get(key); if (existingNode == null) { node = new MutableNode(tableRef.table, parent, edge.step); nodesByParent.put(key, node); } else { node = existingNode; } break; default: for (StepRef edge2 : edges) { final MutableNode parent2 = nodes.get(edge2.source()); final MutableNode node2 = new MutableNode(tableRef.table, parent2, edge2.step); parent2.children.add(node2); } node = null; break; } nodes.put(tableRef, node); } // Transcribe the hierarchy of mutable nodes to immutable nodes final List<Lattice> lattices = new ArrayList<>(); for (MutableNode rootNode : rootNodes) { if (rootNode.isCyclic()) { continue; } final CalciteSchema rootSchema = CalciteSchema.createRootSchema(false); final Lattice.Builder latticeBuilder = new Lattice.Builder(space, rootSchema, rootNode); final List<MutableNode> flatNodes = new ArrayList<>(); rootNode.flatten(flatNodes); for (MutableMeasure measure : frame.measures) { for (ColRef arg : measure.arguments) { if (arg == null) { // Cannot handle expressions, e.g. ""sum(x + 1)"" yet return ImmutableList.of(); } } latticeBuilder.addMeasure( new Lattice.Measure(measure.aggregate, measure.distinct, measure.name, Lists.transform(measure.arguments, colRef -> { final Lattice.Column column; if (colRef instanceof BaseColRef) { final BaseColRef baseColRef = (BaseColRef) colRef; final MutableNode node = nodes.get(baseColRef.t); final int table = flatNodes.indexOf(node); column = latticeBuilder.column(table, baseColRef.c); } else if (colRef instanceof DerivedColRef) { final DerivedColRef derivedColRef = (DerivedColRef) colRef; final String alias = deriveAlias(measure, derivedColRef); column = latticeBuilder.expression(derivedColRef.e, alias, derivedColRef.tableAliases()); } else { throw new AssertionError(""expression in measure""); } latticeBuilder.use(column, true); return column; }))); } for (int i = 0; i < frame.columnCount; i++) { final ColRef c = frame.column(i); if (c instanceof DerivedColRef) { final DerivedColRef derivedColRef = (DerivedColRef) c; final Lattice.Column expression = latticeBuilder.expression(derivedColRef.e, derivedColRef.alias, derivedColRef.tableAliases()); latticeBuilder.use(expression, false); } } final Lattice lattice0 = latticeBuilder.build(); final Lattice lattice1 = findMatch(lattice0, rootNode); lattices.add(lattice1); } return ImmutableList.copyOf(lattices); }"	@return A list of join graphs: usually 1; more if the query contains a cartesian product; zero if the query graph is cyclic	0	1
public int size() { return data.length(); }	@return the value of the count field, which is the number of valid bytes in this output stream.	0	1
public Throwable initCause(Throwable cause) { return super.initCause(cause); }	@return This object.	1	0
public static StringTemplate stringTemplate(Template template, ImmutableList<?> args) { return new StringTemplate(template, args); }	@return template expression	0	1
protected long expireTimeMS(Supplier<Duration> expires) { try { Duration duration = expires.get(); if (duration == null) { return -NUM; } return duration.isZero() ? NUM : duration.getAdjustedTime(currentTimeMillis()); } catch (Exception e) { logger.log(Level.WARNING, STR, e); return -NUM; } }	@return the time when the entry will expire	1	0
public GremlinPipeline<S, String> label() { return this.add(new LabelPipe()); }	@return the extended FluentPipeline	1	0
static boolean observe(@Nullable final Object object) { return !(object instanceof ComponentObservable) || asComponentObservable(object).observe(); }	"@return true if the component is ""alive"" a.k.a. not disposing or disposed."	1	0
"public static List<Point> convexHull(List<Point> points) { if (points.size() < 3) { return null; } List<Point> ch = new ArrayList<>(); // find the left most point Point left = findLeftMost(points); // current point we are on Point current = left; do { ch.add(current); assert ch.size() <= points.size() : ""hull has more points than graph""; if (ch.size() > points.size()) { // Just to make sure we never somehow get stuck in this loop return null; } // the next point - all points are to the right of the // line between current and next Point next = null; for (Point p : points) { if (next == null) { next = p; continue; } long cp = crossProduct(current, p, next); if (cp > 0 || (cp == 0 && current.distanceTo(p) > current.distanceTo(next))) { next = p; } } // Points can be null if they are behind or very close to the camera. if (next == null) { return null; } current = next; } while (current != left); return ch; }"	@return list containing the points part of the convex hull	0	1
public static Iterable<Runnable> thread(final String title, Iterable<Runnable> runnables){ //--Preparation //(variables) final AtomicBoolean haveStarted = new AtomicBoolean(false); final ReentrantLock metaInfoLock = new ReentrantLock(); final AtomicInteger numPending = new AtomicInteger(0); final Iterator<Runnable> iter = runnables.iterator(); //--Create Runnables return new IterableIterator<>(new Iterator<Runnable>() { @Override public boolean hasNext() { synchronized (iter) { return iter.hasNext(); } } @Override public synchronized Runnable next() { final Runnable runnable; synchronized (iter) { runnable = iter.next(); } // (don't flood the queu) while (numPending.get() > 100) { try { Thread.sleep(100); } catch (InterruptedException e) { } } numPending.incrementAndGet(); // (add the job) Runnable toReturn = new Runnable() { public void run() { boolean threadFinished = false; try { //(signal start of threads) metaInfoLock.lock(); if (!haveStarted.getAndSet(true)) { startThreads(title); //<--this must be a blocking operation } metaInfoLock.unlock(); //(run runnable) try { runnable.run(); } catch (Exception | AssertionError e) { e.printStackTrace(); System.exit(1); } //(signal end of thread) finishThread(); threadFinished = true; //(signal end of threads) int numStillPending = numPending.decrementAndGet(); synchronized (iter) { if (numStillPending <= 0 && !iter.hasNext()) { endThreads(title); } } } catch (Throwable t) { t.printStackTrace(); if (!threadFinished) { finishThread(); } } } }; return toReturn; } @Override public void remove() { synchronized (iter) { iter.remove(); } } }); }	@return A new collection of Runnables with the Redwood overhead taken care of	0	1
public Button getButton(int index) { return getter.getView(Button.class, index); }	@return the Button with a specified index or null if index is invalid	0	1
@Override public int getItemCount() { return getAdapterItemCount() + totalAdditionalItems(); }	@return The total number of items in this adapter.	1	0
public Options includeScalarTypes(boolean flag) { return new Options(this.includeIntrospectionTypes, flag, this.includeSchemaDefinition, this.useAstDefinitions, this.descriptionsAsHashComments, this.includeDirective, this.comparatorRegistry); }	@return options	0	1
public boolean transform(Canvas canvas, View child) { final RevealValues revealData = targets.get(child); return revealData != null && revealData.applyTransformation(canvas, child); }	@return True if transformation was successfully applied on referenced child, otherwise child be not the target and therefore animation was skipped	0	1
protected Account getServiceCredentials() { return this.account; }	@return {@link ServiceCredentials} if they are already set.	1	0
private char[] encodePattern(List<Cell> pattern) { return mEncrypter != null ? mEncrypter.encrypt(this, pattern) : LockPatternUtils.patternToSha1(pattern).toCharArray(); }	@return SHA-1 of {@code pattern}, or encrypted string of its.	1	0
public final static AtmosphereRequest wrap(HttpServletRequest request) { // Do not rewrap. if (AtmosphereRequest.class.isAssignableFrom(request.getClass())) { return AtmosphereRequest.class.cast(request); } Builder b = new Builder(); Enumeration<String> e = request.getAttributeNames(); String s; while (e.hasMoreElements()) { s = e.nextElement(); b.localAttributes.put(s, request.getAttribute(s)); } return b.request(request).build(); }	@return an AtmosphereRequest	0	1
public boolean validatePassword(String passString) { if (passString.length() >= 8) { return true; } else { Snackbar snackbar = Snackbar .make(findViewById(android.R.id.content), R.string.password_length, Snackbar.LENGTH_LONG); snackbar.show(); return false; } }	@return Boolean returns true if email format is correct, otherwise false	0	1
private StreamEvent findIfActualMin(AttributeDetails latestEvent) { int indexCurrentMin = valueStack.indexOf(currentMin); int postBound = valueStack.indexOf(latestEvent) - indexCurrentMin; if (postBound > maxPostBound) { currentMin.notEligibleForRealMin(); return null; } if (maxPreBound == NUM) { StreamEvent outputEvent = eventStack.get(indexCurrentMin); complexEventPopulater.populateComplexEvent(outputEvent, new Object[] { STR, NUM, postBound }); currentMin.sentOutputAsRealMin(); return outputEvent; } int preBound = NUM; double dThreshold = currentMin.getValue() + currentMin.getValue() * preBoundChange / NUM; while (preBound <= maxPreBound && indexCurrentMin - preBound >= NUM) { if (valueStack.get(indexCurrentMin - preBound).getValue() >= dThreshold) { StreamEvent outputEvent = eventStack.get(indexCurrentMin); complexEventPopulater.populateComplexEvent(outputEvent, new Object[] { STR, preBound, postBound }); currentMin.sentOutputAsRealMin(); return outputEvent; } ++preBound; } currentMin.notEligibleForRealMin(); return null; }	@return if d, L conditions are met, send stream event output with extrema type, actual_l (distance at which a value satisfying d condition is found), actual_L (distance at which a value satisfying D condition is found)	1	0
"public String next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 180: { return(stem(3,""te"",""ed"")); } case 373: break; case 298: { return(stem(1,""a"",""s"")); } case 374: break; case 94: { return(stem(3,""ide"",""ed"")); } case 375: break; case 126: { return(stem(2,""al"",""s"")); } case 376: break; case 15: { return(null_stem()); } case 377: break; case 293: { return(stem(2,""la"",""s"")); } case 378: break; case 38: { return(stem(3,""will"","""")); } case 379: break; case 8: { yybegin(scan); if (option(tag_output)) return yytext(); } case 380: break; case 11: { return cnull_stem(); } case 381: break; case 72: { return(stem(3,""eel"",""ed"")); } case 382: break; case 173: { return(stem(3,""eal"",""ed"")); } case 383: break; case 177: { return(stem(4,""ake"",""en"")); } case 384: break; case 134: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,""I"","""")); } case 385: break; case 133: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(1,""y"","""")); } case 386: break; case 259: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 4; { return(stem(1,""y"","""")); } case 387: break; case 89: { return(stem(3,""ay"",""ed"")); } case 388: break; case 272: { return(stem(3,""se"",""ed"")); } case 389: break; case 95: { return(stem(3,""ise"",""ed"")); } case 390: break; case 236: { return(stem(3,""ike"",""ed"")); } case 391: break; case 29: { return(ynull_stem()); } case 392: break; case 111: { return(stem(3,""ell"",""ed"")); } case 393: break; case 10: { return(stem(1,""us"",""s"")); } case 394: break; case 1: { return(common_noun_stem()); } case 395: break; case 13: // lookahead expression with fixed lookahead length yypushback(1); { return(common_noun_stem()); } case 396: break; case 70: { return(stem(3,""ly"",""ed"")); } case 397: break; case 67: { return(stem(3,""ive"",""ed"")); } case 398: break; case 356: { return(stem(3,""is"",""s"")); } case 399: break; case 239: { return(stem(5,""eek"",""ed"")); } case 400: break; case 160: { return(stem(3,""ar"",""ed"")); } case 401: break; case 267: { return(stem(4,""ame"",""ed"")); } case 402: break; case 33: { return(stem(3,""see"",""ed"")); } case 403: break; case 151: { return(stem(3,""epe"",""ed"")); } case 404: break; case 21: { return(stem(3,""get"",""ed"")); } case 405: break; case 352: { return(stem(8,""-de-sac"",""s"")); } case 406: break; case 370: { return(stem(12,""-in-the-box"",""s"")); } case 407: break; case 266: { return(stem(5,""ing"",""ed"")); } case 408: break; case 182: { return(stem(2,""i"",""s"")); } case 409: break; case 162: { return(stem(3,""an"",""ed"")); } case 410: break; case 30: { return(stem(3,""red"",""ed"")); } case 411: break; case 51: { return(stem(3,""e"",""ing"")); } case 412: break; case 214: { return(stem(3,""ass"",""ed"")); } case 413: break; case 249: { return(stem(2,""re"",""s"")); } case 414: break; case 65: { return(stem(2,""e"",""s"")); } case 415: break; case 78: { return(stem(3,""o"",""en"")); } case 416: break; case 155: { return(stem(5,""do"",""ed"")); } case 417: break; case 71: { return(stem(3,""all"",""ed"")); } case 418: break; case 125: { return(stem(2,""ra"",""s"")); } case 419: break; case 212: { return(stem(6,""clepe"",""ed"")); } case 420: break; case 256: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 4; { return(stem(1,"""","""")); } case 421: break; case 60: { return(stem(3,""ear"",""ed"")); } case 422: break; case 63: { return(stem(3,""ome"",""ed"")); } case 423: break; case 52: { return(stem(1,"""",""ed"")); } case 424: break; case 157: { return(stem(3,""eeze"",""ed"")); } case 425: break; case 27: { return(stem(3,""light"",""ed"")); } case 426: break; case 139: { return(stem(3,""y"",""s"")); } case 427: break; case 296: { return(stem(2,""zo"",""s"")); } case 428: break; case 31: { return(stem(3,""run"",""ed"")); } case 429: break; case 46: { return(stem(2,""an"",""s"")); } case 430: break; case 333: { return(stem(3,""ix"",""ed"")); } case 431: break; case 304: { return(stem(4,""g"",""ing"")); } case 432: break; case 57: { return(stem(3,""end"",""ed"")); } case 433: break; case 131: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 7; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return(proper_name_stem()); } case 434: break; case 50: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 1; { return(proper_name_stem()); } case 435: break; case 55: { return(stem(3,""low"",""ed"")); } case 436: break; case 193: { return(stem(2,""ny"",""s"")); } case 437: break; case 138: { return(stem(3,""y"",""ed"")); } case 438: break; case 104: { return(stem(3,""mite"",""ed"")); } case 439: break; case 305: { return(stem(3,""d"",""en"")); } case 440: break; case 14: { return(stem(2,""e"",""ed"")); } case 441: break; case 100: { return(stem(3,""hoot"",""ed"")); } case 442: break; case 185: { return(stem(2,""so"",""s"")); } case 443: break; case 341: { return(stem(2,""r"",""s"")); } case 444: break; case 231: { return(stem(5,""elt"",""en"")); } case 445: break; case 225: { return(stem(4,""eeze"",""en"")); } case 446: break; case 332: { return(stem(4,""y"",""ing"")); } case 447: break; case 130: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { yybegin(noun); yypushback(yylength()); return(next()); } case 448: break; case 81: { return(stem(3,""ew"",""en"")); } case 449: break; case 113: { return(stem(3,""aw"",""en"")); } case 450: break; case 49: // lookahead expression with fixed lookahead length yypushback(2); { yybegin(verb); yypushback(yylength()); return(next()); } case 451: break; case 314: { return(stem(3,""ship"",""ed"")); } case 452: break; case 335: { return(stem(1,""de"",""s"")); } case 453: break; case 365: { return(stem(9,""-mutuel"",""s"")); } case 454: break; case 371: { return(stem(14,""y-in-waiting"",""s"")); } case 455: break; case 9: { return(stem(2,""be"","""")); } case 456: break; case 206: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,""be"","""")); } case 457: break; case 69: { return(stem(3,""lee"",""ed"")); } case 458: break; case 40: { return(stem(1,""um"",""s"")); } case 459: break; case 56: { return(stem(3,""reed"",""ed"")); } case 460: break; case 163: { return(stem(3,""ap"",""ed"")); } case 461: break; case 344: { return(stem(2,""te"",""s"")); } case 462: break; case 197: { return(stem(3,""f"",""s"")); } case 463: break; case 200: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,""can"","""")); } case 464: break; case 300: { return(stem(2,""lio"",""s"")); } case 465: break; case 108: { return(stem(3,""wim"",""en"")); } case 466: break; case 91: { return(stem(3,""ow"",""en"")); } case 467: break; case 321: { return(stem(2,""g"",""s"")); } case 468: break; case 228: { return(semi_reg_stem(1,"""")); } case 469: break; case 275: { return(stem(2,""gue"",""s"")); } case 470: break; case 143: { return(stem(3,""ei"",""ed"")); } case 471: break; case 37: { return(stem(3,""eat"",""ed"")); } case 472: break; case 17: { return(stem(3,""bid"",""ed"")); } case 473: break; case 217: { return(stem(3,"""",""en"")); } case 474: break; case 355: { return(stem(10,""an-at-arms"",""s"")); } case 475: break; case 132: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,""we"","""")); } case 476: break; case 244: { return(stem(2,""ron"",""s"")); } case 477: break; case 338: { return(stem(2,""non"",""s"")); } case 478: break; case 196: { return(stem(2,""uum"",""s"")); } case 479: break; case 24: { return(stem(3,""have"",""ed"")); } case 480: break; case 345: { return(stem(3,""ff"",""s"")); } case 481: break; case 251: { return(stem(2,""mum"",""s"")); } case 482: break; case 242: { return(stem(2,""ie"",""ed"")); } case 483: break; case 273: { return(stem(2,""ee"",""ed"")); } case 484: break; case 334: { return(stem(2,""do"",""s"")); } case 485: break; case 262: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,""do"",""s"")); } case 486: break; case 361: { return(stem(6,""-doux"",""s"")); } case 487: break; case 299: { return(stem(3,""ly"",""s"")); } case 488: break; case 224: { return(stem(4,""w"",""ed"")); } case 489: break; case 237: { return(stem(4,""eal"",""en"")); } case 490: break; case 253: { return(stem(6,""m.p."",""s"")); } case 491: break; case 45: { return(stem(2,"""",""s"")); } case 492: break; case 347: { return(stem(9,""an-of-war"",""s"")); } case 493: break; case 90: { return(stem(3,""ie"",""en"")); } case 494: break; case 121: { return(stem(2,""tum"",""s"")); } case 495: break; case 199: { return(stem(5,""eyrir"",""s"")); } case 496: break; case 110: { return(stem(3,""ee"",""en"")); } case 497: break; case 204: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,""will"","""")); } case 498: break; case 250: { return(stem(2,""ia"",""s"")); } case 499: break; case 255: { return(stem(3,""s"",""s"")); } case 500: break; case 44: { return(stem(2,""uo"",""s"")); } case 501: break; case 226: { return(stem(5,""ight"",""ed"")); } case 502: break; case 124: { return(stem(3,""ouse"",""s"")); } case 503: break; case 359: { return(stem(2,""t"",""s"")); } case 504: break; case 7: { return(stem(2,""be"",""s"")); } case 505: break; case 260: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,""be"",""s"")); } case 506: break; case 53: { return(semi_reg_stem(0,""e"")); } case 507: break; case 357: { return(stem(8,""-in-law"",""s"")); } case 508: break; case 181: { return(stem(4,""."",""s"")); } case 509: break; case 169: { return(stem(3,""ay"",""en"")); } case 510: break; case 165: { return(stem(3,""se"",""en"")); } case 511: break; case 39: { return(stem(3,""have"","""")); } case 512: break; case 3: { // The first word isn't stemmed separately, but the second half can be String stem = common_noun_stem(); String n = next(); if (n == null) { return stem; } else { return stem.concat(n); } } case 513: break; case 166: { return(stem(3,""ine"",""ed"")); } case 514: break; case 278: { return(stem(5,""ink"",""ed"")); } case 515: break; case 326: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 4; { return(stem(4,""be"",""ed"")); } case 516: break; case 116: { return(stem(4,""be"",""ed"")); } case 517: break; case 360: { return(stem(9,""-down"",""ing"")); } case 518: break; case 297: { return(stem(3,""en"",""s"")); } case 519: break; case 148: { return(stem(4,""ear"",""en"")); } case 520: break; case 362: { return(stem(8,""-de-lys"",""s"")); } case 521: break; case 115: { return(stem(4,""go"",""ed"")); } case 522: break; case 309: { return(stem(4,""y"",""ed"")); } case 523: break; case 42: { return(stem(2,""a"",""s"")); } case 524: break; case 189: { return(stem(3,""x"",""s"")); } case 525: break; case 61: { return(stem(3,""id"",""ed"")); } case 526: break; case 83: { return(stem(4,""have"",""s"")); } case 527: break; case 59: { return(stem(3,""ear"",""en"")); } case 528: break; case 96: { return(stem(3,""eeve"",""ed"")); } case 529: break; case 76: { return(stem(3,""ild"",""ed"")); } case 530: break; case 354: { return(stem(10,""anservant"",""s"")); } case 531: break; case 202: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 3; { return(stem(3,""he"","""")); } case 532: break; case 254: { return(stem(4,""ex"",""s"")); } case 533: break; case 150: { return(stem(3,""oose"",""ed"")); } case 534: break; case 336: { return(stem(4,""-in"",""s"")); } case 535: break; case 285: { return(stem(6,""ork"",""ed"")); } case 536: break; case 144: { return(stem(3,""eak"",""ed"")); } case 537: break; case 112: { return(stem(3,""ink"",""ed"")); } case 538: break; case 241: { return(stem(3,""a"",""ed"")); } case 539: break; case 141: { return(stem(3,""rn"",""ed"")); } case 540: break; case 330: { return(stem(6,""-up"",""ed"")); } case 541: break; case 156: { return(stem(3,""y"",""en"")); } case 542: break; case 119: { return(stem(2,""um"",""s"")); } case 543: break; case 222: { return(stem(4,""tch"",""ed"")); } case 544: break; case 88: { return(stem(3,""ose"",""ed"")); } case 545: break; case 25: { return(stem(3,""have"",""s"")); } case 546: break; case 101: { return(stem(3,""hit"",""ed"")); } case 547: break; case 122: { return(stem(3,""oot"",""s"")); } case 548: break; case 68: { return(stem(4,""do"",""s"")); } case 549: break; case 97: { return(stem(3,""ing"",""ed"")); } case 550: break; case 246: { return(stem(3,""denum"",""s"")); } case 551: break; case 353: { return(stem(6,""-over"",""s"")); } case 552: break; case 191: { return(stem(1,""s"",""s"")); } case 553: break; case 34: { return(stem(3,""win"",""ed"")); } case 554: break; case 82: { return(stem(3,""eave"",""ed"")); } case 555: break; case 343: { return(stem(7,""-up"",""ing"")); } case 556: break; case 74: { return(stem(3,""eld"",""ed"")); } case 557: break; case 289: { return(stem(4,""yatid"",""s"")); } case 558: break; case 342: { return(stem(4,""us"",""s"")); } case 559: break; case 291: { return(stem(1,""o"",""s"")); } case 560: break; case 127: { return(stem(2,""lo"",""s"")); } case 561: break; case 103: { return(stem(3,""lide"",""ed"")); } case 562: break; case 41: { return(stem(2,""."",""s"")); } case 563: break; case 175: { return(stem(3,""and"",""ed"")); } case 564: break; case 223: { return(stem(3,""am"",""ed"")); } case 565: break; case 114: { return(stem(3,""read"",""ed"")); } case 566: break; case 263: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,""have"",""s"")); } case 567: break; case 350: { return(stem(8,""-down"",""ed"")); } case 568: break; case 209: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,""have"",""ed"")); } case 569: break; case 137: { return(stem(3,"""",""ing"")); } case 570: break; case 146: { return(stem(5,""be"",""ing"")); } case 571: break; case 219: { return(stem(4,""te"",""ing"")); } case 572: break; case 322: { return(stem(4,""isee"",""s"")); } case 573: break; case 118: { return(stem(1,""on"",""s"")); } case 574: break; case 117: { return(stem(2,"""",""ed"")); } case 575: break; case 307: { return(stem(4,""y"",""s"")); } case 576: break; case 346: { return(stem(4,""-on"",""s"")); } case 577: break; case 337: { return(stem(8,""onsieur"",""s"")); } case 578: break; case 178: { return(stem(4,""eave"",""en"")); } case 579: break; case 248: { return(stem(3,""us"",""s"")); } case 580: break; case 366: { return(stem(9,""-de-camp"",""s"")); } case 581: break; case 201: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 3; { return(stem(3,""she"","""")); } case 582: break; case 64: { return(stem(3,""raw"",""ed"")); } case 583: break; case 317: { return(stem(2,""cio"",""s"")); } case 584: break; case 372: { return(stem(11,""y-general"",""s"")); } case 585: break; case 320: { return(stem(2,""eum"",""s"")); } case 586: break; case 369: { return(stem(9,""-at-arms"",""s"")); } case 587: break; case 315: { return(stem(2,""ion"",""s"")); } case 588: break; case 368: { return(stem(11,""erfamilias"",""s"")); } case 589: break; case 328: { return(stem(6,""-down"",""s"")); } case 590: break; case 288: { return(stem(1,""x"",""s"")); } case 591: break; case 323: { return(stem(2,""oan"",""s"")); } case 592: break; case 306: { return(stem(5,""eech"",""ed"")); } case 593: break; case 73: { return(stem(3,""row"",""ed"")); } case 594: break; case 4: { return yytext(); } case 595: break; case 292: { return(stem(2,""ro"",""s"")); } case 596: break; case 252: { return(stem(3,""ey"",""s"")); } case 597: break; case 324: { return(stem(2,""ton"",""s"")); } case 598: break; case 5: { return(stem(1,"""",""s"")); } case 599: break; case 303: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 3; { return(stem(3,""be"","""")); } case 600: break; case 36: { return(stem(3,""be"","""")); } case 601: break; case 229: { return(stem(5,""et"",""en"")); } case 602: break; case 99: { return(stem(3,""hoe"",""ed"")); } case 603: break; case 164: { return(stem(3,""de"",""en"")); } case 604: break; case 43: { return(xnull_stem()); } case 605: break; case 363: { return(stem(8,""-de-lis"",""s"")); } case 606: break; case 207: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,""have"","""")); } case 607: break; case 271: { return(stem(5,""ivy"",""s"")); } case 608: break; case 238: { return(stem(3,""ge"",""ed"")); } case 609: break; case 233: { return(stem(3,""ce"",""ed"")); } case 610: break; case 176: { return(stem(3,""ke"",""en"")); } case 611: break; case 105: { return(stem(3,""pin"",""ed"")); } case 612: break; case 287: { return(stem(2,""no"",""s"")); } case 613: break; case 312: { return(semi_reg_stem(0,""ue"")); } case 614: break; case 235: { return(stem(3,""il"",""ed"")); } case 615: break; case 351: { return(stem(2,""l"",""s"")); } case 616: break; case 167: { return(semi_reg_stem(0,"""")); } case 617: break; case 159: { return(stem(3,""ve"",""en"")); } case 618: break; case 203: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 3; { return(stem(2,""e"","""")); } case 619: break; case 234: { return(stem(5,""ink"",""en"")); } case 620: break; case 145: { return(stem(3,""gin"",""ed"")); } case 621: break; case 286: { return(stem(5,""y"",""ed"")); } case 622: break; case 205: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 3; { return(stem(3,""we"","""")); } case 623: break; case 171: { return(stem(3,""ill"",""ed"")); } case 624: break; case 232: { return(stem(3,""ue"",""ed"")); } case 625: break; case 245: { return(stem(1,""i"",""s"")); } case 626: break; case 183: { return(stem(2,""d"",""s"")); } case 627: break; case 19: { return(stem(3,""do"",""ed"")); } case 628: break; case 58: { return(stem(4,""be"",""en"")); } case 629: break; case 270: { return(stem(5,""ivy"",""ed"")); } case 630: break; case 168: { return(stem(3,""i"",""ed"")); } case 631: break; case 187: { return(stem(1,""e"",""s"")); } case 632: break; case 340: { return(stem(2,""le"",""s"")); } case 633: break; case 280: { return(stem(5,""ead"",""en"")); } case 634: break; case 301: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 5; { return(stem(2,""y"","""")); } case 635: break; case 149: { return(stem(3,""rse"",""ed"")); } case 636: break; case 66: { return(stem(4,""do"",""en"")); } case 637: break; case 170: { return(stem(3,""ite"",""ed"")); } case 638: break; case 227: { return(stem(3,""l"",""en"")); } case 639: break; case 128: { return(stem(4,""ABC"",""s"")); } case 640: break; case 106: { return(stem(3,""peed"",""ed"")); } case 641: break; case 215: { return(stem(4,""eak"",""en"")); } case 642: break; case 28: { return(stem(3,""meet"",""ed"")); } case 643: break; case 348: { return(stem(4,""-by"",""s"")); } case 644: break; case 135: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(1, """", ""n"")); } case 645: break; case 325: { return(stem(4,""s"",""s"")); } case 646: break; case 318: { return(stem(3,""esis"",""s"")); } case 647: break; case 230: { return(stem(3,""ey"",""ed"")); } case 648: break; case 142: { return(stem(3,""ess"",""ed"")); } case 649: break; case 218: { return(stem(3,""e"",""en"")); } case 650: break; case 349: { return(stem(4,""o"",""s"")); } case 651: break; case 152: { return(stem(4,""are"",""ed"")); } case 652: break; case 147: { return(stem(4,""ind"",""ed"")); } case 653: break; case 172: { return(stem(3,""ick"",""ed"")); } case 654: break; case 153: { return(stem(4,""ie"",""ing"")); } case 655: break; case 107: { return(stem(3,""pit"",""ed"")); } case 656: break; case 184: { return(stem(2,""u"",""s"")); } case 657: break; case 129: { return(stem(2,""to"",""s"")); } case 658: break; case 268: { return(stem(3,""ride"",""ed"")); } case 659: break; case 186: { return(stem(2,""denum"",""s"")); } case 660: break; case 290: { return(stem(4,""sbok"",""s"")); } case 661: break; case 308: { return(stem(6,""ivy"",""ing"")); } case 662: break; case 367: { return(stem(13,""ademoiselle"",""s"")); } case 663: break; case 195: { return(stem(4,""ooth"",""s"")); } case 664: break; case 20: { return(stem(3,""feed"",""ed"")); } case 665: break; case 98: { return(stem(3,""ink"",""en"")); } case 666: break; case 92: { return(stem(3,""ake"",""ed"")); } case 667: break; case 62: { return(stem(3,""lothe"",""ed"")); } case 668: break; case 18: { return(stem(3,""dig"",""ed"")); } case 669: break; case 279: { return(stem(4,""k"",""ed"")); } case 670: break; case 194: { return(stem(2,""po"",""s"")); } case 671: break; case 221: { return(stem(3,""ose"",""en"")); } case 672: break; case 174: { return(stem(3,""ave"",""ed"")); } case 673: break; case 77: { return(stem(3,""ird"",""ed"")); } case 674: break; case 161: { return(stem(3,""in"",""ed"")); } case 675: break; case 210: { return(stem(4,"""",""ing"")); } case 676: break; case 85: { return(stem(3,""en"",""ed"")); } case 677: break; case 87: { return(stem(3,""o"",""ed"")); } case 678: break; case 281: { return(stem(3,""mel"",""s"")); } case 679: break; case 274: { return(stem(4,""-up"",""s"")); } case 680: break; case 12: { return(stem(2,""is"",""s"")); } case 681: break; case 23: { return(stem(3,""hide"",""ed"")); } case 682: break; case 93: { return(stem(3,""ing"",""en"")); } case 683: break; case 257: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 3; { return(stem(3,""not"","""")); } case 684: break; case 283: { return(stem(4,""i"",""ing"")); } case 685: break; case 243: { return(stem(4,""e"",""ing"")); } case 686: break; case 284: { return(stem(4,""a"",""ing"")); } case 687: break; case 136: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,""'s"","""")); } case 688: break; case 264: { return(condub_stem(3,"""",""ing"")); } case 689: break; case 120: { return(stem(3,""a"",""s"")); } case 690: break; case 327: { return(stem(4,""l"",""ing"")); } case 691: break; case 316: { return(stem(2,""ne"",""s"")); } case 692: break; case 247: { return(stem(3,""ur"",""s"")); } case 693: break; case 198: { return(stem(2,""b"",""s"")); } case 694: break; case 220: { return(stem(5,""uy"",""ed"")); } case 695: break; case 258: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 3; { return(stem(3,""shall"","""")); } case 696: break; case 190: { return(stem(3,""fe"",""s"")); } case 697: break; case 216: { return(stem(2,"""",""en"")); } case 698: break; case 311: { return(stem(5,""ify"",""s"")); } case 699: break; case 313: { return(stem(5,""k"",""ing"")); } case 700: break; case 6: { return(cnull_stem()); } case 701: break; case 80: { return(stem(3,""old"",""ed"")); } case 702: break; case 339: { return(stem(4,""ese"",""s"")); } case 703: break; case 2: { String str = yytext(); int first = str.charAt(0); String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s) - this may be because your text isn't using _ as a tag delimiter"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); LOGGER.warning(msg); } case 704: break; case 294: { return(stem(2,""dum"",""s"")); } case 705: break; case 47: { return(stem(2,""s"",""s"")); } case 706: break; case 329: { return(stem(5,""y"",""ing"")); } case 707: break; case 358: { return(stem(6,""-lit"",""s"")); } case 708: break; case 158: { return(stem(3,""ip"",""ed"")); } case 709: break; case 79: { return(stem(3,""ang"",""ed"")); } case 710: break; case 331: { return(stem(6,""ify"",""ing"")); } case 711: break; case 295: { return(stem(4,""belly"",""s"")); } case 712: break; case 188: { return(stem(4,""oose"",""s"")); } case 713: break; case 282: { return(stem(4,""ge"",""ing"")); } case 714: break; case 109: { return(stem(3,""wim"",""ed"")); } case 715: break; case 179: { return(stem(3,""t"",""en"")); } case 716: break; case 276: { return(stem(4,""ue"",""ing"")); } case 717: break; case 48: { return(stem(2,""vum"",""s"")); } case 718: break; case 123: { return(stem(2,""rum"",""s"")); } case 719: break; case 192: { return(stem(2,""num"",""s"")); } case 720: break; case 102: { return(stem(3,""lay"",""ed"")); } case 721: break; case 277: { return(stem(5,""ell"",""en"")); } case 722: break; case 140: { return(stem(3,"""",""ed"")); } case 723: break; case 261: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,""as"","""")); } case 724: break; case 16: { return(stem(3,""bite"",""ed"")); } case 725: break; case 154: { return(stem(3,""al"",""ed"")); } case 726: break; case 213: { return(stem(3,"""",""s"")); } case 727: break; case 302: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 3; { return(stem(3,""be"",""ed"")); } case 728: break; case 35: { return(stem(3,""be"",""ed"")); } case 729: break; case 32: { return(stem(3,""sit"",""ed"")); } case 730: break; case 240: { return(stem(5,""each"",""ed"")); } case 731: break; case 364: { return(stem(9,""-a-terre"",""s"")); } case 732: break; case 84: { return(stem(3,""now"",""ed"")); } case 733: break; case 22: { return(stem(3,""gin"",""en"")); } case 734: break; case 269: { return(stem(3,""ie"",""ed"")); } case 735: break; case 75: { return(stem(3,""ee"",""ed"")); } case 736: break; case 86: { return(stem(3,""eep"",""ed"")); } case 737: break; case 208: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,""would"","""")); } case 738: break; case 54: { return(stem(3,""leed"",""ed"")); } case 739: break; case 26: { return(stem(3,""lead"",""ed"")); } case 740: break; case 265: { return(stem(7,""clepe"",""ed"")); } case 741: break; case 319: { return(stem(4,""eps"",""s"")); } case 742: break; case 310: { return(stem(5,""ify"",""ed"")); } case 743: break; case 211: { return(condub_stem(2,"""",""ed"")); } case 744: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }"	@return the next token	0	1
@ApiModelProperty(value = STR) public String getType() { return type; }	@return TypeEnum type	1	0
"public Frame readFrame() throws IOException { byte[] header = new byte[HEADER_SIZE]; int actualHeaderSize = 0; do { int headerCount = inputStream.read(header, actualHeaderSize, HEADER_SIZE - actualHeaderSize); if (headerCount == -1) { return null; } actualHeaderSize += headerCount; } while (actualHeaderSize < HEADER_SIZE); int payloadSize = ((header[4] & 0xff) << 24) + ((header[5] & 0xff) << 16) + ((header[6] & 0xff) << 8) + (header[7] & 0xff); byte[] payload = new byte[payloadSize]; int actualPayloadSize = 0; do { int count = inputStream.read(payload, actualPayloadSize, payloadSize - actualPayloadSize); if (count == -1) { if (actualPayloadSize != payloadSize) { throw new IOException(String.format(""payload must be %d bytes long, but was %d"", payloadSize, actualPayloadSize)); } break; } actualPayloadSize += count; } while (actualPayloadSize < payloadSize); return new Frame(streamType(header[0]), payload); }"	@return A frame, or null if no more frames.	0	1
private static Optional<List<CoreLabel>> getValidEntityChunk(SemanticGraph parse, IndexedWord root, Optional<String> noopArc) { return getValidChunk(parse, root, VALID_ENTITY_ARCS, noopArc); }	@return If this subtree is a valid entity, we return its yield. Otherwise, we return empty.	0	1
@Override public Map<String, DatatypeValidator> getBuiltInTypes() { return new HashMap<>(fBuiltInTypes); }	@return a hashtable which contains all datatypes	1	0
public AnsiClazzes processCode(String code) { if (code == null || code.length() < NUM) return null; if (code.charAt(NUM) != STR && code.charAt(code.length() - NUM) != STR) return null; if (code.length() == NUM) { clazzes_.clear(); blockClazzes_.clear(); return null; } int extendedColor = NUM; boolean extendedMarkerSeen = false; boolean extendedRGBMarkerSeen = false; int extendedRGBColorsSeen = NUM; String[] tokens = code.substring(NUM, code.length() - NUM).split(STR); for (String token : tokens) { int codeVal = StringUtil.parseInt(token, -NUM); if (codeVal == -NUM) continue; if (extendedColor > NUM) { if (!extendedMarkerSeen && !extendedRGBMarkerSeen) { if (codeVal == EXT_BY_INDEX) { extendedMarkerSeen = true; continue; } else if (codeVal == EXT_BY_RGB) { extendedRGBMarkerSeen = true; extendedRGBColorsSeen = NUM; } else { clazzes_.clear(); blockClazzes_.clear(); return null; } } else { if (extendedRGBMarkerSeen) { extendedRGBColorsSeen++; if (extendedRGBColorsSeen == NUM) { extendedColor = NUM; extendedRGBMarkerSeen = false; extendedRGBColorsSeen = NUM; } } else { if (extendedColor == FOREGROUND_EXT) { if (codeVal >= NUM && codeVal <= NUM) { currentColor_.setExtended(codeVal); resetForeground(); clazzes_.add(Color.clazzForColorIndex(codeVal, false)); } } else { if (codeVal >= NUM && codeVal <= NUM) { currentBgColor_.setExtended(codeVal); resetBackground(); clazzes_.add(Color.clazzForColorIndex(codeVal, true)); } } extendedColor = NUM; extendedMarkerSeen = false; } } } else if (codeVal == RESET) { inverted_ = false; currentColor_.reset(); currentBgColor_.reset(); clazzes_.clear(); blockClazzes_.clear(); } else if (codeVal == BOLD) { clazzes_.add(BOLD_STYLE); } else if (codeVal == BLURRED) { } else if (codeVal == BOLD_BLURRED_OFF) { clazzes_.remove(BOLD_STYLE); } else if (codeVal == ITALIC) { clazzes_.add(ITALIC_STYLE); } else if (codeVal == ITALIC_OFF) { clazzes_.remove(ITALIC_STYLE); } else if (codeVal == UNDERLINE) { clazzes_.add(UNDERLINE_STYLE); } else if (codeVal == UNDERLINE_OFF) { clazzes_.remove(UNDERLINE_STYLE); } else if (codeVal == BLINKSLOW || codeVal == BLINKFAST) { clazzes_.add(BLINK_STYLE); } else if (codeVal == BLINK_OFF) { clazzes_.remove(BLINK_STYLE); } else if (codeVal == INVERSE) { if (!inverted_) { resetForeground(); resetBackground(); Color newFg = invertFgColor(); Color newBg = invertBgColor(); currentColor_ = newFg; currentBgColor_ = newBg; inverted_ = true; } } else if (codeVal == INVERSE_OFF) { if (inverted_) { resetForeground(); resetBackground(); Color newFg = invertFgColor(); Color newBg = invertBgColor(); currentColor_ = newFg; currentBgColor_ = newBg; inverted_ = false; } } else if (codeVal == HIDDEN) { clazzes_.add(HIDDEN_STYLE); } else if (codeVal == HIDDEN_OFF) { clazzes_.remove(HIDDEN_STYLE); } else if (codeVal == STRIKETHROUGH) { clazzes_.add(STRIKETHROUGH_STYLE); } else if (codeVal == STRIKETHROUGH_OFF) { clazzes_.remove(STRIKETHROUGH_STYLE); } else if (Color.isFgColorCode(codeVal)) { currentColor_.setCode(codeVal); resetForeground(); clazzes_.add(clazzForColor(codeVal)); } else if (Color.isBgColorCode(codeVal)) { currentBgColor_ = new Color(false, codeVal); resetBackground(); clazzes_.add(clazzForBgColor(codeVal)); } else if (codeVal == RESET_FOREGROUND) { currentColor_.reset(); resetForeground(); } else if (codeVal == RESET_BACKGROUND) { currentBgColor_.reset(); resetBackground(); } else if (codeVal == FOREGROUND_EXT) { extendedColor = codeVal; extendedMarkerSeen = false; } else if (codeVal == BACKGROUND_EXT) { extendedColor = codeVal; extendedMarkerSeen = false; } else if (codeVal == FONT_NINE) { blockClazzes_.add(FONT_NINE_STYLE); } else if (codeVal == DEFAULT_FONT || (codeVal >= FONT_ONE && codeVal <= FONT_EIGHT)) { blockClazzes_.remove(FONT_NINE_STYLE); } else { } } return getStyles(); }	@return Clazzes or null if no color classes were applied	1	0
"public static Platform fromString(String name) { try { return Platform.valueOf(name); } catch (IllegalArgumentException ex) { for (Platform os : Platform.values()) { for (String matcher : os.partOfOsName) { if (name.toLowerCase().equals(matcher.toLowerCase())) { return os; } } } throw new WebDriverException(""Unrecognized platform: "" + name); } }"	@return the Platform enum value matching the parameter	0	1
public static SecureConnectionMode parse(String value, String defaultValue) { SecureConnectionMode mode = parse(value); if (mode == null && defaultValue != null) { mode = parse(defaultValue); } return mode; }	@return the matching option, or null if no match is found	1	0
private IAnnotationModel createExternalSearchAnnotationModel(ExternalEditorInput externalInput) { IStorage storage = externalInput.getStorage(); IResource markerResource = externalInput.getMarkerResource(); return createExternalSearchAnnotationModel(storage, markerResource); }	@return a new annotation model for the editor input	1	0
private Connection handleRedirect(IBasicRequest oldRequest, Headers responseHeaders) { IBasicRequest redirectRequest = null; RedirectHandler redirectHandler = oldRequest.getRedirectHandler(); if (redirectHandler != null) { if (redirectHandler.isDisallowedRedirect(responseHeaders)) return new Connection(null, responseHeaders, null, null); else redirectRequest = redirectHandler.onRedirect(responseHeaders); } if (redirectRequest == null) { redirectRequest = new StringRequest(responseHeaders.getLocation(), oldRequest.getRequestMethod()); redirectRequest.setSSLSocketFactory(oldRequest.getSSLSocketFactory()); redirectRequest.setHostnameVerifier(oldRequest.getHostnameVerifier()); redirectRequest.setProxy(oldRequest.getProxy()); } return getConnection(redirectRequest); }	@return {@link ProtocolResult}.	1	0
public ResourceRepo removeResource(Resource resource) { if ((this.resourceRepos == null) || (resource == null)) { return null; } ResourceRepo doomed = null; for (ResourceRepo rc : this.resourceRepos) { if (resource.equals(rc.getResourceRepoPK().getResource())) { doomed = rc; break; } } if (doomed != null) { this.resourceRepos.remove(doomed); } return doomed; }	@return the mapping that was removed or <code>null</code> if the resource was not subscribed to this channel	1	0
public CacheManager getCacheFactory() { return jbcFactory; }	@return Value for property 'cacheFactory'.	0	1
"public Tree transformTree(Tree t) { if (VERBOSE) { System.err.println(""Input to CoordinationTransformer: "" + t); } Tree tx = tn.transformTree(t); if (VERBOSE) { System.err.println(""After DependencyTreeTransformer: "" + tx); } if (tx == null) { return tx; } Tree tt = UCPtransform(tx); if (VERBOSE) { System.err.println(""After UCPTransformer: "" + tt); } Tree ttt = CCtransform(tt); if (VERBOSE) { System.err.println(""After CCTransformer: "" + ttt); } Tree tttt = qp.transformTree(ttt); if (VERBOSE) { System.err.println(""After QPTreeTransformer: "" + tttt); } Tree flatSQ = SQflatten(tttt); if (VERBOSE) { System.err.println(""After SQ flattening: "" + flatSQ); } Tree fixedDates = dates.transformTree(flatSQ); if (VERBOSE) { System.err.println(""After DateTreeTransformer: "" + fixedDates); } Tree ret = removeXOverX(fixedDates); if (VERBOSE) { System.err.println(""After removeXoverX: "" + ret); } return ret; }"	@return t transformed	0	1
public static IType createType(IASTDeclarator declarator) { IASTDeclSpecifier declSpec = null; IASTNode node = declarator.getParent(); while (node instanceof IASTDeclarator) { declarator = (IASTDeclarator) node; node = node.getParent(); } if (node instanceof IASTParameterDeclaration) declSpec = ((IASTParameterDeclaration) node).getDeclSpecifier(); else if (node instanceof IASTSimpleDeclaration) declSpec = ((IASTSimpleDeclaration) node).getDeclSpecifier(); else if (node instanceof IASTFunctionDefinition) declSpec = ((IASTFunctionDefinition) node).getDeclSpecifier(); else if (node instanceof IASTTypeId) declSpec = ((IASTTypeId) node).getDeclSpecifier(); boolean isParameter = (node instanceof IASTParameterDeclaration || node.getParent() instanceof ICASTKnRFunctionDeclarator); IType type = null; if (isParameter && node.getParent().getParent() instanceof IASTFunctionDefinition) { type = createBaseType(declSpec); } else { type = createType(declSpec); } type = createType(type, declarator); if (isParameter) { if (type instanceof IArrayType) { CArrayType at = (CArrayType) type; type = new CQualifiedPointerType(at.getType(), at.getModifier()); } else if (type instanceof IFunctionType) { type = new CPointerType(type); } } return type; }	@return the IType of the IASTName parameter	1	0
public User getUserByName(String username) throws ApiException { ApiResponse<User> localVarResp = getUserByNameWithHttpInfo(username); return localVarResp.getData(); }	@return User	0	1
public ChromeDriverService build() { return (ChromeDriverService) super.build(); }	@return The new binary.	0	1
@Deprecated public String getBodyContents() { return getStringPayload(); }	@return form encoded string	1	0
"public Client call123testSpecialTags(Client body) throws ApiException { Object localVarPostBody = body; // verify the required parameter 'body' is set if (body == null) { throw new ApiException(400, ""Missing the required parameter 'body' when calling call123testSpecialTags""); } // create path and map variables String localVarPath = ""/another-fake/dummy"".replaceAll(""\\{format\\}"",""json""); // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, String> localVarCookieParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { ""application/json"" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { ""application/json"" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Client> localVarReturnType = new GenericType<Client>() {}; return apiClient.invokeAPI(localVarPath, ""PATCH"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }"	@return a Client	0	1
"public boolean applyAPSRequest(APSResult request, Callback callback) { PumpInterface pump = getActivePump(); request.rate = applyBasalConstraints(request.rate); PumpEnactResult result; if (!pump.isInitialized()) { log.debug(""applyAPSRequest: "" + MainApp.sResources.getString(R.string.pumpNotInitialized)); if (callback != null) { callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpNotInitialized)).enacted(false).success(false)).run(); } return false; } if (pump.isSuspended()) { log.debug(""applyAPSRequest: "" + MainApp.sResources.getString(R.string.pumpsuspended)); if (callback != null) { callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpsuspended)).enacted(false).success(false)).run(); } return false; } if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: "" + request.toString()); if ((request.rate == 0 && request.duration == 0) || Math.abs(request.rate - pump.getBaseBasalRate()) < pump.getPumpDescription().basalStep) { if (isTempBasalInProgress()) { if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: cancelTempBasal()""); getCommandQueue().cancelTempBasal(false, callback); return true; } else { if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: Basal set correctly""); if (callback != null) { callback.result(new PumpEnactResult().absolute(request.rate).duration(0).enacted(false).success(true).comment(""Basal set correctly"")).run(); } return false; } } else if (isTempBasalInProgress() && getTempBasalRemainingMinutesFromHistory() > 5 && Math.abs(request.rate - getTempBasalAbsoluteRateHistory()) < pump.getPumpDescription().basalStep) { if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: Temp basal set correctly""); if (callback != null) { callback.result(new PumpEnactResult().absolute(getTempBasalAbsoluteRateHistory()).duration(getTempBasalFromHistory(System.currentTimeMillis()).getPlannedRemainingMinutes()).enacted(false).success(true).comment(""Temp basal set correctly"")).run(); } return false; } else { if (Config.logCongigBuilderActions) log.debug(""applyAPSRequest: setTempBasalAbsolute()""); getCommandQueue().tempBasalAbsolute(request.rate, request.duration, false, callback); return true; } }"	@return true if command is going to be executed false if error	0	1
private static boolean containsItem(Collection<String> itemCollection, String item) { return itemCollection.contains(item.toLowerCase()); }	@return true if itemCollection contains the key, false otherwise.	1	0
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 25: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 32: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 33: break; case 12: { final String origTxt = yytext(); return getNext(asciiQuotes(origTxt), origTxt); } case 34: break; case 15: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 35: break; case 10: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { String origTxt = yytext(); return getNext(asciiDash(origTxt), origTxt); } } case 36: break; case 1: { String str = yytext(); int first = str.charAt(0); String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } LOGGER.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: LOGGER.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 37: break; case 27: // lookahead expression with fixed lookahead length yypushback(2); { return getNext(); } case 38: break; case 24: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 39: break; case 23: // general lookahead, find correct zzMarkedPos { int zzFState = 1; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 2; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 40: break; case 18: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(); } case 41: break; case 4: { return getNext(); } case 42: break; case 28: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 43: break; case 7: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 44: break; case 9: { return handleEllipsis(yytext()); } case 45: break; case 17: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 46: break; case 2: { if (normalizeOtherBrackets) { return getNext(openparen, yytext()); } else { return getNext(); } } case 47: break; case 30: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } return getNext(txt, yytext()); } case 48: break; case 14: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 49: break; case 11: { return normalizeFractions(yytext()); } case 50: break; case 31: { String txt = yytext(); if (normalizeParentheses) { txt = txt.replaceAll(""\\("", openparen); txt = txt.replaceAll(""\\)"", closeparen); } return getNext(txt, yytext()); } case 51: break; case 26: { return getNormalizedAmpNext(); } case 52: break; case 22: // general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String txt = asciiQuotes(origTxt); return getNext(asciiDash(txt), origTxt); } case 53: break; case 20: { // this one should only match if we're basically at the end of file // since the last one matches two things, even newlines String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 54: break; case 8: { if (invertible) { prevWordAfter.append(yytext()); } } case 55: break; case 29: { yypushback(3) ; return getNext(); } case 56: break; case 3: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 57: break; case 21: { final String origTxt = yytext(); return getNext(asciiDash(origTxt), origTxt); } case 58: break; case 13: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 59: break; case 19: { if (!noSGML) { return getNext(); } } case 60: break; case 6: { if (normalizeOtherBrackets) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 61: break; case 16: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 62: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }"	@return the next token	0	1
public static int getKeyLength(AsymmetricKeyParameter keyParams) { if (keyParams instanceof RSAKeyParameters) { return ((RSAKeyParameters) keyParams).getModulus().bitLength(); } else if (keyParams instanceof DSAKeyParameters) { return ((DSAKeyParameters) keyParams).getParameters().getP().bitLength(); } else if (keyParams instanceof DHKeyParameters) { return ((DHKeyParameters) keyParams).getParameters().getP().bitLength(); } else if (keyParams instanceof ECKeyParameters) { return UNKNOWN_KEY_SIZE; } LOG.warning(STR + keyParams); return UNKNOWN_KEY_SIZE; }	@return The key size	1	0
public boolean isRcsAssociated(final String phoneNumber) { boolean result = false; Cursor cur = ctx.getContentResolver().query(RichAddressBookData.CONTENT_URI, new String[] { RichAddressBookData.KEY_CONTACT_NUMBER }, RichAddressBookData.KEY_CONTACT_NUMBER + STR, new String[] { phoneNumber }, null); if (cur != null) { if (cur.moveToFirst()) { result = true; } cur.close(); } else { result = false; } return result; }	@return true if contact is associated to a RCS raw contact, else false	1	0
public TreeGraphNode headWordNode() { return safeCast(label.get(TreeCoreAnnotations.HeadWordAnnotation.class)); }	@return the node containing the head word for this node	0	1
public boolean isStarting() { return status.get() == STARTING; }	@return true if the Connection is starting	0	1
public static Context getContext() { testInitialize(); return sContext; }	@return {@link Application}.	1	0
public ArrayList<VersionApk> getVersions() { ArrayList<VersionApk> versions = new ArrayList<VersionApk>(); try { NodeList nl = dom.getElementsByTagName(STR); if (nl != null && nl.getLength() > NUM) { for (int i = NUM; i < nl.getLength(); i++) { versions.add(new VersionApk(getVersionTagText(i, STR, nl), getVersionTagText(i, STR, nl), getVersionTagText(i, STR, nl))); } } } catch (MalformedURLException e) { e.printStackTrace(); } return versions; }	@return A hashtable with keys String (VAlues.toString()) and with values VersionApk	1	0
protected boolean hasCustomerRevealAnimator() { return true; }	@return True if you don't want use Android native reveal animator in order to use your own custom one	0	1
public final Location doGeoLookup(final String ip) { Location location = null; Integer ipAddressType = determineIpAddressType(ip); switch(ipAddressType) { case NUM: location = ip4Lookup.getLocation(ip); break; case NUM: location = ip6Lookup.getLocationV6(ip); break; default: break; } return location; }	@return Tuple containing the requested the geocoded field	1	0
public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws ApiException { return uploadFileWithRequiredFileWithHttpInfo(petId, requiredFile, additionalMetadata).getData(); }	@return ModelApiResponse	0	1
protected Object convertBigInt(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0L; } if (data instanceof Long) return data; if (data instanceof Number) { Number value = (Number) data; return new Long(value.longValue()); } if (data instanceof Boolean) { return NumberConversions.getLong((Boolean) data); } return handleUnknownData(column, fieldDefn, data); }	@return the converted value, or null if the conversion could not be made and the column allows nulls	0	1
private ColumnState buildMap(ContainerState parent, ColumnReadProjection colProj) { ColumnMetadata columnSchema = colProj.providedSchema(); // When dynamically adding columns, must add the (empty) // map by itself, then add columns to the map via separate // calls. assert columnSchema.isMap(); assert columnSchema.mapSchema().size() == 0; // Create the vector, vector state and writer. if (columnSchema.isArray()) { return buildMapArray(parent, colProj); } else { return buildSingleMap(parent, colProj); } }	@return column state for the map column	0	1
"public ApiResponse uploadFile (Long petId, String additionalMetadata, File file) throws ApiException { Object localVarPostBody = null; // verify the required parameter 'petId' is set if (petId == null) { throw new ApiException(400, ""Missing the required parameter 'petId' when calling uploadFile""); } // create path and map variables String localVarPath = ""/pet/{petId}/uploadImage"".replaceAll(""\\{format\\}"",""json"").replaceAll(""\\{"" + ""petId"" + ""\\}"", apiInvoker.escapeString(petId.toString())); // query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); // header params Map<String, String> localVarHeaderParams = new HashMap<String, String>(); // form params Map<String, String> localVarFormParams = new HashMap<String, String>(); String[] localVarContentTypes = { ""multipart/form-data"" }; String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : ""application/json""; if (localVarContentType.startsWith(""multipart/form-data"")) { // file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); if (additionalMetadata != null) { localVarBuilder.addTextBody(""additionalMetadata"", ApiInvoker.parameterToString(additionalMetadata), ApiInvoker.TEXT_PLAIN_UTF8); } if (file != null) { localVarBuilder.addBinaryBody(""file"", file); } localVarPostBody = localVarBuilder.build(); } else { // normal form params localVarFormParams.put(""additionalMetadata"", ApiInvoker.parameterToString(additionalMetadata)); } try { String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, ""POST"", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType); if(localVarResponse != null){ return (ApiResponse) ApiInvoker.deserialize(localVarResponse, """", ApiResponse.class); } else { return null; } } catch (ApiException ex) { throw ex; } }"	@return void	1	0
public static List getEditorSearchPath() { String[] paths = PropertyEditorManager.getEditorSearchPath(); List pathList = new ArrayList(paths.length); for (int i = NUM; i < paths.length; i++) { pathList.add(paths[i]); } return pathList; }	@return The package names that will be searched for property editors.	1	0
public String getName() { String name = path.getFileName().toString(); if (name.toLowerCase().endsWith(Aes256Cryptor.FOLDER_EXTENSION.toLowerCase())) { name = name.substring(0, name.length() - Aes256Cryptor.FOLDER_EXTENSION.length()); } return name; }	@return Directory name without preceeding path components	0	1
"public static int getIEVersion(WebDriver driver) { String userAgent = getUserAgent(driver); // extract browser string Pattern browserPattern = Pattern.compile(""MSIE\\s+\\d+\\.""); Matcher browserMatcher = browserPattern.matcher(userAgent); // IE dropped the ""MSIE"" token from its user agent string starting with IE11. Pattern tridentPattern = Pattern.compile(""Trident/\\d+\\.""); Matcher tridentMatcher = tridentPattern.matcher(userAgent); Matcher versionMatcher; if (browserMatcher.find()) { versionMatcher = Pattern.compile(""(\\d+)"").matcher(browserMatcher.group()); } else if (tridentMatcher.find()) { versionMatcher = Pattern.compile(""rv:(\\d+)"").matcher(userAgent); } else { return 0; } // extract version string if (!versionMatcher.find()) { return 0; } return Integer.parseInt(versionMatcher.group(1)); }"	@return The found version, or 0 if no version could be found.	0	1
public synchronized Media getMediaAt(int index) { if (index < NUM || index >= getCount()) throw new IndexOutOfBoundsException(); final Media media = mMediaArray.get(index); media.retain(); return media; }	@return Media hold by MediaList, Should NOT be released.	1	0
public static AdditionalFieldPlacement parse(String value) { if (value == null) { return null; } value = value.trim(); for (AdditionalFieldPlacement option : AdditionalFieldPlacement.values()) { if (option.getValue().equalsIgnoreCase(value)) { return option; } } return null; }	@return the matching option, or null if no match is found and the non-null default is invalid	1	0
"Action action(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException { if (!Utils.properProtocol(req)) { logger.debug(""Invalid request state.""); res.setStatus(501); res.addHeader(X_ATMOSPHERE_ERROR, ""Websocket protocol not supported""); res.flushBuffer(); return new Action(); } if (Utils.webSocketEnabled(req) && !supportWebSocket()) { logger.warn(""Websocket protocol not supported""); res.setStatus(501); res.addHeader(X_ATMOSPHERE_ERROR, ""Websocket protocol not supported""); res.flushBuffer(); return new Action(); } if (config.handlers().isEmpty()) { logger.error(""No AtmosphereHandler found. Make sure you define it inside WEB-INF/atmosphere.xml or annotate using @___Service""); throw new AtmosphereMappingException(""No AtmosphereHandler found. Make sure you define it inside WEB-INF/atmosphere.xml or annotate using @___Service""); } if (res.request() == null) { res.request(req); } if (supportSession()) { // Create the session needed to support the Resume // operation from disparate requests. HttpSession s = req.getSession(config.getInitParameter(PROPERTY_SESSION_CREATE, true)); if (s != null && s.isNew()) { s.setAttribute(FrameworkConfig.BROADCASTER_FACTORY, config.getBroadcasterFactory()); } } req.setAttribute(FrameworkConfig.SUPPORT_SESSION, supportSession()); int tracing = 0; AtmosphereHandlerWrapper handlerWrapper = map(req); if (config.getBroadcasterFactory() == null) { logger.error(""Atmosphere is misconfigured and will not work. BroadcasterFactory is null""); return Action.CANCELLED; } AtmosphereResourceImpl resource = configureWorkflow(null, handlerWrapper, req, res); String v = req.getHeader(HeaderConfig.X_ATMO_BINARY); if (v != null) { resource.forceBinaryWrite(Boolean.valueOf(v)); } // handler interceptor lists Action a = invokeInterceptors(handlerWrapper.interceptors, resource, tracing); if (a.type() != Action.TYPE.CONTINUE && a.type() != Action.TYPE.SKIP_ATMOSPHEREHANDLER) { return a; } // Remap occured. if (req.getAttribute(FrameworkConfig.NEW_MAPPING) != null) { req.removeAttribute(FrameworkConfig.NEW_MAPPING); handlerWrapper = map(req); if (handlerWrapper == null) { logger.debug(""Remap {}"", resource.uuid()); throw new AtmosphereMappingException(""Invalid state. No AtmosphereHandler maps request for "" + req.getRequestURI()); } resource = configureWorkflow(resource, handlerWrapper, req, res); resource.setBroadcaster(handlerWrapper.broadcaster); } //Unit test mock the request and will throw NPE. boolean skipAtmosphereHandler = req.getAttribute(SKIP_ATMOSPHEREHANDLER.name()) != null ? (Boolean) req.getAttribute(SKIP_ATMOSPHEREHANDLER.name()) : Boolean.FALSE; if (!skipAtmosphereHandler) { try { logger.trace(""\t Last: {}"", handlerWrapper.atmosphereHandler.getClass().getName()); handlerWrapper.atmosphereHandler.onRequest(resource); } catch (IOException t) { resource.onThrowable(t); throw t; } } postInterceptors(handlerWrapper.interceptors, resource); Action action = resource.action(); if (supportSession() && allowSessionTimeoutRemoval() && action.type().equals(Action.TYPE.SUSPEND)) { // Do not allow times out. SessionTimeoutSupport.setupTimeout(config, req.getSession(config.getInitParameter(ApplicationConfig.PROPERTY_SESSION_CREATE, true))); } logger.trace(""Action for {} was {} with transport "" + req.getHeader(X_ATMOSPHERE_TRANSPORT), req.resource() != null ? req.resource().uuid() : ""null"", action); return action; }"	@return action the Action operation.	0	1
public Float getRightValue() { return rightValue; }	@return The value of the 'right' CSS-attribute	1	0
"public static SchemaPath parseFromString(String expr) { if (expr == null || expr.isEmpty()) { return null; } if (SchemaPath.DYNAMIC_STAR.equals(expr)) { return SchemaPath.getSimplePath(expr); } LogicalExpression logicalExpression = LogicalExpressionParser.parse(expr); if (logicalExpression instanceof SchemaPath) { return (SchemaPath) logicalExpression; } else { throw new IllegalStateException(String.format(""Schema path is not a valid format: %s."", logicalExpression)); } }"	@return SchemaPath instance	0	1
"public String[] getAttributeFromAllWindows(String attributeName) { String current = driver.getWindowHandle(); List<String> attributes = new ArrayList<String>(); for (String handle : driver.getWindowHandles()) { driver.switchTo().window(handle); String value = (String) ((JavascriptExecutor) driver).executeScript( ""return '' + window[arguments[0]];"", attributeName); attributes.add(value); } driver.switchTo().window(current); return attributes.toArray(new String[attributes.size()]); }"	@return the set of values of this attribute from all known windows.	0	1
public Task<EncodedImage> get(CacheKey key, AtomicBoolean isCancelled) { final EncodedImage pinnedImage = mStagingArea.get(key); if (pinnedImage != null) { return foundPinnedImage(key, pinnedImage); } return getAsync(key, isCancelled); }	@return ListenableFuture that resolves to cached element or null if one cannot be retrieved; returned future never rethrows any exception	1	0
protected int getInSubqueryThreshold() { return IN_SUBQUERY_THRESHOLD; }	@return threshold, default 20	1	0
public Double memory(RelNode rel) { for (;;) { try { return memoryHandler.memory(rel, this); } catch (JaninoRelMetadataProvider.NoHandler e) { memoryHandler = metadataProvider.revise(e.relClass, BuiltInMetadata.Memory.DEF); } } }	@return the expected amount of memory, in bytes, required by a physical operator implementing this relational expression, across all splits, or null if not known	0	1
public JSONObject getJSONObject(String key) { Object object = this.get(key); if (object == null) { return null; } if (object instanceof JSONObject) { return (JSONObject) object; } throw new RuntimeException(STR + quote(key) + STR); }	@return A JSONObject which is the value.	1	0
"private String getEscapedValue(String value) { if (value != null) { try { return URLEncoder.encode(value, ""UTF-8""); } catch ( UnsupportedEncodingException ex) { } } return """"; }"	@return the Encoded value	0	1
public boolean is(Platform compareWith) { return // Any platform is itself this == compareWith || // Any platform is also ANY platform compareWith == ANY || // And any Platform which is not a platform type belongs to the same family (this.family() != null && this.family().is(compareWith)); }	@return true if platforms are approximately similar, false otherwise	0	1
"private ZapTextField getTxtHeadline() { if (txtHeadline == null) { txtHeadline = new ZapTextField(); txtHeadline.setBorder(javax.swing.BorderFactory.createEtchedBorder(javax.swing.border.EtchedBorder.RAISED)); txtHeadline.setEditable(false); txtHeadline.setEnabled(false); txtHeadline.setBackground(java.awt.Color.white); txtHeadline.setFont(new java.awt.Font(""Default"", java.awt.Font.BOLD, 12)); } return txtHeadline; }"	@return javax.swing.JTextField	1	0
public Criterion eqCaseInsensitive(String value) { if (value == null) { return isNull(); } return new CaseInsensitiveEqualsCriterion(this, Operator.eq, value); }	@return a {@link Criterion} that the field must be equal to the given string, ignoring case. Due to a bug in sqlite, this will only work for ASCII characters.	1	0
public SqlNode getTargetTable() { return targetTable; }	@return the identifier for the target table of the insertion	0	1
protected boolean isOutOfRange(int year, int month, int day) { if (mController.getSelectableDays() != null) { return !isSelectable(year, month, day); } if (isBeforeMin(year, month, day)) { return true; } else if (isAfterMax(year, month, day)) { return true; } return false; }	@return true if the specified year/month/day are within the range set by minDate and maxDate. If one or either have not been set, they are considered as Integer.MIN_VALUE and Integer.MAX_VALUE.	1	0
public static String getMessageId(SipRequest request) { String result = null; try { String content = request.getContent(); int index = content.indexOf(ImdnUtils.HEADER_IMDN_MSG_ID); if (index != -NUM) { index = index + ImdnUtils.HEADER_IMDN_MSG_ID.length() + NUM; String part = content.substring(index); String msgId = part.substring(NUM, part.indexOf(CRLF)); result = msgId.trim(); } } catch (Exception e) { } return result; }	@return String or empty	1	0
public static Drawable mockDrawable() { return mockDrawable(FakeDrawable.class); }	@return mock Drawable	0	1
public Chat dccSendChatRequest(User sender, int timeout) throws IOException, SocketTimeoutException { return dccHandler.sendChatRequest(sender); }	@return a DccChat object that can be used to send and recieve lines of text. Returns <b>null</b> if the connection could not be made.	1	0
public BooleanExpression equalsIgnoreCase(String str) { return equalsIgnoreCase(new StringConstant(str)); }	@return this.equalsIgnoreCase(str)	0	1
public PlaceType getPlaceType(String placeTypeName) throws InvalidPlaceType { PlaceType type = placeTypeNameCache.get(placeTypeName); if (type == null) throw new InvalidPlaceType(placeTypeName); return type; }	@return the PlaceType corresponding to the provided name, or null.	1	0
public HttpSession getSelectedSession() { final int selectedRow = this.sessionsTable.getSelectedRow(); if (selectedRow == -1) { // No row selected return null; } final int rowIndex = sessionsTable.convertRowIndexToModel(this.sessionsTable.getSelectedRow()); return this.sessionsModel.getHttpSessionAt(rowIndex); }	@return the selected session, or null if nothing is selected	0	1
public ScalewayCloud getCloud() { Jenkins instance = Jenkins.getInstance(); if (instance != null) { return (ScalewayCloud) instance.getCloud(cloudName); } return null; }	@return the Cloud associated with the specified cloudName	1	0
public boolean hasDataTypeInIdentityColumn() { return getIdentityColumnSupport().hasDataTypeInIdentityColumn(); }	@return boolean	0	1
@Override public ActivityOptions getActivityLaunchOptions(Launcher launcher, View v) { if (hasControlRemoteAppTransitionPermission()) { try { RemoteAnimationRunnerCompat runner = new LauncherAnimationRunner(mHandler) { @Override public AnimatorSet getAnimator(RemoteAnimationTargetCompat[] targetCompats) { AnimatorSet anim = new AnimatorSet(); if (!composeRecentsLaunchAnimator(v, targetCompats, anim)) { mLauncher.getStateManager().setCurrentAnimation(anim); anim.play(getIconAnimator(v)); if (launcherIsATargetWithMode(targetCompats, MODE_CLOSING)) { anim.play(getLauncherContentAnimator(false)); } anim.play(getWindowAnimators(v, targetCompats)); } return anim; } }; int duration = findTaskViewToLaunch(launcher, v, null) != null ? RECENTS_LAUNCH_DURATION : APP_LAUNCH_DURATION; int statusBarTransitionDelay = duration - STATUS_BAR_TRANSITION_DURATION; return ActivityOptionsCompat.makeRemoteAnimation(new RemoteAnimationAdapterCompat(runner, duration, statusBarTransitionDelay)); } catch (NoClassDefFoundError e) { } } return getDefaultActivityLaunchOptions(launcher, v); }	@return A Bundle with remote animations that controls how the window of the opening targets are displayed.	1	0
public static String quantityToRSDecimalStack(int quantity, boolean precise) { String quantityStr = String.valueOf(quantity); if (quantityStr.length() <= 4) { return quantityStr; } int power = (int) Math.log10(quantity); // Output thousandths for values above a million NumberFormat format = precise && power >= 6 ? PRECISE_DECIMAL_FORMATTER : DECIMAL_FORMATTER; return format.format(quantity / (Math.pow(10, (power / 3) * 3))) + SUFFIXES[power / 3]; }	@return The stack size as it would appear in RS, with decimals, with K after 100,000 and M after 10,000,000	0	1
public JFrame getParentFrame() { if (lastInvoker != null) { return (JFrame) SwingUtilities.getAncestorOfClass(JFrame.class, lastInvoker); } return null; }	@return Returns the parentFrame.	0	1
public static ReferenceResult findReferencedMembers(FieldInfo fieldInfo) { Set<String> members = new HashSet<String>(); ClassMemberVisitor visitor = new ClassMemberVisitor(members); Set<Integer> ids = findPoolReferences(fieldInfo); visitor.visitField(fieldInfo); visitPoolReferences(fieldInfo.getClassInfo(), visitor, ids); return new ReferenceResult(members, new ArrayList<InvokeSite>(NUM)); }	@return a set of class names and class member signatures found in the class.	1	0
public String toModelName(final String name) { return initialCaps(modelNamePrefix + name + modelNameSuffix); }	@return capitalized model name	0	1
public DateTimeFormatterBuilder appendTimeZoneName() { return append0(new TimeZonePrinter(false), null); }	@return this DateTimeFormatterBuilder	0	1
public static Action resolve(Schema writer, Schema reader, GenericData data) { return resolve(writer, reader, data, new HashMap<>()); }	@return Nested actions for resolving the two	0	1
@RequestMapping(value = STR, method = { RequestMethod.PUT }) @ResponseBody public CubeRequest updateCubeDesc(@RequestBody CubeRequest cubeRequest) throws JsonProcessingException { CubeDesc desc = deserializeCubeDesc(cubeRequest); CubeDesc oldCubeDesc = null; if (desc == null) { return cubeRequest; } if (!cubeService.isCubeDescEditable(desc)) { String error = STR + desc.getName(); updateRequest(cubeRequest, false, error); return cubeRequest; } if (!cubeRequest.getCubeName().equalsIgnoreCase(CubeService.getCubeNameFromDesc(desc.getName()))) { deleteCube(cubeRequest.getCubeName()); saveCubeDesc(cubeRequest); } String projectName = (null == cubeRequest.getProject()) ? ProjectInstance.DEFAULT_PROJECT_NAME : cubeRequest.getProject(); try { CubeInstance cube = cubeService.getCubeManager().getCube(cubeRequest.getCubeName()); oldCubeDesc = cube.getDescriptor(); desc = cubeService.updateCubeAndDesc(cube, desc, projectName); } catch (AccessDeniedException accessDeniedException) { throw new ForbiddenException(STR); } catch (Exception e) { logger.error(STR + e.getLocalizedMessage(), e); throw new InternalErrorException(STR + e.getLocalizedMessage()); } if (!desc.getError().isEmpty()) { logger.warn(STR + desc.getName() + STR + desc.getError()); updateRequest(cubeRequest, false, omitMessage(desc.getError())); return cubeRequest; } String descData = JsonUtil.writeValueAsIndentString(desc); cubeRequest.setCubeDescData(descData); cubeRequest.setSuccessful(true); return cubeRequest; }	@return cubeRequest cube change request	1	0
"protected long[] executeBatchInternal() throws SQLException { for (int i = 0; i < connection.maxRetriesPerExecute; i++) { try { return connection.prepareAndUpdateBatch(this, batchedSql).updateCounts; } catch (NoSuchStatementException e) { resetStatement(); } } throw new RuntimeException(""Failed to successfully execute batch update after "" + connection.maxRetriesPerExecute + "" attempts""); }"	@return an array of integers mapping to the update count per SQL command.	1	0
public Iterator getPorts() throws ServiceException { if (wsdlService == null || wsdlService.getPorts() == null) { return new Vector().iterator(); } return wsdlService.getPorts().keySet().iterator(); }	@return Iterator The ports specified in the WSDL file	1	0
private JsonNode catIndices(Collection<String> indices, String... fields) { final String fieldNames = String.join(STR, fields); final Cat request = new Cat.IndicesBuilder().addIndex(indices).setParameter(STR, fieldNames).build(); final CatResult response = JestUtils.execute(jestClient, request, () -> STR + indices); return response.getJsonObject().path(STR); }	@return A {@link JsonArray} with the result of the cat indices request.	1	0
public static int hashCode(boolean v) { return Boolean.hashCode(v); }	@return Hash code	0	1
"public static String getPrincipalFromParts(final String primary, final String instance, final String realm) { checkNotNull(primary); checkNotNull(realm); return primary + ((instance != """") ? ""/"" + instance : """") + ""@"" + realm; }"	@return principal of format primary/instance@REALM	1	0
public long getRequestContentLength() { String contentLengthString = requestHeaders.getFirst(Headers.CONTENT_LENGTH); if (contentLengthString == null) { return -NUM; } return Long.parseLong(contentLengthString); }	@return The content length of the request, or <code>null</code> if it has not been set	1	0
public Actions clickAndHold(WebElement target) { if (isBuildingActions()) { action.addAction(new ClickAndHoldAction(jsonMouse, (Locatable) target)); return this; } return moveToElement(target).clickAndHold(); }	@return A self reference.	0	1
public Element[] getElements(String name) { Element[] elems = (Element[]) m_elements.get(name.toLowerCase()); return elems; }	@return the resulting element array (empty if the search failed)	1	0
public Options useAstDefinitions(boolean flag) { return new Options(this.includeIntrospectionTypes, this.includeScalars, this.includeExtendedScalars, this.includeSchemaDefinition, this.includeDirectives, flag, this.descriptionsAsHashComments, this.comparatorRegistry); }	@return new instance of options	0	1
"public ArrayList<Word> segmentWords(MatchHeuristic h) throws UnsupportedOperationException { if(lattice==null || len < 0) throw new UnsupportedOperationException(""segmentWords must be run first""); List<Word> segmentedWords = new ArrayList<>(); // Init dynamic programming: double[] costs = new double[len+1]; List<DFSATransition<Word, Integer>> bptrs = new ArrayList<>(); for (int i = 0; i < len + 1; ++i) { bptrs.add(null); } costs[0]=0.0; for (int i=1; i<=len; ++i) costs[i] = Double.MAX_VALUE; // DP: for (int start=0; start<len; ++start) { DFSAState<Word, Integer> fromState = states.get(start); Collection<DFSATransition<Word, Integer>> trs = fromState.transitions(); for (DFSATransition<Word, Integer> tr : trs) { DFSAState<Word, Integer> toState = tr.getTarget(); double lcost = tr.score(); int end = toState.stateID(); //System.err.println(""start=""+start+"" end=""+end+"" word=""+tr.getInput()); if (h == MatchHeuristic.MINWORDS) { // Minimize number of words: if (costs[start]+1 < costs[end]) { costs[end] = costs[start]+lcost; bptrs.set(end, tr); //System.err.println(""start=""+start+"" end=""+end+"" word=""+tr.getInput()); } } else if (h == MatchHeuristic.MAXWORDS) { // Maximze number of words: if (costs[start]+1 < costs[end]) { costs[end] = costs[start]-lcost; bptrs.set(end, tr); } } else { throw new UnsupportedOperationException(""unimplemented heuristic""); } } } // Extract min-cost path: int i=len; while (i>0) { DFSATransition<Word, Integer> tr = bptrs.get(i); DFSAState<Word, Integer> fromState = tr.getSource(); Word word = tr.getInput(); if (!word.word().equals("" "")) segmentedWords.add(0, word); i = fromState.stateID(); } if(DEBUG) { // Print lattice density ([1,+inf[) : if equal to 1, it means // there is only one segmentation using words of the lexicon. double density = edgesNb*1.0/segmentedWords.size(); System.err.println(""latticeDensity: ""+density+"" cost: ""+costs[len]); } return new ArrayList<>(segmentedWords); }"	@return Segmented sentence.	0	1
public SubProjectData getProjectInfo(AbstractProject context) { SubProjectData subProjectData = new SubProjectData(); iterateBuilds(context, projects, subProjectData); subProjectData.getTriggered().removeAll(subProjectData.getDynamic()); subProjectData.getTriggered().removeAll(subProjectData.getFixed()); return subProjectData; }	@return A list containing sets with Projects	1	0
public String getSourceTableName() { return ((source != null) ? source.getTableName() : null); }	@return The name of the table that this column comes from. Null if not a ColumnReference.	1	0
public Collection<IndexedWord> getSiblings(IndexedWord vertex) { IndexedWord parent = this.getParent(vertex); if (parent != null) { Set<IndexedWord> result = wordMapFactory.newSet(); result.addAll(this.getChildren(parent)); result.remove(vertex);//remove this vertex - you're not your own sibling return result; } else { return Collections.emptySet(); } }	@return collection of sibling nodes (does not include vertex) the collection is empty if your parent is null	0	1
public static String deprocess(String str, STextProcessor processor) { if ((str == null) || (str.length() <= NUM)) return str; STextEnvironment env = new STextEnvironment(null, false, STextEnvironment.ORIENT_UNKNOWN); if (!env.isProcessingNeeded()) return str; return STextEngine.fullToLeanText(processor, env, str, null); }	@return string with no directional formatting characters.	1	0
"public Score score(List<Collection<TypedDependency>> system) { int parserCnt = 0; int goldCnt = 0; int parserUnlabeledCnt = 0; int goldUnlabeledCnt = 0; int correctAttachment = 0; int correctUnlabeledAttachment = 0; int labelCnt = 0; int labelCorrect = 0; ClassicCounter<String> unlabeledErrorCounts = new ClassicCounter<String>(); ClassicCounter<String> labeledErrorCounts = new ClassicCounter<String>(); //System.out.println(""Gold size: ""+ goldDeps.size() + "" System size: ""+system.size()); for (int i = 0; i < system.size(); i++) { List<Set<TypedDependency>> l = toSets(system.get(i)); if (ignorePunc) { removeHeadsAssignedToPunc(l.get(0)); removeHeadsAssignedToPunc(l.get(1)); } parserCnt += l.get(0).size(); goldCnt += goldDeps.get(i).size(); parserUnlabeledCnt += l.get(1).size(); goldUnlabeledCnt += goldDepsUnlabeled.get(i).size(); l.get(0).retainAll(goldDeps.get(i)); l.get(1).retainAll(goldDepsUnlabeled.get(i)); correctAttachment += l.get(0).size(); correctUnlabeledAttachment += l.get(1).size(); labelCnt += l.get(1).size(); labelCorrect += l.get(0).size(); //System.out.println(""""+i+"" Acc: ""+(l.get(0).size())/(double)localCnt+"" ""+l.get(0).size()+""/""+localCnt); // identify errors List<Set<TypedDependency>> errl = toSets(system.get(i)); errl.get(0).removeAll(goldDeps.get(i)); errl.get(1).removeAll(goldDepsUnlabeled.get(i)); Map<String,String> childCorrectWithLabel = Generics.newHashMap(); Map<String,String> childCorrectWithOutLabel = Generics.newHashMap(); for (TypedDependency goldDep: goldDeps.get(i)) { //System.out.print(goldDep); String sChild = goldDep.dep().label().toString().replaceFirst(""-[^-]*$"", """"); String prefixLabeled = """"; String prefixUnlabeled = """"; if (childCorrectWithLabel.containsKey(sChild)) { prefixLabeled = childCorrectWithLabel.get(sChild)+"", ""; prefixUnlabeled = childCorrectWithOutLabel.get(sChild)+"", ""; } childCorrectWithLabel.put(sChild, prefixLabeled + goldDep.reln()+""(""+goldDep.gov().label().toString().replaceFirst(""-[^-]*$"", """")+"", ""+sChild+"")""); childCorrectWithOutLabel.put(sChild, prefixUnlabeled + ""dep(""+goldDep.gov().label().toString().replaceFirst(""-[^-]*$"", """")+"", ""+sChild+"")""); } for (TypedDependency labeledError: errl.get(0)) { String sChild = labeledError.dep().label().toString().replaceFirst(""-[^-]*$"", """"); String sGov = labeledError.gov().label().toString().replaceFirst(""-[^-]*$"", """"); labeledErrorCounts.incrementCount(labeledError.reln().toString()+""(""+sGov+"", ""+sChild+"") <= ""+childCorrectWithLabel.get(sChild)); } for (TypedDependency unlabeledError: errl.get(1)) { String sChild = unlabeledError.dep().label().toString().replaceFirst(""-[^-]*$"", """"); String sGov = unlabeledError.gov().label().toString().replaceFirst(""-[^-]*$"", """"); unlabeledErrorCounts.incrementCount(""dep(""+sGov+"", ""+sChild+"") <= ""+childCorrectWithOutLabel.get(sChild)); } } return new Score(parserCnt, goldCnt, parserUnlabeledCnt, goldUnlabeledCnt, correctAttachment, correctUnlabeledAttachment, labelCnt, labelCorrect, labeledErrorCounts, unlabeledErrorCounts); }"	@return a triple consisting of (labeled attachment, unlabeled attachment, label accuracy)	0	1
public static Heap createHeap(File heapDump, int segment) throws FileNotFoundException, IOException { return new HprofHeap(createBuffer(heapDump, DEFAULT_BUFFER), segment); }	@return implementation of Heap corresponding to the memory dump passed in heapDump parameter	0	1
public static WebClient getWebClient(HttpServletRequest request) { HttpSession session = request.getSession(true); WebClient client = getWebClient(session); if (client == null || client.isClosed()) { client = WebClient.createWebClient(request); session.setAttribute(webClientAttribute, client); } return client; }	@return the web client for the current HTTP session or null if there is not a web client created yet	1	0
public Struct struct(String databaseName) { this.databaseName = databaseName; return struct((TableId) null); }	@return the source partition and offset Struct; never null	0	1
public BackupResultStatus backupSession(final Session session) { if (_log.isInfoEnabled()) { _log.debug(STR + session.getId()); } final MemcachedBackupSession backupSession = (MemcachedBackupSession) session; final BackupSessionTask task = getOrCreateBackupSessionTask(backupSession); final Map<String, Object> attributes = backupSession.getAttributesInternal(); final byte[] attributesData = _transcoderService.serializeAttributes(backupSession, attributes); final int hashCode = Arrays.hashCode(attributesData); if (backupSession.getDataHashCode() != hashCode || task.sessionCookieWasRelocated()) { final byte[] data = _transcoderService.serialize(backupSession, attributesData); final BackupResult result = task.backupSession(data, attributesData); if (result.getAttributesData() != null) { backupSession.setDataHashCode(Arrays.hashCode(result.getAttributesData())); } return result.getStatus(); } else { return BackupResultStatus.SKIPPED; } }	@return the {@link SessionTrackerValve.SessionBackupService.BackupResult}	1	0
"public JSONObject getJSONObject(String key) { Object object = this.get(key); if (object == null) { return null; } if (object instanceof JSONObject) { return (JSONObject)object; } throw new RuntimeException(""JSONObject["" + quote(key) + ""] is not a JSONObject.""); }"	@return A JSONObject which is the value.	1	0
"public static Path relativize(Path baseDir, Path childPath) { Path fullPathWithoutSchemeAndAuthority = Path.getPathWithoutSchemeAndAuthority(childPath); Path basePathWithoutSchemeAndAuthority = Path.getPathWithoutSchemeAndAuthority(baseDir); // Since hadoop Path hasn't relativize() we use uri.relativize() to get relative path Path relativeFilePath = new Path(basePathWithoutSchemeAndAuthority.toUri() .relativize(fullPathWithoutSchemeAndAuthority.toUri())); if (relativeFilePath.isAbsolute()) { throw new IllegalStateException(String.format(""Path %s is not a subpath of %s."", basePathWithoutSchemeAndAuthority.toUri().getPath(), fullPathWithoutSchemeAndAuthority.toUri().getPath())); } return relativeFilePath; }"	@return relative path	0	1
"public boolean isOrdered(String locator1, String locator2) { return (Boolean) seleneseMethods.get(""isOrdered"").apply(driver, locator1, locator2); }"	@return true if element1 is the previous sibling of element2, false otherwise	0	1
"public Applications getApplications(String serviceUrl) { if (shouldUseExperimentalTransport()) { try { EurekaHttpResponse<Applications> response = clientConfig.getRegistryRefreshSingleVipAddress() == null ? eurekaHttpClient.getApplications() : eurekaHttpClient.getVip(clientConfig.getRegistryRefreshSingleVipAddress()); if (response.getStatusCode() == 200) { logger.debug(PREFIX + appPathIdentifier + "" - refresh status: "" + response.getStatusCode()); return response.getEntity(); } logger.error(PREFIX + appPathIdentifier + "" - was unable to refresh its cache! status = "" + response.getStatusCode()); } catch (Throwable th) { logger.error(PREFIX + appPathIdentifier + "" - was unable to refresh its cache! status = "" + th.getMessage(), th); } } else { ClientResponse response = null; try { response = makeRemoteCall(Action.Refresh); Applications apps = response.getEntity(Applications.class); logger.debug(PREFIX + appPathIdentifier + "" - refresh status: "" + response.getStatus()); return apps; } catch (Throwable th) { logger.error(PREFIX + appPathIdentifier + "" - was unable to refresh its cache! status = "" + th.getMessage(), th); } finally { closeResponse(response); } } return null; }"	@return - The registry information containing all applications.	0	1
public ArrayList<View> getViews() { final Activity activity = soloActivity.getCurrentActivity(); final Dialog currentDialog = dialogUtils.getCurrentDialog(); inst.waitForIdleSync(); final Window window; try { if (currentDialog != null) { window = currentDialog.getWindow(); } else { window = activity.getWindow(); } View decorView = window.getDecorView(); viewList.clear(); getViews(getTopParent(decorView)); return viewList; } catch (Throwable e) { e.printStackTrace(); } return null; }	@return ArrayList with the views found in the current activity	1	0
public static DateTimeFormatter ordinalDate() { return Constants.od; }	@return a formatter for yyyy-DDD	0	1
public Subject login(AuthenticationToken token) throws AuthenticationException { Account account; try { account = authenticate(token); rememberMeSuccessfulLogin(token, account); } catch (AuthenticationException ae) { rememberMeFailedLogin(token, ae); throw ae; } Subject secCtx = createSubject(token, account); assertCreation(secCtx); bind(secCtx); return secCtx; }	@return a SecurityContext representing the authenticated account.	1	0
public BigInteger getNumber() { BigDecimal bigDecimal = getEnteredNumber().setScale(NUM, BigDecimal.ROUND_FLOOR); return bigDecimal.toBigIntegerExact(); }	@return an int representation of the number with no decimal	1	0
public static Collection<IconSet> getRegisteredIconSets() { return REGISTERED_ICON_SETS.values(); }	@return a list of registered FontIconSets.	1	0
protected DimensionValueLoadTask buildDruidDimensionsLoader(DruidWebService webService, PhysicalTableDictionary physicalTableDictionary, DimensionDictionary dimensionDictionary) { DruidDimensionValueLoader druidDimensionRowProvider = new DruidDimensionValueLoader(physicalTableDictionary, dimensionDictionary, webService); return new DimensionValueLoadTask(Collections.singletonList(druidDimensionRowProvider)); }	@return A DruidDimensionsLoader	1	0
public Element writeSchema(Class javaType, Types types) throws Exception { if (!SimpleType.class.isAssignableFrom(javaType)) return null; Element complexType = types.createElement(STR); types.writeSchemaElement(xmlType, complexType); complexType.setAttribute(STR, xmlType.getLocalPart()); Element simpleContent = types.createElement(STR); complexType.appendChild(simpleContent); Element extension = types.createElement(STR); simpleContent.appendChild(extension); String base = STR; for (int i = NUM; i < propertyDescriptor.length; i++) { String propName = propertyDescriptor[i].getName(); if (!propName.equals(STR)) { if (typeDesc != null) { FieldDesc field = typeDesc.getFieldByName(propName); if (field != null) { if (field.isElement()) { } QName qname = field.getXmlName(); if (qname == null) { qname = new QName(STR, propName); } Class fieldType = propertyDescriptor[i].getType(); if (!types.isAcceptableAsAttribute(fieldType)) { throw new AxisFault(Messages.getMessage(STR, propName, fieldType.getName())); } Element elem = types.createAttributeElement(propName, fieldType, field.getXmlType(), false, extension.getOwnerDocument()); extension.appendChild(elem); } } continue; } BeanPropertyDescriptor bpd = propertyDescriptor[i]; Class type = bpd.getType(); if (!types.isAcceptableAsAttribute(type)) { throw new AxisFault(Messages.getMessage(STR, type.getName())); } base = types.writeType(type); extension.setAttribute(STR, base); } return complexType; }	@return true if we wrote a schema, false if we didn't.	1	0
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 35: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, yytext()); } case 50: break; case 8: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 51: break; case 19: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 52: break; case 47: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; // try to work around an apparent jflex bug where it // gets a space at the token end by getting // wrong the length of the trailing context. while (yylength() > 0) { char last = yycharat(yylength()-1); if (last == ' ' || last == '\t' || (last >= '\n' && last <= '\r' || last == '\u0085')) { yypushback(1); } else { break; } } if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 53: break; case 15: { return handleQuotes(yytext(), false); } case 54: break; case 32: // lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), false); } case 55: break; case 24: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 56: break; case 30: // lookahead expression with fixed lookahead length yypushback(1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 57: break; case 44: // lookahead expression with fixed lookahead length yypushback(1); { return getNormalizedAmpNext(); } case 58: break; case 31: { return getNormalizedAmpNext(); } case 59: break; case 34: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, yytext()); } case 60: break; case 48: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 4; { return getNext(); } case 61: break; case 40: // lookahead expression with fixed lookahead length yypushback(2); { return getNext(); } case 62: break; case 38: // general lookahead, find correct zzMarkedPos { int zzFState = 13; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 12; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 63: break; case 37: // general lookahead, find correct zzMarkedPos { int zzFState = 11; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 12; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 64: break; case 4: { return getNext(); } case 65: break; case 21: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(); } case 66: break; case 46: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } return getNext(txt, yytext()); } case 67: break; case 23: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, origTxt); } case 68: break; case 6: { if (normalizeOtherBrackets) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 69: break; case 7: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 70: break; case 28: // general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 71: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 72: break; case 43: { yypushback(2) ; return getNext(); } case 73: break; case 25: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 74: break; case 18: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 75: break; case 49: { String txt = yytext(); if (normalizeSpace) { // txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 76: break; case 45: { yypushback(3) ; return getNext(); } case 77: break; case 22: // lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), true); } case 78: break; case 2: { if (normalizeOtherBrackets) { return getNext(openparen, yytext()); } else { return getNext(); } } case 79: break; case 36: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 80: break; case 20: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 81: break; case 17: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 82: break; case 11: { return handleEllipsis(yytext()); } case 83: break; case 33: // lookahead expression with fixed base length zzMarkedPos = zzStartRead + 1; { /* invert quote - often but not always right */ return handleQuotes(yytext(), true); } case 84: break; case 13: { return normalizeFractions(yytext()); } case 85: break; case 14: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(); } } case 86: break; case 41: // general lookahead, find correct zzMarkedPos { int zzFState = 9; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 10; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 87: break; case 10: { if (invertible) { prevWordAfter.append(yytext()); } } case 88: break; case 3: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 89: break; case 42: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 90: break; case 12: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 91: break; case 27: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 92: break; case 9: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 93: break; case 29: // lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 94: break; case 26: { // this one should only match if we're basically at the end of file // since the last one matches two things, even newlines String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 95: break; case 1: { String str = yytext(); int first = str.charAt(0); String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } LOGGER.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: LOGGER.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 96: break; case 39: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 97: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 98: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }"	@return the next token	0	1
public final FacebookRequestError getError() { return error; }	@return the error encountered, or null if the request succeeded	1	0
protected Object convertRowId(Column column, Field fieldDefn, Object data) { return convertValue(column, fieldDefn, data, BYTE_BUFFER_ZERO, (r) -> { if (data instanceof java.sql.RowId) { java.sql.RowId row = (java.sql.RowId) data; r.deliver(ByteBuffer.wrap(row.getBytes())); } }); }	@return the converted value, or null if the conversion could not be made and the column allows nulls	0	1
public PrototypeFactoryDeprecated getQuestionElementsFactory() { if (questionFactory == null) { questionFactory = new PrototypeFactoryDeprecated(); addAnswerDataPrototype(new DateData()); addAnswerDataPrototype(new IntegerData()); addAnswerDataPrototype(new SelectMultiData()); addAnswerDataPrototype(new SelectOneData()); addAnswerDataPrototype(new StringData()); addAnswerDataPrototype(new TimeData()); } return questionFactory; }	@return a PrototypeFactory containing prototypes for IAnswerData's, IDataReferences, and QuestionDataGroups. If a factory doesn't yet exist, one is created, and default IAnswerData implementing classes are pre-populated.	1	0
public static ActiveMQConnectionFactory createConnectionFactoryWithoutHA(final DiscoveryGroupConfiguration groupConfiguration, JMSFactoryType jmsFactoryType) { ActiveMQConnectionFactory factory = null; if (jmsFactoryType.equals(JMSFactoryType.CF)) { factory = new ActiveMQJMSConnectionFactory(false, groupConfiguration); } else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_CF)) { factory = new ActiveMQQueueConnectionFactory(false, groupConfiguration); } else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_CF)) { factory = new ActiveMQTopicConnectionFactory(false, groupConfiguration); } else if (jmsFactoryType.equals(JMSFactoryType.XA_CF)) { factory = new ActiveMQXAConnectionFactory(false, groupConfiguration); } else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_XA_CF)) { factory = new ActiveMQXAQueueConnectionFactory(false, groupConfiguration); } else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_XA_CF)) { factory = new ActiveMQXATopicConnectionFactory(false, groupConfiguration); } return factory; }	@return the HornetQConnectionFactory	1	0
protected String computeDigest() { RelDigestWriter rdw = new RelDigestWriter(); explain(rdw); return rdw.digest; }	@return Digest	0	1
private ZapTextField getTxtReverseProxyIp() { if (txtReverseProxyIp == null) { txtReverseProxyIp = new ZapTextField(); } return txtReverseProxyIp; }	@return javax.swing.JTextField	1	0
public ErrorDomain getDomain() { return domain; }	@return a VirErrorDomain	1	0
public boolean scrollDown() { return scroll(Direction.DOWN); }	@return true if more scrolling can be done and false if it is at the end of the screen	0	1
@NonNull protected List<Action> retrieveActions(@NonNull SCMHead head, @NonNull SCMHeadEvent event, @NonNull TaskListener listener) throws IOException, InterruptedException { return Collections.emptyList(); }	@return the map of {@link Action} instances to persist, keyed by the class of action. Keys with {@code null} values indicate actions that should be removed if present.	1	0
public boolean isDelicious() { return this.isBaked() || this.isCooked(); }	@return true if this potato is delicious, false if otherwise	0	1
public static String addPropertiesToURIFromBean(String uri, Object bean) throws Exception { Map<String, String> properties = PropertyUtil.getProperties(bean); return PropertyUtil.addPropertiesToURI(uri, properties); }	@return <Code>Map</Code> of properties	1	0
public Collection<OsmPrimitive> getSelected() { return Collections.unmodifiableSet(selectedPrimitives); }	@return List of all selected objects.	1	0
private Object readResolve() { if (iChronology == null) { return new LocalTime(iLocalMillis, ISOChronology.getInstanceUTC()); } if (DateTimeZone.UTC.equals(iChronology.getZone()) == false) { return new LocalTime(iLocalMillis, iChronology.withUTC()); } return this; }	@return the resolved object, not null	0	1
@Nullable public synchronized Habit getHabitByPosition(int position) { if (position < NUM || position >= data.habits.size()) return null; return data.habits.get(position); }	@return the habit at given position	1	0
"long addLocation(String locationSetting, String cityName, double lat, double lon) { long locationId; // First, check if the location with this city name exists in the db Cursor locationCursor = mContext.getContentResolver().query( WeatherContract.LocationEntry.CONTENT_URI, new String[]{WeatherContract.LocationEntry._ID}, WeatherContract.LocationEntry.COLUMN_LOCATION_SETTING + "" = ?"", new String[]{locationSetting}, null); if (locationCursor.moveToFirst()) { int locationIdIndex = locationCursor.getColumnIndex(WeatherContract.LocationEntry._ID); locationId = locationCursor.getLong(locationIdIndex); } else { // Now that the content provider is set up, inserting rows of data is pretty simple. // First create a ContentValues object to hold the data you want to insert. ContentValues locationValues = new ContentValues(); // Then add the data, along with the corresponding name of the data type, // so the content provider knows what kind of value is being inserted. locationValues.put(WeatherContract.LocationEntry.COLUMN_CITY_NAME, cityName); locationValues.put(WeatherContract.LocationEntry.COLUMN_LOCATION_SETTING, locationSetting); locationValues.put(WeatherContract.LocationEntry.COLUMN_COORD_LAT, lat); locationValues.put(WeatherContract.LocationEntry.COLUMN_COORD_LONG, lon); // Finally, insert location data into the database. Uri insertedUri = mContext.getContentResolver().insert( WeatherContract.LocationEntry.CONTENT_URI, locationValues ); // The resulting URI contains the ID for the row. Extract the locationId from the Uri. locationId = ContentUris.parseId(insertedUri); } locationCursor.close(); // Wait, that worked? Yes! return locationId; }"	@return the row ID of the added location.	0	1
private int getColumnCount() { // Initialize currentRow = rowIterator.next(); int rowNumber = readerConfig.headerRow > 0 ? sheet.getFirstRowNum() : 0; // If the headerRow is greater than zero, advance the iterator to the first row of data // This is unfortunately necessary since the streaming reader eliminated the getRow() method. for (int i = 1; i < rowNumber; i++) { currentRow = rowIterator.next(); } return currentRow.getPhysicalNumberOfCells(); }	@return The number of actual columns	0	1
@Override public String toString() { if (stringRep == null) { stringRep = toString(true); } return stringRep; }	@return the signature string	1	0
protected Object convertInteger(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0; } if (data instanceof Integer) return data; if (data instanceof Number) { Number value = (Number) data; return Integer.valueOf(value.intValue()); } if (data instanceof Boolean) { return NumberConversions.getInteger((Boolean) data); } return handleUnknownData(column, fieldDefn, data); }	@return the converted value, or null if the conversion could not be made and the column allows nulls	0	1
protected Object convertBoolean(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return false; } if (data instanceof Boolean) return data; if (data instanceof Short) return ((Short) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE; if (data instanceof Integer) return ((Integer) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE; if (data instanceof Long) return ((Long) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE; return handleUnknownData(column, fieldDefn, data); }	@return the converted value, or null if the conversion could not be made	1	0
"private static List<Column> resolveColumnsFromStreamTupleData(ByteBuffer buffer, TypeRegistry typeRegistry, Table table) { // Read number of the columns short numberOfColumns = buffer.getShort(); List<Column> columns = new ArrayList<>(numberOfColumns); for (short i = 0; i < numberOfColumns; ++i) { final io.debezium.relational.Column column = table.columns().get(i); final String columnName = column.name(); final String typeName = column.typeName(); final PostgresType columnType = typeRegistry.get(typeName); final String typeExpression = column.typeExpression(); final boolean optional = column.isOptional(); // Read the sub-message type // 't' : Value is represented as text // 'u' : An unchanged TOAST-ed value, actual value is not sent. // 'n' : Value is null. char type = (char) buffer.get(); if (type == 't') { final String valueStr = readColumnValueAsString(buffer); columns.add( new AbstractReplicationMessageColumn(columnName, columnType, typeExpression, optional, true) { @Override public Object getValue(PgConnectionSupplier connection, boolean includeUnknownDatatypes) { return PgOutputReplicationMessage.getValue(columnName, columnType, typeExpression, valueStr, connection, includeUnknownDatatypes, typeRegistry); } @Override public String toString() { return columnName + ""("" + typeExpression + "")="" + valueStr; } }); } else if (type == 'u') { columns.add( new UnchangedToastedReplicationMessageColumn(columnName, columnType, typeExpression, optional, true) { @Override public String toString() { return columnName + ""("" + typeExpression + "") - Unchanged toasted column""; } }); } else if (type == 'n') { columns.add( new AbstractReplicationMessageColumn(columnName, columnType, typeExpression, true, true) { @Override public Object getValue(PgConnectionSupplier connection, boolean includeUnknownDatatypes) { return null; } }); } } columns.forEach(c -> LOGGER.trace(""Column: {}"", c)); return columns; }"	@return list of replication message columns	0	1
public static Project createThermalProject(File file) { return createProject(file, THERMAL); }	@return the created project, or null if file was not writable.	1	0
"public static CloseableHttpClient createHttpClient(int maxTotal,int maxPerRoute,int timeout,int retryExecutionCount) { try { SSLContext sslContext = SSLContexts.custom().useSSL().build(); SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(sslContext,SSLConnectionSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER); PoolingHttpClientConnectionManager poolingHttpClientConnectionManager = new PoolingHttpClientConnectionManager(); poolingHttpClientConnectionManager.setMaxTotal(maxTotal); poolingHttpClientConnectionManager.setDefaultMaxPerRoute(maxPerRoute); SocketConfig socketConfig = SocketConfig.custom().setSoTimeout(timeout).build(); poolingHttpClientConnectionManager.setDefaultSocketConfig(socketConfig); HttpClientBuilder builder = HttpClientBuilder.create(); if(proxy != null){ builder.setProxy(proxy); } return builder.setConnectionManager(poolingHttpClientConnectionManager) .setSSLSocketFactory(sf) .setRetryHandler(new HttpRequestRetryHandlerImpl(retryExecutionCount)) .build(); } catch (KeyManagementException e) { logger.error("""", e); } catch (NoSuchAlgorithmException e) { logger.error("""", e); } return null; }"	@return CloseableHttpClient	0	1
private boolean nonValueAnno(AnnotatedTypeMirror mirror) { AnnotationMirror valueAnno = getValueAnnotation(mirror); return AnnotationUtils.areSameIgnoringValues(valueAnno, UNKNOWNVAL) || AnnotationUtils.areSameByClass(valueAnno, BottomVal.class) || AnnotationUtils.areSameIgnoringValues(mirror.getAnnotationInHierarchy(ARRAYLEN), ARRAYLEN); }	@return true if the AnnotatedTypeMirror contains the UnknownVal or ArrayLen AnnotationMirror, false otherwise	1	0
"public PhysicalPlan getPlan(SqlNode sqlNode) throws ValidationException, RelConversionException, IOException { SqlDropTable dropTableNode = ((SqlDropTable) sqlNode); SqlIdentifier tableIdentifier = dropTableNode.getTableIdentifier(); SchemaPlus defaultSchema = config.getConverter().getDefaultSchema(); AbstractSchema drillSchema = null; if (tableIdentifier != null) { drillSchema = SchemaUtilites.resolveToMutableDrillSchema(defaultSchema, dropTableNode.getSchema()); } String tableName = dropTableNode.getName(); if (drillSchema == null) { throw UserException.validationError() .message(""Invalid table_name [%s]"", tableName) .build(logger); } if (dropTableNode.checkTableExistence()) { final Table tableToDrop = SqlHandlerUtil.getTableFromSchema(drillSchema, tableName); if (tableToDrop == null || tableToDrop.getJdbcTableType() != Schema.TableType.TABLE) { return DirectPlan.createDirectPlan(context, true, String.format(""Table [%s] not found"", tableName)); } } drillSchema.dropTable(tableName); return DirectPlan.createDirectPlan(context, true, String.format(""Table [%s] %s"", tableName, ""dropped"")); }"	@return - Single row indicating drop succeeded, raise exception otherwise	1	0
"public CompletableFuture<ExecutionResult> executeAsync(ExecutionInput executionInput) { try { log.debug(""Executing request. operation name: {}. query: {}. variables {} "", executionInput.getOperationName(), executionInput.getQuery(), executionInput.getVariables()); InstrumentationState instrumentationState = instrumentation.createState(); InstrumentationExecutionParameters instrumentationParameters = new InstrumentationExecutionParameters(executionInput, this.graphQLSchema, instrumentationState); InstrumentationContext<ExecutionResult> executionInstrumentation = instrumentation.beginExecution(instrumentationParameters); CompletableFuture<ExecutionResult> executionResult = parseValidateAndExecute(executionInput, instrumentationState); // // finish up instrumentation executionResult = executionResult.whenComplete(executionInstrumentation::onEnd); // // allow instrumentation to tweak the result executionResult = executionResult.thenCompose(result -> instrumentation.instrumentExecutionResult(result, instrumentationParameters)); return executionResult; } catch (AbortExecutionException abortException) { ExecutionResultImpl executionResult = new ExecutionResultImpl(abortException); return CompletableFuture.completedFuture(executionResult); } }"	@return a promise to an ExecutionResult which can include errors	0	1
"public static String getHostFromUrl(String url) { String authority = getAuthorityFromUrl(url); // no port int idx = authority.indexOf("":""); if (idx == -1) return authority; // port, return only the portion preceding the port return authority.substring(0, idx); }"	@return Host name and port, as a string.	1	0
private RexNode convertUsing(RelNode leftRel, RelNode rightRel, List<String> nameList) { final List<RexNode> list = Lists.newArrayList(); for (String name : nameList) { final RelDataType leftRowType = leftRel.getRowType(); RelDataTypeField leftField = catalogReader.field(leftRowType, name); RexNode left = rexBuilder.makeInputRef(leftField.getType(), leftField.getIndex()); final RelDataType rightRowType = rightRel.getRowType(); RelDataTypeField rightField = catalogReader.field(rightRowType, name); RexNode right = rexBuilder.makeInputRef(rightField.getType(), leftRowType.getFieldList().size() + rightField.getIndex()); RexNode equalsCall = rexBuilder.makeCall(SqlStdOperatorTable.EQUALS, left, right); list.add(equalsCall); } return RexUtil.composeConjunction(rexBuilder, list, false); }	@return Expression to match columns from name list, or null if name list is empty	1	0
public static HashMap getXmlRpcWorkflowCondition(WorkflowCondition c) { HashMap condition = new HashMap(); condition.put(STR, c.getConditionInstanceClassName()); condition.put(STR, c.getConditionId()); condition.put(STR, c.getConditionName()); condition.put(STR, String.valueOf(c.getOrder())); condition.put(STR, String.valueOf(c.getTimeoutSeconds())); condition.put(STR, String.valueOf(c.isOptional())); condition.put(STR, getXmlRpcWorkflowConditionConfig(c.getCondConfig())); return condition; }	@return an XML-RPC {@link Hashtable} representation of the {@link WorkflowCondition} to send over the wire.	1	0
public ApiResponse<Void> deletePetWithHttpInfo(Long petId, String apiKey) throws ApiException { okhttp3.Call localVarCall = deletePetValidateBeforeCall(petId, apiKey, null, null); return localVarApiClient.execute(localVarCall); }	@return ApiResponse&lt;Void&gt;	0	1
public static Criterion fromRawSelection(final String selection, final String[] selectionArgs) { if (TextUtils.isEmpty(selection)) { return null; } return new Criterion(null) { @Override protected void populate(SqlBuilder builder, boolean forSqlValidation) { builder.sql.append(selection); if (selectionArgs != null && selectionArgs.length > NUM) { if (builder.args == null) { throw new UnsupportedOperationException(STR + STR); } Collections.addAll(builder.args, selectionArgs); } } }; }	@return a {@link Criterion} that evaluates the raw selection and selection args	1	0
protected Object convertTimestampToEpochMicros(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0L; // return epoch } try { return MicroTimestamp.toEpochMicros(data, adjuster); } catch (IllegalArgumentException e) { return handleUnknownData(column, fieldDefn, data); } }	@return the converted value, or null if the conversion could not be made and the column allows nulls	0	1
public UserInformationResponse getUserInfo(OIDCConfiguration oidcConfiguration, String acsToken) throws UserInfoException { BearerAccessToken accessToken = new BearerAccessToken(acsToken); URI userInfoEndpoint = oidcConfiguration.getUserInfoEndpoint(); UserInfoRequest userInfoRequest = new UserInfoRequest(userInfoEndpoint, accessToken); HTTPRequest request = userInfoRequest.toHTTPRequest(); return processUserInfoResponse(request); }	@return UserInfoResponse Object	1	0
"protected String errorMessage(Exception e) { return String.format(""%s is invalid: %s"", parameterName, e.getMessage()); }"	@return the error message to be sent the client	0	1
public static Map<String, String> getProperties(Object object) throws Exception { if (object == null) { return Collections.emptyMap(); } Map<String, String> props = new LinkedHashMap<String, String>(); BeanInfo beanInfo = Introspector.getBeanInfo(object.getClass()); Object[] NULL_ARG = {}; PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors(); if (propertyDescriptors != null) { for (int i = NUM; i < propertyDescriptors.length; i++) { PropertyDescriptor pd = propertyDescriptors[i]; if (pd.getReadMethod() != null && !pd.getName().equals(STR) && !pd.getName().equals(STR) && !pd.getName().equals(STR)) { Object value = pd.getReadMethod().invoke(object, NULL_ARG); if (value != null) { if (value instanceof Boolean || value instanceof Number || value instanceof String || value instanceof URI || value instanceof URL) { props.put(pd.getName(), (STR + value)); } else if (value instanceof SSLContext) { } else { Map<String, String> inner = getProperties(value); for (Map.Entry<String, String> entry : inner.entrySet()) { props.put(pd.getName() + STR + entry.getKey(), entry.getValue()); } } } } } } return props; }	@return <Code>Map</Code> of properties	1	0
public Map<String, Set<String>> getAllGraylogDeflectorIndices() { final Map<String, Set<String>> indexNamesAndAliases = indices.getIndexNamesAndAliases(getDeflectorWildcard()); return indexNamesAndAliases.entrySet().stream().filter(e -> isGraylogDeflectorIndex(e.getKey())).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue)); }	@return index name and index stats	1	0
public String getMergePolicy() { return mergePolicyConfig.getPolicy(); }	@return the updated map configuration	1	0
public NumberExpression<T> negate(){ if (negation == null){ negation = multiply(-1); } return negation; }	@return this -1	0	1
protected FieldValueInfo completeValueForList(ExecutionContext executionContext, ExecutionStrategyParameters parameters, Iterable<Object> iterableValues) { Collection<Object> values = FpKit.toCollection(iterableValues); ExecutionTypeInfo typeInfo = parameters.getTypeInfo(); GraphQLList fieldType = typeInfo.castType(GraphQLList.class); GraphQLFieldDefinition fieldDef = parameters.getTypeInfo().getFieldDefinition(); InstrumentationFieldCompleteParameters instrumentationParams = new InstrumentationFieldCompleteParameters(executionContext, parameters, fieldDef, fieldTypeInfo(parameters, fieldDef), values); Instrumentation instrumentation = executionContext.getInstrumentation(); InstrumentationContext<ExecutionResult> completeListCtx = instrumentation.beginFieldListComplete( instrumentationParams ); List<FieldValueInfo> fieldValueInfos = new ArrayList<>(); int index = 0; for (Object item : values) { ExecutionPath indexedPath = parameters.getPath().segment(index); ExecutionTypeInfo wrappedTypeInfo = ExecutionTypeInfo.newTypeInfo() .parentInfo(typeInfo) .type(fieldType.getWrappedType()) .path(indexedPath) .fieldDefinition(fieldDef) .build(); NonNullableFieldValidator nonNullableFieldValidator = new NonNullableFieldValidator(executionContext, wrappedTypeInfo); int finalIndex = index; ExecutionStrategyParameters newParameters = parameters.transform(builder -> builder.typeInfo(wrappedTypeInfo) .nonNullFieldValidator(nonNullableFieldValidator) .listSize(values.size()) .currentListIndex(finalIndex) .path(indexedPath) .source(item) ); fieldValueInfos.add(completeValue(executionContext, newParameters)); index++; } CompletableFuture<List<ExecutionResult>> resultsFuture = Async.each(fieldValueInfos, (item, i) -> item.getFieldValue()); CompletableFuture<ExecutionResult> overallResult = new CompletableFuture<>(); completeListCtx.onDispatched(overallResult); resultsFuture.whenComplete((results, exception) -> { if (exception != null) { ExecutionResult executionResult = handleNonNullException(executionContext, overallResult, exception); completeListCtx.onCompleted(executionResult, exception); return; } List<Object> completedResults = new ArrayList<>(); for (ExecutionResult completedValue : results) { completedResults.add(completedValue.getData()); } ExecutionResultImpl executionResult = new ExecutionResultImpl(completedResults, null); overallResult.complete(executionResult); }); overallResult.whenComplete(completeListCtx::onCompleted); return FieldValueInfo.newFieldValueInfo(LIST) .fieldValue(overallResult) .fieldValueInfos(fieldValueInfos) .build(); }	@return an ExecutionResult	1	0
protected CompletableFuture<ExecutionResult> resolveField(ExecutionContext executionContext, ExecutionStrategyParameters parameters) { return resolveFieldWithInfo(executionContext,parameters).thenCompose(FieldValueInfo::getFieldValue); }	@return an ExecutionResult	1	0
public FluentWait<T> withMessage(final String message) { this.messageSupplier = new Supplier<String>() { @Override public String get() { return message; } }; return this; }	@return A self reference.	0	1
public Map<String, InternalPortletPreference> getStoredPreferences(PortletWindow portletWindow, PortletRequest request) throws PortletContainerException { String key = getFormattedKey(portletWindow, request); Map<String, InternalPortletPreference> preferences = storage.get(key); if (preferences == null) { if (LOG.isDebugEnabled()) { LOG.debug(STR + key); } return Collections.emptyMap(); } else { if (LOG.isDebugEnabled()) { LOG.debug(STR + preferences.size() + STR); } return clonePreferences(preferences); } }	@return a copy of the stored portlet preferences array.	1	0
public static boolean isVisibleInExplain(RelNode rel, SqlExplainLevel explainLevel) { final BuiltInMetadata.ExplainVisibility metadata = rel.metadata(BuiltInMetadata.ExplainVisibility.class); Boolean b = metadata.isVisibleInExplain(explainLevel); return b == null || b; }	@return true for visible, false for invisible	1	0
public boolean isSessionToken(String site, String token) { HashSet<String> siteTokens = sessionTokens.get(site); if (siteTokens == null) return false; return siteTokens.contains(token.toLowerCase(Locale.ENGLISH)); }	@return true, if it is session token	0	1
"private boolean getPartitionVectors() { if (!saveSamples()) { return false; } CachedVectorContainer finalTable = null; long val = minorFragmentSampleCount.incrementAndGet(); logger.debug(""Incremented mfsc, got {}"", val); long fragmentsBeforeProceed = (long) Math.ceil(sendingMajorFragmentWidth * completionFactor); String finalTableKey = mapKey + ""final""; if (val == fragmentsBeforeProceed) { // we crossed the barrier, build table and get data. buildTable(); finalTable = tableMap.get(finalTableKey); } else { // Wait until sufficient number of fragments have submitted samples, or proceed after xx ms passed // TODO: this should be polling. if (val < fragmentsBeforeProceed) { waitUntilTimeOut(10); } for (int i = 0; i < 100 && finalTable == null; i++) { finalTable = tableMap.get(finalTableKey); if (finalTable != null) { break; } waitUntilTimeOut(10); } if (finalTable == null) { buildTable(); } finalTable = tableMap.get(finalTableKey); } Preconditions.checkState(finalTable != null); // Extract vectors from the wrapper, and add to partition vectors. These vectors will be used for partitioning in // the rest of this operator for (VectorWrapper<?> w : finalTable.get()) { partitionVectors.add(w.getValueVector()); } return true; }"	@return True is successful. False if failed.	0	1
public static SocketInputWrapper getInputStream(Socket socket, long timeout) throws IOException { InputStream stm = (socket.getChannel() == null) ? socket.getInputStream() : new SocketInputStream(socket); SocketInputWrapper w = new SocketInputWrapper(socket, stm); w.setTimeout(timeout); return w; }	@return InputStream for reading from the socket.	1	0
private ZapTextField getTxtProxyPort() { if (txtProxyPort == null) { txtProxyPort = new ZapTextField(); } return txtProxyPort; }	@return javax.swing.JTextField	1	0
public static ParameterMemento fromRegistration(ParameterRegistrationImplementor registration) { return new ParameterMemento( registration.getPosition(), registration.getName(), registration.getMode(), registration.getParameterType(), registration.getHibernateType(), registration.isPassNullsEnabled() ); }	@return The memento	0	1
"public double getDefaultScore() { String approx = getProperty(""approximate""); if (approx == null) { return getLang().equals(""english"") ? 1.0 : 0.0; } else if (""false"".equalsIgnoreCase(approx)) { return -1.0; } else if (""true"".equalsIgnoreCase(approx)) { return 1.0; } else { return Double.parseDouble(approx); } }"	@return default score	0	1
public boolean isEmpty() { return pendingCount <= NUM; }	@return true if there are no pending messages	1	0
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; // set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { // prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); // System.err.println(""At end of text making after: |"" + str + ""|""); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); // System.err.println(""prevWord is |"" + prevWord.get(CoreAnnotations.TextAnnotation.class) + ""|, its after is |"" + // prevWord.get(CoreAnnotations.AfterAnnotation.class) + ""|""); prevWordAfter.setLength(0); } return null; } } else { switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { String str = yytext(); int first = str.codePointAt(0); String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } logger.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: logger.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 79: break; case 2: { return getNext(""<"", yytext()); } case 80: break; case 3: { return getNext(); } case 81: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 82: break; case 5: { if (tokenizeNLs) { return getNext(AbstractTokenizer.NEWLINE_TOKEN, yytext()); // for tokenizing newliens } else if (invertible) { // System.err.println(""Appending newline: |"" + yytext() + ""|""); prevWordAfter.append(yytext()); } } case 83: break; case 6: { final String origTxt = yytext(); String tok = LexerUtils.removeSoftHyphens(origTxt); if (americanize) { tok = Americanize.americanize(tok); } if (DEBUG) { logger.info(""Used {WORD} (2) to recognize "" + origTxt + "" as "" + tok); } return getNext(tok, origTxt); } case 84: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 85: break; case 8: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {QUOTES} (3) to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 86: break; case 9: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {SREDAUX} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 87: break; case 10: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 88: break; case 11: { return getNext("">"", yytext()); } case 89: break; case 12: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 90: break; case 13: { handleHyphenatedNumber(yytext()); if (DEBUG) { logger.info(""Used {NUMBER} to recognize "" + yytext() + "" as "" + removeFromNumber(yytext())); } return getNext(removeFromNumber(yytext()), yytext()); } case 91: break; case 14: { return handleEllipsis(yytext()); } case 92: break; case 15: { // breakByHyphens(yytext()); // this is causing fail of attempted to pushback too much! String tok = yytext(); /* A THING can contain quote like O'Malley */ String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {THING} (2) to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 93: break; case 16: { String txt = yytext(); String norm = normalizeFractions(yytext()); if (DEBUG) { logger.info(""Used {FRAC2} to recognize "" + txt + "" as "" + norm + ""; normalizeFractions="" + normalizeFractions + "", escapeForwardSlashAsterisk="" + escapeForwardSlashAsterisk); } return getNext(norm, txt); } case 94: break; case 17: { if (normalizeCurrency) { return getNext(LexerUtils.normalizeCurrency(yytext()), yytext()); } else { return getNext(LexerUtils.minimallyNormalizeCurrency(yytext()), yytext()); } } case 95: break; case 18: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 96: break; case 19: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 97: break; case 20: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 98: break; case 21: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 99: break; case 22: { if (normalizeOtherBrackets) { return getNext(""-LSB-"", yytext()); } else { return getNext(); } } case 100: break; case 23: { if (normalizeOtherBrackets) { return getNext(""-RSB-"", yytext()); } else { return getNext(); } } case 101: break; case 24: { String tok = yytext(); String norm = LexerUtils.processCp1252misc(tok); if (DEBUG) { logger.info(""Used {CP1252_MISC_SYMBOL} to recognize "" + tok + "" as "" + norm); } return getNext(norm, tok); } case 102: break; case 25: { if (invertible) { prevWordAfter.append(yytext()); } } case 103: break; case 26: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 104: break; case 27: // general lookahead, find correct zzMarkedPos { int zzFState = 17; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 18; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 105: break; case 28: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(); } case 106: break; case 29: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {REDAUX} (2) to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 107: break; case 30: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {APOWORD} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 108: break; case 31: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); String norm = handleQuotes(tok, true); if (DEBUG) { logger.info(""Used {DBLQUOT} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + true); } return getNext(norm, tok); } case 109: break; case 32: { String tok = yytext(); if (DEBUG) { logger.info(""Used {PROG_LANGS} to recognize "" + tok + "" as "" + tok); } return getNext(tok, tok); } case 110: break; case 33: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 111: break; case 34: { breakByHyphens(yytext()); if (DEBUG) { logger.info(""Used {HTHING} to recognize "" + yytext() + "" as "" + LexerUtils.removeSoftHyphens(yytext())); } return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext()); } case 112: break; case 35: // general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tok = LexerUtils.removeSoftHyphens(origTxt); if (americanize) { tok = Americanize.americanize(tok); } if (DEBUG) { logger.info(""Used {WORD} to recognize "" + origTxt + "" as "" + tok); } return getNext(tok, origTxt); } case 113: break; case 36: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 114: break; case 37: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String origTok = yytext(); String norm = LexerUtils.removeSoftHyphens(origTok); if (DEBUG) { logger.info(""Used {WORD} (3) to recognize "" + origTok + "" as "" + norm); } return getNext(norm, origTok); } case 115: break; case 38: { // this one should only match if we're basically at the end of file // since the last one matches two things, even newlines (if not tokenize per line) return processAbbrev1(); } case 116: break; case 39: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 117: break; case 40: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { // Extra context is to not match on ones like 'd but you do want words like ""a"" // can't have digit here because of cases like '90s String tok = yytext(); /* invert single quote - often but not always right */ String norm = handleQuotes(tok, true); if (DEBUG) { logger.info(""Used {QUOTES} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + true); } return getNext(norm, tok); } case 118: break; case 41: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {REDAUX} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 119: break; case 42: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { // Extra context is to not match on ones like 'd but you do want words like ""a"" // can't have digit here because of cases like '90s String tok = yytext(); /* invert single quote - often but not always right */ String norm = handleQuotes(tok, true); if (DEBUG) { logger.info(""Used {QUOTES} (2) to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + true); } return getNext(norm, tok); } case 120: break; case 43: { return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext()); } case 121: break; case 44: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {SREDAUX} (2) to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 122: break; case 45: { if (splitAssimilations) { yypushback(2); } String tok = yytext(); if (DEBUG) { logger.info(""Used {ASSIMILATIONS3} to recognize "" + tok + "" as "" + tok + ""; splitAssimilations="" + splitAssimilations); } return getNext(tok, tok); } case 123: break; case 46: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String txt = yytext(); if (DEBUG) { logger.info(""Used {DIGIT}/{SEP_SUFFIX} to recognize "" + txt); } return getNext(txt, txt); } case 124: break; case 47: { String txt = yytext(); // if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space... if (strictTreebank3) { int spaceIndex = indexOfSpace(txt); if (spaceIndex >= 0) { yypushback(txt.length() - spaceIndex); return getNext(); } } if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, yytext()); } case 125: break; case 48: { final String origTxt = yytext(); String tok; if (normalizeAmpersandEntity) { tok = LexerUtils.normalizeAmp(origTxt); } else { tok = origTxt; } if (DEBUG) { logger.info(""Used {THINGA} (2) to recognize "" + origTxt + "" as "" + tok); } return getNext(tok, origTxt); } case 126: break; case 49: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, origTxt); } case 127: break; case 50: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space } return getNext(txt, origTxt); } case 128: break; case 51: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tok = LexerUtils.removeSoftHyphens(origTxt); if (DEBUG) { logger.info(""Used {SWORD} to recognize "" + origTxt + "" as "" + tok); } return getNext(tok, origTxt); } case 129: break; case 52: // general lookahead, find correct zzMarkedPos { int zzFState = 19; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 18; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 130: break; case 53: { String txt = yytext(); String normTok = txt; if (escapeForwardSlashAsterisk) { normTok = delimit(normTok, '*'); } if (DEBUG) { logger.info(""Used {SWEARING} to recognize "" + txt + "" as "" + normTok); } return getNext(normTok, txt); } case 131: break; case 54: { final String origTxt = yytext(); String tok; if (normalizeAmpersandEntity) { tok = LexerUtils.normalizeAmp(origTxt); } else { tok = origTxt; } if (DEBUG) { logger.info(""Used {TBSPEC} to recognize "" + origTxt + "" as "" + tok); } return getNext(tok, origTxt); } case 132: break; case 55: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(""Used {SREDAUX} to recognize "" + tok + "" as "" + norm + ""; probablyLeft="" + false); } return getNext(norm, tok); } case 133: break; case 56: // general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 13; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 134: break; case 57: // general lookahead, find correct zzMarkedPos { int zzFState = 22; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 24; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 135: break; case 58: // general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 21; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 136: break; case 59: // general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 13; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 137: break; case 60: // general lookahead, find correct zzMarkedPos { int zzFState = 22; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 23; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 138: break; case 61: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); breakByHyphens(tok); tok = yytext(); String norm = LexerUtils.removeSoftHyphens(tok); if (DEBUG) { logger.info(""Used {HTHING} (2) to recognize "" + tok + "" as "" + norm); } return getNext(norm, tok); } case 139: break; case 62: { if (splitAssimilations) { yypushback(3); } String tok = yytext(); if (DEBUG) { logger.info(""Used {ASSIMILATIONS3} to recognize "" + tok + "" as "" + tok + ""; splitAssimilations="" + splitAssimilations); } return getNext(tok, tok); } case 140: break; case 63: { final String origTxt = yytext(); String tok; if (normalizeAmpersandEntity) { tok = LexerUtils.normalizeAmp(origTxt); } else { tok = origTxt; } if (DEBUG) { logger.info(""Used {SPAMP} to recognize "" + origTxt + "" as "" + tok); } return getNext(tok, origTxt); } case 141: break; case 64: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext()); } case 142: break; case 65: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { final String origTxt = yytext(); String tok; if (normalizeAmpersandEntity) { tok = LexerUtils.normalizeAmp(origTxt); } else { tok = origTxt; } if (DEBUG) { logger.info(""Used {THINGA} to recognize "" + origTxt + "" as "" + tok); } return getNext(tok, origTxt); } case 143: break; case 66: // general lookahead, find correct zzMarkedPos { int zzFState = 9; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 144: break; case 67: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { return getNext(); } case 145: break; case 68: // general lookahead, find correct zzMarkedPos { int zzFState = 14; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 146: break; case 69: // general lookahead, find correct zzMarkedPos { int zzFState = 9; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 10; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 147: break; case 70: // general lookahead, find correct zzMarkedPos { int zzFState = 14; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 15; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 148: break; case 71: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String txt = yytext(); String norm = txt; if (escapeForwardSlashAsterisk) { norm = delimit(norm, '/'); norm = delimit(norm, '*'); } if (DEBUG) { logger.info(""Used {LIKELYURL} to recognize "" + txt + "" as "" + norm); } return getNext(norm, txt); } case 149: break; case 72: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } return getNext(txt, yytext()); } case 150: break; case 73: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4); { return getNext(); } case 151: break; case 74: // lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { return getNext(); } case 152: break; case 75: { String txt = yytext(); String norm = txt; if (escapeForwardSlashAsterisk) { norm = delimit(norm, '/'); norm = delimit(norm, '*'); } if (DEBUG) { logger.info(""Used {FULLURL} to recognize "" + txt + "" as "" + norm); } return getNext(norm, txt); } case 153: break; case 76: { String txt = yytext(); if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } if (DEBUG) { logger.info(""Used {PHONE} to recognize "" + yytext() + "" as "" + txt); } return getNext(txt, yytext()); } case 154: break; case 77: // general lookahead, find correct zzMarkedPos { int zzFState = 25; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 27; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 155: break; case 78: // general lookahead, find correct zzMarkedPos { int zzFState = 25; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 26; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 156: break; default: zzScanError(ZZ_NO_MATCH); } } } }"	@return the next token	0	1
public OfflinePlayer asOfflinePlayer() { return Bukkit.getOfflinePlayer(raw); }	@return The offline player by the name of the raw arg	1	0
private static Class getVMPrimitiveType(final String name) { return VM_PRIMITIVES.get(name); }	@return Primitive type or null.	0	1
"public static StandardProperty buildStandardProperty(AttributeBinding property, boolean lazyAvailable) { final Type type = property.getHibernateTypeDescriptor().getResolvedTypeMapping(); // we need to dirty check collections, since they can cause an owner // version number increment // we need to dirty check many-to-ones with not-found=""ignore"" in order // to update the cache (not the database), since in this case a null // entity reference can lose information final boolean alwaysDirtyCheck = type.isAssociationType() && ( (AssociationType) type ).isAlwaysDirtyChecked(); if ( property.getAttribute().isSingular() ) { final SingularAttributeBinding singularAttributeBinding = ( SingularAttributeBinding ) property; final CascadeStyle cascadeStyle = singularAttributeBinding.isAssociation() ? ( (AssociationAttributeBinding) singularAttributeBinding ).getCascadeStyle() : CascadeStyles.NONE; final FetchMode fetchMode = singularAttributeBinding.isAssociation() ? ( (AssociationAttributeBinding) singularAttributeBinding ).getFetchMode() : FetchMode.DEFAULT; return new StandardProperty( singularAttributeBinding.getAttribute().getName(), type, lazyAvailable && singularAttributeBinding.isLazy(), true, // insertable true, // updatable singularAttributeBinding.getGeneration() == PropertyGeneration.INSERT || singularAttributeBinding.getGeneration() == PropertyGeneration.ALWAYS, singularAttributeBinding.getGeneration() == PropertyGeneration.ALWAYS, singularAttributeBinding.isNullable(), alwaysDirtyCheck || areAllValuesIncludedInUpdate( singularAttributeBinding ), singularAttributeBinding.isIncludedInOptimisticLocking(), cascadeStyle, fetchMode ); } else { final AbstractPluralAttributeBinding pluralAttributeBinding = (AbstractPluralAttributeBinding) property; final CascadeStyle cascadeStyle = pluralAttributeBinding.isAssociation() ? pluralAttributeBinding.getCascadeStyle() : CascadeStyles.NONE; final FetchMode fetchMode = pluralAttributeBinding.isAssociation() ? pluralAttributeBinding.getFetchMode() : FetchMode.DEFAULT; return new StandardProperty( pluralAttributeBinding.getAttribute().getName(), type, lazyAvailable && pluralAttributeBinding.isLazy(), // TODO: fix this when HHH-6356 is fixed; for now assume AbstractPluralAttributeBinding is updatable and insertable true, // pluralAttributeBinding.isInsertable(), true, //pluralAttributeBinding.isUpdatable(), false, false, false, // nullable - not sure what that means for a collection // TODO: fix this when HHH-6356 is fixed; for now assume AbstractPluralAttributeBinding is updatable and insertable //alwaysDirtyCheck || pluralAttributeBinding.isUpdatable(), true, pluralAttributeBinding.isIncludedInOptimisticLocking(), cascadeStyle, fetchMode ); } }"	@return The appropriate StandardProperty definition.	1	0
public ActivityOptions getActivityLaunchOptions(Launcher launcher, View v) { if (hasControlRemoteAppTransitionPermission()) { try { RemoteAnimationRunnerCompat runner = new LauncherAnimationRunner(mLauncher) { @Override public void onAnimationStart(RemoteAnimationTargetCompat[] targets, Runnable finishedCallback) { // Post at front of queue ignoring sync barriers to make sure it gets // processed before the next frame. postAtFrontOfQueueAsynchronously(v.getHandler(), () -> { final boolean removeTrackingView; LauncherTransitionAnimator animator = composeRecentsLaunchAnimator(v, targets); if (animator != null) { // We are animating the task view directly, do not remove it after removeTrackingView = false; } else { animator = composeAppLaunchAnimator(v, targets); // A new floating view is created for the animation, remove it after removeTrackingView = true; } setCurrentAnimator(animator); mAnimator = animator.getAnimatorSet(); mAnimator.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { // Reset launcher to normal state v.setVisibility(View.VISIBLE); if (removeTrackingView) { ((ViewGroup) mDragLayer.getParent()).removeView( mFloatingView); } mDragLayer.setAlpha(1f); mDragLayer.setTranslationY(0f); View appsView = mLauncher.getAppsView(); appsView.setAlpha(1f); appsView.setTranslationY(0f); finishedCallback.run(); } }); mAnimator.start(); // Because t=0 has the app icon in its original spot, we can skip the // first frame and have the same movement one frame earlier. mAnimator.setCurrentPlayTime(REFRESH_RATE_MS); }); } }; return ActivityOptionsCompat.makeRemoteAnimation( new RemoteAnimationAdapterCompat(runner, 500, 380)); } catch (NoClassDefFoundError e) { // Gracefully fall back to default launch options if the user's platform doesn't // have the latest changes. } } return getDefaultActivityLaunchOptions(launcher, v); }	@return A Bundle with remote animations that controls how the window of the opening targets are displayed.	1	0
public ActivityOptions getActivityLaunchOptions(Launcher launcher, View v) { if (hasControlRemoteAppTransitionPermission()) { TaskView taskView = findTaskViewToLaunch(launcher, v); try { RemoteAnimationRunnerCompat runner = new LauncherAnimationRunner(mLauncher) { @Override public void onAnimationStart(RemoteAnimationTargetCompat[] targets, Runnable finishedCallback) { // Post at front of queue ignoring sync barriers to make sure it gets // processed before the next frame. postAtFrontOfQueueAsynchronously(v.getHandler(), () -> { final boolean removeTrackingView; LauncherTransitionAnimator animator = composeRecentsLaunchAnimator( taskView == null ? v : taskView, targets); if (animator != null) { // We are animating the task view directly, do not remove it after removeTrackingView = false; } else { animator = composeAppLaunchAnimator(v, targets); // A new floating view is created for the animation, remove it after removeTrackingView = true; } setCurrentAnimator(animator); mAnimator = animator.getAnimatorSet(); mAnimator.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { // Reset launcher to normal state v.setVisibility(View.VISIBLE); if (removeTrackingView) { ((ViewGroup) mDragLayer.getParent()).removeView( mFloatingView); } mDragLayer.setAlpha(1f); mDragLayer.setTranslationY(0f); View appsView = mLauncher.getAppsView(); appsView.setAlpha(1f); appsView.setTranslationY(0f); finishedCallback.run(); } }); mAnimator.start(); // Because t=0 has the app icon in its original spot, we can skip the // first frame and have the same movement one frame earlier. mAnimator.setCurrentPlayTime(REFRESH_RATE_MS); }); } }; int duration = taskView != null ? RECENTS_LAUNCH_DURATION : APP_LAUNCH_DURATION; int statusBarTransitionDelay = duration - STATUS_BAR_TRANSITION_DURATION; return ActivityOptionsCompat.makeRemoteAnimation(new RemoteAnimationAdapterCompat( runner, duration, statusBarTransitionDelay)); } catch (NoClassDefFoundError e) { // Gracefully fall back to default launch options if the user's platform doesn't // have the latest changes. } } return getDefaultActivityLaunchOptions(launcher, v); }	@return ActivityOptions with remote animations that controls how the window of the opening targets are displayed.	0	1
protected String getUrlProtocol() { return STR + (getPort() > NUM ? getPort() : DEFAULT_PORT) + STR; }	@return Always returns {@link DerbyDatabase#PROTOCOL}.	1	0
"public boolean isBodyAllowed() { return Arrays.asList(""PUT"", ""PATCH"", ""POST"").contains(httpMethod.toUpperCase(Locale.ROOT)); }"	@return true request method is PUT, PATCH or POST; false otherwise	0	1
@Nullable public synchronized CloseableReference<Bitmap> cloneUnderlyingBitmapReference() { return CloseableReference.cloneOrNull(mBitmapReference); }	@return the cloned bitmap reference without altering this instance	1	0
"public static String detectCharset(InputStream inStream) { if (inStream == null) { return DEFAULT_CHARSET; } nsDetector detector = new nsDetector(); detector.Init(charset -> { CharsetDetector.found = true; CharsetDetector.foundCharset = charset; }); BufferedInputStream bis = new BufferedInputStream(inStream); byte[] buf = new byte[1024]; int len; boolean done = false; boolean isAscii = true; try { while ((len = bis.read(buf, 0, buf.length)) != -1) { // Check if the stream is only ascii. if (isAscii) isAscii = detector.isAscii(buf, len); // DoIt if non-ascii and not done yet. if (!isAscii && !done) done = detector.DoIt(buf, len, false); } detector.DataEnd(); } catch (IOException e) { e.printStackTrace(); } if (isAscii) { found = true; return ""ascii""; } if (!found) { String prob[] = detector.getProbableCharsets(); if (prob.length > 0 && !Objects.equals(prob[0], ""nomatch"")) { return prob[0]; } } return DEFAULT_CHARSET; }"	"@return detected charset name (e.g. ""UTF-8"") or ""nomatch"" if no known charset can be guessed"	0	1
"public String toDefaultValue(Schema p) { if (p instanceof StringSchema) { StringSchema dp = (StringSchema) p; if (dp.getDefault() != null) { return ""@\"""" + dp.getDefault() + ""\""""; } } else if (p instanceof BooleanSchema) { BooleanSchema dp = (BooleanSchema) p; if (dp.getDefault() != null) { if (dp.getDefault().toString().equalsIgnoreCase(""false"")) return ""@(NO)""; else return ""@(YES)""; } } else if (p instanceof DateSchema) { // TODO } else if (p instanceof DateTimeSchema) { // TODO } else if (p instanceof NumberSchema) { NumberSchema dp = (NumberSchema) p; if (dp.getDefault() != null) { return ""@"" + dp.getDefault().toString(); } } else if (p instanceof IntegerSchema) { IntegerSchema dp = (IntegerSchema) p; if (dp.getDefault() != null) { return ""@"" + dp.getDefault().toString(); } } return null; }"	@return string presentation of the default value of the property	1	0
"public Object next() throws java.io.IOException { int zzInput; int zzAction; // cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; // set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { // store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); // get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } // store back cached position zzMarkedPos = zzMarkedPosL; if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { String str = yytext(); int first = str.codePointAt(0); String msg = String.format(""Untokenizable: %s (U+%s, decimal: %s)"", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } logger.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: logger.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 67: break; case 2: { return getNext(""<"", yytext()); } case 68: break; case 3: { return getNext(); } case 69: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 70: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 71: break; case 6: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 72: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 73: break; case 8: { return handleQuotes(yytext(), false); } case 74: break; case 9: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 75: break; case 10: { return getNext("">"", yytext()); } case 76: break; case 11: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 77: break; case 12: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 78: break; case 13: { return handleEllipsis(yytext()); } case 79: break; case 14: { return normalizeFractions(yytext()); } case 80: break; case 15: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(minimallyNormalizeCurrency(yytext()), yytext()); } } case 81: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 82: break; case 17: { if (normalizeOtherBrackets) { return getNext(""-RSB-"", yytext()); } else { return getNext(); } } case 83: break; case 18: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 84: break; case 19: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 85: break; case 20: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 86: break; case 21: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 87: break; case 22: { if (normalizeOtherBrackets) { return getNext(""-LSB-"", yytext()); } else { return getNext(); } } case 88: break; case 23: { if (invertible) { prevWordAfter.append(yytext()); } } case 89: break; case 24: { return getNext(""\u2022"", yytext()); } case 90: break; case 25: { return getNext(""\u2122"", yytext()); } case 91: break; case 26: // general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 92: break; case 27: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(); } case 93: break; case 28: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return handleQuotes(yytext(), true); } case 94: break; case 29: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 95: break; case 30: { breakByHyphens(yytext()); return getNext(removeSoftHyphens(yytext()), yytext()); } case 96: break; case 31: // general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 97: break; case 32: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '/'), yytext()); } else { return getNext(); } } case 98: break; case 33: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 99: break; case 34: { // this one should only match if we're basically at the end of file // since the last one matches two things, even newlines (if not tokenize per line) String s; if (strictTreebank3 && ! ""U.S."".equals(yytext())) { yypushback(1); // return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); // return a period for next time } return getNext(s, yytext()); } case 100: break; case 35: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 101: break; case 36: // lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 1); { /* invert quote - often but not always right */ return handleQuotes(yytext(), true); } case 102: break; case 37: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return handleQuotes(yytext(), false); } case 103: break; case 38: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 104: break; case 39: { String txt = yytext(); // if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space... if (strictTreebank3) { int spaceIndex = indexOfSpace(txt); if (spaceIndex >= 0) { yypushback(txt.length() - spaceIndex); String newText = yytext(); return getNext(newText, newText); } } if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, txt); } case 105: break; case 40: { return getNormalizedAmpNext(); } case 106: break; case 41: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } return getNext(txt, origTxt); } case 107: break; case 42: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(""\u00A0""); // change to non-breaking space } return getNext(txt, origTxt); } case 108: break; case 43: // general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 109: break; case 44: { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 110: break; case 45: // general lookahead, find correct zzMarkedPos { int zzFState = 17; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 111: break; case 46: // lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 112: break; case 47: // general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 113: break; case 48: // general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 22; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 114: break; case 49: // general lookahead, find correct zzMarkedPos { int zzFState = 18; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 19; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 115: break; case 50: // general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 116: break; case 51: // general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 21; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 117: break; case 52: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 118: break; case 53: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { breakByHyphens(yytext()); return getNext(removeSoftHyphens(yytext()), yytext()); } case 119: break; case 54: { if (splitAssimilations) { yypushback(3) ; return getNext(); } else { return getNext(); } } case 120: break; case 55: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNormalizedAmpNext(); } case 121: break; case 56: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 9; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 122: break; case 57: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { return getNext(); } case 123: break; case 58: // general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 124: break; case 59: // general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 125: break; case 60: // general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 13; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 126: break; case 61: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '/'); } return getNext(txt, yytext()); } case 127: break; case 62: // lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4); { return getNext(); } case 128: break; case 63: // lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { return getNext(); } case 129: break; case 64: { String txt = yytext(); if (normalizeSpace) { txt = txt.replace(' ', '\u00A0'); // change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 130: break; case 65: // general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 25; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 131: break; case 66: // general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 24; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { /* attempt to treat fourth ellipsis as period if followed by space and letter. */ return handleEllipsis(yytext()); } case 132: break; default: zzScanError(ZZ_NO_MATCH); } } } }"	@return the next token	0	1
public CloseableHttpClient build(String name) { final InstrumentedHttpClientConnectionManager manager = createConnectionManager(registry, name); final CloseableHttpClient client = createClient(manager, name); return client; }	@return an {@link HttpClient}	1	0
"public boolean isCookiePresent(String name) { return (Boolean) seleneseMethods.get(""isCookiePresent"").apply(driver, name); }"	@return true if a cookie with the specified name is present, or false otherwise.	0	1
protected Object convertTimestampToEpochNanos(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0L; // return epoch } try { return NanoTimestamp.toEpochNanos(data); } catch (IllegalArgumentException e) { return handleUnknownData(column, fieldDefn, data); } }	@return the converted value, or null if the conversion could not be made	1	0
Folder getOpenFolder() { CellLayout currentScreen = (CellLayout) getChildAt(mCurrentScreen); int count = currentScreen.getChildCount(); for (int i = 0; i < count; i++) { View child = currentScreen.getChildAt(i); CellLayout.LayoutParams lp = (CellLayout.LayoutParams) child.getLayoutParams(); if (lp.cellHSpan == 4 && lp.cellVSpan == 4 && child instanceof Folder) { return (Folder) child; } } return null; }	@return The open folder on the current screen, or null if there is none	0	1
public ApiResponse<Void> testBodyWithFileSchemaWithHttpInfo(FileSchemaTestClass body) throws ApiException { okhttp3.Call localVarCall = testBodyWithFileSchemaValidateBeforeCall(body, null, null); return localVarApiClient.execute(localVarCall); }	@return ApiResponse&lt;Void&gt;	0	1
"public static SchemaPath parseFromString(String expr) { if (expr == null || expr.isEmpty()) { return null; } try { if (SchemaPath.DYNAMIC_STAR.equals(expr)) { return SchemaPath.getSimplePath(expr); } ExprLexer lexer = new ExprLexer(new ANTLRStringStream(expr)); CommonTokenStream tokens = new CommonTokenStream(lexer); ExprParser parser = new ExprParser(tokens); parse_return ret = parser.parse(); if (ret.e instanceof SchemaPath) { return (SchemaPath) ret.e; } else { throw new IllegalStateException(""Schema path is not a valid format.""); } } catch (RecognitionException e) { throw new RuntimeException(e); } }"	@return SchemaPath instance	0	1
"protected String removeNonNameElementToCamelCase(final String name, final String nonNameElementPattern) { String result = Arrays.stream(name.split(nonNameElementPattern)) .map(StringUtils::capitalize) .collect(Collectors.joining("""")); if (result.length() > 0) { result = result.substring(0, 1).toLowerCase() + result.substring(1); } return result; }"	@return camelized string	0	1
"public boolean setTaskCompleted(List<FileDownloadTaskAtom> taskAtomList) { FileDownloadLog.w(this, ""If you invoked this method, please remove it directly feel free, "" + ""it doesn't need any longer""); return true; }"	@return Whether is successful to update all tasks' status to the Filedownloader Engine. If one task atom among them is not match the Rules in com.liulishuo.filedownloader.services.FileDownloadMgr#obtainCompletedTaskShelfModel(String, String, long) will receive false, and non of them would be updated to DB.	1	0
public static MailboxMessage<HBaseId> messageMetaFromResult(Configuration conf, Result result) { HBaseMailboxMessage message = null; Flags flags = new Flags(); List<Property> propList = new ArrayList<Property>(); KeyValue[] keys = result.raw(); String mediaType = null, subType = null; Long modSeq = null, uid, bodyOctets = null, contentOctets = null, textualLineCount = null; Date internalDate = null; int i = NUM; if (Bytes.equals(keys[i].getQualifier(), MESSAGE_BODY_OCTETS)) { bodyOctets = Bytes.toLong(keys[i].getValue()); i++; } if (Bytes.equals(keys[i].getQualifier(), MESSAGE_CONTENT_OCTETS)) { contentOctets = Bytes.toLong(keys[i].getValue()); i++; } if (Bytes.equals(keys[i].getQualifier(), MESSAGE_INTERNALDATE)) { internalDate = new Date(Bytes.toLong(keys[i].getValue())); i++; } if (Bytes.equals(keys[i].getQualifier(), MESSAGE_TEXT_LINE_COUNT)) { textualLineCount = Bytes.toLong(keys[i].getValue()); i++; } if (Bytes.equals(keys[i].getQualifier(), MESSAGE_MODSEQ)) { modSeq = Bytes.toLong(keys[i].getValue()); i++; } if (Bytes.equals(keys[i].getQualifier(), MESSAGE_MEDIA_TYPE)) { mediaType = Bytes.toString(keys[i].getValue()); i++; } if (Bytes.equals(keys[i].getQualifier(), MESSAGE_SUB_TYPE)) { subType = Bytes.toString(keys[i].getValue()); i++; } if (i < NUM) { throw new RuntimeException(STR); } while (i < keys.length) { if (Bytes.startsWith(keys[i].getQualifier(), PREFIX_PROP_B)) { propList.add(getProperty(keys[i].getValue())); } else if (Bytes.startsWith(keys[i].getQualifier(), PREFIX_SFLAGS_B)) { if (Bytes.equals(MARKER_PRESENT, keys[i].getValue())) { flags.add(systemFlagFromBytes(keys[i].getQualifier())); } } else if (Bytes.startsWith(keys[i].getQualifier(), PREFIX_UFLAGS_B)) { flags.add(userFlagFromBytes(keys[i].getQualifier())); } i++; } HBaseId uuid = HBaseIdFromRowKey(result.getRow()); uid = Long.MAX_VALUE - Bytes.toLong(result.getRow(), NUM); PropertyBuilder props = new PropertyBuilder(propList); props.setMediaType(mediaType); props.setSubType(subType); message = new HBaseMailboxMessage(conf, uuid, internalDate, flags, contentOctets, (int) (contentOctets - bodyOctets), props); message.setUid(uid); message.setModSeq(modSeq); message.setTextualLineCount(textualLineCount); return message; }	@return a HBaseMessage instance with message metadata.	1	0
"public Object getValue(PgProto.DatumMessage datumMessage, PgConnectionSupplier connection, boolean includeUnknownDatatypes) { if (datumMessage.hasDatumMissing()) { return UnchangedToastedReplicationMessageColumn.UNCHANGED_TOAST_VALUE; } int columnType = (int) datumMessage.getColumnType(); switch (columnType) { case PgOid.BOOL: return datumMessage.hasDatumBool() ? datumMessage.getDatumBool() : null; case PgOid.INT2: case PgOid.INT4: return datumMessage.hasDatumInt32() ? datumMessage.getDatumInt32() : null; case PgOid.INT8: case PgOid.OID: case PgOid.MONEY: return datumMessage.hasDatumInt64() ? datumMessage.getDatumInt64() : null; case PgOid.FLOAT4: return datumMessage.hasDatumFloat()? datumMessage.getDatumFloat() : null; case PgOid.FLOAT8: return datumMessage.hasDatumDouble() ? datumMessage.getDatumDouble() : null; case PgOid.NUMERIC: if (datumMessage.hasDatumDouble()) { // For backwards compatibility only to enable independent upgrade of Postgres plug-in return datumMessage.getDatumDouble(); } else if (datumMessage.hasDatumString()) { final String s = datumMessage.getDatumString(); return PostgresValueConverter.toSpecialValue(s).orElseGet(() -> new SpecialValueDecimal(new BigDecimal(s))); } return null; case PgOid.CHAR: case PgOid.VARCHAR: case PgOid.BPCHAR: case PgOid.TEXT: case PgOid.JSON: case PgOid.JSONB_OID: case PgOid.XML: case PgOid.UUID: case PgOid.BIT: case PgOid.VARBIT: case PgOid.INET_OID: case PgOid.CIDR_OID: case PgOid.MACADDR_OID: case PgOid.MACADDR8_OID: return datumMessage.hasDatumString() ? datumMessage.getDatumString() : null; case PgOid.DATE: return datumMessage.hasDatumInt32() ? (long) datumMessage.getDatumInt32() : null; case PgOid.TIMESTAMP: if (!datumMessage.hasDatumInt64()) { return null; } // these types are sent by the plugin as LONG - microseconds since Unix Epoch return Conversions.toInstantFromMicros(datumMessage.getDatumInt64()); case PgOid.TIMESTAMPTZ: if (!datumMessage.hasDatumInt64()) { return null; } // these types are sent by the plugin as LONG - microseconds since Unix Epoch return Conversions.toInstantFromMicros(datumMessage.getDatumInt64()).atOffset(ZoneOffset.UTC); case PgOid.TIME: if (!datumMessage.hasDatumInt64()) { return null; } // these types are sent by the plugin as LONG - microseconds since Unix Epoch return Duration.of(datumMessage.getDatumInt64(), ChronoUnit.MICROS); case PgOid.TIMETZ: if (!datumMessage.hasDatumDouble()) { return null; } // the value is sent as a double microseconds return Conversions.toInstantFromMicros((long) datumMessage.getDatumDouble()) .atOffset(ZoneOffset.UTC) .toOffsetTime(); case PgOid.INTERVAL: // these are sent as doubles by the plugin since their storage is larger than 8 bytes return datumMessage.hasDatumDouble() ? datumMessage.getDatumDouble() : null; // the plugin will send back a TZ formatted string case PgOid.BYTEA: return datumMessage.hasDatumBytes() ? datumMessage.getDatumBytes().toByteArray() : null; case PgOid.POINT: { PgProto.Point datumPoint = datumMessage.getDatumPoint(); return new PGpoint(datumPoint.getX(), datumPoint.getY()); } case PgOid.TSRANGE_OID: case PgOid.TSTZRANGE_OID: case PgOid.DATERANGE_OID: case PgOid.INT4RANGE_OID: case PgOid.NUM_RANGE_OID: case PgOid.INT8RANGE_OID: return datumMessage.hasDatumBytes() ? new String(datumMessage.getDatumBytes().toByteArray(), Charset.forName(""UTF-8"")) : null; case PgOid.INT2_ARRAY: case PgOid.INT4_ARRAY: case PgOid.INT8_ARRAY: case PgOid.TEXT_ARRAY: case PgOid.NUMERIC_ARRAY: case PgOid.FLOAT4_ARRAY: case PgOid.FLOAT8_ARRAY: case PgOid.BOOL_ARRAY: case PgOid.DATE_ARRAY: case PgOid.TIME_ARRAY: case PgOid.TIMETZ_ARRAY: case PgOid.TIMESTAMP_ARRAY: case PgOid.TIMESTAMPTZ_ARRAY: case PgOid.BYTEA_ARRAY: case PgOid.VARCHAR_ARRAY: case PgOid.OID_ARRAY: case PgOid.BPCHAR_ARRAY: case PgOid.MONEY_ARRAY: case PgOid.NAME_ARRAY: case PgOid.INTERVAL_ARRAY: case PgOid.CHAR_ARRAY: case PgOid.VARBIT_ARRAY: case PgOid.UUID_ARRAY: case PgOid.XML_ARRAY: case PgOid.POINT_ARRAY: case PgOid.JSONB_ARRAY: case PgOid.JSON_ARRAY: case PgOid.REF_CURSOR_ARRAY: case PgOid.INET_ARRAY: case PgOid.CIDR_ARRAY: case PgOid.MACADDR_ARRAY: case PgOid.MACADDR8_ARRAY: case PgOid.TSRANGE_ARRAY: case PgOid.TSTZRANGE_ARRAY: case PgOid.DATERANGE_ARRAY: case PgOid.INT4RANGE_ARRAY: case PgOid.NUM_RANGE_ARRAY: case PgOid.INT8RANGE_ARRAY: return getArray(datumMessage, connection, columnType); case PgOid.UNSPECIFIED: return null; default: PostgresType type = typeRegistry.get(columnType); if (type.getOid() == typeRegistry.geometryOid() || type.getOid() == typeRegistry.geographyOid() || type.getOid() == typeRegistry.citextOid() ) { return datumMessage.getDatumBytes().toByteArray(); } if(type.getOid() == typeRegistry.hstoreOid()) { return datumMessage.getDatumBytes().toByteArray(); } if (type.getOid() == typeRegistry.geometryArrayOid() || type.getOid() == typeRegistry.geographyArrayOid() || type.getOid() == typeRegistry.citextArrayOid() || type.getOid() == typeRegistry.hstoreArrayOid()) { return getArray(datumMessage, connection, columnType); } // unknown data type is sent by decoder as binary value if (includeUnknownDatatypes && datumMessage.hasDatumBytes()) { return datumMessage.getDatumBytes().toByteArray(); } return null; } }"	@return the value; may be null	0	1
public String[] getHistory(String historyId) { Assert.isNotNull(historyId); List<String> entries = history.get(historyId); if (entries == null) { entries = new ArrayList<String>(); } return entries.toArray(new String[entries.size()]); }	@return The list of ids within the history ids list or an empty list.	1	0
public String ceDataschema() { return dataSchemaUrl; }	@return the data schema url of CloudEvents envelope	0	1
public boolean isThisMyUrl(String url) { return isInstanceURL(url, applicationInfoManager.getInfo()); }	@return true, if the url represents the current node which is trying to replicate, false otherwise.	0	1
@RequestMapping(value = STR, method = { RequestMethod.POST }) @ResponseBody public CubeRequest saveCubeDesc(@RequestBody CubeRequest cubeRequest) { CubeDesc desc = deserializeCubeDesc(cubeRequest); if (desc == null) { cubeRequest.setMessage(STR); return cubeRequest; } String name = CubeService.getCubeNameFromDesc(desc.getName()); if (StringUtils.isEmpty(name)) { logger.info(STR); throw new BadRequestException(STR); } CubeInstance cubeInstance; try { desc.setUuid(UUID.randomUUID().toString()); String projectName = (null == cubeRequest.getProject()) ? ProjectInstance.DEFAULT_PROJECT_NAME : cubeRequest.getProject(); cubeInstance = cubeService.createCubeAndDesc(name, projectName, desc); } catch (Exception e) { logger.error(STR, e); throw new InternalErrorException(e.getLocalizedMessage(), e); } boolean createStreamingConfigSuccess = false, createKafkaConfigSuccess = false; StreamingConfig streamingConfig = null; KafkaConfig kafkaConfig = null; boolean isStreamingCube = cubeRequest.getStreamingCube() != null && cubeRequest.getStreamingCube().equals(STR); try { if (isStreamingCube) { streamingConfig = deserializeStreamingDesc(cubeRequest); kafkaConfig = deserializeKafkaDesc(cubeRequest); if (kafkaConfig == null) { cubeRequest.setMessage(STR); return cubeRequest; } if (streamingConfig == null) { cubeRequest.setMessage(STR); return cubeRequest; } try { streamingConfig.setUuid(UUID.randomUUID().toString()); streamingService.createStreamingConfig(streamingConfig); createStreamingConfigSuccess = true; } catch (IOException e) { logger.error(STR + e.getLocalizedMessage(), e); throw new InternalErrorException(STR + e.getLocalizedMessage()); } try { kafkaConfig.setUuid(UUID.randomUUID().toString()); kafkaConfigService.createKafkaConfig(kafkaConfig); createKafkaConfigSuccess = true; } catch (IOException e) { logger.error(STR + e.getLocalizedMessage(), e); throw new InternalErrorException(STR + e.getLocalizedMessage()); } } } finally { if (isStreamingCube) { if (createStreamingConfigSuccess == false || createKafkaConfigSuccess == false) { try { cubeService.deleteCube(cubeInstance); } catch (Exception ex) { throw new InternalErrorException(STR + STR + ex.getMessage(), ex); } if (createStreamingConfigSuccess == true) { try { streamingService.dropStreamingConfig(streamingConfig); } catch (IOException e) { throw new InternalErrorException(STR + e.getLocalizedMessage()); } } if (createKafkaConfigSuccess == true) { try { kafkaConfigService.dropKafkaConfig(kafkaConfig); } catch (IOException e) { throw new InternalErrorException(STR + e.getLocalizedMessage()); } } } } } cubeRequest.setUuid(desc.getUuid()); cubeRequest.setSuccessful(true); return cubeRequest; }	@return cubeRequest cube change request	1	0
"public boolean setOffsetFor(String replicaSetName, Map<String, ?> sourceOffset) { if (replicaSetName == null) throw new IllegalArgumentException(""The replica set name may not be null""); if (sourceOffset == null) return false; // We have previously recorded at least one offset for this database ... boolean initSync = booleanOffsetValue(sourceOffset, INITIAL_SYNC); if (initSync) { return false; } int time = intOffsetValue(sourceOffset, TIMESTAMP); int order = intOffsetValue(sourceOffset, ORDER); Long operationId = longOffsetValue(sourceOffset, OPERATION_ID); positionsByReplicaSetName.put(replicaSetName, new Position(time, order, operationId)); return true; }"	@return true if the offset was recorded, or false if the source offset is null	0	1
"private ZapTextArea getTxtScope() { if (txtScope == null) { txtScope = new ZapTextArea(); txtScope.setLineWrap(true); txtScope.setRows(3); txtScope.setFont(new java.awt.Font(""Dialog"", java.awt.Font.PLAIN, 11)); } return txtScope; }"	@return javax.swing.JTextArea	1	0
"public static String[] decodeArray(String encoded){ if (encoded.isEmpty()) return EMPTY_STRING_ARRAY; char[] chars = encoded.trim().toCharArray(); //--Parse the String // (state) char quoteCloseChar = (char) 0; List<StringBuilder> terms = new LinkedList<>(); StringBuilder current = new StringBuilder(); //(start/stop overhead) int start = 0; int end = chars.length; if(chars[0] == '('){ start += 1; end -= 1; if(chars[end] != ')') throw new IllegalArgumentException(""Unclosed paren in encoded array: "" + encoded); } if(chars[0] == '['){ start += 1; end -= 1; if(chars[end] != ']') throw new IllegalArgumentException(""Unclosed bracket in encoded array: "" + encoded); } if(chars[0] == '{'){ start += 1; end -= 1; if(chars[end] != '}') throw new IllegalArgumentException(""Unclosed bracket in encoded array: "" + encoded); } // (finite state automaton) for (int i=start; i<end; i++) { if (chars[i] == '\r') { // Ignore funny windows carriage return continue; } else if(chars[i] == '\\'){ //(case: escaped character) if(i == chars.length - 1) throw new IllegalArgumentException(""Last character of encoded array is escape character: "" + encoded); current.append(chars[i+1]); i += 1; } else if (quoteCloseChar != 0) { //(case: in quotes) if(chars[i] == quoteCloseChar){ quoteCloseChar = (char) 0; }else{ current.append(chars[i]); } } else { //(case: normal) if(chars[i] == '""'){ quoteCloseChar = '""'; } else if(chars[i] == '\''){ quoteCloseChar = '\''; } else if(chars[i] == ',' || chars[i] == ';' || chars[i] == ' ' || chars[i] == '\t' || chars[i] == '\n'){ //break if (current.length() > 0) { terms.add(current); } current = new StringBuilder(); }else{ current.append(chars[i]); } } } //--Return if(current.length() > 0) terms.add(current); String[] rtn = new String[terms.size()]; int i=0; for(StringBuilder b : terms){ rtn[i] = b.toString().trim(); i += 1; } return rtn; }"	@return A String array corresponding to the encoded array	0	1
public List<I> joinWithTimeout() { if (timeout < 0) { join(); return null; } // Make blocking calls to the last processes that are running if ( ! threadPool.isShutdown()) { try { List<I> leftover = null; int i; for (i = nThreads; i > 0; --i) { if (idleProcessors.poll(timeout, TimeUnit.MILLISECONDS) == null) { leftover = shutdownNow(); break; } } // if the poll hit a timeout, retake the remaining processors // so join() can guarantee the threads are finished if (i > 0) { for ( ; i > leftover.size(); --i) { idleProcessors.take(); } return leftover; } else { threadPool.shutdown(); // Sanity check. The threadpool should be done after iterating over // the processors. threadPool.awaitTermination(10, TimeUnit.SECONDS); } } catch (InterruptedException e) { throw new RuntimeException(e); } } return null; }	@return a list of jobs which had never been started if timeout was reached, or an empty list if that did not happen.	1	0
public int delete(Object[] row, long ts, int rowNumber, int numberOfRows) throws InterruptedException { return converter.delete(source, row, rowNumber, numberOfRows, includedColumns, ts, consumer); }	@return the number of records produced; will be 0 or more	0	1
