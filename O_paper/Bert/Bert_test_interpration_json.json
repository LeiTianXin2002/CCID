[{"new_code_raw":"private static EmbeddedElasticsearchNode create(Settings settings) { \/\/ ensure PainlessPlugin is installed or otherwise scripted fields would not work Node node = new LocalNode(settings, Arrays.asList(Netty4Plugin.class, PainlessPlugin.class)); return new EmbeddedElasticsearchNode(node); }","old_code_raw":"  public static EmbeddedElasticsearchNode create() {\n    File data = Files.createTempDir();\n    data.deleteOnExit();\n    File home = Files.createTempDir();\n    home.deleteOnExit();\n\n    Settings settings = Settings.builder()\n        .put(\"node.name\", \"fake-elastic\")\n        .put(\"path.home\", home.getAbsolutePath())\n        .put(\"path.data\", data.getAbsolutePath())\n        .put(\"http.type\", \"netty4\")\n        .put(\"network.host\", \"localhost\")\n        .build();\n\n    return create(settings);\n  }\n","new_comment_raw":"Creates an instance with existing settings","old_comment_raw":"Creates elastic node as single member of a cluster.","label":1,"pre_label":0,"AST_level":8,"line_counts":6,"new_code_token_num":48},{"new_code_raw":"public boolean areInsertionsOrDeletionsQueued() { return ( insertions.size() > 0 || ! unresolvedInsertions.isEmpty() || deletions.size() > 0 ); }","old_code_raw":"\tpublic boolean areInsertionsOrDeletionsQueued() {\n\t\treturn ( insertions.size() > 0 || deletions.size() > 0 );\n\t}\n","new_comment_raw":"Check whether any insertion or deletion actions are currently queued.","old_comment_raw":"Check whether any insertion or deletion actions are currently queued.","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":30},{"new_code_raw":"private byte[] marshalAggregatorValues(long superstep) { if (superstep == INPUT_SUPERSTEP) { return new byte[0]; } ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); DataOutputStream output = new DataOutputStream(outputStream); for (Entry<String, AggregatorWrapper<Writable>> entry : getAggregatorMap().entrySet()) { if (entry.getValue().isChanged()) { try { output.writeUTF(entry.getKey()); entry.getValue().getCurrentAggregatedValue().write(output); } catch (IOException e) { throw new IllegalStateException(\"Failed to marshall aggregator \" + \"with IOException \" + entry.getKey(), e); } } } if (LOG.isInfoEnabled()) { LOG.info( \"marshalAggregatorValues: Finished assembling aggregator values\"); } return outputStream.toByteArray(); }","old_code_raw":"  private JSONArray marshalAggregatorValues(long superstep) {\n    JSONArray aggregatorArray = new JSONArray();\n    if ((superstep == INPUT_SUPERSTEP) || (aggregatorInUse.size() == 0)) {\n      return aggregatorArray;\n    }\n\n    for (String name : aggregatorInUse) {\n      try {\n        Aggregator<Writable> aggregator = getAggregatorMap().get(name);\n        ByteArrayOutputStream outputStream =\n            new ByteArrayOutputStream();\n        DataOutput output = new DataOutputStream(outputStream);\n        aggregator.getAggregatedValue().write(output);\n\n        JSONObject aggregatorObj = new JSONObject();\n        aggregatorObj.put(AGGREGATOR_NAME_KEY, name);\n        aggregatorObj.put(AGGREGATOR_CLASS_NAME_KEY,\n            aggregator.getClass().getName());\n        aggregatorObj.put(\n            AGGREGATOR_VALUE_KEY,\n            Base64.encodeBytes(outputStream.toByteArray()));\n        aggregatorArray.put(aggregatorObj);\n        if (LOG.isInfoEnabled()) {\n          LOG.info(\"marshalAggregatorValues: \" +\n              \"Found aggregatorObj \" +\n              aggregatorObj + \", value (\" +\n              aggregator.getAggregatedValue() + \")\");\n        }\n      } catch (JSONException e) {\n        throw new IllegalStateException(\"Failed to marshall aggregator \" +\n            \"with JSONException \" + name, e);\n      } catch (IOException e) {\n        throw new IllegalStateException(\"Failed to marshall aggregator \" +\n            \"with IOException \" + name, e);\n      }\n    }\n\n    if (LOG.isInfoEnabled()) {\n      LOG.info(\"marshalAggregatorValues: Finished assembling \" +\n          \"aggregator values in JSONArray - \" + aggregatorArray);\n    }\n    aggregatorInUse.clear();\n    return aggregatorArray;\n  }\n","new_comment_raw":"Marshal the aggregator values of the worker to a byte array that will later be aggregated by master.","old_comment_raw":"Marshal the aggregator values of to a JSONArray that will later be aggregated by master.","label":1,"pre_label":0,"AST_level":13,"line_counts":28,"new_code_token_num":153},{"new_code_raw":"static MongoDatabasePolicy create() { final MongoClient client; if (MongoAssertions.useMongo()) { \/\/ use to real client (connects to mongo) client = new MongoClient(); } else if (MongoAssertions.useFongo()) { \/\/ in-memory DB (fake Mongo) client = new Fongo(MongoDatabasePolicy.class.getSimpleName()).getMongo(); } else { throw new UnsupportedOperationException(\"I can only connect to Mongo or Fongo instances\"); } return new MongoDatabasePolicy(client); }","old_code_raw":"  static MongoDatabaseRule create() {\n    final MongoClient client;\n    if (MongoAssertions.useMongo()) {\n      \/\/ use to real client (connects to mongo)\n      client = new MongoClient();\n    } else if (MongoAssertions.useFongo()) {\n      \/\/ in-memory DB (fake Mongo)\n      client = new Fongo(MongoDatabaseRule.class.getSimpleName()).getMongo();\n    } else {\n      throw new UnsupportedOperationException(\"I can only connect to Mongo or Fongo instances\");\n    }\n\n    return new MongoDatabaseRule(client);\n  }\n","new_comment_raw":"Creates an instance based on current maven profile (as defined by  -Pit).","old_comment_raw":"Create an instance based on current maven profile (as defined by -Pit).","label":1,"pre_label":0,"AST_level":10,"line_counts":16,"new_code_token_num":98},{"new_code_raw":"public static Iterable<ProviderMetadata> boundedByIso3166Code(String iso3166Code, TypeToken<? extends Wrapper> contextWrappableAs) { return filter(all(), Predicates.and(ProviderPredicates.boundedByIso3166Code(iso3166Code), ProviderPredicates .contextWrappableAs(contextWrappableAs))); }","old_code_raw":"   public static Iterable<ProviderMetadata<?, ?, ?, ?>> boundedByIso3166Code(String iso3166Code, ApiType type) {\n      return filter(all(),\n            Predicates.and(ProviderPredicates.boundedByIso3166Code(iso3166Code), ProviderPredicates.type(type)));\n   }\n","new_comment_raw":"Returns the providers that are bound to the same location as the given ISO 3166 code and of the given contextWrappableAs.","old_comment_raw":"Returns the providers that are bound to the same location as the given ISO 3166 code and of the given type.","label":1,"pre_label":0,"AST_level":7,"line_counts":7,"new_code_token_num":41},{"new_code_raw":"public static StandardProperty buildStandardProperty(AttributeBinding property, boolean lazyAvailable) { final Type type = property.getHibernateTypeDescriptor().getExplicitType(); \/\/ we need to dirty check collections, since they can cause an owner \/\/ version number increment \/\/ we need to dirty check many-to-ones with not-found=\"ignore\" in order \/\/ to update the cache (not the database), since in this case a null \/\/ entity reference can lose information boolean alwaysDirtyCheck = type.isAssociationType() && ( (AssociationType) type ).isAlwaysDirtyChecked(); if ( property.isSimpleValue() ) { SimpleAttributeBinding simpleProperty = ( SimpleAttributeBinding ) property; return new StandardProperty( simpleProperty.getAttribute().getName(), simpleProperty.getNodeName(), type, lazyAvailable && simpleProperty.isLazy(), simpleProperty.isInsertable(), simpleProperty.isUpdatable(), simpleProperty.getGeneration() == PropertyGeneration.INSERT || simpleProperty.getGeneration() == PropertyGeneration.ALWAYS, simpleProperty.getGeneration() == PropertyGeneration.ALWAYS, simpleProperty.isNullable(), alwaysDirtyCheck || simpleProperty.isUpdatable(), simpleProperty.isOptimisticLockable(), \/\/ TODO: get cascadeStyle from simpleProperty when HHH-6355 is fixed; for now, assume NONE \/\/simpleProperty.getCascadeStyle(), CascadeStyle.NONE, \/\/ TODO: get fetchMode() from simpleProperty when HHH-6357 is fixed; for now, assume FetchMode.DEFAULT \/\/simpleProperty.getFetchMode() FetchMode.DEFAULT ); } else { PluralAttributeBinding pluralProperty = ( PluralAttributeBinding ) property; return new StandardProperty( pluralProperty.getAttribute().getName(), pluralProperty.getNodeName(), type, lazyAvailable && pluralProperty.isLazy(), \/\/ TODO: fix this when HHH-6356 is fixed; for now assume PluralAttributeBinding is updatable and insertable \/\/ pluralProperty.isInsertable(), \/\/pluralProperty.isUpdatable(), true, true, false, false, pluralProperty.isNullable(), \/\/ TODO: fix this when HHH-6356 is fixed; for now assume PluralAttributeBinding is updatable and insertable \/\/alwaysDirtyCheck || pluralProperty.isUpdatable(), true, pluralProperty.isOptimisticLocked(), \/\/ TODO: get cascadeStyle from property when HHH-6355 is fixed; for now, assume NONE \/\/pluralProperty.getCascadeStyle(), CascadeStyle.NONE, \/\/ TODO: get fetchMode() from simpleProperty when HHH-6357 is fixed; for now, assume FetchMode.DEFAULT \/\/pluralProperty.getFetchMode() FetchMode.DEFAULT ); } }","old_code_raw":"\tpublic static StandardProperty buildStandardProperty(Property property, boolean lazyAvailable) {\n\t\t\n\t\tfinal Type type = property.getValue().getType();\n\t\t\n\t\t\/\/ we need to dirty check collections, since they can cause an owner\n\t\t\/\/ version number increment\n\t\t\n\t\t\/\/ we need to dirty check many-to-ones with not-found=\"ignore\" in order \n\t\t\/\/ to update the cache (not the database), since in this case a null\n\t\t\/\/ entity reference can lose information\n\t\t\n\t\tboolean alwaysDirtyCheck = type.isAssociationType() && \n\t\t\t\t( (AssociationType) type ).isAlwaysDirtyChecked(); \n\n\t\treturn new StandardProperty(\n\t\t\t\tproperty.getName(),\n\t\t\t\tproperty.getNodeName(),\n\t\t\t\ttype,\n\t\t\t\tlazyAvailable && property.isLazy(),\n\t\t\t\tproperty.isInsertable(),\n\t\t\t\tproperty.isUpdateable(),\n\t\t        property.getGeneration() == PropertyGeneration.INSERT || property.getGeneration() == PropertyGeneration.ALWAYS,\n\t\t\t\tproperty.getGeneration() == PropertyGeneration.ALWAYS,\n\t\t\t\tproperty.isOptional(),\n\t\t\t\talwaysDirtyCheck || property.isUpdateable(),\n\t\t\t\tproperty.isOptimisticLocked(),\n\t\t\t\tproperty.getCascadeStyle(),\n\t\t        property.getValue().getFetchMode()\n\t\t\t);\n\t}\n","new_comment_raw":"Generate a \"standard\" (i.e., non-identifier and non-version) based on the given mapped property.","old_comment_raw":"Generate a \"standard\" (i.e., non-identifier and non-version) based on the given mapped property.","label":0,"pre_label":1,"AST_level":9,"line_counts":66,"new_code_token_num":450},{"new_code_raw":"public boolean isMirrored() { if (!fMirroringEnabled) return false; Object property = getProperty(MIRRORED); return property instanceof Boolean && (Boolean) property; }","old_code_raw":"\tpublic boolean isMirrored() {\n\t\tObject property = getProperty(MIRRORED);\n\t\treturn property instanceof Boolean && (Boolean) property;\n\t}\n","new_comment_raw":"Returns true if the compare viewer is mirrored, i.e.","old_comment_raw":"Only the views are mirrored.","label":1,"pre_label":0,"AST_level":6,"line_counts":8,"new_code_token_num":33},{"new_code_raw":"public static Viewable create(final boolean authEnabled, final String templateName, final SecurityContext sc) { return new ViewableWithPermissions(authEnabled, templateName, sc, true, null); }","old_code_raw":"  public static Viewable create(final String templateName, final SecurityContext sc, final Object model) {\n    return new ViewableWithPermissions(templateName, sc, true, model);\n  }\n","new_comment_raw":"Create the web page using the given template and  SecurityContext after authentication is done.","old_comment_raw":"Create a web page using the given template, SecurityContext and model data.","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":34},{"new_code_raw":"private BufferedImage loadImage(int itemId, int quantity, boolean stackable) { SpritePixels sprite = client.get().createItemSprite(itemId, quantity, 1, SpritePixels.DEFAULT_SHADOW_COLOR, stackable ? 1 : 0, false, CLIENT_DEFAULT_ZOOM); return sprite.toBufferedImage(); }","old_code_raw":"\tprivate AsyncBufferedImage loadImage(int itemId, int quantity, boolean stackable)\n\t{\n\t\tAsyncBufferedImage img = new AsyncBufferedImage(36, 32, BufferedImage.TYPE_INT_ARGB);\n\t\tclientThread.invokeLater(() ->\n\t\t{\n\t\t\tif (client.getGameState().ordinal() < GameState.LOGIN_SCREEN.ordinal())\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tSpritePixels sprite = client.createItemSprite(itemId, quantity, 1, SpritePixels.DEFAULT_SHADOW_COLOR,\n\t\t\t\tstackable ? 1 : 0, false, CLIENT_DEFAULT_ZOOM);\n\t\t\tif (sprite == null)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tsprite.toBufferedImage(img);\n\t\t\timg.changed();\n\t\t\treturn true;\n\t\t});\n\t\treturn img;\n\t}\n","new_comment_raw":"Loads item sprite from game, makes transparent, and generates image","old_comment_raw":"Loads item sprite from game, makes transparent, and generates image","label":0,"pre_label":1,"AST_level":8,"line_counts":7,"new_code_token_num":49},{"new_code_raw":"public Element writeSchema(Class javaType, Types types) throws Exception { \/\/ Let the caller generate WSDL if this is not a SimpleType if (!SimpleType.class.isAssignableFrom(javaType)) return null; \/\/ ComplexType representation of SimpleType bean class Element complexType = types.createElement(\"complexType\"); types.writeSchemaElement(xmlType, complexType); complexType.setAttribute(\"name\", xmlType.getLocalPart()); \/\/ Produce simpleContent extending base type. Element simpleContent = types.createElement(\"simpleContent\"); complexType.appendChild(simpleContent); Element extension = types.createElement(\"extension\"); simpleContent.appendChild(extension); \/\/ Get the base type from the \"value\" element of the bean String base = \"string\"; for (int i=0; i<propertyDescriptor.length; i++) { String propName = propertyDescriptor[i].getName(); if (!propName.equals(\"value\")) { if (typeDesc != null) { FieldDesc field = typeDesc.getFieldByName(propName); if (field != null) { if (field.isElement()) { \/\/ throw? } QName qname = field.getXmlName(); if (qname == null) { \/\/ Use the default... qname = new QName(\"\", propName); } \/\/ write attribute element Class fieldType = propertyDescriptor[i].getType(); \/\/ Attribute must be a simple type, enum or SimpleType if (!types.isAcceptableAsAttribute(fieldType)) { throw new AxisFault(Messages.getMessage(\"AttrNotSimpleType00\", propName, fieldType.getName())); } \/\/ write attribute element \/\/ TODO the attribute name needs to be preserved from the XML Element elem = types.createAttributeElement(propName, fieldType, field.getXmlType(), false, extension.getOwnerDocument()); extension.appendChild(elem); } } continue; } BeanPropertyDescriptor bpd = propertyDescriptor[i]; Class type = bpd.getType(); \/\/ Attribute must extend a simple type, enum or SimpleType if (!types.isAcceptableAsAttribute(type)) { throw new AxisFault(Messages.getMessage(\"AttrNotSimpleType01\", type.getName())); } base = types.writeType(type); extension.setAttribute(\"base\", base); } \/\/ done return complexType; }","old_code_raw":"    public boolean writeSchema(Types types) throws Exception {\n        \/\/ Let the caller generate WSDL if this is not a SimpleType\n        if (!SimpleType.class.isAssignableFrom(javaType))\n            return false;\n\n        \/\/ ComplexType representation of SimpleType bean class\n        Element complexType = types.createElement(\"complexType\");\n        types.writeSchemaElement(xmlType, complexType);\n        complexType.setAttribute(\"name\", xmlType.getLocalPart());\n\n        \/\/ Produce simpleContent extending base type.\n        Element simpleContent = types.createElement(\"simpleContent\");\n        complexType.appendChild(simpleContent);\n        Element extension = types.createElement(\"extension\");\n        simpleContent.appendChild(extension);\n\n        \/\/ Get the base type from the \"value\" element of the bean\n        String base = \"string\";\n        for (int i=0; i<propertyDescriptor.length; i++) {\n            String propName = propertyDescriptor[i].getName();\n            if (!propName.equals(\"value\")) {\n                if (typeDesc != null) {\n                    FieldDesc field = typeDesc.getFieldByName(propName);\n                    if (field != null) {\n                        if (field.isElement()) {\n                            \/\/ throw?\n                        }\n                        QName qname = field.getXmlName();\n                        if (qname == null) {\n                            \/\/ Use the default...\n                            propName = propName;\n                            qname = new QName(\"\", propName);\n                        }\n\n                        \/\/  write attribute element\n                        Class fieldType = propertyDescriptor[i].getType();\n\n                        \/\/ Attribute must be a simple type, enum or SimpleType\n                        if (!types.isAcceptableAsAttribute(fieldType)) {\n                            throw new AxisFault(Messages.getMessage(\"AttrNotSimpleType00\",\n                                    propName,\n                                    fieldType.getName()));\n                        }\n\n                        \/\/ write attribute element\n                        \/\/ TODO the attribute name needs to be preserved from the XML\n                        String elementType = types.writeType(fieldType);\n                        Element elem = types.createAttributeElement(propName,\n                                elementType,\n                                false,\n                                extension.getOwnerDocument());\n                        extension.appendChild(elem);\n                    }\n                }\n                continue;\n            }\n\n            BeanPropertyDescriptor bpd = propertyDescriptor[i];\n            Class type = bpd.getType();\n            \/\/ Attribute must extend a simple type, enum or SimpleType\n            if (!types.isAcceptableAsAttribute(type)) {\n                throw new AxisFault(Messages.getMessage(\"AttrNotSimpleType01\",\n                        type.getName()));\n            }\n            base = types.writeType(type);\n            extension.setAttribute(\"base\", base);\n        }\n\n        \/\/ done\n        return true;\n\n    }\n","new_comment_raw":"Return XML schema for the specified type, suitable for insertion into the &lt;types&gt; element of a WSDL document, or underneath an &lt;element&gt; or &lt;attribute&gt; declaration.","old_comment_raw":"Return XML schema for the specified type, suitable for insertion into the element of a WSDL document.","label":1,"pre_label":0,"AST_level":16,"line_counts":73,"new_code_token_num":428},{"new_code_raw":"public static String[] getModulePrefixes(ServletContext context) { return (String[]) context.getAttribute(Globals.MODULE_PREFIXES_KEY); }","old_code_raw":"    public synchronized static String[] getModulePrefixes(ServletContext context) {\n        \/\/ TODO Move prefix list initialization to ActionServlet.init() and unsynchronize\n        \/\/ this method in Struts 1.2 \n        \n        String prefixes[] = (String[]) context.getAttribute(PREFIXES_KEY);\n        if (prefixes != null) {\n            return (prefixes);\n        }\n\n        ArrayList list = new ArrayList();\n        Enumeration names = context.getAttributeNames();\n        while (names.hasMoreElements()) {\n            String name = (String) names.nextElement();\n            if (!name.startsWith(Globals.MODULE_KEY)) {\n                continue;\n            }\n            String prefix = name.substring(Globals.MODULE_KEY.length());\n            if (prefix.length() > 0) {\n                list.add(prefix);\n            }\n        }\n        prefixes = (String[]) list.toArray(new String[list.size()]);\n        context.setAttribute(PREFIXES_KEY, prefixes);\n        return (prefixes);\n\n    }\n","new_comment_raw":"Return the list of module prefixes that are defined for this web application.","old_comment_raw":"Return the list of module prefixes that are defined for this web application, creating it if necessary.","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":25},{"new_code_raw":"private ObjectWriter buildColumn(ParentShim parent, ColumnMetadata colSchema) { if (colSchema.isMultiList()) { return buildRepeatedList(parent, colSchema); } else if (colSchema.isMap()) { return buildMap(parent, colSchema); } else if (isSingleList(colSchema)) { return buildSingleList(parent, colSchema); } else if (colSchema.isVariant()) { return buildVariant(parent, colSchema); } else if (colSchema.isDict()) { return buildDict(parent, colSchema); } else { return buildPrimitive(parent, colSchema); } }","old_code_raw":"  private ObjectWriter buildColumn(ParentShim parent, ColumnMetadata colSchema) {\n    if (colSchema.isMultiList()) {\n      return buildRepeatedList(parent, colSchema);\n    } else if (colSchema.isMap()) {\n      return buildMap(parent, colSchema);\n    } else if (isSingleList(colSchema)) {\n      return buildSingleList(parent, colSchema);\n    } else if (colSchema.isVariant()) {\n      return buildVariant(parent, colSchema);\n    } else {\n      return buildPrimitive(parent, colSchema);\n    }\n  }\n","new_comment_raw":"Build the column writer, and any nested content, returning the built column writer as a generic object writer.","old_comment_raw":"Build the column writer, and any nested content, returning the built column writer as a generic object writer.","label":0,"pre_label":1,"AST_level":11,"line_counts":16,"new_code_token_num":112},{"new_code_raw":"protected static ASTNode findDeclaration2(Name findMe, ASTNode alternateParent) { ASTNode declaringClass = null; ASTNode parent = findMe.getParent(); ASTNode ret = null; ArrayList<Integer> constrains = new ArrayList<Integer>(); if (parent.getNodeType() == ASTNode.METHOD_INVOCATION) { Expression exp = (Expression) ((MethodInvocation) parent) .getStructuralProperty(MethodInvocation.EXPRESSION_PROPERTY); \/\/TODO: Note the imbalance of constrains.add(ASTNode.METHOD_DECLARATION); \/\/ Possibly a bug here. Investigate later. if (((MethodInvocation) parent).getName().toString() .equals(findMe.toString())) { constrains.add(ASTNode.METHOD_DECLARATION); if (exp != null) { constrains.add(ASTNode.TYPE_DECLARATION); \/\/ log(\"MI EXP: \" + exp.toString() + \" of type \" \/\/ + exp.getClass().getName() + \" parent: \" + exp.getParent()); if (exp instanceof MethodInvocation) { SimpleType stp = extracTypeInfo(findDeclaration2(((MethodInvocation) exp) .getName(), alternateParent)); if (stp == null) return null; declaringClass = findDeclaration2(stp.getName(), alternateParent); return definedIn(declaringClass, ((MethodInvocation) parent) .getName().toString(), constrains, declaringClass); } else if (exp instanceof FieldAccess) { SimpleType stp = extracTypeInfo(findDeclaration2(((FieldAccess) exp) .getName(), alternateParent)); if (stp == null) return null; declaringClass = findDeclaration2((stp.getName()), alternateParent); return definedIn(declaringClass, ((MethodInvocation) parent) .getName().toString(), constrains, declaringClass); } if (exp instanceof SimpleName) { SimpleType stp = extracTypeInfo(findDeclaration2(((SimpleName) exp), alternateParent)); if (stp == null) return null; declaringClass = findDeclaration2(stp.getName(), alternateParent); \/\/ log(\"MI.SN \" + getNodeAsString(declaringClass)); constrains.add(ASTNode.METHOD_DECLARATION); return definedIn(declaringClass, ((MethodInvocation) parent) .getName().toString(), constrains, declaringClass); } } } else { parent = parent.getParent(); \/\/ Move one up the ast. V V IMP!! alternateParent = alternateParent.getParent(); } } else if (parent.getNodeType() == ASTNode.FIELD_ACCESS) { FieldAccess fa = (FieldAccess) parent; Expression exp = fa.getExpression(); if (fa.getName().toString().equals(findMe.toString())) { constrains.add(ASTNode.FIELD_DECLARATION); if (exp != null) { constrains.add(ASTNode.TYPE_DECLARATION); \/\/ log(\"FA EXP: \" + exp.toString() + \" of type \" \/\/ + exp.getClass().getName() + \" parent: \" + exp.getParent()); if (exp instanceof MethodInvocation) { SimpleType stp = extracTypeInfo(findDeclaration2(((MethodInvocation) exp) .getName(), alternateParent)); if (stp == null) return null; declaringClass = findDeclaration2(stp.getName(), alternateParent); return definedIn(declaringClass, fa.getName().toString(), constrains, declaringClass); } else if (exp instanceof FieldAccess) { SimpleType stp = extracTypeInfo(findDeclaration2(((FieldAccess) exp) .getName(), alternateParent)); if (stp == null) return null; declaringClass = findDeclaration2((stp.getName()), alternateParent); constrains.add(ASTNode.TYPE_DECLARATION); return definedIn(declaringClass, fa.getName().toString(), constrains, declaringClass); } if (exp instanceof SimpleName) { SimpleType stp = extracTypeInfo(findDeclaration2(((SimpleName) exp), alternateParent)); if (stp == null) return null; declaringClass = findDeclaration2(stp.getName(), alternateParent); \/\/ log(\"FA.SN \" + getNodeAsString(declaringClass)); constrains.add(ASTNode.METHOD_DECLARATION); return definedIn(declaringClass, fa.getName().toString(), constrains, declaringClass); } } } else { parent = parent.getParent(); \/\/ Move one up the ast. V V IMP!! alternateParent = alternateParent.getParent(); } } else if (parent.getNodeType() == ASTNode.QUALIFIED_NAME) { QualifiedName qn = (QualifiedName) parent; if (!findMe.toString().equals(qn.getQualifier().toString())) { SimpleType stp = extracTypeInfo(findDeclaration2((qn.getQualifier()), alternateParent)); if(stp == null) return null; declaringClass = findDeclaration2(stp.getName(), alternateParent); \/\/ log(qn.getQualifier() + \"->\" + qn.getName()); \/\/ log(\"QN decl class: \" + getNodeAsString(declaringClass)); constrains.clear(); constrains.add(ASTNode.TYPE_DECLARATION); constrains.add(ASTNode.FIELD_DECLARATION); return definedIn(declaringClass, qn.getName().toString(), constrains, null); } else{ if(findMe instanceof QualifiedName){ QualifiedName qnn = (QualifiedName) findMe; \/\/ log(\"findMe is a QN, \" \/\/ + (qnn.getQualifier().toString() + \" other \" + qnn.getName() \/\/ .toString())); SimpleType stp = extracTypeInfo(findDeclaration2((qnn.getQualifier()), alternateParent)); if (stp == null) { return null; } \/\/ log(qnn.getQualifier() + \"->\" + qnn.getName()); declaringClass = findDeclaration2(stp.getName(), alternateParent); \/\/ log(\"QN decl class: \" \/\/ + getNodeAsString(declaringClass)); constrains.clear(); constrains.add(ASTNode.TYPE_DECLARATION); constrains.add(ASTNode.FIELD_DECLARATION); return definedIn(declaringClass, qnn.getName().toString(), constrains, null); } } } else if (parent.getNodeType() == ASTNode.SIMPLE_TYPE) { constrains.add(ASTNode.TYPE_DECLARATION); if (parent.getParent().getNodeType() == ASTNode.CLASS_INSTANCE_CREATION) constrains.add(ASTNode.CLASS_INSTANCE_CREATION); } else if (parent instanceof Expression) { \/\/ constrains.add(ASTNode.TYPE_DECLARATION); \/\/ constrains.add(ASTNode.METHOD_DECLARATION); \/\/ constrains.add(ASTNode.FIELD_DECLARATION); } \/\/ TODO: in findDec, we also have a case where parent of type TD is handled. \/\/ Figure out if needed here as well. \/\/ log(\"Alternate parent: \" + getNodeAsString(alternateParent)); while (alternateParent != null) { \/\/ log(\"findDeclaration2 -> \" \/\/ + getNodeAsString(alternateParent)); for (Object oprop : alternateParent.structuralPropertiesForType()) { StructuralPropertyDescriptor prop = (StructuralPropertyDescriptor) oprop; if (prop.isChildProperty() || prop.isSimpleProperty()) { if (alternateParent.getStructuralProperty(prop) instanceof ASTNode) { \/\/ log(prop + \" C\/S Prop of -> \" \/\/ + getNodeAsString(alternateParent)); ret = definedIn((ASTNode) alternateParent .getStructuralProperty(prop), findMe.toString(), constrains, declaringClass); if (ret != null) return ret; } } else if (prop.isChildListProperty()) { \/\/ log((prop) + \" ChildList props of \" \/\/ + getNodeAsString(alternateParent)); List<ASTNode> nodelist = (List<ASTNode>) alternateParent .getStructuralProperty(prop); for (ASTNode retNode : nodelist) { ret = definedIn(retNode, findMe.toString(), constrains, declaringClass); if (ret != null) return ret; } } } alternateParent = alternateParent.getParent(); } return null; }","old_code_raw":"  protected static ASTNode findDeclaration2(Name findMe, ASTNode alternateParent) {\n    ASTNode declaringClass = null;\n    ASTNode parent = findMe.getParent();\n    ASTNode ret = null;\n    ArrayList<Integer> constrains = new ArrayList<Integer>();\n    if (parent.getNodeType() == ASTNode.METHOD_INVOCATION) {\n      Expression exp = (Expression) ((MethodInvocation) parent)\n          .getStructuralProperty(MethodInvocation.EXPRESSION_PROPERTY);\n      \/\/TODO: Note the imbalance of constrains.add(ASTNode.METHOD_DECLARATION);\n      \/\/ Possibly a bug here. Investigate later.\n      if (((MethodInvocation) parent).getName().toString()\n          .equals(findMe.toString())) {\n        constrains.add(ASTNode.METHOD_DECLARATION);\n\n        if (exp != null) {\n          constrains.add(ASTNode.TYPE_DECLARATION);\n\/\/          log(\"MI EXP: \" + exp.toString() + \" of type \"\n\/\/              + exp.getClass().getName() + \" parent: \" + exp.getParent());\n          if (exp instanceof MethodInvocation) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((MethodInvocation) exp)\n                                                                 .getName(),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2(stp.getName(), alternateParent);\n            return definedIn(declaringClass, ((MethodInvocation) parent)\n                .getName().toString(), constrains, declaringClass);\n          } else if (exp instanceof FieldAccess) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((FieldAccess) exp)\n                                                                 .getName(),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2((stp.getName()), alternateParent);\n            return definedIn(declaringClass, ((MethodInvocation) parent)\n                .getName().toString(), constrains, declaringClass);\n          }\n          if (exp instanceof SimpleName) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((SimpleName) exp),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2(stp.getName(), alternateParent);\n\/\/            log(\"MI.SN \" + getNodeAsString(declaringClass));\n            constrains.add(ASTNode.METHOD_DECLARATION);\n            return definedIn(declaringClass, ((MethodInvocation) parent)\n                .getName().toString(), constrains, declaringClass);\n          }\n\n        }\n      } else {\n        parent = parent.getParent(); \/\/ Move one up the ast. V V IMP!!\n        alternateParent = alternateParent.getParent();\n      }\n    } else if (parent.getNodeType() == ASTNode.FIELD_ACCESS) {\n      FieldAccess fa = (FieldAccess) parent;\n      Expression exp = fa.getExpression();\n      if (fa.getName().toString().equals(findMe.toString())) {\n        constrains.add(ASTNode.FIELD_DECLARATION);\n\n        if (exp != null) {\n          constrains.add(ASTNode.TYPE_DECLARATION);\n\/\/          log(\"FA EXP: \" + exp.toString() + \" of type \"\n\/\/              + exp.getClass().getName() + \" parent: \" + exp.getParent());\n          if (exp instanceof MethodInvocation) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((MethodInvocation) exp)\n                                                                 .getName(),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2(stp.getName(), alternateParent);\n            return definedIn(declaringClass, fa.getName().toString(),\n                             constrains, declaringClass);\n          } else if (exp instanceof FieldAccess) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((FieldAccess) exp)\n                                                                 .getName(),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2((stp.getName()), alternateParent);\n            constrains.add(ASTNode.TYPE_DECLARATION);\n            return definedIn(declaringClass, fa.getName().toString(),\n                             constrains, declaringClass);\n          }\n          if (exp instanceof SimpleName) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((SimpleName) exp),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2(stp.getName(), alternateParent);\n\/\/            log(\"FA.SN \" + getNodeAsString(declaringClass));\n            constrains.add(ASTNode.METHOD_DECLARATION);\n            return definedIn(declaringClass, fa.getName().toString(),\n                             constrains, declaringClass);\n          }\n        }\n\n      } else {\n        parent = parent.getParent(); \/\/ Move one up the ast. V V IMP!!\n        alternateParent = alternateParent.getParent();\n      }\n    } else if (parent.getNodeType() == ASTNode.QUALIFIED_NAME) {\n\n      QualifiedName qn = (QualifiedName) parent;\n      if (!findMe.toString().equals(qn.getQualifier().toString())) {\n\n        SimpleType stp = extracTypeInfo(findDeclaration2((qn.getQualifier()),\n                                                         alternateParent));\n        if(stp == null)\n          return null;\n        declaringClass = findDeclaration2(stp.getName(), alternateParent);\n\/\/        log(qn.getQualifier() + \"->\" + qn.getName());\n\/\/        log(\"QN decl class: \" + getNodeAsString(declaringClass));\n        constrains.clear();\n        constrains.add(ASTNode.TYPE_DECLARATION);\n        constrains.add(ASTNode.FIELD_DECLARATION);\n        return definedIn(declaringClass, qn.getName().toString(), constrains,\n                         null);\n      }\n      else{\n        if(findMe instanceof QualifiedName){\n          QualifiedName qnn = (QualifiedName) findMe;\n\/\/          log(\"findMe is a QN, \"\n\/\/              + (qnn.getQualifier().toString() + \" other \" + qnn.getName()\n\/\/                  .toString()));\n\n          SimpleType stp = extracTypeInfo(findDeclaration2((qnn.getQualifier()), alternateParent));\n\/\/          log(qnn.getQualifier() + \"->\" + qnn.getName());\n          declaringClass = findDeclaration2(stp.getName(), alternateParent);\n\n\/\/          log(\"QN decl class: \"\n\/\/              + getNodeAsString(declaringClass));\n          constrains.clear();\n          constrains.add(ASTNode.TYPE_DECLARATION);\n          constrains.add(ASTNode.FIELD_DECLARATION);\n          return definedIn(declaringClass, qnn.getName().toString(), constrains,\n                           null);\n        }\n      }\n    } else if (parent.getNodeType() == ASTNode.SIMPLE_TYPE) {\n      constrains.add(ASTNode.TYPE_DECLARATION);\n      if (parent.getParent().getNodeType() == ASTNode.CLASS_INSTANCE_CREATION)\n        constrains.add(ASTNode.CLASS_INSTANCE_CREATION);\n    } else if (parent instanceof Expression) {\n\/\/      constrains.add(ASTNode.TYPE_DECLARATION);\n\/\/      constrains.add(ASTNode.METHOD_DECLARATION);\n\/\/      constrains.add(ASTNode.FIELD_DECLARATION);\n    } \/\/ TODO: in findDec, we also have a case where parent of type TD is handled.\n      \/\/ Figure out if needed here as well.\n\/\/    log(\"Alternate parent: \" + getNodeAsString(alternateParent));\n    while (alternateParent != null) {\n\/\/      log(\"findDeclaration2 -> \"\n\/\/          + getNodeAsString(alternateParent));\n      for (Object oprop : alternateParent.structuralPropertiesForType()) {\n        StructuralPropertyDescriptor prop = (StructuralPropertyDescriptor) oprop;\n        if (prop.isChildProperty() || prop.isSimpleProperty()) {\n          if (alternateParent.getStructuralProperty(prop) instanceof ASTNode) {\n\/\/            log(prop + \" C\/S Prop of -> \"\n\/\/                + getNodeAsString(alternateParent));\n            ret = definedIn((ASTNode) alternateParent\n                                .getStructuralProperty(prop),\n                            findMe.toString(), constrains, declaringClass);\n            if (ret != null)\n              return ret;\n          }\n        } else if (prop.isChildListProperty()) {\n\/\/          log((prop) + \" ChildList props of \"\n\/\/              + getNodeAsString(alternateParent));\n          List<ASTNode> nodelist = (List<ASTNode>) alternateParent\n              .getStructuralProperty(prop);\n          for (ASTNode retNode : nodelist) {\n            ret = definedIn(retNode, findMe.toString(), constrains,\n                            declaringClass);\n            if (ret != null)\n              return ret;\n          }\n        }\n      }\n      alternateParent = alternateParent.getParent();\n    }\n    return null;\n  }\n","new_comment_raw":"A variation of findDeclaration() but accepts an alternate parent ASTNode","old_comment_raw":"A variation of findDeclaration() but accepts an alternate parent ASTNode","label":0,"pre_label":1,"AST_level":18,"line_counts":188,"new_code_token_num":1441},{"new_code_raw":"public long getDifferenceAsLong(ReadableInstant instant) { if (instant == null) { return getField().getDifferenceAsLong(getMillis(), DateTimeUtils.currentTimeMillis()); } return getField().getDifferenceAsLong(getMillis(), instant.getMillis()); }","old_code_raw":"    public long getDifferenceAsLong(ReadableInstant instant) {\n        if (instant == null) {\n            return getField().getDifferenceAsLong(getReadableInstant().getMillis(), DateTimeUtils.currentTimeMillis());\n        }\n        return getField().getDifferenceAsLong(getReadableInstant().getMillis(), instant.getMillis());\n    }\n","new_comment_raw":"Returns the difference between this field property instant and the one passed in, in the units of this field.","old_comment_raw":"Returns the difference between this field property instant and the one passed in, in the units of this field.","label":0,"pre_label":1,"AST_level":8,"line_counts":7,"new_code_token_num":48},{"new_code_raw":"public static IType createType(IASTDeclarator declarator) { IASTDeclSpecifier declSpec = null; IASTNode node = declarator.getParent(); while( node instanceof IASTDeclarator ){ declarator = (IASTDeclarator) node; node = node.getParent(); } if( node instanceof IASTParameterDeclaration ) declSpec = ((IASTParameterDeclaration) node).getDeclSpecifier(); else if( node instanceof IASTSimpleDeclaration ) declSpec = ((IASTSimpleDeclaration)node).getDeclSpecifier(); else if( node instanceof IASTFunctionDefinition ) declSpec = ((IASTFunctionDefinition)node).getDeclSpecifier(); else if( node instanceof IASTTypeId ) declSpec = ((IASTTypeId)node).getDeclSpecifier(); boolean isParameter = ( node instanceof IASTParameterDeclaration || node.getParent() instanceof ICASTKnRFunctionDeclarator ); IType type = null; \/\/C99 6.7.5.3-12 The storage class specifier for a parameter declaration is ignored unless the declared parameter is one of the \/\/members of the parameter type list for a function definition. if( isParameter && node.getParent().getParent() instanceof IASTFunctionDefinition ){ type = createBaseType( declSpec ); } else { type = createType( declSpec ); } type = createType( type, declarator ); if( isParameter ) { \/\/C99: 6.7.5.3-7 a declaration of a parameter as \"array of type\" shall be adjusted to \"qualified pointer to type\", where the \/\/type qualifiers (if any) are those specified within the [ and ] of the array type derivation if( type instanceof IArrayType ){ CArrayType at = (CArrayType) type; type = new CQualifiedPointerType( at.getType(), at.getModifier() ); } else if( type instanceof IFunctionType ) { \/\/-8 A declaration of a parameter as \"function returning type\" shall be adjusted to \"pointer to function returning type\" type = new CPointerType( type ); } } return type; }","old_code_raw":"\tpublic static IType createType(IASTName name) {\n\t\tif (!(name.getParent() instanceof IASTDeclarator)) return null;\n\t\t\n\t    IASTDeclSpecifier declSpec = null;\n\t\tIASTDeclarator declarator = (IASTDeclarator) name.getParent();\n\t\t\n\t\tIASTNode node = declarator.getParent();\n\t\twhile( node instanceof IASTDeclarator ){\n\t\t\tdeclarator = (IASTDeclarator) node;\n\t\t\tnode = node.getParent();\n\t\t}\n\t\t\n\t\tif( node instanceof IASTParameterDeclaration )\n\t\t\tdeclSpec = ((IASTParameterDeclaration) node).getDeclSpecifier();\n\t\telse if( node instanceof IASTSimpleDeclaration )\n\t\t\tdeclSpec = ((IASTSimpleDeclaration)node).getDeclSpecifier();\n\t\telse if( node instanceof IASTFunctionDefinition )\n\t\t\tdeclSpec = ((IASTFunctionDefinition)node).getDeclSpecifier();\n\t\telse if( node instanceof IASTTypeId )\n\t\t    declSpec = ((IASTTypeId)node).getDeclSpecifier();\n\t\n\t\tboolean isParameter = ( node instanceof IASTParameterDeclaration || node.getParent() instanceof ICASTKnRFunctionDeclarator ); \n\t\t\n\t\tIType type = null;\n\t\t\n\t\t\/\/C99 6.7.5.3-12 The storage class specifier for a parameter declaration is ignored unless the declared parameter is one of the \n\t\t\/\/members of the parameter type list for a function definition.\n\t\tif( isParameter && node.getParent().getParent() instanceof IASTFunctionDefinition ){\n\t\t    type = createBaseType( declSpec );\n\t\t} else {\n\t\t    type = createType( declSpec );\n\t\t}\n\t\t\n\t\ttype = createType( type, declarator );\n\t\t\n\t\t\n        if( isParameter ) {\n            \/\/C99: 6.7.5.3-7 a declaration of a parameter as \"array of type\" shall be adjusted to \"qualified pointer to type\", where the\n    \t\t\/\/type qualifiers (if any) are those specified within the [ and ] of the array type derivation\n            if( type instanceof IArrayType ){\n\t            CArrayType at = (CArrayType) type;\n\t            type = new CQualifiedPointerType( at.getType(), at.getModifier() );\n\t        } else if( type instanceof IFunctionType ) {\n\t            \/\/-8 A declaration of a parameter as \"function returning type\" shall be adjusted to \"pointer to function returning type\"\n\t            type = new CPointerType( type );\n\t        }\n        }\n        \n\t\treturn type;\n\t}\n","new_comment_raw":"Create an IType for an IASTDeclarator.","old_comment_raw":"Create an IType for an IASTName.","label":1,"pre_label":0,"AST_level":11,"line_counts":49,"new_code_token_num":347},{"new_code_raw":"public static CodegenConfig forName(String name) { ServiceLoader<CodegenConfig> loader = load(CodegenConfig.class); StringBuilder availableConfigs = new StringBuilder(); for (CodegenConfig config : loader) { if (config.getName().equals(name)) { return config; } availableConfigs.append(config.getName()).append(\"\\n\"); } \/\/ else try to load directly try { return (CodegenConfig) Class.forName(name).getDeclaredConstructor().newInstance(); } catch (Exception e) { throw new GeneratorNotFoundException(\"Can't load config class with name '\".concat(name) + \"'\\nAvailable:\\n\" + availableConfigs.toString(), e); } }","old_code_raw":"    public static CodegenConfig forName(String name) {\n        ServiceLoader<CodegenConfig> loader = load(CodegenConfig.class);\n\n        StringBuilder availableConfigs = new StringBuilder();\n\n        for (CodegenConfig config : loader) {\n            if (config.getName().equals(name)) {\n                return config;\n            }\n\n            availableConfigs.append(config.getName()).append(\"\\n\");\n        }\n\n        \/\/ else try to load directly\n        try {\n            return (CodegenConfig) Class.forName(name).newInstance();\n        } catch (Exception e) {\n            throw new GeneratorNotFoundException(\"Can't load config class with name '\".concat(name) + \"'\\nAvailable:\\n\" + availableConfigs.toString(), e);\n        }\n    }\n","new_comment_raw":"Tries to load config class with SPI first, then with class name directly from classpath","old_comment_raw":"Tries to load config class with SPI first, then with class name directly from classpath","label":0,"pre_label":1,"AST_level":11,"line_counts":21,"new_code_token_num":137},{"new_code_raw":"public IterOutcome innerNext() { if (hasRemainderForLeftJoin) { \/\/ if set that means there is spill over from previous left batch and no \/\/ corresponding right rows and it is left join scenario allocateVectors(); boolean hasMoreRows = !handleRemainingLeftRows(); if (leftUpstream == EMIT || hasMoreRows) { logger.debug(\"Sending current output batch with EMIT outcome since left is received with EMIT and is fully \" + \"consumed now in output batch\"); hasRemainderForLeftJoin = hasMoreRows; finalizeOutputContainer(); return (leftUpstream == EMIT) ? EMIT : OK; } else { \/\/ release memory for previous left batch leftJoinIndex = -1; VectorAccessibleUtilities.clear(left); } } \/\/ We don't do anything special on FIRST state. Process left batch first and then right batch if need be IterOutcome childOutcome = processLeftBatch(); logger.debug(\"Received left batch with outcome {}\", childOutcome); if (processLeftBatchInFuture && hasRemainderForLeftJoin) { finalizeOutputContainer(); hasRemainderForLeftJoin = false; return OK; } \/\/ reset this state after calling processLeftBatch above. processLeftBatchInFuture = false; hasRemainderForLeftJoin = false; \/\/ If the left batch doesn't have any record in the incoming batch (with OK_NEW_SCHEMA\/EMIT) or the state returned \/\/ from left side is terminal state then just return the IterOutcome and don't call next() on right branch if (isTerminalOutcome(childOutcome) || left.getRecordCount() == 0) { container.setRecordCount(0); return childOutcome; } \/\/ Left side has some records in the batch so let's process right batch childOutcome = processRightBatch(); logger.debug(\"Received right batch with outcome {}\", childOutcome); \/\/ reset the left & right outcomes to OK here and send the empty batch downstream. Non-Empty right batch with \/\/ OK_NEW_SCHEMA will be handled in subsequent next call if (childOutcome == OK_NEW_SCHEMA) { leftUpstream = (leftUpstream != EMIT) ? OK : leftUpstream; rightUpstream = OK; return childOutcome; } if (isTerminalOutcome(childOutcome)) { return childOutcome; } \/\/ If OK_NEW_SCHEMA is seen only on non empty left batch but not on right batch, then we should setup schema in \/\/ output container based on new left schema and old right schema. If schema change failed then return STOP \/\/ downstream if (leftUpstream == OK_NEW_SCHEMA) { handleSchemaChange(); } \/\/ Setup the references of left, right and outgoing container in generated operator state = BatchState.NOT_FIRST; \/\/ Update the memory manager only if its a brand new incoming i.e. leftJoinIndex and rightJoinIndex is 0 \/\/ Otherwise there will be a case where while filling last output batch, some records from previous left or \/\/ right batch are still left to be sent in output for which we will count this batch twice. The actual checks \/\/ are done in updateMemoryManager updateMemoryManager(LEFT_INDEX); \/\/ We have to call update on memory manager for empty batches (rightJoinIndex = -1) as well since other wise while \/\/ allocating memory for vectors below it can fail. Since in that case colSize will not have any info on right side \/\/ vectors and throws NPE. The actual checks are done in updateMemoryManager updateMemoryManager(RIGHT_INDEX); if (outputIndex > 0) { \/\/ this means batch is already allocated but because of new incoming the width and output row count might have \/\/ changed. So update the maxOutputRowCount with new value if (useMemoryManager) { setMaxOutputRowCount(batchMemoryManager.getCurrentOutgoingMaxRowCount()); } } \/\/ if output is not allocated then maxRowCount will be set correctly below \/\/ allocate space for the outgoing batch allocateVectors(); return produceOutputBatch(); }","old_code_raw":"  public IterOutcome innerNext() {\n\n    if (hasRemainderForLeftJoin) { \/\/ if set that means there is spill over from previous left batch and no\n      \/\/ corresponding right rows and it is left join scenario\n      allocateVectors();\n\n      boolean hasMoreRows = !handleRemainingLeftRows();\n      if (leftUpstream == EMIT || hasMoreRows) {\n        logger.debug(\"Sending current output batch with EMIT outcome since left is received with EMIT and is fully \" +\n          \"consumed now in output batch\");\n        hasRemainderForLeftJoin = hasMoreRows;\n        finalizeOutputContainer();\n        return (leftUpstream == EMIT) ? EMIT : OK;\n      } else {\n        \/\/ release memory for previous left batch\n        leftJoinIndex = -1;\n        VectorAccessibleUtilities.clear(left);\n      }\n    }\n\n    \/\/ We don't do anything special on FIRST state. Process left batch first and then right batch if need be\n    IterOutcome childOutcome = processLeftBatch();\n    logger.debug(\"Received left batch with outcome {}\", childOutcome);\n\n    if (processLeftBatchInFuture && hasRemainderForLeftJoin) {\n      finalizeOutputContainer();\n      hasRemainderForLeftJoin = false;\n      return OK;\n    }\n\n    \/\/ reset this state after calling processLeftBatch above.\n    processLeftBatchInFuture = false;\n    hasRemainderForLeftJoin = false;\n\n    \/\/ If the left batch doesn't have any record in the incoming batch (with OK_NEW_SCHEMA\/EMIT) or the state returned\n    \/\/ from left side is terminal state then just return the IterOutcome and don't call next() on right branch\n    if (isTerminalOutcome(childOutcome) || left.getRecordCount() == 0) {\n      container.setRecordCount(0);\n      return childOutcome;\n    }\n\n    \/\/ Left side has some records in the batch so let's process right batch\n    childOutcome = processRightBatch();\n    logger.debug(\"Received right batch with outcome {}\", childOutcome);\n\n    \/\/ reset the left & right outcomes to OK here and send the empty batch downstream. Non-Empty right batch with\n    \/\/ OK_NEW_SCHEMA will be handled in subsequent next call\n    if (childOutcome == OK_NEW_SCHEMA) {\n      leftUpstream = (leftUpstream != EMIT) ? OK : leftUpstream;\n      rightUpstream = OK;\n      return childOutcome;\n    }\n\n    if (isTerminalOutcome(childOutcome)) {\n      return childOutcome;\n    }\n\n    \/\/ If OK_NEW_SCHEMA is seen only on non empty left batch but not on right batch, then we should setup schema in\n    \/\/ output container based on new left schema and old right schema. If schema change failed then return STOP\n    \/\/ downstream\n    if (leftUpstream == OK_NEW_SCHEMA && !handleSchemaChange()) {\n      return STOP;\n    }\n\n    \/\/ Setup the references of left, right and outgoing container in generated operator\n    state = BatchState.NOT_FIRST;\n\n    \/\/ Update the memory manager only if its a brand new incoming i.e. leftJoinIndex and rightJoinIndex is 0\n    \/\/ Otherwise there will be a case where while filling last output batch, some records from previous left or\n    \/\/ right batch are still left to be sent in output for which we will count this batch twice. The actual checks\n    \/\/ are done in updateMemoryManager\n    updateMemoryManager(LEFT_INDEX);\n\n    \/\/ We have to call update on memory manager for empty batches (rightJoinIndex = -1) as well since other wise while\n    \/\/ allocating memory for vectors below it can fail. Since in that case colSize will not have any info on right side\n    \/\/ vectors and throws NPE. The actual checks are done in updateMemoryManager\n    updateMemoryManager(RIGHT_INDEX);\n\n    if (outputIndex > 0) {\n      \/\/ this means batch is already allocated but because of new incoming the width and output row count might have\n      \/\/ changed. So update the maxOutputRowCount with new value\n      if (useMemoryManager) {\n        setMaxOutputRowCount(batchMemoryManager.getCurrentOutgoingMaxRowCount());\n      }\n    }\n    \/\/ if output is not allocated then maxRowCount will be set correctly below\n    \/\/ allocate space for the outgoing batch\n    allocateVectors();\n\n    return produceOutputBatch();\n  }\n","new_comment_raw":"Gets the left and right incoming batch and produce the output batch.","old_comment_raw":"Method that get's left and right incoming batch and produce the output batch.","label":1,"pre_label":0,"AST_level":10,"line_counts":92,"new_code_token_num":691},{"new_code_raw":"private ZapTextArea getTxtSkipURL() { if (txtSkipURL == null) { txtSkipURL = new ZapTextArea(); txtSkipURL.setFont(new java.awt.Font(\"Default\", java.awt.Font.PLAIN, 11)); if (Model.getSingleton().getOptionsParam().getViewParam().getWmUiHandlingOption() == 0) { txtSkipURL.setSize(new java.awt.Dimension(290,52)); } } return txtSkipURL; }","old_code_raw":"    private JTextArea getTxtSkipURL() {\n        if (txtSkipURL == null) {\n            txtSkipURL = new JTextArea();\n            txtSkipURL.setFont(new java.awt.Font(\"Default\", java.awt.Font.PLAIN, 11));\n    \t    if (Model.getSingleton().getOptionsParam().getViewParam().getWmUiHandlingOption() == 0) {\n    \t    \ttxtSkipURL.setSize(new java.awt.Dimension(290,52));\n    \t    }\n        }\n        return txtSkipURL;\n    }\n","new_comment_raw":"This method initializes ZapTextArea","old_comment_raw":"This method initializes jTextArea","label":1,"pre_label":0,"AST_level":12,"line_counts":11,"new_code_token_num":77},{"new_code_raw":"protected Object convertTimestamp(Field fieldDefn, Object data) { java.util.Date date = null; if (data instanceof java.sql.Timestamp) { \/\/ JDBC specification indicates that this will be the canonical object for this JDBC type. date = (java.util.Date) data; } else if (data instanceof java.sql.Date) { \/\/ This should still work, even though it should have just date info date = (java.util.Date) data; } else if (data instanceof java.util.Date) { \/\/ Possible that some implementations might use this. date = (java.util.Date) data; } else if (data instanceof java.time.LocalDate) { \/\/ If we get a local date (no TZ info), we need to just convert to a util.Date (no TZ info) ... java.time.LocalDate local = (java.time.LocalDate) data; date = java.util.Date.from(local.atStartOfDay().toInstant(ZoneOffset.UTC)); } else if (data instanceof java.time.LocalDateTime) { \/\/ Get the instant in time by changing any date info to the epoch day so we only have time ... java.time.LocalDateTime local = (java.time.LocalDateTime) data; date = java.util.Date.from(local.toInstant(ZoneOffset.UTC)); } else { \/\/ An unexpected date = unexpectedTimestamp(data, fieldDefn); } return date; }","old_code_raw":"    protected Object convertTimestamp(Field fieldDefn, Object data) {\n        java.util.Date date = null;\n        if (data instanceof java.sql.Timestamp) {\n            \/\/ JDBC specification indicates that this will be the canonical object for this JDBC type.\n            date = (java.util.Date) data;\n        } else if (data instanceof java.sql.Date) {\n            \/\/ This should still work, even though it should have just date info\n            date = (java.util.Date) data;\n        } else if (data instanceof java.util.Date) {\n            \/\/ Possible that some implementations might use this.\n            date = (java.util.Date) data;\n        } else if (data instanceof java.time.LocalDate) {\n            \/\/ If we get a local date (no TZ info), we need to just convert to a util.Date (no TZ info) ...\n            java.time.LocalDate local = (java.time.LocalDate) data;\n            date = java.util.Date.from(local.atStartOfDay().toInstant(ZoneOffset.UTC));\n        } else if (data instanceof java.time.LocalDateTime) {\n            \/\/ Get the instant in time by changing any date info to the epoch day so we only have time ...\n            java.time.LocalDateTime local = (java.time.LocalDateTime) data;\n            date = java.util.Date.from(local.toInstant(ZoneOffset.UTC));\n        } else {\n            \/\/ An unexpected\n            date = unexpectedTimestamp(data, fieldDefn);\n        }\n        return date == null ? null : Timestamp.fromLogical(fieldDefn.schema(), date);\n    }\n","new_comment_raw":"Converts a value object for an expected JDBC type of  Types#TIMESTAMP.","old_comment_raw":"Converts a value object for an expected JDBC type of Types#TIMESTAMP.","label":0,"pre_label":1,"AST_level":14,"line_counts":26,"new_code_token_num":256},{"new_code_raw":"public static EBoolean endsWith(Expr<String> left, String right) { return operationFactory.createBoolean(Ops.ENDSWITH, left, exprFactory .createConstant(right)); }","old_code_raw":"    public static EBoolean endsWith(Expr<String> left, String right, boolean caseSensitive) {\n        if (caseSensitive){\n            return endsWith(left, right);            \n        }else{\n            return operationFactory.createBoolean(Ops.ENDSWITH_IC, left, exprFactory.createConstant(right));\n        }                \n    }\n","new_comment_raw":"Expr : left.endsWith(right)","old_comment_raw":"Expr : left.endsWith(right) (ignore case)","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":30},{"new_code_raw":"public JPAQuery clone(EntityManager entityManager){ return new JPAQuery(new DefaultSessionHolder(entityManager), getTemplates(), getMetadata().clone()); }","old_code_raw":"    public JPAQuery clone(EntityManager entityManager){\n        return new JPAQuery(new DefaultSessionHolder(entityManager), templates, getMetadata().clone());\n    }\n","new_comment_raw":"Clone the state of this query to a new JPAQuery instance with the given EntityManager","old_comment_raw":"Clone the state of this query to a new JPAQuery instance with the given EntityManager","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":31},{"new_code_raw":"public boolean shouldBuffer() { Window window = runningQuery.getQuery().getWindow(); boolean noWindow = window == null; \/\/ Only buffer if there is no window (including Raw) or if it's a record based window. return noWindow || !window.isTimeBased(); }","old_code_raw":"    public boolean shouldBuffer() {\n        Window window = runningQuery.getQuery().getWindow();\n        boolean noWindow = window == null;\n        \/\/ If it's a RAW query without a window, it should be buffered if and only if it timed out. This means that the\n        \/\/ query is not yet done. So this tells the driver to buffer the query to wait for more potential results.\n        if (noWindow && isRaw()) {\n            return runningQuery.isTimedOut();\n        }\n        \/\/ No window (and not raw) is a duration based query => do buffer. Otherwise, buffer if the window is time based.\n        return noWindow || window.isTimeBased();\n    }\n","new_comment_raw":"Returns if this query should buffer before emitting the final results.","old_comment_raw":"Returns if this query should buffer before emitting results.","label":1,"pre_label":0,"AST_level":6,"line_counts":8,"new_code_token_num":54},{"new_code_raw":"public MenuItem addItem(String text, boolean asHTML, Command cmd) { return addItem(new MenuItem(text, asHTML, cmd)); }","old_code_raw":"  public MenuItem addItem(SafeHtml html, ScheduledCommand cmd) {\n    return addItem(new MenuItem(html, Roles.getMenuitemRole(), false, cmd));\n  }\n","new_comment_raw":"Adds a menu item to the bar, that will fire the given command when it is selected.","old_comment_raw":"Adds a menu item to the bar containing SafeHtml, that will fire the given command when it is selected.","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":29},{"new_code_raw":"public Field withDefault(boolean defaultValue) { return new Field(name(), displayName(), type(), width, description(), importance(), dependents, () -> Boolean.valueOf(defaultValue), validator, recommender); }","old_code_raw":"    public Field withDefault(boolean defaultValue) {\n        return Field.create(name(), description(), defaultValue);\n    }\n","new_comment_raw":"Create and return a new Field instance that is a copy of this field but with the given default value.","old_comment_raw":"Create and return a new Field instance that is a copy of this field but with the given default value.","label":0,"pre_label":1,"AST_level":7,"line_counts":5,"new_code_token_num":51},{"new_code_raw":"public ENumber<Integer> length() { if (length == null) { length = ONumber.create(Integer.class, Ops.STRING_LENGTH, this); } return length; }","old_code_raw":"    public ENumber<Long> length() {\n        if (length == null) {\n            length = ONumber.create(Long.class, Ops.STRING_LENGTH, this);\n        }\n        return length;\n    }\n","new_comment_raw":"Return the length of this String","old_comment_raw":"Return the length of this String","label":0,"pre_label":1,"AST_level":9,"line_counts":7,"new_code_token_num":31},{"new_code_raw":"public static EBoolean startsWith(Expr<String> left, Expr<String> right) { return factory.createBoolean(Ops.STARTSWITH, left, right); }","old_code_raw":"    public static EBoolean startsWith(Expr<String> left, Expr<String> right) {\n        return createBoolean(Ops.STARTSWITH, left, right);\n    }\n","new_comment_raw":"Expr : left.startsWith(right)","old_comment_raw":"Expr : left.startsWith(right)","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":27},{"new_code_raw":"public final DBCompareColExpr in(Collection<?> values) { if (values==null || values.isEmpty()) return cmp(DBCmpType.EQUAL, null); \/\/ create expression return cmp(DBCmpType.IN, values); }","old_code_raw":"    public DBCompareColExpr in(Object value)\n    {\n        return cmp(DBCmpType.IN, listToArray(value));\n    }\n","new_comment_raw":"Creates and returns an expression for the SQL \"in\" operator.","old_comment_raw":"Creates and returns a new comparison object for the SQL \"in\" operator.","label":1,"pre_label":0,"AST_level":6,"line_counts":9,"new_code_token_num":44},{"new_code_raw":"public String getAuthorizationUrl() { return createAuthorizationUrlBuilder().build(); }","old_code_raw":"    public String getAuthorizationUrl() {\n        return getAuthorizationUrl(null, null, null);\n    }\n","new_comment_raw":"Returns the URL where you should redirect your users to authenticate your application.","old_comment_raw":"Returns the URL where you should redirect your users to authenticate your application.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":15},{"new_code_raw":"public boolean equals(Object obj) { if (obj == null) { return false; } if (obj == this) { return true; } if (obj.getClass() != getClass()) { return false; } FiltersAggregation rhs = (FiltersAggregation) obj; return super.equals(obj) && Objects.equals(bucketMap, rhs.bucketMap); }","old_code_raw":"    public boolean equals(Object obj) {\n        if (obj == null) {\n            return false;\n        }\n        if (obj == this) {\n            return true;\n        }\n        if (obj.getClass() != getClass()) {\n            return false;\n        }\n\n        FiltersAggregation rhs = (FiltersAggregation) obj;\n        return new EqualsBuilder()\n                .appendSuper(super.equals(obj))\n                .append(bucketMap, rhs.bucketMap)\n                .isEquals();\n    }\n","new_comment_raw":"Method for getting counts using named filters","old_comment_raw":"Method for getting counts using named filters","label":0,"pre_label":1,"AST_level":6,"line_counts":15,"new_code_token_num":69},{"new_code_raw":"private TableExportButton getExportButton() { if (exportButton == null) { exportButton = new TableExportButton(getParamsTable()); } return exportButton; }","old_code_raw":"\tprivate JButton getExportButton() {\n\t\tJButton csvExportButton = new JButton(Constant.messages.getString(\"params.toolbar.button.export\"));\n\t\tcsvExportButton.setIcon(new ImageIcon(ParamsPanel.class.getResource(\"\/resource\/icon\/16\/115.png\")));\n\t\tcsvExportButton.addActionListener((new AbstractAction() {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tWritableFileChooser chooser = new WritableFileChooser();\n\t\t\t\tchooser.setSelectedFile(new File(Constant.messages.getString(\"params.button.export.default.name\")));\n\t\t\t\tif (chooser\n\t\t\t\t\t\t.showSaveDialog(View.getSingleton().getMainFrame()) == WritableFileChooser.APPROVE_OPTION) {\n\t\t\t\t\tString file = chooser.getSelectedFile().toString();\n\t\t\t\t\tif (!file.endsWith(\".csv\")) {\n\t\t\t\t\t\tfile += \".csv\";\n\t\t\t\t\t}\n\t\t\t\t\ttry (CSVPrinter pw = new CSVPrinter(\n\t\t\t\t\t\t\tFiles.newBufferedWriter(chooser.getSelectedFile().toPath(), StandardCharsets.UTF_8),\n\t\t\t\t\t\t\tCSVFormat.DEFAULT)) {\n\t\t\t\t\t\tpw.printRecord(((ParamsTableModel) paramsTable.getModel()).getColumnNames());\n\t\t\t\t\t\tint rowCount = paramsTable.getRowCount();\n\t\t\t\t\t\tint colCount = paramsTable.getColumnCount();\n\t\t\t\t\t\tfor (int row = 0; row < rowCount; row++) {\n\t\t\t\t\t\t\tList<Object> valueOfRow = new ArrayList<Object>();\n\t\t\t\t\t\t\tfor (int col = 0; col < colCount; col++) {\n\t\t\t\t\t\t\t\tvalueOfRow.add(paramsTable.getValueAt(row, col));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpw.printRecord(valueOfRow);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tJOptionPane.showMessageDialog(View.getSingleton().getMainFrame(),\n\t\t\t\t\t\t\t\tConstant.messages.getString(\"params.button.export.success\"));\n\t\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\t\tJOptionPane.showMessageDialog(View.getSingleton().getMainFrame(),\n\t\t\t\t\t\t\t\tConstant.messages.getString(\"params.button.export.error\") + \"\\n\"\n\t\t\t\t\t\t\t\t\t\t+ ex.getLocalizedMessage());\n\t\t\t\t\t\tLOGGER.error(\"Export Failed: \" + ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\t\treturn csvExportButton;\n\t}\n","new_comment_raw":"This method initializes panelCommand","old_comment_raw":"This method initializes panelCommand","label":0,"pre_label":1,"AST_level":8,"line_counts":7,"new_code_token_num":26},{"new_code_raw":"public static Schema getReferencedSchema(OpenAPI openAPI, Schema schema) { if (schema != null && StringUtils.isNotEmpty(schema.get$ref())) { String name = getSimpleRef(schema.get$ref()); Schema referencedSchema = getSchema(openAPI, name); if(referencedSchema != null) { return referencedSchema; } } return schema; }","old_code_raw":"    public static Schema getReferencedSchema(OpenAPI openAPI, Schema schema) {\n        if (schema != null && StringUtils.isNotEmpty(schema.get$ref())) {\n            String name = getSimpleRef(schema.get$ref());\n            return getSchema(openAPI, name);\n        }\n        return schema;\n    }\n","new_comment_raw":"If a Schema contains a reference to an other Schema with '$ref', returns the referenced Schema if it is found or the actual Schema in the other cases.","old_comment_raw":"If a Schema contains a reference to an other Schema with '$ref', returns the referenced Schema or the actual Schema in the other cases.","label":1,"pre_label":0,"AST_level":8,"line_counts":11,"new_code_token_num":68},{"new_code_raw":"public boolean updateComponent(Widget component, UIDL uidl, boolean manageCaption) { \/\/ Switch to correct implementation if neede if (!widgetFactory.isCorrectImplementation(component, uidl)) { Layout parent = getParentLayout(component); if (parent != null) { Widget w = widgetFactory.createWidget(uidl); registerPaintable(uidl.getId(), (Paintable) w); parent.replaceChildComponent(component, w); ((Paintable) w).updateFromUIDL(uidl, this); return true; } } \/\/ Set captions \/\/ TODO Manage Error messages if (manageCaption) { Layout parent = getParentLayout(component); if (parent != null) parent.updateCaption(component, uidl); } \/\/ Visibility, Disabling and read-only status if (component instanceof FocusWidget) ((FocusWidget) component).setEnabled(!uidl .getBooleanAttribute(\"disabled\")); boolean visible = !uidl.getBooleanAttribute(\"invisible\"); component.setVisible(visible); if (!visible) return true; return false; }","old_code_raw":"\tpublic boolean updateComponent(Widget component, UIDL uidl,\n\t\t\tboolean manageCaption) {\n\n\t\tif (manageCaption) {\n\t\t\tLayout parent = getParentLayout(component);\n\t\t\tif (parent != null)\n\t\t\t\tparent.updateCaption(component, uidl);\n\t\t}\n\t\t\n\t\tboolean visible = !uidl.getBooleanAttribute(\"invisible\");\n\t\tcomponent.setVisible(visible);\n\t\tif (!visible) return true;\n\t\t\n\t\tif (widgetFactory.isCorrectImplementation(component, uidl))\n\t\t\treturn false;\n\t\tLayout parent = getParentLayout(component);\n\t\tif (parent == null)\n\t\t\treturn false;\n\t\tWidget w = widgetFactory.createWidget(uidl);\n\t\tregisterPaintable(uidl.getId(), (Paintable) w);\n\t\tparent.replaceChildComponent(component, w);\n\t\t((Paintable) w).updateFromUIDL(uidl, this);\n\n\t\treturn true;\n\t}\n","new_comment_raw":"Update generic component features.","old_comment_raw":"Ensure that correct implementation is used for the component.","label":1,"pre_label":0,"AST_level":10,"line_counts":36,"new_code_token_num":195},{"new_code_raw":"public static String encodeValue(Value value) { return NTriplesUtil.toNTriplesString(value); }","old_code_raw":"\tpublic static String encodeValue(Value value) {\r\n\t\tif (value instanceof BNode) {\r\n\t\t\t\/\/ SES-2129 special treatment of blank node names to avoid problems with round-tripping.\r\n\t\t\treturn \"_:\" + ((BNode)value).getID();\r\n\t\t}\r\n\t\t\r\n\t\t\/\/ for everything else we just use N-Triples serialization.\r\n\t\treturn NTriplesUtil.toNTriplesString(value);\r\n\t}\r\n","new_comment_raw":"Encodes a value for use in a URL.","old_comment_raw":"Encodes a value in a canonical serialized string format, for use in a URL query parameter.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":17},{"new_code_raw":"private AsyncBufferedImage loadImage(int itemId, int quantity, boolean stackable) { AsyncBufferedImage img = new AsyncBufferedImage(36, 32, BufferedImage.TYPE_INT_ARGB); clientThread.invokeLater(() -> { if (client.getGameState().ordinal() < GameState.LOGIN_SCREEN.ordinal()) { return false; } SpritePixels sprite = client.createItemSprite(itemId, quantity, 1, SpritePixels.DEFAULT_SHADOW_COLOR, stackable ? 1 : 0, false, CLIENT_DEFAULT_ZOOM); if (sprite == null) { return false; } sprite.toBufferedImage(img); img.changed(); return true; }); return img; }","old_code_raw":"\tprivate BufferedImage loadImage(int itemId, int quantity, boolean stackable)\n\t{\n\t\tSpritePixels sprite = client.createItemSprite(itemId, quantity, 1, SpritePixels.DEFAULT_SHADOW_COLOR,\n\t\t\tstackable ? 1 : 0, false, CLIENT_DEFAULT_ZOOM);\n\t\treturn sprite.toBufferedImage();\n\t}\n","new_comment_raw":"Loads item sprite from game, makes transparent, and generates image","old_comment_raw":"Loads item sprite from game, makes transparent, and generates image","label":0,"pre_label":1,"AST_level":10,"line_counts":22,"new_code_token_num":110},{"new_code_raw":"public Action timedout(AtmosphereRequest request, AtmosphereResponse response) throws IOException, ServletException { AtmosphereResourceImpl r = null; try { SessionTimeoutSupport.restoreTimeout(request); if (trackActiveRequest) { long l = (Long) request.getAttribute(MAX_INACTIVE); if (l == -1) { \/\/ The closedDetector closed the connection. return timedoutAction; } request.setAttribute(MAX_INACTIVE, (long) -1); } logger.debug(\"Timing out the connection for request {}\", request); \/\/ Something went wrong. if (request == null || response == null) { logger.warn(\"Invalid Request\/Response: {}\/{}\", request, response); return timedoutAction; } r = (AtmosphereResourceImpl) request.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE); if (r != null && r.getAtmosphereResourceEvent().isSuspended()) { r.getAtmosphereResourceEvent().setIsResumedOnTimeout(true); Broadcaster b = r.getBroadcaster(); if (b instanceof DefaultBroadcaster) { ((DefaultBroadcaster) b).broadcastOnResume(r); } if (request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT) != null) { r.getAtmosphereResourceEvent().setIsResumedOnTimeout( (Boolean) request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT)); } invokeAtmosphereHandler(r); } } catch (Throwable t) { logger.error(\"failed to timeout resource {}\", r, t); } finally { config.framework().notify(Action.TYPE.TIMEOUT, request, response); try { if (r != null) { r.notifyListeners(); r.setIsInScope(false); r.cancel(); } } catch (Throwable t) { logger.trace(\"timedout\", t); } finally { try { response.getOutputStream().close(); } catch (Throwable t) { try { response.getWriter().close(); } catch (Throwable t2) { } } if (r != null) { destroyResource(r); } } } return timedoutAction; }","old_code_raw":"    public Action timedout(AtmosphereRequest request, AtmosphereResponse response)\n            throws IOException, ServletException {\n\n        AtmosphereResourceImpl r = null;\n\n        try {\n            SessionTimeoutSupport.restoreTimeout(request);\n\n            if (trackActiveRequest) {\n                long l = (Long) request.getAttribute(MAX_INACTIVE);\n                if (l == -1) {\n                    \/\/ The closedDetector closed the connection.\n                    return timedoutAction;\n                }\n                request.setAttribute(MAX_INACTIVE, (long) -1);\n            }\n\n            logger.debug(\"Timing out the connection for request {}\", request);\n\n            \/\/ Something went wrong.\n            if (request == null || response == null) {\n                logger.warn(\"Invalid Request\/Response: {}\/{}\", request, response);\n                return timedoutAction;\n            }\n\n            r = (AtmosphereResourceImpl) request.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE);\n\n            if (r != null && r.isCancelled()) {\n                return cancelledAction;\n            }\n\n            if (r == null) {\n                logger.debug(\"AtmosphereResource was null, failed to timeout AtmosphereRequest {}\", request);\n            }\n\n            if (r != null && r.getAtmosphereResourceEvent().isSuspended()) {\n                r.getAtmosphereResourceEvent().setIsResumedOnTimeout(true);\n\n                Broadcaster b = r.getBroadcaster();\n                if (b instanceof DefaultBroadcaster) {\n                    ((DefaultBroadcaster) b).broadcastOnResume(r);\n                }\n\n                if (request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT) != null) {\n                    r.getAtmosphereResourceEvent().setIsResumedOnTimeout(\n                            (Boolean) request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT));\n                }\n\n                invokeAtmosphereHandler(r);\n            }\n        } catch (Throwable t) {\n            logger.error(\"failed to timeout resource {}\", r, t);\n        } finally {\n            config.framework().notify(Action.TYPE.TIMEOUT, request, response);\n            try {\n                if (r != null) {\n                    r.notifyListeners();\n                    r.setIsInScope(false);\n                    r.cancel();\n                }\n            } catch (Throwable t) {\n                logger.trace(\"timedout\", t);\n            } finally {\n                try {\n                    response.getOutputStream().close();\n                } catch (Throwable t) {\n                    try {\n                        response.getWriter().close();\n                    } catch (Throwable t2) {\n                    }\n                }\n\n                if (r != null) {\n                    r._destroy();\n                }\n            }\n        }\n\n        return timedoutAction;\n    }\n","new_comment_raw":"All proprietary Comet based  Servlet must invoke the timedout method when the underlying WebServer time out the  AtmosphereResponse.","old_comment_raw":"All proprietary Comet based Servlet must invoke the timedout method when the underlying WebServer time out the AtmosphereResponse.","label":0,"pre_label":1,"AST_level":13,"line_counts":74,"new_code_token_num":372},{"new_code_raw":"File getBaseDir(final File file1, final File file2) { if (file1 == null || file2 == null) { return null; } final Iterator bases = getParents(file1).iterator(); final Iterator fileParents = getParents(file2.getAbsoluteFile()).iterator(); File result = null; while (bases.hasNext() && fileParents.hasNext()) { File next = (File) bases.next(); if (next.equals(fileParents.next())) { result = next; } else { break; } } return result; }","old_code_raw":"    File getBaseDir(File base, File file) {\n        if (base == null) {\n            return file.getParentFile().getAbsoluteFile();\n        } else {\n            Iterator bases = getParents(base).iterator();\n            Iterator fileParents = getParents(file.getAbsoluteFile()).iterator();\n            File result = null;\n            while (bases.hasNext() && fileParents.hasNext()) {\n                File next = (File) bases.next();\n                if (next.equals(fileParents.next())) {\n                    result = next;\n                } else {\n                    break;\n                }\n            }\n            return result;\n        }\n    }\n","new_comment_raw":"Returns the common base directory between the passed file1 and file2.","old_comment_raw":"Returns the common base directory between a current base directory and a given file.","label":1,"pre_label":0,"AST_level":9,"line_counts":19,"new_code_token_num":105},{"new_code_raw":"public static StringExpression stringTemplate(String template, Object... args) { return new StringTemplate(createTemplate(template), ImmutableList.copyOf(args)); }","old_code_raw":"    public static StringExpression stringTemplate(String template, Object... args) {\n        return StringTemplate.create(template, args);\n    }\n","new_comment_raw":"Create a new Template expression","old_comment_raw":"Create a new Template expression","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":29},{"new_code_raw":"private String getConfigurationTable(Connection con) { try { if (StorageManager.getStorageImpl(con.getMetaData().getDatabaseProductName()).requiresConfigSchema()) { if (DatabaseConst.getConfigSchema().endsWith(\".\")) return DatabaseConst.getConfigSchema() + TBL_GLOBAL_CONFIG; else return DatabaseConst.getConfigSchema() + \".\" + TBL_GLOBAL_CONFIG; } } catch (SQLException e) { LOG.warn(e); } return TBL_GLOBAL_CONFIG; }","old_code_raw":"    private String getConfigurationTable(Connection con) {\n        try {\n            if (StorageManager.getStorageImpl(con.getMetaData().getDatabaseProductName()).escapeSchema())\n                return \"\\\"\" + DatabaseConst.getConfigSchema() + \"\\\".\" + TBL_GLOBAL_CONFIG;\n        } catch (SQLException e) {\n            LOG.warn(e);\n        }\n        return DatabaseConst.getConfigSchema() + \".\" + TBL_GLOBAL_CONFIG;\n    }\n","new_comment_raw":"Get the global configuration table name including the correct schema","old_comment_raw":"Get the global configuration table name including the correct escaped schema","label":1,"pre_label":0,"AST_level":10,"line_counts":15,"new_code_token_num":79},{"new_code_raw":"public List<Tree> getChildrenAsList() { return new ArrayList<>(Arrays.asList(children())); }","old_code_raw":"  public List<Tree> getChildrenAsList() {\n    return new ArrayList<Tree>(Arrays.asList(children()));\n  }\n","new_comment_raw":"Returns a List of children for the current node.","old_comment_raw":"Returns a List of children for the current node.","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":21},{"new_code_raw":"@Deprecated public long getNumBytesUploaded() { return totalBytesServerReceived; }","old_code_raw":"  public long getNumBytesUploaded() {\n    return bytesUploaded;\n  }\n","new_comment_raw":"Gets the total number of bytes the server received so far or  0 for direct uploads when the content length is not known.","old_comment_raw":"Gets the total number of bytes uploaded by this uploader or 0 for direct uploads when the content length is not known.","label":1,"pre_label":0,"AST_level":4,"line_counts":6,"new_code_token_num":12},{"new_code_raw":"static public IStructuredTextExpert getStatefulExpert(StructuredTextTypeHandler handler, StructuredTextEnvironment environment) { if (environment == null) environment = StructuredTextEnvironment.DEFAULT; return new StructuredTextImpl(handler, environment, true); }","old_code_raw":"\tstatic public ISTextExpert getStatefulExpert(STextTypeHandler handler, STextEnvironment environment) {\n\t\tif (environment == null)\n\t\t\tenvironment = STextEnvironment.DEFAULT;\n\t\treturn new STextImpl(handler, environment, true);\n\t}\n","new_comment_raw":"Obtains a IStructuredTextExpert instance for processing structured text with the specified type handler and the specified environment.","old_comment_raw":"Obtains a ISTextExpert instance for processing structured text with the specified type handler and the specified environment.","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":33},{"new_code_raw":"public String print(ReadablePartial partial) { StringBuilder builder = new StringBuilder(requirePrinter().estimatePrintedLength()); try { printTo(builder, partial); } catch (IOException e) { \/\/ StringBuilder does not throw IOException } return builder.toString(); }","old_code_raw":"    public String print(ReadablePartial partial) {\n        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\n        printTo(buf, partial);\n        return buf.toString();\n    }\n","new_comment_raw":"Prints a ReadablePartial to a new String.","old_comment_raw":"Prints a ReadablePartial to a new String.","label":0,"pre_label":1,"AST_level":7,"line_counts":10,"new_code_token_num":52},{"new_code_raw":"public PumpEnactResult applyAPSRequest(APSResult request) { request.rate = applyBasalConstraints(request.rate); PumpEnactResult result; if (!isInitialized()) { result = new PumpEnactResult(); result.comment = MainApp.sResources.getString(R.string.pumpNotInitialized); result.enacted = false; result.success = false; log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpNotInitialized)); return result; } if (isSuspended()) { result = new PumpEnactResult(); result.comment = MainApp.sResources.getString(R.string.pumpsuspended); result.enacted = false; result.success = false; log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpsuspended)); return result; } if (Config.logCongigBuilderActions) log.debug(\"applyAPSRequest: \" + request.toString()); if ((request.rate == 0 && request.duration == 0) || Math.abs(request.rate - getBaseBasalRate()) < getPumpDescription().basalStep) { if (isTempBasalInProgress()) { if (Config.logCongigBuilderActions) log.debug(\"applyAPSRequest: cancelTempBasal()\"); result = cancelTempBasal(false); } else { result = new PumpEnactResult(); result.absolute = request.rate; result.duration = 0; result.enacted = false; result.comment = \"Basal set correctly\"; result.success = true; if (Config.logCongigBuilderActions) log.debug(\"applyAPSRequest: Basal set correctly\"); } } else if (isTempBasalInProgress() && Math.abs(request.rate - getTempBasalAbsoluteRateHistory()) < getPumpDescription().basalStep) { result = new PumpEnactResult(); result.absolute = getTempBasalAbsoluteRateHistory(); result.duration = getTempBasalFromHistory(System.currentTimeMillis()).getPlannedRemainingMinutes(); result.enacted = false; result.comment = \"Temp basal set correctly\"; result.success = true; if (Config.logCongigBuilderActions) log.debug(\"applyAPSRequest: Temp basal set correctly\"); } else { if (Config.logCongigBuilderActions) log.debug(\"applyAPSRequest: setTempBasalAbsolute()\"); result = setTempBasalAbsolute(request.rate, request.duration); } return result; }","old_code_raw":"    public boolean applyAPSRequest(APSResult request, Callback callback) {\n        PumpInterface pump = getActivePump();\n        request.rate = applyBasalConstraints(request.rate);\n        PumpEnactResult result;\n\n        if (!pump.isInitialized()) {\n            log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpNotInitialized));\n            if (callback != null) {\n                callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpNotInitialized)).enacted(false).success(false)).run();\n            }\n            return false;\n        }\n\n        if (pump.isSuspended()) {\n            log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpsuspended));\n            if (callback != null) {\n                callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpsuspended)).enacted(false).success(false)).run();\n            }\n            return false;\n        }\n\n        if (Config.logCongigBuilderActions)\n            log.debug(\"applyAPSRequest: \" + request.toString());\n        if ((request.rate == 0 && request.duration == 0) || Math.abs(request.rate - pump.getBaseBasalRate()) < pump.getPumpDescription().basalStep) {\n            if (isTempBasalInProgress()) {\n                if (Config.logCongigBuilderActions)\n                    log.debug(\"applyAPSRequest: cancelTempBasal()\");\n                getCommandQueue().cancelTempBasal(false, callback);\n                return true;\n            } else {\n                if (Config.logCongigBuilderActions)\n                    log.debug(\"applyAPSRequest: Basal set correctly\");\n                if (callback != null) {\n                    callback.result(new PumpEnactResult().absolute(request.rate).duration(0).enacted(false).success(true).comment(\"Basal set correctly\")).run();\n                }\n                return false;\n            }\n        } else if (isTempBasalInProgress() && Math.abs(request.rate - getTempBasalAbsoluteRateHistory()) < pump.getPumpDescription().basalStep) {\n            if (Config.logCongigBuilderActions)\n                log.debug(\"applyAPSRequest: Temp basal set correctly\");\n            if (callback != null) {\n                callback.result(new PumpEnactResult().absolute(getTempBasalAbsoluteRateHistory()).duration(getTempBasalFromHistory(System.currentTimeMillis()).getPlannedRemainingMinutes()).enacted(false).success(true).comment(\"Temp basal set correctly\")).run();\n            }\n            return false;\n        } else {\n            if (Config.logCongigBuilderActions)\n                log.debug(\"applyAPSRequest: setTempBasalAbsolute()\");\n            getCommandQueue().tempBasalAbsolute(request.rate, request.duration, false, callback);\n            return true;\n        }\n    }\n","new_comment_raw":"expect absolute request and allow both absolute and percent response based on pump capabilities","old_comment_raw":"expect absolute request and allow both absolute and percent response based on pump capabilities","label":0,"pre_label":1,"AST_level":10,"line_counts":56,"new_code_token_num":379},{"new_code_raw":"public User executeAs(Function<Response, Response> handler) { Type type = new TypeToken<User>(){}.getType(); return execute(handler).as(type); }","old_code_raw":"        public User executeAs(Function<Response, Response> handler) {\n            Type type = new TypeToken<User>(){}.getType();\n            return getJSON().deserialize(execute(handler).asString(), type);\n        }\n","new_comment_raw":"GET \/user\/username","old_comment_raw":"GET \/user\/username","label":0,"pre_label":1,"AST_level":8,"line_counts":5,"new_code_token_num":35},{"new_code_raw":"public Iterator<String> iterator() { return new Iterator<String>() { protected BufferedReader reader = this.getReader(); protected String line = this.getLine(); public boolean hasNext() { return this.line != null; } public String next() { String nextLine = this.line; if (nextLine == null) { throw new NoSuchElementException(); } line = getLine(); return nextLine; } protected String getLine() { try { String result = this.reader.readLine(); if (result == null) { this.reader.close(); } return result; } catch (IOException e) { throw new RuntimeIOException(e); } } protected BufferedReader getReader() { try { InputStream stream = new FileInputStream(file); if (fileInputStreamWrapper != null) { stream = fileInputStreamWrapper.getConstructor( InputStream.class).newInstance(stream); } if (encoding == null) { return new BufferedReader(new InputStreamReader(stream)); } else { return new BufferedReader(new InputStreamReader(stream, encoding)); } } catch (Exception e) { throw new RuntimeIOException(e); } } public void remove() { throw new UnsupportedOperationException(); } }; }","old_code_raw":"      public Iterator<String> iterator() {\n        return new Iterator<String>() {\n\n          protected BufferedReader reader = this.getReader();\n          protected String line = this.getLine();\n\n          public boolean hasNext() {\n            return this.line != null;\n          }\n\n          public String next() {\n            String nextLine = this.line;\n            if (nextLine == null) {\n              throw new NoSuchElementException();\n            }\n            line = getLine();\n            return nextLine;\n          }\n\n          protected String getLine() {\n            try {\n              String result = this.reader.readLine();\n              if (result == null) {\n                this.reader.close();\n              }\n              return result;\n            } catch (IOException e) {\n              throw new RuntimeIOException(e);\n            }\n          }\n\n          protected BufferedReader getReader() {\n            try {\n              InputStream stream = new FileInputStream(file);\n              if (fileInputStreamWrapper != null) {\n                stream = fileInputStreamWrapper.getConstructor(\n                        InputStream.class).newInstance(stream);\n              }\n              return new BufferedReader(new InputStreamReader(stream));\n            } catch (Exception e) {\n              throw new RuntimeIOException(e);\n            }\n          }\n\n          public void remove() {\n            throw new UnsupportedOperationException();\n          }\n        };\n      }\n","new_comment_raw":"Returns an Iterable of the lines in the file, wrapping the generated","old_comment_raw":"Returns an Iterable of the lines in the file, wrapping the generated","label":0,"pre_label":1,"AST_level":13,"line_counts":54,"new_code_token_num":226},{"new_code_raw":"public Button getButton(String text, boolean onlyVisible) { return getter.getView(Button.class, text, onlyVisible); }","old_code_raw":"\tpublic Button getButton(String text, boolean onlyVisible)\n\t{\n\t\treturn viewFetcher.getView(Button.class, text, onlyVisible);\n\t}\n","new_comment_raw":"Returns a Button which shows a given text.","old_comment_raw":"Returns a Button which shows a given text.","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":24},{"new_code_raw":"@GET public Set<CassandraInstance> findAll() { return service.findAll(); }","old_code_raw":"  @GET\n  public List<CassandraInstance> findAll() {\n    return service.findAll();\n  }\n","new_comment_raw":"Return the set of Cassandra instances.","old_comment_raw":"Return the list of Cassandra instances ordered by position on ring, indicated by token.","label":1,"pre_label":0,"AST_level":5,"line_counts":6,"new_code_token_num":16},{"new_code_raw":"public static PathMetadata<String> forProperty(Path<?> parent, String property) { return new PathMetadata<String>(parent, Assert.hasLength(property,\"property\"), PathType.PROPERTY); }","old_code_raw":"    public static PathMetadata<String> forProperty(Path<?> parent, String property) {\n        return new PathMetadata<String>(parent, ConstantImpl.create(Assert.hasLength(property,\"property\"), true), PathType.PROPERTY);\n    }\n","new_comment_raw":"Create a new PathMetadata for property access","old_comment_raw":"Create a new PathMetadata for property access","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":36},{"new_code_raw":"public String getReplicationDirectory() { return this.replicationDirectory; }","old_code_raw":"    public String getReplicationDirectory() {\n        return replicationDirectory;\n    }\n","new_comment_raw":"Returns the path to the replication directory","old_comment_raw":"DOCUMENT ME!","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":11},{"new_code_raw":"public String getValue(String key) throws NotFoundException, NotLeaderException { if (cluster.getLocalRole() != Role.LEADER) { throw new NotLeaderException(); } if (!entries.containsKey(key)) { throw new NotFoundException(); } String value = entries.get(key); logger.info(String.format(\"Get key %s: %s\", key, value)); return value; }","old_code_raw":"    public String getValue(String entryId) throws RecordNotFoundException {\n        if (!entries.containsKey(entryId)) {\n            throw new RecordNotFoundException();\n        }\n        return entries.get(entryId);\n    }\n","new_comment_raw":"Returns the value stored at the specified key.","old_comment_raw":"Get entry data, read directly from internal data structure.","label":1,"pre_label":0,"AST_level":7,"line_counts":13,"new_code_token_num":81},{"new_code_raw":"public static Token seek(String path, Parser parser) { \/\/ return current token if no path is given if (!StringUtils.hasText(path)) { return null; } List<String> tokens = StringUtils.tokenize(path, \"\/\"); return seek(parser, tokens.toArray(new String[tokens.size()])); }","old_code_raw":"    public static Token seek(String path, Parser parser) {\n        \/\/ return current token if no path is given\n        if (!StringUtils.hasText(path)) {\n            return null;\n        }\n\n        List<String> tokens = StringUtils.tokenize(path, \"\/\");\n        ListIterator<String> li = tokens.listIterator();\n        return doSeekToken(li.next(), li, parser);\n    }\n","new_comment_raw":"Seeks the field with the given name in the stream and positions (and returns) the parser to the next available token (value or not).","old_comment_raw":"Seeks the field with the given name in the stream and positions (and returns) the parser to the next available token (value or not).","label":0,"pre_label":1,"AST_level":7,"line_counts":10,"new_code_token_num":69},{"new_code_raw":"static public Allocation createFromBitmap(RenderScript rs, Bitmap b, MipmapControl mips, int usage) { if (rs.isNative) { RenderScriptThunker rst = (RenderScriptThunker)rs; return AllocationThunker.createFromBitmap(rst, b, mips, usage); } rs.validate(); \/\/ WAR undocumented color formats if (b.getConfig() == null) { if ((usage & USAGE_SHARED) != 0) { throw new RSIllegalArgumentException(\"USAGE_SHARED cannot be used with a Bitmap that has a null config.\"); } Bitmap newBitmap = Bitmap.createBitmap(b.getWidth(), b.getHeight(), Bitmap.Config.ARGB_8888); Canvas c = new Canvas(newBitmap); c.drawBitmap(b, 0, 0, null); return createFromBitmap(rs, newBitmap, mips, usage); } Type t = typeFromBitmap(rs, b, mips); \/\/ enable optimized bitmap path only with no mipmap and script-only usage if (mips == MipmapControl.MIPMAP_NONE && t.getElement().isCompatible(Element.RGBA_8888(rs)) && usage == (USAGE_SHARED | USAGE_SCRIPT)) { int id = rs.nAllocationCreateBitmapBackedAllocation(t.getID(rs), mips.mID, b, usage); if (id == 0) { throw new RSRuntimeException(\"Load failed.\"); } \/\/ keep a reference to the Bitmap around to prevent GC Allocation alloc = new Allocation(id, rs, t, usage); alloc.setBitmap(b); return alloc; } int id = rs.nAllocationCreateFromBitmap(t.getID(rs), mips.mID, b, usage); if (id == 0) { throw new RSRuntimeException(\"Load failed.\"); } return new Allocation(id, rs, t, usage); }","old_code_raw":"    static public Allocation createFromBitmap(RenderScript rs, Bitmap b,\n                                              MipmapControl mips,\n                                              int usage) {\n        rs.validate();\n        Type t = typeFromBitmap(rs, b, mips);\n\n        int id = rs.nAllocationCreateFromBitmap(t.getID(rs), mips.mID, b, usage);\n        if (id == 0) {\n            throw new RSRuntimeException(\"Load failed.\");\n        }\n        return new Allocation(id, rs, t, usage);\n    }\n","new_comment_raw":"Creates an Allocation from a  android.graphics.Bitmap.","old_comment_raw":"Creates a renderscript allocation from a bitmap","label":1,"pre_label":0,"AST_level":9,"line_counts":46,"new_code_token_num":327},{"new_code_raw":"public static Treepath getNextSibling( Treepath treepath ) { if( treepath.getHeight() < 2 ) { throw new IllegalArgumentException( \"Treepath must have minimum height of 2\" ) ; } final Tree treeToMove = treepath.getBottom() ; final Tree parent = treepath.getTreeAtHeight( 1 ) ; for( int i = 0 ; i < parent.getChildCount() - 1 ; i++ ) { final Tree child = parent.getChildAt( i ) ; if( child == treeToMove ) { return Treepath.create( treepath.getParent(), parent.getChildAt( i + 1 ) ) ; } } throw new IllegalArgumentException( \"No next sibling\" ) ; }","old_code_raw":"  public static Treepath getNextSibling( Treepath treepath ) {\n    throw new UnsupportedOperationException( \"getNextSibling\" ) ;\n  }\n","new_comment_raw":"Returns the sibling on the left of the bottom of given  Treepath.","old_comment_raw":"Returns the sibling on the right of the end of given Treepath.","label":1,"pre_label":0,"AST_level":11,"line_counts":16,"new_code_token_num":117},{"new_code_raw":"public String toString() { return ISODateTimeFormat.getInstance().dateTime().print(this); }","old_code_raw":"    public String toString() {\n        return ISODateTimeFormat.getInstance(getChronology()).dateTime().print(this);\n    }\n","new_comment_raw":"Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSSZ).","old_comment_raw":"Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSSZ).","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"public byte[] evaluateChallenge(byte[] challenge) throws MessagingException { try { String result = \"\\0\"+username+\"\\0\"+password; if(authzid != null && authzid.length() > 0) { result = authzid+result; } complete = true; return result.getBytes(\"UTF-8\"); } catch (UnsupportedEncodingException e) { \/\/ got an error, fail this throw new MessagingException(\"Invalid encoding\"); } }","old_code_raw":"    public byte[] evaluateChallenge(byte[] challenge) throws MessagingException {\n        try {\n            \/\/ get the username and password in an UTF-8 encoding to create the\n            \/\/ token\n            byte[] userBytes = username.getBytes(\"UTF-8\");\n            byte[] passBytes = password.getBytes(\"UTF-8\");\n\n            \/\/ our token has two copies of the username, one copy of the\n            \/\/ password, and nulls\n            \/\/ between\n            byte[] tokenBytes = new byte[(userBytes.length * 2) + passBytes.length + 2];\n\n            System.arraycopy(userBytes, 0, tokenBytes, 0, userBytes.length);\n            System.arraycopy(userBytes, 0, tokenBytes, userBytes.length + 1, userBytes.length);\n            System.arraycopy(passBytes, 0, tokenBytes, (userBytes.length * 2) + 2, passBytes.length);\n\n            complete = true;\n            return tokenBytes;\n\n        } catch (UnsupportedEncodingException e) {\n            \/\/ got an error, fail this\n            throw new MessagingException(\"Invalid encoding\");\n        }\n    }\n","new_comment_raw":"Evaluate a PLAIN login challenge, returning the a result string that should satisfy the challenge.","old_comment_raw":"Evaluate a PLAIN login challenge, returning the a result string that should satisfy the clallenge.","label":1,"pre_label":0,"AST_level":9,"line_counts":19,"new_code_token_num":93},{"new_code_raw":"public static int[] getViewToHeaderPosition(JTextArea view, int start, int end) { validateView(view); validateStartEnd(start, end); if (!isValidStartEndForLength(start, end, view.getDocument().getLength())) { return INVALID_POSITION; } return getViewToHeaderPositionImpl(view, start, end); }","old_code_raw":"    public static int[] getViewToHeaderPosition(JTextArea view, int start, int end) {\n        validateView(view);\n        validateStartEnd(start, end, view.getDocument().getLength());\n        return getViewToHeaderPositionImpl(view, start, end);\n    }\n","new_comment_raw":"Gets the given  start and  end view positions offset to a header.","old_comment_raw":"Gets the given start and end view positions offset to a header.","label":0,"pre_label":1,"AST_level":6,"line_counts":11,"new_code_token_num":63},{"new_code_raw":"public static String getPluginQuality(PluginPassiveScanner scanner) { \/\/ String scannerPackage = scanner.getClass().getCanonicalName(); String scannerName = scanner.getName(); return (getSpecificQuality(scannerName, scanner)); }","old_code_raw":"\tpublic static String getPluginQuality(PluginPassiveScanner scanner) {\n        String scannerPackage = scanner.getClass().getCanonicalName();\n        String scannerName = scanner.getName();\n        \n        return (getSpecificQuality(scannerName, scannerPackage));\n        \n        }\n","new_comment_raw":"Gets the quality or status of the given passive  scanner.","old_comment_raw":"Gets the quality or status of the given passive scanner.","label":0,"pre_label":1,"AST_level":5,"line_counts":8,"new_code_token_num":39},{"new_code_raw":"public static ENumber<Integer> lastIndexOf(Expr<String> left, String right) { return factory.createNumber(Integer.class,Ops.LAST_INDEX, left, factory.createConstant(right)); }","old_code_raw":"    public static ENumber<Integer> lastIndexOf(Expr<String> left, String right) {\n        return createNumber(Integer.class,Ops.LAST_INDEX, left, createConstant(right));\n    }\n","new_comment_raw":"Expr : left.lastIndexOf(right)","old_comment_raw":"Expr : left.lastIndexOf(right)","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":34},{"new_code_raw":"public ArrayList getImageSrcs() { return this.img_src; }","old_code_raw":"    public ArrayList getImageSrcs() {\n        return img_src;\n    }\n","new_comment_raw":"Get the list of src attributes for images","old_comment_raw":"DOCUMENT ME!","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":11},{"new_code_raw":"public RepoContentSource removeContentSource(ContentSource contentSource) { if ((this.repoContentSources == null) || (contentSource == null)) { return null; } RepoContentSource doomed = null; for (RepoContentSource ccs : this.repoContentSources) { if (contentSource.equals(ccs.getRepoContentSourcePK().getContentSource())) { doomed = ccs; break; } } if (doomed != null) { this.repoContentSources.remove(doomed); } return doomed; }","old_code_raw":"    public ChannelContentSource removeContentSource(ContentSource contentSource) {\n        if ((this.channelContentSources == null) || (contentSource == null)) {\n            return null;\n        }\n\n        ChannelContentSource doomed = null;\n\n        for (ChannelContentSource ccs : this.channelContentSources) {\n            if (contentSource.equals(ccs.getChannelContentSourcePK().getContentSource())) {\n                doomed = ccs;\n                break;\n            }\n        }\n\n        if (doomed != null) {\n            this.channelContentSources.remove(doomed);\n        }\n\n        return doomed;\n    }\n","new_comment_raw":"Removes the content source from this repo, if it exists.","old_comment_raw":"Removes the content source from this channel, if it exists.","label":1,"pre_label":0,"AST_level":9,"line_counts":22,"new_code_token_num":81},{"new_code_raw":"boolean hasClient() { return listeningThread != null && listeningThread.hasClient && !listeningThread.sockets.isEmpty(); }","old_code_raw":"  boolean hasClient() {\n    return listeningThread != null && listeningThread.hasClient;\n  }\n","new_comment_raw":"Returns whether an instance of Chrome is currently connected","old_comment_raw":"Returns whether an instance of Chrome is currently connected","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":23},{"new_code_raw":"public EAttribute getChange_State() { return (EAttribute) changeEClass.getEStructuralFeatures().get(5); }","old_code_raw":"\tpublic EReference getChange_State() {\n\t\treturn (EReference) changeEClass.getEStructuralFeatures().get(5);\n\t}\n","new_comment_raw":"Returns the meta object for the attribute ' org.eclipse.mylyn.reviews.core.model.IChange#getState State'.","old_comment_raw":"Returns the meta object for the containment reference ' org.eclipse.mylyn.reviews.core.model.IChange#getState State'.","label":1,"pre_label":0,"AST_level":7,"line_counts":5,"new_code_token_num":20},{"new_code_raw":"static Folder fromXml(Launcher launcher) { return (Folder) launcher.getLayoutInflater() .inflate(R.layout.user_folder_icon_normalized, null); }","old_code_raw":"    static Folder fromXml(Launcher launcher) {\n        return (Folder) launcher.getLayoutInflater().inflate(\n                FeatureFlags.LAUNCHER3_DISABLE_ICON_NORMALIZATION\n                        ? R.layout.user_folder : R.layout.user_folder_icon_normalized, null);\n    }\n","new_comment_raw":"Creates a new UserFolder, inflated from R.layout.user_folder.","old_comment_raw":"Creates a new UserFolder, inflated from R.layout.user_folder.","label":0,"pre_label":1,"AST_level":7,"line_counts":5,"new_code_token_num":26},{"new_code_raw":"public Collection<TableGrant> getTableGrants(TableIdentifier table) { Collection<TableGrant> result = new HashSet<TableGrant>(); ResultSet rs = null; try { TableIdentifier tbl = table.createCopy(); tbl.adjustCase(this.dbConnection); rs = this.metaData.getTablePrivileges(tbl.getCatalog(), tbl.getSchema(), tbl.getTableName()); while (rs.next()) { String from = rs.getString(4); String to = rs.getString(5); String what = rs.getString(6); boolean grantable = StringUtil.stringToBool(rs.getString(7)); TableGrant grant = new TableGrant(to, what, grantable); result.add(grant); } } catch (Exception e) { LogMgr.logError(\"DbMetadata.getTableGrants()\", \"Error when retrieving table privileges\",e); } finally { try { rs.close(); } catch (Throwable th) {} } return result; }","old_code_raw":"\tpublic DataStore getTableGrants(TableIdentifier table)\n\t{\n\t\tString[] columns = new String[] { \"TABLENAME\", \"GRANTOR\", \"GRANTEE\", \"PRIVILEGE\", \"GRANTABLE\" };\n\t\tint[] colTypes = new int[] { Types.VARCHAR, Types.VARCHAR, Types.VARCHAR, Types.VARCHAR, Types.VARCHAR };\n\t\tDataStore result = new DataStore(columns, colTypes);\n\t\tResultSet rs = null;\n\t\ttry\n\t\t{\n\t\t\tTableIdentifier tbl = table.createCopy();\n\t\t\ttbl.adjustCase(this.dbConnection);\n\t\t\trs = this.metaData.getTablePrivileges(tbl.getCatalog(), tbl.getSchema(), tbl.getTableName());\n\t\t\twhile (rs.next())\n\t\t\t{\n\t\t\t\tint row = result.addRow();\n\t\t\t\tresult.setValue(row, COLUMN_IDX_TABLE_GRANTS_OBJECT_NAME, rs.getString(3));\n\t\t\t\tresult.setValue(row, COLUMN_IDX_TABLE_GRANTS_GRANTOR, rs.getString(4));\n\t\t\t\tresult.setValue(row, COLUMN_IDX_TABLE_GRANTS_GRANTEE, rs.getString(5));\n\t\t\t\tresult.setValue(row, COLUMN_IDX_TABLE_GRANTS_PRIV, rs.getString(6));\n\t\t\t\tresult.setValue(row, COLUMN_IDX_TABLE_GRANTS_GRANTABLE, rs.getString(7));\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tLogMgr.logError(\"DbMetadata.getTableGrants()\", \"Error when retrieving table privileges\",e);\n\t\t\tresult.reset();\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\ttry { rs.close(); } catch (Throwable th) {}\n\t\t}\n\t\treturn result;\n\t}\n","new_comment_raw":"Return the GRANTs for the given table","old_comment_raw":"Return a String to recreate the GRANTs given for the passed table.","label":1,"pre_label":0,"AST_level":10,"line_counts":31,"new_code_token_num":173},{"new_code_raw":"protected int intersectsValidDropTarget(int id) { LauncherAccessibilityDelegate delegate = LauncherAppState.getInstance().getAccessibilityDelegate(); if (delegate == null) { return -1; } int y = id % mCountY; int x = id \/ mCountY; LauncherAccessibilityDelegate.DragInfo dragInfo = delegate.getDragInfo(); if (dragInfo.dragType == DragType.WIDGET) { \/\/ For a widget, every cell must be vacant. In addition, we will return any valid \/\/ drop target by which the passed id is contained. boolean fits = false; \/\/ These represent the amount that we can back off if we hit a problem. They \/\/ get consumed as we move up and to the right, trying new regions. int spanX = dragInfo.info.spanX; int spanY = dragInfo.info.spanY; for (int m = 0; m < spanX; m++) { for (int n = 0; n < spanY; n++) { fits = true; int x0 = x - m; int y0 = y - n; if (x0 < 0 || y0 < 0) continue; for (int i = x0; i < x0 + spanX; i++) { if (!fits) break; for (int j = y0; j < y0 + spanY; j++) { if (i >= mCountX || j >= mCountY || mOccupied[i][j]) { fits = false; break; } } } if (fits) { return x0 * mCountY + y0; } } } return -1; } else { \/\/ For an icon, we simply check the view directly below View child = getChildAt(x, y); if (child == null || child == dragInfo.item) { \/\/ Empty cell. Good for an icon or folder. return id; } else if (dragInfo.dragType != DragType.FOLDER) { \/\/ For icons, we can consider cells that have another icon or a folder. ItemInfo info = (ItemInfo) child.getTag(); if (info instanceof AppInfo || info instanceof FolderInfo || info instanceof ShortcutInfo) { return id; } } return -1; } }","old_code_raw":"        protected int intersectsValidDropTarget(int id) {\n            LauncherAccessibilityDelegate delegate =\n                    LauncherAppState.getInstance().getAccessibilityDelegate();\n            LauncherAccessibilityDelegate.DragInfo dragInfo = delegate.getDragInfo();\n\n            int y = id % mCountY;\n            int x = id \/ mCountY;\n\n            if (dragInfo.dragType == DragType.WIDGET) {\n                \/\/ For a widget, every cell must be vacant. In addition, we will return any valid\n                \/\/ drop target by which the passed id is contained.\n                boolean fits = false;\n\n                \/\/ These represent the amount that we can back off if we hit a problem. They\n                \/\/ get consumed as we move up and to the right, trying new regions.\n                int spanX = dragInfo.info.spanX;\n                int spanY = dragInfo.info.spanY;\n\n                for (int m = 0; m < spanX; m++) {\n                    for (int n = 0; n < spanY; n++) {\n\n                        fits = true;\n                        int x0 = x - m;\n                        int y0 = y - n;\n\n                        if (x0 < 0 || y0 < 0) continue;\n\n                        for (int i = x0; i < x0 + spanX; i++) {\n                            if (!fits) break;\n                            for (int j = y0; j < y0 + spanY; j++) {\n                                if (i >= mCountX || j >= mCountY || mOccupied[i][j]) {\n                                    fits = false;\n                                    break;\n                                }\n                            }\n                        }\n                        if (fits) {\n                            return x0 * mCountY + y0;\n                        }\n                    }\n                }\n                return -1;\n            } else {\n                \/\/ For an icon, we simply check the view directly below\n                View child = getChildAt(x, y);\n                if (child == null || child == dragInfo.item) {\n                    \/\/ Empty cell. Good for an icon or folder.\n                    return id;\n                } else if (dragInfo.dragType != DragType.FOLDER) {\n                    \/\/ For icons, we can consider cells that have another icon or a folder.\n                    ItemInfo info = (ItemInfo) child.getTag();\n                    if (info instanceof AppInfo || info instanceof FolderInfo ||\n                            info instanceof ShortcutInfo) {\n                        return id;\n                    }\n                }\n                return -1;\n            }\n        }\n","new_comment_raw":"Find the virtual view id corresponding to the top left corner of any drop region by which the passed id is contained.","old_comment_raw":"Find the virtual view id corresponding to the top left corner of any drop region by which the passed id is contained.","label":0,"pre_label":1,"AST_level":17,"line_counts":63,"new_code_token_num":389},{"new_code_raw":"public Vertex rotate(int orientation) { \/\/ models are orientated north (1024) and there are 2048 angles total orientation = (orientation + 1024) % 2048; if (orientation == 0) { return this; } int sin = Perspective.SINE[orientation]; int cos = Perspective.COSINE[orientation]; return new Vertex( x * cos + z * sin >> 16, y, z * cos - x * sin >> 16 ); }","old_code_raw":"\tpublic Vertex rotate(int orientation)\n\t{\n\t\tint sin = Perspective.SINE[orientation];\n\t\tint cos = Perspective.COSINE[orientation];\n\n\t\treturn new Vertex(\n\t\t\tx * cos + z * sin >> 16,\n\t\t\ty,\n\t\t\tz * cos - x * sin >> 16\n\t\t);\n\t}\n","new_comment_raw":"Rotate the vertex by the given orientation","old_comment_raw":"Rotate the vertex by the given orientation","label":0,"pre_label":1,"AST_level":8,"line_counts":20,"new_code_token_num":84},{"new_code_raw":"public RollCycle getRollCycle() { return queue.rollCycle(); }","old_code_raw":"\tpublic RollCycle getRollCycle() {\n\t\treturn rollCycle;\n\t}\n","new_comment_raw":"Returns the queue file roll cycle","old_comment_raw":"Returns","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":13},{"new_code_raw":"protected DimensionValueLoadTask buildDruidDimensionsLoader( DruidWebService webService, PhysicalTableDictionary physicalTableDictionary, DimensionDictionary dimensionDictionary ) { DruidDimensionValueLoader druidDimensionRowProvider = new DruidDimensionValueLoader( physicalTableDictionary, dimensionDictionary, webService ); return new DimensionValueLoadTask(Collections.singletonList(druidDimensionRowProvider)); }","old_code_raw":"    protected DruidDimensionsLoader buildDruidDimensionsLoader(\n            DruidWebService webService,\n            PhysicalTableDictionary physicalTableDictionary,\n            DimensionDictionary dimensionDictionary\n    ) {\n        return new DruidDimensionsLoader(\n                physicalTableDictionary,\n                dimensionDictionary,\n                webService\n        );\n    }\n","new_comment_raw":"Build a DimensionValueLoadTask.","old_comment_raw":"Build a DruidDimensionsLoader.","label":1,"pre_label":0,"AST_level":6,"line_counts":14,"new_code_token_num":38},{"new_code_raw":"public static int getAccentColorFromThemeIfAvailable(Context context) { TypedValue typedValue = new TypedValue(); \/\/ First, try the android:colorAccent if (Build.VERSION.SDK_INT >= 21) { context.getTheme().resolveAttribute(android.R.attr.colorAccent, typedValue, true); return typedValue.data; } \/\/ Next, try colorAccent from support lib int colorAccentResId = context.getResources().getIdentifier(\"colorAccent\", \"attr\", context.getPackageName()); if (colorAccentResId != 0 && context.getTheme().resolveAttribute(colorAccentResId, typedValue, true)) { return typedValue.data; } \/\/ Return the value in mdtp_accent_color return ContextCompat.getColor(context, R.color.mdtp_accent_color); }","old_code_raw":"    public static int getAccentColorFromThemeIfAvailable(Context context) {\n        TypedValue typedValue = new TypedValue();\n        \/\/ First, try the android:colorAccent\n        if (Build.VERSION.SDK_INT >= 21) {\n            context.getTheme().resolveAttribute(android.R.attr.colorAccent, typedValue, true);\n            return typedValue.data;\n        }\n        \/\/ Next, try colorAccent from support lib\n        int colorAccentResId = context.getResources().getIdentifier(\"colorAccent\", \"attr\", context.getPackageName());\n        if (colorAccentResId != 0 && context.getTheme().resolveAttribute(colorAccentResId, typedValue, true)) {\n            return typedValue.data;\n        }\n        \/\/ Return the value in mdtp_accent_color\n        return Utils.getColor(context, R.color.mdtp_accent_color);\n    }\n","new_comment_raw":"Gets the colorAccent from the current context, if possible\/available","old_comment_raw":"Gets the colorAccent from the current context, if possible\/available","label":0,"pre_label":1,"AST_level":8,"line_counts":16,"new_code_token_num":130},{"new_code_raw":"public String getTreeAuthoringPath() { return this.treeAuthoringPath; }","old_code_raw":"    public String getTreeAuthoringPath() {\n        return treeAuthoringPath;\n    }\n","new_comment_raw":"Returns the path to the authoring tree","old_comment_raw":"DOCUMENT ME!","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":11},{"new_code_raw":"@Override protected Bitmap alloc(int size) { return Bitmap.createBitmap( 1, (int) Math.ceil(size \/ (double) BitmapUtil.RGB_565_BYTES_PER_PIXEL), Bitmap.Config.RGB_565); }","old_code_raw":"  @Override\n  protected Bitmap alloc(int size) {\n    return Bitmap.createBitmap(1, size, Bitmaps.BITMAP_CONFIG);\n  }\n","new_comment_raw":"Allocate a bitmap that has a backing memory allocacation of 'size' bytes.","old_comment_raw":"Allocate a bitmap with the specified width and height.","label":1,"pre_label":0,"AST_level":9,"line_counts":9,"new_code_token_num":37},{"new_code_raw":"public Mono<Client> testClientModel(Client body) throws RestClientException { Object postBody = body; \/\/ verify the required parameter 'body' is set if (body == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'body' when calling testClientModel\"); } String path = UriComponentsBuilder.fromPath(\"\/fake\").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { \"application\/json\" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { \"application\/json\" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {}; return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType); }","old_code_raw":"    public Mono<Client> testClientModel(Client body) throws RestClientException {\n        Object postBody = body;\n        \n        \/\/ verify the required parameter 'body' is set\n        if (body == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'body' when calling testClientModel\");\n        }\n        \n        String path = UriComponentsBuilder.fromPath(\"\/fake\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application\/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"application\/json\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {};\n        return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n","new_comment_raw":"To test \\&quot;client\\&quot; model","old_comment_raw":"To test \\&quot;client\\&quot; model","label":0,"pre_label":1,"AST_level":8,"line_counts":30,"new_code_token_num":217},{"new_code_raw":"public static final Element elementFromUse(ExpressionTree node) { return InternalUtils.symbol(node); }","old_code_raw":"    public static final ExecutableElement elementFromUse(MethodInvocationTree node) {\n        return (ExecutableElement)TreeInfo.symbol((JCTree)node.getMethodSelect());\n    }\n","new_comment_raw":"Gets the element for the declaration corresponding to this use of an element.","old_comment_raw":"Gets the element for the method corresponding to this invocation.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":18},{"new_code_raw":"public Struct offsetStructForEvent(String replicaSetName, Document oplogEvent) { Position position = INITIAL_POSITION; String namespace = \"\"; if (oplogEvent != null) { BsonTimestamp ts = extractEventTimestamp(oplogEvent); Long opId = oplogEvent.getLong(\"h\"); position = new Position(ts, opId); namespace = oplogEvent.getString(\"ns\"); } positionsByReplicaSetName.put(replicaSetName, position); return offsetStructFor(replicaSetName, CollectionId.parse(replicaSetName + \".\" + namespace), position, isInitialSyncOngoing(replicaSetName)); }","old_code_raw":"    public Struct offsetStructForEvent(String replicaSetName, Document oplogEvent) {\n        Position position = INITIAL_POSITION;\n        String namespace = \"\";\n        if (oplogEvent != null) {\n            BsonTimestamp ts = extractEventTimestamp(oplogEvent);\n            Long opId = oplogEvent.getLong(\"h\");\n            position = new Position(ts, opId);\n            namespace = oplogEvent.getString(\"ns\");\n        }\n        positionsByReplicaSetName.put(replicaSetName, position);\n        return offsetStructFor(replicaSetName, namespace, position, isInitialSyncOngoing(replicaSetName));\n    }\n","new_comment_raw":"Get a  Struct representation of the source  #partition(String) partition and  #lastOffset(String) offset information.","old_comment_raw":"Get a Struct representation of the source #partition(String) partition and #lastOffset(String) offset information.","label":0,"pre_label":1,"AST_level":8,"line_counts":13,"new_code_token_num":96},{"new_code_raw":"public static Iterable<ProviderMetadata> collocatedWith(ProviderMetadata providerMetadata, TypeToken<? extends Wrapper> contextWrappableAs) { return filter(all(), Predicates.and(ProviderPredicates.intersectingIso3166Code(providerMetadata), ProviderPredicates.contextWrappableAs(contextWrappableAs))); }","old_code_raw":"   public static Iterable<ProviderMetadata<?, ?, ?, ?>> collocatedWith(ProviderMetadata<?, ?, ?, ?> providerMetadata,\n         ApiType type) {\n      return filter(all(),\n            Predicates.and(ProviderPredicates.intersectingIso3166Code(providerMetadata), ProviderPredicates.type(type)));\n   }\n","new_comment_raw":"Returns the providers that have at least one common ISO 3166 code and are of the given contextWrappableAs.","old_comment_raw":"Returns the providers that have at least one common ISO 3166 code and are of the given type.","label":1,"pre_label":0,"AST_level":7,"line_counts":7,"new_code_token_num":41},{"new_code_raw":"public Mono<Pet> getPetById(Long petId) throws RestClientException { Object postBody = null; \/\/ verify the required parameter 'petId' is set if (petId == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'petId' when calling getPetById\"); } \/\/ create path and map variables final Map<String, Object> uriVariables = new HashMap<String, Object>(); uriVariables.put(\"petId\", petId); String path = UriComponentsBuilder.fromPath(\"\/pet\/{petId}\").buildAndExpand(uriVariables).toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { \"application\/xml\", \"application\/json\" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { \"api_key\" }; ParameterizedTypeReference<Pet> returnType = new ParameterizedTypeReference<Pet>() {}; return apiClient.invokeAPI(path, HttpMethod.GET, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType); }","old_code_raw":"    public Mono<Pet> getPetById(Long petId) throws RestClientException {\n        Object postBody = null;\n        \n        \/\/ verify the required parameter 'petId' is set\n        if (petId == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'petId' when calling getPetById\");\n        }\n        \n        \/\/ create path and map variables\n        final Map<String, Object> uriVariables = new HashMap<String, Object>();\n        uriVariables.put(\"petId\", petId);\n        String path = UriComponentsBuilder.fromPath(\"\/pet\/{petId}\").buildAndExpand(uriVariables).toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application\/xml\", \"application\/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] { \"api_key\" };\n\n        ParameterizedTypeReference<Pet> returnType = new ParameterizedTypeReference<Pet>() {};\n        return apiClient.invokeAPI(path, HttpMethod.GET, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n","new_comment_raw":"Find pet by ID","old_comment_raw":"Find pet by ID","label":0,"pre_label":1,"AST_level":8,"line_counts":31,"new_code_token_num":257},{"new_code_raw":"static String boxClassName(Type type) { if (!(type instanceof Class)) { return type.toString(); } Primitive primitive = Primitive.of(type); if (primitive != null) { return primitive.boxClass.getSimpleName(); } else { return className(type); } }","old_code_raw":"    static String boxClassName(Type type) {\n        if (!(type instanceof Class)) {\n            return type.toString();\n        }\n        Class clazz = (Class) type;\n        if (clazz.isPrimitive()) {\n            return PRIMITIVES.get(clazz).getSimpleName();\n        } else {\n            return className(clazz);\n        }\n    }\n","new_comment_raw":"Boxes a type, if it is primitive, and returns the type name.","old_comment_raw":"Boxes a type, if it is primitive, and returns the type name.","label":0,"pre_label":1,"AST_level":7,"line_counts":12,"new_code_token_num":58},{"new_code_raw":"public BooleanExpression eq(Expression<? super T> right) { return BooleanOperation.create(Ops.EQ, this, right); }","old_code_raw":"    public BooleanExpression eq(Expression<? super T> right) {\n        if (primitive) {\n            return BooleanOperation.create(Ops.EQ_PRIMITIVE, this, right);\n        } else {\n            return BooleanOperation.create(Ops.EQ_OBJECT, this, right);\n        }\n    }\n","new_comment_raw":"Get a this == right expression","old_comment_raw":"Get a this == right expression","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":24},{"new_code_raw":"public static Collection<Simon> getSimons(SimonFilter simonFilter) { return manager.getSimons(simonFilter); }","old_code_raw":"\tpublic static Collection<Simon> getSimons(SimonPattern pattern) {\n\t\treturn manager.getSimons(pattern);\n\t}\n","new_comment_raw":"Returns collection containing all existing Simons accepted by specified  SimonFilter.","old_comment_raw":"Returns collection containing all existing Simons matching the pattern (can be null).","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":18},{"new_code_raw":"public static boolean isTree(SemanticGraph tree) { for (IndexedWord vertex : tree.vertexSet()) { \/\/ Check one and only one incoming edge if (tree.getRoots().contains(vertex)) { if (tree.incomingEdgeIterator(vertex).hasNext()) { return false; } } else { Iterator<SemanticGraphEdge> iter = tree.incomingEdgeIterator(vertex); if (!iter.hasNext()) { return false; } iter.next(); if (iter.hasNext()) { return false; } } \/\/ Check incoming and outgoing edges match for (SemanticGraphEdge edge : tree.outgoingEdgeIterable(vertex)) { boolean foundReverse = false; for (SemanticGraphEdge reverse : tree.incomingEdgeIterable(edge.getDependent())) { if (reverse == edge) { foundReverse = true; } } if (!foundReverse) { return false; } } for (SemanticGraphEdge edge : tree.incomingEdgeIterable(vertex)) { boolean foundReverse = false; for (SemanticGraphEdge reverse : tree.outgoingEdgeIterable(edge.getGovernor())) { if (reverse == edge) { foundReverse = true; } } if (!foundReverse) { return false; } } } \/\/ Check topological sort -- sometimes fails? \/\/ try { \/\/ tree.topologicalSort(); \/\/ } catch (Exception e) { \/\/ e.printStackTrace(); \/\/ return false; \/\/ } return true; }","old_code_raw":"  public static boolean isTree(SemanticGraph tree) {\n    for (IndexedWord vertex : tree.vertexSet()) {\n      if (tree.getRoots().contains(vertex)) {\n        if (tree.incomingEdgeIterator(vertex).hasNext()) {\n          return false;\n        }\n      } else {\n        Iterator<SemanticGraphEdge> iter = tree.incomingEdgeIterator(vertex);\n        if (!iter.hasNext()) {\n          return false;\n        }\n        iter.next();\n        if (iter.hasNext()) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n","new_comment_raw":"A little utility function to make sure a SemanticGraph is a tree.","old_comment_raw":"A little utility function to make sure a SemanticGraph is a tree.","label":0,"pre_label":1,"AST_level":13,"line_counts":47,"new_code_token_num":264},{"new_code_raw":"public Action doCometSupport(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException { req.setAttribute(BROADCASTER_FACTORY, broadcasterFactory); req.setAttribute(PROPERTY_USE_STREAM, useStreamForFlushingComments); req.setAttribute(BROADCASTER_CLASS, broadcasterClassName); req.setAttribute(ATMOSPHERE_CONFIG, config); Action a = null; try { if ((config.getInitParameter(ALLOW_QUERYSTRING_AS_REQUEST) != null || (isIECandidate(req) || req.getParameter(HeaderConfig.JSONP_CALLBACK_NAME) != null)) && req.getAttribute(WebSocket.WEBSOCKET_SUSPEND) == null) { Map<String, String> headers = configureQueryStringAsRequest(req); String body = headers.remove(ATMOSPHERE_POST_BODY); if (body != null && body.isEmpty()) { body = null; } req.headers(headers) .method(body != null && req.getMethod().equalsIgnoreCase(\"GET\") ? \"POST\" : req.getMethod()); if (body != null) { req.body(body); } a = asyncSupport.service(req, res); } else { return asyncSupport.service(req, res); } } catch (IllegalStateException ex) { if (ex.getMessage() != null && (ex.getMessage().startsWith(\"Tomcat failed\") || ex.getMessage().startsWith(\"JBoss failed\") )) { if (!isFilter) { logger.warn(\"Failed using comet support: {}, error: {} Is the Nio or Apr Connector enabled?\", asyncSupport.getClass().getName(), ex.getMessage()); logger.warn(\"Using BlockingIOCometSupport.\"); } logger.trace(ex.getMessage(), ex); asyncSupport = new BlockingIOCometSupport(config); doCometSupport(req, res); } else { logger.error(\"AtmosphereServlet exception\", ex); throw ex; } } finally { if (req != null && a != null && a.type != Action.TYPE.SUSPEND) { req.destroy(); res.destroy(); } } return null; }","old_code_raw":"    public Action doCometSupport(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException {\n        req.setAttribute(BROADCASTER_FACTORY, broadcasterFactory);\n        req.setAttribute(PROPERTY_USE_STREAM, useStreamForFlushingComments);\n        req.setAttribute(BROADCASTER_CLASS, broadcasterClassName);\n        req.setAttribute(ATMOSPHERE_CONFIG, config);\n\n        Action a = null;\n        try {\n            if ((config.getInitParameter(ALLOW_QUERYSTRING_AS_REQUEST) != null\n                    || (isIECandidate(req) || req.getParameter(HeaderConfig.JSONP_CALLBACK_NAME) != null))\n                    && req.getAttribute(WebSocket.WEBSOCKET_SUSPEND) == null) {\n\n                Map<String, String> headers = configureQueryStringAsRequest(req);\n                String body = headers.remove(ATMOSPHERE_POST_BODY);\n                if (body != null && body.isEmpty()) {\n                    body = null;\n                }\n\n                req.headers(headers)\n                   .method(body != null && req.getMethod().equalsIgnoreCase(\"GET\") ? \"POST\" : req.getMethod());\n\n                if (body != null) {\n                   req.body(body);\n                }\n\n                a = cometSupport.service(req, res);\n            } else {\n                return cometSupport.service(req, res);\n            }\n        } catch (IllegalStateException ex) {\n            if (ex.getMessage() != null && (ex.getMessage().startsWith(\"Tomcat failed\") || ex.getMessage().startsWith(\"JBoss failed\") )) {\n                if (!isFilter) {\n                    logger.warn(\"Failed using comet support: {}, error: {} Is the Nio or Apr Connector enabled?\", cometSupport.getClass().getName(),\n                            ex.getMessage());\n                    logger.warn(\"Using BlockingIOCometSupport.\");\n                }\n                logger.trace(ex.getMessage(), ex);\n\n                cometSupport = new BlockingIOCometSupport(config);\n                doCometSupport(req, res);\n            } else {\n                logger.error(\"AtmosphereServlet exception\", ex);\n                throw ex;\n            }\n        } finally {\n            if (req != null && a != null && a.type != Action.TYPE.SUSPEND) {\n                req.destroy();\n                res.destroy();\n            }\n        }\n        return null;\n    }\n","new_comment_raw":"Invoke the proprietary  AsyncSupport","old_comment_raw":"Invoke the proprietary CometSupport","label":1,"pre_label":0,"AST_level":13,"line_counts":53,"new_code_token_num":380},{"new_code_raw":"public ScopeContainer getModuleScope() { return moduleScope; }","old_code_raw":"    public ScopeContext getModuleScope() {\n        return moduleScope;\n    }\n","new_comment_raw":"Returns the ScopeContainer for the MODULE scope that will be associated with this deployment unit.","old_comment_raw":"Returns the ScopeContext for the MODULE scope that will be associated with this deployment unit.","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":10},{"new_code_raw":"public static String[] splitPrincipalIntoParts(final String principal) { final String[] components = principal.split(\"[\/@]\"); checkState(components.length < 4); checkState(components.length > 1); checkNotNull(components[0]); checkNotNull(components[1]); if (components.length == 2) { return new String[] { components[0], \"\", components[1] }; } else { checkNotNull(components[2]); return components; } }","old_code_raw":"  public static String[] splitPrincipalIntoParts(final String principal) {\n    final String[] components = principal.split(\"[\/@]\");\n    checkState(components.length == 3);\n    checkNotNull(components[0]);\n    checkNotNull(components[1]);\n    checkNotNull(components[2]);\n    return components;\n  }\n","new_comment_raw":"Expects principal of the format primary\/instance@REALM or primary@REALM.","old_comment_raw":"Expects principal of the format primary\/instance@REALM.","label":1,"pre_label":0,"AST_level":10,"line_counts":15,"new_code_token_num":101},{"new_code_raw":"public DurationField seconds() { return UnsupportedDurationField.getInstance(\"seconds\"); }","old_code_raw":"    public DurationField seconds() {\n        return UnsupportedDurationField.INSTANCE;\n    }\n","new_comment_raw":"Returns a DurationField representing seconds.","old_comment_raw":"Returns a DurationField representing seconds.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":16},{"new_code_raw":"private static int parseOffset(String str) { Chronology chrono; if (cDefault != null) { chrono = ISOChronology.getInstanceUTC(); } else { \/\/ Can't use a real chronology if called during class \/\/ initialization. Offset parser doesn't need it anyhow. chrono = new BaseChronology() { public DateTimeZone getZone() { return null; } public Chronology withUTC() { return this; } public Chronology withZone(DateTimeZone zone) { return this; } public String toString() { return getClass().getName(); } }; } return -(int) offsetFormatter().withChronology(chrono).parseMillis(str); }","old_code_raw":"    private static int parseOffset(String str) {\n        Chronology chrono;\n        if (cDefault != null) {\n            chrono = ISOChronology.getInstanceUTC();\n        } else {\n            \/\/ Can't use a real chronology if called during class\n            \/\/ initialization. Offset parser doesn't need it anyhow.\n            chrono = new BaseChronology() {\n                public DateTimeZone getZone() {\n                    return null;\n                }\n                public Chronology withUTC() {\n                    return this;\n                }\n                public Chronology withZone(DateTimeZone zone) {\n                    return this;\n                }\n                public String toString() {\n                    return getClass().getName();\n                }\n            };\n        }\n\n        return -(int) offsetFormatter().parseMillis(str, chrono);\n    }\n","new_comment_raw":"Converts an old style id to a new style id.","old_comment_raw":"Converts an old style id to a new style id.","label":0,"pre_label":1,"AST_level":11,"line_counts":26,"new_code_token_num":126},{"new_code_raw":"private String functionReplacement(FunctionCall functionCall) { String funcName = functionCall.getName(); if (functionCall.args.size() == 0) { return funcName; } boolean castToNullableNumeric = optionManager != null && optionManager.getOption(ExecConstants.CAST_TO_NULLABLE_NUMERIC_OPTION); if (! castToNullableNumeric) { return funcName; } MajorType majorType = functionCall.args.get(0).getMajorType(); DataMode dataMode = majorType.getMode(); MinorType minorType = majorType.getMinorType(); if (CastFunctions.isReplacementNeeded(funcName, minorType)) { funcName = CastFunctions.getReplacingCastFunction(funcName, dataMode, minorType); } return funcName; }","old_code_raw":"  private String functionReplacement(FunctionCall functionCall) {\n    String funcName = functionCall.getName();\n      if (functionCall.args.size() > 0) {\n          MajorType majorType =  functionCall.args.get(0).getMajorType();\n          DataMode dataMode = majorType.getMode();\n          MinorType minorType = majorType.getMinorType();\n          if (optionManager != null\n              && optionManager.getOption(ExecConstants.CAST_TO_NULLABLE_NUMERIC).bool_val\n              && CastFunctions.isReplacementNeeded(funcName, minorType)) {\n              funcName = CastFunctions.getReplacingCastFunction(funcName, dataMode, minorType);\n          }\n      }\n\n    return funcName;\n  }\n","new_comment_raw":"Checks if this function replacement is needed.","old_comment_raw":"Checks if this function replacement is needed.","label":0,"pre_label":1,"AST_level":8,"line_counts":20,"new_code_token_num":106},{"new_code_raw":"protected Object convertBigInt(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0L; } if (data instanceof Long) return data; if (data instanceof Number) { Number value = (Number) data; return Long.valueOf(value.longValue()); } if (data instanceof Boolean) { return NumberConversions.getLong((Boolean) data); } return handleUnknownData(column, fieldDefn, data); }","old_code_raw":"    protected Object convertBigInt(Column column, Field fieldDefn, Object data) {\n        if (data == null) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return 0L;\n        }\n        if (data instanceof Long) return data;\n        if (data instanceof Number) {\n            Number value = (Number) data;\n            return new Long(value.longValue());\n        }\n        if (data instanceof Boolean) {\n            return NumberConversions.getLong((Boolean) data);\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n","new_comment_raw":"Converts a value object for an expected JDBC type of  Types#INTEGER.","old_comment_raw":"Converts a value object for an expected JDBC type of Types#INTEGER.","label":0,"pre_label":1,"AST_level":8,"line_counts":19,"new_code_token_num":113},{"new_code_raw":"public boolean isWordwrap() { return wordwrap; }","old_code_raw":"    @Override\n    public boolean isWordwrap() {\n        \/\/ TODO implement here once the API from TextField is removed\n        return super.isWordwrap();\n    }\n","new_comment_raw":"Tests if the text area is in word-wrap mode.","old_comment_raw":"Tests if the editor is in word-wrap mode.","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":10},{"new_code_raw":"public static ApiResponse getReferencedApiResponse(OpenAPI openAPI, ApiResponse apiResponse) { if (apiResponse != null && StringUtils.isNotEmpty(apiResponse.get$ref())) { String name = getSimpleRef(apiResponse.get$ref()); ApiResponse referencedApiResponse = getApiResponse(openAPI, name); if(referencedApiResponse != null) { return referencedApiResponse; } } return apiResponse; }","old_code_raw":"    public static ApiResponse getReferencedApiResponse(OpenAPI openAPI, ApiResponse apiResponse) {\n        if (apiResponse != null && StringUtils.isNotEmpty(apiResponse.get$ref())) {\n            String name = getSimpleRef(apiResponse.get$ref());\n            return getApiResponse(openAPI, name);\n        }\n        return apiResponse;\n    }\n","new_comment_raw":"If a ApiResponse contains a reference to an other ApiResponse with '$ref', returns the referenced ApiResponse if it is found or the actual ApiResponse in the other cases.","old_comment_raw":"If a ApiResponse contains a reference to an other ApiResponse with '$ref', returns the referenced ApiResponse or the actual ApiResponse in the other cases.","label":1,"pre_label":0,"AST_level":8,"line_counts":11,"new_code_token_num":68},{"new_code_raw":"public static InetAddress guessPrimaryNetworkAddress(boolean preferIPv4) throws SocketException { final Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces(); if (interfaces != null) { for (NetworkInterface interf : Collections.list(interfaces)) { if (!interf.isLoopback() && interf.isUp()) { \/\/ Interface is not loopback and up. Try to get the first address. for (InetAddress addr : Collections.list(interf.getInetAddresses())) { if (preferIPv4 && addr instanceof Inet4Address) { return addr; } if (!preferIPv4 && addr instanceof Inet6Address) { return addr; } } } } } return InetAddress.getLoopbackAddress(); }","old_code_raw":"    public static InetAddress guessPrimaryNetworkAddress() throws SocketException {\n        final Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();\n\n        if (interfaces != null) {\n            for (NetworkInterface interf : Collections.list(interfaces)) {\n                if (!interf.isLoopback() && interf.isUp()) {\n                    \/\/ Interface is not loopback and up. Try to get the first address.\n                    for (InetAddress addr : Collections.list(interf.getInetAddresses())) {\n                        if (addr instanceof Inet4Address) {\n                            return addr;\n                        }\n                    }\n                }\n            }\n        }\n\n        return InetAddress.getLoopbackAddress();\n    }\n","new_comment_raw":"Try to get the primary  InetAddress of the primary network interface with fallback to the local loopback address (usually  127.0.0.1 or  ::1.","old_comment_raw":"Try to get the primary java.net.InetAddress of the primary network interface with fallback to the local loopback address (usually 127.0.0.1 or ::1.","label":1,"pre_label":0,"AST_level":14,"line_counts":23,"new_code_token_num":123},{"new_code_raw":"public String doCommand(String command, String field, String value) { resultExpected = true; doCommandWithoutWaitingForAResponse(command, field, value); try { return queueGetResult(\"doCommand\"); } finally { resultExpected = false; } }","old_code_raw":"    public String doCommand(String command, String field, String value) {\n        resultExpected = true;\n        doCommandWithoutWaitingForAResponse(command, field, value);\n        try {\n            return (String) queueGet(\"commandResultHolder\", commandResultHolder);\n        } catch (SeleniumCommandTimedOutException e) {\n            return \"ERROR: Command timed out\";\n        }\n        finally {\n            resultExpected = false;\n        }\n    }\n","new_comment_raw":"Schedules the specified command to be retrieved by the next call to handle command result, and returns the result of that command.","old_comment_raw":"Schedules the specified command to be retrieved by the next call to handle command result, and returns the result of that command.","label":0,"pre_label":1,"AST_level":6,"line_counts":11,"new_code_token_num":44},{"new_code_raw":"public DurationConverter removeDurationConverter(DurationConverter converter) throws SecurityException { checkAlterDurationConverters(); if (converter == null) { return null; } DurationConverter[] removed = new DurationConverter[1]; iDurationConverters = iDurationConverters.remove(converter, removed); return removed[0]; }","old_code_raw":"    public DurationConverter removeDurationConverter(int index) throws SecurityException {\n        checkAlterDurationConverters();\n        DurationConverter[] removed = new DurationConverter[1];\n        iDurationConverters = iDurationConverters.remove(index, removed);\n        return removed[0];\n    }\n","new_comment_raw":"Removes a converter from the set of converters.","old_comment_raw":"Removes a converter from the set of converters, by index.","label":1,"pre_label":0,"AST_level":6,"line_counts":12,"new_code_token_num":50},{"new_code_raw":"protected int[] JavaToPdeOffsets(int line, int offset) { return new int[] { 0, 0 }; \/\/ TODO \/* int codeIndex = 0; int x = line - mainClassOffset; if (x < 0) { \/\/ log(\"Negative line number \" \/\/ + problem.getSourceLineNumber() + \" , offset \" \/\/ + mainClassOffset); x = line - 2; \/\/ Another -1 for 0 index if (x < programImports.size() && x >= 0) { ImportStatement is = programImports.get(x); \/\/ log(is.importName + \", \" + is.tab + \", \" \/\/ + is.lineNumber); return new int[] { 0, 0 }; \/\/ TODO } else { \/\/ Some seriously ugly stray error, just can't find the source \/\/ line! Simply return first line for first tab. return new int[] { 0, 1 }; } } try { for (SketchCode sc : editor.getSketch().getCode()) { if (sc.isExtension(\"pde\")) { int len; if (editor.getSketch().getCurrentCode().equals(sc)) { len = Util.countLines(sc.getDocumentText()) + 1; } else { len = Util.countLines(sc.getProgram()) + 1; } \/\/ log(\"x,len, CI: \" + x + \",\" + len + \",\" \/\/ + codeIndex); if (x >= len) { \/\/ We're in the last tab and the line count is greater \/\/ than the no. \/\/ of lines in the tab, if (codeIndex >= editor.getSketch().getCodeCount() - 1) { \/\/ log(\"Exceeds lc \" + x + \",\" + len \/\/ + problem.toString()); \/\/ x = len x = editor.getSketch().getCode(codeIndex) .getLineCount(); \/\/ TODO: Obtain line having last non-white space \/\/ character in the code. break; } else { x -= len; codeIndex++; } } else { if (codeIndex >= editor.getSketch().getCodeCount()) { codeIndex = editor.getSketch().getCodeCount() - 1; } break; } } } } catch (Exception e) { System.err.println(\"Error inside ErrorCheckerService.JavaToPdeOffset()\"); e.printStackTrace(); } return new int[] { codeIndex, x }; *\/ }","old_code_raw":"  protected int[] JavaToPdeOffsets(int line, int offset) {\n    int codeIndex = 0;\n\n    int x = line - mainClassOffset;\n    if (x < 0) {\n      \/\/ log(\"Negative line number \"\n      \/\/ + problem.getSourceLineNumber() + \" , offset \"\n      \/\/ + mainClassOffset);\n      x = line - 2; \/\/ Another -1 for 0 index\n      if (x < programImports.size() && x >= 0) {\n        ImportStatement is = programImports.get(x);\n        \/\/ log(is.importName + \", \" + is.tab + \", \"\n        \/\/ + is.lineNumber);\n        return new int[] { is.getTab(), is.getLineNumber() };\n      } else {\n\n        \/\/ Some seriously ugly stray error, just can't find the source\n        \/\/ line! Simply return first line for first tab.\n        return  new int[] { 0, 1 };\n      }\n\n    }\n\n    try {\n      for (SketchCode sc : editor.getSketch().getCode()) {\n        if (sc.isExtension(\"pde\")) {\n          int len;\n          if (editor.getSketch().getCurrentCode().equals(sc)) {\n            len = Util.countLines(sc.getDocumentText()) + 1;\n          } else {\n            len = Util.countLines(sc.getProgram()) + 1;\n          }\n\n          \/\/ log(\"x,len, CI: \" + x + \",\" + len + \",\"\n          \/\/ + codeIndex);\n\n          if (x >= len) {\n\n            \/\/ We're in the last tab and the line count is greater\n            \/\/ than the no.\n            \/\/ of lines in the tab,\n            if (codeIndex >= editor.getSketch().getCodeCount() - 1) {\n              \/\/ log(\"Exceeds lc \" + x + \",\" + len\n              \/\/ + problem.toString());\n              \/\/ x = len\n              x = editor.getSketch().getCode(codeIndex)\n                  .getLineCount();\n              \/\/ TODO: Obtain line having last non-white space\n              \/\/ character in the code.\n              break;\n            } else {\n              x -= len;\n              codeIndex++;\n            }\n          } else {\n\n            if (codeIndex >= editor.getSketch().getCodeCount()) {\n              codeIndex = editor.getSketch().getCodeCount() - 1;\n            }\n            break;\n          }\n\n        }\n      }\n    } catch (Exception e) {\n      System.err.println(\"Error inside ErrorCheckerService.JavaToPdeOffset()\");\n      e.printStackTrace();\n    }\n    return new int[] { codeIndex, x };\n  }\n","new_comment_raw":"Maps offset from java code to pde code.","old_comment_raw":"Maps offset from java code to pde code.","label":0,"pre_label":1,"AST_level":6,"line_counts":76,"new_code_token_num":484},{"new_code_raw":"public String getRCMLDirectory() { return this.rcmlDirectory; }","old_code_raw":"    public String getRCMLDirectory() {\n        return rcmlDirectory;\n    }\n","new_comment_raw":"Get the RCML directory","old_comment_raw":"DOCUMENT ME!","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":11},{"new_code_raw":"@Override public void createRecord(DBRecord rec, Connection conn) { throw new NotImplementedException(this, \"createRecord\"); }","old_code_raw":"    @Override\n    public boolean createRecord(DBRecord rec, Connection conn)\n    {\n        return error(Errors.NotImplemented, \"addRecord\");\n    }\n","new_comment_raw":"Returns an error, because it is not possible to add a record to a query.","old_comment_raw":"Returns an error, because querys could't add new records to the database.","label":1,"pre_label":0,"AST_level":5,"line_counts":7,"new_code_token_num":25},{"new_code_raw":"public User getUserByName (String username) throws ApiException { Object postBody = null; byte[] postBinaryBody = null; \/\/ verify the required parameter 'username' is set if (username == null) { throw new ApiException(400, \"Missing the required parameter 'username' when calling getUserByName\"); } \/\/ create path and map variables String path = \"\/user\/{username}\".replaceAll(\"\\\\{format\\\\}\",\"json\") .replaceAll(\"\\\\{\" + \"username\" + \"\\\\}\", apiClient.escapeString(username.toString())); \/\/ query params List<Pair> queryParams = new ArrayList<Pair>(); Map<String, String> headerParams = new HashMap<String, String>(); Map<String, Object> formParams = new HashMap<String, Object>(); final String[] accepts = { \"application\/json\", \"application\/xml\" }; final String accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final String contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; TypeRef returnType = new TypeRef<User>() {}; return apiClient.invokeAPI(path, \"GET\", queryParams, postBody, postBinaryBody, headerParams, formParams, accept, contentType, authNames, returnType); }","old_code_raw":"  public User getUserByName (String username) throws ApiException {\n    Object postBody = null;\n    \n    \/\/ verify the required parameter 'username' is set\n    if (username == null) {\n       throw new ApiException(400, \"Missing the required parameter 'username' when calling getUserByName\");\n    }\n    \n\n    \/\/ create path and map variables\n    String path = \"\/user\/{username}\".replaceAll(\"\\\\{format\\\\}\",\"json\")\n      .replaceAll(\"\\\\{\" + \"username\" + \"\\\\}\", apiClient.escapeString(username.toString()));\n\n    \/\/ query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    Map<String, String> headerParams = new HashMap<String, String>();\n    Map<String, Object> formParams = new HashMap<String, Object>();\n\n    \n\n    \n\n    \n\n    final String[] accepts = {\n      \"application\/json\", \"application\/xml\"\n    };\n    final String accept = apiClient.selectHeaderAccept(accepts);\n\n    final String[] contentTypes = {\n      \n    };\n    final String contentType = apiClient.selectHeaderContentType(contentTypes);\n\n    String[] authNames = new String[] {  };\n    \n    TypeRef returnType = new TypeRef<User>() {};\n    return apiClient.invokeAPI(path, \"GET\", queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    \n  }\n","new_comment_raw":"Get user by user name","old_comment_raw":"Get user by user name","label":0,"pre_label":1,"AST_level":9,"line_counts":48,"new_code_token_num":254},{"new_code_raw":"public static DefaultMetaBroadcaster metaBroadcaster() { return metaBroadcaster; }","old_code_raw":"    public static MetaBroadcaster metaBroadcaster() {\n        return metaBroadcaster;\n    }\n","new_comment_raw":"Return the  DefaultMetaBroadcaster","old_comment_raw":"Return the org.atmosphere.cpr.MetaBroadcaster","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":11},{"new_code_raw":"public String convert(Object object) { if (object == null) { return null; } try { JsonElement json = convertObject(object); return new GsonBuilder().serializeNulls().create().toJson(json); } catch (Exception e) { throw new WebDriverException(\"Unable to convert: \" + object, e); } }","old_code_raw":"  public String convert(Object object) {\n    if (object == null) {\n      return null;\n    }\n\n    try {\n      Object converted = convertObject(object, MAX_DEPTH);\n      if (converted instanceof JSONObject\n          || converted instanceof JSONArray\n          || converted instanceof String\n          || converted instanceof Number) {\n        return converted.toString();\n      }\n\n      return String.valueOf(object);\n    } catch (Exception e) {\n      throw new WebDriverException(\"Unable to convert: \" + object, e);\n    }\n  }\n","new_comment_raw":"Convert an object that may or may not be a JsonElement into its JSON string representation, handling the case where it is neither in a graceful way.","old_comment_raw":"Convert an object that may or may not be a JSONArray or JSONObject into its JSON string representation, handling the case where it is neither in a graceful way.","label":1,"pre_label":0,"AST_level":8,"line_counts":13,"new_code_token_num":68},{"new_code_raw":"public Pet getPetById (Long petId) throws ApiException { Object postBody = null; \/\/ verify the required parameter 'petId' is set if (petId == null) { throw new ApiException(400, \"Missing the required parameter 'petId' when calling getPetById\"); } \/\/ create path and map variables String path = \"\/pet\/{petId}\".replaceAll(\"\\\\{format\\\\}\",\"json\") .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString())); \/\/ query params Map<String, String> queryParams = new HashMap<String, String>(); Map<String, String> headerParams = new HashMap<String, String>(); Map<String, String> formParams = new HashMap<String, String>(); String[] contentTypes = { }; String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\"; if(contentType.startsWith(\"multipart\/form-data\")) { boolean hasFields = false; FormDataMultiPart mp = new FormDataMultiPart(); if(hasFields) postBody = mp; } else { } try { String response = apiClient.invokeAPI(path, \"GET\", queryParams, postBody, headerParams, formParams, contentType); if(response != null){ return (Pet) apiClient.deserialize(response, \"\", Pet.class); } else { return null; } } catch (ApiException ex) { throw ex; } }","old_code_raw":"  public Pet getPetById (Long petId) throws ApiException {\n    Object postBody = null;\n    \n    \/\/ verify the required parameter 'petId' is set\n    if (petId == null) {\n       throw new ApiException(400, \"Missing the required parameter 'petId' when calling getPetById\");\n    }\n    \n\n    \/\/ create path and map variables\n    String path = \"\/pet\/{petId}\".replaceAll(\"\\\\{format\\\\}\",\"json\")\n      .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiInvoker.escapeString(petId.toString()));\n\n    \/\/ query params\n    Map<String, String> queryParams = new HashMap<String, String>();\n    Map<String, String> headerParams = new HashMap<String, String>();\n    Map<String, String> formParams = new HashMap<String, String>();\n\n    \n    \n    String[] contentTypes = {\n      \n    };\n\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\";\n\n    if(contentType.startsWith(\"multipart\/form-data\")) {\n      boolean hasFields = false;\n      FormDataMultiPart mp = new FormDataMultiPart();\n      \n      if(hasFields)\n        postBody = mp;\n    }\n    else {\n      \n    }\n\n    try {\n      String response = apiInvoker.invokeAPI(basePath, path, \"GET\", queryParams, postBody, headerParams, formParams, contentType);\n      if(response != null){\n        return (Pet) ApiInvoker.deserialize(response, \"\", Pet.class);\n      }\n      else {\n        return null;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n","new_comment_raw":"Find pet by ID","old_comment_raw":"Find pet by ID","label":0,"pre_label":1,"AST_level":10,"line_counts":50,"new_code_token_num":283},{"new_code_raw":"public static MemberID parse(String memberID) { return parse(memberID, false, AppInfo.getSingleton().getClassPath()); }","old_code_raw":"    public static MemberID parse(String signature) {\n        return parse(signature, false, AppInfo.getSingleton().getClassPath());\n    }\n","new_comment_raw":"Parse a member ID, with or without classname, with or without descriptor.","old_comment_raw":"Parse a signature, with or without classname, with or without descriptor.","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":26},{"new_code_raw":"private static Provider getDefaultProvider() { \/\/ approach 1 try { String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.Provider\"); if (providerClass != null) { try { Provider provider = (Provider) Class.forName(providerClass).newInstance(); return validateProvider(provider); } catch (Exception ex) { throw new RuntimeException(ex); } } } catch (SecurityException ex) { \/\/ ignored } \/\/ approach 2 try { String dataFolder = System.getProperty(\"org.joda.time.DateTimeZone.Folder\"); if (dataFolder != null) { try { Provider provider = new ZoneInfoProvider(new File(dataFolder)); return validateProvider(provider); } catch (Exception ex) { throw new RuntimeException(ex); } } } catch (SecurityException ex) { \/\/ ignored } \/\/ approach 3 try { Provider provider = new ZoneInfoProvider(\"org\/joda\/time\/tz\/data\"); return validateProvider(provider); } catch (Exception ex) { ex.printStackTrace(); } \/\/ approach 4 return new UTCProvider(); }","old_code_raw":"    private static Provider getDefaultProvider() {\n        Provider provider = null;\n\n        try {\n            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n            if (providerClass != null) {\n                try {\n                    provider = (Provider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            \/\/ ignored\n        }\n\n        if (provider == null) {\n            try {\n                provider = new ZoneInfoProvider(\"org\/joda\/time\/tz\/data\");\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n        }\n\n        if (provider == null) {\n            provider = new UTCProvider();\n        } else {\n            validateProvider(provider);\n        }\n        return provider;\n    }\n","new_comment_raw":"Gets the default zone provider.","old_comment_raw":"Gets the default zone provider.","label":0,"pre_label":1,"AST_level":11,"line_counts":40,"new_code_token_num":211},{"new_code_raw":"public Object next() throws java.io.IOException { int zzInput; int zzAction; \/\/ cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; \/\/ set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { \/\/ store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); \/\/ get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } \/\/ store back cached position zzMarkedPos = zzMarkedPosL; if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { \/\/ prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); \/\/ System.err.println(\"At end of text making after: |\" + str + \"|\"); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); \/\/ System.err.println(\"prevWord is |\" + prevWord.get(CoreAnnotations.TextAnnotation.class) + \"|, its after is |\" + \/\/ prevWord.get(CoreAnnotations.AfterAnnotation.class) + \"|\"); prevWordAfter.setLength(0); } return null; } } else { switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { String str = yytext(); int first = str.codePointAt(0); String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } logger.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: logger.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 79: break; case 2: { return getNext(\"<\", yytext()); } case 80: break; case 3: { return getNext(); } case 81: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 82: break; case 5: { if (tokenizeNLs) { return getNext(AbstractTokenizer.NEWLINE_TOKEN, yytext()); \/\/ for tokenizing newliens } else if (invertible) { \/\/ System.err.println(\"Appending newline: |\" + yytext() + \"|\"); prevWordAfter.append(yytext()); } } case 83: break; case 6: { final String origTxt = yytext(); String tok = LexerUtils.removeSoftHyphens(origTxt); if (americanize) { tok = Americanize.americanize(tok); } if (DEBUG) { logger.info(\"Used {WORD} (2) to recognize \" + origTxt + \" as \" + tok); } return getNext(tok, origTxt); } case 84: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 85: break; case 8: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {QUOTES} (3) to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 86: break; case 9: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 87: break; case 10: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 88: break; case 11: { return getNext(\">\", yytext()); } case 89: break; case 12: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 90: break; case 13: { handleHyphenatedNumber(yytext()); if (DEBUG) { logger.info(\"Used {NUMBER} to recognize \" + yytext() + \" as \" + removeFromNumber(yytext())); } return getNext(removeFromNumber(yytext()), yytext()); } case 91: break; case 14: { return handleEllipsis(yytext()); } case 92: break; case 15: { \/\/ breakByHyphens(yytext()); \/\/ this is causing fail of attempted to pushback too much! String tok = yytext(); \/* A THING can contain quote like O'Malley *\/ String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {THING} (2) to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 93: break; case 16: { String txt = yytext(); String norm = normalizeFractions(yytext()); if (DEBUG) { logger.info(\"Used {FRAC2} to recognize \" + txt + \" as \" + norm + \"; normalizeFractions=\" + normalizeFractions + \", escapeForwardSlashAsterisk=\" + escapeForwardSlashAsterisk); } return getNext(norm, txt); } case 94: break; case 17: { if (normalizeCurrency) { return getNext(LexerUtils.normalizeCurrency(yytext()), yytext()); } else { return getNext(LexerUtils.minimallyNormalizeCurrency(yytext()), yytext()); } } case 95: break; case 18: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 96: break; case 19: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 97: break; case 20: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 98: break; case 21: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 99: break; case 22: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 100: break; case 23: { if (normalizeOtherBrackets) { return getNext(\"-LSB-\", yytext()); } else { return getNext(); } } case 101: break; case 24: { if (normalizeOtherBrackets) { return getNext(\"-RSB-\", yytext()); } else { return getNext(); } } case 102: break; case 25: { String tok = yytext(); String norm = LexerUtils.processCp1252misc(tok); if (DEBUG) { logger.info(\"Used {CP1252_MISC_SYMBOL} to recognize \" + tok + \" as \" + norm); } return getNext(norm, tok); } case 103: break; case 26: { if (invertible) { prevWordAfter.append(yytext()); } } case 104: break; case 27: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 17; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 18; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 105: break; case 28: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(); } case 106: break; case 29: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {REDAUX} (2) to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 107: break; case 30: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {APOWORD} to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 108: break; case 31: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); String norm = handleQuotes(tok, true); if (DEBUG) { logger.info(\"Used {DBLQUOT} to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + true); } return getNext(norm, tok); } case 109: break; case 32: { String tok = yytext(); if (DEBUG) { logger.info(\"Used {PROG_LANGS} to recognize \" + tok + \" as \" + tok); } return getNext(tok, tok); } case 110: break; case 33: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String txt = yytext(); if (DEBUG) { logger.info(\"Used {DIGIT}\/{SEP_SUFFIX} to recognize \" + txt); } return getNext(txt, txt); } case 111: break; case 34: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 112: break; case 35: { breakByHyphens(yytext()); if (DEBUG) { logger.info(\"Used {HTHING} to recognize \" + yytext() + \" as \" + LexerUtils.removeSoftHyphens(yytext())); } return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext()); } case 113: break; case 36: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tok = LexerUtils.removeSoftHyphens(origTxt); if (americanize) { tok = Americanize.americanize(tok); } if (DEBUG) { logger.info(\"Used {WORD} to recognize \" + origTxt + \" as \" + tok); } return getNext(tok, origTxt); } case 114: break; case 37: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 115: break; case 38: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String origTok = yytext(); String norm = LexerUtils.removeSoftHyphens(origTok); if (DEBUG) { logger.info(\"Used {WORD} (3) to recognize \" + origTok + \" as \" + norm); } return getNext(norm, origTok); } case 116: break; case 39: { \/\/ this one should only match if we're basically at the end of file \/\/ since the last one matches two things, even newlines (if not tokenize per line) return processAbbrev1(); } case 117: break; case 40: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 118: break; case 41: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { \/\/ Extra context is to not match on ones like 'd but you do want words like \"a\" \/\/ can't have digit here because of cases like '90s String tok = yytext(); \/* invert single quote - often but not always right *\/ String norm = handleQuotes(tok, true); if (DEBUG) { logger.info(\"Used {QUOTES} to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + true); } return getNext(norm, tok); } case 119: break; case 42: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {REDAUX} to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 120: break; case 43: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { \/\/ Extra context is to not match on ones like 'd but you do want words like \"a\" \/\/ can't have digit here because of cases like '90s String tok = yytext(); \/* invert single quote - often but not always right *\/ String norm = handleQuotes(tok, true); if (DEBUG) { logger.info(\"Used {QUOTES} (2) to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + true); } return getNext(norm, tok); } case 121: break; case 44: { return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext()); } case 122: break; case 45: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {SREDAUX} (2) to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 123: break; case 46: { if (splitAssimilations) { yypushback(2); } String tok = yytext(); if (DEBUG) { logger.info(\"Used {ASSIMILATIONS3} to recognize \" + tok + \" as \" + tok + \"; splitAssimilations=\" + splitAssimilations); } return getNext(tok, tok); } case 124: break; case 47: { String txt = yytext(); \/\/ if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space... if (strictTreebank3) { int spaceIndex = indexOfSpace(txt); if (spaceIndex >= 0) { yypushback(txt.length() - spaceIndex); return getNext(); } } if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, yytext()); } case 125: break; case 48: { final String origTxt = yytext(); String tok; if (normalizeAmpersandEntity) { tok = LexerUtils.normalizeAmp(origTxt); } else { tok = origTxt; } if (DEBUG) { logger.info(\"Used {THINGA} (2) to recognize \" + origTxt + \" as \" + tok); } return getNext(tok, origTxt); } case 126: break; case 49: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, origTxt); } case 127: break; case 50: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space } return getNext(txt, origTxt); } case 128: break; case 51: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tok = LexerUtils.removeSoftHyphens(origTxt); if (DEBUG) { logger.info(\"Used {SWORD} to recognize \" + origTxt + \" as \" + tok); } return getNext(tok, origTxt); } case 129: break; case 52: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 19; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 18; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 130: break; case 53: { String txt = yytext(); String normTok = txt; if (escapeForwardSlashAsterisk) { normTok = delimit(normTok, '*'); } if (DEBUG) { logger.info(\"Used {SWEARING} to recognize \" + txt + \" as \" + normTok); } return getNext(normTok, txt); } case 131: break; case 54: { final String origTxt = yytext(); String tok; if (normalizeAmpersandEntity) { tok = LexerUtils.normalizeAmp(origTxt); } else { tok = origTxt; } if (DEBUG) { logger.info(\"Used {TBSPEC} to recognize \" + origTxt + \" as \" + tok); } return getNext(tok, origTxt); } case 132: break; case 55: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 133: break; case 56: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 13; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 134: break; case 57: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 22; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 24; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 135: break; case 58: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 21; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 136: break; case 59: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 13; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 137: break; case 60: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 22; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 23; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 138: break; case 61: { String txt = yytext(); String norm = txt; if (escapeForwardSlashAsterisk) { norm = delimit(norm, '\/'); norm = delimit(norm, '*'); } if (DEBUG) { logger.info(\"Used {LIKELYURL} to recognize \" + txt + \" as \" + norm); } return getNext(norm, txt); } case 139: break; case 62: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); breakByHyphens(tok); tok = yytext(); String norm = LexerUtils.removeSoftHyphens(tok); if (DEBUG) { logger.info(\"Used {HTHING} (2) to recognize \" + tok + \" as \" + norm); } return getNext(norm, tok); } case 140: break; case 63: { if (splitAssimilations) { yypushback(3); } String tok = yytext(); if (DEBUG) { logger.info(\"Used {ASSIMILATIONS3} to recognize \" + tok + \" as \" + tok + \"; splitAssimilations=\" + splitAssimilations); } return getNext(tok, tok); } case 141: break; case 64: { final String origTxt = yytext(); String tok; if (normalizeAmpersandEntity) { tok = LexerUtils.normalizeAmp(origTxt); } else { tok = origTxt; } if (DEBUG) { logger.info(\"Used {SPAMP} to recognize \" + origTxt + \" as \" + tok); } return getNext(tok, origTxt); } case 142: break; case 65: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext()); } case 143: break; case 66: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { final String origTxt = yytext(); String tok; if (normalizeAmpersandEntity) { tok = LexerUtils.normalizeAmp(origTxt); } else { tok = origTxt; } if (DEBUG) { logger.info(\"Used {THINGA} to recognize \" + origTxt + \" as \" + tok); } return getNext(tok, origTxt); } case 144: break; case 67: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 9; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 145: break; case 68: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { return getNext(); } case 146: break; case 69: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 14; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 147: break; case 70: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 9; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 10; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 148: break; case 71: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 14; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 15; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 149: break; case 72: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } return getNext(txt, yytext()); } case 150: break; case 73: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4); { return getNext(); } case 151: break; case 74: \/\/ lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { return getNext(); } case 152: break; case 75: { String txt = yytext(); String norm = txt; if (escapeForwardSlashAsterisk) { norm = delimit(norm, '\/'); norm = delimit(norm, '*'); } if (DEBUG) { logger.info(\"Used {FULLURL} to recognize \" + txt + \" as \" + norm); } return getNext(norm, txt); } case 153: break; case 76: { String txt = yytext(); if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } if (DEBUG) { logger.info(\"Used {PHONE} to recognize \" + yytext() + \" as \" + txt); } return getNext(txt, yytext()); } case 154: break; case 77: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 25; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 27; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 155: break; case 78: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 25; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 26; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 156: break; default: zzScanError(ZZ_NO_MATCH); } } } }","old_code_raw":"  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    \/\/ cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      \/\/ set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            \/\/ store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            \/\/ get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      \/\/ store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n        zzAtEOF = true;\n              {\n                if (invertible) {\n            \/\/ prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            \/\/ System.err.println(\"At end of text making after: |\" + str + \"|\");\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n            \/\/ System.err.println(\"prevWord is |\" + prevWord.get(CoreAnnotations.TextAnnotation.class) + \"|, its after is |\" +\n            \/\/         prevWord.get(CoreAnnotations.AfterAnnotation.class) + \"|\");\n            prevWordAfter.setLength(0);\n          }\n          return null;\n              }\n      }\n      else {\n        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n          case 1: \n            { String str = yytext();\n          int first = str.codePointAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\",\n                          yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n            }\n          case 77: break;\n          case 2: \n            { return getNext(\"<\", yytext());\n            }\n          case 78: break;\n          case 3: \n            { return getNext();\n            }\n          case 79: break;\n          case 4: \n            { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n            }\n          case 80: break;\n          case 5: \n            { if (tokenizeNLs) {\n                      return getNext(AbstractTokenizer.NEWLINE_TOKEN, yytext()); \/\/ for tokenizing newliens\n                  } else if (invertible) {\n                    \/\/ System.err.println(\"Appending newline: |\" + yytext() + \"|\");\n                    prevWordAfter.append(yytext());\n                  }\n            }\n          case 81: break;\n          case 6: \n            { final String origTxt = yytext();\n                          String tok = LexerUtils.removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tok = Americanize.americanize(tok);\n                          }\n                          if (DEBUG) { logger.info(\"Used {WORD} (2) to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 82: break;\n          case 7: \n            { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n            }\n          case 83: break;\n          case 8: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} (3) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 84: break;\n          case 9: \n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 85: break;\n          case 10: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '\/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 86: break;\n          case 11: \n            { return getNext(\">\", yytext());\n            }\n          case 87: break;\n          case 12: \n            { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n            }\n          case 88: break;\n          case 13: \n            { handleHyphenatedNumber(yytext());\n                          if (DEBUG) { logger.info(\"Used {NUMBER} to recognize \" + yytext() + \" as \" + removeFromNumber(yytext())); }\n                          return getNext(removeFromNumber(yytext()), yytext());\n            }\n          case 89: break;\n          case 14: \n            { return handleEllipsis(yytext());\n            }\n          case 90: break;\n          case 15: \n            { \/\/ breakByHyphens(yytext()); \/\/ this is causing fail of attempted to pushback too much!\n                  String tok = yytext();\n                  \/* A THING can contain quote like O'Malley *\/\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {THING} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 91: break;\n          case 16: \n            { String txt = yytext();\n                  String norm = normalizeFractions(yytext());\n                  if (DEBUG) { logger.info(\"Used {FRAC2} to recognize \" + txt + \" as \" + norm +\n                                       \"; normalizeFractions=\" + normalizeFractions +\n                                       \", escapeForwardSlashAsterisk=\" + escapeForwardSlashAsterisk); }\n                  return getNext(norm, txt);\n            }\n          case 92: break;\n          case 17: \n            { if (normalizeCurrency) {\n                            return getNext(LexerUtils.normalizeCurrency(yytext()), yytext());\n                        } else {\n                            return getNext(LexerUtils.minimallyNormalizeCurrency(yytext()), yytext());\n                          }\n            }\n          case 93: break;\n          case 18: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-RSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 94: break;\n          case 19: \n            { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 95: break;\n          case 20: \n            { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 96: break;\n          case 21: \n            { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 97: break;\n          case 22: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 98: break;\n          case 23: \n            { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 99: break;\n          case 24: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-LSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 100: break;\n          case 25: \n            { String tok = yytext();\n                        String norm = LexerUtils.processCp1252misc(tok);\n                        if (DEBUG) { logger.info(\"Used {CP1252_MISC_SYMBOL} to recognize \" + tok + \" as \" + norm); }\n                        return getNext(norm, tok);\n            }\n          case 101: break;\n          case 26: \n            { if (invertible) {\n                            prevWordAfter.append(yytext());\n                        }\n            }\n          case 102: break;\n          case 27: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 15;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 103: break;\n          case 28: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext();\n            }\n          case 104: break;\n          case 29: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {REDAUX} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 105: break;\n          case 30: \n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {APOWORD} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 106: break;\n          case 31: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                                   String norm = handleQuotes(tok, true);\n                                   if (DEBUG) { logger.info(\"Used {DBLQUOT} to recognize \" + tok + \" as \" + norm +\n                                                            \"; probablyLeft=\" + true); }\n                                   return getNext(norm, tok);\n            }\n          case 107: break;\n          case 32: \n            { String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {PROG_LANGS} to recognize \" + tok + \" as \" + tok); }\n                    return getNext(tok, tok);\n            }\n          case 108: break;\n          case 33: \n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 109: break;\n          case 34: \n            { breakByHyphens(yytext());\n                  if (DEBUG) { logger.info(\"Used {HTHING} to recognize \" + yytext() + \" as \" + LexerUtils.removeSoftHyphens(yytext())); }\n                  return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext());\n            }\n          case 110: break;\n          case 35: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 3;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 4;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String origTxt = yytext();\n                          String tok = LexerUtils.removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tok = Americanize.americanize(tok);\n                          }\n                          if (DEBUG) { logger.info(\"Used {WORD} to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 111: break;\n          case 36: \n            { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '\/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 112: break;\n          case 37: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String origTok = yytext();\n                          String norm = LexerUtils.removeSoftHyphens(origTok);\n                          if (DEBUG) { logger.info(\"Used {WORD} (3) to recognize \" + origTok + \" as \" + norm); }\n                          return getNext(norm, origTok);\n            }\n          case 113: break;\n          case 38: \n            { \/\/ this one should only match if we're basically at the end of file\n                          \/\/ since the last one matches two things, even newlines (if not tokenize per line)\n                          return processAbbrev1();\n            }\n          case 114: break;\n          case 39: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 115: break;\n          case 40: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { \/\/ Extra context is to not match on ones like 'd but you do want words like \"a\"\n                  \/\/ can't have digit here because of cases like '90s\n                  String tok = yytext();\n                  \/* invert single quote - often but not always right *\/\n                  String norm = handleQuotes(tok, true);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + true); }\n                  return getNext(norm, tok);\n            }\n          case 116: break;\n          case 41: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {REDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 117: break;\n          case 42: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { \/\/ Extra context is to not match on ones like 'd but you do want words like \"a\"\n                  \/\/ can't have digit here because of cases like '90s\n                  String tok = yytext();\n                  \/* invert single quote - often but not always right *\/\n                  String norm = handleQuotes(tok, true);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + true); }\n                  return getNext(norm, tok);\n            }\n          case 118: break;\n          case 43: \n            { return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext());\n            }\n          case 119: break;\n          case 44: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {SREDAUX} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 120: break;\n          case 45: \n            { if (splitAssimilations) {\n                      yypushback(2);\n                    }\n                    String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {ASSIMILATIONS3} to recognize \" + tok + \" as \" + tok +\n                            \"; splitAssimilations=\" + splitAssimilations); }\n                    return getNext(tok, tok);\n            }\n          case 121: break;\n          case 46: \n            { String txt = yytext();\n                  \/\/ if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space...\n                  if (strictTreebank3) {\n                    int spaceIndex = indexOfSpace(txt);\n                    if (spaceIndex >= 0) {\n                      yypushback(txt.length() - spaceIndex);\n                      return getNext();\n                    }\n                  }\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '\/');\n                  }\n                  if (normalizeSpace) {\n                    txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                  }\n                  return getNext(txt, yytext());\n            }\n          case 122: break;\n          case 47: \n            { final String origTxt = yytext();\n                          String tok;\n                          if (normalizeAmpersandEntity) {\n                            tok = LexerUtils.normalizeAmp(origTxt);\n                          } else {\n                            tok = origTxt;\n                          }\n                          if (DEBUG) { logger.info(\"Used {THINGA} (2) to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 123: break;\n          case 48: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 124: break;\n          case 49: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 125: break;\n          case 50: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 5;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 6;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String origTxt = yytext();\n                          String tok = LexerUtils.removeSoftHyphens(origTxt);\n                          if (DEBUG) { logger.info(\"Used {SWORD} to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 126: break;\n          case 51: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 17;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 127: break;\n          case 52: \n            { String txt = yytext();\n                  String normTok = txt;\n                  if (escapeForwardSlashAsterisk) {\n                    normTok = delimit(normTok, '*');\n                  }\n                  if (DEBUG) { logger.info(\"Used {SWEARING} to recognize \" + txt + \" as \" + normTok); }\n                  return getNext(normTok, txt);\n            }\n          case 128: break;\n          case 53: \n            { final String origTxt = yytext();\n                  String tok;\n                  if (normalizeAmpersandEntity) {\n                    tok = LexerUtils.normalizeAmp(origTxt);\n                  } else {\n                    tok = origTxt;\n                  }\n                  if (DEBUG) { logger.info(\"Used {TBSPEC} to recognize \" + origTxt + \" as \" + tok); }\n                  return getNext(tok, origTxt);\n            }\n          case 129: break;\n          case 54: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 130: break;\n          case 55: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 10;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 131: break;\n          case 56: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 22;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 132: break;\n          case 57: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 18;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 19;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 133: break;\n          case 58: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 10;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 134: break;\n          case 59: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 21;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 135: break;\n          case 60: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 136: break;\n          case 61: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                  breakByHyphens(tok);\n                  tok = yytext();\n                  String norm = LexerUtils.removeSoftHyphens(tok);\n                  if (DEBUG) { logger.info(\"Used {HTHING} (2) to recognize \" + tok + \" as \" + norm); }\n                  return getNext(norm, tok);\n            }\n          case 137: break;\n          case 62: \n            { if (splitAssimilations) {\n                      yypushback(3);\n                    }\n                    String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {ASSIMILATIONS3} to recognize \" + tok + \" as \" + tok +\n                            \"; splitAssimilations=\" + splitAssimilations); }\n                    return getNext(tok, tok);\n            }\n          case 138: break;\n          case 63: \n            { final String origTxt = yytext();\n                          String tok;\n                          if (normalizeAmpersandEntity) {\n                            tok = LexerUtils.normalizeAmp(origTxt);\n                          } else {\n                            tok = origTxt;\n                          }\n                          if (DEBUG) { logger.info(\"Used {SPAMP} to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 139: break;\n          case 64: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext());\n            }\n          case 140: break;\n          case 65: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { final String origTxt = yytext();\n                          String tok;\n                          if (normalizeAmpersandEntity) {\n                            tok = LexerUtils.normalizeAmp(origTxt);\n                          } else {\n                            tok = origTxt;\n                          }\n                          if (DEBUG) { logger.info(\"Used {THINGA} to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 141: break;\n          case 66: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 9;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 142: break;\n          case 67: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { return getNext();\n            }\n          case 143: break;\n          case 68: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 14;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 144: break;\n          case 69: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 8;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 145: break;\n          case 70: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 13;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 146: break;\n          case 71: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 147: break;\n          case 72: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4);\n            { return getNext();\n            }\n          case 148: break;\n          case 73: \n            \/\/ lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);\n            { return getNext();\n            }\n          case 149: break;\n          case 74: \n            { String txt = yytext();\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          if (DEBUG) { logger.info(\"Used {PHONE} to recognize \" + yytext() + \" as \" + txt); }\n                          return getNext(txt, yytext());\n            }\n          case 150: break;\n          case 75: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 23;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 25;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 151: break;\n          case 76: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 23;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 24;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 152: break;\n          default:\n            zzScanError(ZZ_NO_MATCH);\n        }\n      }\n    }\n  }\n","new_comment_raw":"Resumes scanning until the next regular expression is matched, the end of input is encountered or an I\/O-Error occurs.","old_comment_raw":"Resumes scanning until the next regular expression is matched, the end of input is encountered or an I\/O-Error occurs.","label":0,"pre_label":1,"AST_level":21,"line_counts":1164,"new_code_token_num":8301},{"new_code_raw":"@NonNull protected List<Action> retrieveActions(@NonNull SCMHead head, @NonNull SCMHeadEvent event, @NonNull TaskListener listener) throws IOException, InterruptedException { return Collections.emptyList(); }","old_code_raw":"    @NonNull\n    protected Map<Class<? extends Action>, Action> retrieveActions(@NonNull SCMHead head,\n                                                                   @NonNull TaskListener listener)\n            throws IOException, InterruptedException {\n        return Collections.emptyMap();\n    }\n","new_comment_raw":"SPI for  #fetchActions(SCMHead, SCMHeadEvent, TaskListener).","old_comment_raw":"SPI for #fetchActions(SCMHead, TaskListener).","label":1,"pre_label":0,"AST_level":5,"line_counts":9,"new_code_token_num":34},{"new_code_raw":"public static Schema unaliasSchema(Map<String, Schema> allSchemas, Schema schema) { if (allSchemas == null || allSchemas.isEmpty()) { \/\/ skip the warning as the spec can have no model defined \/\/LOGGER.warn(\"allSchemas cannot be null\/empty in unaliasSchema. Returned 'schema'\"); return schema; } if (schema != null && StringUtils.isNotEmpty(schema.get$ref())) { Schema ref = allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())); if (ref == null) { LOGGER.warn(\"{} is not defined\", schema.get$ref()); return schema; } else if (ref.getEnum() != null && !ref.getEnum().isEmpty()) { \/\/ top-level enum class return schema; } else if (isFreeFormObject(ref)) { return schema; } else if (isArraySchema(ref) || isComposedSchema(ref)) { \/\/ array def should be created as models return schema; } else if (isMapSchema(ref)) { if (ref.getProperties() != null && !ref.getProperties().isEmpty()) \/\/ has properties return schema; \/\/ treat it as model else { \/\/ treat it as a typical map \/* TODO unalias the map item if it's an alias if (ref.getAdditionalProperties() != null) { Schema innerSchema = (Schema) ref.getAdditionalProperties(); if (StringUtils.isNotEmpty(innerSchema.get$ref())) { \/\/ map item is a ref to something else \/\/Schema unaliasInnerSchema = unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(innerSchema.get$ref()))); \/\/ref.setAdditionalProperties(unaliasInnerSchema); } }*\/ return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()))); } } else if (isObjectSchema(ref)) { \/\/ model return schema; } else { return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()))); } } return schema; }","old_code_raw":"    public static Schema unaliasSchema(Map<String, Schema> allSchemas, Schema schema) {\n        if (allSchemas == null || allSchemas.isEmpty()) {\n            LOGGER.warn(\"allSchemas cann't be null\/empty in unaliasSchema. Returned 'schema'\");\n            return schema;\n        }\n\n        if (schema != null && StringUtils.isNotEmpty(schema.get$ref())) {\n            Schema ref = allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()));\n            if (ref == null) {\n                LOGGER.warn(\"{} is not defined\", schema.get$ref());\n                return schema;\n            } else if (ref.getEnum() != null && !ref.getEnum().isEmpty()) {\n                \/\/ top-level enum class\n                return schema;\n            } else if (isArraySchema(ref) || isComposedSchema(ref)) { \/\/ array def should be created as models\n                return schema;\n            } else if (isMapSchema(ref)) {\n                if (ref.getProperties() != null && !ref.getProperties().isEmpty()) \/\/ has properties\n                    return schema; \/\/ treat it as model\n                else {\n                    \/\/ treat it as a typical map\n                    \/* TODO unalias the map item if it's an alias\n                    if (ref.getAdditionalProperties() != null) {\n\n                        Schema innerSchema = (Schema) ref.getAdditionalProperties();\n                        if (StringUtils.isNotEmpty(innerSchema.get$ref())) { \/\/ map item is a ref to something else\n                            \/\/Schema unaliasInnerSchema = unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(innerSchema.get$ref())));\n                            \/\/ref.setAdditionalProperties(unaliasInnerSchema);\n                        }\n                    }*\/\n                    return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));\n                }\n            } else if (isObjectSchema(ref)) { \/\/ model\n                return schema;\n            } else {\n                return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));\n            }\n        }\n        return schema;\n    }\n","new_comment_raw":"Get the actual schema from aliases.","old_comment_raw":"Get the actual schema from aliases.","label":0,"pre_label":1,"AST_level":17,"line_counts":44,"new_code_token_num":415},{"new_code_raw":"public boolean matches( Method method, Class targetClass) { return ( (method.getAnnotation( RequiresPermissions.class ) != null ) || (method.getAnnotation( RequiresRoles.class ) != null ) ); }","old_code_raw":"    public boolean matches( Method method, Class targetClass) {\n        return ( (method.getAnnotation( PermissionsRequired.class ) != null ) ||\n                 (method.getAnnotation( RolesRequired.class ) != null ) );\n    }\n","new_comment_raw":"Returns true if the method has a JSecurity RequiresRoles or RequiresPermissions annotation, false otherwise.","old_comment_raw":"Returns true if the method has a JSecurity RolesRequired or PermissionsRequired annotation, false otherwise.","label":1,"pre_label":0,"AST_level":8,"line_counts":6,"new_code_token_num":38},{"new_code_raw":"protected IsolationLevel getTransactionIsolation() { return this.transactionIsolationLevel; }","old_code_raw":"\tprotected TransactionIsolation getTransactionIsolation() {\r\n\t\treturn this.transactionIsolationLevel;\r\n\t}\r\n","new_comment_raw":"Retrieve the currently specified  IsolationLevel level.","old_comment_raw":"Retrieve the currently specified TransactionIsolation level.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":11},{"new_code_raw":"public static EBoolean contains(Expr<String> left, String right) { return factory.createBoolean(Ops.CONTAINS, left, factory.createConstant(right)); }","old_code_raw":"    public static EBoolean contains(Expr<String> left, String right) {\n        return createBoolean(Ops.CONTAINS, left, createConstant(right));\n    }\n","new_comment_raw":"Expr : left || right","old_comment_raw":"Expr : left || right","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":30},{"new_code_raw":"public boolean isEmpty() { return propertyPathsByTransientEntity == null || propertyPathsByTransientEntity.isEmpty(); }","old_code_raw":"\tpublic boolean isEmpty() {\n\t\treturn propertyPathsByTransientEntity.isEmpty();\n\t}\n","new_comment_raw":"Are there any paths currently tracked here?","old_comment_raw":"Are there any paths currently tracked here?","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":17},{"new_code_raw":"public int getIconUtfValue(String icon) { if (iconMap.containsKey(icon)) { return iconMap.get(icon); } else { return 0; } }","old_code_raw":"    public int getIconUtfValue(String icon) {\n        return iconMap.get(icon);\n    }\n","new_comment_raw":"Loads a  Typeface for the given icon font.","old_comment_raw":"Loads a Typeface for the given icon font.","label":0,"pre_label":1,"AST_level":7,"line_counts":8,"new_code_token_num":32},{"new_code_raw":"public boolean matches( Method method, Class targetClass) { return ( (method.getAnnotation( PermissionRequired.class ) != null ) || (method.getAnnotation( RolesRequired.class ) != null ) ); }","old_code_raw":"    public boolean matches( Method method, Class targetClass) {\n        return ( (method.getAnnotation( Implies.class ) != null ) ||\n                 (method.getAnnotation( HasRole.class ) != null ) );\n    }\n","new_comment_raw":"Returns true if the method has a JSecurity RolesRequired or PermissionRequired annotation, false otherwise.","old_comment_raw":"Returns true if the method has a JSecurity HasRole or Implies annotation, false otherwise.","label":1,"pre_label":0,"AST_level":8,"line_counts":6,"new_code_token_num":38},{"new_code_raw":"protected Object convertDateToEpochDays(Column column, Field fieldDefn, Object data) { \/\/ epoch is the fallback value return convertValue(column, fieldDefn, data, 0, (r) -> { try { r.deliver(Date.toEpochDay(data, adjuster)); } catch (IllegalArgumentException e) { logger.warn(\"Unexpected JDBC DATE value for field {} with schema {}: class={}, value={}\", fieldDefn.name(), fieldDefn.schema(), data.getClass(), data); } }); }","old_code_raw":"    protected Object convertDateToEpochDays(Column column, Field fieldDefn, Object data) {\n        if (data == null && !fieldDefn.schema().isOptional()) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return 0; \/\/ return epoch\n        }\n        try {\n            return Date.toEpochDay(data, adjuster);\n        } catch (IllegalArgumentException e) {\n            logger.warn(\"Unexpected JDBC DATE value for field {} with schema {}: class={}, value={}\", fieldDefn.name(),\n                        fieldDefn.schema(), data.getClass(), data);\n            return handleUnknownData(column, fieldDefn, data);\n        }\n    }\n","new_comment_raw":"Converts a value object for an expected JDBC type of  Types#DATE to the number of days past epoch.","old_comment_raw":"Converts a value object for an expected JDBC type of Types#DATE to the number of days past epoch.","label":0,"pre_label":1,"AST_level":10,"line_counts":12,"new_code_token_num":107},{"new_code_raw":"public static Predicate isNotNull(Expression<?> left) { return PredicateOperation.create(Ops.IS_NOT_NULL, left); }","old_code_raw":"    public static Predicate isNotNull(Expression<?> left) {\n        return new PredicateOperation(Ops.IS_NOT_NULL, left);\n    }   \n","new_comment_raw":"Create a left is not null expression","old_comment_raw":"Create a left is not null expression","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":21},{"new_code_raw":"public Object getCache(PGraphics renderer) { return g.getCache(renderer); }","old_code_raw":"  public PMetadata getCache(PGraphics renderer) {\n    return g.getCache(renderer);\n  }\n","new_comment_raw":"Get cache storage data for the specified renderer.","old_comment_raw":"Get cache storage data for the specified renderer.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":16},{"new_code_raw":"@Override public String toString() { return \"[\" + name + \" \" + state + \"]\"; }","old_code_raw":"\t@Override\n\tpublic String toString() {\n\t\treturn \"[\" + name + \" \" + state + \"\/stats=\" + getStatProcessor().getType() + \"]\";\n\t}\n","new_comment_raw":"Returns name and state of the Simon as a human readable string.","old_comment_raw":"Returns name, state and stats of the Simon as a human readable string.","label":1,"pre_label":0,"AST_level":8,"line_counts":6,"new_code_token_num":25},{"new_code_raw":"public AsyncFile getBinary() { return binary; }","old_code_raw":"  public byte[] getBinary() {\n    return binary;\n  }\n","new_comment_raw":"Get binary","old_comment_raw":"Get binary","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"public long getContentDuration() { return mBundle.getLong(KEY_CONTENT_DURATION, -1); }","old_code_raw":"    public double getContentDuration() {\n        return mBundle.getDouble(KEY_CONTENT_DURATION, -1);\n    }\n","new_comment_raw":"Gets the total duration of the content to be played as a long integer number of milliseconds.","old_comment_raw":"Gets the total duration of the content to be played as a floating point number of seconds.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":17},{"new_code_raw":"public Configuration addCacheableFile(String xmlFile) throws MappingException { metadataSources.addCacheableFile( xmlFile ); return this; }","old_code_raw":"\tpublic Configuration addCacheableFile(String xmlFile) throws MappingException {\n\t\treturn addCacheableFile( new File( xmlFile ) );\n\t}\n","new_comment_raw":"Add a cacheable mapping file.","old_comment_raw":"Add a cacheable mapping file.","label":0,"pre_label":1,"AST_level":5,"line_counts":5,"new_code_token_num":20},{"new_code_raw":"public Observable<Integer> observeWifiSignalLevel(final Context context, final int numLevels) { final WifiManager wifiManager = (WifiManager) context.getSystemService(Context.WIFI_SERVICE); final IntentFilter filter = new IntentFilter(); filter.addAction(WifiManager.RSSI_CHANGED_ACTION); return Observable.create(new Observable.OnSubscribe<Integer>() { @Override public void call(final Subscriber<? super Integer> subscriber) { final BroadcastReceiver receiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { final int rssi = wifiManager.getConnectionInfo().getRssi(); final int level = WifiManager.calculateSignalLevel(rssi, numLevels); subscriber.onNext(level); } }; context.registerReceiver(receiver, filter); subscriber.add(unsubscribeInUiThread(new Action0() { @Override public void call() { context.unregisterReceiver(receiver); } })); } }).defaultIfEmpty(0); }","old_code_raw":"  public Observable<Integer> observeWifiSignalLevel(final Context context, final int numLevels) {\n    final WifiManager wifiManager = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);\n\n    final IntentFilter filter = new IntentFilter();\n    filter.addAction(WifiManager.RSSI_CHANGED_ACTION);\n\n    return Observable.create(new Observable.OnSubscribe<Integer>() {\n\n      @Override\n      public void call(final Subscriber<? super Integer> subscriber) {\n        final BroadcastReceiver receiver = new BroadcastReceiver() {\n          @Override\n          public void onReceive(Context context, Intent intent) {\n            int level = WifiManager.calculateSignalLevel(wifiManager.getConnectionInfo().getRssi(), numLevels);\n            subscriber.onNext(level);\n          }\n        };\n\n        context.registerReceiver(receiver, filter);\n\n        subscriber.add(unsubscribeInUiThread(new Action0() {\n          @Override\n          public void call() {\n            context.unregisterReceiver(receiver);\n          }\n        }));\n      }\n    }).defaultIfEmpty(0);\n  }\n","new_comment_raw":"Observes WiFi signal level.","old_comment_raw":"Observe WiFi signal level.","label":1,"pre_label":0,"AST_level":14,"line_counts":28,"new_code_token_num":165},{"new_code_raw":"protected ComponentTemplate getMetaData( final Object entry ) { return (ComponentTemplate)entry; }","old_code_raw":"    protected ComponentMetaData getMetaData( final Object entry )\n    {\n        return (ComponentMetaData)entry;\n    }\n","new_comment_raw":"Return the ComponentTemplate for specified component entry.","old_comment_raw":"Return the org.jcontainer.loom.components.util.metadata.ComponentMetaData for specified component entry.","label":1,"pre_label":0,"AST_level":5,"line_counts":6,"new_code_token_num":16},{"new_code_raw":"public static DateTimeFormatter basicTime() { return Constants.bt; }","old_code_raw":"    public static DateTimeFormatter basicTime() {\n        if (bt == null) {\n            bt = new DateTimeFormatterBuilder()\n                .appendFixedDecimal(DateTimeFieldType.hourOfDay(), 2)\n                .appendFixedDecimal(DateTimeFieldType.minuteOfHour(), 2)\n                .appendFixedDecimal(DateTimeFieldType.secondOfMinute(), 2)\n                .appendLiteral('.')\n                .appendFractionOfSecond(3, 9)\n                .appendTimeZoneOffset(\"Z\", false, 2, 2)\n                .toFormatter();\n        }\n        return bt;\n    }\n","new_comment_raw":"Returns a basic formatter for a two digit hour of day, two digit minute of hour, two digit second of minute, three digit millis, and time zone offset (HHmmss.SSSZ).","old_comment_raw":"Returns a basic formatter for a two digit hour of day, two digit minute of hour, two digit second of minute, three digit millis, and time zone offset (HHmmss.SSSZ).","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":12},{"new_code_raw":"public <T> int querySimpleList(Class<T> c, String sqlCmd, Connection conn, Collection<T> result) { \/\/ Check status if (checkOpen()==false) return -1; \/\/ Start query ResultSet rs = null; try { \/\/ Log performance long start = System.currentTimeMillis(); if (log.isInfoEnabled()) log.info(\"executing: \" + sqlCmd); \/\/ Get the next Value rs = driver.executeQuery(sqlCmd, null, false, conn); if (rs == null) { \/\/ Error error(driver); return -1; } \/\/ Check Result int count=0; while (rs.next()) { T item = ObjectUtils.convert(c, rs.getObject(1)); result.add(item); count++; } \/\/ No Value if (log.isInfoEnabled()) log.info(\"querySimpleList retured \"+String.valueOf(count)+\" items. Query completed in \" + String.valueOf(System.currentTimeMillis() - start) + \" ms\"); clearError(); return count; } catch (ClassCastException e) { log.error(\"querySingleValue cast exception: \", e); error(Errors.Exception, e); return -1; } catch (SQLException e) { log.error(\"querySimpleList exception: \", e); error(DBErrors.QueryFailed, e); return -1; } finally { \/\/ Cleanup closeResultSet(rs); } }","old_code_raw":"    public <T> List<T> querySimpleList(Class<T> c, String sqlCmd, Connection conn)\n    {   \/\/ Execute the  Statement\n        if (checkOpen()==false)\n            return null;\n        \/\/ Debug\n        ResultSet rs = null;\n        try\n        {\t\/\/ Check Open\n            if (checkOpen()==false)\n                return null;\n            \/\/ Debug\n            long start = System.currentTimeMillis();\n            if (log.isInfoEnabled())\n                log.info(\"executing: \" + sqlCmd);\n            \/\/ Get the next Value\n            rs = driver.executeQuery(sqlCmd, null, false, conn);\n            if (rs == null)\n            { \/\/ Error\n                error(driver);\n                return null;\n            }\n            \/\/ Check Result\n            List<T> result = new ArrayList<T>();\n            while (rs.next())\n            {\n                T item = ObjectUtils.convert(c, rs.getObject(1));\n                result.add(item);\n            }\n            \/\/ No Value\n            if (log.isInfoEnabled())\n                log.info(\"querySimpleList retured \"+String.valueOf(result.size())+\" items. Query completed in \" + String.valueOf(System.currentTimeMillis() - start) + \" ms\");\n            clearError();\n            return result;\n        } catch (ClassCastException e) \n        {   \n            log.error(\"querySingleValue cast exception: \", e);\n            error(Errors.Exception, e);\n            return null;\n        } catch (SQLException e) \n        {\n            log.error(\"querySimpleList exception: \", e);\n            error(DBErrors.QueryFailed, e);\n            return null;\n        } finally\n        { \/\/ Cleanup\n            closeResultSet(rs);\n        }\n    }\n","new_comment_raw":"Adds the first column of a query result to a collection.","old_comment_raw":"Returns a one dimensional array from an sql query.","label":1,"pre_label":0,"AST_level":12,"line_counts":48,"new_code_token_num":284},{"new_code_raw":"public InstantConverter removeInstantConverter(InstantConverter converter) throws SecurityException { checkAlterInstantConverters(); if (converter == null) { return null; } InstantConverter[] removed = new InstantConverter[1]; iInstantConverters = iInstantConverters.remove(converter, removed); return removed[0]; }","old_code_raw":"    public InstantConverter removeInstantConverter(int index) throws SecurityException {\n        checkAlterInstantConverters();\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(index, removed);\n        return removed[0];\n    }\n","new_comment_raw":"Removes a converter from the set of converters.","old_comment_raw":"Removes a converter from the set of converters, by index.","label":1,"pre_label":0,"AST_level":6,"line_counts":12,"new_code_token_num":50},{"new_code_raw":"public static Schema getKeyWriterSchema(Configuration conf) { String json = conf.get(CONF_KEY_WRITER_SCHEMA); return null == json ? null : new Schema.Parser().parse(json); }","old_code_raw":"  public static Schema getKeyWriterSchema(Configuration conf) {\n    String json = conf.get(CONF_KEY_WRITER_SCHEMA);\n    return null == json ? null : Schema.parse(json);\n  }\n","new_comment_raw":"Gets the writer schema of the AvroKey datum that is being serialized\/deserialized.","old_comment_raw":"Gets the writer schema of the AvroKey datum that is being serialized\/deserialized.","label":0,"pre_label":1,"AST_level":7,"line_counts":5,"new_code_token_num":34},{"new_code_raw":"public Object get(long timeout, String key) throws TimeoutException { SynchronizationObject<CachedData[]> sync=setupGet(key); waitForNotNull(timeout, sync); CachedData[] rvContainer=sync.get(); assert rvContainer.length == 1; Object rv=null; if(rvContainer[0] != null) { rv=transcoder.decode(rvContainer[0]); } return rv; }","old_code_raw":"\tpublic Map<String, Object> get(String... keys) {\n\t\tfinal Map<String, Object> rv=new ConcurrentHashMap<String, Object>();\n\t\tfinal AtomicInteger requests=new AtomicInteger();\n\t\tfinal SynchronizationObject<AtomicInteger> sync\n\t\t\t=new SynchronizationObject<AtomicInteger>(requests);\n\t\tGetOperation.Callback cb=new GetOperation.Callback() {\n\t\t\t\tpublic void getComplete() {\n\t\t\t\t\trequests.decrementAndGet();\n\t\t\t\t\tsync.set(requests);\n\t\t\t\t}\n\t\t\t\tpublic void gotData(String k, int flags, byte[] data) {\n\t\t\t\t\trv.put(k, transcoder.decode(new CachedData(flags, data)));\n\t\t\t\t}\n\t\t};\n\t\t\/\/ Break the gets down into groups by key\n\t\tMap<Integer, Collection<String>> chunks\n\t\t\t=new HashMap<Integer, Collection<String>>();\n\t\tfor(String key : keys) {\n\t\t\tint which=getServerForKey(key);\n\t\t\tCollection<String> ks=chunks.get(which);\n\t\t\tif(ks == null) {\n\t\t\t\tks=new ArrayList<String>();\n\t\t\t\tchunks.put(which, ks);\n\t\t\t}\n\t\t\tks.add(key);\n\t\t}\n\t\tfor(Map.Entry<Integer, Collection<String>> me : chunks.entrySet()) {\n\t\t\trequests.incrementAndGet();\n\t\t\taddOp(me.getKey(), new GetOperation(me.getValue(), cb));\n\t\t}\n\t\ttry {\n\t\t\tsync.waitUntilTrue(\n\t\t\t\t\tnew SynchronizationObject.Predicate<AtomicInteger>() {\n\t\t\t\t\t\tpublic boolean evaluate(AtomicInteger val) {\n\t\t\t\t\t\t\treturn val.get() == 0;\n\t\t\t\t\t\t}},\n\t\t\t\t\tLong.MAX_VALUE, TimeUnit.SECONDS);\n\t\t} catch (InterruptedException e) {\n\t\t\tthrow new RuntimeException(\"Interrupted waiting for results\", e);\n\t\t} catch (TimeoutException e) {\n\t\t\tthrow new RuntimeException(\"Timed out waiting forever\", e);\n\t\t}\n\t\treturn rv;\n\t}\n","new_comment_raw":"Get with a single key.","old_comment_raw":"Get the values for multiple keys from the cache.","label":1,"pre_label":0,"AST_level":10,"line_counts":13,"new_code_token_num":73},{"new_code_raw":"public String toModelName(final String name) { String result = camelize(sanitizeName(name)); if (!StringUtils.isEmpty(modelNamePrefix)) { result = modelNamePrefix + \"_\" + result; } \/\/ model name cannot use reserved keyword, e.g. return if (isReservedWord(name)) { String modelName = \"Model_\" + result; LOGGER.warn(name + \" (reserved word) cannot be used as model name. Renamed to \" + modelName); return modelName; } \/\/ model name starts with number if (result.matches(\"^\\\\d.*\")) { String modelName = \"Model_\" + result; \/\/ e.g. 200Response => Model_200Response (after camelize) LOGGER.warn(name + \" (model name starts with number) cannot be used as model name. Renamed to \" + modelName); return modelName; } if (languageSpecificPrimitives.contains(result)) { String modelName = \"Model_\" + result; LOGGER.warn(name + \" (model name matches existing language type) cannot be used as a model name. Renamed to \" + modelName); return modelName; } if (!StringUtils.isEmpty(modelNameSuffix)) { result = result + \"_\" + modelNameSuffix; } return result; }","old_code_raw":"    public String toModelName(final String name) {\n        String result = super.toModelName(name);\n        if (result.matches(\"^\\\\d.*\") || result.startsWith(\"_\")) {\n            result = \"Model_\" + result;\n        }\n        return result.replaceAll(\"[\\\\.-]\", \"_\").replaceAll(\"__+\", \"_\");\n    }\n","new_comment_raw":"Output the proper model name (capitalized).","old_comment_raw":"Output the proper model name (capitalized).","label":0,"pre_label":1,"AST_level":9,"line_counts":34,"new_code_token_num":237},{"new_code_raw":"public double getBalance(World world) { if (!Config.multiWorld) return getBalance(CurrencyHandler.getCurrency(Config.currencyDefault, true)); return getBalance(CurrencyHandler.getCurrency(Config.currencyDefault, true),world); }","old_code_raw":"\tpublic double getBalance()\r\n\t{\r\n\t\treturn balance;\r\n\t}\r\n","new_comment_raw":"Get the default balance in the specific world","old_comment_raw":"Get the player balance.","label":1,"pre_label":0,"AST_level":7,"line_counts":8,"new_code_token_num":43},{"new_code_raw":"private boolean propertyHasBreakingCharacters(String str) { final String regex = \"^.*[+*:;,.()-]+.*$\"; final Pattern pattern = Pattern.compile(regex); final Matcher matcher = pattern.matcher(str); return matcher.matches(); }","old_code_raw":"    private boolean propertyHasBreakingCharacters(String str) {\n        final String regex = \"^.*[+*:;,.()-]+.*$\";\n        final Pattern pattern = Pattern.compile(regex);\n        final Matcher matcher = pattern.matcher(str);\n        boolean matches = matcher.matches();\n        return matches;\n    }\n","new_comment_raw":"Checks whether property names have breaking characters like ':', '-'.","old_comment_raw":"Checks whether property names have breaking characters like ':', '-'.","label":0,"pre_label":1,"AST_level":6,"line_counts":7,"new_code_token_num":54},{"new_code_raw":"public Reader getReader() { debug(\"\\nContents: \" + this.contentsBuffer.toString()); return new StringReader(this.contentsBuffer.toString()); }","old_code_raw":"    public Reader getReader() {\n        debug(\"\\nContents: \" + contentsBuffer.toString());\n\n        return new StringReader(contentsBuffer.toString());\n    }\n","new_comment_raw":"Obtain the reader","old_comment_raw":"DOCUMENT ME!","label":1,"pre_label":0,"AST_level":7,"line_counts":7,"new_code_token_num":33},{"new_code_raw":"private Symbol generate(Resolver.Action action, Map<Object, Symbol> seen) throws IOException { if (action instanceof Resolver.DoNothing) { return simpleGen(action.writer, seen); } else if (action instanceof Resolver.ErrorAction) { return Symbol.error(action.toString()); } else if (action instanceof Resolver.Skip) { return Symbol.skipAction(simpleGen(action.writer, seen)); } else if (action instanceof Resolver.Promote) { return Symbol.resolve(simpleGen(action.writer, seen), simpleGen(action.reader, seen)); } else if (action instanceof Resolver.ReaderUnion) { Resolver.ReaderUnion ru = (Resolver.ReaderUnion) action; Symbol s = generate(ru.actualAction, seen); return Symbol.seq(Symbol.unionAdjustAction(ru.firstMatch, s), Symbol.UNION); } else if (action.writer.getType() == Schema.Type.ARRAY) { Symbol es = generate(((Resolver.Container) action).elementAction, seen); return Symbol.seq(Symbol.repeat(Symbol.ARRAY_END, es), Symbol.ARRAY_START); } else if (action.writer.getType() == Schema.Type.MAP) { Symbol es = generate(((Resolver.Container) action).elementAction, seen); return Symbol.seq(Symbol.repeat(Symbol.MAP_END, es, Symbol.STRING), Symbol.MAP_START); } else if (action.writer.getType() == Schema.Type.UNION) { if (((Resolver.WriterUnion) action).unionEquiv) return simpleGen(action.writer, seen); Resolver.Action[] branches = ((Resolver.WriterUnion) action).actions; Symbol[] symbols = new Symbol[branches.length]; String[] labels = new String[branches.length]; int i = 0; for (Resolver.Action branch : branches) { symbols[i] = generate(branch, seen); labels[i] = action.writer.getTypes().get(i).getFullName(); i++; } return Symbol.seq(Symbol.alt(symbols, labels), Symbol.WRITER_UNION_ACTION); } else if (action instanceof Resolver.EnumAdjust) { Resolver.EnumAdjust e = (Resolver.EnumAdjust) action; Object[] adjs = new Object[e.adjustments.length]; for (int i = 0; i < adjs.length; i++) adjs[i] = (0 <= e.adjustments[i] ? new Integer(e.adjustments[i]) : \"No match for \" + e.writer.getEnumSymbols().get(i)); return Symbol.seq(Symbol.enumAdjustAction(e.reader.getEnumSymbols().size(), adjs), Symbol.ENUM); } else if (action instanceof Resolver.RecordAdjust) { Symbol result = seen.get(action); if (result == null) { final Resolver.RecordAdjust ra = (Resolver.RecordAdjust) action; int defaultCount = ra.readerOrder.length - ra.firstDefault; int count = 1 + ra.fieldActions.length + 3 * defaultCount; Symbol[] production = new Symbol[count]; result = Symbol.seq(production); seen.put(action, result); production[--count] = Symbol.fieldOrderAction(ra.readerOrder); for (Resolver.Action wfa : ra.fieldActions) production[--count] = generate(wfa, seen); for (int i = ra.firstDefault; i < ra.readerOrder.length; i++) { Schema.Field rf = ra.readerOrder[i]; byte[] bb = getBinary(rf.schema(), Accessor.defaultValue(rf)); production[--count] = Symbol.defaultStartAction(bb); production[--count] = simpleGen(rf.schema(), seen); production[--count] = Symbol.DEFAULT_END_ACTION; } } return result; } throw new IllegalArgumentException(\"Unrecognized Resolver.Action: \" + action); }","old_code_raw":"  private Symbol generate(Resolver.Action action, Map<Object, Symbol> seen) throws IOException {\n    if (action instanceof Resolver.DoNothing) {\n      return simpleGen(action.writer, seen);\n\n    } else if (action instanceof Resolver.ErrorAction) {\n      return Symbol.error(action.toString());\n\n    } else if (action instanceof Resolver.Skip) {\n      return Symbol.skipAction(simpleGen(action.writer, seen));\n\n    } else if (action instanceof Resolver.Promote) {\n      return Symbol.resolve(simpleGen(action.writer, seen), simpleGen(action.reader, seen));\n\n    } else if (action.writer.getType() == Schema.Type.ARRAY) {\n      Symbol es = generate(((Resolver.Container) action).elementAction, seen);\n      return Symbol.seq(Symbol.repeat(Symbol.ARRAY_END, es), Symbol.ARRAY_START);\n\n    } else if (action.writer.getType() == Schema.Type.MAP) {\n      Symbol es = generate(((Resolver.Container) action).elementAction, seen);\n      return Symbol.seq(Symbol.repeat(Symbol.MAP_END, es, Symbol.STRING), Symbol.MAP_START);\n\n    } else if (action.writer.getType() == Schema.Type.UNION) {\n      if (((Resolver.WriterUnion) action).unionEquiv)\n        return simpleGen(action.writer, seen);\n      Resolver.Action[] branches = ((Resolver.WriterUnion) action).actions;\n      Symbol[] symbols = new Symbol[branches.length];\n      String[] labels = new String[branches.length];\n      int i = 0;\n      for (Resolver.Action branch : branches) {\n        symbols[i] = generate(branch, seen);\n        labels[i] = action.writer.getTypes().get(i).getFullName();\n        i++;\n      }\n      return Symbol.seq(Symbol.alt(symbols, labels), Symbol.WRITER_UNION_ACTION);\n\n    } else if (action instanceof Resolver.ReaderUnion) {\n      Resolver.ReaderUnion ru = (Resolver.ReaderUnion) action;\n      Symbol s = generate(ru.actualAction, seen);\n      return Symbol.seq(Symbol.unionAdjustAction(ru.firstMatch, s), Symbol.UNION);\n\n    } else if (action instanceof Resolver.EnumAdjust) {\n      Resolver.EnumAdjust e = (Resolver.EnumAdjust) action;\n      Object[] adjs = new Object[e.adjustments.length];\n      for (int i = 0; i < adjs.length; i++)\n        adjs[i] = (0 <= e.adjustments[i] ? new Integer(e.adjustments[i])\n            : \"No match for \" + e.writer.getEnumSymbols().get(i));\n      return Symbol.seq(Symbol.enumAdjustAction(e.reader.getEnumSymbols().size(), adjs), Symbol.ENUM);\n\n    } else if (action instanceof Resolver.RecordAdjust) {\n      Symbol result = seen.get(action);\n      if (result == null) {\n        final Resolver.RecordAdjust ra = (Resolver.RecordAdjust) action;\n        int defaultCount = ra.readerOrder.length - ra.firstDefault;\n        int count = 1 + ra.fieldActions.length + 3 * defaultCount;\n        Symbol[] production = new Symbol[count];\n        result = Symbol.seq(production);\n        seen.put(action, result);\n        production[--count] = Symbol.fieldOrderAction(ra.readerOrder);\n        for (Resolver.Action wfa : ra.fieldActions)\n          production[--count] = generate(wfa, seen);\n        for (int i = ra.firstDefault; i < ra.readerOrder.length; i++) {\n          Schema.Field rf = ra.readerOrder[i];\n          byte[] bb = getBinary(rf.schema(), Accessor.defaultValue(rf));\n          production[--count] = Symbol.defaultStartAction(bb);\n          production[--count] = simpleGen(rf.schema(), seen);\n          production[--count] = Symbol.DEFAULT_END_ACTION;\n        }\n      }\n      return result;\n    }\n\n    throw new IllegalArgumentException(\"Unrecognized Resolver.Action: \" + action);\n  }\n","new_comment_raw":"Takes a  Resolver.Action for resolving two schemas and returns the start symbol for a grammar that implements that resolution.","old_comment_raw":"Takes a Resolver.Action for resolving two schemas and returns the start symbol for a grammar that implements that resolution.","label":0,"pre_label":1,"AST_level":22,"line_counts":73,"new_code_token_num":707},{"new_code_raw":"public Remote getPort(QName portName, Class proxyInterface) throws ServiceException { \/\/ First, try to find a generated stub. If that \/\/ returns null, then find a dynamic stub. Remote stub = getGeneratedStub(portName, proxyInterface); return stub != null ? stub : getPort(null, portName, proxyInterface); }","old_code_raw":"    public Remote getPort(QName portName, Class proxyInterface)\n                           throws ServiceException {\n        return getPort(null, portName, proxyInterface);\n    }\n","new_comment_raw":"Return either an instance of a generated stub, if it can be found, or a dynamic proxy for the given proxy interface.","old_comment_raw":"Not implemented yet","label":1,"pre_label":0,"AST_level":6,"line_counts":9,"new_code_token_num":61},{"new_code_raw":"public static <T> Stream<T> from( T object ) { return new Stream<T>( new RepeatingObjectIterator<T>( object ), null ) ; }","old_code_raw":"    @SuppressWarnings(\"unchecked\")\n    public static <T> Stream<T> from( T[] array ) {\n        return new Stream<T>( primitiveArrayToList( array ).iterator(), null ) ;\n    }\n","new_comment_raw":"Construct a  Stream that for every element, returns  object.","old_comment_raw":"Construct a Stream that iterates every Object in an array.","label":1,"pre_label":0,"AST_level":8,"line_counts":5,"new_code_token_num":27},{"new_code_raw":"protected static CodecFactory getCompressionCodec(TaskAttemptContext context) { if (FileOutputFormat.getCompressOutput(context)) { \/\/ Default to deflate compression. String outputCodec = context.getConfiguration() .get(AvroJob.CONF_OUTPUT_CODEC, DataFileConstants.DEFLATE_CODEC); if (DataFileConstants.DEFLATE_CODEC.equals(outputCodec)) { int compressionLevel = context.getConfiguration().getInt( org.apache.avro.mapred.AvroOutputFormat.DEFLATE_LEVEL_KEY, org.apache.avro.mapred.AvroOutputFormat.DEFAULT_DEFLATE_LEVEL); return CodecFactory.deflateCodec(compressionLevel); } else { return CodecFactory.fromString(outputCodec); } } \/\/ No compression. return CodecFactory.nullCodec(); }","old_code_raw":"  protected static CodecFactory getCompressionCodec(TaskAttemptContext context) {\n    if (FileOutputFormat.getCompressOutput(context)) {\n      \/\/ Deflate compression.\n      int compressionLevel = context.getConfiguration().getInt(\n          org.apache.avro.mapred.AvroOutputFormat.DEFLATE_LEVEL_KEY,\n          org.apache.avro.mapred.AvroOutputFormat.DEFAULT_DEFLATE_LEVEL);\n      return CodecFactory.deflateCodec(compressionLevel);\n    }\n\n    \/\/ No compression.\n    return CodecFactory.nullCodec();\n  }\n","new_comment_raw":"Gets the configured compression codec from the task context.","old_comment_raw":"Gets the configured compression codec from the task context.","label":0,"pre_label":1,"AST_level":11,"line_counts":19,"new_code_token_num":102},{"new_code_raw":"public PhysicalPlan getPlan(SqlNode sqlNode) throws ValidationException, RelConversionException, IOException { SqlDropTable dropTableNode = ((SqlDropTable) sqlNode); SqlIdentifier tableIdentifier = dropTableNode.getTableIdentifier(); SchemaPlus defaultSchema = config.getConverter().getDefaultSchema(); AbstractSchema drillSchema = null; if (tableIdentifier != null) { drillSchema = SchemaUtilites.resolveToMutableDrillSchema(defaultSchema, dropTableNode.getSchema()); } String tableName = dropTableNode.getName(); if (drillSchema == null) { throw UserException.validationError() .message(\"Invalid table_name [%s]\", tableName) .build(logger); } if (dropTableNode.checkTableExistence()) { final Table tableToDrop = SqlHandlerUtil.getTableFromSchema(drillSchema, tableName); if (tableToDrop == null || tableToDrop.getJdbcTableType() != Schema.TableType.TABLE) { return DirectPlan.createDirectPlan(context, true, String.format(\"Table [%s] not found\", tableName)); } } drillSchema.dropTable(tableName); return DirectPlan.createDirectPlan(context, true, String.format(\"Table [%s] %s\", tableName, \"dropped\")); }","old_code_raw":"  public PhysicalPlan getPlan(SqlNode sqlNode) throws ValidationException, RelConversionException, IOException {\n\n    SqlDropTable dropTableNode = ((SqlDropTable) sqlNode);\n    SqlIdentifier tableIdentifier = dropTableNode.getTableIdentifier();\n\n    SchemaPlus defaultSchema = config.getConverter().getDefaultSchema();\n    AbstractSchema drillSchema = null;\n\n    if (tableIdentifier != null) {\n      drillSchema = SchemaUtilites.resolveToMutableDrillSchema(defaultSchema, dropTableNode.getSchema());\n    }\n\n    String tableName = ((SqlDropTable) sqlNode).getName();\n    if (drillSchema == null) {\n      throw UserException.validationError()\n          .message(\"Invalid table_name [%s]\", tableName)\n          .build(logger);\n    }\n\n    drillSchema.dropTable(tableName);\n\n    return DirectPlan.createDirectPlan(context, true,\n        String.format(\"Table [%s] %s\", tableName, \"dropped\"));\n  }\n","new_comment_raw":"Function resolves the schema and invokes the drop method (while IF EXISTS statement is used function invokes the drop method only if table exists).","old_comment_raw":"Function resolves the schema and invokes the drop method.","label":1,"pre_label":0,"AST_level":10,"line_counts":33,"new_code_token_num":199},{"new_code_raw":"public static void main(String[] args) throws IOException, ClassNotFoundException { RedwoodConfiguration.standard().apply(); \/\/ Disable SLF4J crap. ArgumentParser.fillOptions(KBPStatisticalExtractor.class, args); \/\/ Fill command-line options \/\/ Load the test (or dev) data forceTrack(\"Test data\"); List<Pair<KBPInput, String>> testExamples = KBPRelationExtractor.readDataset(TEST_FILE); log.info(\"Read \" + testExamples.size() + \" examples\"); endTrack(\"Test data\"); \/\/ If we can't find an existing model, train one if (!IOUtils.existsInClasspathOrFileSystem(MODEL_FILE)) { forceTrack(\"Training data\"); List<Pair<KBPInput, String>> trainExamples = KBPRelationExtractor.readDataset(TRAIN_FILE); log.info(\"Read \" + trainExamples.size() + \" examples\"); log.info(\"\" + trainExamples.stream().map(Pair::second).filter(NO_RELATION::equals).count() + \" are \" + NO_RELATION); endTrack(\"Training data\"); \/\/ Featurize + create the dataset forceTrack(\"Creating dataset\"); RVFDataset<String, String> dataset = new RVFDataset<>(); final AtomicInteger i = new AtomicInteger(0); long beginTime = System.currentTimeMillis(); trainExamples.stream().parallel().forEach(example -> { if (i.incrementAndGet() % 1000 == 0) { log.info(\"[\" + Redwood.formatTimeDifference(System.currentTimeMillis() - beginTime) + \"] Featurized \" + i.get() + \" \/ \" + trainExamples.size() + \" examples\"); } Counter<String> features = features(example.first); \/\/ This takes a while per example synchronized (dataset) { dataset.add(new RVFDatum<>(features, example.second)); } }); trainExamples.clear(); \/\/ Free up some memory endTrack(\"Creating dataset\"); \/\/ Train the classifier log.info(\"Training classifier:\"); Classifier<String, String> classifier = trainMultinomialClassifier(dataset, FEATURE_THRESHOLD, SIGMA); dataset.clear(); \/\/ Free up some memory \/\/ Save the classifier IOUtils.writeObjectToFile(new KBPStatisticalExtractor(classifier), MODEL_FILE); } \/\/ Read either a newly-trained or pre-trained model Object model = IOUtils.readObjectFromURLOrClasspathOrFileSystem(MODEL_FILE); KBPStatisticalExtractor classifier; if (model instanceof Classifier) { \/\/noinspection unchecked classifier = new KBPStatisticalExtractor((Classifier<String, String>) model); } else { classifier = ((KBPStatisticalExtractor) model); } \/\/ Evaluate the model classifier.computeAccuracy(testExamples.stream(), PREDICTIONS.map(x -> { try { return \"stdout\".equalsIgnoreCase(x) ? System.out : new PrintStream(new FileOutputStream(x)); } catch (IOException e) { throw new RuntimeIOException(e); } })); }","old_code_raw":"  public static void main(String[] args) throws IOException, ClassNotFoundException {\n    RedwoodConfiguration.standard().apply();  \/\/ Disable SLF4J crap.\n    ArgumentParser.fillOptions(KBPStatisticalExtractor.class, args);  \/\/ Fill command-line options\n\n    \/\/ Load the test (or dev) data\n    forceTrack(\"Test data\");\n    List<Pair<KBPInput, String>> testExamples = KBPRelationExtractor.readDataset(TEST_FILE);\n    log.info(\"Read \" + testExamples.size() + \" examples\");\n    endTrack(\"Test data\");\n\n    \/\/ If we can't find an existing model, train one\n    if (!IOUtils.existsInClasspathOrFileSystem(MODEL_FILE)) {\n      forceTrack(\"Training data\");\n      List<Pair<KBPInput, String>> trainExamples = KBPRelationExtractor.readDataset(TRAIN_FILE);\n      log.info(\"Read \" + trainExamples.size() + \" examples\");\n      log.info(\"\" + trainExamples.stream().map(Pair::second).filter(NO_RELATION::equals).count() + \" are \" + NO_RELATION);\n      endTrack(\"Training data\");\n\n      \/\/ Featurize + create the dataset\n      forceTrack(\"Creating dataset\");\n      RVFDataset<String, String> dataset = new RVFDataset<>();\n      final AtomicInteger i = new AtomicInteger(0);\n      long beginTime = System.currentTimeMillis();\n      trainExamples.stream().parallel().forEach(example -> {\n        if (i.incrementAndGet() % 1000 == 0) {\n          log.info(\"[\" + Redwood.formatTimeDifference(System.currentTimeMillis() - beginTime) +\n              \"] Featurized \" + i.get() + \" \/ \" + trainExamples.size() + \" examples\");\n        }\n        Counter<String> features = features(example.first);  \/\/ This takes a while per example\n        synchronized (dataset) {\n          dataset.add(new RVFDatum<>(features, example.second));\n        }\n      });\n      trainExamples.clear();  \/\/ Free up some memory\n      endTrack(\"Creating dataset\");\n\n      \/\/ Train the classifier\n      log.info(\"Training classifier:\");\n      Classifier<String, String> classifier = trainMultinomialClassifier(dataset, FEATURE_THRESHOLD, SIGMA);\n      dataset.clear();  \/\/ Free up some memory\n\n      \/\/ Save the classifier\n      IOUtils.writeObjectToFile(new KBPStatisticalExtractor(classifier), MODEL_FILE);\n    }\n\n    \/\/ Read either a newly-trained or pre-trained model\n    Object model = IOUtils.readObjectFromURLOrClasspathOrFileSystem(MODEL_FILE);\n    KBPStatisticalExtractor classifier;\n    if (model instanceof Classifier) {\n      \/\/noinspection unchecked\n      classifier = new KBPStatisticalExtractor((Classifier<String, String>) model);\n    } else {\n      classifier = ((KBPStatisticalExtractor) model);\n    }\n\n    \/\/ Evaluate the model\n    forceTrack(\"Test accuracy\");\n    Accuracy accuracy = new Accuracy();\n    AtomicInteger testI = new AtomicInteger(0);\n    forceTrack(\"Featurizing\");\n    testExamples.stream().parallel().forEach( example -> {\n      Pair<String, Double> predicted = classifier.classify(example.first);\n      synchronized (accuracy) {\n        accuracy.predict(Collections.singleton(predicted.first), Collections.singleton(example.second));\n      }\n      if (testI.incrementAndGet() % 1000 == 0) {\n        log(\"[\" + testI.get() + \" \/ \" + testExamples.size() + \"]  \" + accuracy.toOneLineString());\n      }\n    });\n    endTrack(\"Featurizing\");\n    log(accuracy.toString());\n    endTrack(\"Test accuracy\");\n  }\n","new_comment_raw":"Score the given input, returning both the classification decision and the probability of that decision.","old_comment_raw":"Score the given input, returning both the classification decision and the probability of that decision.","label":0,"pre_label":1,"AST_level":21,"line_counts":65,"new_code_token_num":549},{"new_code_raw":"public char get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }","old_code_raw":"    public char get(WithAttributes attributes) {\r\n        return attributes.getAttributes().get(this);\r\n    }\r\n","new_comment_raw":"Extracts the attribute map from the specified  WithAttributes and returns the value of this attribute from the map.","old_comment_raw":"Analogous to #get(WithAttributes) except returning a primitive char.","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":19},{"new_code_raw":"private Type buildAttributeConverterTypeAdapter() { \/\/ todo : validate the number of columns present here? final Class entityAttributeJavaType = jpaAttributeConverterDefinition.getEntityAttributeType(); final Class databaseColumnJavaType = jpaAttributeConverterDefinition.getDatabaseColumnType(); \/\/ resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \/\/ For the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of \/\/ the AttributeConverter to resolve the corresponding descriptor. final JavaTypeDescriptor entityAttributeJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType ); \/\/ build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \/\/ Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer <-> String \/\/ conversions. This is the more complicated piece. First we need to determine the JDBC type code \/\/ corresponding to the AttributeConverter's declared \"databaseColumnJavaType\" (how we read that value out \/\/ of ResultSets). See JdbcTypeJavaClassMappings for details. Again, given example, this should return \/\/ VARCHAR\/CHAR final int jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType ); \/\/ find the standard SqlTypeDescriptor for that JDBC type code. final SqlTypeDescriptor sqlTypeDescriptor = SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode ); \/\/ find the JavaTypeDescriptor representing the \"intermediate database type representation\". Back to the \/\/ illustration, this should be the type descriptor for Strings final JavaTypeDescriptor intermediateJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType ); \/\/ and finally construct the adapter, which injects the AttributeConverter calls into the binding\/extraction \/\/ process... final SqlTypeDescriptor sqlTypeDescriptorAdapter = new AttributeConverterSqlTypeDescriptorAdapter( jpaAttributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptor, intermediateJavaTypeDescriptor ); \/\/ todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times. final String name = String.format( \"BasicType adapter for AttributeConverter<%s,%s>\", entityAttributeJavaType.getSimpleName(), databaseColumnJavaType.getSimpleName() ); return new AttributeConverterTypeAdapter( name, jpaAttributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptorAdapter, entityAttributeJavaTypeDescriptor ); }","old_code_raw":"\tprivate Type buildAttributeConverterTypeAdapter() {\n\t\t\/\/ todo : validate the number of columns present here?\n\n\t\tfinal Class entityAttributeJavaType = jpaAttributeConverterDefinition.getEntityAttributeType();\n\t\tfinal Class databaseColumnJavaType = jpaAttributeConverterDefinition.getDatabaseColumnType();\n\n\n\t\t\/\/ resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t\/\/ For the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of\n\t\t\/\/ the AttributeConverter to resolve the corresponding descriptor.\n\t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType );\n\n\n\t\t\/\/ build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t\/\/ Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer <-> String\n\t\t\/\/\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n\t\t\/\/\t\tcorresponding to the AttributeConverter's declared \"databaseColumnJavaType\" (how we read that value out\n\t\t\/\/ \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n\t\t\/\/ \t\tVARCHAR\/CHAR\n\t\tfinal int jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );\n\t\t\/\/ find the standard SqlTypeDescriptor for that JDBC type code.\n\t\tfinal SqlTypeDescriptor sqlTypeDescriptor = SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode );\n\t\t\/\/ find the JavaTypeDescriptor representing the \"intermediate database type representation\".  Back to the\n\t\t\/\/ \t\tillustration, this should be the type descriptor for Strings\n\t\tfinal JavaTypeDescriptor intermediateJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType );\n\t\t\/\/ and finally construct the adapter, which injects the AttributeConverter calls into the binding\/extraction\n\t\t\/\/ \t\tprocess...\n\t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter = new AttributeConverterSqlTypeDescriptorAdapter(\n\t\t\t\tjpaAttributeConverterDefinition.getAttributeConverter(),\n\t\t\t\tsqlTypeDescriptor,\n\t\t\t\tintermediateJavaTypeDescriptor\n\t\t);\n\n\t\t\/\/ todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n\n\t\tfinal String name = \"BasicType adapter for AttributeConverter<\" + entityAttributeJavaType + \",\" + databaseColumnJavaType + \">\";\n\t\treturn new AttributeConverterTypeAdapter( sqlTypeDescriptorAdapter, entityAttributeJavaTypeDescriptor, name );\n\t}\n","new_comment_raw":"Build a Hibernate Type that incorporates the JPA AttributeConverter.","old_comment_raw":"Build a Hibernate Type that incorporates the JPA AttributeConverter.","label":0,"pre_label":1,"AST_level":6,"line_counts":48,"new_code_token_num":326},{"new_code_raw":"private static int getMaxOrLimit(final RowSelection selection, final Dialect dialect) { final int firstRow = dialect.convertToFirstRowValue( getFirstRow( selection ) ); final int lastRow = selection.getMaxRows(); return dialect.useMaxForLimit() ? lastRow + firstRow : lastRow; }","old_code_raw":"\tprivate static int getMaxOrLimit(final RowSelection selection, final Dialect dialect) {\n\t\tfinal int firstRow = dialect.convertToFirstRowValue( getFirstRow( selection ) );\n\t\tfinal int lastRow = selection.getMaxRows().intValue();\n\t\tif ( dialect.useMaxForLimit() ) {\n\t\t\treturn lastRow + firstRow;\n\t\t}\n\t\telse {\n\t\t\treturn lastRow;\n\t\t}\n\t}\n","new_comment_raw":"Some dialect-specific LIMIT clauses require the maximum last row number (aka, first_row_number + total_row_count), while others require the maximum returned row count (the total maximum number of rows to return).","old_comment_raw":"Some dialect-specific LIMIT clauses require the maximum last row number (aka, first_row_number + total_row_count), while others require the maximum returned row count (the total maximum number of rows to return).","label":0,"pre_label":1,"AST_level":7,"line_counts":6,"new_code_token_num":47},{"new_code_raw":"private ServiceReference[] getInitialReferences(boolean trackAllServices, String className, String filterString) throws InvalidSyntaxException { if (trackAllServices) { return context.getAllServiceReferences(className, filterString); } return context.getServiceReferences(className, filterString); }","old_code_raw":"\tprivate ServiceReference[] getInitialReferences(boolean trackAllServices,\n\t\t\tString trackClass, String filterString)\n\t\t\tthrows InvalidSyntaxException {\n\t\tif (trackAllServices) {\n\t\t\treturn context.getAllServiceReferences(trackClass, filterString);\n\t\t}\n\t\telse {\n\t\t\treturn context.getServiceReferences(trackClass, filterString);\n\t\t}\n\t}\n","new_comment_raw":"Returns the list of initial ServiceReferences that will be tracked by this ServiceTracker.","old_comment_raw":"Returns the list of initial ServiceReference objects that will be tracked by this ServiceTracker object.","label":1,"pre_label":0,"AST_level":7,"line_counts":10,"new_code_token_num":43},{"new_code_raw":"public int toStatusCode(Throwable thrown) { if (thrown == null) { return SUCCESS; } else if (thrown instanceof InvalidCookieDomainException) { return INVALID_COOKIE_DOMAIN; } else if (thrown instanceof UnableToSetCookieException) { return UNABLE_TO_SET_COOKIE; } else if (thrown instanceof NoSuchWindowException) { return NO_SUCH_WINDOW; } else if (thrown instanceof InvalidSelectorException) { return INVALID_SELECTOR_ERROR; } else if (thrown instanceof NoSuchElementException) { return NO_SUCH_ELEMENT; } else if (thrown instanceof NoSuchFrameException) { return NO_SUCH_FRAME; } else if (thrown instanceof StaleElementReferenceException) { return STALE_ELEMENT_REFERENCE; } else if (thrown instanceof ElementNotVisibleException) { return ELEMENT_NOT_VISIBLE; } else if (thrown instanceof InvalidElementStateException) { return INVALID_ELEMENT_STATE; } else if (thrown instanceof XPathLookupException) { return XPATH_LOOKUP_ERROR; } else if (thrown instanceof TimeoutException) { return ASYNC_SCRIPT_TIMEOUT; } else if (thrown instanceof InvalidCoordinatesException) { return INVALID_ELEMENT_COORDINATES; } else if (thrown instanceof ImeNotAvailableException) { return IME_NOT_AVAILABLE; } else if (thrown instanceof ImeActivationFailedException) { return IME_ENGINE_ACTIVATION_FAILED; } else if (thrown instanceof NoAlertPresentException) { return NO_ALERT_PRESENT; } else if (thrown instanceof MoveTargetOutOfBoundsException) { return MOVE_TARGET_OUT_OF_BOUNDS; } else { return UNHANDLED_ERROR; } }","old_code_raw":"  public int toStatusCode(Throwable thrown) {\n    if (thrown == null) {\n      return SUCCESS;\n    } else if (thrown instanceof InvalidCookieDomainException) {\n      return INVALID_COOKIE_DOMAIN;\n    } else if (thrown instanceof UnableToSetCookieException) {\n      return UNABLE_TO_SET_COOKIE;\n    } else if (thrown instanceof NoSuchWindowException) {\n      return NO_SUCH_WINDOW;\n    } else if (thrown instanceof InvalidSelectorException) {\n      return INVALID_SELECTOR_ERROR;\n    } else if (thrown instanceof NoSuchElementException) {\n      return NO_SUCH_ELEMENT;\n    } else if (thrown instanceof NoSuchFrameException) {\n      return NO_SUCH_FRAME;\n    } else if (thrown instanceof StaleElementReferenceException) {\n      return STALE_ELEMENT_REFERENCE;\n    } else if (thrown instanceof ElementNotVisibleException) {\n      return ELEMENT_NOT_VISIBLE;\n    } else if (thrown instanceof InvalidElementStateException) {\n      return INVALID_ELEMENT_STATE;\n    } else if (thrown instanceof XPathLookupException) {\n      return XPATH_LOOKUP_ERROR;\n    } else if (thrown instanceof TimeoutException) {\n      return ASYNC_SCRIPT_TIMEOUT;\n    } else if (thrown instanceof InvalidCoordinatesException) {\n      return INVALID_ELEMENT_COORDINATES;\n    } else if (thrown instanceof ImeNotAvailableException) {\n      return IME_NOT_AVAILABLE;\n    } else if (thrown instanceof ImeActivationFailedException) {\n      return IME_ENGINE_ACTIVATION_FAILED;\n    } else if (thrown instanceof NoAlertPresentException) {\n      return NO_ALERT_PRESENT;\n    } else {\n      return UNHANDLED_ERROR;\n    }\n  }\n","new_comment_raw":"Converts a thrown error into the corresponding status code.","old_comment_raw":"Converts a thrown error into the corresponding status code.","label":0,"pre_label":1,"AST_level":22,"line_counts":40,"new_code_token_num":217},{"new_code_raw":"public EReference getComment_Replies() { return (EReference) commentEClass.getEStructuralFeatures().get(3); }","old_code_raw":"\tpublic EReference getComment_Replies() {\n\t\treturn (EReference) commentEClass.getEStructuralFeatures().get(4);\n\t}\n","new_comment_raw":"Returns the meta object for the reference list ' org.eclipse.mylyn.reviews.core.model.IComment#getReplies Replies'.","old_comment_raw":"Returns the meta object for the containment reference list ' org.eclipse.mylyn.reviews.core.model.IComment#getReplies Replies'.","label":1,"pre_label":0,"AST_level":7,"line_counts":5,"new_code_token_num":20},{"new_code_raw":"public Future<Map<String, Object>> asyncGetBulk(String... keys) { return asyncGetBulk(Arrays.asList(keys)); }","old_code_raw":"\tpublic Future<Map<String, Object>> asyncGetBulk(Collection<String> keys) {\n\t\treturn asyncGetBulk(keys, transcoder);\n\t}\n","new_comment_raw":"Varargs wrapper for asynchronous bulk gets.","old_comment_raw":"Asynchronously get a bunch of objects from the cache and decode them with the given transcoder.","label":1,"pre_label":0,"AST_level":7,"line_counts":5,"new_code_token_num":23},{"new_code_raw":"public <RX extends RxInvokerProvider> Client buildRx(String name, Class<RX> invokerType) { return build(name).register(invokerType); }","old_code_raw":"    public <RX extends RxInvoker> RxClient<RX> buildRx(String name, Class<RX> invokerType) {\n        return Rx.from(build(name), invokerType, executorService);\n    }\n","new_comment_raw":"Builds the  Client instance with a custom reactive client provider.","old_comment_raw":"Builds the RxClient instance.","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":26},{"new_code_raw":"public Set<Warning> getWarnings() { return Collections.unmodifiableSet(project.getWarnings(packageName)); }","old_code_raw":"    public Collection<Warning> getWarnings() {\n        return project.getWarnings(packageName);\n    }\n","new_comment_raw":"Returns all warnings for this package details view.","old_comment_raw":"Returns all the warnings in this package.","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":19},{"new_code_raw":"public String getResultKey() { return resultKey; }","old_code_raw":"    public String getResultKey() {\n        Field singleField = getSingleField();\n        if (singleField.getAlias() != null) {\n            return singleField.getAlias();\n        }\n        return singleField.getName();\n    }\n","new_comment_raw":"Returns the key of this MergedField for the overall result.","old_comment_raw":"Returns the key of this MergedField for the overall result.","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"@SuppressWarnings(\"unchecked\") protected Class[] getClassContext() { return VMStack.getClasses(-1, false); }","old_code_raw":"    @SuppressWarnings(\"unchecked\")\n    protected Class[] getClassContext() {\n        return Class.getStackClasses(-1, false);\n    }\n","new_comment_raw":"Returns an array containing one entry for each method in the current execution stack.","old_comment_raw":"Returns an array containing one entry for each method in the stack.","label":1,"pre_label":0,"AST_level":5,"line_counts":6,"new_code_token_num":26},{"new_code_raw":"public DurationType getDurationType(Object object) { return DurationType.getMillisType(); }","old_code_raw":"    public DurationType getDurationType(Object object) {\n        return DurationType.getAverageYearMonthType();\n    }\n","new_comment_raw":"Selects a suitable duration type for the given object.","old_comment_raw":"Selects a suitable duration type for the given object.","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":15},{"new_code_raw":"public static ImportMode getModeValue(String mode) { if (mode == null) return null; mode = mode.trim().toLowerCase(); if (mode.indexOf(',') == -1) { \/\/ only one keyword supplied if (\"insert\".equals(mode)) { return ImportMode.insert; } else if (\"update\".equals(mode)) { return ImportMode.update; } else { return null; } } else { List l = StringUtil.stringToList(mode, \",\"); String first = (String)l.get(0); String second = (String)l.get(1); if (\"insert\".equals(first) && \"update\".equals(second)) { return ImportMode.insertUpdate; } else if (\"update\".equals(first) && \"insert\".equals(second)) { return ImportMode.updateInsert; } else { return null; } } }","old_code_raw":"\tpublic static int getModeValue(String mode)\n\t{\n\t\tif (mode == null) return -1;\n\t\tmode = mode.trim().toLowerCase();\n\t\tif (mode.indexOf(',') == -1)\n\t\t{\n\t\t\t\/\/ only one keyword supplied\n\t\t\tif (\"insert\".equals(mode))\n\t\t\t{\n\t\t\t\treturn MODE_INSERT;\n\t\t\t}\n\t\t\telse if (\"update\".equals(mode))\n\t\t\t{\n\t\t\t\treturn MODE_UPDATE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tList l = StringUtil.stringToList(mode, \",\");\n\t\t\tString first = (String)l.get(0);\n\t\t\tString second = (String)l.get(1);\n\t\t\tif (\"insert\".equals(first) && \"update\".equals(second))\n\t\t\t{\n\t\t\t\treturn MODE_INSERT_UPDATE;\n\t\t\t}\n\t\t\telse if (\"update\".equals(first) && \"insert\".equals(second))\n\t\t\t{\n\t\t\t\treturn MODE_UPDATE_INSERT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t}\n","new_comment_raw":"Return the mode value based on keywords.","old_comment_raw":"Return the numeric mode value based on keywords.","label":1,"pre_label":0,"AST_level":10,"line_counts":43,"new_code_token_num":180},{"new_code_raw":"public TregexMatcher matcher(Tree t) { return matcher(t, t, null, new HashMap<String, Tree>(), new VariableStrings()); }","old_code_raw":"  public TregexMatcher matcher(Tree t) {\n    return matcher(t, t, null, Generics.<String, Tree>newHashMap(), new VariableStrings());\n  }\n","new_comment_raw":"Get a  TregexMatcher for this pattern on this tree.","old_comment_raw":"Get a TregexMatcher for this pattern on this tree.","label":0,"pre_label":1,"AST_level":8,"line_counts":4,"new_code_token_num":32},{"new_code_raw":"public boolean isTextPresent(String pattern) { return (Boolean) seleneseMethods.get(\"isTextPresent\").apply(driver, pattern); }","old_code_raw":"  public boolean isTextPresent(String pattern) {\n    String text = driver.findElement(By.xpath(\"\/html\/body\")).getText();\n    text = text.trim();\n\n    String strategyName = \"implicit\";\n    String use = pattern;\n    Matcher matcher = TEXT_MATCHING_STRATEGY_AND_VALUE_PATTERN.matcher(pattern);\n    if (matcher.matches()) {\n      strategyName = matcher.group(1);\n      use = matcher.group(2);\n    }\n    TextMatchingStrategy strategy = textMatchingStrategies.get(strategyName);\n\n    return strategy.isAMatch(use, text);\n  }\n","new_comment_raw":"Verifies that the specified text pattern appears somewhere on the rendered page shown to the user.","old_comment_raw":"Verifies that the specified text pattern appears somewhere on the rendered page shown to the user.","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":27},{"new_code_raw":"public Object getParams(PGraphics renderer) { if (paramMap == null) return null; return paramMap.get(renderer); }","old_code_raw":"  public PParameters getParams(PGraphics renderer) {\n    if (paramMap == null) return null;\n    return paramMap.get(renderer);\n  }\n","new_comment_raw":"Get the parameters for the specified renderer.","old_comment_raw":"Get the parameters for the specified renderer.","label":0,"pre_label":1,"AST_level":5,"line_counts":5,"new_code_token_num":24},{"new_code_raw":"public Node getFirstNode() { return m_node1; } \/\/","old_code_raw":"\tpublic NodeItem getFirstNode() {\n\t\treturn m_node1;\n\t} \/\/\n","new_comment_raw":"Return the VisualItem representing the first (source) node in the edge.","old_comment_raw":"Return the GraphItem representing the first (source) node in the edge.","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":12},{"new_code_raw":"public ArrayList<ErrorMsg> getWarnings() { return _parser.getWarnings(); }","old_code_raw":"    public Vector getWarnings() {\n        return _parser.getWarnings();\n    }\n","new_comment_raw":"Get a list of all compile warning messages","old_comment_raw":"Get a Vector containing all compile warning messages","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":14},{"new_code_raw":"public int atAdPos(final int pos) { final int take_int = (int) Math.floor((pos + 1) \/ adfrequency); Log.d(\"atAdPosE2\", take_int + \"\"); return take_int; }","old_code_raw":"    public int atAdPos(final int pos) {\n        return (int) Math.floor(pos \/ adfrequency);\n    }\n","new_comment_raw":"to display the accumulator for the Ad position","old_comment_raw":"to display the accumulator for the Ad position","label":0,"pre_label":1,"AST_level":9,"line_counts":6,"new_code_token_num":44},{"new_code_raw":"public List<LogicalInputSplit> getInputSplits(final HiveReadEntry hiveReadEntry) { final Stopwatch timeGetSplits = Stopwatch.createStarted(); try { if (!isPartitionedTable) { return getTableInputSplits(); } final List<LogicalInputSplit> splits = Lists.newArrayList(); for (HivePartition p : hiveReadEntry.getPartitions()) { splits.addAll(getPartitionInputSplits(p)); } return splits; } catch (final Exception e) { logger.error(\"Failed to get InputSplits\", e); throw new DrillRuntimeException(\"Failed to get InputSplits\", e); } finally { logger.debug(\"Took {} \u00c2\u00b5s to get InputSplits from {}.{}\", timeGetSplits.elapsed(TimeUnit.NANOSECONDS) \/ 1000, hiveReadEntry.getTable().getDbName(), hiveReadEntry.getTable().getTableName()); } }","old_code_raw":"  public List<InputSplitWrapper> getInputSplits(final HiveReadEntry hiveReadEntry) {\n    final Stopwatch timeGetSplits = Stopwatch.createStarted();\n    try {\n      if (!isPartitionedTable) {\n        return getTableInputSplits();\n      }\n\n      final List<InputSplitWrapper> splits = Lists.newArrayList();\n      for (HivePartition p : hiveReadEntry.getPartitions()) {\n        splits.addAll(getPartitionInputSplits(p));\n      }\n      return splits;\n    } catch (final Exception e) {\n      logger.error(\"Failed to get InputSplits\", e);\n      throw new DrillRuntimeException(\"Failed to get InputSplits\", e);\n    } finally {\n      logger.debug(\"Took {} \u00c2\u00b5s to get InputSplits from {}.{}\", timeGetSplits.elapsed(TimeUnit.NANOSECONDS) \/ 1000,\n          hiveReadEntry.getTable().getDbName(), hiveReadEntry.getTable().getTableName());\n    }\n  }\n","new_comment_raw":"Return  LogicalInputSplits for given  HiveReadEntry.","old_comment_raw":"Return InputSplitWrappers for given HiveReadEntry.","label":1,"pre_label":0,"AST_level":9,"line_counts":21,"new_code_token_num":149},{"new_code_raw":"public String toString() { try { return toString(-1); } catch (Exception e) { return null; } }","old_code_raw":"  public String toString() {\n    try {\n      return this.toString(0);\n    } catch (Exception e) {\n      return null;\n    }\n  }\n","new_comment_raw":"Make a JSON text of this JSONArray as a single line.","old_comment_raw":"Make a JSON text of this JSONArray.","label":1,"pre_label":0,"AST_level":6,"line_counts":8,"new_code_token_num":27},{"new_code_raw":"private File[] getDirectoryHistory() { File[] dirhist = Settings.instance().getDirectoryHistory(); if (dirhist == null || dirhist.length == 0) return new File[] { new File(\".\").getAbsoluteFile() }; else return dirhist; }","old_code_raw":"    private String[] getDirectoryHistory() {\n        return new String[] { directory.getAbsolutePath(), \"resources\", \"mursukas\", \"heppa\", \"marsupapana\" };\n\n        \/\/ TODO:\n        \/\/return Settings.instance().getDirectoryHistory();\n    }\n","new_comment_raw":"Reads current directory history from Settings.","old_comment_raw":"Gets current directory history from TODO.","label":1,"pre_label":0,"AST_level":8,"line_counts":8,"new_code_token_num":52},{"new_code_raw":"protected Object getComponentValue(ComponentType type, Object component, String propertyPath) { final int loc = propertyPath.indexOf( '.' ); final String basePropertyName = loc > 0 ? propertyPath.substring( 0, loc ) : propertyPath; final int index = findSubPropertyIndex( type, basePropertyName ); final Object baseValue = type.getPropertyValue( component, index, getEntityMode() ); if ( loc > 0 ) { if ( baseValue == null ) { return null; } return getComponentValue( (ComponentType) type.getSubtypes()[index], baseValue, propertyPath.substring(loc+1) ); } else { return baseValue; } }","old_code_raw":"\tprotected Object getComponentValue(ComponentType type, Object component, String propertyPath) {\n\t\t\n\t\tint loc = propertyPath.indexOf('.');\n\t\tString basePropertyName = loc>0 ?\n\t\t\tpropertyPath.substring(0, loc) : propertyPath;\n\t\t\n\t\tString[] propertyNames = type.getPropertyNames();\n\t\tint index=0;\n\t\tfor ( ; index<propertyNames.length; index++ ) {\n\t\t\tif ( basePropertyName.equals( propertyNames[index] ) ) break;\n\t\t}\n\t\tif (index==propertyNames.length) {\n\t\t\tthrow new MappingException( \"component property not found: \" + basePropertyName );\n\t\t}\n\t\t\n\t\tObject baseValue = type.getPropertyValue( component, index, getEntityMode() );\n\t\t\n\t\tif ( loc>0 ) {\n\t\t\tComponentType subtype = (ComponentType) type.getSubtypes()[index];\n\t\t\treturn getComponentValue( subtype, baseValue, propertyPath.substring(loc+1) );\n\t\t}\n\t\telse {\n\t\t\treturn baseValue;\n\t\t}\n\t\t\n\t}\n","new_comment_raw":"Extract a component property value.","old_comment_raw":"Extract a component property value.","label":0,"pre_label":1,"AST_level":10,"line_counts":23,"new_code_token_num":114},{"new_code_raw":"public static Log named(String name) { \/\/ a thread-safe SLF4J initialization routine is apparently hard, so I get to do dumb \/\/ shit like this while (true) { final org.slf4j.Logger logger = LoggerFactory.getLogger(name); if (logger instanceof Logger) { return forSlf4jLogger(logger); } } }","old_code_raw":"    public static Log named(String name) {\n        return forSlf4jLogger(LoggerFactory.getLogger(name));\n    }\n","new_comment_raw":"Returns a  Log instance with the given name.","old_comment_raw":"Returns a Log instance with the given name.","label":0,"pre_label":1,"AST_level":9,"line_counts":11,"new_code_token_num":65},{"new_code_raw":"public static int nextPowerOfTwo(final int value) { return 1 << (32 - Integer.numberOfLeadingZeros(value - 1)); }","old_code_raw":"    public static int nextPowerOfTwo(int value) {\n        if (!isPowerOfTwo(value)) {\n            value--;\n            value |= value >> 1;\n            value |= value >> 2;\n            value |= value >> 4;\n            value |= value >> 8;\n            value |= value >> 16;\n            value++;\n        }\n        return value;\n    }\n","new_comment_raw":"Fast method of finding the next power of 2 greater than or equal to the supplied value.","old_comment_raw":"Returns the next power of two that is larger than the specified int value.","label":1,"pre_label":0,"AST_level":8,"line_counts":5,"new_code_token_num":25},{"new_code_raw":"private List<BatchResponse> handleBatchRequests(final List<BatchRequest> requestList, final UriInfo uriInfo) { final List<BatchResponse> responseList = new ArrayList<>(requestList.size()); final List<BatchRequestNode> batchRequestNodes = this.resolutionHelper.getDependingRequests(requestList); checkList.clear(); if(batchRequestNodes.isEmpty()) { final BatchResponse response = new BatchResponse(); ErrorInfo ex = ErrorHandler.handler(new ClientDetailsNotFoundException()); response.setStatusCode(500); response.setBody(ex.getMessage()); responseList.add(response) ; return responseList ; } for (BatchRequestNode rootNode : batchRequestNodes) { final BatchRequest rootRequest = rootNode.getRequest(); final CommandStrategy commandStrategy = this.strategyProvider.getCommandStrategy(CommandContext .resource(rootRequest.getRelativeUrl()).method(rootRequest.getMethod()).build()); final BatchResponse rootResponse = commandStrategy.execute(rootRequest, uriInfo); responseList.add(rootResponse); responseList.addAll(this.processChildRequests(rootNode, rootResponse, uriInfo)); } Collections.sort(responseList, new Comparator<BatchResponse>() { @Override public int compare(BatchResponse source, BatchResponse testee) { return source.getRequestId().compareTo(testee.getRequestId()); } }); checkList = responseList; return responseList; }","old_code_raw":"    private List<BatchResponse> handleBatchRequests(final List<BatchRequest> requestList, final UriInfo uriInfo) {\n\n        final List<BatchResponse> responseList = new ArrayList<>(requestList.size());\n\n        final List<BatchRequestNode> batchRequestNodes = this.resolutionHelper.getDependingRequests(requestList);\n        checkList.clear();\n\n        for (BatchRequestNode rootNode : batchRequestNodes) {\n            final BatchRequest rootRequest = rootNode.getRequest();\n            final CommandStrategy commandStrategy = this.strategyProvider.getCommandStrategy(CommandContext\n                    .resource(rootRequest.getRelativeUrl()).method(rootRequest.getMethod()).build());\n            final BatchResponse rootResponse = commandStrategy.execute(rootRequest, uriInfo);\n\n            responseList.add(rootResponse);\n            responseList.addAll(this.processChildRequests(rootNode, rootResponse, uriInfo));\n        }\n\n        Collections.sort(responseList, new Comparator<BatchResponse>() {\n\n            @Override\n            public int compare(BatchResponse source, BatchResponse testee) {\n                return source.getRequestId().compareTo(testee.getRequestId());\n            }\n        });\n\n        checkList = responseList;\n        return responseList;\n\n    }\n","new_comment_raw":"Returns the response list by getting a proper  org.apache.fineract.batch.command.CommandStrategy.","old_comment_raw":"Returns the response list by getting a proper org.apache.fineract.batch.command.CommandStrategy.","label":0,"pre_label":1,"AST_level":11,"line_counts":37,"new_code_token_num":219},{"new_code_raw":"public static MatchFinder anyOf(final MatchFinder... finders) { return new MatchFinder() { @Override public boolean matches(UiElement element) { for (MatchFinder finder : finders) { if (finder.matches(element)) { return true; } } return false; } @Override public String toString() { return \"anyOf(\" + Joiner.on(\",\").join(finders) + \")\"; } }; }","old_code_raw":"  public static ElementMatcher anyOf(final ElementMatcher... matchers) {\n    return new ElementMatcher() {\n      @Override\n      public boolean matches(UiElement element) {\n        for (ElementMatcher matcher : matchers) {\n          if (matcher.matches(element)) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      @Override\n      public String toString() {\n        return \"anyOf(\" + Joiner.on(\",\").join(matchers) + \")\";\n      }\n    };\n  }\n","new_comment_raw":"Evaluates given @finders in short-circuit fashion in the order they are passed.","old_comment_raw":"Evaluates given @matchers in short-circuit fashion in the order they are passed.","label":1,"pre_label":0,"AST_level":11,"line_counts":20,"new_code_token_num":86},{"new_code_raw":"public BootstrapServiceRegistry build() { final ClassLoaderServiceImpl classLoaderService = new ClassLoaderServiceImpl( applicationClassLoader, resourcesClassLoader, hibernateClassLoader, environmentClassLoader ); final IntegratorServiceImpl integratorService = new IntegratorServiceImpl( providedIntegrators, classLoaderService ); return new BootstrapServiceRegistryImpl( classLoaderService, integratorService ); }","old_code_raw":"\tpublic ServiceRegistry build() {\n\t\tfinal ClassLoaderServiceImpl classLoaderService = new ClassLoaderServiceImpl(\n\t\t\t\tapplicationClassLoader,\n\t\t\t\tresourcesClassLoader,\n\t\t\t\thibernateClassLoader,\n\t\t\t\tenvironmentClassLoader\n\t\t);\n\n\t\tfinal IntegratorServiceImpl integratorService = new IntegratorServiceImpl(\n\t\t\t\tprovidedIntegrators,\n\t\t\t\tclassLoaderService\n\t\t);\n\n\t\treturn new BootstrapServiceRegistryImpl( classLoaderService, integratorService );\n\t}\n","new_comment_raw":"Build the bootstrap registry.","old_comment_raw":"Build the bootstrap registry.","label":0,"pre_label":1,"AST_level":6,"line_counts":16,"new_code_token_num":42},{"new_code_raw":"public LockableMGraph getUnsecuredMGraph() { try { checkWrite(); return wrapped; } catch (AccessControlException ex) { checkRead(); return new WriteBlockedMGraph(wrapped); } }","old_code_raw":"\tpublic LockableMGraph getUnsecuredMGraph() {\n\t\tcheckWrite();\n\t\treturn wrapped;\n\t}\n","new_comment_raw":"Returns the wrapped LockableMGraph if the caller has all access rights.","old_comment_raw":"Returns the wrapped LockableMGraph if the caller has all access rights, otherwise an AccessControlException is thrown.","label":1,"pre_label":0,"AST_level":7,"line_counts":12,"new_code_token_num":35},{"new_code_raw":"public boolean isVisible(String locator) { return ((RenderedWebElement) elementFinder.findElement(driver, locator)).isDisplayed(); }","old_code_raw":"  public boolean isVisible(String locator) {\n    return ((RenderedWebElement) findElement(locator)).isDisplayed();\n  }\n","new_comment_raw":"Determines if the specified element is visible.","old_comment_raw":"Determines if the specified element is visible.","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":26},{"new_code_raw":"public static YourKitContext startProfile(boolean enableStackTelemetry, boolean enableCPUProfilling, boolean enableAllocationRecording) { Controller controller; try { controller = new Controller(); \/\/ CHECKSTYLE: stop IllegalCatch } catch (Exception e) { \/\/ CHECKSTYLE: resume IllegalCatch LOG.info(\"Failed to set up YourKit controller\", e); return null; } try { if (enableStackTelemetry) { controller.enableStackTelemetry(); LOG.info(\"Enabled Yourkit stack telemetry\"); } \/\/ CHECKSTYLE: stop IllegalCatch } catch (Exception e) { \/\/ CHECKSTYLE: resume IllegalCatch LOG.info(\"Failed to enable YourKit stack telemetry\", e); } try { if (enableCPUProfilling) { controller.startCPUProfiling(ProfilingModes.CPU_SAMPLING, Controller.DEFAULT_FILTERS, Controller.DEFAULT_WALLTIME_SPEC); LOG.info(\"Started YourKit CPU profiling\"); } \/\/ CHECKSTYLE: stop IllegalCatch } catch (Exception e) { \/\/ CHECKSTYLE: resume IllegalCatch LOG.info(\"Failed to start YourKit CPU profiling\", e); } try { if (enableAllocationRecording) { controller.startAllocationRecording(true, ALLOCATION_RECORDING_INTERVAL, false, -1, true, false); LOG.info(\"Started YourKit allocation recording\"); } \/\/ CHECKSTYLE: stop IllegalCatch } catch (Exception e) { \/\/ CHECKSTYLE: resume IllegalCatch LOG.info(\"Failed to start YourKit allocation recording\", e); } return new YourKitContext(controller); }","old_code_raw":"  public static YourKitContext startProfile(GiraphConfiguration conf) {\n    Controller controller = null;\n    try {\n      controller = new Controller();\n      controller.enableStackTelemetry();\n      controller.startCPUProfiling(ProfilingModes.CPU_SAMPLING,\n          Controller.DEFAULT_FILTERS);\n      LOG.debug(\"Started YourKit profiling CPU\");\n      \/\/ CHECKSTYLE: stop IllegalCatch\n    } catch (Exception e) {\n      \/\/ CHECKSTYLE: resume IllegalCatch\n      LOG.debug(\"Failed to start YourKit CPU profiling\", e);\n    }\n    return new YourKitContext(controller);\n  }\n","new_comment_raw":"Create a YourKit controller and do some or all of  Controller#enableExceptionTelemetry()  Controller#startCPUProfiling(long, String, String)  Controller#startAllocationRecording(boolean, int, boolean, int, boolean, boolean) based on boolean config options passed as method parameters","old_comment_raw":"Convenient replacement of #startProfilingCPU(long) with ProfilingModes#CPU_TRACING for the mode.","label":1,"pre_label":0,"AST_level":8,"line_counts":52,"new_code_token_num":269},{"new_code_raw":"public ExecutionInfo treatAs(GraphQLType newType) { return new ExecutionInfo(unwrapNonNull(newType), fieldDefinition, field, path, this.parentInfo, this.typeIsNonNull, arguments); }","old_code_raw":"    public ExecutionInfo treatAs(GraphQLType newType) {\n        return new ExecutionInfo(unwrapNonNull(newType), fieldDefinition, field, path, this.parentType, this.typeIsNonNull, arguments);\n    }\n","new_comment_raw":"This allows you to morph a type into a more specialized form yet return the same parent and non-null ness, for example taking a  GraphQLInterfaceType and turning it into a specific  graphql.schema.GraphQLObjectType after type resolution has occurred","old_comment_raw":"This allows you to morph a type into a more specialized form yet return the same parent and non-null ness, for example taking a GraphQLInterfaceType and turning it into a specific graphql.schema.GraphQLObjectType after type resolution has occurred","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":33},{"new_code_raw":"public static Schema getOutputKeySchema(Configuration conf) { String schemaString = conf.get(CONF_OUTPUT_KEY_SCHEMA); return schemaString != null ? new Schema.Parser().parse(schemaString) : null; }","old_code_raw":"  public static Schema getOutputKeySchema(Configuration conf) {\n    String schemaString = conf.get(CONF_OUTPUT_KEY_SCHEMA);\n    return schemaString != null ? Schema.parse(schemaString) : null;\n  }\n","new_comment_raw":"Gets the job output key schema.","old_comment_raw":"Gets the job output key schema.","label":0,"pre_label":1,"AST_level":7,"line_counts":5,"new_code_token_num":35},{"new_code_raw":"@Transactional(readOnly = true) @Override public int getCount(final List<BatchInstanceStatus> batchInstStatusList, final List<BatchPriority> batchPriorities, final boolean isCurrUsrNotReq, final String currentUser, final Set<String> userRoles, EphesoftUser ephesoftUser) { return batchInstanceDao .getCount(batchInstStatusList, batchPriorities, isCurrUsrNotReq, userRoles, currentUser, ephesoftUser); }","old_code_raw":"\t@Transactional(readOnly = true)\n\t@Override\n\tpublic int getCount(final List<BatchInstanceStatus> batchInstStatusList, final List<BatchPriority> batchPriorities,\n\t\t\tfinal boolean isCurrUsrNotReq, final String currentUser, final Set<String> currentRole) {\n\t\treturn batchInstanceDao.getCount(batchInstStatusList, batchPriorities, isCurrUsrNotReq, currentRole, currentUser);\n\t}\n","new_comment_raw":"An api to fetch count of the batch instances for a given status list and batch priority and isCurrUsrNotReq is used for adding the batch instance access by the current user.","old_comment_raw":"An api to fetch count of the batch instance table for a given status list and batch priority and current user required","label":1,"pre_label":0,"AST_level":6,"line_counts":9,"new_code_token_num":57},{"new_code_raw":"public ChuckInterceptor maxContentLength(long max) { this.maxContentLength = max; return this; }","old_code_raw":"    public ChuckInterceptor maxContentLength(long max) {\n        this.maxContentLength = max;\n    }\n","new_comment_raw":"Control the max length for request and response content that will be retained.","old_comment_raw":"Control the max length for request and response content that will be retained.","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":16},{"new_code_raw":"public double getAssignmentValue(int[] assignment) { double d = super.getAssignmentValue(assignment); \/\/ if (d == null) d = Double.NEGATIVE_INFINITY; return Math.exp(d); }","old_code_raw":"    public double getAssignmentValue(int[] assignment) {\n        double d = super.getAssignmentValue(assignment);\n        \/\/ if (d == null) d = Double.NEGATIVE_INFINITY;\n        return FastMath.exp(d);\n    }\n","new_comment_raw":"Just a pass through to the NDArray version, plus a Math.exp to ensure that to the outside world the TableFactor doesn't look like it's in log-space","old_comment_raw":"Just a pass through to the NDArray version, plus a FastMath.exp to ensure that to the outside world the TableFactor doesn't look like it's in log-space","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":37},{"new_code_raw":"public static Builder create() { return new Builder() { private Configuration config; private Consumer<SourceRecord> consumer; private ClassLoader classLoader; private Clock clock; private CompletionCallback completionCallback; @Override public Builder using(Configuration config) { this.config = config; return this; } @Override public Builder using(ClassLoader classLoader) { this.classLoader = classLoader; return this; } @Override public Builder using(Clock clock) { this.clock = clock; return this; } @Override public Builder using(CompletionCallback completionCallback) { this.completionCallback = completionCallback; return this; } @Override public Builder notifying(Consumer<SourceRecord> consumer) { this.consumer = consumer; return this; } @Override public EmbeddedEngine build() { if (classLoader == null) classLoader = getClass().getClassLoader(); if (clock == null) clock = Clock.system(); Objects.requireNonNull(config, \"A connector configuration must be specified.\"); Objects.requireNonNull(consumer, \"A connector consumer must be specified.\"); return new EmbeddedEngine(config, classLoader, clock, consumer, completionCallback); } }; }","old_code_raw":"    public static Builder create() {\n        return new Builder() {\n            private Configuration config;\n            private Consumer<SourceRecord> consumer;\n            private ClassLoader classLoader;\n            private Clock clock;\n\n            @Override\n            public Builder using(Configuration config) {\n                this.config = config;\n                return this;\n            }\n\n            @Override\n            public Builder using(ClassLoader classLoader) {\n                this.classLoader = classLoader;\n                return this;\n            }\n\n            @Override\n            public Builder using(Clock clock) {\n                this.clock = clock;\n                return this;\n            }\n\n            @Override\n            public Builder notifying(Consumer<SourceRecord> consumer) {\n                this.consumer = consumer;\n                return this;\n            }\n\n            @Override\n            public EmbeddedEngine build() {\n                if (classLoader == null) classLoader = getClass().getClassLoader();\n                if (clock == null) clock = Clock.system();\n                Objects.requireNonNull(config, \"A connector configuration must be specified.\");\n                Objects.requireNonNull(consumer, \"A connector consumer must be specified.\");\n                return new EmbeddedEngine(config, classLoader, clock, consumer);\n            }\n\n        };\n    }\n","new_comment_raw":"Obtain a new  Builder instance that can be used to construct runnable  EmbeddedEngine instances.","old_comment_raw":"Obtain a new Builder instance that can be used to construct runnable EmbeddedEngine instances.","label":0,"pre_label":1,"AST_level":10,"line_counts":50,"new_code_token_num":206},{"new_code_raw":"public static Treepath getPreviousSibling( Treepath treepath ) throws IllegalArgumentException { if( treepath.getHeight() < 2 ) { throw new IllegalArgumentException( \"Treepath must have minimum height of 2\" ) ; } final Tree treeToMove = treepath.getBottom() ; final Tree parent = treepath.getTreeAtHeight( 1 ) ; for( int i = parent.getChildCount() - 1 ; i > 0 ; i-- ) { final Tree child = parent.getChildAt( i ) ; if( child == treeToMove ) { return Treepath.create( treepath.getParent(), parent.getChildAt( i - 1 ) ) ; } } throw new IllegalArgumentException( \"No previous sibling\" ) ; }","old_code_raw":"  public static Treepath getPreviousSibling( Treepath treepath ) {\n    if( treepath.getHeight() < 2 ) {\n      throw new IllegalArgumentException( \"Treepath must have minimum height of 2\" ) ;\n    }\n    final Tree treeToMove = treepath.getBottom() ;\n    final Tree parent = treepath.getTreeAtHeight( 1 ) ;\n    for( int i = parent.getChildCount() - 1 ; i > 0 ; i-- ) {\n      final Tree child = parent.getChildAt( i ) ;\n      if( child == treeToMove ) {\n        return Treepath.create( treepath.getParent(), parent.getChildAt( i - 1 ) ) ;\n      }\n    }\n    return null ;\n  }\n","new_comment_raw":"Returns the sibling on the left of the bottom of given  Treepath.","old_comment_raw":"Returns the sibling on the left of the end of given Treepath.","label":1,"pre_label":0,"AST_level":11,"line_counts":16,"new_code_token_num":119},{"new_code_raw":"public Object next() throws java.io.IOException { int zzInput; int zzAction; \/\/ cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { \/\/ store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); \/\/ get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } \/\/ store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 38: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } if (normalizeSpace) { \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, yytext()); } case 55: break; case 43: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 9; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 10; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/\/ try to work around an apparent jflex bug where it \/\/ gets a space at the token end by getting \/\/ wrong the length of the trailing context. while (yylength() > 0) { char last = yycharat(yylength()-1); if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) { yypushback(1); } else { break; } } return getNext(); } case 56: break; case 11: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 57: break; case 19: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 58: break; case 8: { return handleQuotes(yytext(), false); } case 59: break; case 35: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), false); } case 60: break; case 27: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 61: break; case 33: \/\/ lookahead expression with fixed lookahead length yypushback(1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 62: break; case 49: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return getNormalizedAmpNext(); } case 63: break; case 36: { return getNormalizedAmpNext(); } case 64: break; case 23: { if (invertible) { prevWordAfter.append(yytext()); } } case 65: break; case 37: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } if (normalizeSpace) { \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, yytext()); } case 66: break; case 53: \/\/ lookahead expression with fixed lookahead length yypushback(4); { return getNext(); } case 67: break; case 46: \/\/ lookahead expression with fixed lookahead length yypushback(2); { return getNext(); } case 68: break; case 42: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 69: break; case 41: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 16; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 17; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 70: break; case 40: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 13; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 71: break; case 3: { return getNext(); } case 72: break; case 24: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return getNext(); } case 73: break; case 51: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } return getNext(txt, yytext()); } case 74: break; case 26: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, origTxt); } case 75: break; case 6: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 76: break; case 29: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 77: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 78: break; case 2: { return getNext(\"<\", yytext()); } case 79: break; case 30: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 80: break; case 18: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 81: break; case 54: { String txt = yytext(); if (normalizeSpace) { \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 82: break; case 50: { yypushback(3) ; return getNext(); } case 83: break; case 25: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), true); } case 84: break; case 39: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 85: break; case 21: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 86: break; case 17: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 87: break; case 13: { return handleEllipsis(yytext()); } case 88: break; case 34: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 1; { \/* invert quote - often but not always right *\/ return handleQuotes(yytext(), true); } case 89: break; case 14: { return normalizeFractions(yytext()); } case 90: break; case 15: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(); } } case 91: break; case 47: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 11; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 12; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 92: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 93: break; case 9: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 94: break; case 45: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 95: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 96: break; case 28: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 97: break; case 48: { if (keepAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 98: break; case 20: { if (normalizeOtherBrackets) { return getNext(\"-RSB-\", yytext()); } else { return getNext(); } } case 99: break; case 12: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 100: break; case 31: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 101: break; case 10: { return getNext(\">\", yytext()); } case 102: break; case 32: { \/\/ this one should only match if we're basically at the end of file \/\/ since the last one matches two things, even newlines String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 103: break; case 22: { if (normalizeOtherBrackets) { return getNext(\"-LSB-\", yytext()); } else { return getNext(); } } case 104: break; case 52: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/\/ try to work around an apparent jflex bug where it \/\/ gets a space at the token end by getting \/\/ wrong the length of the trailing context. while (yylength() > 0) { char last = yycharat(yylength()-1); if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) { yypushback(1); } else { break; } } String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 105: break; case 1: { String str = yytext(); int first = str.charAt(0); String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } LOGGER.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: LOGGER.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 106: break; case 44: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 107: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 108: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }","old_code_raw":"  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    \/\/ cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            \/\/ store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            \/\/ get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          int zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      \/\/ store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 38: \n          { String txt = yytext();\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '\/');\n                  }\n                  if (normalizeSpace) {\n                    \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                    txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n\n                  }\n                  return getNext(txt, yytext());\n          }\n        case 55: break;\n        case 43: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 9;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 10;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { \/\/ try to work around an apparent jflex bug where it\n                          \/\/ gets a space at the token end by getting\n                          \/\/ wrong the length of the trailing context.\n                          while (yylength() > 0) {\n                            char last = yycharat(yylength()-1);\n                            if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) {\n                              yypushback(1);\n                            } else {\n                              break;\n                            }\n                          }\n\t\t\t  return getNext();\n          }\n        case 56: break;\n        case 11: \n          { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 57: break;\n        case 19: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 58: break;\n        case 8: \n          { return handleQuotes(yytext(), false);\n          }\n        case 59: break;\n        case 35: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return handleQuotes(yytext(), false);\n          }\n        case 60: break;\n        case 27: \n          { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n          }\n        case 61: break;\n        case 33: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n          }\n        case 62: break;\n        case 48: \n          { if (splitAssimilations) {\n                            yypushback(2) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 63: break;\n        case 49: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNormalizedAmpNext();\n          }\n        case 64: break;\n        case 36: \n          { return getNormalizedAmpNext();\n          }\n        case 65: break;\n        case 23: \n          { if (invertible) {\n                            prevWordAfter.append(yytext());\n                        }\n          }\n        case 66: break;\n        case 37: \n          { String txt = yytext();\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '\/');\n                  }\n                  if (normalizeSpace) {\n                    \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                    txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                  }\n                  return getNext(txt, yytext());\n          }\n        case 67: break;\n        case 53: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(4);\n          { return getNext();\n          }\n        case 68: break;\n        case 46: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(2);\n          { return getNext();\n          }\n        case 69: break;\n        case 42: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 15;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 14;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 70: break;\n        case 41: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 16;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 17;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 71: break;\n        case 40: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 13;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 14;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 72: break;\n        case 3: \n          { return getNext();\n          }\n        case 73: break;\n        case 24: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext();\n          }\n        case 74: break;\n        case 51: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 75: break;\n        case 26: \n          { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n          }\n        case 76: break;\n        case 6: \n          { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n          }\n        case 77: break;\n        case 29: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 3;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 4;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n          }\n        case 78: break;\n        case 16: \n          { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 79: break;\n        case 2: \n          { return getNext(\"<\", yytext());\n          }\n        case 80: break;\n        case 30: \n          { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '\/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 81: break;\n        case 18: \n          { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 82: break;\n        case 54: \n          { String txt = yytext();\n                          if (normalizeSpace) {\n                            \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 83: break;\n        case 25: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return handleQuotes(yytext(), true);\n          }\n        case 84: break;\n        case 39: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 5;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 6;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String txt = yytext();\n                          return getNext(removeSoftHyphens(txt),\n                                         txt);\n          }\n        case 85: break;\n        case 21: \n          { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 86: break;\n        case 50: \n          { if (splitAssimilations) {\n                            yypushback(3) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 87: break;\n        case 17: \n          { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 88: break;\n        case 13: \n          { return handleEllipsis(yytext());\n          }\n        case 89: break;\n        case 34: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 1;\n          { \/* invert quote - often but not always right *\/\n                  return handleQuotes(yytext(), true);\n          }\n        case 90: break;\n        case 14: \n          { return normalizeFractions(yytext());\n          }\n        case 91: break;\n        case 15: \n          { if (normalizeCurrency) {\n                            return getNext(normalizeCurrency(yytext()), yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 92: break;\n        case 47: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 11;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 12;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 93: break;\n        case 7: \n          { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n          }\n        case 94: break;\n        case 9: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '\/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 95: break;\n        case 45: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext(removeSoftHyphens(yytext()),\n                                               yytext());\n          }\n        case 96: break;\n        case 4: \n          { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n          }\n        case 97: break;\n        case 28: \n          { return getNext(removeSoftHyphens(yytext()), yytext());\n          }\n        case 98: break;\n        case 20: \n          { if (normalizeOtherBrackets) {\n                    return getNext(\"-RSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 99: break;\n        case 12: \n          { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n          }\n        case 100: break;\n        case 31: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n          }\n        case 101: break;\n        case 10: \n          { return getNext(\">\", yytext());\n          }\n        case 102: break;\n        case 32: \n          { \/\/ this one should only match if we're basically at the end of file\n                          \/\/ since the last one matches two things, even newlines\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 103: break;\n        case 22: \n          { if (normalizeOtherBrackets) {\n                    return getNext(\"-LSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 104: break;\n        case 52: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 7;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 8;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { \/\/ try to work around an apparent jflex bug where it\n                          \/\/ gets a space at the token end by getting\n                          \/\/ wrong the length of the trailing context.\n                          while (yylength() > 0) {\n                            char last = yycharat(yylength()-1);\n                            if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) {\n                              yypushback(1);\n                            } else {\n                              break;\n                            }\n                          }\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 105: break;\n        case 1: \n          { String str = yytext();\n          int first = str.charAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n          }\n        case 106: break;\n        case 44: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 107: break;\n        case 5: \n          { if (tokenizeNLs) {\n                      return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns\n                  } else if (invertible) {\n                      prevWordAfter.append(yytext());\n                  }\n          }\n        case 108: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                if (invertible) {\n            prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            prevWordAfter.setLength(0);\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n          }\n          return null;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n","new_comment_raw":"Resumes scanning until the next regular expression is matched, the end of input is encountered or an I\/O-Error occurs.","old_comment_raw":"Resumes scanning until the next regular expression is matched, the end of input is encountered or an I\/O-Error occurs.","label":0,"pre_label":1,"AST_level":17,"line_counts":702,"new_code_token_num":4305},{"new_code_raw":"public ComponentType introspect(Class<?> implClass) throws ConfigurationLoadException { ComponentType compType = factory.createComponentType(); return introspect(implClass, compType); }","old_code_raw":"    public ComponentInfo introspect(Class<?> implClass) throws ConfigurationLoadException {\n        ComponentInfo compType = factory.createComponentInfo();\n        return introspect(implClass, compType);\n    }\n","new_comment_raw":"Visits the given implementation type and calls back to  org.apache.tuscany.core.extension.config.ImplementationProcessors registered with this introspector to build up a  ComponentType","old_comment_raw":"Visits the given implementation type and calls back to org.apache.tuscany.core.extension.config.ImplementationProcessors registered with this introspector to build up a ComponentInfo","label":1,"pre_label":0,"AST_level":5,"line_counts":6,"new_code_token_num":27},{"new_code_raw":"public Object next() throws java.io.IOException { int zzInput; int zzAction; \/\/ cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; \/\/ set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { \/\/ store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); \/\/ get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } \/\/ store back cached position zzMarkedPos = zzMarkedPosL; if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { String str = yytext(); int first = str.codePointAt(0); String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } logger.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: logger.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 67: break; case 2: { return getNext(\"<\", yytext()); } case 68: break; case 3: { return getNext(); } case 69: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 70: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 71: break; case 6: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 72: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 73: break; case 8: { return handleQuotes(yytext(), false); } case 74: break; case 9: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 75: break; case 10: { return getNext(\">\", yytext()); } case 76: break; case 11: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 77: break; case 12: { return getNext(removeFromNumber(yytext()), yytext()); } case 78: break; case 13: { return handleEllipsis(yytext()); } case 79: break; case 14: { return normalizeFractions(yytext()); } case 80: break; case 15: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(minimallyNormalizeCurrency(yytext()), yytext()); } } case 81: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 82: break; case 17: { if (normalizeOtherBrackets) { return getNext(\"-RSB-\", yytext()); } else { return getNext(); } } case 83: break; case 18: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 84: break; case 19: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 85: break; case 20: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 86: break; case 21: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 87: break; case 22: { if (normalizeOtherBrackets) { return getNext(\"-LSB-\", yytext()); } else { return getNext(); } } case 88: break; case 23: { if (invertible) { prevWordAfter.append(yytext()); } } case 89: break; case 24: { return getNext(\"\\u2022\", yytext()); } case 90: break; case 25: { return getNext(\"\\u2122\", yytext()); } case 91: break; case 26: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 92: break; case 27: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(); } case 93: break; case 28: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return handleQuotes(yytext(), true); } case 94: break; case 29: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 95: break; case 30: { breakByHyphens(yytext()); return getNext(removeSoftHyphens(yytext()), yytext()); } case 96: break; case 31: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 97: break; case 32: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 98: break; case 33: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 99: break; case 34: { \/\/ this one should only match if we're basically at the end of file \/\/ since the last one matches two things, even newlines (if not tokenize per line) String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 100: break; case 35: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 101: break; case 36: \/\/ lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 1); { \/* invert quote - often but not always right *\/ return handleQuotes(yytext(), true); } case 102: break; case 37: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return handleQuotes(yytext(), false); } case 103: break; case 38: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 104: break; case 39: { String txt = yytext(); \/\/ if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space... if (strictTreebank3) { int spaceIndex = indexOfSpace(txt); if (spaceIndex >= 0) { yypushback(txt.length() - spaceIndex); String newText = yytext(); return getNext(newText, newText); } } if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, txt); } case 105: break; case 40: { return getNormalizedAmpNext(); } case 106: break; case 41: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, origTxt); } case 107: break; case 42: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space } return getNext(txt, origTxt); } case 108: break; case 43: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 109: break; case 44: { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 110: break; case 45: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 17; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 111: break; case 46: \/\/ lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 112: break; case 47: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 113: break; case 48: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 22; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 114: break; case 49: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 18; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 19; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 115: break; case 50: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 116: break; case 51: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 21; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 117: break; case 52: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 118: break; case 53: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { breakByHyphens(yytext()); return getNext(removeSoftHyphens(yytext()), yytext()); } case 119: break; case 54: { if (splitAssimilations) { yypushback(3) ; return getNext(); } else { return getNext(); } } case 120: break; case 55: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNormalizedAmpNext(); } case 121: break; case 56: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 9; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 122: break; case 57: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { return getNext(); } case 123: break; case 58: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 124: break; case 59: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 125: break; case 60: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 13; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 126: break; case 61: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } return getNext(txt, yytext()); } case 127: break; case 62: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4); { return getNext(); } case 128: break; case 63: \/\/ lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { return getNext(); } case 129: break; case 64: { String txt = yytext(); if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 130: break; case 65: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 25; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 131: break; case 66: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 24; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 132: break; default: zzScanError(ZZ_NO_MATCH); } } } }","old_code_raw":"  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    \/\/ cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      \/\/ set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            \/\/ store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            \/\/ get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      \/\/ store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n        zzAtEOF = true;\n              {\n                if (invertible) {\n            \/\/ prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            \/\/ System.err.println(\"At end of text making after: |\" + str + \"|\");\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n            \/\/ System.err.println(\"prevWord is |\" + prevWord.get(CoreAnnotations.TextAnnotation.class) + \"|, its after is |\" +\n            \/\/         prevWord.get(CoreAnnotations.AfterAnnotation.class) + \"|\");\n            prevWordAfter.setLength(0);\n          }\n          return null;\n              }\n      }\n      else {\n        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n          case 1: \n            { String str = yytext();\n          int first = str.codePointAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n            }\n          case 67: break;\n          case 2: \n            { return getNext(\"<\", yytext());\n            }\n          case 68: break;\n          case 3: \n            { return getNext();\n            }\n          case 69: break;\n          case 4: \n            { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n            }\n          case 70: break;\n          case 5: \n            { if (tokenizeNLs) {\n                      return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns\n                  } else if (invertible) {\n                    \/\/ System.err.println(\"Appending newline: |\" + yytext() + \"|\");\n                    prevWordAfter.append(yytext());\n                  }\n            }\n          case 71: break;\n          case 6: \n            { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n            }\n          case 72: break;\n          case 7: \n            { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n            }\n          case 73: break;\n          case 8: \n            { return handleQuotes(yytext(), false);\n            }\n          case 74: break;\n          case 9: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '\/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 75: break;\n          case 10: \n            { return getNext(\">\", yytext());\n            }\n          case 76: break;\n          case 11: \n            { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n            }\n          case 77: break;\n          case 12: \n            { handleHyphenatedNumber(yytext());\n                          return getNext(removeFromNumber(yytext()), yytext());\n            }\n          case 78: break;\n          case 13: \n            { return handleEllipsis(yytext());\n            }\n          case 79: break;\n          case 14: \n            { return normalizeFractions(yytext());\n            }\n          case 80: break;\n          case 15: \n            { if (normalizeCurrency) {\n                            return getNext(normalizeCurrency(yytext()), yytext());\n                        } else {\n                            return getNext(minimallyNormalizeCurrency(yytext()), yytext());\n                          }\n            }\n          case 81: break;\n          case 16: \n            { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 82: break;\n          case 17: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-RSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 83: break;\n          case 18: \n            { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 84: break;\n          case 19: \n            { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 85: break;\n          case 20: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 86: break;\n          case 21: \n            { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 87: break;\n          case 22: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-LSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 88: break;\n          case 23: \n            { if (invertible) {\n                            prevWordAfter.append(yytext());\n                        }\n            }\n          case 89: break;\n          case 24: \n            { return getNext(\"\\u2022\", yytext());\n            }\n          case 90: break;\n          case 25: \n            { return getNext(\"\\u2122\", yytext());\n            }\n          case 91: break;\n          case 26: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 15;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 92: break;\n          case 27: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext();\n            }\n          case 93: break;\n          case 28: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return handleQuotes(yytext(), true);\n            }\n          case 94: break;\n          case 29: \n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 95: break;\n          case 30: \n            { breakByHyphens(yytext());\n                    return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 96: break;\n          case 31: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 3;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 4;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n            }\n          case 97: break;\n          case 32: \n            { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '\/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 98: break;\n          case 33: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 99: break;\n          case 34: \n            { \/\/ this one should only match if we're basically at the end of file\n                          \/\/ since the last one matches two things, even newlines (if not tokenize per line)\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n                          return getNext(s, yytext());\n            }\n          case 100: break;\n          case 35: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 101: break;\n          case 36: \n            \/\/ lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 1);\n            { \/* invert quote - often but not always right *\/\n                  return handleQuotes(yytext(), true);\n            }\n          case 102: break;\n          case 37: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return handleQuotes(yytext(), false);\n            }\n          case 103: break;\n          case 38: \n            { return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 104: break;\n          case 39: \n            { String txt = yytext();\n                  \/\/ if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space...\n                  if (strictTreebank3) {\n                    int spaceIndex = indexOfSpace(txt);\n                    if (spaceIndex >= 0) {\n                      yypushback(txt.length() - spaceIndex);\n                      return getNext();\n                    }\n                  }\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '\/');\n                  }\n                  if (normalizeSpace) {\n                    txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                  }\n                  return getNext(txt, yytext());\n            }\n          case 105: break;\n          case 40: \n            { return getNormalizedAmpNext();\n            }\n          case 106: break;\n          case 41: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 107: break;\n          case 42: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 108: break;\n          case 43: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 5;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 6;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String txt = yytext();\n                          return getNext(removeSoftHyphens(txt),\n                                         txt);\n            }\n          case 109: break;\n          case 44: \n            { if (splitAssimilations) {\n                            yypushback(2) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 110: break;\n          case 45: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 17;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 111: break;\n          case 46: \n            \/\/ lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);\n            { if (splitAssimilations) {\n                            yypushback(2) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 112: break;\n          case 47: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 10;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 113: break;\n          case 48: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 22;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 114: break;\n          case 49: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 18;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 19;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 115: break;\n          case 50: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 10;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 116: break;\n          case 51: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 21;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 117: break;\n          case 52: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 118: break;\n          case 53: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { breakByHyphens(yytext());\n                    return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 119: break;\n          case 54: \n            { if (splitAssimilations) {\n                            yypushback(3) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 120: break;\n          case 55: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNormalizedAmpNext();\n            }\n          case 121: break;\n          case 56: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 9;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 122: break;\n          case 57: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { return getNext();\n            }\n          case 123: break;\n          case 58: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 14;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 124: break;\n          case 59: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 8;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 125: break;\n          case 60: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 13;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 126: break;\n          case 61: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 127: break;\n          case 62: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4);\n            { return getNext();\n            }\n          case 128: break;\n          case 63: \n            \/\/ lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);\n            { return getNext();\n            }\n          case 129: break;\n          case 64: \n            { String txt = yytext();\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 130: break;\n          case 65: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 23;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 25;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 131: break;\n          case 66: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 23;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 24;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 132: break;\n          default:\n            zzScanError(ZZ_NO_MATCH);\n        }\n      }\n    }\n  }\n","new_comment_raw":"Resumes scanning until the next regular expression is matched, the end of input is encountered or an I\/O-Error occurs.","old_comment_raw":"Resumes scanning until the next regular expression is matched, the end of input is encountered or an I\/O-Error occurs.","label":0,"pre_label":1,"AST_level":19,"line_counts":965,"new_code_token_num":6267},{"new_code_raw":"@Override public boolean isClosed() { return mode == Mode.PARTITION ? window.isClosedForPartition() : window.isClosed(); }","old_code_raw":"    @Override\n    public boolean isClosed() {\n        return window.isClosed();\n    }\n","new_comment_raw":"Depending on the  Mode#ALL mode this is operating in, returns true if and only if the query window is closed and you should emit the result at this time.","old_comment_raw":"Returns true if the query window is closed and you should emit the result at this time.","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":24},{"new_code_raw":"public static DateTimeFieldType clockhourOfDay() { return CLOCKHOUR_OF_DAY_TYPE; }","old_code_raw":"    public static DateTimeFieldType clockhourOfDay() {\n        return CLOCKHOUR_OF_DAY;\n    }\n","new_comment_raw":"Get the hour of day (offset to 1-24) field type.","old_comment_raw":"Get the hour of day (offset to 1-24) field type.","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":11},{"new_code_raw":"public boolean searchEditText(String search) { boolean found = soloSearch.searchEditText(search); return found; }","old_code_raw":"\tpublic boolean searchEditText(String search) {\n\t\tPattern p = Pattern.compile(search);\n\t\tMatcher matcher;\n\t\tArrayList<EditText> editTextList = getCurrentEditTexts();\n\t\tIterator<EditText> iterator = editTextList.iterator();\n\t\twhile (iterator.hasNext()) {\n\t\t\tEditText editText = (EditText) iterator.next();\n\t\t\tmatcher = p.matcher(editText.getText().toString());\n\t\t\tif (matcher.matches()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tif (scrollDownList())\n\t\t\treturn searchEditText(search);\n\t\telse\n\t\t\treturn false;\n\t}\n","new_comment_raw":"Searches for a text string in the edit texts located in the current activity.","old_comment_raw":"Searches for a text string in the edit texts located in the current activity.","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":20},{"new_code_raw":"public static Socket socket(URI uri, Options opts) { if (opts == null) { opts = new Options(); } URL parsed = Url.parse(uri); URI source; try { source = parsed.toURI(); } catch (URISyntaxException e) { throw new RuntimeException(e); } String id = Url.extractId(parsed); String path = parsed.getPath(); boolean sameNamespace = managers.containsKey(id) && managers.get(id).nsps.containsKey(path); boolean newConnection = opts.forceNew || !opts.multiplex || sameNamespace; Manager io; if (newConnection) { logger.fine(String.format(\"ignoring socket cache for %s\", source)); io = new Manager(source, opts); } else { if (!managers.containsKey(id)) { logger.fine(String.format(\"new io instance for %s\", source)); managers.putIfAbsent(id, new Manager(source, opts)); } io = managers.get(id); } String query = parsed.getQuery(); if (query != null && (opts.query == null || opts.query.isEmpty())) { opts.query = query; } return io.socket(parsed.getPath(), opts); }","old_code_raw":"    public static Socket socket(URI uri, Options opts) {\n        if (opts == null) {\n            opts = new Options();\n        }\n\n        URL parsed = Url.parse(uri);\n        URI source;\n        try {\n            source = parsed.toURI();\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n        String id = Url.extractId(parsed);\n        String path = parsed.getPath();\n        boolean sameNamespace = managers.containsKey(id)\n                && managers.get(id).nsps.containsKey(path);\n        boolean newConnection = opts.forceNew || !opts.multiplex || sameNamespace;\n        Manager io;\n\n        if (newConnection) {\n            logger.fine(String.format(\"ignoring socket cache for %s\", source));\n            io = new Manager(source, opts);\n        } else {\n            if (!managers.containsKey(id)) {\n                logger.fine(String.format(\"new io instance for %s\", source));\n                managers.putIfAbsent(id, new Manager(source, opts));\n            }\n            io = managers.get(id);\n        }\n\n        return io.socket(parsed.getPath());\n    }\n","new_comment_raw":"Initializes a  Socket from an existing  Manager for multiplexing.","old_comment_raw":"Initializes a Socket from an existing Manager for multiplexing.","label":0,"pre_label":1,"AST_level":10,"line_counts":38,"new_code_token_num":244},{"new_code_raw":"public User getUserByName(String username) throws ApiException { ApiResponse<User> localVarResp = getUserByNameWithHttpInfo(username); return localVarResp.getData(); }","old_code_raw":"    public User getUserByName(String username) throws ApiException {\n        ApiResponse<User> resp = getUserByNameWithHttpInfo(username);\n        return resp.getData();\n    }\n","new_comment_raw":"Get user by user name","old_comment_raw":"Get user by user name","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":25},{"new_code_raw":"public boolean contains(long millisInstant) { long thisStart = getStartMillis(); long thisEnd = getEndMillis(); return (millisInstant >= thisStart && millisInstant < thisEnd) || (thisStart == millisInstant && thisEnd == millisInstant); }","old_code_raw":"    public boolean contains(long millisInstant) {\n        long thisStart = getStartMillis();\n        long thisEnd = getEndMillis();\n        return (millisInstant >= thisStart && millisInstant < thisEnd);\n    }\n","new_comment_raw":"Does this time interval contain or equal the specified millisecond instant.","old_comment_raw":"Does this time interval contain the specified millisecond instant.","label":1,"pre_label":0,"AST_level":7,"line_counts":7,"new_code_token_num":41},{"new_code_raw":"protected static Extractor[] getExtractorFramesRare(String identifier, TTags ttags) { ArrayList<Extractor> extrs = new ArrayList<>(); List<String> args = StringUtils.valueSplit(identifier, \"[a-zA-Z0-9]*(?:\\\\([^)]*\\\\))?\", \"\\\\s*,\\\\s*\"); for (String arg : args) { if (\"naacl2003unknowns\".equalsIgnoreCase(arg)) { extrs.addAll(Arrays.asList(eFrames_motley_naacl2003)); getNaaclExtractors(extrs); } else if ((\"lnaacl2003unknowns\").equalsIgnoreCase(arg)) { extrs.addAll(Arrays.asList(eFrames_motley_naacl2003_left)); getNaaclExtractors(extrs); } else if (\"caselessnaacl2003unknowns\".equalsIgnoreCase(arg)) { extrs.addAll(Arrays.asList(eFrames_motley_caseless_naacl2003)); getCaselessNaaclExtractors(extrs); \/\/ TODO: test this next one } else if (\"naacl2003conjunctions\".equalsIgnoreCase(arg)) { extrs.addAll(Arrays.asList(naacl2003Conjunctions())); } else if (\"frenchunknowns\".equalsIgnoreCase(arg)) { extrs.addAll(Arrays.asList(french_unknown_extractors)); } else if (arg.startsWith(\"wordshapes(\")) { int lWindow = Extractor.getParenthesizedNum(arg, 1); int rWindow = Extractor.getParenthesizedNum(arg, 2); String wsc = Extractor.getParenthesizedArg(arg, 3); if (wsc == null) { wsc = \"chris2\"; } for (int i = lWindow; i <= rWindow; i++) { extrs.add(new ExtractorWordShapeClassifier(i, wsc)); } } else if (arg.startsWith(\"wordshapeconjunction(\")) { int lWindow = Extractor.getParenthesizedNum(arg, 1); int rWindow = Extractor.getParenthesizedNum(arg, 2); String wsc = Extractor.getParenthesizedArg(arg, 3); if (wsc == null) { wsc = \"chris2\"; } for (int i = lWindow; i <= rWindow; i++) { extrs.add(new ExtractorWordShapeConjunction(lWindow, rWindow, wsc)); } } else if (arg.startsWith(\"unicodeshapes(\")) { int lWindow = Extractor.getParenthesizedNum(arg, 1); int rWindow = Extractor.getParenthesizedNum(arg, 2); for (int i = lWindow; i <= rWindow; i++) { extrs.add(new ExtractorWordShapeClassifier(i, \"chris4\")); } } else if (arg.startsWith(\"unicodeshapeconjunction(\")) { int lWindow = Extractor.getParenthesizedNum(arg, 1); int rWindow = Extractor.getParenthesizedNum(arg, 2); extrs.add(new ExtractorWordShapeConjunction(lWindow, rWindow, \"chris4\")); } else if (arg.startsWith(\"chinesedictionaryfeatures(\")) { throw new RuntimeException(\"These features are no longer supported.\" + \" The paths and data files associated \" + \"with this material are out of date, and \" + \"the classes used are not thread-safe. \" + \"Those problems would need to be fixed \" + \"to use this feature.\"); \/\/String path = Extractor.getParenthesizedArg(arg, 1); \/\/\/\/ Default nlp location for these features is: \/u\/nlp\/data\/pos-tagger\/dictionary \/\/int lWindow = Extractor.getParenthesizedNum(arg, 2); \/\/int rWindow = Extractor.getParenthesizedNum(arg, 3); \/\/\/\/ First set up the dictionary prefix for the Chinese dictionaries \/\/ASBCDict.setPathPrefix(path); \/\/for (int i = lWindow; i <= rWindow; i++) { \/\/ extrs.addAll(Arrays.asList(ctbPreFeatures(i))); \/\/ extrs.addAll(Arrays.asList(ctbSufFeatures(i))); \/\/ extrs.addAll(Arrays.asList(ctbUnkDictFeatures(i))); \/\/ extrs.addAll(Arrays.asList(asbcUnkFeatures(i))); \/\/} \/\/ No longer add prefix suffix features, now that you can more flexibly add them separately. \/\/ } else if (\"generic\".equalsIgnoreCase(arg)) { \/\/ \/\/ does prefix and suffix up to 6 grams \/\/ for (int i = 1; i <= 6; i++) { \/\/ extrs.add(new ExtractorCWordSuff(i)); \/\/ extrs.add(new ExtractorCWordPref(i)); \/\/ } } else if (arg.equalsIgnoreCase(\"motleyUnknown\")) { \/\/ This is naacl2003unknown minus prefix and suffix features. extrs.addAll(Arrays.asList(eFrames_motley_naacl2003)); } else if (arg.startsWith(\"suffix(\")) { int max = Extractor.getParenthesizedNum(arg, 1); \/\/ will conveniently be 0 if not specified int position = Extractor.getParenthesizedNum(arg, 2); for (int i = 1; i <= max; i++) { extrs.add(new ExtractorWordSuff(i, position)); } } else if (arg.startsWith(\"prefix(\")) { int max = Extractor.getParenthesizedNum(arg, 1); \/\/ will conveniently be 0 if not specified int position = Extractor.getParenthesizedNum(arg, 2); for (int i = 1; i <= max; i++) { extrs.add(new ExtractorWordPref(i, position)); } } else if (arg.startsWith(\"prefixsuffix(\")) { int max = Extractor.getParenthesizedNum(arg, 1); for (int i = 1; i <= max; i++) { extrs.add(new ExtractorsConjunction(new ExtractorWordPref(i, 0), new ExtractorWordSuff(i, 0))); } } else if (arg.startsWith(\"capitalizationsuffix(\")) { int max = Extractor.getParenthesizedNum(arg, 1); for (int i = 1; i <= max; i++) { extrs.add(new ExtractorsConjunction(cWordUppCase, new ExtractorWordSuff(i,0))); } } else if (arg.startsWith(\"distsim(\")) { String path = Extractor.getParenthesizedArg(arg, 1); \/\/ traditional nlp filesystem location is: \/u\/nlp\/data\/pos_tags_are_useless\/egw.bnc.200.pruned int lWindow = Extractor.getParenthesizedNum(arg, 2); int rWindow = Extractor.getParenthesizedNum(arg, 3); for (int i = lWindow; i <= rWindow; i++) { extrs.add(new ExtractorDistsim(path, i)); } } else if (arg.startsWith(\"distsimconjunction(\")) { String path = Extractor.getParenthesizedArg(arg, 1); int lWindow = Extractor.getParenthesizedNum(arg, 2); int rWindow = Extractor.getParenthesizedNum(arg, 3); extrs.add(new ExtractorDistsimConjunction(path, lWindow, rWindow)); } else if (arg.equalsIgnoreCase(\"lctagfeatures\")) { extrs.addAll(Arrays.asList(lcTagFeatures(ttags))); } } return extrs.toArray(Extractor.EMPTY_EXTRACTOR_ARRAY); }","old_code_raw":"  protected static Extractor[] getExtractorFramesRare(String identifier, TTags ttags) {\n    ArrayList<Extractor> extrs = new ArrayList<>();\n    List<String> args = StringUtils.valueSplit(identifier, \"[a-zA-Z0-9]*(?:\\\\([^)]*\\\\))?\", \"\\\\s*,\\\\s*\");\n\n    for (String arg : args) {\n      if (\"naacl2003unknowns\".equalsIgnoreCase(arg)) {\n        extrs.addAll(Arrays.asList(eFrames_motley_naacl2003));\n        getNaaclExtractors(extrs);\n      } else if ((\"lnaacl2003unknowns\").equalsIgnoreCase(arg)) {\n        extrs.addAll(Arrays.asList(eFrames_motley_naacl2003_left));\n        getNaaclExtractors(extrs);\n      } else if (\"caselessnaacl2003unknowns\".equalsIgnoreCase(arg)) {\n        extrs.addAll(Arrays.asList(eFrames_motley_caseless_naacl2003));\n        getCaselessNaaclExtractors(extrs);\n        \/\/ TODO: test this next one\n      } else if (\"naacl2003conjunctions\".equalsIgnoreCase(arg)) {\n        extrs.addAll(Arrays.asList(naacl2003Conjunctions()));\n      } else if (\"frenchunknowns\".equalsIgnoreCase(arg)) {\n        extrs.addAll(Arrays.asList(french_unknown_extractors));\n      } else if (arg.startsWith(\"wordshapes(\")) {\n        int lWindow = Extractor.getParenthesizedNum(arg, 1);\n        int rWindow = Extractor.getParenthesizedNum(arg, 2);\n        String wsc = Extractor.getParenthesizedArg(arg, 3);\n        if (wsc == null) {\n          wsc = \"chris2\";\n        }\n        for (int i = lWindow; i <= rWindow; i++) {\n          extrs.add(new ExtractorWordShapeClassifier(i, wsc));\n        }\n      } else if (arg.startsWith(\"wordshapeconjunction(\")) {\n        int lWindow = Extractor.getParenthesizedNum(arg, 1);\n        int rWindow = Extractor.getParenthesizedNum(arg, 2);\n        String wsc = Extractor.getParenthesizedArg(arg, 3);\n        if (wsc == null) {\n          wsc = \"chris2\";\n        }\n        for (int i = lWindow; i <= rWindow; i++) {\n          extrs.add(new ExtractorWordShapeConjunction(lWindow, rWindow, wsc));\n        }\n      } else if (arg.startsWith(\"unicodeshapes(\")) {\n        int lWindow = Extractor.getParenthesizedNum(arg, 1);\n        int rWindow = Extractor.getParenthesizedNum(arg, 2);\n        for (int i = lWindow; i <= rWindow; i++) {\n          extrs.add(new ExtractorWordShapeClassifier(i, \"chris4\"));\n        }\n      } else if (arg.startsWith(\"unicodeshapeconjunction(\")) {\n        int lWindow = Extractor.getParenthesizedNum(arg, 1);\n        int rWindow = Extractor.getParenthesizedNum(arg, 2);\n        extrs.add(new ExtractorWordShapeConjunction(lWindow, rWindow, \"chris4\"));\n      } else if (arg.startsWith(\"chinesedictionaryfeatures(\")) {\n        throw new RuntimeException(\"These features are no longer supported.\" +\n                                   \"  The paths and data files associated \" +\n                                   \"with this material are out of date, and \" +\n                                   \"the classes used are not thread-safe.  \" +\n                                   \"Those problems would need to be fixed \" +\n                                   \"to use this feature.\");\n        \/\/String path = Extractor.getParenthesizedArg(arg, 1);\n        \/\/\/\/ Default nlp location for these features is: \/u\/nlp\/data\/pos-tagger\/dictionary\n        \/\/int lWindow = Extractor.getParenthesizedNum(arg, 2);\n        \/\/int rWindow = Extractor.getParenthesizedNum(arg, 3);\n        \/\/\/\/ First set up the dictionary prefix for the Chinese dictionaries\n        \/\/ASBCDict.setPathPrefix(path);\n        \/\/for (int i = lWindow; i <= rWindow; i++) {\n        \/\/  extrs.addAll(Arrays.asList(ctbPreFeatures(i)));\n        \/\/  extrs.addAll(Arrays.asList(ctbSufFeatures(i)));\n        \/\/  extrs.addAll(Arrays.asList(ctbUnkDictFeatures(i)));\n        \/\/  extrs.addAll(Arrays.asList(asbcUnkFeatures(i)));\n        \/\/}\n      \/\/ No longer add prefix suffix features, now that you can more flexibly add them separately.\n      \/\/ } else if (\"generic\".equalsIgnoreCase(arg)) {\n      \/\/   \/\/ does prefix and suffix up to 6 grams\n      \/\/   for (int i = 1; i <= 6; i++) {\n      \/\/     extrs.add(new ExtractorCWordSuff(i));\n      \/\/     extrs.add(new ExtractorCWordPref(i));\n      \/\/   }\n      } else if (arg.equalsIgnoreCase(\"motleyUnknown\")) {  \/\/ This is naacl2003unknown minus prefix and suffix features.\n        extrs.addAll(Arrays.asList(eFrames_motley_naacl2003));\n      } else if (arg.startsWith(\"suffix(\")) {\n        int max = Extractor.getParenthesizedNum(arg, 1);\n        \/\/ will conveniently be 0 if not specified\n        int position = Extractor.getParenthesizedNum(arg, 2);\n        for (int i = 1; i <= max; i++) {\n          extrs.add(new ExtractorWordSuff(i, position));\n        }\n      } else if (arg.startsWith(\"prefix(\")) {\n        int max = Extractor.getParenthesizedNum(arg, 1);\n        \/\/ will conveniently be 0 if not specified\n        int position = Extractor.getParenthesizedNum(arg, 2);\n        for (int i = 1; i <= max; i++) {\n          extrs.add(new ExtractorWordPref(i, position));\n        }\n      } else if (arg.startsWith(\"prefixsuffix(\")) {\n        int max = Extractor.getParenthesizedNum(arg, 1);\n        for (int i = 1; i <= max; i++) {\n          extrs.add(new ExtractorsConjunction(new ExtractorWordPref(i, 0),\n                                              new ExtractorWordSuff(i, 0)));\n        }\n      } else if (arg.startsWith(\"capitalizationsuffix(\")) {\n        int max = Extractor.getParenthesizedNum(arg, 1);\n        for (int i = 1; i <= max; i++) {\n          extrs.add(new ExtractorsConjunction(cWordUppCase, new ExtractorWordSuff(i,0)));\n        }\n      } else if (arg.startsWith(\"distsim(\")) {\n        String path = Extractor.getParenthesizedArg(arg, 1);\n        \/\/ traditional nlp filesystem location is: \/u\/nlp\/data\/pos_tags_are_useless\/egw.bnc.200.pruned\n        int lWindow = Extractor.getParenthesizedNum(arg, 2);\n        int rWindow = Extractor.getParenthesizedNum(arg, 3);\n        for (int i = lWindow; i <= rWindow; i++) {\n          extrs.add(new ExtractorDistsim(path, i));\n        }\n      } else if (arg.startsWith(\"distsimconjunction(\")) {\n        String path = Extractor.getParenthesizedArg(arg, 1);\n        int lWindow = Extractor.getParenthesizedNum(arg, 2);\n        int rWindow = Extractor.getParenthesizedNum(arg, 3);\n        extrs.add(new ExtractorDistsimConjunction(path, lWindow, rWindow));\n      } else if (arg.equalsIgnoreCase(\"lctagfeatures\")) {\n        extrs.addAll(Arrays.asList(lcTagFeatures(ttags)));\n      }\n    }\n\n    return extrs.toArray(new Extractor[extrs.size()]);\n  }\n","new_comment_raw":"Get an array of rare word feature Extractor identified by a name.","old_comment_raw":"Get an array of rare word feature Extractor identified by a name.","label":0,"pre_label":1,"AST_level":28,"line_counts":123,"new_code_token_num":1307},{"new_code_raw":"public List getAnchorHRefs(boolean duplicate) { if (duplicate) { return this.htmlHandler.getAllAHRefs(); } return this.htmlHandler.getAHRefs(); }","old_code_raw":"    public List getAnchorHRefs(boolean duplicate) {\n        if (duplicate) {\n            return htmlHandler.getAllAHRefs();\n        } else {\n            return htmlHandler.getAHRefs();\n        }\n    }\n","new_comment_raw":"Get Anchor Hrefs","old_comment_raw":"DOCUMENT ME!","label":1,"pre_label":0,"AST_level":7,"line_counts":8,"new_code_token_num":29},{"new_code_raw":"public List<TableDesc> listTables() { return allTables; }","old_code_raw":"    public List<TableDesc> listTables() {\n        return Lists.newArrayList(this.tableDesc);\n    }\n","new_comment_raw":"at first stage the only table in II is fact table, tables","old_comment_raw":"at first stage the only table in II is fact table, TODO: to extend to all tables","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":11},{"new_code_raw":"public int start() { FileDownloadLog.d(this, \"begin call start url[%s], savePath[%s], listener[%s], isNeedNotification[%B], notificationTitle[%s], notificationDesc[%s],\" + \" tag[%s]\", url, savePath, listener, isNeedNotification, notificationTitle, notificationDesc, tag); if (savePath == null) { savePath = FileDownloadUtils.getDefaultSaveFilePath(url); FileDownloadLog.e(this, \"save path is null to %s\", savePath); } addEventListener(); if (isNeedNotification) { \/\/ TODO \u00e6\u009b\u00bf\u00e6\u008d\u00a2app name notificationTitle = notificationTitle == null ? \"app name\" : notificationTitle; } try { checkFile(savePath); \/\/ \u00e6\u009c\u008d\u00e5\u008a\u00a1\u00e6\u0098\u00af\u00e5\u0090\u00a6\u00e5\u0090\u00af\u00e5\u008a\u00a8 if (!checkCanStart()) { \/\/ \u00e6\u00b2\u00a1\u00e6\u009c\u0089\u00e5\u0087\u0086\u00e5\u00a4\u0087\u00e5\u00a5\u00bd return getDownloadId(); } FileDownloadList.getImpl().add(this); \/\/ \u00e6\u0098\u00af\u00e5\u0090\u00a6\u00e6\u00ad\u00a3\u00e5\u009c\u00a8\u00e4\u00b8\u008b\u00e8\u00bd\u00bd if (checkDownloading(getUrl(), getSavePath())) { \/\/ \u00e6\u00ad\u00a3\u00e5\u009c\u00a8\u00e4\u00b8\u008b\u00e8\u00bd\u00bd \/\/ \u00e8\u00bf\u0099\u00e9\u0087\u008c\u00e5\u00b0\u00b1\u00e7\u009b\u00b4\u00e6\u008e\u00a5\u00e7\u00bb\u0093\u00e6\u009d\u009f\u00e4\u00ba\u0086 FileDownloadLog.d(this, \"Current is downloading %d\", getDownloadId()); setStatus(FileDownloadStatus.warn); FileDownloadList.getImpl().removeByWarn(this); return getDownloadId(); } if (checkCanReuse()) { FileDownloadLog.d(this, \"reuse downloaded file %s\", getUrl()); this.isReusedOldFile = true; setStatus(FileDownloadStatus.completed); FileDownloadList.getImpl().removeByCompleted(this); } else { FileDownloadLog.d(this, \"start downloaded by ui process %s\", getUrl()); this.isReusedOldFile = false; if (startExecute() == 0) { setEx(new RuntimeException(\"not run download, not got download id\")); FileDownloadList.getImpl().removeByError(this); } } } catch (Throwable e) { e.printStackTrace(); setEx(e); FileDownloadList.getImpl().removeByError(this); } FileDownloadLog.d(this, \"end call start url[%s], savePath[%s], listener[%s], isNeedNotification[%B], notificationTitle[%s], notificationDesc[%s],\" + \"tag[%s]\", url, savePath, listener, isNeedNotification, notificationTitle, notificationDesc, tag); return getDownloadId(); }","old_code_raw":"    public int start() {\n        FileDownloadLog.d(this, \"begin call start url[%s], savePath[%s], listener[%s], isNeedNotification[%B], notificationTitle[%s], notificationDesc[%s],\" +\n                \" tag[%s]\", url, savePath, listener, isNeedNotification, notificationTitle, notificationDesc, tag);\n\n        if (savePath == null) {\n            savePath = FileDownloadUtils.getDefaultSaveFilePath(url);\n            FileDownloadLog.e(this, \"save path is null to %s\", savePath);\n        }\n\n\n        addEventListener();\n\n        if (isNeedNotification) {\n            \/\/ TODO \u00e6\u009b\u00bf\u00e6\u008d\u00a2app name\n            notificationTitle = notificationTitle == null ? \"app name\" : notificationTitle;\n        }\n\n\n        this.downloadId = 0;\n\n        try {\n            checkFile(savePath);\n\n            \/\/ \u00e6\u009c\u008d\u00e5\u008a\u00a1\u00e6\u0098\u00af\u00e5\u0090\u00a6\u00e5\u0090\u00af\u00e5\u008a\u00a8\n            if (!checkCanStart()) {\n                \/\/ \u00e6\u00b2\u00a1\u00e6\u009c\u0089\u00e5\u0087\u0086\u00e5\u00a4\u0087\u00e5\u00a5\u00bd\n                return 0;\n            }\n\n            FileDownloadList.getImpl().add(this);\n\n            \/\/ \u00e6\u0098\u00af\u00e5\u0090\u00a6\u00e6\u00ad\u00a3\u00e5\u009c\u00a8\u00e4\u00b8\u008b\u00e8\u00bd\u00bd\n            if (checkDownloading(getUrl(), getSavePath())) {\n                \/\/ \u00e6\u00ad\u00a3\u00e5\u009c\u00a8\u00e4\u00b8\u008b\u00e8\u00bd\u00bd\n                \/\/ \u00e8\u00bf\u0099\u00e9\u0087\u008c\u00e5\u00b0\u00b1\u00e7\u009b\u00b4\u00e6\u008e\u00a5\u00e7\u00bb\u0093\u00e6\u009d\u009f\u00e4\u00ba\u0086\n                FileDownloadLog.d(this, \"Current is downloading %d\", getDownloadId());\n\n                setStatus(FileDownloadStatus.warn);\n                FileDownloadList.getImpl().removeByWarn(this);\n\n                return 0;\n            }\n\n            if (checkCanReuse()) {\n                FileDownloadLog.d(this, \"reuse downloaded file %s\", getUrl());\n                this.isReusedOldFile = true;\n\n\n                setStatus(FileDownloadStatus.completed);\n                FileDownloadList.getImpl().removeByCompleted(this);\n\n            } else {\n                FileDownloadLog.d(this, \"start downloaded by ui process %s\", getUrl());\n                this.isReusedOldFile = false;\n\n                downloadId = startExecute();\n                if (downloadId == 0) {\n                    setEx(new RuntimeException(\"not run download, not got download id\"));\n                    FileDownloadList.getImpl().removeByError(this);\n                }\n            }\n\n        } catch (Throwable e) {\n            e.printStackTrace();\n\n            setEx(e);\n            FileDownloadList.getImpl().removeByError(this);\n        }\n\n        FileDownloadLog.d(this, \"end call start url[%s], savePath[%s], listener[%s], isNeedNotification[%B], notificationTitle[%s], notificationDesc[%s],\" +\n                        \"tag[%s]\", url, savePath, listener, isNeedNotification, notificationTitle, notificationDesc,\n                tag);\n\n        return downloadId;\n\n    }\n","new_comment_raw":"start download","old_comment_raw":"start download","label":0,"pre_label":1,"AST_level":11,"line_counts":74,"new_code_token_num":470},{"new_code_raw":"public static boolean startsWithPattern(final byte[] byteArray, final byte[] pattern) { return hasPatternAt(byteArray, pattern, 0); }","old_code_raw":"  public static boolean startsWithPattern(final byte[] byteArray, final byte[] pattern) {\n    Preconditions.checkNotNull(byteArray);\n    Preconditions.checkNotNull(pattern);\n    if (pattern.length > byteArray.length) {\n      return false;\n    }\n\n    for (int i = 0; i < pattern.length; ++i) {\n      if (byteArray[i] != pattern[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n","new_comment_raw":"Checks if byteArray interpreted as sequence of bytes starts with pattern starting at position equal to offset.","old_comment_raw":"Checks if byteArray interpreted as sequence of bytes starts with pattern starting at position equal to offset.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":29},{"new_code_raw":"public Definition emit(Class cls, String allowedMethods) throws Exception { this.cls = cls; this.allowedMethods = allowedMethods; \/** @todo ravi: getting the serviceName from cls name or explicitly ask the user? *\/ String name = cls.getName(); name = name.substring(name.lastIndexOf('.') + 1); setServiceName(name); return emit(); }","old_code_raw":"    public Document emit(Class cls, String allowedMethods) throws Exception {\n        this.cls = cls;\n        this.allowedMethods = allowedMethods;\n\n        \/** @todo ravi: getting the serviceName from cls name or explicitly ask the user? *\/\n        String name = cls.getName();\n        name = name.substring(name.lastIndexOf('.') + 1);\n        setServiceName(name);\n        return emit();\n    }\n","new_comment_raw":"Generates a WSDL Definition for a given Class and a space seperated list of methods at design time","old_comment_raw":"Generates a WSDL Document for a given Class and a space seperated list of methods at design time","label":1,"pre_label":0,"AST_level":8,"line_counts":12,"new_code_token_num":74},{"new_code_raw":"public String toBooleanGetter(String name) { return getterAndSetterCapitalize(name); }","old_code_raw":"    public String toBooleanGetter(String name) {\n        return \"is\" + getterAndSetterCapitalize(name);\n    }\n","new_comment_raw":"Output the partial Getter name for boolean property, e.g.","old_comment_raw":"Output the Getter name for boolean property, e.g.","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":15},{"new_code_raw":"public static TimeExtractionFunction createFromGranularity(Granularity granularity) { switch (granularity) { case DAY: return new TimeExtractionFunction(\"d\", null, \"UTC\", Locale.getDefault().toLanguageTag()); case MONTH: return new TimeExtractionFunction(\"M\", null, \"UTC\", Locale.getDefault().toLanguageTag()); case YEAR: return new TimeExtractionFunction(\"yyyy\", null, \"UTC\", Locale.getDefault().toLanguageTag()); default: throw new AssertionError(\"Extraction \" + granularity.value + \" is not valid\"); } }","old_code_raw":"  public static TimeExtractionFunction createFromGranularity(Granularity granularity) {\n    switch (granularity) {\n    case DAY:\n      return new TimeExtractionFunction(\"dd\", null, \"UTC\", null);\n    case MONTH:\n      return new TimeExtractionFunction(\"MM\", null, \"UTC\", null);\n    case YEAR:\n      return new TimeExtractionFunction(\"yyyy\", null, \"UTC\", null);\n    case HOUR:\n      return new TimeExtractionFunction(\"hh\", null, \"UTC\", null);\n    default:\n      throw new AssertionError(\"Extraction \" + granularity.value + \" is not valid\");\n    }\n  }\n","new_comment_raw":"Creates the time format extraction function for the given granularity.","old_comment_raw":"Creates the time format extraction function for the given granularity.","label":0,"pre_label":1,"AST_level":9,"line_counts":13,"new_code_token_num":114},{"new_code_raw":"public Observable<Connectivity> observeNetworkConnectivity(final Context context) { final IntentFilter filter = new IntentFilter(); filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION); return Observable.create(new Observable.OnSubscribe<Connectivity>() { @Override public void call(final Subscriber<? super Connectivity> subscriber) { final BroadcastReceiver receiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { subscriber.onNext(Connectivity.create(context)); } }; context.registerReceiver(receiver, filter); subscriber.add(unsubscribeInUiThread(new Action0() { @Override public void call() { context.unregisterReceiver(receiver); } })); } }).defaultIfEmpty(Connectivity.create()); }","old_code_raw":"  public Observable<ConnectivityStatus> observeNetworkConnectivity(final Context context) {\n    final IntentFilter filter = new IntentFilter();\n    filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);\n\n    return Observable.create(new Observable.OnSubscribe<ConnectivityStatus>() {\n      @Override public void call(final Subscriber<? super ConnectivityStatus> subscriber) {\n        final BroadcastReceiver receiver = new BroadcastReceiver() {\n          @Override public void onReceive(Context context, Intent intent) {\n            final ConnectivityStatus newStatus = getConnectivityStatus(context);\n\n            \/\/ we need to perform check below,\n            \/\/ because after going off-line, onReceive() is called twice\n            if (newStatus != status) {\n              status = newStatus;\n              subscriber.onNext(newStatus);\n            }\n          }\n        };\n\n        context.registerReceiver(receiver, filter);\n\n        subscriber.add(unsubscribeInUiThread(new Action0() {\n          @Override public void call() {\n            context.unregisterReceiver(receiver);\n          }\n        }));\n      }\n    }).defaultIfEmpty(ConnectivityStatus.OFFLINE);\n  }\n","new_comment_raw":"Observes network connectivity.","old_comment_raw":"Observes ConnectivityStatus, which can be WIFI_CONNECTED, MOBILE_CONNECTED or OFFLINE","label":1,"pre_label":0,"AST_level":14,"line_counts":24,"new_code_token_num":133},{"new_code_raw":"public Float getTopValue() { return topValue; }","old_code_raw":"        public float getTopValue() {\n            return topValue == null ? 0 : topValue.floatValue();\n        }\n","new_comment_raw":"Gets the 'top' attributes value in current units.","old_comment_raw":"Gets the 'top' CSS-attributes value in specified units.","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":10},{"new_code_raw":"private boolean canCombine(RelNode input, boolean nullGenerating) { return input instanceof MultiJoin && !((MultiJoin) input).isFullOuterJoin() && !((MultiJoin) input).containsOuter() && !nullGenerating; }","old_code_raw":"  private boolean canCombine(RelNode input, boolean nullGenerating) {\n    return input instanceof MultiJoinRel\n        && !((MultiJoinRel) input).isFullOuterJoin()\n        && !((MultiJoinRel) input).containsOuter()\n        && !nullGenerating;\n  }\n","new_comment_raw":"Returns whether an input can be merged into a given relational expression without changing semantics.","old_comment_raw":"Returns whether an input can be merged into a given relational expression without changing semantics.","label":0,"pre_label":1,"AST_level":8,"line_counts":7,"new_code_token_num":45},{"new_code_raw":"public Chat dccSendChatRequest(User sender, int timeout) throws IOException, SocketTimeoutException { return dccHandler.sendChatRequest(sender); }","old_code_raw":"\tpublic DccChat dccSendChatRequest(User sender, int timeout) throws IOException, SocketTimeoutException {\r\n\t\tif (sender == null)\r\n\t\t\tthrow new IllegalArgumentException(\"Can't send chat request to null user\");\r\n\t\tServerSocket ss = null;\/\/dccManager.createServerSocket();\r\n\t\tss.setSoTimeout(timeout);\r\n\t\tint serverPort = ss.getLocalPort();\r\n\r\n\t\tInetAddress ourAddress = getDccInetAddress();\r\n\t\tif (ourAddress == null)\r\n\t\t\tourAddress = getInetAddress();\r\n\t\tString ipNum = DccManager.addressToInteger(ourAddress);\r\n\r\n\t\tsendCTCPCommand(sender, \"DCC CHAT chat \" + ipNum + \" \" + serverPort);\r\n\r\n\t\t\/\/ The client may now connect to us to chat.\r\n\t\tSocket userSocket = ss.accept();\r\n\r\n\t\t\/\/ Close the server socket now that we've finished with it.\r\n\t\tss.close();\r\n\r\n\t\treturn new DccChat(this, sender, userSocket);\r\n\t}\r\n","new_comment_raw":"Utility method to send a chat request to a user.","old_comment_raw":"Attempts to establish a DCC CHAT session with a client.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":23},{"new_code_raw":"public DateTime getShipDate() { return shipDate; }","old_code_raw":"    public Date getShipDate() {\n        return shipDate;\n    }\n","new_comment_raw":"Get shipDate","old_comment_raw":"Get shipDate","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"public static Schema parse(File file) throws IOException { return new Parser().parse(file); }","old_code_raw":"  public static Schema parse(File file) throws IOException {\n    JsonParser parser = FACTORY.createJsonParser(file);\n    try {\n      return Schema.parse(MAPPER.readTree(parser), new Names());\n    } catch (JsonParseException e) {\n      throw new SchemaParseException(e);\n    }\n  }\n","new_comment_raw":"Constructs a Schema object from JSON schema file file.","old_comment_raw":"Constructs a Schema object from JSON schema file file.","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":22},{"new_code_raw":"public static String getPrefix() { if (PropertiesComponent.getInstance().isValueSet(Settings.PREFIX)) { return PropertiesComponent.getInstance().getValue(Settings.PREFIX); } else { CodeStyleSettingsManager manager = CodeStyleSettingsManager.getInstance(); CodeStyleSettings settings = manager.getCurrentSettings(); return settings.FIELD_NAME_PREFIX; } }","old_code_raw":"\tpublic static String getPrefix() {\n        String prefix = PropertiesComponent.getInstance().getValue(Settings.PREFIX);\n        if (prefix == null || prefix.length() == 0) {\n            CodeStyleSettingsManager manager = CodeStyleSettingsManager.getInstance();\n            CodeStyleSettings settings = manager.getCurrentSettings();\n            prefix = settings.FIELD_NAME_PREFIX;\n        }\n\t\tif (prefix == null || prefix.length() == 0) {\n\t\t\tprefix = \"m\"; \/\/ field name\n\t\t}\n\t\treturn prefix;\n\t}\n","new_comment_raw":"Load field name prefix from code style","old_comment_raw":"Load field name prefix from code style","label":0,"pre_label":1,"AST_level":8,"line_counts":10,"new_code_token_num":54},{"new_code_raw":"private static String convertBufferToString(byte[] buf) throws UnsupportedEncodingException { return new String(buf, 0, buf.length - 2, \"UTF-16LE\"); }","old_code_raw":"  private static String convertBufferToString(byte[] buf) throws UnsupportedEncodingException {\n    return(new String(buf, 0, buf.length - 2, \"UTF-16LE\"));\n  }\n","new_comment_raw":"Converts a Windows buffer to a Java String.","old_comment_raw":"Converts a Windows buffer to a Java String.","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":34},{"new_code_raw":"protected TreePath[] getPathBetweenRows(int index0, int index1) { TreeUI tree = getUI(); if (tree != null) { int rowCount = getRowCount(); if (rowCount > 0 && !((index0 < 0 && index1 < 0) || (index0 >= rowCount && index1 >= rowCount))){ index0 = Math.min(rowCount - 1, Math.max(index0, 0)); index1 = Math.min(rowCount - 1, Math.max(index1, 0)); int minIndex = Math.min(index0, index1); int maxIndex = Math.max(index0, index1); TreePath[] selection = new TreePath[ maxIndex - minIndex + 1]; for(int counter = minIndex; counter <= maxIndex; counter++) { selection[counter - minIndex] = tree.getPathForRow(this, counter); } return selection; } } return new TreePath[0]; }","old_code_raw":"    protected TreePath[] getPathBetweenRows(int index0, int index1) {\n        int              newMinIndex, newMaxIndex;\n        TreeUI           tree = getUI();\n\n        newMinIndex = Math.min(index0, index1);\n        newMaxIndex = Math.max(index0, index1);\n\n        if(tree != null) {\n            TreePath[] selection = new TreePath[newMaxIndex - newMinIndex + 1];\n            for(int counter = newMinIndex; counter <= newMaxIndex; counter++) {\n                selection[counter - newMinIndex] = tree.getPathForRow(this, counter);\n            }\n            return selection;\n        }\n        return null;\n    }\n","new_comment_raw":"Returns the paths (inclusive) between the specified rows.","old_comment_raw":"Returns JTreePath instances representing the path between index0 and index1 (including index1).","label":1,"pre_label":0,"AST_level":14,"line_counts":23,"new_code_token_num":171},{"new_code_raw":"public boolean isConstrained(String observation) { return observationIndex.indexOf(observation) >= 0; }","old_code_raw":"  public boolean isConstrained(String observation) {\n    return labelDictionary.containsKey(observation);\n  }\n","new_comment_raw":"True if this observation is constrained, and false otherwise.","old_comment_raw":"True if this observation is constrained, and false otherwise.","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":17},{"new_code_raw":"public static HashMap getXmlRpcWorkflowInstancePage( WorkflowInstancePage page) { HashMap pageHash = new HashMap(); pageHash.put(\"totalPages\", String.valueOf(page.getTotalPages())); pageHash.put(\"pageNum\", String.valueOf(page.getPageNum())); pageHash.put(\"pageSize\", String.valueOf(page.getPageSize())); pageHash.put(\"pageWorkflows\", getXmlRpcWorkflowInstances(page.getPageWorkflows())); return pageHash; }","old_code_raw":"  public static Hashtable getXmlRpcWorkflowInstancePage(\n      WorkflowInstancePage page) {\n    Hashtable pageHash = new Hashtable();\n    pageHash.put(\"totalPages\", String.valueOf(page.getTotalPages()));\n    pageHash.put(\"pageNum\", String.valueOf(page.getPageNum()));\n    pageHash.put(\"pageSize\", String.valueOf(page.getPageSize()));\n    pageHash.put(\"pageWorkflows\",\n        getXmlRpcWorkflowInstances(page.getPageWorkflows()));\n\n    return pageHash;\n\n  }\n","new_comment_raw":"Gets a  HashMap representation of a  WorkflowInstancePage that is serializable over the XML-RPC wire.","old_comment_raw":"Gets a Hashtable representation of a WorkflowInstancePage that is serializable over the XML-RPC wire.","label":1,"pre_label":0,"AST_level":6,"line_counts":14,"new_code_token_num":87},{"new_code_raw":"public Options useAstDefinitions(boolean flag) { return new Options(this.includeIntrospectionTypes, this.includeScalars, this.includeSchemaDefinition, flag, this.descriptionsAsHashComments, this.includeDirective, this.comparatorRegistry); }","old_code_raw":"        public Options useAstDefinitions(boolean flag) {\n            return new Options(this.includeIntrospectionTypes, this.includeScalars, this.includeExtendedScalars, this.includeSchemaDefinition, flag, this.descriptionsAsHashComments, this.includeDirective, this.comparatorRegistry);\n        }\n","new_comment_raw":"This flag controls whether schema printer will use the  graphql.schema.GraphQLType's original Ast  graphql.language.TypeDefinitions when printing the type.","old_comment_raw":"This flag controls whether schema printer will use the graphql.schema.GraphQLType's original Ast graphql.language.TypeDefinitions when printing the type.","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":34},{"new_code_raw":"public int pingAndWaitForReply(Message message, int numPings, long timeout) throws JMSException, InterruptedException { \/\/ Put a unique correlation id on the message before sending it. String messageCorrelationId = Long.toString(idGenerator.incrementAndGet()); message.setJMSCorrelationID(messageCorrelationId); for (int i = 0; i < numPings; i++) { \/\/ Re-timestamp the message. message.setLongProperty(\"timestamp\", System.currentTimeMillis()); _producer.send(message); } \/\/ Commit the transaction if running in transactional mode. This must happen now, rather than at the end of \/\/ this method, as the message will not be sent until the transaction is committed. commitTx(getProducerSession()); \/\/ Keep the messageId to correlate with the reply. \/\/String messageId = message.getJMSMessageID(); if (_verbose) { _logger.info(timestampFormatter.format(new Date()) + \": Pinged at with correlation id, \" + messageCorrelationId); } \/\/ Block the current thread until a reply to the message is received, or it times out. CountDownLatch trafficLight = new CountDownLatch(numPings); trafficLights.put(messageCorrelationId, trafficLight); \/\/ Note that this call expects a timeout in nanoseconds, millisecond timeout is multiplied up. trafficLight.await(timeout, TimeUnit.MILLISECONDS); \/\/ Work out how many replies were receieved. int numReplies = numPings - (int) trafficLight.getCount(); if ((numReplies < numPings) && _verbose) { _logger.info(\"Timed out before all replies received on id, \" + messageCorrelationId); } else if (_verbose) { _logger.info(\"Got all replies on id, \" + messageCorrelationId); } return numReplies; }","old_code_raw":"    public Message pingAndWaitForReply(Message message, long timeout) throws JMSException, InterruptedException\r\n    {\r\n        _producer.send(message);\r\n\r\n        \/\/ Keep the messageId to correlate with the reply.\r\n        String messageId = message.getJMSMessageID();\r\n\r\n        \/\/ Commit the transaction if running in transactional mode. This must happen now, rather than at the end of\r\n        \/\/ this method, as the message will not be sent until the transaction is committed.\r\n        commitTx();\r\n\r\n        \/\/ Block the current thread until a reply to the message is received, or it times out.\r\n        BooleanLatch trafficLight = new BooleanLatch();\r\n        trafficLights.put(messageId, trafficLight);\r\n\r\n        \/\/ Note that this call expects a timeout in nanoseconds, millisecond timeout is multiplied up.\r\n        trafficLight.await(timeout * 1000);\r\n\r\n        \/\/ Check the replies to see if one was generated, if not then the reply timed out.\r\n        Message result = replies.get(messageId);\r\n\r\n        return result;\r\n    }\r\n","new_comment_raw":"Sends the specified number of ping message and then waits for all correlating replies.","old_comment_raw":"Sends the specified ping message and then waits for a correlating reply.","label":1,"pre_label":0,"AST_level":11,"line_counts":49,"new_code_token_num":322},{"new_code_raw":"public TopicSubscriber createSubscriber(Topic topic, String messageSelector, boolean noLocal) throws JMSException { checkClosed(); if (topic instanceof CustomDestination) { CustomDestination customDestination = (CustomDestination) topic; return customDestination.createSubscriber(this, messageSelector, noLocal); } ActiveMQPrefetchPolicy prefetchPolicy = this.connection.getPrefetchPolicy(); return new ActiveMQTopicSubscriber(this, getNextConsumerId(), ActiveMQMessageTransformation .transformDestination(topic), null, messageSelector, prefetchPolicy.getTopicPrefetch(), prefetchPolicy.getMaximumPendingMessageLimit(), noLocal, false, asyncDispatch); }","old_code_raw":"    public TopicSubscriber createSubscriber(Topic topic, String messageSelector, boolean noLocal) throws JMSException {\n        checkClosed();\n        ActiveMQPrefetchPolicy prefetchPolicy = this.connection.getPrefetchPolicy();\n        return new ActiveMQTopicSubscriber(this, getNextConsumerId(), ActiveMQMessageTransformation\n                .transformDestination(topic), null, messageSelector, prefetchPolicy.getTopicPrefetch(), \n                prefetchPolicy.getMaximumPendingMessageLimit(), noLocal, false, asyncDispatch);\n    }\n","new_comment_raw":"Creates a nondurable subscriber to the specified topic, using a message selector or specifying whether messages published by its own connection should be delivered to it.","old_comment_raw":"Creates a nondurable subscriber to the specified topic, using a message selector or specifying whether messages published by its own connection should be delivered to it.","label":0,"pre_label":1,"AST_level":8,"line_counts":14,"new_code_token_num":92},{"new_code_raw":"public synchronized static String hashPassword(long accountId, String password) { try { return sha1Hash(getBytes(\"FX-SALT\" + accountId + password)); } catch (NoSuchAlgorithmException e) { throw new FxCreateException(\"Failed to load the SHA1 algorithm.\").asRuntimeException(); } }","old_code_raw":"    public synchronized static final String hashPassword(String password) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"CMS will be unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        \/\/Now, compute hash.\n        digest.update(getBytes(password));\n        String result = FxFormatUtils.encodeHex(digest.digest());\n        \/\/ Avoid SQL problems\n        return result.replaceAll(\"'\", \"_\");\n    }\n","new_comment_raw":"Compute the hash of the given flexive password.","old_comment_raw":"Hashes a password, making it almost impossible to read it.","label":1,"pre_label":0,"AST_level":9,"line_counts":9,"new_code_token_num":58},{"new_code_raw":"public WebDriver frame(final String nameOrIdOrIndex) { try { \/\/ 1.) try to find frame in current window ... currentWindow = findFrame(currentWindow, nameOrIdOrIndex); } catch (NoSuchFrameException ignored) { \/\/ 2.) try to find frame in top window ... final WebWindow topWindow = currentWindow.getTopWindow(); currentWindow = findFrame(topWindow, nameOrIdOrIndex); } return HtmlUnitDriver.this; }","old_code_raw":"    public WebDriver frame(final String name) {\n      WebWindow window = currentWindow.getTopWindow();\n\n      \/\/ Walk over all parts of the frame identifier, each time looking for a frame\n      \/\/ with a name or ID matching this part of the identifier (separated by '.').\n      String[] frames = name.split(\"\\\\.\");\n      for (int i = 0; i < frames.length; ++i) {\n        final String currentFrameId = frames[i];\n        final HtmlPage page = (HtmlPage) window.getEnclosedPage();\n        \n        if (isNumericFrameIdValid(currentFrameId, page)) {\n          window = getWindowByNumericFrameId(currentFrameId, page);\n        } else {\n          \/\/ Numeric frame ID is not valid - could be either because the identifier\n          \/\/ was numeric and not valid OR the number that was given is actually a frame\n          \/\/ name, not an index.\n          \n          boolean nextFrameFound = false;\n          for (final FrameWindow frameWindow : page.getFrames()) {\n            final String frameName = frameWindow.getName();\n            final String frameId = frameWindow.getFrameElement().getId();\n            final String remainingFrameId = joinFrom(frames, i, '.');\n            if (frameName.equals(remainingFrameId) || frameId.equals(remainingFrameId)) {\n              currentWindow = frameWindow;\n              return HtmlUnitDriver.this;\n            }\n            if (frameName.equals(currentFrameId) || frameId.equals(currentFrameId)) {\n              window = frameWindow;\n              nextFrameFound = true;\n            }\n          } \/\/ End for.\n          \n          if (!nextFrameFound) {\n            throw new NoSuchFrameException(\"Cannot find frame: \" + name);\n          }\n        } \/\/ End else\n\n      } \/\/ End for\n      \n      currentWindow = window;\n      return HtmlUnitDriver.this;\n    }\n","new_comment_raw":"Switches to a given frame according to name or numeric ID.","old_comment_raw":"Switches to a given frame according to name or numeric ID.","label":0,"pre_label":1,"AST_level":8,"line_counts":12,"new_code_token_num":70},{"new_code_raw":"public VariableInspector variableInspector() { return inspector; }","old_code_raw":"  public VariableInspector variableInspector() {\n    return tray;\n  }\n","new_comment_raw":"Access variable inspector window.","old_comment_raw":"Access variable inspector window.","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"private long insertData(ContentValues values, boolean callerIsSyncAdapter) { long id = 0; mValues.clear(); mValues.putAll(values); Long rawContactId = mValues.getAsLong(Data.RAW_CONTACT_ID); if (rawContactId == null) { throw new IllegalArgumentException(Data.RAW_CONTACT_ID + \" is required\"); } \/\/ Replace package with internal mapping final String packageName = mValues.getAsString(Data.RES_PACKAGE); if (packageName != null) { mValues.put(DataColumns.PACKAGE_ID, mDbHelper.get().getPackageId(packageName)); } mValues.remove(Data.RES_PACKAGE); \/\/ Replace mimetype with internal mapping final String mimeType = mValues.getAsString(Data.MIMETYPE); if (TextUtils.isEmpty(mimeType)) { throw new IllegalArgumentException(Data.MIMETYPE + \" is required\"); } mValues.put(DataColumns.MIMETYPE_ID, mDbHelper.get().getMimeTypeId(mimeType)); mValues.remove(Data.MIMETYPE); DataRowHandler rowHandler = getDataRowHandler(mimeType); final SQLiteDatabase db = mDbHelper.get().getWritableDatabase(); id = rowHandler.insert(db, mTransactionContext.get(), rawContactId, mValues); mTransactionContext.get().markRawContactDirtyAndChanged(rawContactId, callerIsSyncAdapter); mTransactionContext.get().rawContactUpdated(rawContactId); return id; }","old_code_raw":"    private long insertData(ContentValues inputValues, boolean callerIsSyncAdapter) {\n        final Long rawContactId = inputValues.getAsLong(Data.RAW_CONTACT_ID);\n        if (rawContactId == null) {\n            throw new IllegalArgumentException(Data.RAW_CONTACT_ID + \" is required\");\n        }\n\n        final String mimeType = inputValues.getAsString(Data.MIMETYPE);\n        if (TextUtils.isEmpty(mimeType)) {\n            throw new IllegalArgumentException(Data.MIMETYPE + \" is required\");\n        }\n\n        \/\/ The input seem valid, create a shallow copy.\n        final ContentValues values = new ContentValues(inputValues);\n\n        \/\/ Populate the relevant values before inserting the new entry into the database.\n        replacePackageNameByPackageId(values);\n\n        \/\/ Replace the mimetype by the corresponding mimetype ID.\n        values.put(DataColumns.MIMETYPE_ID, mDbHelper.get().getMimeTypeId(mimeType));\n        values.remove(Data.MIMETYPE);\n\n        \/\/ Insert the new entry.\n        final SQLiteDatabase db = mDbHelper.get().getWritableDatabase();\n        final TransactionContext context = mTransactionContext.get();\n        final long dataId = getDataRowHandler(mimeType).insert(db, context, rawContactId, values);\n        context.markRawContactDirtyAndChanged(rawContactId, callerIsSyncAdapter);\n        context.rawContactUpdated(rawContactId);\n\n        return dataId;\n    }\n","new_comment_raw":"Inserts an item in the data table","old_comment_raw":"Inserts a new entry into the (contact) data table.","label":1,"pre_label":0,"AST_level":9,"line_counts":35,"new_code_token_num":224},{"new_code_raw":"public Hashtable getBuiltInTypes() { return (Hashtable)fBuiltInTypes.clone(); }","old_code_raw":"    @Override\n    public Map<String, DatatypeValidator> getBuiltInTypes() {\n        return new HashMap<>(fBuiltInTypes);\n    }\n","new_comment_raw":"get all built-in DVs, which are stored in a hashtable keyed by the name","old_comment_raw":"get all built-in DVs, which are stored in a Map keyed by the name","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":16},{"new_code_raw":"public static String versionName() { return \"1.0.3\"; }","old_code_raw":"    public static String versionName() {\n        return \"1.0.2\";\n    }\n","new_comment_raw":"Get version name of NoHttp.","old_comment_raw":"Get version name of NoHttp.","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":15},{"new_code_raw":"public ArrayList getLinkHRefs() { return this.link_href; }","old_code_raw":"    public ArrayList getLinkHRefs() {\n        return link_href;\n    }\n","new_comment_raw":"Get a list of links","old_comment_raw":"DOCUMENT ME!","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":11},{"new_code_raw":"public Actions moveToElement(WebElement target) { if (isBuildingActions()) { action.addAction(new MoveMouseAction(jsonMouse, (Locatable) target)); } return moveInTicks(target, 0, 0); }","old_code_raw":"  public Actions moveToElement(WebElement target) {\n    if (isBuildingActions()) {\n      action.addAction(new MoveMouseAction(jsonMouse, (Locatable) target));\n      return this;\n    }\n    return moveToElement(target, 0, 0);\n  }\n","new_comment_raw":"Moves the mouse to the middle of the element.","old_comment_raw":"Moves the mouse to the middle of the element.","label":0,"pre_label":1,"AST_level":9,"line_counts":8,"new_code_token_num":42},{"new_code_raw":"public boolean isSentenceFinalPunctuationTag(String str) { return sFPunctTagStringAcceptFilter.test(str); }","old_code_raw":"  public boolean isSentenceFinalPunctuationTag(String str) {\n    return sFPunctTagStringAcceptFilter.accept(str);\n  }\n","new_comment_raw":"Accepts a String that is a sentence end punctuation tag, and rejects everything else.","old_comment_raw":"Accepts a String that is a sentence end punctuation tag, and rejects everything else.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":16},{"new_code_raw":"InputStream openSourceFile(String path) throws IOException { if (path.startsWith(\"gen\/\")) { \/\/ generated file? String rest = path.substring(\"gen\/\".length()); File fileInGenDir = new File(getGenDir(), rest); if (!fileInGenDir.isFile()) { return null; } return new BufferedInputStream(new FileInputStream(fileInGenDir)); } else { \/\/ regular source file? URL resource = recompiler.getResourceLoader().getResource(path); if (resource == null) { return null; } return resource.openStream(); } }","old_code_raw":"  InputStream openSourceFile(String resourceName) throws IOException {\n    URL resource = recompiler.getResourceLoader().getResource(resourceName);\n    return resource == null ? null : resource.openStream();\n  }\n","new_comment_raw":"Finds a source file (or other resource) that's either in this module's source path, or is a generated file.","old_comment_raw":"Finds a source file (or other resource) in this module's source path.","label":1,"pre_label":0,"AST_level":9,"line_counts":21,"new_code_token_num":114},{"new_code_raw":"private GridHubConfiguration getHubConfiguration() throws Exception { String hubApi = \"http:\/\/\" + registrationRequest.getConfiguration().getHubHost() + \":\" + registrationRequest.getConfiguration().getHubPort() + \"\/grid\/api\/hub\"; URL api = new URL(hubApi); HttpClient client = httpClientFactory.createClient(api); String url = api.toExternalForm(); HttpRequest request = new HttpRequest(GET, url); HttpResponse response = client.execute(request); try (Reader reader = new StringReader(response.getContentString()); JsonInput jsonInput = new Json().newInput(reader)) { return StandaloneConfiguration.loadFromJson(jsonInput, GridHubConfiguration.class); } }","old_code_raw":"  private GridHubConfiguration getHubConfiguration() throws Exception {\n    String hubApi =\n      \"http:\/\/\" + registrationRequest.getConfiguration().getHubHost() + \":\"\n      + registrationRequest.getConfiguration().getHubPort() + \"\/grid\/api\/hub\";\n\n    URL api = new URL(hubApi);\n    HttpClient client = httpClientFactory.createClient(api);\n    String url = api.toExternalForm();\n    HttpRequest request = new HttpRequest(GET, url);\n\n    HttpResponse response = client.execute(request);\n    return GridHubConfiguration.loadFromJSON(extractObject(response));\n  }\n","new_comment_raw":"uses the hub API to get some of its configuration.","old_comment_raw":"uses the hub API to get some of its configuration.","label":0,"pre_label":1,"AST_level":10,"line_counts":17,"new_code_token_num":124},{"new_code_raw":"public byte get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }","old_code_raw":"    public byte get(WithAttributes attributes) {\r\n        return attributes.getAttributes().get(this);\r\n    }\r\n","new_comment_raw":"Extracts the attribute map from the specified  WithAttributes and returns the value of this attribute from the map.","old_comment_raw":"Analogous to #get(WithAttributes) except returning a primitive byte.","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":19},{"new_code_raw":"@Override public Object put(Object value) { return put(value, false); }","old_code_raw":"\t@Override\n\tpublic Object put(Object value) {\n\t\treturn put(null, value);\n\t}\n","new_comment_raw":"encode = false","old_comment_raw":"encode = true","label":1,"pre_label":0,"AST_level":5,"line_counts":6,"new_code_token_num":19},{"new_code_raw":"public static EString concat(Expr<String> left, String right) { return factory.createString(Ops.CONCAT, left, factory.createConstant(right)); }","old_code_raw":"    public static EString concat(Expr<String> left, String right) {\n        return createString(Ops.CONCAT, left, createConstant(right));\n    }\n","new_comment_raw":"Expr : left || right","old_comment_raw":"Expr : left || right","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":30},{"new_code_raw":"public boolean add(E o) { return super.add(o); }","old_code_raw":"    public boolean add(E e) {\n        return offer(e);\n    }\n","new_comment_raw":"Adds the specified element to this queue.","old_comment_raw":"Inserts the specified element into this priority queue.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":16},{"new_code_raw":"private Iterable<TransactionObserver> observers() { if ( observers == null || observers.isEmpty() ) { return Collections.emptyList(); } else { return new ArrayList<>( observers ); } }","old_code_raw":"\tprivate Iterable<TransactionObserver> observers() {\n\t\treturn new ArrayList<>( observers );\n\t}\n","new_comment_raw":"Needed because while iterating the observers list and executing the before\/update callbacks, some observers might get removed from the list.","old_comment_raw":"Needed because while iterating the observers list and executing the before\/update callbacks, some observers might get removed from the list.","label":0,"pre_label":1,"AST_level":7,"line_counts":9,"new_code_token_num":37},{"new_code_raw":"public HBaseResponse getHTableInfo(String tableName) throws IOException { Configuration hconf = HadoopUtil.getCurrentHBaseConfiguration(); HTable table = null; HBaseResponse hr = null; long tableSize = 0; int regionCount = 0; try { table = new HTable(hconf, tableName); HBaseRegionSizeCalculator cal = new HBaseRegionSizeCalculator(table); Map<byte[], Long> sizeMap = cal.getRegionSizeMap(); for (long s : sizeMap.values()) { tableSize += s; } regionCount = sizeMap.size(); \/\/ Set response. hr = new HBaseResponse(); hr.setTableSize(tableSize); hr.setRegionCount(regionCount); } finally { if (null != table) { table.close(); } } return hr; }","old_code_raw":"    public HBaseResponse getHTableInfo(String tableName) throws IOException {\n        if (htableInfoCache.containsKey(tableName)) {\n            return htableInfoCache.get(tableName);\n        }\n\n        \/\/ Get HBase storage conf.\n        String hbaseUrl = KylinConfig.getInstanceFromEnv().getStorageUrl();\n        Configuration hconf = HBaseConnection.newHBaseConfiguration(hbaseUrl);\n\n        HTable table = null;\n        HBaseResponse hr = null;\n        long tableSize = 0;\n        int regionCount = 0;\n\n        try {\n            table = new HTable(hconf, tableName);\n\n            HBaseRegionSizeCalculator cal = new HBaseRegionSizeCalculator(table);\n            Map<byte[], Long> sizeMap = cal.getRegionSizeMap();\n\n            for (long s : sizeMap.values()) {\n                tableSize += s;\n            }\n\n            regionCount = sizeMap.size();\n\n            \/\/ Set response.\n            hr = new HBaseResponse();\n            hr.setTableSize(tableSize);\n            hr.setRegionCount(regionCount);\n        } finally {\n            if (null != table) {\n                table.close();\n            }\n        }\n\n        htableInfoCache.put(tableName, hr);\n\n        return hr;\n    }\n","new_comment_raw":"Calculate size of each region for given table and other info of the table.","old_comment_raw":"Calculate size of each region for given table and other info of the table.","label":0,"pre_label":1,"AST_level":8,"line_counts":32,"new_code_token_num":129},{"new_code_raw":"public ReporterData getSingleData(Xref idc) { List<ReporterData> dlist = data.get(idc); if(dlist != null && dlist.size() > 0) return dlist.get(0); return null; }","old_code_raw":"\tpublic Data getSingleData(Xref idc) {\n\t\tList<Data> dlist = data.get(idc);\n\t\tif(dlist != null && dlist.size() > 0) return dlist.get(0);\n\t\treturn null;\n\t}\n","new_comment_raw":"Get the first  ReporterData instance of the cached data for this gene-product.","old_comment_raw":"Get the first Data instance of the cached data for this gene-product.","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":41},{"new_code_raw":"public boolean isBatchFull() { return processedRecordCount >= HiveDefaultRecordReader.TARGET_RECORD_COUNT; }","old_code_raw":"  public boolean isBatchFull() {\n    return processedRecordCount >= HiveAbstractReader.TARGET_RECORD_COUNT;\n  }\n","new_comment_raw":"Checks if current number of processed records does not exceed max batch size.","old_comment_raw":"Checks if current number of processed records does not exceed max batch size.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":12},{"new_code_raw":"public Map<String, String> populateImplicitColumns(String filePath, List<String> partitionValues, boolean includeFileImplicitColumns) { Map<String, String> implicitValues = new LinkedHashMap<>(); for (int i = 0; i < partitionValues.size(); i++) { if (isStarQuery || selectedPartitionColumns.contains(i)) { implicitValues.put(partitionDesignator + i, partitionValues.get(i)); } } if (includeFileImplicitColumns) { Path path = Path.getPathWithoutSchemeAndAuthority(new Path(filePath)); for (Map.Entry<String, ImplicitFileColumns> entry : selectedImplicitColumns.entrySet()) { implicitValues.put(entry.getKey(), entry.getValue().getValue(path)); } } return implicitValues; }","old_code_raw":"  public Map<String, String> populateImplicitColumns(FileWork work, String selectionRoot) {\n    return populateImplicitColumns(work.getPath(), selectionRoot);\n  }\n","new_comment_raw":"Creates map with implicit columns where key is column name, value is columns actual value.","old_comment_raw":"Compares selection root and actual file path to determine partition columns values.","label":1,"pre_label":0,"AST_level":11,"line_counts":22,"new_code_token_num":129},{"new_code_raw":"public Date toDate() { int dom = getDayOfMonth(); Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom, getHourOfDay(), getMinuteOfHour(), getSecondOfMinute()); date.setTime(date.getTime() + getMillisOfSecond()); return correctDstTransition(date, TimeZone.getDefault()); }","old_code_raw":"    public Date toDate() {\n        int dom = getDayOfMonth();\n        Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom,\n                        getHourOfDay(), getMinuteOfHour(), getSecondOfMinute());\n        date.setTime(date.getTime() + getMillisOfSecond());\n        LocalDateTime check = LocalDateTime.fromDateFields(date);\n        if (check.isBefore(this)) {\n            \/\/ DST gap\n            \/\/ move forward in units of one minute until equal\/after\n            while (check.isBefore(this)) {\n                date.setTime(date.getTime() + 60000);\n                check = LocalDateTime.fromDateFields(date);\n            }\n            \/\/ move back in units of one second until date wrong\n            while (check.isBefore(this) == false) {\n                date.setTime(date.getTime() - 1000);\n                check = LocalDateTime.fromDateFields(date);\n            }\n            date.setTime(date.getTime() + 1000);\n        } else if (check.equals(this)) {\n            \/\/ check for DST overlap\n            Date earlier = new Date(date.getTime() - TimeZone.getDefault().getDSTSavings());\n            check = LocalDateTime.fromDateFields(earlier);\n            if (check.equals(this)) {\n                date = earlier;\n            }\n        }\n        return date;\n    }\n","new_comment_raw":"Get the date time as a java.util.Date.","old_comment_raw":"Get the date time as a java.util.Date.","label":0,"pre_label":1,"AST_level":7,"line_counts":9,"new_code_token_num":69},{"new_code_raw":"public String escapeReservedWord(String name) { if(this.reservedWordsMappings().containsKey(name)) { return this.reservedWordsMappings().get(name); } return \"_\" + name; }","old_code_raw":"    public String escapeReservedWord(String name) {\n        return \"_\" + name;  \/\/ add an underscore to the name\n    }\n","new_comment_raw":"Escapes a reserved word as defined in the `reservedWords` array.","old_comment_raw":"Escapes a reserved word as defined in the `reservedWords` array.","label":0,"pre_label":1,"AST_level":8,"line_counts":7,"new_code_token_num":39},{"new_code_raw":"public static RequestBody getReferencedRequestBody(OpenAPI openAPI, RequestBody requestBody) { if (requestBody != null && StringUtils.isNotEmpty(requestBody.get$ref())) { String name = getSimpleRef(requestBody.get$ref()); RequestBody referencedRequestBody = getRequestBody(openAPI, name); if(referencedRequestBody != null) { return referencedRequestBody; } } return requestBody; }","old_code_raw":"    public static RequestBody getReferencedRequestBody(OpenAPI openAPI, RequestBody requestBody) {\n        if (requestBody != null && StringUtils.isNotEmpty(requestBody.get$ref())) {\n            String name = getSimpleRef(requestBody.get$ref());\n            return getRequestBody(openAPI, name);\n        }\n        return requestBody;\n    }\n","new_comment_raw":"If a RequestBody contains a reference to an other RequestBody with '$ref', returns the referenced RequestBody if it is found or the actual RequestBody in the other cases.","old_comment_raw":"If a RequestBody contains a reference to an other RequestBody with '$ref', returns the referenced RequestBody or the actual RequestBody in the other cases.","label":1,"pre_label":0,"AST_level":8,"line_counts":11,"new_code_token_num":68},{"new_code_raw":"public PayloadBuilder resizeAlertBody(int payloadLength) { return resizeAlertBody(payloadLength, \"\"); }","old_code_raw":"    public PayloadBuilder resizeAlertBody(int payloadLength) {\n        int currLength = length();\n        if (currLength < payloadLength)\n            return this;\n\n        int d = currLength - payloadLength;\n        String body = (String)aps.get(\"alert\");\n\n        if (body.length() < d)\n            aps.remove(\"alert\");\n        else\n            aps.put(\"alert\", body.subSequence(0, body.length() - d));\n\n        return this;\n    }\n","new_comment_raw":"Shrinks the alert message body so that the resulting payload message fits within the passed expected payload length.","old_comment_raw":"Shrinks the alert message body so that the resulting payload message fits within the passed expected payload length.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":18},{"new_code_raw":"public BatchSchema build(){ List<MaterializedField> fieldList = Lists.newArrayList(fields); return new BatchSchema(this.selectionVectorMode, fieldList); }","old_code_raw":"  public BatchSchema build() throws SchemaChangeException {\n    \/\/ check if any fields are unaccounted for.\n\n    List<MaterializedField> fieldList = Lists.newArrayList();\n    for (ObjectCursor<MaterializedField> f : fields.values()) {\n      if (f != null) fieldList.add(f.value);\n    }\n    Collections.sort(fieldList);\n    return new BatchSchema(this.hasSelectionVector, fieldList);\n  }\n","new_comment_raw":"Generate a new BatchSchema object based on the current state of the builder.","old_comment_raw":"Generate a new BatchSchema object based on the current state of the builder.","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":26},{"new_code_raw":"public Single<ModelApiResponse> rxUploadFileWithRequiredFile(Long petId, AsyncFile requiredFile, String additionalMetadata) { return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> { delegate.uploadFileWithRequiredFile(petId, requiredFile, additionalMetadata, fut); })); }","old_code_raw":"    public Single<ModelApiResponse> rxUploadFileWithRequiredFile(Long petId, AsyncFile file, String additionalMetadata) {\n        return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> {\n            delegate.uploadFileWithRequiredFile(petId, file, additionalMetadata, fut);\n        }));\n    }\n","new_comment_raw":"uploads an image (required)","old_comment_raw":"uploads an image (required)","label":0,"pre_label":1,"AST_level":10,"line_counts":6,"new_code_token_num":46},{"new_code_raw":"public MutableDirectBuffer buffer() { return mutableDirectBuffer; }","old_code_raw":"    public ClientProtocolBuffer buffer() {\n        return protocolBuffer;\n    }\n","new_comment_raw":"The  MutableDirectBuffer that encapsulates the internal buffer.","old_comment_raw":"The ClientProtocolBuffer that encapsulates the internal buffer.","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":10},{"new_code_raw":"@Override public Refactoring getParent() { return this.parent; }","old_code_raw":"\t@Override\n\tpublic EmfRefactoring getParent() {\n\t\treturn this.parent;\n\t}\n","new_comment_raw":"Gets the Refactoring supported by the controller.","old_comment_raw":"Gets the EmfRefactoring supported by the controller.","label":1,"pre_label":0,"AST_level":5,"line_counts":6,"new_code_token_num":13},{"new_code_raw":"public String toString(OutputFormat format) { switch(format) { case XML: return toXMLString(); case READABLE: return toReadableString(); case LIST: return toList(); case RECURSIVE: return toString(); default: throw new IllegalArgumentException(\"Unsupported format \" + format); } }","old_code_raw":"  public String toString(String format) {\n    if (format != null && format.equals(\"xml\")) {\n      return toXMLString();\n    } else if (format != null && format.equals(\"readable\")) {\n      return toReadableString();\n    } else {\n      return toList();\n    }\n  }\n","new_comment_raw":"Returns a String representation of the result of this set of typed dependencies in a user-specified format.","old_comment_raw":"Returns a String representation of the result of this set of typed dependencies in a user-specified format.","label":0,"pre_label":1,"AST_level":8,"line_counts":15,"new_code_token_num":61},{"new_code_raw":"public EvictionConfig getEvictionConfig() { return evictionConfig; }","old_code_raw":"    public CacheEvictionConfig getEvictionConfig() {\n        return evictionConfig;\n    }\n","new_comment_raw":"Gets the  EvictionConfig instance for eviction configuration of the cache config.","old_comment_raw":"Gets the CacheEvictionConfig instance for eviction configuration of the cache config.","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":10},{"new_code_raw":"@SuppressWarnings(\"static-access\") public ObjectName getQueueObjectName(String virtualHostName, String queue) { \/\/ Get the name of the test manager AllObjects allObject = new AllObjects(_mbsc); allObject.querystring = \"org.apache.qpid:type=VirtualHost.Queue,VirtualHost=\" + virtualHostName + \",name=\" + queue + \",*\"; Set<ObjectName> objectNames = allObject.returnObjects(); _test.assertNotNull(\"Null ObjectName Set returned\", objectNames); _test.assertEquals(\"Incorrect number of queues with name '\" + allObject.querystring + \"' returned\", 1, objectNames.size()); \/\/ We have verified we have only one value in objectNames so return it ObjectName objectName = objectNames.iterator().next(); _test.getLogger().info(\"Loading: \" + objectName); return objectName; }","old_code_raw":"    public ObjectName getQueueObjectName(String virtualHostName, String queue)\n    {\n        \/\/ Get the name of the test manager\n        AllObjects allObject = new AllObjects(_mbsc);\n        allObject.querystring = \"org.apache.qpid:type=VirtualHost.Queue,VirtualHost=\" + virtualHostName + \",name=\" + queue + \",*\";\n\n        Set<ObjectName> objectNames = allObject.returnObjects();\n\n        _test.assertNotNull(\"Null ObjectName Set returned\", objectNames);\n        _test.assertEquals(\"Incorrect number of queues with name '\" + allObject.querystring +\n                           \"' returned\", 1, objectNames.size());\n\n        \/\/ We have verified we have only one value in objectNames so return it\n        return objectNames.iterator().next();\n    }\n","new_comment_raw":"Retrive the ObjectName for the given Queue on a Virtualhost.","old_comment_raw":"Retrive the ObjectName for the given Exchange on the test Virtualhost.","label":1,"pre_label":0,"AST_level":9,"line_counts":20,"new_code_token_num":158},{"new_code_raw":"public ArrayList<EditText> getCurrentEditTexts() { return getCurrentViews(EditText.class); }","old_code_raw":"\tpublic ArrayList<EditText> getCurrentEditTexts() {\n\t\tArrayList<EditText>editTextList = new ArrayList<EditText>();\n\t\tArrayList<View> viewList = getViews();\n\t\tfor(View view : viewList){\n\t\t\tif (view instanceof android.widget.EditText)\n\t\t\t\teditTextList.add((EditText) view);\n\t\t}\n\t\treturn editTextList;\t\n\t}\n","new_comment_raw":"Returns a  List of the  EditTexts contained in the current  Activity.","old_comment_raw":"Returns a List of the EditTexts contained in the current Activity.","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":15},{"new_code_raw":"static public IStructuredTextExpert getStatefulExpert(String type) { return getStatefulExpert(type, StructuredTextEnvironment.DEFAULT); }","old_code_raw":"\tstatic public ISTextExpert getStatefulExpert(String type) {\n\t\treturn getStatefulExpert(type, STextEnvironment.DEFAULT);\n\t}\n","new_comment_raw":"Obtains a IStructuredTextExpert instance for processing structured text with the specified type handler.","old_comment_raw":"Obtains a ISTextExpert instance for processing structured text with the specified type handler.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":19},{"new_code_raw":"public float get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }","old_code_raw":"    public float get(WithAttributes attributes) {\r\n        return attributes.getAttributes().get(this);\r\n    }\r\n","new_comment_raw":"Extracts the attribute map from the specified  WithAttributes and returns the value of this attribute from the map.","old_comment_raw":"Analogous to #get(WithAttributes) except returning a primitive float.","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":19},{"new_code_raw":"public static BinaryResourceFile fromInputStream(InputStream is) throws IOException { byte[] buf = ByteStreams.toByteArray(is); return new BinaryResourceFile(buf); }","old_code_raw":"  public static ResourceFile fromInputStream(InputStream is) throws IOException {\n    byte[] buf = ByteStreams.toByteArray(is);\n    return new ResourceFile(buf);\n  }\n","new_comment_raw":"Given an input stream, reads the stream until the end and returns a  BinaryResourceFile representing the contents of the stream.","old_comment_raw":"Given an input stream, reads the stream until the end and returns a ResourceFile representing the contents of the stream.","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":29},{"new_code_raw":"Class[] getServiceClasses( final Class type, final List issues ) { final ServiceDescriptorSet set = (ServiceDescriptorSet)type.getAnnotation( ServiceDescriptorSet.class ); if( null != set ) { final ServiceDescriptor[] descriptors = set.value(); final Class[] services = new Class[descriptors.length]; for( int i = 0; i < descriptors.length; i++ ) { ServiceDescriptor descriptor = descriptors[i]; services[i] = descriptor.type(); } return services; } else { return new Class[0]; } }","old_code_raw":"    Class[] getServiceClasses( final Class type, final List issues )\n    {\n        final List services = new ArrayList();\n        final ClassLoader classLoader = type.getClassLoader();\n        final Attribute[] attributes =\n            Attributes.getAttributes( type, \"dna.service\" );\n        for( int i = 0; i < attributes.length; i++ )\n        {\n            final String classname = attributes[ i ].getParameter( \"type\" );\n            try\n            {\n                final Class clazz = classLoader.loadClass( classname );\n                services.add( clazz );\n            }\n            catch( final Throwable t )\n            {\n                final Object[] args = new Object[]{classname, t};\n                final String message = getMessage( \"CV014\", args );\n                final VerifyIssue issue =\n                    new VerifyIssue( VerifyIssue.ERROR, message );\n                issues.add( issue );\n            }\n        }\n\n        return (Class[])services.toArray( new Class[ services.size() ] );\n    }\n","new_comment_raw":"Retrieve an array of Classes for all the value that a Component offers.","old_comment_raw":"Retrieve an array of Classes for all the services that a Component offers.","label":1,"pre_label":0,"AST_level":11,"line_counts":22,"new_code_token_num":103},{"new_code_raw":"List<ExtensionState> getExtensions() { return extensions; }","old_code_raw":"    List<ExtensionState> getExtensions() {\n        return Collections.unmodifiableList(extensions);\n    }\n","new_comment_raw":"Gets the extensions' state (as saved in the configuration file).","old_comment_raw":"Gets the extensions' state (as saved in the configuration file).","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"public Dictionary getProperties() { return m_properties; }","old_code_raw":"    public Properties getProperties() {\r\n        return m_properties;\r\n    }\r\n","new_comment_raw":"Returns the properties.","old_comment_raw":"Returns the property descriptors","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":10},{"new_code_raw":"private int getIconResId() { JSONObject settings = BackgroundMode.getSettings(); Context context = getApplicationContext(); Resources res = context.getResources(); String pkgName = context.getPackageName(); String icon = settings.optString(\"icon\", \"icon\"); int resId = res.getIdentifier(icon, \"drawable\", pkgName); if (resId == 0) { resId = res.getIdentifier(\"icon\", \"drawable\", pkgName); } return resId; }","old_code_raw":"    private int getIconResId() {\n        JSONObject settings = BackgroundMode.getSettings();\n        Context context = getApplicationContext();\n        Resources res   = context.getResources();\n        String pkgName  = context.getPackageName();\n        String icon     = settings.optString(\"icon\", \"icon\");\n\n        return res.getIdentifier(icon, \"drawable\", pkgName);\n    }\n","new_comment_raw":"Retrieves the resource ID of the app icon.","old_comment_raw":"Retrieves the resource ID of the app icon.","label":0,"pre_label":1,"AST_level":8,"line_counts":16,"new_code_token_num":87},{"new_code_raw":"public static Platform extractFromSysProperty(String osName, String osVersion) { osName = osName.toLowerCase(); \/\/ os.name for android is linux if (\"dalvik\".equalsIgnoreCase(System.getProperty(\"java.vm.name\"))) { return Platform.ANDROID; } \/\/ Windows 8 can't be detected by osName alone if (osVersion.equals(\"6.2\") && osName.startsWith(\"windows nt\")) { return WIN8; } Platform mostLikely = UNIX; String previousMatch = null; for (Platform os : Platform.values()) { for (String matcher : os.partOfOsName) { if (\"\".equals(matcher)) { continue; } matcher = matcher.toLowerCase(); if (os.isExactMatch(osName, matcher)) { return os; } if (os.isCurrentPlatform(osName, matcher) && isBetterMatch(previousMatch, matcher)) { previousMatch = matcher; mostLikely = os; } } } \/\/ Default to assuming we're on a UNIX variant (including LINUX) return mostLikely; }","old_code_raw":"  public static Platform extractFromSysProperty(String osName) {\n    osName = osName.toLowerCase();\n    \/\/ os.name for android is linux\n    if (\"dalvik\".equalsIgnoreCase(System.getProperty(\"java.vm.name\"))) {\n      return Platform.ANDROID;\n    }\n    Platform mostLikely = UNIX;\n    String previousMatch = null;\n    for (Platform os : Platform.values()) {\n      for (String matcher : os.partOfOsName) {\n        if (\"\".equals(matcher)) {\n          continue;\n        }\n        matcher = matcher.toLowerCase();\n        if (os.isExactMatch(osName, matcher)) {\n          return os;\n        }\n        if (os.isCurrentPlatform(osName, matcher) && isBetterMatch(previousMatch, matcher)) {\n          previousMatch = matcher;\n          mostLikely = os;\n        }\n      }\n    }\n\n    \/\/ Default to assuming we're on a UNIX variant (including LINUX)\n    return mostLikely;\n  }\n","new_comment_raw":"Extracts platforms based on system properties in Java and uses a heuristic to determine the most likely operating system.","old_comment_raw":"Extracts platforms based on system properties in Java and a heuristic to determine the most likely operating system.","label":1,"pre_label":0,"AST_level":11,"line_counts":32,"new_code_token_num":198},{"new_code_raw":"public Order placeOrder(Order body) throws ApiException { Object localVarPostBody = body; \/\/ verify the required parameter 'body' is set if (body == null) { throw new ApiException(400, \"Missing the required parameter 'body' when calling placeOrder\"); } \/\/ create path and map variables String localVarPath = \"\/store\/order\"; \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { \"application\/xml\", \"application\/json\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Order> localVarReturnType = new GenericType<Order>() {}; return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public Order placeOrder(Order body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    \/\/ verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling placeOrder\");\n    }\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/store\/order\";\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application\/xml\", \"application\/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Order> localVarReturnType = new GenericType<Order>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"Place an order for a pet","old_comment_raw":"Place an order for a pet","label":0,"pre_label":1,"AST_level":8,"line_counts":36,"new_code_token_num":213},{"new_code_raw":"private String buildAddVideoSdpProposal() { if (logger.isActivated()) { logger.debug(\"Build SDP proposal to add video stream in the session\"); } try { \/\/ Build SDP part String ntpTime = SipUtils.constructNTPtime(System.currentTimeMillis()); String ipAddress = getDialogPath().getSipStack().getLocalIpAddress(); getAudioPlayer().getLocalRtpPort(); String audioSdp = AudioSdpBuilder.buildSdpOffer(getAudioPlayer().getSupportedAudioCodecs(), getAudioPlayer().getLocalRtpPort()); String videoSdp; videoSdp = VideoSdpBuilder.buildSdpOfferWithOrientation( getVideoPlayer().getSupportedVideoCodecs(), getVideoPlayer().getLocalRtpPort()); return \"v=0\" + SipUtils.CRLF + \"o=- \" + ntpTime + \" \" + ntpTime + \" \" + SdpUtils.formatAddressType(ipAddress) + SipUtils.CRLF + \"s=-\" + SipUtils.CRLF + \"c=\" + SdpUtils.formatAddressType(ipAddress) + SipUtils.CRLF + \"t=0 0\" + SipUtils.CRLF + audioSdp + \"a=sendrcv\" + SipUtils.CRLF + videoSdp + \"a=sendrcv\" + SipUtils.CRLF; } catch (RemoteException e) { if (logger.isActivated()) { logger.error(\"Add video has failed\", e); } \/\/ Unexpected error handleError(new IPCallError(IPCallError.UNEXPECTED_EXCEPTION, e.getMessage())); return null; } }","old_code_raw":"\tprivate String buildAddVideoSdpProposal() {\n\t\tif (logger.isActivated()) {\n\t\t\tlogger.info(\"buildAddVideoSdpProposal()\");\n\t\t}\n\n\t\tString sdp = \"\";\n\t\ttry {\n\t\t\tif ((getVideoPlayer() == null)\n\t\t\t\t\t|| (getVideoPlayer().getMediaCodec() == null)) {\n\t\t\t\thandleError(new IPCallError(IPCallError.UNSUPPORTED_VIDEO_TYPE,\n\t\t\t\t\t\t\"Video codec not selected\"));\n\t\t\t} \n\t\t\telse if ((getVideoRenderer() == null)\n\t\t\t\t\t|| (getVideoRenderer().getMediaCodec() == null)) {\n\t\t\t\thandleError(new IPCallError(IPCallError.UNSUPPORTED_VIDEO_TYPE,\n\t\t\t\t\t\t\"Video codec not selected\"));\n\t\t\t} \n\t\t\telse {\n\t\t\t\t\/\/ Build SDP part\n\t\t\t\tString ntpTime = SipUtils.constructNTPtime(System\n\t\t\t\t\t\t.currentTimeMillis());\n\t\t\t\tString ipAddress = getDialogPath().getSipStack()\n\t\t\t\t\t\t.getLocalIpAddress();\n\t\t\t\n\t\t\t\tlogger.warn(\"Build audio sdp\");\n\t\t\t\tgetAudioPlayer().getLocalRtpPort();\n\t\t\t\tString audioSdp = AudioSdpBuilder.buildSdp(getAudioPlayer().getSupportedAudioCodecs(), getAudioPlayer().getLocalRtpPort());\n\t\t\t\t\n\t\t\t\tlogger.warn(\"Build video sdp\");\n\t\t\t\tString videoSdp;\n\t\t\t\tvideoSdp = VideoSdpBuilder.buildSdpWithOrientationExtension(\n\t\t\t\t\t\tgetVideoPlayer().getSupportedMediaCodecs(),\n\t\t\t\t\t\tgetVideoPlayer().getLocalRtpPort());\n\t\t\t\t\n\t\t\t\tsdp = \"v=0\" + SipUtils.CRLF + \"o=- \" + ntpTime + \" \" + ntpTime\n\t\t\t\t\t\t+ \" \" + SdpUtils.formatAddressType(ipAddress)\n\t\t\t\t\t\t+ SipUtils.CRLF + \"s=-\" + SipUtils.CRLF + \"c=\"\n\t\t\t\t\t\t+ SdpUtils.formatAddressType(ipAddress) + SipUtils.CRLF\n\t\t\t\t\t\t+ \"t=0 0\" + SipUtils.CRLF + audioSdp + \"a=sendrcv\"\n\t\t\t\t\t\t+ SipUtils.CRLF + videoSdp + \"a=sendrcv\"\n\t\t\t\t\t\t+ SipUtils.CRLF;\n\n\t\t\t}\n\t\t} catch (RemoteException e) {\n\t\t\tif (logger.isActivated()) {\n\t\t\t\tlogger.error(\"Add Video has failed\", e);\n\t\t\t}\n\n\t\t\t\/\/ Unexpected error\n\t\t\thandleError(new IPCallError(IPCallError.UNEXPECTED_EXCEPTION,\n\t\t\t\t\te.getMessage()));\n\t\t}\n\n\t\treturn sdp;\n\t}\n","new_comment_raw":"Build SDP proposal to add video stream in the session","old_comment_raw":"Build sdp proposal for addVideo","label":1,"pre_label":0,"AST_level":26,"line_counts":37,"new_code_token_num":247},{"new_code_raw":"protected static Serializable deserializeTime(ByteArrayInputStream inputStream) throws IOException { \/\/ Times are stored as an integer as `HHMMSS`, so we need to split out the digits ... int value = inputStream.readInteger(3); int[] split = split(value, 100, 3); int hours = split[2]; int minutes = split[1]; int seconds = split[0]; return Duration.ofHours(hours).plusMinutes(minutes).plusSeconds(seconds); }","old_code_raw":"    protected static Serializable deserializeTime(ByteArrayInputStream inputStream) throws IOException {\n        \/\/ Times are stored as an integer as `HHMMSS`, so we need to split out the digits ...\n        int value = inputStream.readInteger(3);\n        int[] split = split(value, 100, 3);\n        int hours = split[2];\n        int minutes = split[1];\n        int seconds = split[0];\n        int nanoOfSecond = 0; \/\/ This version does not support fractional seconds\n        return LocalTime.of(hours, minutes, seconds, nanoOfSecond);\n    }\n","new_comment_raw":"Converts a MySQL  TIME value without fractional seconds to a  java.time.Duration.","old_comment_raw":"Converts a MySQL TIME value without fractional seconds to a LocalTime.","label":1,"pre_label":0,"AST_level":7,"line_counts":10,"new_code_token_num":88},{"new_code_raw":"public RelOptCost getNonCumulativeCost(RelNode rel) { for (;;) { try { return nonCumulativeCostHandler.getNonCumulativeCost(rel, this); } catch (JaninoRelMetadataProvider.NoHandler e) { nonCumulativeCostHandler = metadataProvider.revise(e.relClass, BuiltInMetadata.NonCumulativeCost.DEF); } } }","old_code_raw":"  public RelOptCost getNonCumulativeCost(RelNode rel) {\n    final BuiltInMetadata.NonCumulativeCost metadata =\n        rel.metadata(BuiltInMetadata.NonCumulativeCost.class, this);\n    return metadata.getNonCumulativeCost();\n  }\n","new_comment_raw":"Returns the  BuiltInMetadata.NonCumulativeCost#getNonCumulativeCost() statistic.","old_comment_raw":"Returns the BuiltInMetadata.NonCumulativeCost#getNonCumulativeCost() statistic.","label":0,"pre_label":1,"AST_level":10,"line_counts":11,"new_code_token_num":48},{"new_code_raw":"protected static String getTargetText(Target target) { if (target != null) { if (target.getStartNode() != null) { return getNodeText(target.getStartNode()); } else if (target.getContext() != null) { return Constant.messages.getString(\"context.prefixName\", target.getContext().getName()); } else if (target.isInScopeOnly()) { return Constant.messages.getString(\"context.allInScope\"); } } return null; }","old_code_raw":"\tprotected static String getTargetText(Target target) {\n\t\tif (target != null) {\n\t\t\tif (target.getStartNode() != null && target.getStartNode().getHistoryReference() != null) {\n\t\t\t\treturn target.getStartNode().getHistoryReference().getURI().toString();\n\t\t\t} else if (target.getContext() != null) {\n\t\t\t\treturn Constant.messages.getString(\"context.prefixName\", target.getContext().getName());\n\t\t\t} else if (target.isInScopeOnly()) {\n\t\t\t\treturn Constant.messages.getString(\"context.allInScope\");\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n","new_comment_raw":"Returns the text representation of the given  target.","old_comment_raw":"Returns the text representation of the given target.","label":0,"pre_label":1,"AST_level":11,"line_counts":13,"new_code_token_num":93},{"new_code_raw":"public VisualItem findItem(Point p) { Point2D p2 = (m_itransform==null ? p : m_itransform.transform(p, m_tmpPoint)); synchronized (m_registry) { Iterator items = m_registry.getItemsReversed(); while (items.hasNext()) { VisualItem vi = (VisualItem) items.next(); Renderer r = vi.getRenderer(); if (r != null && r.locatePoint(p2, vi)) { return vi; } } } return null; } \/\/","old_code_raw":"\tpublic GraphItem findItem(Point p) {\n        Point2D p2 = (m_itransform==null ? p : \n                        m_itransform.transform(p, m_tmpPoint));\n\t\tsynchronized (m_registry) {\n\t\t\tIterator items = m_registry.getItemsReversed();\n\t\t\twhile (items.hasNext()) {\n\t\t\t\tGraphItem gi = (GraphItem) items.next();\n\t\t\t\tRenderer r = gi.getRenderer();\n\t\t\t\tif (r != null && r.locatePoint(p2, gi)) {\n\t\t\t\t\treturn gi;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t} \/\/\n","new_comment_raw":"Returns the VisualItem located at the given point.","old_comment_raw":"Returns the GraphItem located at the given point.","label":1,"pre_label":0,"AST_level":9,"line_counts":17,"new_code_token_num":90},{"new_code_raw":"public static long nextPowerOfTwo(long value) { if (!isPowerOfTwo(value)) { value--; value |= value >> 1; value |= value >> 2; value |= value >> 4; value |= value >> 8; value |= value >> 16; value |= value >> 32; value++; } return value; }","old_code_raw":"    public static long nextPowerOfTwo(final long value) {\n        return 1L << (64 - Long.numberOfLeadingZeros(value - 1));\n    }\n","new_comment_raw":"Returns the next power of two that is larger than the specified long value.","old_comment_raw":"Fast method of finding the next power of 2 greater than or equal to the supplied value.","label":1,"pre_label":0,"AST_level":8,"line_counts":15,"new_code_token_num":61},{"new_code_raw":"public Iterable<RelNode> getRels() { return new Iterable<RelNode>() { public Iterator<RelNode> iterator() { return Linq4j.asEnumerable(set.rels) .where( new Predicate1<RelNode>() { public boolean apply(RelNode v1) { return v1.getTraitSet().satisfies(traitSet); } }) .iterator(); } }; }","old_code_raw":"  public Iterable<RelNode> getRels() {\n    return new Iterable<RelNode>() {\n      public Iterator<RelNode> iterator() {\n        return Linq4j.asEnumerable(set.rels)\n            .where(\n                new Predicate1<RelNode>() {\n                  public boolean apply(RelNode v1) {\n                    return v1.getTraitSet().subsumes(traitSet);\n                  }\n                })\n            .iterator();\n      }\n    };\n  }\n","new_comment_raw":"Returns the rel nodes in this rel subset.","old_comment_raw":"Returns the rel nodes in this rel subset.","label":0,"pre_label":1,"AST_level":14,"line_counts":15,"new_code_token_num":65},{"new_code_raw":"public org.apache.poi.ss.usermodel.Workbook transformXLS(InputStream is, Map beanParams) throws ParsePropertyException, InvalidFormatException { org.apache.poi.ss.usermodel.Workbook hssfWorkbook = null; try { hssfWorkbook = WorkbookFactory.create(is); transformWorkbook(hssfWorkbook, beanParams); } catch (IOException e) { e.printStackTrace(); } return hssfWorkbook; }","old_code_raw":"    public HSSFWorkbook transformXLS(InputStream is, Map beanParams) throws ParsePropertyException {\n        HSSFWorkbook hssfWorkbook = null;\n        try {\n            POIFSFileSystem fs = new POIFSFileSystem(is);\n            hssfWorkbook = new HSSFWorkbook(fs);\n            transformWorkbook(hssfWorkbook, beanParams);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return hssfWorkbook;\n    }\n","new_comment_raw":"Creates Workbook instance based on .xls template from a given InputStream and a number of beans","old_comment_raw":"Creates HSSFWorkbook instance based on .xls template from a given InputStream and a number of beans","label":1,"pre_label":0,"AST_level":9,"line_counts":12,"new_code_token_num":62},{"new_code_raw":"public boolean isConnected(Integer channelId) { synchronized (wsProxies) { if (wsProxies.containsKey(channelId)) { return wsProxies.get(channelId).isConnected(); } } return false; }","old_code_raw":"\tpublic boolean isConnected(HttpMessage handshakeMessage) {\n\t\tint historyId = handshakeMessage.getHistoryRef().getHistoryId();\n\t\tfor (Entry<Integer, WebSocketProxy> entry : wsProxies.entrySet()) {\n\t\t\tWebSocketProxy proxy = entry.getValue();\n\t\t\tif (historyId == proxy.getHandshakeReference().getHistoryId()) {\n\t\t\t\treturn proxy.isConnected();\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n","new_comment_raw":"Returns true if given channel id is connected.","old_comment_raw":"Returns true if the WebSocket connection that followed the given","label":1,"pre_label":0,"AST_level":8,"line_counts":9,"new_code_token_num":38},{"new_code_raw":"public int getDays() { return getPeriodType().getIndexedField(this, PeriodType.DAY_INDEX); }","old_code_raw":"    public int getDays() {\n        return getPeriodType().getDays(this);\n    }\n","new_comment_raw":"Gets the days field part of the period.","old_comment_raw":"Gets the days field part of the period.","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":19},{"new_code_raw":"private String prepareQueryString(String groupPath, String jobName, Properties options) { List<NameValuePair> parameters = new ArrayList<NameValuePair>(); parameters.add(new BasicNameValuePair(\"groupPath\", groupPath)); parameters.add(new BasicNameValuePair(\"jobName\", jobName)); if (options != null) { for (Entry<Object, Object> option : options.entrySet()) { parameters.add(new BasicNameValuePair(\"extra.command.option.\" + option.getKey(), String.valueOf(option.getValue()))); } } return URLEncodedUtils.format(parameters, HTTP.UTF_8); }","old_code_raw":"    private NameValuePair[] prepareQueryString(String groupPath, String jobName, Properties options) {\n        List<NameValuePair> queryString = new ArrayList<NameValuePair>();\n\n        queryString.add(new NameValuePair(\"groupPath\", groupPath));\n        queryString.add(new NameValuePair(\"jobName\", jobName));\n\n        if (options != null) {\n            StringBuilder argString = new StringBuilder();\n            for (Entry<Object, Object> option : options.entrySet()) {\n                String key = String.valueOf(option.getKey());\n                String value = String.valueOf(option.getValue());\n                if (StringUtils.isNotBlank(key) && StringUtils.isNotBlank(value)) {\n                    \/\/ for rundeck 1.1, we need 1 argument per option\n                    queryString.add(new NameValuePair(\"extra.command.option.\" + key, value));\n\n                    \/\/ for rundeck 1.2, we need a single argument (extra.argString) with all options\n                    \/\/ format is : \"-key1 value1 -key2 'this is value 2 with spaces'\"\n                    if (argString.length() > 0) {\n                        argString.append(\" \");\n                    }\n                    argString.append(\"-\").append(key);\n                    argString.append(\" \");\n                    if (value.indexOf(\" \") >= 0\n                        && !(0 == value.indexOf(\"'\") && (value.length() - 1) == value.lastIndexOf(\"'\"))) {\n                        argString.append(\"'\").append(value).append(\"'\");\n                    } else {\n                        argString.append(value);\n                    }\n                }\n            }\n            queryString.add(new NameValuePair(\"extra.argString\", argString.toString()));\n        }\n\n        return queryString.toArray(new NameValuePair[queryString.size()]);\n    }\n","new_comment_raw":"prepares an url-encoded HTTP queryString containing the group\/job and the options.","old_comment_raw":"prepare the HttpClient's queryString containing the group\/job and the options.","label":1,"pre_label":0,"AST_level":11,"line_counts":17,"new_code_token_num":113},{"new_code_raw":"public boolean scroll(int direction, boolean allTheWay) { final ArrayList<View> viewList = RobotiumUtils. removeInvisibleViews(viewFetcher.getAllViews(true)); @SuppressWarnings(\"unchecked\") ArrayList<View> views = RobotiumUtils.filterViewsToSet(new Class[] { ListView.class, ScrollView.class, GridView.class, WebView.class}, viewList); View view = viewFetcher.getFreshestView(views); if (view == null) { view = getRecyclerView(viewList); if(view == null){ return false; } } if (view instanceof AbsListView) { return scrollList((AbsListView)view, direction, allTheWay); } if(view instanceof WebView){ return scrollWebView((WebView)view, direction, allTheWay); } if (allTheWay) { scrollViewAllTheWay(view, direction); return false; } else { return scrollView(view, direction); } }","old_code_raw":"\tpublic boolean scroll(int direction, boolean allTheWay) {\n\t\tfinal ArrayList<View> viewList = RobotiumUtils.\n\t\t\t\tremoveInvisibleViews(viewFetcher.getAllViews(true));\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tArrayList<View> views = RobotiumUtils.filterViewsToSet(new Class[] { ListView.class,\n\t\t\t\tScrollView.class, GridView.class, WebView.class}, viewList);\n\t\tView view = viewFetcher.getFreshestView(views);\n\t\t\n\t\tif (view == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tif (view instanceof AbsListView) {\n\t\t\treturn scrollList((AbsListView)view, direction, allTheWay);\n\t\t}\n\n\t\tif (view instanceof ScrollView) {\n\t\t\tif (allTheWay) {\n\t\t\t\tscrollScrollViewAllTheWay((ScrollView) view, direction);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn scrollScrollView((ScrollView)view, direction);\n\t\t\t}\n\t\t}\n\t\tif(view instanceof WebView){\n\t\t\treturn scrollWebView((WebView)view, direction, allTheWay);\n\t\t}\n\t\treturn false;\n\t}\n","new_comment_raw":"Scrolls up and down.","old_comment_raw":"Scrolls up and down.","label":0,"pre_label":1,"AST_level":9,"line_counts":33,"new_code_token_num":160},{"new_code_raw":"public static boolean isVisibleInExplain(RelNode rel, SqlExplainLevel explainLevel) { final BuiltInMetadata.ExplainVisibility metadata = rel.metadata(BuiltInMetadata.ExplainVisibility.class); Boolean b = metadata.isVisibleInExplain(explainLevel); return b == null || b; }","old_code_raw":"  public static boolean isVisibleInExplain(\n      RelNode rel,\n      SqlExplainLevel explainLevel) {\n    Boolean b =\n        (Boolean) rel.getCluster().getMetadataProvider().getRelMetadata(\n            rel,\n            \"isVisibleInExplain\",\n            new Object[]{explainLevel});\n    if (b == null) {\n      return true;\n    } else {\n      return b;\n    }\n  }\n","new_comment_raw":"Returns the  BuiltInMetadata.ExplainVisibility#isVisibleInExplain(SqlExplainLevel) statistic.","old_comment_raw":"Determines whether a relational expression should be visible in EXPLAIN","label":1,"pre_label":0,"AST_level":7,"line_counts":9,"new_code_token_num":40},{"new_code_raw":"public DurationType getDurationType(Object object, boolean precise) { ReadableTimePeriod period = (ReadableTimePeriod) object; if (precise) { if (period.getDurationType().isPrecise()) { return period.getDurationType(); } else { return DurationType.getPreciseAllType(); } } return period.getDurationType(); }","old_code_raw":"    public DurationType getDurationType(Object object, boolean precise) {\n        return DurationType.getPreciseAllType();\n    }\n","new_comment_raw":"Selects a suitable duration type for the given object.","old_comment_raw":"Selects a suitable duration type for the given object.","label":0,"pre_label":1,"AST_level":8,"line_counts":12,"new_code_token_num":58},{"new_code_raw":"public boolean available() { return 0 < glTextureID; }","old_code_raw":"  public boolean available()  {\n    return 0 < glTextureID[0];\n  }\n","new_comment_raw":"Returns true if the texture has been initialized.","old_comment_raw":"Returns true if the texture has been initialized.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":11},{"new_code_raw":"public static SchemaRefreshMode parse(String value) { if (value == null) return null; value = value.trim(); for (SchemaRefreshMode option : SchemaRefreshMode.values()) { if (option.getValue().equalsIgnoreCase(value)) return option; } return null; }","old_code_raw":"        public static TopicSelectionStrategy parse(String value) {\n            if (value == null) return null;\n            value = value.trim();\n            for (TopicSelectionStrategy option : TopicSelectionStrategy.values()) {\n                if (option.getValue().equalsIgnoreCase(value)) return option;\n            }\n            return null;\n        }\n","new_comment_raw":"Determine if the supplied value is one of the predefined options.","old_comment_raw":"Determine if the supplied value is one of the predefined options.","label":0,"pre_label":1,"AST_level":8,"line_counts":9,"new_code_token_num":53},{"new_code_raw":"CloseableReference<Bitmap> createBitmap(short width, short height) { CloseableReference<PooledByteBuffer> jpgRef = mJpegGenerator.generate(width, height); try { CloseableReference<Bitmap> bitmapRef = decodeJPEGFromPooledByteBuffer(jpgRef, jpgRef.get().size()); Bitmap underlying = bitmapRef.get(); for (int x = 0; x < underlying.getWidth(); x++) { for (int y = 0; y < underlying.getHeight(); y++) { underlying.setPixel(x, y, Color.TRANSPARENT); } } return bitmapRef; } finally { jpgRef.close(); } }","old_code_raw":"  CloseableReference<Bitmap> createBitmap(short width, short height) {\n    CloseableReference<PooledByteBuffer> jpgRef = mJpegGenerator.generate(width, height);\n    try {\n      return decodeJPEGFromPooledByteBuffer(jpgRef, jpgRef.get().size());\n    } finally {\n      jpgRef.close();\n    }\n  }\n","new_comment_raw":"Creates a bitmap of the specified width and height.","old_comment_raw":"Creates a bitmap of the specified width and height.","label":0,"pre_label":1,"AST_level":10,"line_counts":17,"new_code_token_num":107},{"new_code_raw":"private static String literalValue(RexLiteral literal) { Object value = literal.getValue2(); return String.valueOf(value); }","old_code_raw":"    private static String literalValue(RexLiteral literal) {\n      Object value = literal.getValue2();\n      StringBuilder buf = new StringBuilder();\n      buf.append(value);\n      return buf.toString();\n    }\n","new_comment_raw":"Convert the value of a literal to a string.","old_comment_raw":"Convert the value of a literal to a string.","label":0,"pre_label":1,"AST_level":5,"line_counts":5,"new_code_token_num":24},{"new_code_raw":"public User getOwner() { return owner; }","old_code_raw":"    public Person getOwner() {\n        return owner;\n    }\n","new_comment_raw":"Gets the  User that owns the page","old_comment_raw":"Gets the Person that owns the page","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":10},{"new_code_raw":"public ApiResponse<String> loginUserWithHttpInfo(String username, String password) throws ApiException { okhttp3.Call localVarCall = loginUserValidateBeforeCall(username, password, null, null); Type localVarReturnType = new TypeToken<String>(){}.getType(); return localVarApiClient.execute(localVarCall, localVarReturnType); }","old_code_raw":"    public ApiResponse<String> loginUserWithHttpInfo(String username, String password) throws ApiException {\n        okhttp3.Call call = loginUserValidateBeforeCall(username, password, null, null);\n        Type localVarReturnType = new TypeToken<String>(){}.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n","new_comment_raw":"Logs user into the system","old_comment_raw":"Logs user into the system","label":0,"pre_label":1,"AST_level":8,"line_counts":6,"new_code_token_num":51},{"new_code_raw":"public final ProviderDescriptor getDescriptor() { return mDescriptor; }","old_code_raw":"    public final RouteProviderDescriptor getDescriptor() {\n        return mDescriptor;\n    }\n","new_comment_raw":"Gets the provider's descriptor.","old_comment_raw":"Gets the current route provider descriptor.","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":11},{"new_code_raw":"public Float getRightValue() { return rightValue; }","old_code_raw":"        public float getRightValue() {\n            return rightValue == null ? 0 : rightValue.floatValue();\n        }\n","new_comment_raw":"Gets the 'right' attributes value in current units.","old_comment_raw":"Gets the 'right' CSS-attributes value in specified units.","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":10},{"new_code_raw":"public List<Media> getMedia() { return this.media; }","old_code_raw":"    public List<Image> getMedia() {\n        return this.media;\n    }\n","new_comment_raw":"Media items","old_comment_raw":"Image items","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":12},{"new_code_raw":"public static Criterion ilike(String propertyName, Object value) { if ( value == null ) { throw new IllegalArgumentException( \"Comparison value passed to ilike cannot be null\" ); } return ilike( propertyName, value.toString(), MatchMode.EXACT ); }","old_code_raw":"\tpublic static Criterion ilike(String propertyName, Object value) {\n\t\tif ( value == null ) {\n\t\t\tthrow new IllegalArgumentException( \"Comparison value passed to ilike cannot be null\" );\n\t\t}\n\t\treturn ilike( propertyName, value.toString(), MatchMode.ANYWHERE );\n\t}\n","new_comment_raw":"A case-insensitive \"like\", similar to Postgres ilike operator","old_comment_raw":"A case-insensitive \"like\", similar to Postgres ilike operator","label":0,"pre_label":1,"AST_level":7,"line_counts":7,"new_code_token_num":50},{"new_code_raw":"public String applyClassNamingPolicy(String input) { if (input != null && input.length() > 0) { if (\"string\".equalsIgnoreCase(input)) { return \"string\"; } String output = input.substring(0, 1).toUpperCase() + input.substring(1); \/\/ class name can't have . so if dot exists remove the same output = output.replace(\".\", \"\"); return output; } else { throw new CodeGenerationException(\"Error converting input to first letter caps becuase of null or empty input\"); } }","old_code_raw":"  public String applyClassNamingPolicy(String input) {\n    if (input != null && input.length() > 0) {\n      String output = input.substring(0, 1).toUpperCase() + input.substring(1);\n      \/\/ class name can't have . so if dot exists remove the same\n      output = output.replace(\".\", \"\");\n      \n      return output;\n    }\n    else {\n      throw new CodeGenerationException(\"Error converting input to first letter caps becuase of null or empty input\");\n    }\n  }\n","new_comment_raw":"Converts the first character of the input into upper case .","old_comment_raw":"Converts the first character of the input into upper case .","label":0,"pre_label":1,"AST_level":9,"line_counts":17,"new_code_token_num":113},{"new_code_raw":"private boolean isShareable() { return getRequestScope().getDictionary().isShareable(obj.getClass()); }","old_code_raw":"    private boolean isShareable() {\n        return getRequestScope().getDictionary().isSharable(obj.getClass());\n    }\n","new_comment_raw":"Checks if this persistent resource's underlying entity is shareable.","old_comment_raw":"Checks if this persistent resource's underlying entity is sharable.","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":22},{"new_code_raw":"public CometSupport defaultCometSupport(final boolean preferBlocking) { if (!preferBlocking && testClassExists(SERVLET_30)) { if (detectWebSocketPresent().size() > 0) { return new Servlet30CometSupportWithWebSocket(config); } return new Servlet30CometSupport(config); } else { return new BlockingIOCometSupport(config); } }","old_code_raw":"    public CometSupport defaultCometSupport(final boolean preferBlocking) {\n        if (!preferBlocking && testClassExists(SERVLET_30)) {\n            return new Servlet30CometSupport(config);\n        } else {\n            return new BlockingIOCometSupport(config);\n        }\n    }\n","new_comment_raw":"This method is used to determine the default CometSupport if all else fails","old_comment_raw":"This method is used to determine the default CometSupport if all else fails","label":0,"pre_label":1,"AST_level":9,"line_counts":11,"new_code_token_num":59},{"new_code_raw":"public int compareTo(IndexedWord w) { if (this.equals(IndexedWord.NO_WORD)) { if (w.equals(IndexedWord.NO_WORD)) { return 0; } else { return -1; } } if (w.equals(IndexedWord.NO_WORD)) { return 1; } \/\/ Override the default comparator if pseudo-positions are set. \/\/ This is needed for splicing trees together awkwardly in OpenIE. if (!Double.isNaN(w.pseudoPosition) || !Double.isNaN(this.pseudoPosition)) { double val = this.pseudoPosition() - w.pseudoPosition(); if (val < 0) { return -1; } if (val > 0) { return 1; } else { return 0; } } \/\/ Otherwise, compare using the normal doc\/sentence\/token index hierarchy String docID = this.getString(CoreAnnotations.DocIDAnnotation.class); int docComp = docID.compareTo(w.getString(CoreAnnotations.DocIDAnnotation.class)); if (docComp != 0) return docComp; int sentComp = Integer.compare(sentIndex(), w.sentIndex()); if (sentComp != 0) return sentComp; int indexComp = Integer.compare(index(), w.index()); if (indexComp != 0) return indexComp; return Integer.compare(copyCount(), w.copyCount()); }","old_code_raw":"  public int compareTo(IndexedWord w) {\n    if (this.equals(IndexedWord.NO_WORD)) {\n      if (w.equals(IndexedWord.NO_WORD)) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n    if (w.equals(IndexedWord.NO_WORD)) {\n      return 1;\n    }\n\n    \/\/ Override the default comparator if pseudo-positions are set.\n    \/\/ This is needed for splicing trees together awkwardly in OpenIE.\n    if (!Double.isNaN(w.pseudoPosition) || !Double.isNaN(this.pseudoPosition)) {\n      double val = this.pseudoPosition() - w.pseudoPosition();\n      if (val < 0) { return -1; }\n      if (val > 0) { return 1; }\n      else { return 0; }\n    }\n\n    \/\/ Otherwise, compare using the normal doc\/sentence\/token index hierarchy\n    String docID = this.getString(CoreAnnotations.DocIDAnnotation.class);\n    int docComp = docID.compareTo(w.getString(CoreAnnotations.DocIDAnnotation.class));\n    if (docComp != 0) return docComp;\n\n    int sentComp = sentIndex() - w.sentIndex();\n    if (sentComp != 0) return sentComp;\n\n    int indexComp = index() - w.index();\n    if (indexComp != 0) return indexComp;\n\n    return copyCount() - w.copyCount();\n  }\n","new_comment_raw":"NOTE: For this compareTo, you must have a DocIDAnnotation,","old_comment_raw":"NOTE: This compareTo is based on and made to be compatible with the one from IndexedFeatureLabel.","label":1,"pre_label":0,"AST_level":9,"line_counts":35,"new_code_token_num":249},{"new_code_raw":"public boolean hasCorrelation() { return !mapCorToCorRel.isEmpty(); }","old_code_raw":"    public boolean hasCorrelation() {\n      return !mapCorVarToCorRel.isEmpty();\n    }\n","new_comment_raw":"Returns whether there are any correlating variables in this statement.","old_comment_raw":"Returns whether there are any correlating variables in this statement.","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":14},{"new_code_raw":"static public ContentionManager getContentionManager() { return cm; }","old_code_raw":"    static public ContentionManager getContentionManager() {\n        ThreadState threadState = BaseTask.getThreadState();\n        return threadState.manager();\n    }\n","new_comment_raw":"Gets the contention manager","old_comment_raw":"Gets the contention manager of the invoking Thread.","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":11},{"new_code_raw":"public boolean isEmergencyAlertMessage() { return mSmsCbMessage.isEmergencyMessage(); }","old_code_raw":"    public boolean isEmergencyAlertMessage() {\n        if (!mSmsCbMessage.isEmergencyMessage()) {\n            return false;\n        }\n        SmsCbCmasInfo cmasInfo = mSmsCbMessage.getCmasWarningInfo();\n        if (cmasInfo != null &&\n                cmasInfo.getMessageClass() == SmsCbCmasInfo.CMAS_CLASS_CHILD_ABDUCTION_EMERGENCY) {\n            return false;\n        }\n        return true;\n    }\n","new_comment_raw":"Returns whether the broadcast is an emergency (PWS) message type, including test messages and AMBER alerts.","old_comment_raw":"Returns whether the broadcast is an emergency (PWS) message type, including test messages, but excluding lower priority Amber alert broadcasts.","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":13},{"new_code_raw":"protected int getNewForOldInput(int oldOrdinal) { return getNewFieldForOldInput(oldOrdinal).i; }","old_code_raw":"  protected int getNewForOldInput(int oldOrdinal) {\n    assert currentRel != null;\n    int newOrdinal = 0;\n\n    \/\/ determine which input rel oldOrdinal references, and adjust\n    \/\/ oldOrdinal to be relative to that input rel\n    RelNode oldInput = null;\n    for (RelNode oldInput1 : currentRel.getInputs()) {\n      RelDataType oldInputType = oldInput1.getRowType();\n      int n = oldInputType.getFieldCount();\n      if (oldOrdinal < n) {\n        oldInput = oldInput1;\n        break;\n      }\n      RelNode newInput = getNewForOldRel(oldInput1);\n      newOrdinal += newInput.getRowType().getFieldCount();\n      oldOrdinal -= n;\n    }\n    assert oldInput != null;\n\n    RelDataType oldInputType = oldInput.getRowType();\n    newOrdinal += calculateFlattenedOffset(oldInputType, oldOrdinal);\n    return newOrdinal;\n  }\n","new_comment_raw":"Maps the ordinal of a field pre-flattening to the ordinal of the corresponding field post-flattening.","old_comment_raw":"Maps the ordinal of a field pre-flattening to the ordinal of the corresponding field post-flattening, and optionally returns its type.","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":16},{"new_code_raw":"public String[] createText(MilStd2525TacticalGraphic graphic) { String[] result; String functionId = graphic.getFunctionId(); if (CircularFireSupportArea.FUNCTION_ID_TARGET.equals(functionId)) { result = new String[] { graphic.getText() }; } else { boolean useSeparateTimeLabel = this.isShowSeparateTimeLabel(functionId); String mainText = this.createMainText(graphic, functionId, !useSeparateTimeLabel); if (useSeparateTimeLabel) { String timeText = this.createTimeRangeText(graphic); result = new String[] { mainText, timeText }; } else { result = new String[] { mainText }; } } return result; }","old_code_raw":"    public String createText(MilStd2525TacticalGraphic graphic)\n    {\n        String functionId = graphic.getFunctionId();\n        if (CircularFireSupportArea.FUNCTION_ID_TARGET.equals(functionId))\n            return graphic.getText();\n        else\n            return createDateRangeText(graphic, functionId);\n    }\n","new_comment_raw":"Construct the text for labels in a Fire Support area graphic.","old_comment_raw":"Construct the text for the main label of a graphic.","label":1,"pre_label":0,"AST_level":11,"line_counts":28,"new_code_token_num":110},{"new_code_raw":"public Constructor[] getDeclaredConstructors() throws SecurityException { \/\/ BEGIN android-note \/\/ trying to get closer to the RI which returns a raw constructor array. \/\/ copied from newer version of harmony \/\/ END android-note checkDeclaredMemberAccess(); return getDeclaredConstructors(this, false); }","old_code_raw":"    public Constructor<T>[] getDeclaredConstructors() throws SecurityException {\n        checkDeclaredMemberAccess();\n        return getDeclaredConstructors(this, false);\n    }\n","new_comment_raw":"Returns an array containing  Constructor objects for all constructors declared in the class represented by this  Class.","old_comment_raw":"Returns an array containing Constructor objects describing all constructor which are defined by the receiver.","label":1,"pre_label":0,"AST_level":5,"line_counts":10,"new_code_token_num":58},{"new_code_raw":"public int compareTo(ByteArrayWritable that) { return WritableComparator.compareBytes(this.data, this.offset, this.length, that.data, that.offset, that.length); }","old_code_raw":"    public int compareTo(final byte[] that) {\n        return WritableComparator.compareBytes(this.data, this.offset, this.length, that, 0, that.length);\n    }\n","new_comment_raw":"Define the sort order of the BytesWritable.","old_comment_raw":"Compares the bytes in this object to the specified byte array","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":32},{"new_code_raw":"public static boolean shouldDisplay(Context context) { WelcomeActivityContent fragment = getCurrentFragment(context); return fragment != null; }","old_code_raw":"    public static boolean shouldDisplay(Context context) {\n        WelcomeActivityContent fragment = getCurrentFragment(context);\n        if (fragment == null) {\n            return false;\n        }\n        return true;\n    }\n","new_comment_raw":"Tracks whether to display this activity.","old_comment_raw":"Whether to display the WelcomeActivity.","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":22},{"new_code_raw":"public Hashtable getBuiltInTypes() { Hashtable toReturn = (Hashtable)fBuiltInTypes.clone(); Enumeration xml11Keys = fXML11BuiltInTypes.keys(); while (xml11Keys.hasMoreElements()) { Object key = xml11Keys.nextElement(); toReturn.put(key, fXML11BuiltInTypes.get(key)); } return toReturn; }","old_code_raw":"    @Override\n    public Map<String, DatatypeValidator> getBuiltInTypes() {\n        final HashMap<String, DatatypeValidator> toReturn = new HashMap<>(fBuiltInTypes);\n        toReturn.putAll(XML11BUILTINTYPES);\n        return toReturn;\n    }\n","new_comment_raw":"get all built-in DVs, which are stored in a hashtable keyed by the name","old_comment_raw":"get all built-in DVs, which are stored in a Map keyed by the name","label":1,"pre_label":0,"AST_level":8,"line_counts":11,"new_code_token_num":55},{"new_code_raw":"public Object next() throws java.io.IOException { int zzInput; int zzAction; \/\/ cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; \/\/ set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { \/\/ store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); \/\/ get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } \/\/ store back cached position zzMarkedPos = zzMarkedPosL; if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { return null; } } else { switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { return tokenFactory.makeToken(yytext(), yychar, yylength()); } case 4: break; case 2: { return tokenFactory.makeToken(NEWLINE, yychar, yylength()); } case 5: break; case 3: { } case 6: break; default: zzScanError(ZZ_NO_MATCH); } } } }","old_code_raw":"  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    \/\/ cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n\n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      \/\/ set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n\n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            \/\/ store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            \/\/ get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      \/\/ store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1:\n          { return tokenFactory.makeToken(yytext(), yychar, yylength());\n          }\n        case 4: break;\n        case 2:\n          { return tokenFactory.makeToken(NEWLINE, yychar, yylength());\n          }\n        case 5: break;\n        case 3:\n          {\n          }\n        case 6: break;\n        default:\n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                return null;\n              }\n          }\n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n","new_comment_raw":"Resumes scanning until the next regular expression is matched, the end of input is encountered or an I\/O-Error occurs.","old_comment_raw":"Resumes scanning until the next regular expression is matched, the end of input is encountered or an I\/O-Error occurs.","label":0,"pre_label":1,"AST_level":16,"line_counts":107,"new_code_token_num":420},{"new_code_raw":"public final int getEndLine() { return this.bufline[this.bufpos]; }","old_code_raw":"    public final int getEndLine() {\n        return bufline[bufpos];\n    }\n","new_comment_raw":"Get the line number","old_comment_raw":"DOCUMENT ME!","label":1,"pre_label":0,"AST_level":7,"line_counts":5,"new_code_token_num":16},{"new_code_raw":"public NonLiteral convertNonLiteral(Node node) { if (node == null) { throw new IllegalArgumentException(\"null argument not allowed\"); } if (node.isBlank()) { return convertJenaNode2TriaBlankNode(node); } if (node.isURI()) { return convertJenaUri2UriRef(node); } throw new RuntimeException(\"cannot convert \" + node + \" to NonLiteral\"); }","old_code_raw":"    public BlankNodeOrIri convertNonLiteral(Node node) {\n        if (node == null) {\n            throw new IllegalArgumentException(\"null argument not allowed\");\n        }\n        if (node.isBlank()) {\n            return convertJenaNode2TriaBlankNode(node);\n        }\n        if (node.isURI()) {\n            return convertJenaUri2UriRef(node);\n        }\n        throw new RuntimeException(\"cannot convert \" + node + \" to BlankNodeOrIri\");\n    }\n","new_comment_raw":"Converts a node to a BNode if it is a Blank Node otherwise to a UriRef.","old_comment_raw":"Converts a node to a BlankNode if it is a Blank Node otherwise to a Iri.","label":1,"pre_label":0,"AST_level":7,"line_counts":14,"new_code_token_num":75},{"new_code_raw":"public String fakeOuterStringSerialize(String body) throws ApiException { ApiResponse<String> localVarResp = fakeOuterStringSerializeWithHttpInfo(body); return localVarResp.getData(); }","old_code_raw":"    public String fakeOuterStringSerialize(String body) throws ApiException {\n        ApiResponse<String> resp = fakeOuterStringSerializeWithHttpInfo(body);\n        return resp.getData();\n    }\n","new_comment_raw":"Test serialization of outer string types","old_comment_raw":"Test serialization of outer string types","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":25},{"new_code_raw":"public Object next() throws java.io.IOException { int zzInput; int zzAction; \/\/ cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { \/\/ store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); \/\/ get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } \/\/ store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 38: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } if (normalizeSpace) { \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, yytext()); } case 55: break; case 43: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 9; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 10; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/\/ try to work around an apparent jflex bug where it \/\/ gets a space at the token end by getting \/\/ wrong the length of the trailing context. while (yylength() > 0) { char last = yycharat(yylength()-1); if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) { yypushback(1); } else { break; } } return getNext(); } case 56: break; case 11: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 57: break; case 19: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 58: break; case 8: { return handleQuotes(yytext(), false); } case 59: break; case 35: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), false); } case 60: break; case 27: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 61: break; case 33: \/\/ lookahead expression with fixed lookahead length yypushback(1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 62: break; case 49: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return getNormalizedAmpNext(); } case 63: break; case 36: { return getNormalizedAmpNext(); } case 64: break; case 23: { if (invertible) { prevWordAfter.append(yytext()); } } case 65: break; case 37: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } if (normalizeSpace) { \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, yytext()); } case 66: break; case 53: \/\/ lookahead expression with fixed lookahead length yypushback(4); { return getNext(); } case 67: break; case 46: \/\/ lookahead expression with fixed lookahead length yypushback(2); { return getNext(); } case 68: break; case 42: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 69: break; case 41: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 16; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 17; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 70: break; case 40: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 13; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 71: break; case 3: { return getNext(); } case 72: break; case 24: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return getNext(); } case 73: break; case 51: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } return getNext(txt, yytext()); } case 74: break; case 26: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, origTxt); } case 75: break; case 6: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 76: break; case 29: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 77: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 78: break; case 2: { return getNext(\"<\", yytext()); } case 79: break; case 30: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 80: break; case 18: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 81: break; case 54: { String txt = yytext(); if (normalizeSpace) { \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 82: break; case 50: { yypushback(3) ; return getNext(); } case 83: break; case 25: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), true); } case 84: break; case 39: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 85: break; case 21: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 86: break; case 17: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 87: break; case 13: { return handleEllipsis(yytext()); } case 88: break; case 34: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 1; { \/* invert quote - often but not always right *\/ return handleQuotes(yytext(), true); } case 89: break; case 14: { return normalizeFractions(yytext()); } case 90: break; case 15: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(); } } case 91: break; case 47: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 11; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 12; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 92: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 93: break; case 9: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 94: break; case 45: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 95: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 96: break; case 28: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 97: break; case 48: { if (keepAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 98: break; case 20: { if (normalizeOtherBrackets) { return getNext(\"-RSB-\", yytext()); } else { return getNext(); } } case 99: break; case 12: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 100: break; case 31: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 101: break; case 10: { return getNext(\">\", yytext()); } case 102: break; case 32: { \/\/ this one should only match if we're basically at the end of file \/\/ since the last one matches two things, even newlines String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 103: break; case 22: { if (normalizeOtherBrackets) { return getNext(\"-LSB-\", yytext()); } else { return getNext(); } } case 104: break; case 52: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/\/ try to work around an apparent jflex bug where it \/\/ gets a space at the token end by getting \/\/ wrong the length of the trailing context. while (yylength() > 0) { char last = yycharat(yylength()-1); if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) { yypushback(1); } else { break; } } String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 105: break; case 1: { String str = yytext(); int first = str.charAt(0); String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } LOGGER.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: LOGGER.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 106: break; case 44: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 107: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 108: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }","old_code_raw":"  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    \/\/ cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            \/\/ store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            \/\/ get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          int zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      \/\/ store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 38: \n          { String txt = yytext();\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '\/');\n                  }\n                  if (normalizeSpace) {\n                    \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                    txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n\n                  }\n                  return getNext(txt, yytext());\n          }\n        case 55: break;\n        case 43: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 9;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 10;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { \/\/ try to work around an apparent jflex bug where it\n                          \/\/ gets a space at the token end by getting\n                          \/\/ wrong the length of the trailing context.\n                          while (yylength() > 0) {\n                            char last = yycharat(yylength()-1);\n                            if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) {\n                              yypushback(1);\n                            } else {\n                              break;\n                            }\n                          }\n\t\t\t  return getNext();\n          }\n        case 56: break;\n        case 11: \n          { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 57: break;\n        case 19: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 58: break;\n        case 8: \n          { return handleQuotes(yytext(), false);\n          }\n        case 59: break;\n        case 35: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return handleQuotes(yytext(), false);\n          }\n        case 60: break;\n        case 27: \n          { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n          }\n        case 61: break;\n        case 33: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n          }\n        case 62: break;\n        case 49: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNormalizedAmpNext();\n          }\n        case 63: break;\n        case 36: \n          { return getNormalizedAmpNext();\n          }\n        case 64: break;\n        case 23: \n          { if (invertible) {\n                            prevWordAfter.append(yytext());\n                        }\n          }\n        case 65: break;\n        case 37: \n          { String txt = yytext();\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '\/');\n                  }\n                  if (normalizeSpace) {\n                    \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                    txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                  }\n                  return getNext(txt, yytext());\n          }\n        case 66: break;\n        case 53: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(4);\n          { return getNext();\n          }\n        case 67: break;\n        case 46: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(2);\n          { return getNext();\n          }\n        case 68: break;\n        case 42: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 15;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 14;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 69: break;\n        case 41: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 16;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 17;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 70: break;\n        case 40: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 13;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 14;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 71: break;\n        case 3: \n          { return getNext();\n          }\n        case 72: break;\n        case 24: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext();\n          }\n        case 73: break;\n        case 51: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 74: break;\n        case 26: \n          { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n          }\n        case 75: break;\n        case 6: \n          { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n          }\n        case 76: break;\n        case 29: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 3;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 4;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n          }\n        case 77: break;\n        case 16: \n          { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 78: break;\n        case 2: \n          { return getNext(\"<\", yytext());\n          }\n        case 79: break;\n        case 48: \n          { yypushback(2) ; return getNext();\n          }\n        case 80: break;\n        case 30: \n          { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '\/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 81: break;\n        case 18: \n          { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 82: break;\n        case 54: \n          { String txt = yytext();\n                          if (normalizeSpace) {\n                            \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 83: break;\n        case 50: \n          { yypushback(3) ; return getNext();\n          }\n        case 84: break;\n        case 25: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return handleQuotes(yytext(), true);\n          }\n        case 85: break;\n        case 39: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 5;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 6;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String txt = yytext();\n                          return getNext(removeSoftHyphens(txt),\n                                         txt);\n          }\n        case 86: break;\n        case 21: \n          { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 87: break;\n        case 17: \n          { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 88: break;\n        case 13: \n          { return handleEllipsis(yytext());\n          }\n        case 89: break;\n        case 34: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 1;\n          { \/* invert quote - often but not always right *\/\n                  return handleQuotes(yytext(), true);\n          }\n        case 90: break;\n        case 14: \n          { return normalizeFractions(yytext());\n          }\n        case 91: break;\n        case 15: \n          { if (normalizeCurrency) {\n                            return getNext(normalizeCurrency(yytext()), yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 92: break;\n        case 47: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 11;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 12;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 93: break;\n        case 7: \n          { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n          }\n        case 94: break;\n        case 9: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '\/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 95: break;\n        case 45: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext(removeSoftHyphens(yytext()),\n                                               yytext());\n          }\n        case 96: break;\n        case 4: \n          { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n          }\n        case 97: break;\n        case 28: \n          { return getNext(removeSoftHyphens(yytext()), yytext());\n          }\n        case 98: break;\n        case 20: \n          { if (normalizeOtherBrackets) {\n                    return getNext(\"-RSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 99: break;\n        case 12: \n          { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n          }\n        case 100: break;\n        case 31: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n          }\n        case 101: break;\n        case 10: \n          { return getNext(\">\", yytext());\n          }\n        case 102: break;\n        case 32: \n          { \/\/ this one should only match if we're basically at the end of file\n                          \/\/ since the last one matches two things, even newlines\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 103: break;\n        case 22: \n          { if (normalizeOtherBrackets) {\n                    return getNext(\"-LSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 104: break;\n        case 52: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 7;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 8;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { \/\/ try to work around an apparent jflex bug where it\n                          \/\/ gets a space at the token end by getting\n                          \/\/ wrong the length of the trailing context.\n                          while (yylength() > 0) {\n                            char last = yycharat(yylength()-1);\n                            if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) {\n                              yypushback(1);\n                            } else {\n                              break;\n                            }\n                          }\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 105: break;\n        case 1: \n          { String str = yytext();\n          int first = str.charAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n          }\n        case 106: break;\n        case 44: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 107: break;\n        case 5: \n          { if (tokenizeNLs) {\n                      return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns\n                  } else if (invertible) {\n                      prevWordAfter.append(yytext());\n                  }\n          }\n        case 108: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                if (invertible) {\n            prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            prevWordAfter.setLength(0);\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n          }\n          return null;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n","new_comment_raw":"Resumes scanning until the next regular expression is matched, the end of input is encountered or an I\/O-Error occurs.","old_comment_raw":"Resumes scanning until the next regular expression is matched, the end of input is encountered or an I\/O-Error occurs.","label":0,"pre_label":1,"AST_level":17,"line_counts":702,"new_code_token_num":4305},{"new_code_raw":"public CharSequence getQueryHint() { final CharSequence hint; if (mQueryHint != null) { hint = mQueryHint; } else if (IS_AT_LEAST_FROYO && mSearchable != null && mSearchable.getHintId() != 0) { hint = getContext().getText(mSearchable.getHintId()); } else { hint = mDefaultQueryHint; } return hint; }","old_code_raw":"    public CharSequence getQueryHint() {\n        if (mQueryHint != null) {\n            return mQueryHint;\n        } else if (IS_AT_LEAST_FROYO && mSearchable != null) {\n            CharSequence hint = null;\n            int hintId = mSearchable.getHintId();\n            if (hintId != 0) {\n                hint = getContext().getString(hintId);\n            }\n            return hint;\n        }\n        return null;\n    }\n","new_comment_raw":"Returns the hint text that will be displayed in the query text field.","old_comment_raw":"Gets the hint text to display in the query text field.","label":1,"pre_label":0,"AST_level":10,"line_counts":13,"new_code_token_num":63},{"new_code_raw":"public static XpiDriverService createDefaultService() { try { return new Builder().build(); } catch (WebDriverException e) { throw new IllegalStateException(e.getMessage(), e.getCause()); } }","old_code_raw":"  public static XpiDriverService createDefaultService() {\n    try {\n      return new XpiDriverService.Builder().usingAnyFreePort().build();\n    } catch (WebDriverException e) {\n      throw new IllegalStateException(e.getMessage(), e.getCause());\n    }\n  }\n","new_comment_raw":"Configures and returns a new  XpiDriverService using the default configuration.","old_comment_raw":"Configures and returns a new XpiDriverService using the default configuration.","label":0,"pre_label":1,"AST_level":7,"line_counts":8,"new_code_token_num":42},{"new_code_raw":"public static LobCreator getLobCreator(SessionImplementor session) { return session.getFactory() .getServiceRegistry() .getService( JdbcServices.class ) .getLobCreator( session ); }","old_code_raw":"\tpublic static LobCreator getLobCreator(SessionImplementor session) {\n\t\treturn session.getFactory()\n\t\t\t\t.getJdbcServices()\n\t\t\t\t.getLobCreator( session );\n\t}\n","new_comment_raw":"Obtain a lob creator for the given session.","old_comment_raw":"Obtain a lob creator for the given session.","label":0,"pre_label":1,"AST_level":7,"line_counts":7,"new_code_token_num":28},{"new_code_raw":"public User getUserByName(String username) throws ApiException { return getUserByNameWithHttpInfo(username).getData(); }","old_code_raw":"  public User getUserByName(String username) throws ApiException {\n    Object localVarPostBody = null;\n    \n    \/\/ verify the required parameter 'username' is set\n    if (username == null) {\n      throw new ApiException(400, \"Missing the required parameter 'username' when calling getUserByName\");\n    }\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/user\/{username}\"\n      .replaceAll(\"\\\\{\" + \"username\" + \"\\\\}\", apiClient.escapeString(username.toString()));\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application\/xml\", \"application\/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<User> localVarReturnType = new GenericType<User>() {};\n    return apiClient.invokeAPI(localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"Get user by user name","old_comment_raw":"Get user by user name","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"public final Map<String, String> validateSubDocuments() { final OOXML ooxml = this.getFormatVersion().getXML(); if (!ooxml.canValidate()) return null; final Map<String, String> res = new HashMap<String, String>(); for (final String s : subdocNames) { if (this.getEntries().contains(s)) { final String valid = ooxml.getValidator(this.getDocument(s)).isValid(); if (valid != null) res.put(s, valid); } } return res; }","old_code_raw":"    public final Map<String, String> validateSubDocuments() {\r\n        final OOXML ooxml = OOXML.get(getVersion());\r\n        final Map<String, String> res = new HashMap<String, String>();\r\n        for (final String s : subdocNames) {\r\n            if (this.getEntries().contains(s)) {\r\n                final String valid = ooxml.getValidator(this.getDocument(s)).isValid();\r\n                if (valid != null)\r\n                    res.put(s, valid);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n","new_comment_raw":"Call  Validator#isValid() on each XML subdocuments.","old_comment_raw":"Call OOXML#isValid(Document) on each XML subdocuments.","label":1,"pre_label":0,"AST_level":12,"line_counts":16,"new_code_token_num":103},{"new_code_raw":"public Schema getDefaultSchema() { return this; }","old_code_raw":"  public AbstractSchema getDefaultSchema() {\n    return this;\n  }\n","new_comment_raw":"The schema can be a top level schema which doesn't have its own tables, but refers to one of the default sub schemas for table look up.","old_comment_raw":"The schema can be a top level schema which doesn't have its own tables, but refers to one of the default sub schemas for table look up.","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"public static List<CmdLineOptionValidator.Result> validate( CmdLineArgs cmdLineArgs) { Validate.notNull(cmdLineArgs); List<CmdLineOptionValidator.Result> results = Lists.newArrayList(); for (CmdLineOptionInstance optionInst : cmdLineArgs .getSpecifiedOptions()) { results.addAll(CmdLineUtils.validate(optionInst)); } return results; }","old_code_raw":"   public static Set<CmdLineOptionInstance> validate(CmdLineArgs cmdLineArgs) {\n      Validate.notNull(cmdLineArgs);\n\n      HashSet<CmdLineOptionInstance> optionsFailed = new HashSet<CmdLineOptionInstance>();\n      for (CmdLineOptionInstance optionInst : cmdLineArgs\n            .getSpecifiedOptions()) {\n         if (!CmdLineUtils.validate(optionInst)) {\n            optionsFailed.add(optionInst);\n         }\n      }\n      return optionsFailed;\n   }\n","new_comment_raw":"Runs validation on  CmdLineArgs and returns the validation results.","old_comment_raw":"Runs validation on CmdLineArgs and returns the options which failed validation.","label":1,"pre_label":0,"AST_level":8,"line_counts":13,"new_code_token_num":52},{"new_code_raw":"public Order placeOrder(Order body) throws ApiException { ApiResponse<Order> resp = placeOrderWithHttpInfo(body); return resp.getData(); }","old_code_raw":"  public Order placeOrder(Order body) throws ApiException {\n    Call call = placeOrderCall(body, null, null);\n    Type returnType = new TypeToken<Order>(){}.getType();\n    return apiClient.execute(call, returnType);\n  }\n","new_comment_raw":"Place an order for a pet","old_comment_raw":"Place an order for a pet","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":25},{"new_code_raw":"public ApiResponse uploadFile (Long petId, String additionalMetadata, File file) throws ApiException { Object postBody = null; \/\/ verify the required parameter 'petId' is set if (petId == null) { throw new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFile\"); } \/\/ create path and map variables String path = \"\/pet\/{petId}\/uploadImage\".replaceAll(\"\\\\{format\\\\}\",\"json\").replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiInvoker.escapeString(petId.toString())); \/\/ query params List<Pair> queryParams = new ArrayList<Pair>(); \/\/ header params Map<String, String> headerParams = new HashMap<String, String>(); \/\/ form params Map<String, String> formParams = new HashMap<String, String>(); String[] contentTypes = { \"multipart\/form-data\" }; String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\"; if (contentType.startsWith(\"multipart\/form-data\")) { \/\/ file uploading MultipartEntityBuilder builder = MultipartEntityBuilder.create(); if (additionalMetadata != null) { builder.addTextBody(\"additionalMetadata\", ApiInvoker.parameterToString(additionalMetadata), ApiInvoker.TEXT_PLAIN_UTF8); } if (file != null) { builder.addBinaryBody(\"file\", file); } HttpEntity httpEntity = builder.build(); postBody = httpEntity; } else { \/\/ normal form params formParams.put(\"additionalMetadata\", ApiInvoker.parameterToString(additionalMetadata)); } try { String response = apiInvoker.invokeAPI(basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType); if(response != null){ return (ApiResponse) ApiInvoker.deserialize(response, \"\", ApiResponse.class); } else { return null; } } catch (ApiException ex) { throw ex; } }","old_code_raw":"  public void  uploadFile (Long petId, String additionalMetadata, File file) throws ApiException {\n    Object postBody = null;\n    \n    \/\/ verify the required parameter 'petId' is set\n    if (petId == null) {\n       throw new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFile\");\n    }\n    \n\n    \/\/ create path and map variables\n    String path = \"\/pet\/{petId}\/uploadImage\".replaceAll(\"\\\\{format\\\\}\",\"json\").replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiInvoker.escapeString(petId.toString()));\n\n    \/\/ query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    \/\/ header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    \/\/ form params\n    Map<String, String> formParams = new HashMap<String, String>();\n\n    \n\n    \n\n    String[] contentTypes = {\n      \"multipart\/form-data\"\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\";\n\n    if (contentType.startsWith(\"multipart\/form-data\")) {\n      \/\/ file uploading\n      MultipartEntityBuilder builder = MultipartEntityBuilder.create();\n      \n      if (additionalMetadata != null) {\n        builder.addTextBody(\"additionalMetadata\", ApiInvoker.parameterToString(additionalMetadata), ApiInvoker.TEXT_PLAIN_UTF8);\n      }\n      \n      if (file != null) {\n        builder.addBinaryBody(\"file\", file);\n      }\n      \n\n      HttpEntity httpEntity = builder.build();\n      postBody = httpEntity;\n    } else {\n      \/\/ normal form params\n      formParams.put(\"additionalMetadata\", ApiInvoker.parameterToString(additionalMetadata));\n      \n      \n    }\n\n    try {\n      String response = apiInvoker.invokeAPI(basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType);\n      if(response != null){\n        return ;\n      }\n      else {\n        return ;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n","new_comment_raw":"uploads an image","old_comment_raw":"uploads an image","label":0,"pre_label":1,"AST_level":10,"line_counts":63,"new_code_token_num":369},{"new_code_raw":"@Override public boolean equals(Object other) { if (this == other) { return true; } if (other instanceof PwPair) { PwPair otherPwPair = (PwPair) other; return getRank() == otherPwPair.getRank() && mUrlDevice.equals(otherPwPair.mUrlDevice) && mPwsResult.equals(otherPwPair.mPwsResult); } return false; }","old_code_raw":"  public boolean equals(Object other) {\n    if (other instanceof PwPair) {\n      PwPair otherPwPair = (PwPair) other;\n      return getRank() == otherPwPair.getRank();\n    }\n    return false;\n  }\n","new_comment_raw":"Check if two PwPairs are equal.","old_comment_raw":"Check if two PwPairs are equal based on rank.","label":1,"pre_label":0,"AST_level":9,"line_counts":16,"new_code_token_num":64},{"new_code_raw":"public String getAsText(long instant, Locale locale) { return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToText(get(instant)); }","old_code_raw":"    public String getAsText(long millis, Locale locale) {\n        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToText(get(millis));\n    }\n","new_comment_raw":"Get the textual value of the specified time instant.","old_comment_raw":"Get the textual value of the specified time instant.","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":26},{"new_code_raw":"public String getSchemaType(Schema schema) { if (schema instanceof ComposedSchema) { \/\/ composed schema ComposedSchema cs = (ComposedSchema) schema; List<Schema> schemas = ModelUtils.getInterfaces(cs); if (cs.getAllOf() != null) { for (Schema s : cs.getAllOf()) { if (s != null) { \/\/schema = s; } \/\/LOGGER.info(\"ALL OF SCHEMA: {}\", s); } LOGGER.info(\"Composed schema not yet supported: {}\", cs); \/\/ get the model (allOf) return getAlias(\"UNKNOWN_COMPOSED_SCHMEA\"); } else if (cs.getAnyOf() != null) { \/\/ anyOf List<String> names = new ArrayList<String>(); for (Schema s : schemas) { if (StringUtils.isNotBlank(s.get$ref())) { \/\/ reference to another definition\/schema String schemaName = ModelUtils.getSimpleRef(s.get$ref()); if (StringUtils.isNotEmpty(schemaName)) { names.add(getAlias(schemaName)); } else { LOGGER.warn(\"Error obtaining the datatype from ref:\" + schema.get$ref() + \". Default to 'object'\"); return \"object\"; } } else { \/\/ primitive type or model names.add(getAlias(getPrimitiveType(s))); } return \"anyOf<\" + String.join(\",\", names) + \">\"; } } else if (cs.getOneOf() != null) { \/\/ oneOf List<String> names = new ArrayList<String>(); for (Schema s : schemas) { if (StringUtils.isNotBlank(s.get$ref())) { \/\/ reference to another definition\/schema String schemaName = ModelUtils.getSimpleRef(s.get$ref()); if (StringUtils.isNotEmpty(schemaName)) { names.add(getAlias(schemaName)); } else { LOGGER.warn(\"Error obtaining the datatype from ref:\" + schema.get$ref() + \". Default to 'object'\"); return \"object\"; } } else { \/\/ primitive type or model names.add(getAlias(getPrimitiveType(s))); } return \"oneOf<\" + String.join(\",\", names) + \">\"; } } } if (StringUtils.isNotBlank(schema.get$ref())) { \/\/ reference to another definition\/schema \/\/ get the schema\/model name from $ref String schemaName = ModelUtils.getSimpleRef(schema.get$ref()); if (StringUtils.isNotEmpty(schemaName)) { return getAlias(schemaName); } else { LOGGER.warn(\"Error obtaining the datatype from ref:\" + schema.get$ref() + \". Default to 'object'\"); return \"object\"; } } else { \/\/ primitive type or model return getAlias(getPrimitiveType(schema)); } }","old_code_raw":"    public String getSchemaType(Schema schema) {\n        \/\/ TODO better logic to handle compose schema\n        if (schema instanceof ComposedSchema) { \/\/ composed schema\n            ComposedSchema cs = (ComposedSchema) schema;\n            if (cs.getAllOf() != null) {\n                for (Schema s : cs.getAllOf()) {\n                    if (s != null) {\n                        \/\/ using the first schema defined in allOf\n                        schema = s;\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (StringUtils.isNotBlank(schema.get$ref())) { \/\/ reference to another definition\/schema\n            \/\/ get the schema\/model name from $ref\n            String schemaName = ModelUtils.getSimpleRef(schema.get$ref());\n            if (StringUtils.isNotEmpty(schemaName)) {\n                return getAlias(schemaName);\n            } else {\n                LOGGER.warn(\"Error obtaining the datatype from ref:\" + schema.get$ref() + \". Default to 'object'\");\n                return \"object\";\n            }\n        } else { \/\/ primitive type or model\n            return getAlias(getPrimitiveType(schema));\n        }\n    }\n","new_comment_raw":"returns the OpenAPI type for the property.","old_comment_raw":"returns the OpenAPI type for the property.","label":0,"pre_label":1,"AST_level":19,"line_counts":66,"new_code_token_num":569},{"new_code_raw":"public static GraphQLSchema transformSchema(GraphQLSchema schema, GraphQLTypeVisitor visitor) { return transformSchema(schema, TraversalType.ALL, visitor); }","old_code_raw":"    public static GraphQLSchema transformSchema(GraphQLSchema schema, GraphQLTypeVisitor visitor) {\n        SchemaTransformer schemaTransformer = new SchemaTransformer();\n        return schemaTransformer.transform(schema, visitor);\n    }\n","new_comment_raw":"Transforms a GraphQLSchema and returns a new GraphQLSchema object.","old_comment_raw":"Transforms a GrapQLSchema and returns a new GraphQLSchema object.","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":24},{"new_code_raw":"public TaskShutdownDameon execute() throws Exception { \/\/ create heartbeat TaskHeartbeatRunable hb = new TaskHeartbeatRunable(zkCluster, topologyid, taskid, uptime, taskStats, taskStatus, stormConf); AsyncLoopThread heartbeat_thread = new AsyncLoopThread(hb, false, Thread.MIN_PRIORITY, true); IConnection puller = context.bind(topologyid, taskid, false); TaskSendTargets sendTargets = echoToSystemBolt(); \/\/ create thread to get tuple from zeroMQ, \/\/ and pass the tuple to bolt\/spout RunnableCallback baseExecutor = mkExecutor(puller, sendTargets); AsyncLoopThread executor_threads = new AsyncLoopThread(baseExecutor, false, Thread.MAX_PRIORITY, true); List<AsyncLoopThread> allThreads = new ArrayList<AsyncLoopThread>(); allThreads.add(heartbeat_thread); allThreads.add(executor_threads); LOG.info(\"Finished loading task \" + componentid + \":\" + taskid); return getShutdown(allThreads, heartbeat_thread, puller, baseExecutor); }","old_code_raw":"\tpublic TaskShutdownDameon execute() throws Exception {\n\n\t\t\/\/ create heartbeat\n\t\tTaskHeartbeatRunable hb = new TaskHeartbeatRunable(zkCluster,\n\t\t\t\ttopologyid, taskid, uptime, taskStats, taskStatus, stormConf);\n\n\t\tAsyncLoopThread heartbeat_thread = new AsyncLoopThread(hb, false,\n\t\t\t\tThread.MIN_PRIORITY, true);\n\n\t\tIConnection puller = context.bind(topologyid, taskid, false);\n\n\t\tTaskSendTargets sendTargets = echoToSystemBolt();\n\n\t\t\/\/ create thread to get tuple from zeroMQ,\n\t\t\/\/ and pass the tuple to bolt\/spout\n\t\tRunnableCallback baseExecutor = mkExecutor(puller, sendTargets);\n\t\tAsyncLoopThread executor_threads = new AsyncLoopThread(baseExecutor,\n\t\t\t\tfalse, Thread.MAX_PRIORITY, true);\n\n\t\tAsyncLoopThread[] all_threads = { executor_threads, heartbeat_thread };\n\n\t\tLOG.info(\"Finished loading task \" + componentid + \":\" + taskid);\n\n\t\treturn getShutdown(all_threads, heartbeat_thread, puller);\n\t}\n","new_comment_raw":"create executor to receive tuples and run bolt\/spout execute function","old_comment_raw":"create executor to receive tuples and run bolt\/spout execute function","label":0,"pre_label":1,"AST_level":8,"line_counts":28,"new_code_token_num":161},{"new_code_raw":"public static ColumnNameFilter getInstance(String fullyQualifiedColumnNames) { Predicate<ColumnId> delegate = Predicates.excludes(fullyQualifiedColumnNames, ColumnId::toString); return (catalogName, schemaName, tableName, columnName) -> delegate.test(new ColumnId(new TableId(catalogName, schemaName, tableName), columnName)); }","old_code_raw":"        public static ColumnNameFilter getInstance(String fullyQualifiedColumnNames) {\n            Predicate<ColumnId> delegate = Predicates.excludes(fullyQualifiedColumnNames, ColumnId::toString);\n\n            return new ColumnNameFilter() {\n\n                @Override\n                public boolean matches(String catalogName, String schemaName, String tableName, String columnName) {\n                    return delegate.test(new ColumnId(new TableId(catalogName, schemaName, tableName), columnName));\n                }\n            };\n        }\n","new_comment_raw":"Build the  ColumnNameFilter that determines whether a column identified by a given  ColumnId is to be included, using the given comma-separated regular expression patterns defining which columns (if any) should be excluded.","old_comment_raw":"Build the ColumnNameFilter that determines whether a column identified by a given ColumnId is to be included, using the given comma-separated regular expression patterns defining which columns (if any) should be excluded.","label":0,"pre_label":1,"AST_level":8,"line_counts":5,"new_code_token_num":55},{"new_code_raw":"public static Method getGetterFor(Field field) { String name = field.getName().substring(0, 1).toUpperCase() + field.getName().substring(1); String methodName; if (boolean.class.isAssignableFrom(field.getType()) || Boolean.class.isAssignableFrom(field.getType())) { methodName = \"is\" + name; } else { methodName = \"get\" + name; } try { return field.getDeclaringClass().getMethod(methodName); } catch (NoSuchMethodException e) { if (methodName.startsWith(\"is\")) { methodName = \"get\" + name; try { return field.getDeclaringClass().getMethod(methodName); } catch (NoSuchMethodException e2) { } } LOG.info(\"No getter {}() for field {}[{}]\", methodName, field.getDeclaringClass().getName(), field.getName()); return null; } }","old_code_raw":"\tpublic static Method getGetterFor(Field field) {\n\t\tString name = field.getName().substring(0, 1).toUpperCase()\n\t\t\t\t+ field.getName().substring(1);\n\t\ttry {\n\t\t\treturn field.getDeclaringClass().getMethod(\"get\" + name);\n\t\t} catch (NoSuchMethodException e) {\n\t\t\tLOG.info(\"No getter method for \" + name, e);\n\t\t\treturn null;\n\t\t}\n\t}\n","new_comment_raw":"It returns the getter for the given field.","old_comment_raw":"It returns the getter for the given field.","label":0,"pre_label":1,"AST_level":11,"line_counts":28,"new_code_token_num":178},{"new_code_raw":"public static Result createGemFireErrorResult(String message) { return createErrorResult(ERRORCODE_GEODE_ERROR, \"Could not process command due to error. \" + message); }","old_code_raw":"  public static Result createGemFireErrorResult(String message) {\n    return createErrorResult(ERRORCODE_GEMFIRE_ERROR,\n        \"Could not process command due to GemFire error. \" + message);\n  }\n","new_comment_raw":"Method for convenience to create error result for error in Geode while executing command.","old_comment_raw":"Method for convenience to create error result for error in GemFire while executing command.","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":28},{"new_code_raw":"public SortedMap<String, String> getOriginTabContentsAsStrings(final Origin selectedColumn) { openTab(Tab.ORIGIN); return mapTableCellsKeyValue(String.class, getVisibleTableRows(true, false), selectedColumn.column); }","old_code_raw":"    public SortedMap<String, String> getOriginTabContentsAsStrings() {\n        openTab(Tab.ORIGIN);\n        return mapTableCellsKeyValue(String.class, getVisibleTableRows(true, true), 3);\n    }\n","new_comment_raw":"Returns the first and the specified columns of the \"Origin\"-tab as key => value pairs, skipping the header row.","old_comment_raw":"Returns the first two columns of the \"Warnings\"-tab as key => value pairs, skipping the header row.","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":36},{"new_code_raw":"public boolean isPullSuccessIndicated() { if (isErrorIndicated() || getStatus() == null) { return false; } return (getStatus().contains(DOWNLOAD_COMPLETE) || getStatus().contains(IMAGE_UP_TO_DATE) || getStatus().contains(DOWNLOADED_NEWER_IMAGE) || getStatus().contains(LEGACY_REGISTRY) || getStatus().contains(DOWNLOADED_SWARM) ); }","old_code_raw":"    public boolean isPullSuccessIndicated() {\n        if (isErrorIndicated() || getStatus() == null) {\n            return false;\n        }\n\n        return (getStatus().contains(DOWNLOAD_COMPLETE) || getStatus().contains(IMAGE_UP_TO_DATE)\n                || getStatus().contains(DOWNLOADED_NEWER_IMAGE) || getStatus().contains(LEGACY_REGISTRY));\n    }\n","new_comment_raw":"Returns whether the status indicates a successful pull operation","old_comment_raw":"Returns whether the status indicates a successful pull operation","label":0,"pre_label":1,"AST_level":10,"line_counts":13,"new_code_token_num":71},{"new_code_raw":"protected AuthenticationInfo doMultiRealmAuthentication(Collection<? extends Realm> realms, AuthenticationToken token) { ModularAuthenticationStrategy strategy = getModularAuthenticationStrategy(); AuthenticationInfo aggregate = strategy.beforeAllAttempts(realms, token); if (log.isDebugEnabled()) { log.debug(\"Iterating through [\" + realms.size() + \"] realms for PAM authentication\"); } for (Realm realm : realms) { if (realm.supports(token)) { if (log.isDebugEnabled()) { log.debug(\"Attempting to authenticate token [\" + token + \"] \" + \"using realm of type [\" + realm + \"]\"); } AuthenticationInfo info = null; Throwable t = null; try { info = realm.getAuthenticationInfo(token); } catch (Throwable throwable) { t = throwable; if (log.isTraceEnabled()) { String msg = \"Realm [\" + realm + \"] threw an exception during a multi-realm authentication attempt:\"; log.trace(msg, t); } } aggregate = strategy.afterAttempt(realm, token, info, aggregate, t); } else { if (log.isDebugEnabled()) { log.debug(\"Realm of type [\" + realm + \"] does not support token \" + \"[\" + token + \"]. Skipping realm.\"); } } } aggregate = strategy.afterAllAttempts(token, aggregate); return aggregate; }","old_code_raw":"    protected Account doMultiRealmAuthentication(Collection<? extends Realm> realms, AuthenticationToken token) {\n\n        ModularAuthenticationStrategy strategy = getModularAuthenticationStrategy();\n\n        Account aggregate = strategy.beforeAllAttempts(realms, token);\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Iterating through [\" + realms.size() + \"] realms for PAM authentication\");\n        }\n\n        for (Realm realm : realms) {\n\n            if (realm.supports(token)) {\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Attempting to authenticate token [\" + token + \"] \" +\n                            \"using realm of type [\" + realm + \"]\");\n                }\n\n                aggregate = strategy.beforeAttempt(realm, token, aggregate);\n\n                Account account = null;\n                Throwable t = null;\n                try {\n                    account = realm.getAccount(token);\n                } catch (Throwable throwable) {\n                    t = throwable;\n                    if (log.isTraceEnabled()) {\n                        String msg = \"Realm [\" + realm + \"] threw an exception during a multi-realm authentication attempt:\";\n                        log.trace(msg, t);\n                    }\n                }\n\n                aggregate = strategy.afterAttempt(realm, token, account, aggregate, t);\n\n            } else {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Realm of type [\" + realm + \"] does not support token \" +\n                            \"[\" + token + \"].  Skipping realm.\");\n                }\n            }\n        }\n\n        aggregate = strategy.afterAllAttempts(token, aggregate);\n\n        return aggregate;\n    }\n","new_comment_raw":"Performs the multi-realm authentication attempt by calling back to a  ModularAuthenticationStrategy object as each realm is consulted for AuthenticationInfo for the specified token.","old_comment_raw":"Performs the multi-realm authentication attempt by calling back to a ModularAuthenticationStrategy object as each realm is consulted for Account for the specified token.","label":1,"pre_label":0,"AST_level":16,"line_counts":47,"new_code_token_num":264},{"new_code_raw":"public static FlumeNodeState findByValue(int value) { switch (value) { case 0: return HELLO; case 1: return IDLE; case 2: return CONFIGURING; case 3: return ACTIVE; case 4: return ERROR; case 5: return LOST; case 6: return DECOMMISSIONED; default: return null; } }","old_code_raw":"  public static FlumeNodeState findByValue(int value) { \n    return BY_VALUE.get(value);\n  }\n","new_comment_raw":"Find a the enum type by its integer value, as defined in the Thrift IDL.","old_comment_raw":"Find a the enum type by its integer value, as defined in the Thrift IDL.","label":0,"pre_label":1,"AST_level":6,"line_counts":21,"new_code_token_num":63},{"new_code_raw":"public double get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }","old_code_raw":"    public double get(WithAttributes attributes) {\r\n        return attributes.getAttributes().get(this);\r\n    }\r\n","new_comment_raw":"Extracts the attribute map from the specified  WithAttributes and returns the value of this attribute from the map.","old_comment_raw":"Analogous to #get(WithAttributes) except returning a primitive double.","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":19},{"new_code_raw":"public String getTypeDeclaration(Schema schema) { if (schema == null) { LOGGER.warn(\"Null schema found. Default type to `NULL_SCHMEA_ERR`\"); return \"NULL_SCHMEA_ERR\"; } String oasType = getSchemaType(schema); if (typeMapping.containsKey(oasType)) { return typeMapping.get(oasType); } return oasType; }","old_code_raw":"    public String getTypeDeclaration(Schema schema) {\n        String oasType = getSchemaType(schema);\n        if (typeMapping.containsKey(oasType)) {\n            return typeMapping.get(oasType);\n        }\n        return oasType;\n    }\n","new_comment_raw":"Output the type declaration of the property","old_comment_raw":"Output the type declaration of the property","label":0,"pre_label":1,"AST_level":7,"line_counts":14,"new_code_token_num":62},{"new_code_raw":"static HintStrategyTable createHintStrategies(HintStrategyTable.Builder builder) { return builder .addHintStrategy(\"no_hash_join\", HintStrategies.JOIN) .addHintStrategy(\"time_zone\", HintStrategies.SET_VAR) .addHintStrategy(\"REPARTITION\", HintStrategies.SET_VAR) .addHintStrategy(\"index\", HintStrategies.TABLE_SCAN) .addHintStrategy(\"properties\", HintStrategies.TABLE_SCAN) .addHintStrategy( \"resource\", HintStrategies.or( HintStrategies.PROJECT, HintStrategies.AGGREGATE, HintStrategies.CALC)) .addHintStrategy(\"AGG_STRATEGY\", HintStrategies.AGGREGATE, (hint, errorHandler) -> errorHandler.check( hint.listOptions.size() == 1 && (hint.listOptions.get(0).equalsIgnoreCase(\"ONE_PHASE\") || hint.listOptions.get(0).equalsIgnoreCase(\"TWO_PHASE\")), \"Hint {} only allows single option, \" + \"allowed options: [ONE_PHASE, TWO_PHASE]\", hint.hintName )) .addHintStrategy(\"use_hash_join\", HintStrategies.and(HintStrategies.JOIN, HintStrategies.explicit((hint, rel) -> { if (!(rel instanceof LogicalJoin)) { return false; } LogicalJoin join = (LogicalJoin) rel; final List<String> tableNames = hint.listOptions; final List<String> inputTables = join.getInputs().stream() .filter(input -> input instanceof TableScan) .map(scan -> Util.last(scan.getTable().getQualifiedName())) .collect(Collectors.toList()); return equalsStringList(tableNames, inputTables); }))) .build(); }","old_code_raw":"    private static HintStrategyTable createHintStrategies() {\n      return HintStrategyTable.builder()\n        .addHintStrategy(\"no_hash_join\", HintStrategies.JOIN)\n        .addHintStrategy(\"time_zone\", HintStrategies.SET_VAR)\n        .addHintStrategy(\"REPARTITION\", HintStrategies.SET_VAR)\n        .addHintStrategy(\"index\", HintStrategies.TABLE_SCAN)\n        .addHintStrategy(\"properties\", HintStrategies.TABLE_SCAN)\n        .addHintStrategy(\n            \"resource\", HintStrategies.or(\n            HintStrategies.PROJECT, HintStrategies.AGGREGATE, HintStrategies.CALC))\n        .addHintStrategy(\"AGG_STRATEGY\", HintStrategies.AGGREGATE)\n        .addHintStrategy(\"use_hash_join\",\n          HintStrategies.and(HintStrategies.JOIN,\n            HintStrategies.explicit((hint, rel) -> {\n              if (!(rel instanceof LogicalJoin)) {\n                return false;\n              }\n              LogicalJoin join = (LogicalJoin) rel;\n              final List<String> tableNames = hint.listOptions;\n              final List<String> inputTables = join.getInputs().stream()\n                  .filter(input -> input instanceof TableScan)\n                  .map(scan -> Util.last(scan.getTable().getQualifiedName()))\n                  .collect(Collectors.toList());\n              return equalsStringList(tableNames, inputTables);\n            })))\n        .build();\n    }\n","new_comment_raw":"Creates mock hint strategies with given builder.","old_comment_raw":"Creates mock hint strategies.","label":1,"pre_label":0,"AST_level":16,"line_counts":37,"new_code_token_num":266},{"new_code_raw":"public ScrollableResults scroll(ScrollMode mode, Expr<?>[] args) { Query query = createQuery(args); reset(); return query.scroll(mode); }","old_code_raw":"    public ScrollableResults scroll(ScrollMode mode, Expr<?>[] args) {\n        return createQuery(args).scroll(mode);\n    }\n","new_comment_raw":"Return the query results as ScrollableResults.","old_comment_raw":"Return the query results as ScrollableResults.","label":0,"pre_label":1,"AST_level":6,"line_counts":6,"new_code_token_num":33},{"new_code_raw":"public static Set<ImmutableBitSet> getUniqueKeys(RelNode rel) { final BuiltInMetadata.UniqueKeys metadata = rel.metadata(BuiltInMetadata.UniqueKeys.class); return metadata.getUniqueKeys(false); }","old_code_raw":"  public static Set<BitSet> getUniqueKeys(RelNode rel) {\n    final BuiltInMetadata.UniqueKeys metadata =\n        rel.metadata(BuiltInMetadata.UniqueKeys.class);\n    return metadata.getUniqueKeys(false);\n  }\n","new_comment_raw":"Returns the  BuiltInMetadata.UniqueKeys#getUniqueKeys(boolean) statistic.","old_comment_raw":"Returns the BuiltInMetadata.UniqueKeys#getUniqueKeys(boolean) statistic.","label":0,"pre_label":1,"AST_level":7,"line_counts":6,"new_code_token_num":30},{"new_code_raw":"public Boolean fakeOuterBooleanSerialize(Boolean body) throws ApiException { return fakeOuterBooleanSerializeWithHttpInfo(body).getData(); }","old_code_raw":"  public Boolean fakeOuterBooleanSerialize(Boolean body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/fake\/outer\/boolean\";\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"Test serialization of outer boolean types","old_comment_raw":"Test serialization of outer boolean types","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"public boolean hasPath(final String path, final boolean consistent) { return hasPath(path, consistent, null); }","old_code_raw":"  public boolean hasPath(final String path, final boolean consistent) {\n    Preconditions.checkNotNull(path, \"path is required\");\n\n    final String target = PathUtils.join(root, path);\n    try {\n      if (consistent) {\n        return curator.checkExists().forPath(target) != null;\n      } else {\n        return getCache().getCurrentData(target) != null;\n      }\n    } catch (final Exception e) {\n      throw new DrillRuntimeException(\"error while checking path on zookeeper\", e);\n    }\n  }\n","new_comment_raw":"Returns true if path exists, false otherwise.","old_comment_raw":"Checks if the given path exists.","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":24},{"new_code_raw":"public BuildResult getPreviousResult() { ResultAction<? extends BuildResult> action = getPreviousAction(); if (action != null) { return action.getResult(); } throw new NoSuchElementException(\"No previous result available\"); }","old_code_raw":"    public BuildResult getPreviousResult() {\n        return getPreviousAction().getResult();\n    }\n","new_comment_raw":"Returns the previous build result.","old_comment_raw":"Returns the action of the previous build.","label":1,"pre_label":0,"AST_level":6,"line_counts":9,"new_code_token_num":42},{"new_code_raw":"public DateTimeFormatterBuilder appendDayOfWeekShortText() { return appendShortText(DateTimeFieldType.dayOfWeek()); }","old_code_raw":"    public DateTimeFormatterBuilder appendDayOfWeekShortText() {\n        return appendShortText(iChronoUTC.dayOfWeek());\n    }\n","new_comment_raw":"Instructs the printer to emit a short locale-specific dayOfWeek text.","old_comment_raw":"Instructs the printer to emit a short locale-specific dayOfWeek text.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":16},{"new_code_raw":"public WebDriver augment(WebDriver driver) { \/\/ TODO(simon): We should really add a \"SelfDescribing\" interface for this if (!(driver instanceof RemoteWebDriver)) { return driver; } Map<String, ?> capabilities = ((RemoteWebDriver) driver).getCapabilities().asMap(); CompoundHandler handler = new CompoundHandler((RemoteWebDriver) driver); for (Map.Entry<String, ?> capablityName : capabilities.entrySet()) { AugmenterProvider augmenter = augmentors.get(capablityName.getKey()); if (augmenter == null) { continue; } Object value = capablityName.getValue(); if (value instanceof Boolean && !((Boolean) value).booleanValue()) { continue; } handler.addCapabilityHander(augmenter.getDescribedInterface(), augmenter.getImplementation(value)); } if (handler.isNeedingApplication()) { \/\/ Gather the existing interfaces Set<Class<?>> interfaces = new HashSet<Class<?>>(); interfaces.addAll(handler.getInterfaces()); interfaces.addAll(getInterfacesFrom(driver.getClass())); Enhancer enhancer = new Enhancer(); enhancer.setInterfaces(interfaces.toArray(new Class<?>[interfaces.size()])); enhancer.setCallback(handler); enhancer.setSuperclass(driver.getClass()); RemoteWebDriver remote = (RemoteWebDriver) enhancer.create(); remote.setCommandExecutor(((RemoteWebDriver) driver).getCommandExecutor()); remote.setElementConverter(((RemoteWebDriver) driver).getElementConverter()); return remote; } return driver; }","old_code_raw":"  public WebDriver augment(WebDriver driver) {\n    \/\/ TODO(simon): We should really add a \"SelfDescribing\" interface for this\n    if (!(driver instanceof RemoteWebDriver)) {\n      return driver;\n    }\n\n    Map<String, ?> capabilities = ((RemoteWebDriver) driver).getCapabilities().asMap();\n\n    CompoundHandler handler = new CompoundHandler((RemoteWebDriver) driver);\n\n    for (Map.Entry<String, ?> capablityName : capabilities.entrySet()) {\n      AugmenterProvider augmenter = augmentors.get(capablityName.getKey());\n      if (augmenter == null) {\n        continue;\n      }\n\n      Object value = capablityName.getValue();\n      if (value instanceof Boolean && !((Boolean) value).booleanValue()) {\n        continue;\n      }\n\n      handler.addCapabilityHander(augmenter.getDescribedInterface(),\n          augmenter.getImplementation(value));\n    }\n\n    if (handler.isNeedingApplication()) {\n      \/\/ Gather the existing interfaces\n      Set<Class<?>> interfaces = new HashSet<Class<?>>();\n      interfaces.addAll(handler.getInterfaces());\n      interfaces.addAll(getInterfacesFrom(driver.getClass()));\n\n      return (WebDriver) Proxy.newProxyInstance(getClass().getClassLoader(),\n          interfaces.toArray(new Class<?>[interfaces.size()]), handler);\n    }\n\n    return driver;\n  }\n","new_comment_raw":"Enhance the interfaces implemented by this instance of WebDriver iff that instance is a  org.openqa.selenium.remote.RemoteWebDriver.","old_comment_raw":"Enhance the interfaces implemented by this instance of WebDriver iff that instance is a org.openqa.selenium.remote.RemoteWebDriver.","label":0,"pre_label":1,"AST_level":11,"line_counts":45,"new_code_token_num":281},{"new_code_raw":"private File createNewFile() { String filename = \"image-\" + UUID.randomUUID().toString() + \".jpg\"; File path; if (tmpImage) { path = mReactContext.getExternalCacheDir(); } else { path = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES); } File f = new File(path, filename); try { path.mkdirs(); f.createNewFile(); } catch (IOException e) { e.printStackTrace(); } return f; }","old_code_raw":"  private File createNewFile(final boolean forcePictureDirectory) {\n    String filename = \"image-\" + UUID.randomUUID().toString() + \".jpg\";\n    if (tmpImage && forcePictureDirectory != true) {\n      return new File(mReactContext.getCacheDir(), filename);\n    } else {\n      File path = Environment.getExternalStoragePublicDirectory(\n              Environment.DIRECTORY_PICTURES);\n      File f = new File(path, filename);\n\n      try {\n        path.mkdirs();\n        f.createNewFile();\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n      return f;\n    }\n  }\n","new_comment_raw":"Create a new file","old_comment_raw":"Create a new file","label":0,"pre_label":1,"AST_level":8,"line_counts":20,"new_code_token_num":90},{"new_code_raw":"static public IStructuredTextExpert getExpert(String type, StructuredTextEnvironment environment) { IStructuredTextExpert expert; if (environment == null) environment = StructuredTextEnvironment.DEFAULT; synchronized (sharedExperts) { Map experts = (Map) sharedExperts.get(type); if (experts == null) { experts = new HashMap(); \/\/ environment -> expert sharedExperts.put(type, experts); } expert = (IStructuredTextExpert) experts.get(environment); if (expert == null) { StructuredTextTypeHandler handler = StructuredTextTypeHandlerFactory.getHandler(type); if (handler == null) throw new IllegalArgumentException(\"Invalid type argument\"); \/\/$NON-NLS-1$ expert = new StructuredTextImpl(handler, environment, false); experts.put(type, expert); } } return expert; }","old_code_raw":"\tstatic public ISTextExpert getExpert(String type, STextEnvironment environment) {\n\t\tISTextExpert expert;\n\t\tif (environment == null)\n\t\t\tenvironment = STextEnvironment.DEFAULT;\n\t\tsynchronized (sharedExperts) {\n\t\t\tMap experts = (Map) sharedExperts.get(type);\n\t\t\tif (experts == null) {\n\t\t\t\texperts = new HashMap(); \/\/ environment -> expert\n\t\t\t\tsharedExperts.put(type, experts);\n\t\t\t}\n\t\t\texpert = (ISTextExpert) experts.get(environment);\n\t\t\tif (expert == null) {\n\t\t\t\tSTextTypeHandler handler = STextTypeHandlerFactory.getHandler(type);\n\t\t\t\tif (handler == null)\n\t\t\t\t\tthrow new IllegalArgumentException(\"Invalid type argument\"); \/\/$NON-NLS-1$\n\t\t\t\texpert = new STextImpl(handler, environment, false);\n\t\t\t\texperts.put(type, expert);\n\t\t\t}\n\t\t}\n\t\treturn expert;\n\t}\n","new_comment_raw":"Obtains a IStructuredTextExpert instance for processing structured text with the specified type handler and the specified environment.","old_comment_raw":"Obtains a ISTextExpert instance for processing structured text with the specified type handler and the specified environment.","label":1,"pre_label":0,"AST_level":9,"line_counts":23,"new_code_token_num":140},{"new_code_raw":"public static String addPropertiesToURI(URI uri, Map<String, String> properties) throws Exception { return addPropertiesToURI(uri.toString(), properties); }","old_code_raw":"    public static String addPropertiesToURI(URI uri, Map<String, String> props) throws Exception {\n        return addPropertiesToURI(uri.toString(), props);\n    }\n","new_comment_raw":"Enumerate the properties of the target object and add them as additional entries to the query string of the given URI.","old_comment_raw":"Add properties to a URI","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":29},{"new_code_raw":"protected Object convertDouble(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0.0d; } if (data instanceof Double) return data; if (data instanceof Number) { \/\/ Includes BigDecimal and other numeric values ... Number value = (Number) data; return new Double(value.doubleValue()); } if (data instanceof Boolean) { return NumberConversions.getDouble((Boolean) data); } return handleUnknownData(column, fieldDefn, data); }","old_code_raw":"    protected Object convertDouble(Column column, Field fieldDefn, Object data) {\n        if (data == null) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return 0.0d;\n        }\n        if (data instanceof Double) return data;\n        if (data instanceof Number) {\n            \/\/ Includes BigDecimal and other numeric values ...\n            Number value = (Number) data;\n            return new Double(value.doubleValue());\n        }\n        if (data instanceof Boolean) {\n            return ((Boolean) data).booleanValue() ? DOUBLE_TRUE : DOUBLE_FALSE;\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n","new_comment_raw":"Converts a value object for an expected JDBC type of  Types#DOUBLE.","old_comment_raw":"Converts a value object for an expected JDBC type of Types#DOUBLE.","label":0,"pre_label":1,"AST_level":8,"line_counts":20,"new_code_token_num":122},{"new_code_raw":"protected String getNewIdFor(EObject element_p) { return copyXmlIds()? null: EcoreUtil.generateUUID(); }","old_code_raw":"  protected String getNewIdFor(EObject element_p) {\r\n    return copyPhysicalIds()? null: EcoreUtil.generateUUID();\r\n  }\r\n","new_comment_raw":"Return a new unique intrinsic ID for the given element, if relevant.","old_comment_raw":"Return a new unique Ecore identifier for the given element, if relevant.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":21},{"new_code_raw":"public CubeDesc updateCubeDesc(CubeDesc desc) throws IOException { \/\/ Validate CubeDesc if (desc.getUuid() == null || desc.getName() == null) { throw new IllegalArgumentException(); } String name = desc.getName(); if (!cubeDescMap.containsKey(name)) { throw new IllegalArgumentException(\"CubeDesc '\" + name + \"' does not exist.\"); } try { desc.init(config, getMetadataManager().getAllTablesMap()); } catch (Exception e) { desc.addError(e.getMessage()); return desc; } \/\/ Semantic validation CubeMetadataValidator validator = new CubeMetadataValidator(); ValidateContext context = validator.validate(desc); if (!context.ifPass()) { return desc; } desc.setSignature(desc.calculateSignature()); \/\/ Save Source String path = desc.getResourcePath(); getStore().putResource(path, desc, CUBE_DESC_SERIALIZER); \/\/ Reload the CubeDesc CubeDesc ndesc = loadCubeDesc(path, false); \/\/ Here replace the old one cubeDescMap.put(ndesc.getName(), desc); return ndesc; }","old_code_raw":"    public CubeDesc updateCubeDesc(CubeDesc desc) throws IOException {\n        \/\/ Validate CubeDesc\n        if (desc.getUuid() == null || desc.getName() == null) {\n            throw new IllegalArgumentException();\n        }\n        String name = desc.getName();\n        if (!cubeDescMap.containsKey(name)) {\n            throw new IllegalArgumentException(\"CubeDesc '\" + name + \"' does not exist.\");\n        }\n\n        try {\n            desc.init(config, getMetadataManager().getAllTablesMap());\n        } catch (IllegalStateException e) {\n            desc.addError(e.getMessage(), true);\n            return desc;\n        } catch (IllegalArgumentException e) {\n            desc.addError(e.getMessage(), true);\n            return desc;\n        }\n\n        \/\/ Semantic validation\n        CubeMetadataValidator validator = new CubeMetadataValidator();\n        ValidateContext context = validator.validate(desc, true);\n        if (!context.ifPass()) {\n            return desc;\n        }\n\n        desc.setSignature(desc.calculateSignature());\n\n        \/\/ Save Source\n        String path = desc.getResourcePath();\n        getStore().putResource(path, desc, CUBE_DESC_SERIALIZER);\n\n        \/\/ Reload the CubeDesc\n        CubeDesc ndesc = loadCubeDesc(path);\n        \/\/ Here replace the old one\n        cubeDescMap.put(ndesc.getName(), desc);\n\n        return ndesc;\n    }\n","new_comment_raw":"Update CubeDesc with the input.","old_comment_raw":"Update CubeDesc with the input.","label":0,"pre_label":1,"AST_level":9,"line_counts":38,"new_code_token_num":209},{"new_code_raw":"public SessionFactoryImpl getEntityManagerFactory() { return sessionFactory; }","old_code_raw":"\tpublic  EntityManagerFactoryImpl getEntityManagerFactory() {\n\t\treturn entityManagerFactory;\n\t}\n","new_comment_raw":"Provides protected access to the underlying  SessionFactoryImpl.","old_comment_raw":"Provides protected access to the underlying EntityManagerFactoryImpl.","label":1,"pre_label":0,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"private int waitForSocket(Launcher launcher, int port, int timeout) { try { LocalPortReceiveAdbPortTask task = new LocalPortReceiveAdbPortTask(port, timeout); return launcher.getChannel().call(task); } catch (InterruptedException ex) { \/\/ Ignore } catch (IOException e) { \/\/ Ignore } return -1; }","old_code_raw":"    private boolean waitForSocket(Launcher launcher, int port, int timeout) {\n        try {\n            LocalPortOpenTask task = new LocalPortOpenTask(port, timeout);\n            return launcher.getChannel().call(task);\n        } catch (InterruptedException ex) {\n            \/\/ Ignore\n        } catch (IOException e) {\n            \/\/ Ignore\n        }\n\n        return false;\n    }\n","new_comment_raw":"Waits for an emulator to say what socket its using, or times out.","old_comment_raw":"Waits for a socket on the remote machine's localhost to become available, or times out.","label":1,"pre_label":0,"AST_level":7,"line_counts":13,"new_code_token_num":62},{"new_code_raw":"public static StringExpression type(EntityPath<?> path) { return StringOperation.create(JPQLOps.TYPE, path); }","old_code_raw":"    public static StringExpression type(EntityPath<?> path) {\n        return StringOperation.create(JPQLTemplates.TYPE, path);\n    }\n","new_comment_raw":"Get the type(path) expression","old_comment_raw":"Get the type(path) expression","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":21},{"new_code_raw":"public Q clone() { return clone(entityManager, getTemplates()); }","old_code_raw":"    public Q clone() {\n        JPQLTemplates existingTemplates = getTemplates();\n        if (existingTemplates != null) {\n            return clone(entityManager, existingTemplates);\n        }else {\n            return clone(entityManager);\n        }\n    }\n","new_comment_raw":"Clone the state of this query to a new instance","old_comment_raw":"Clone the state of this query to a new instance","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":17},{"new_code_raw":"protected MedicationMedicalRecordBodyType mapBody(final EHREXTRACT ehrExtract, final int compositionIndex) { final COMPOSITION composition = ehrExtract.getAllCompositions().get(compositionIndex); \/\/ parse this composition into values stored in a Map Map<String,String> ehr13606values = retrieveValues(composition, compositionIndex); \/\/ use the ehr values to build a medication medical history record body return buildBody(ehr13606values); }","old_code_raw":"    protected MedicationMedicalRecordBodyType mapBody(final EHREXTRACT ehrExtract, final int compositionIndex) {\n        final COMPOSITION composition = ehrExtract.getAllCompositions().get(compositionIndex);\n\n        final MedicationMedicalRecordBodyType bodyType = new MedicationMedicalRecordBodyType();\n        \n        \n        AdditionalPatientInformationType apit = new AdditionalPatientInformationType();\n        apit.setDateOfBirth(\"2010-01-31\");\n        \n        CVType gender = new CVType();\n        gender.setCode(\"abc\");\n        gender.setCodeSystem(\"def\");\n        gender.setDisplayName(\"ghi\");\n        gender.setOriginalText(\"jkl\");\n        apit.setGender(gender);\n        \n        bodyType.setAdditionalPatientInformation(apit);\n        \n        MedicationPrescriptionType mpt = new MedicationPrescriptionType();\n        \n        mpt.setDispensationAuthorization(new DispensationAuthorizationType());\n        mpt.setEndOfTreatment(\"2014-12-31\");\n        mpt.setEndOfTreatmentReason(new CVType());\n        mpt.setEvaluator(new HealthcareProfessionalType());\n        mpt.setPrecedingPrescriptionId(new IIType());\n        mpt.setPrescriber(new HealthcareProfessionalType());\n        mpt.setPrescriptionChainId(new IIType());\n        mpt.setPrescriptionId(new IIType());\n        mpt.setPrescriptionStatus(new CVType());\n        mpt.setSelfMedication(false);\n        mpt.setStartOfFirstTreatment(\"2014-01-31\");\n        mpt.setSucceedingPrescriptionId(new IIType());\n        mpt.setTypeOfPrescription(TypeOfPrescriptionEnum.INS\u00c4TTNING);\n        \n        bodyType.setMedicationPrescription(mpt);\n\n        for (final CONTENT content : composition.getContent()) {\n            for (final ITEM item : ((ENTRY) content).getItems()) {\n            \t\n            \t\n            \tlog.debug(item.getMeaning().getCode() + \" \" + item.getMeaning().getDisplayName().getValue() + \" \" + (item instanceof ELEMENT ? \"ELEMENT\" : \"CLUSTER\"));\n\n                switch (item.getMeaning().getCode()) {\n                    case \"lkm-ord-tid\":   \/\/ Ordinationstidpunkt\n                        mpt.setStartOfTreatment(\"2014-02-28\");\n                        log.debug(item.getMeaning().getCode() + \" \" + item.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)item));\n                        break;\n                    case \"lkm-ord-not\":   \/\/ Notat\n                        mpt.setPrescriptionNote(\"Here is a note\");\n                        log.debug(item.getMeaning().getCode() + \" \" + item.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)item));\n                        break;\n                    case \"lkm-ord-utv\":   \/\/ Utv\u00e4rderingstidpunkt\n                        mpt.setEvaluationTime(\"123\");\n                        log.debug(item.getMeaning().getCode() + \" \" + item.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)item));\n                        break;\n                    case \"lkm-ord-and\":   \/\/ \u00c4ndam\u00e5l\n                        mpt.setTreatmentPurpose(\"There is a purpose to this treatment\");\n                        log.debug(item.getMeaning().getCode() + \" \" + item.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)item));\n                        break;\n                        \n\n                    case \"lkm-dos\"    :   \/\/ Dosering\n                        log.debug(item.getMeaning().getCode() + \" \" + item.getMeaning().getDisplayName().getValue());\n                    \tCLUSTER c = (CLUSTER)item;\n                    \tList<ITEM> parts = c.getParts();\n                    \tfor (ITEM part : parts) {\n                        \tlog.debug(part.getMeaning().getCode());\n                            if (\"lkm-dst\".equals(part.getMeaning().getCode())) {\n                                c = (CLUSTER)part;\n                                \n                                List<ITEM> dosparts = c.getParts();\n                                for (ITEM dospart : dosparts) {\n                                    log.debug(dospart.getMeaning().getCode() + \" \" + dospart.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)dospart));\n                                }\n                            }\n                        }\n                        break;\n                        \n                    case \"lkm-lva\"    :   \/\/ L\u00e4kemedelsval\n                        log.debug(item.getMeaning().getCode() + \" \" + item.getMeaning().getDisplayName().getValue());\n                        c = (CLUSTER)item;\n                        parts = c.getParts();\n                        for (ITEM part : parts) {\n                            log.debug(part.getMeaning().getCode());\n                            \n                            switch (item.getMeaning().getCode()) {\n                            case \"lkm-lva-kom\" :\n                                log.debug(part.getMeaning().getCode() + \" \" + part.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)part));\n                                break;\n                            case \"lkm-lva-typ\" :\n                                log.debug(part.getMeaning().getCode() + \" \" + part.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)part));\n                                break;\n                            case \"lkm-lva-ext\" :\n                                log.debug(part.getMeaning().getCode() + \" \" + part.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)part));\n                                break;\n                            case \"lkm-lkm-lva\":\n                                log.debug(part.getMeaning().getCode() + \" \" + part.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)part));\n                                break;\n                            }\n                        }\n                        \/\/ mpt.setDrug(new DrugChoiceType());\n                        \/\/ EHRUtil.getElementTextValue((ELEMENT)item);\n                        break;\n                        \n                        \n                    case \"lkm-for-tid\":   \/\/ F\u00f6rskrivningstidpunkt\n                        mpt.setStartOfTreatment(\"2014-02-28\");\n                        break;\n                    case \"lkm-for-uiv\":   \/\/ Utl\u00e4mningsintervall\n                        log.debug(item.getMeaning().getCode() + \" \" + item.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)item));\n                        break;\n                    case \"lkm-for-mpt\":   \/\/ M\u00e4ngd per tillf\u00e4lle\n                        log.debug(item.getMeaning().getCode() + \" \" + item.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)item));\n                        break;\n                    case \"lkm-for-tot\":   \/\/ Totalm\u00e4ngd\n                        log.debug(item.getMeaning().getCode() + \" \" + item.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)item));\n                        break;\n                    case \"lkm-for-fpe\":   \/\/ F\u00f6rpackningsenhet\n                        log.debug(item.getMeaning().getCode() + \" \" + item.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)item));\n                        break;\n                    case \"lkm-for-dbs\":   \/\/ Distributionss\u00e4tt\n                        log.debug(item.getMeaning().getCode() + \" \" + item.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)item));\n                        break;\n                }\n            }\n        }\n        return bodyType;\n    }\n","new_comment_raw":"Create a MedicationMedicalRecord using the information in the current ehr13606 composition.","old_comment_raw":"Maps contact body information.","label":1,"pre_label":0,"AST_level":7,"line_counts":12,"new_code_token_num":69},{"new_code_raw":"public T caseCustomersType(CustomersType object) { return null; }","old_code_raw":"  public Object caseCustomersType(CustomersType object)\n  {\n    return null;\n  }\n","new_comment_raw":"Returns the result of interpretting the object as an instance of 'Customers Type'.","old_comment_raw":"Returns the result of interpretting the object as an instance of 'sType'.","label":1,"pre_label":0,"AST_level":4,"line_counts":6,"new_code_token_num":12},{"new_code_raw":"public static Command<List<Cookie>> getAllCookies() { return new Command<>( DOMAIN_NAME + \".getAllCookies\", ImmutableMap.of(), map(\"cookies\", new TypeToken<List<Cookie>>() {}.getType())); }","old_code_raw":"  public static Command<Cookies> getAllCookies() {\n    return new Command<>(\n      DOMAIN_NAME + \".getAllCookies\",\n      ImmutableMap.of(),\n      map(\"cookies\", Cookies.class));\n  }\n","new_comment_raw":"Returns all browser cookies.","old_comment_raw":"Returns all browser cookies.","label":0,"pre_label":1,"AST_level":11,"line_counts":7,"new_code_token_num":45},{"new_code_raw":"public String toString() { long millis = getMillis(); StringBuffer buf = new StringBuffer(); buf.append(\"PT\"); FormatUtils.appendUnpaddedInteger(buf, millis \/ 1000); long part = Math.abs(millis % 1000); if (part > 0) { buf.append('.'); FormatUtils.appendPaddedInteger(buf, part, 3); } buf.append('S'); return buf.toString(); }","old_code_raw":"    public String toString() {\n        return ISOPeriodFormat.getInstance().standard().print(toPeriod());\n    }\n","new_comment_raw":"Gets the value as a String in the ISO8601 duration format including only seconds and milliseconds.","old_comment_raw":"Gets the value as a String in the ISO8601 duration format.","label":1,"pre_label":0,"AST_level":7,"line_counts":14,"new_code_token_num":86},{"new_code_raw":"public static boolean isMatchedWithTopN(CubeInstance cube, SQLDigest digest) { boolean hasTopN = hasTopNMeasure(cube.getDescriptor()); if (hasTopN == false) { return false; } Collection<TblColRef> dimensionColumns = CubeDimensionDeriver.getDimensionColumns(digest); boolean matchDimensions = isMatchedWithDimensions(dimensionColumns, cube); if (matchDimensions == true) { return false; } Collection<FunctionDesc> functions = digest.aggregations; if (functions == null || functions.size() != 1) { \/\/ topN only allow one measure return false; } return isMatchedWithTopN(dimensionColumns, cube, digest); }","old_code_raw":"    public static boolean isMatchedWithTopN(CubeInstance cube, SQLDigest digest) {\n        Collection<TblColRef> dimensionColumns = CubeDimensionDeriver.getDimensionColumns(digest);\n        \n        boolean matchDimensions = isMatchedWithDimensions(dimensionColumns, cube);\n\n        if (matchDimensions == true) {\n            return false;\n        }\n\n        Collection<FunctionDesc> functions = digest.aggregations;\n        if (functions == null || functions.size() != 1) {\n            \/\/ topN only allow one measure\n            return false;\n        }\n\n        return isMatchedWithTopN(dimensionColumns, cube, digest);\n    }\n","new_comment_raw":"Check whether the cube can match the sql digest with TopN measure","old_comment_raw":"Check whether the cube can match the sql digest with TopN measure","label":0,"pre_label":1,"AST_level":6,"line_counts":25,"new_code_token_num":102},{"new_code_raw":"public Set<ClassInfo> getInterfaces() { String[] names = classGen.getInterfaceNames(); Set<ClassInfo> interfaces = new HashSet<ClassInfo>(names.length); for (String name : names) { ClassInfo cls = getAppInfo().getClassInfo(name); if (cls != null) { interfaces.add(cls); } } return interfaces; }","old_code_raw":"    public Collection<ClassInfo> getInterfaces() {\n        return interfaces;\n    }\n","new_comment_raw":"Get a set of all (loaded) interfaces this class directly implements.","old_comment_raw":"Get a collection of all (loaded) interfaces this class directly implements.","label":1,"pre_label":0,"AST_level":9,"line_counts":13,"new_code_token_num":64},{"new_code_raw":"public CreateTableEntry createNewTable(String tableName, List<String> partitionColumns) { return createNewTable(tableName, partitionColumns, StorageStrategy.DEFAULT); }","old_code_raw":"  public CreateTableEntry createNewTable(String tableName, List<String> partitionColumns) {\n    return createNewTable(tableName, partitionColumns, StorageStrategy.PERSISTENT);\n  }\n","new_comment_raw":"Creates table entry using table name and list of partition columns if any.","old_comment_raw":"Creates table entry using table name and list of partition columns if any.","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":24},{"new_code_raw":"public int getPosition() { return currentPosition; }","old_code_raw":"    public int getPosition() {\n        return this.currentPosition;\n\n    }\n","new_comment_raw":"Returns the position where the handler is currently, or where it is heading right now.","old_comment_raw":"Returns current known position.","label":1,"pre_label":0,"AST_level":4,"line_counts":6,"new_code_token_num":10},{"new_code_raw":"@PreAuthorize(Constant.ACCESS_HAS_ROLE_ADMIN + \" or hasPermission(#cube, 'ADMINISTRATION') or hasPermission(#cube, 'OPERATION') or hasPermission(#cube, 'MANAGEMENT')\") public CubeInstance enableCube(CubeInstance cube) throws IOException, JobException { String cubeName = cube.getName(); RealizationStatusEnum ostatus = cube.getStatus(); if (!cube.getStatus().equals(RealizationStatusEnum.DISABLED)) { throw new InternalErrorException(\"Only disabled cube can be enabled, status of \" + cubeName + \" is \" + ostatus); } if (cube.getSegments(SegmentStatusEnum.READY).size() == 0) { throw new InternalErrorException(\"Cube \" + cubeName + \" dosen't contain any READY segment\"); } final List<CubingJob> cubingJobs = listAllCubingJobs(cube.getName(), null, EnumSet.of(ExecutableState.READY, ExecutableState.RUNNING)); if (!cubingJobs.isEmpty()) { throw new JobException(\"Enable is not allowed with a running job.\"); } if (!cube.getDescriptor().calculateSignature().equals(cube.getDescriptor().getSignature())) { this.releaseAllSegments(cube); } cube.setStatus(RealizationStatusEnum.READY); try { return getCubeManager().updateCube(cube); } catch (IOException e) { cube.setStatus(ostatus); throw e; } }","old_code_raw":"    @PreAuthorize(Constant.ACCESS_HAS_ROLE_ADMIN + \" or hasPermission(#cube, 'ADMINISTRATION') or hasPermission(#cube, 'OPERATION')  or hasPermission(#cube, 'MANAGEMENT')\")\n    public CubeInstance enableCube(CubeInstance cube) throws IOException, JobException {\n        String cubeName = cube.getName();\n\n        RealizationStatusEnum ostatus = cube.getStatus();\n        if (!cube.getStatus().equals(RealizationStatusEnum.DISABLED)) {\n            throw new InternalErrorException(\"Only disabled cube can be enabled, status of \" + cubeName + \" is \" + ostatus);\n        }\n\n        if (cube.getSegments(SegmentStatusEnum.READY).size() == 0) {\n            throw new InternalErrorException(\"Cube \" + cubeName + \" dosen't contain any READY segment\");\n        }\n\n        final List<CubingJob> cubingJobs = listAllCubingJobs(cube.getName(), null, EnumSet.of(ExecutableState.READY, ExecutableState.RUNNING));\n        if (!cubingJobs.isEmpty()) {\n            throw new JobException(\"Enable is not allowed with a running job.\");\n        }\n        if (!cube.getDescriptor().calculateSignature().equals(cube.getDescriptor().getSignature())) {\n            cube = this.releaseAllSegments(cube);\n        }\n\n        try {\n            return getCubeManager().updateCube(cube, null, null, null, RealizationStatusEnum.READY);\n        } catch (IOException e) {\n            cube.setStatus(ostatus);\n            throw e;\n        }\n    }\n","new_comment_raw":"Update a cube status from disable to ready.","old_comment_raw":"Update a cube status from disable to ready.","label":0,"pre_label":1,"AST_level":10,"line_counts":30,"new_code_token_num":256},{"new_code_raw":"protected Object convertTimeToMicrosPastMidnight(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0L; \/\/ return epoch } try { return MicroTime.toMicroOfDay(data, adjuster); } catch (IllegalArgumentException e) { return handleUnknownData(column, fieldDefn, data); } }","old_code_raw":"    protected Object convertTimeToMicrosPastMidnight(Column column, Field fieldDefn, Object data) {\n        if (data == null) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return 0L; \/\/ return epoch\n        }\n        try {\n            return MicroTime.toMicroOfDay(data);\n        } catch (IllegalArgumentException e) {\n            return handleUnknownData(column, fieldDefn, data);\n        }\n    }\n","new_comment_raw":"Converts a value object for an expected JDBC type of  Types#TIME to  MicroTime values, or microseconds past midnight.","old_comment_raw":"Converts a value object for an expected JDBC type of Types#TIME to MicroTime values, or microseconds past midnight.","label":0,"pre_label":1,"AST_level":8,"line_counts":15,"new_code_token_num":84},{"new_code_raw":"public static Predicate or(Predicate left, Predicate right) { left = (Predicate) extract(left); right = (Predicate) extract(right); if (left == null) { return right; } else if (right == null) { return left; } else { return PredicateOperation.create(Ops.OR, left, right); } }","old_code_raw":"    public static Predicate or(Predicate left, Predicate right) {\n        return PredicateOperation.create(Ops.OR, left, right);\n    }\n","new_comment_raw":"Create a left or right expression","old_comment_raw":"Create a left or right expression","label":0,"pre_label":1,"AST_level":8,"line_counts":12,"new_code_token_num":67},{"new_code_raw":"public ArrayList filterContent(String key) { return this.of.filter(key); }","old_code_raw":"\t\tpublic ArrayList filterContent(String prefix) {\n\t\t\t\/\/ prefix MUST be in lowercase\n\t\t\tif (\"\".equals(prefix)) {\n\t\t\t\tthis.filteredItemsBuffer = new ArrayList(getItemIds());\n\t\t\t\treturn this.filteredItemsBuffer;\n\n\t\t\t} else if (items != null) { \n\t\t\t\t\/\/ all items will be iterated and tested.\n\t\t\t\t\/\/ SLOW when there are lot of items.\n\t\t\t\t\/\/ TODO Should we add \n\t\t\t\tthis.filteredItemsBuffer = new ArrayList();\n\t\t\t\tfor (Iterator iter = items.getItemIds().iterator(); iter\n\t\t\t\t\t\t.hasNext();) {\n\t\t\t\t\tObject id = iter.next();\n\n\t\t\t\t\tItem item = getItem(id);\n\t\t\t\t\tString test = \"\";\n\t\t\t\t\tif (getItemCaptionMode() == ITEM_CAPTION_MODE_PROPERTY)\n\t\t\t\t\t\ttest = item.getItemProperty(getItemCaptionPropertyId())\n\t\t\t\t\t\t\t\t.getValue().toString().trim();\n\t\t\t\t\telse\n\t\t\t\t\t\ttest = String.valueOf(id);\n\n\t\t\t\t\tif (test.toLowerCase().startsWith(prefix)) {\n\t\t\t\t\t\tthis.filteredItemsBuffer.add(id);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this.filteredItemsBuffer;\n\t\t}\n","new_comment_raw":"Updates the visible items by given key.","old_comment_raw":"Updates the visible items by given prefix.","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":17},{"new_code_raw":"protected String[] convert(Path<?> leftHandSide, Object rightHandSide) { String str = rightHandSide.toString(); if (lowerCase){ str = str.toLowerCase(); } if (splitTerms) { if (str.equals(\"\")) { return new String[] { str }; } else { return StringUtils.split(str); } } else { return new String[] { str }; } }","old_code_raw":"    protected String convert(Path<?> path, Object value){\n        return value.toString();\n    }\n","new_comment_raw":"template method","old_comment_raw":"Template method, override to customize.","label":1,"pre_label":0,"AST_level":10,"line_counts":16,"new_code_token_num":82},{"new_code_raw":"protected int getInSubqueryThreshold() { return config.getInSubqueryThreshold(); }","old_code_raw":"  protected int getInSubqueryThreshold() {\n    return IN_SUBQUERY_THRESHOLD;\n  }\n","new_comment_raw":"Gets the list size threshold under which  #convertInToOr is used.","old_comment_raw":"Gets the list size threshold under which #convertInToOr is used.","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":13},{"new_code_raw":"public static GitlabRepositoryName create(final String url) { LOGGER.log(Level.FINE, \"Constructing from URL {0}\", url); for (Pattern p : URL_PATTERNS) { Matcher m = p.matcher(url.trim()); if (m.matches()) { LOGGER.log(Level.FINE, \"URL matches {0}\", m); GitlabRepositoryName ret = new GitlabRepositoryName(m.group(1), m.group(2), m.group(3)); LOGGER.log(Level.FINE, \"Object is {0}\", ret); return ret; } } LOGGER.log(Level.WARNING, \"Could not match URL {0}\", url); return null; }","old_code_raw":"    public static GitHubRepositoryName create(final String url) {\n        LOGGER.log(Level.FINE, \"Constructing from URL {0}\", url);\n        for (Pattern p : URL_PATTERNS) {\n            Matcher m = p.matcher(url.trim());\n            if (m.matches()) {\n                LOGGER.log(Level.FINE, \"URL matches {0}\", m);\n                GitHubRepositoryName ret = new GitHubRepositoryName(m.group(1), m.group(2),\n                        m.group(3));\n                LOGGER.log(Level.FINE, \"Object is {0}\", ret);\n                return ret;\n            }\n        }\n        LOGGER.log(Level.WARNING, \"Could not match URL {0}\", url);\n        return null;\n    }\n","new_comment_raw":"Create  GitlabRepositoryName from URL","old_comment_raw":"Create GitHubRepositoryName from URL","label":1,"pre_label":0,"AST_level":11,"line_counts":17,"new_code_token_num":141},{"new_code_raw":"private static RemoteCalculator lookupRemoteStatelessCalculator() throws NamingException { final Hashtable jndiProperties = new Hashtable(); jndiProperties.put(Context.URL_PKG_PREFIXES, \"org.jboss.ejb.client.naming\"); final Context context = new InitialContext(jndiProperties); \/\/ The JNDI lookup name for a stateless session bean has the syntax of: \/\/ ejb:<appName>\/<moduleName>\/<distinctName>\/<beanName>!<viewClassName> \/\/ \/\/ <appName> The application name is the name of the EAR that the EJB is deployed in \/\/ (without the .ear). If the EJB JAR is not deployed in an EAR then this is \/\/ blank. The app name can also be specified in the EAR's application.xml \/\/ \/\/ <moduleName> By the default the module name is the name of the EJB JAR file (without the \/\/ .jar suffix). The module name might be overridden in the ejb-jar.xml \/\/ \/\/ <distinctName> : WildFly allows each deployment to have an (optional) distinct name. \/\/ This example does not use this so leave it blank. \/\/ \/\/ <beanName> : The name of the session been to be invoked. \/\/ \/\/ <viewClassName>: The fully qualified classname of the remote interface. Must include \/\/ the whole package name. \/\/ let's do the lookup return (RemoteCalculator) context.lookup(\"ejb:\/wildfly-ejb-remote-server-side\/CalculatorBean!\" + RemoteCalculator.class.getName()); }","old_code_raw":"    private static RemoteCalculator lookupRemoteStatelessCalculator() throws NamingException {\n        final Hashtable jndiProperties = new Hashtable();\n        jndiProperties.put(Context.URL_PKG_PREFIXES, \"org.jboss.ejb.client.naming\");\n        final Context context = new InitialContext(jndiProperties);\n\n        \/\/ The JNDI lookup name for a stateless session bean has the syntax of:\n        \/\/ ejb:<appName>\/<moduleName>\/<distinctName>\/<beanName>!<viewClassName>\n        \/\/\n        \/\/ <appName> The application name is the name of the EAR that the EJB is deployed in\n        \/\/ (without the .ear). If the EJB JAR is not deployed in an EAR then this is\n        \/\/ blank. The app name can also be specified in the EAR's application.xml\n        \/\/\n        \/\/ <moduleName> By the default the module name is the name of the EJB JAR file (without the\n        \/\/ .jar suffix). The module name might be overridden in the ejb-jar.xml\n        \/\/\n        \/\/ <distinctName> : AS7 allows each deployment to have an (optional) distinct name.\n        \/\/ This example does not use this so leave it blank.\n        \/\/\n        \/\/ <beanName> : The name of the session been to be invoked.\n        \/\/\n        \/\/ <viewClassName>: The fully qualified classname of the remote interface. Must include\n        \/\/ the whole package name.\n\n        \/\/ let's do the lookup\n        return (RemoteCalculator) context.lookup(\"ejb:\/jboss-as-ejb-remote-server-side\/CalculatorBean!\"\n                + RemoteCalculator.class.getName());\n    }\n","new_comment_raw":"Looks up and returns the proxy to remote stateless calculator bean","old_comment_raw":"Looks up and returns the proxy to remote stateless calculator bean","label":0,"pre_label":1,"AST_level":8,"line_counts":28,"new_code_token_num":274},{"new_code_raw":"public final FileChannel getChannel() { synchronized(this) { if(channel == null) { channel = FileChannelFactory.getFileChannel(this, fd.descriptor, options); } return channel; } }","old_code_raw":"    public final synchronized FileChannel getChannel() {\n        return channel;\n    }\n","new_comment_raw":"Gets this file's  FileChannel object.","old_comment_raw":"Returns the FileChannel equivalent to this stream.","label":1,"pre_label":0,"AST_level":9,"line_counts":11,"new_code_token_num":36},{"new_code_raw":"public DocumentCollection getMetadataByName(String name, String[] docs) throws RepositoryAccessException { String[] names = {name}; return this.getDocCollection(names, docs); \/* HashMap<String, String[]> vals = new HashMap<String, String[]>(); HashSet<String> activeFields = new HashSet<String>(); HashSet<String> lazyFields = new HashSet<String>(); activeFields.add(LUCENE_DOCID_FIELD); lazyFields.add(name); SetBasedFieldSelector fsel = new SetBasedFieldSelector(activeFields, lazyFields); IndexReader lreader; try { lreader = this.getIndexReader(); int last = lreader.maxDoc(); Document d; String docID; for(int i = 0; i < last; ++i) { if(!lreader.isDeleted(i)) { d = lreader.document(i, fsel); docID = d.get(LUCENE_DOCID_FIELD); for(String did: docs) if(did.equals(docID)) vals.put(docID, d.getValues(name)); } } lreader.close(); } catch (java.io.IOException ioe) { throw new RepositoryAccessException(\"IOException: \" + ioe.getMessage()); } return vals; *\/ }","old_code_raw":"\tpublic java.util.Map<String, String[]> getMetadataByName(String name, String[] docs) \n\t\t\tthrows RepositoryAccessException {\n\t\t\n\t\t\n\t\t\/*\n\t\t * Loop through all IDs, getting a document with only attribute DocID\n\t\t * If docID matches, fetch name too?\n\t\t *\/\n\t\t\n\t\tHashMap<String, String[]> vals = new HashMap<String, String[]>();\n\t\t\n\t\tHashSet<String> activeFields = new HashSet<String>();\n\t\tHashSet<String> lazyFields = new HashSet<String>();\n\t\t\n\t\tactiveFields.add(LUCENE_DOCID_FIELD);\n\t\tlazyFields.add(name);\n\t\t\n\t\tSetBasedFieldSelector fsel = new SetBasedFieldSelector(activeFields, lazyFields);\n\t\tIndexReader lreader;\n\t\t\n\t\ttry {\n\t\t\tlreader = this.getIndexReader();\n\t\t\tint last = lreader.maxDoc();\n\t\t\tDocument d;\n\t\t\tString docID;\n\t\t\tfor(int i = 0; i < last; ++i) {\n\t\t\t\tif(!lreader.isDeleted(i)) {\n\t\t\t\t\td = lreader.document(i, fsel);\n\t\t\t\t\tdocID = d.get(LUCENE_DOCID_FIELD);\n\t\t\t\t\tfor(String did: docs)\n\t\t\t\t\t\tif(did.equals(docID)) vals.put(docID, d.getValues(name));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tlreader.close();\n\t\t} catch (java.io.IOException ioe) {\n\t\t\tthrow new RepositoryAccessException(\"IOException: \" + ioe.getMessage());\n\t\t}\n\t\t\n\t\treturn vals;\n\t}\n","new_comment_raw":"Returns a DocumentCollection of document IDs and metadata.","old_comment_raw":"Returns a map of document IDs and values.","label":1,"pre_label":0,"AST_level":6,"line_counts":42,"new_code_token_num":220},{"new_code_raw":"public List getImageSrcs(boolean duplicate) { if (duplicate) { return this.htmlHandler.getAllImageSrcs(); } return this.htmlHandler.getImageSrcs(); }","old_code_raw":"    public List getImageSrcs(boolean duplicate) {\n        if (duplicate) {\n            return htmlHandler.getAllImageSrcs();\n        } else {\n            return htmlHandler.getImageSrcs();\n        }\n    }\n","new_comment_raw":"Get Image src attributes","old_comment_raw":"DOCUMENT ME!","label":1,"pre_label":0,"AST_level":7,"line_counts":8,"new_code_token_num":29},{"new_code_raw":"@SuppressWarnings(\"static-access\") public ObjectName getExchangeObjectName(String virtualHostName, String exchange) { \/\/ Get the name of the test manager AllObjects allObject = new AllObjects(_mbsc); allObject.querystring = \"org.apache.qpid:type=VirtualHost.Exchange,VirtualHost=\" + virtualHostName + \",name=\" + exchange + \",*\"; Set<ObjectName> objectNames = allObject.returnObjects(); _test.assertNotNull(\"Null ObjectName Set returned\", objectNames); _test.assertEquals(\"Incorrect number of exchange with name '\" + exchange + \"' returned\", 1, objectNames.size()); \/\/ We have verified we have only one value in objectNames so return it ObjectName objectName = objectNames.iterator().next(); _test.getLogger().info(\"Loading: \" + objectName); return objectName; }","old_code_raw":"    public ObjectName getExchangeObjectName(String virtualHostName, String exchange)\n    {\n        \/\/ Get the name of the test manager\n        AllObjects allObject = new AllObjects(_mbsc);\n        allObject.querystring = \"org.apache.qpid:type=VirtualHost.Exchange,VirtualHost=\" + virtualHostName + \",name=\" + exchange + \",*\";\n\n        Set<ObjectName> objectNames = allObject.returnObjects();\n\n        _test.assertNotNull(\"Null ObjectName Set returned\", objectNames);\n        _test.assertEquals(\"Incorrect number of exchange with name '\" + exchange +\n                           \"' returned\", 1, objectNames.size());\n\n        \/\/ We have verified we have only one value in objectNames so return it\n        return objectNames.iterator().next();\n    }\n","new_comment_raw":"Retrive the ObjectName for the given Exchange on a VirtualHost.","old_comment_raw":"Retrive the ObjectName for the given Exchange on the test Virtualhost.","label":1,"pre_label":0,"AST_level":9,"line_counts":19,"new_code_token_num":157},{"new_code_raw":"public ProjectItem getChild(String text) { String[] childPath = new String[path.length + 1]; System.arraycopy(path, 0, childPath, 0, path.length); childPath[childPath.length - 1] = text; return project.getProjectItem(childPath); }","old_code_raw":"\tpublic ProjectItem getChild(String text) {\n\t\tString[] childPath = new String[path.length + 1];\n\t\tSystem.arraycopy(path, 0, childPath, 0, path.length);\n\t\tchildPath[childPath.length - 1] = text;\n\t\treturn new ProjectItem(treeViewerHandler.getTreeItem(\n\t\t\t\ttreeItem, text), project, childPath);\n\t}\n","new_comment_raw":"Gets child of the project item.","old_comment_raw":"Gets child of the project item with given text without decorators.","label":1,"pre_label":0,"AST_level":8,"line_counts":8,"new_code_token_num":53},{"new_code_raw":"public Double getEnumNumber() { if (enumNumber == null) { return null; } return enumNumber.value(); }","old_code_raw":"  public EnumNumberEnum getEnumNumber() {\n    return enumNumber;\n  }\n","new_comment_raw":"Get enumNumber","old_comment_raw":"Get enumNumber","label":0,"pre_label":1,"AST_level":6,"line_counts":7,"new_code_token_num":23},{"new_code_raw":"protected EngineParameterMetaData getParameterMetaData() throws SQLException { if (stmtPmeta != null) return stmtPmeta; stmtPmeta = ((EnginePreparedStatement)ps).getEmbedParameterSetMetaData(); return stmtPmeta; }","old_code_raw":"\tprotected EmbedParameterSetMetaData getParameterMetaData() throws SQLException\n\t{\n\t\tif (stmtPmeta != null)\n\t\t\treturn stmtPmeta;\n\n\t\tEmbedParameterSetMetaData pmeta = null;\n\t\tClass[] getParameterMetaDataParam = {};\n\t\ttry {\n\t\t\tMethod sh =\n\t\t\t\tgetPreparedStatement().getClass().getMethod(\"getEmbedParameterSetMetaData\", getParameterMetaDataParam);\n\t\t\tpmeta = (EmbedParameterSetMetaData)\n\t\t\t\tsh.invoke(getPreparedStatement(),null);\n\t\t\tstmtPmeta = pmeta;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\thandleReflectionException(e);\n\t\t}\n\t\treturn stmtPmeta;\n\t}\n","new_comment_raw":"Retrieve the ParameterMetaData for the prepared statement.","old_comment_raw":"Get parameter metadata from EmbedPreparedStatement or","label":1,"pre_label":0,"AST_level":6,"line_counts":11,"new_code_token_num":32},{"new_code_raw":"public Object getProperty(String name) { if (name == null || !isPropertySupported(name)) throw new IllegalArgumentException(); return callProperties.get(name); } \/\/ getProperty","old_code_raw":"    public Object getProperty(String name) {\n        if (name != null)\n            return callProperties.get(name);\n        return null;\n    } \/\/ getProperty\n","new_comment_raw":"Returns the value associated with the named property","old_comment_raw":"Returns the value associated with the named property - or null if not defined\/set.","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":37},{"new_code_raw":"protected static CodecFactory getCompressionCodec(TaskAttemptContext context) { if (FileOutputFormat.getCompressOutput(context)) { \/\/ Default to deflate compression. int deflateLevel = context.getConfiguration().getInt( org.apache.avro.mapred.AvroOutputFormat.DEFLATE_LEVEL_KEY, CodecFactory.DEFAULT_DEFLATE_LEVEL); int xzLevel = context.getConfiguration().getInt( org.apache.avro.mapred.AvroOutputFormat.XZ_LEVEL_KEY, CodecFactory.DEFAULT_XZ_LEVEL); String outputCodec = context.getConfiguration() .get(AvroJob.CONF_OUTPUT_CODEC); if (outputCodec == null) { String compressionCodec = context.getConfiguration().get(\"mapred.output.compression.codec\"); String avroCodecName = HadoopCodecFactory.getAvroCodecName(compressionCodec); if ( avroCodecName != null){ context.getConfiguration().set(AvroJob.CONF_OUTPUT_CODEC, avroCodecName); return HadoopCodecFactory.fromHadoopString(compressionCodec); } else { return CodecFactory.deflateCodec(deflateLevel); } } else if (DataFileConstants.DEFLATE_CODEC.equals(outputCodec)) { return CodecFactory.deflateCodec(deflateLevel); } else if (DataFileConstants.XZ_CODEC.equals(outputCodec)) { return CodecFactory.xzCodec(xzLevel); } else { return CodecFactory.fromString(outputCodec); } } \/\/ No compression. return CodecFactory.nullCodec(); }","old_code_raw":"  protected static CodecFactory getCompressionCodec(TaskAttemptContext context) {\n    if (FileOutputFormat.getCompressOutput(context)) {\n      \/\/ Default to deflate compression.\n      int compressionLevel = context.getConfiguration().getInt(\n          org.apache.avro.mapred.AvroOutputFormat.DEFLATE_LEVEL_KEY,\n          org.apache.avro.mapred.AvroOutputFormat.DEFAULT_DEFLATE_LEVEL);\n      \n      String outputCodec = context.getConfiguration()\n        .get(AvroJob.CONF_OUTPUT_CODEC);\n\n      if (outputCodec == null) {\n        String compressionCodec = context.getConfiguration().get(\"mapred.output.compression.codec\");\n        String avroCodecName = HadoopCodecFactory.getAvroCodecName(compressionCodec);\n        if ( avroCodecName != null){\n          context.getConfiguration().set(AvroJob.CONF_OUTPUT_CODEC, avroCodecName);\n          return HadoopCodecFactory.fromHadoopString(compressionCodec);\n        } else {\n          return CodecFactory.deflateCodec(compressionLevel);\n        }\n      } else if (DataFileConstants.DEFLATE_CODEC.equals(outputCodec)) {\n          return CodecFactory.deflateCodec(compressionLevel);\n        } else {\n          return CodecFactory.fromString(outputCodec);\n        }\n      \n      }\n\n    \/\/ No compression.\n    return CodecFactory.nullCodec();\n  }\n","new_comment_raw":"Gets the configured compression codec from the task context.","old_comment_raw":"Gets the configured compression codec from the task context.","label":0,"pre_label":1,"AST_level":12,"line_counts":36,"new_code_token_num":202},{"new_code_raw":"public boolean peek() { if (outputQueue.isEmpty()) { return false; } else { final int nextId = outputQueue.peek().id; return orderResults ? nextId == lastReturnedId + 1 : true; } }","old_code_raw":"  public boolean peek() {\n    if (outputQueue.isEmpty()) {\n      return false;\n    } else {\n       return orderResults ? outputQueue.containsKey(returnedItemCounter + 1) : true;\n    }\n  }\n","new_comment_raw":"Indicates whether a not a new result is available.","old_comment_raw":"Indicates whether or not a new result is available.","label":1,"pre_label":0,"AST_level":9,"line_counts":9,"new_code_token_num":41},{"new_code_raw":"public ParameterList getBodyParams() { return bodyParams; }","old_code_raw":"  public Map<String, String> getBodyParams()\n  {\n    return bodyParams;\n  }\n","new_comment_raw":"Obtains a  ParameterList of the body parameters.","old_comment_raw":"Obtains a Map of the body parameters.","label":1,"pre_label":0,"AST_level":4,"line_counts":6,"new_code_token_num":10},{"new_code_raw":"public Vector getErrors() { return _parser.getErrors(); }","old_code_raw":"    public ArrayList<ErrorMsg> getErrors() {\n        return _parser.getErrors();\n    }\n","new_comment_raw":"Get a Vector containing all compile error messages","old_comment_raw":"Get a list of all compile error messages","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":13},{"new_code_raw":"public ArchiveEntry findMostRecentArchive(Connection con, int indexId, int archiveId) { return con.createQuery(\"select archive.id, archive.archiveId, archive.nameHash,\" + \" archive.crc, archive.revision, archive.hash from archive \" + \"join index_archive on index_archive.archive = archive.id \" + \"join `index` on index.id = index_archive.index \" + \"where index.indexId = :indexId and archive.archiveId = :archiveId \" + \"group by archive.id \" + \"order by archive.revision desc \" + \"limit 1\") .addParameter(\"indexId\", indexId) .addParameter(\"archiveId\", archiveId) .executeAndFetchFirst(ArchiveEntry.class); }","old_code_raw":"\tpublic ArchiveEntry findMostRecentArchive(Connection con, int indexId, int archiveId)\n\t{\n\t\treturn con.createQuery(\"select archive.id, archive.archiveId, archive.nameHash, archive.revision from archive \"\n\t\t\t+ \"join index_archive on index_archive.archive = archive.id \"\n\t\t\t+ \"join `index` on index.id = index_archive.index \"\n\t\t\t+ \"where index.indexId = :indexId and archive.archiveId = :archiveId \"\n\t\t\t+ \"group by archive.id \"\n\t\t\t+ \"order by archive.revision desc \"\n\t\t\t+ \"limit 1\")\n\t\t\t.addParameter(\"indexId\", indexId)\n\t\t\t.addParameter(\"archiveId\", archiveId)\n\t\t\t.executeAndFetchFirst(ArchiveEntry.class);\n\t}\n","new_comment_raw":"Finds the most recent archive for the given indexId\/archiveId","old_comment_raw":"Finds the most recent archive for the given indexId\/archiveId","label":0,"pre_label":1,"AST_level":12,"line_counts":15,"new_code_token_num":120},{"new_code_raw":"public static StringTemplate stringTemplate(String template, ImmutableList<?> args) { return stringTemplate(createTemplate(template), args); }","old_code_raw":"    public static StringTemplate stringTemplate(String template, ImmutableList<?> args) {\n        return new StringTemplate(createTemplate(template), args);\n    }\n","new_comment_raw":"Create a new Template expression","old_comment_raw":"Create a new Template expression","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":25},{"new_code_raw":"public int getMinimumValue() { return DateTimeConstants.MONDAY; }","old_code_raw":"    public int getMinimumValue() {\n        return MIN;\n    }\n","new_comment_raw":"Get the minimum value that this field can have.","old_comment_raw":"Get the minimum value that this field can have.","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":11},{"new_code_raw":"public final List<ModuleReference> getDependentModulesRecursively(final ModuleReference ref) throws Exception { return getDependentModulesRecursively(ref, new ArrayList<ModuleReference>()); }","old_code_raw":"    public synchronized final List<String> getDependentModulesRecursively(final String id) throws Exception {\r\n        final List<String> res = new ArrayList<String>();\r\n        for (final String depModule : getDependentModules(id)) {\r\n            res.add(depModule);\r\n            \/\/ the graph has no cycle, so we don't need to protected against infinite loop\r\n\r\n            res.addAll(this.getDependentModulesRecursively(depModule));\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n","new_comment_raw":"The list of installed modules depending on the passed one.","old_comment_raw":"The list of modules depending on the passed one.","label":1,"pre_label":0,"AST_level":8,"line_counts":5,"new_code_token_num":26},{"new_code_raw":"public static InboundContext getActiveSessionAndProducer() { return threadLocal.get(); }","old_code_raw":"    public static InboundContext getActiveSessionAndProducer() {\n        return (InboundContext) threadLocal.get();\n    }\n","new_comment_raw":"Returns the current  InboundContext used by the current thread which is processing a message.","old_comment_raw":"Returns the current InboundContext used by the current thread which is processing a message.","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":14},{"new_code_raw":"public Object getValue(PgProto.DatumMessage datumMessage, PgConnectionSupplier connection, boolean includeUnknownDatatypes) { int columnType = (int) datumMessage.getColumnType(); switch (columnType) { case PgOid.BOOL: return datumMessage.hasDatumBool() ? datumMessage.getDatumBool() : null; case PgOid.INT2: case PgOid.INT4: return datumMessage.hasDatumInt32() ? datumMessage.getDatumInt32() : null; case PgOid.INT8: case PgOid.OID: case PgOid.MONEY: return datumMessage.hasDatumInt64() ? datumMessage.getDatumInt64() : null; case PgOid.FLOAT4: return datumMessage.hasDatumFloat()? datumMessage.getDatumFloat() : null; case PgOid.FLOAT8: return datumMessage.hasDatumDouble() ? datumMessage.getDatumDouble() : null; case PgOid.NUMERIC: if (datumMessage.hasDatumDouble()) { \/\/ For backwards compatibility only to enable independent upgrade of Postgres plug-in return datumMessage.getDatumDouble(); } else if (datumMessage.hasDatumString()) { final String s = datumMessage.getDatumString(); return PostgresValueConverter.toSpecialValue(s).orElseGet(() -> new SpecialValueDecimal(new BigDecimal(s))); } return null; case PgOid.CHAR: case PgOid.VARCHAR: case PgOid.BPCHAR: case PgOid.TEXT: case PgOid.JSON: case PgOid.JSONB_OID: case PgOid.XML: case PgOid.UUID: case PgOid.BIT: case PgOid.VARBIT: case PgOid.INET_OID: case PgOid.CIDR_OID: case PgOid.MACADDR_OID: case PgOid.MACADDR8_OID: return datumMessage.hasDatumString() ? datumMessage.getDatumString() : null; case PgOid.DATE: return datumMessage.hasDatumInt32() ? (long) datumMessage.getDatumInt32() : null; case PgOid.TIMESTAMP: if (!datumMessage.hasDatumInt64()) { return null; } \/\/ these types are sent by the plugin as LONG - microseconds since Unix Epoch return Conversions.toInstantFromMicros(datumMessage.getDatumInt64()); case PgOid.TIMESTAMPTZ: if (!datumMessage.hasDatumInt64()) { return null; } \/\/ these types are sent by the plugin as LONG - microseconds since Unix Epoch return Conversions.toInstantFromMicros(datumMessage.getDatumInt64()).atOffset(ZoneOffset.UTC); case PgOid.TIME: if (!datumMessage.hasDatumInt64()) { return null; } \/\/ these types are sent by the plugin as LONG - microseconds since Unix Epoch return Duration.of(datumMessage.getDatumInt64(), ChronoUnit.MICROS); case PgOid.TIMETZ: if (!datumMessage.hasDatumDouble()) { return null; } \/\/ the value is sent as a double microseconds return Conversions.toInstantFromMicros((long) datumMessage.getDatumDouble()) .atOffset(ZoneOffset.UTC) .toOffsetTime(); case PgOid.INTERVAL: \/\/ these are sent as doubles by the plugin since their storage is larger than 8 bytes return datumMessage.hasDatumDouble() ? datumMessage.getDatumDouble() : null; \/\/ the plugin will send back a TZ formatted string case PgOid.BYTEA: return datumMessage.hasDatumBytes() ? datumMessage.getDatumBytes().toByteArray() : null; case PgOid.POINT: { PgProto.Point datumPoint = datumMessage.getDatumPoint(); return new PGpoint(datumPoint.getX(), datumPoint.getY()); } case PgOid.TSRANGE_OID: case PgOid.TSTZRANGE_OID: case PgOid.DATERANGE_OID: case PgOid.INT4RANGE_OID: case PgOid.NUM_RANGE_OID: case PgOid.INT8RANGE_OID: return datumMessage.hasDatumBytes() ? new String(datumMessage.getDatumBytes().toByteArray(), Charset.forName(\"UTF-8\")) : null; case PgOid.INT2_ARRAY: case PgOid.INT4_ARRAY: case PgOid.INT8_ARRAY: case PgOid.TEXT_ARRAY: case PgOid.NUMERIC_ARRAY: case PgOid.FLOAT4_ARRAY: case PgOid.FLOAT8_ARRAY: case PgOid.BOOL_ARRAY: case PgOid.DATE_ARRAY: case PgOid.TIME_ARRAY: case PgOid.TIMETZ_ARRAY: case PgOid.TIMESTAMP_ARRAY: case PgOid.TIMESTAMPTZ_ARRAY: case PgOid.BYTEA_ARRAY: case PgOid.VARCHAR_ARRAY: case PgOid.OID_ARRAY: case PgOid.BPCHAR_ARRAY: case PgOid.MONEY_ARRAY: case PgOid.NAME_ARRAY: case PgOid.INTERVAL_ARRAY: case PgOid.CHAR_ARRAY: case PgOid.VARBIT_ARRAY: case PgOid.UUID_ARRAY: case PgOid.XML_ARRAY: case PgOid.POINT_ARRAY: case PgOid.JSONB_ARRAY: case PgOid.JSON_ARRAY: case PgOid.REF_CURSOR_ARRAY: case PgOid.INET_ARRAY: case PgOid.CIDR_ARRAY: case PgOid.MACADDR_ARRAY: case PgOid.MACADDR8_ARRAY: case PgOid.TSRANGE_ARRAY: case PgOid.TSTZRANGE_ARRAY: case PgOid.DATERANGE_ARRAY: case PgOid.INT4RANGE_ARRAY: case PgOid.NUM_RANGE_ARRAY: case PgOid.INT8RANGE_ARRAY: return getArray(datumMessage, connection, columnType); case PgOid.UNSPECIFIED: return null; default: PostgresType type = typeRegistry.get(columnType); if (type.getOid() == typeRegistry.geometryOid() || type.getOid() == typeRegistry.geographyOid() || type.getOid() == typeRegistry.citextOid() ) { return datumMessage.getDatumBytes().toByteArray(); } if(type.getOid() == typeRegistry.hstoreOid()) { return datumMessage.getDatumBytes().toByteArray(); } if (type.getOid() == typeRegistry.geometryArrayOid() || type.getOid() == typeRegistry.geographyArrayOid() || type.getOid() == typeRegistry.citextArrayOid() || type.getOid() == typeRegistry.hstoreArrayOid()) { return getArray(datumMessage, connection, columnType); } \/\/ unknown data type is sent by decoder as binary value if (includeUnknownDatatypes && datumMessage.hasDatumBytes()) { return datumMessage.getDatumBytes().toByteArray(); } return null; } }","old_code_raw":"    public Object getValue(PgProto.DatumMessage datumMessage, PgConnectionSupplier connection, boolean includeUnknownDatatypes) {\n        int columnType = (int) datumMessage.getColumnType();\n        switch (columnType) {\n            case PgOid.BOOL:\n                return datumMessage.hasDatumBool() ? datumMessage.getDatumBool() : null;\n            case PgOid.INT2:\n            case PgOid.INT4:\n                return datumMessage.hasDatumInt32() ? datumMessage.getDatumInt32() : null;\n            case PgOid.INT8:\n            case PgOid.OID:\n            case PgOid.MONEY:\n                return datumMessage.hasDatumInt64() ? datumMessage.getDatumInt64() : null;\n            case PgOid.FLOAT4:\n                return datumMessage.hasDatumFloat()? datumMessage.getDatumFloat() : null;\n            case PgOid.FLOAT8:\n                return datumMessage.hasDatumDouble() ? datumMessage.getDatumDouble() : null;\n            case PgOid.NUMERIC:\n                if (datumMessage.hasDatumDouble()) {\n                    \/\/ For backwards compatibility only to enable independent upgrade of Postgres plug-in\n                    return datumMessage.getDatumDouble();\n                }\n                else if (datumMessage.hasDatumString()) {\n                    final String s = datumMessage.getDatumString();\n                    return PostgresValueConverter.toSpecialValue(s).orElseGet(() -> new SpecialValueDecimal(new BigDecimal(s)));\n                }\n                return null;\n            case PgOid.CHAR:\n            case PgOid.VARCHAR:\n            case PgOid.BPCHAR:\n            case PgOid.TEXT:\n            case PgOid.JSON:\n            case PgOid.JSONB_OID:\n            case PgOid.XML:\n            case PgOid.UUID:\n            case PgOid.BIT:\n            case PgOid.VARBIT:\n            case PgOid.INET_OID:\n            case PgOid.CIDR_OID:\n            case PgOid.MACADDR_OID:\n            case PgOid.MACADDR8_OID:\n                return datumMessage.hasDatumString() ? datumMessage.getDatumString() : null;\n            case PgOid.DATE:\n                return datumMessage.hasDatumInt32() ? (long) datumMessage.getDatumInt32() : null;\n            case PgOid.TIMESTAMP:\n                if (!datumMessage.hasDatumInt64()) {\n                    return null;\n                }\n                \/\/ these types are sent by the plugin as LONG - microseconds since Unix Epoch\n                \/\/ but we'll convert them to nanos which is the smallest unit\n                final LocalDateTime serverLocal = Conversions.toLocalDateTimeUTC(datumMessage.getDatumInt64());\n                return Conversions.toEpochNanos(serverLocal.toInstant(ZoneOffset.UTC));\n            case PgOid.TIMESTAMPTZ:\n            case PgOid.TIME:\n                if (!datumMessage.hasDatumInt64()) {\n                    return null;\n                }\n                \/\/ these types are sent by the plugin as LONG - microseconds since Unix Epoch\n                \/\/ but we'll convert them to nanos which is the smallest unit\n                return TimeUnit.NANOSECONDS.convert(datumMessage.getDatumInt64(), TimeUnit.MICROSECONDS);\n            case PgOid.TIMETZ:\n                if (!datumMessage.hasDatumDouble()) {\n                    return null;\n                }\n                \/\/ the value is sent as a double microseconds, convert to nano\n                return BigDecimal.valueOf(datumMessage.getDatumDouble() * 1000).longValue();\n            case PgOid.INTERVAL:\n                \/\/ these are sent as doubles by the plugin since their storage is larger than 8 bytes\n                return datumMessage.hasDatumDouble() ? datumMessage.getDatumDouble() : null;\n            \/\/ the plugin will send back a TZ formatted string\n            case PgOid.BYTEA:\n                return datumMessage.hasDatumBytes() ? datumMessage.getDatumBytes().toByteArray() : null;\n            case PgOid.POINT: {\n                PgProto.Point datumPoint = datumMessage.getDatumPoint();\n                return new PGpoint(datumPoint.getX(), datumPoint.getY());\n            }\n            case PgOid.TSRANGE_OID:\n            case PgOid.TSTZRANGE_OID:\n            case PgOid.DATERANGE_OID:\n            case PgOid.INT4RANGE_OID:\n            case PgOid.NUM_RANGE_OID:\n            case PgOid.INT8RANGE_OID:\n                return datumMessage.hasDatumBytes() ? new String(datumMessage.getDatumBytes().toByteArray(), Charset.forName(\"UTF-8\")) : null;\n            case PgOid.INT2_ARRAY:\n            case PgOid.INT4_ARRAY:\n            case PgOid.INT8_ARRAY:\n            case PgOid.TEXT_ARRAY:\n            case PgOid.NUMERIC_ARRAY:\n            case PgOid.FLOAT4_ARRAY:\n            case PgOid.FLOAT8_ARRAY:\n            case PgOid.BOOL_ARRAY:\n            case PgOid.DATE_ARRAY:\n            case PgOid.TIME_ARRAY:\n            case PgOid.TIMETZ_ARRAY:\n            case PgOid.TIMESTAMP_ARRAY:\n            case PgOid.TIMESTAMPTZ_ARRAY:\n            case PgOid.BYTEA_ARRAY:\n            case PgOid.VARCHAR_ARRAY:\n            case PgOid.OID_ARRAY:\n            case PgOid.BPCHAR_ARRAY:\n            case PgOid.MONEY_ARRAY:\n            case PgOid.NAME_ARRAY:\n            case PgOid.INTERVAL_ARRAY:\n            case PgOid.CHAR_ARRAY:\n            case PgOid.VARBIT_ARRAY:\n            case PgOid.UUID_ARRAY:\n            case PgOid.XML_ARRAY:\n            case PgOid.POINT_ARRAY:\n            case PgOid.JSONB_ARRAY:\n            case PgOid.JSON_ARRAY:\n            case PgOid.REF_CURSOR_ARRAY:\n            case PgOid.INET_ARRAY:\n            case PgOid.CIDR_ARRAY:\n            case PgOid.MACADDR_ARRAY:\n            case PgOid.MACADDR8_ARRAY:\n            case PgOid.TSRANGE_ARRAY:\n            case PgOid.TSTZRANGE_ARRAY:\n            case PgOid.DATERANGE_ARRAY:\n            case PgOid.INT4RANGE_ARRAY:\n            case PgOid.NUM_RANGE_ARRAY:\n            case PgOid.INT8RANGE_ARRAY:\n            return getArray(datumMessage, connection, columnType);\n\n            case PgOid.UNSPECIFIED:\n                return null;\n\n            default:\n                PostgresType type = typeRegistry.get(columnType);\n                if (type.getOid() == typeRegistry.geometryOid() || type.getOid() == typeRegistry.geographyOid() || type.getOid() == typeRegistry.citextOid() ) {\n                    return datumMessage.getDatumBytes().toByteArray();\n                }\n                if(type.getOid() == typeRegistry.hstoreOid()) {\n                    return datumMessage.getDatumBytes().toByteArray();\n                }\n                if (type.getOid() == typeRegistry.geometryArrayOid() ||\n                        type.getOid() == typeRegistry.geographyArrayOid() ||\n                        type.getOid() == typeRegistry.citextArrayOid() ||\n                        type.getOid() == typeRegistry.hstoreArrayOid()) {\n                    return getArray(datumMessage, connection, columnType);\n                }\n                \/\/ unknown data type is sent by decoder as binary value\n                if (includeUnknownDatatypes && datumMessage.hasDatumBytes()) {\n                    return datumMessage.getDatumBytes().toByteArray();\n                }\n\n                return null;\n        }\n    }\n","new_comment_raw":"Converts the Protobuf value for a  io.debezium.connector.postgresql.proto.PgProto.DatumMessage plugin message to a Java value based on the type of the column from the message.","old_comment_raw":"Converts the Protobuf value for a io.debezium.connector.postgresql.proto.PgProto.DatumMessage plugin message to a Java value based on the type of the column from the message.","label":0,"pre_label":1,"AST_level":14,"line_counts":153,"new_code_token_num":961},{"new_code_raw":"public static <T> T getObject(Heap heap, JsonValue name, Class<T> type) throws HeapException { if (name.isNull()) { return null; } return getRequiredObject(heap, name, type); }","old_code_raw":"    @SuppressWarnings(\"unchecked\")\n    public static <T> T getObject(Heap heap, JsonValue name, Class<T> type) throws HeapException {\n        Object o = heap.get(name.required().asString());\n        if (o != null && !(type.isInstance(o))) {\n            throw new JsonValueException(name, \"expecting heap object of type \" + type.getName());\n        }\n        return (T) o;\n    }\n","new_comment_raw":"Retrieves an object from a heap with the specified name and type, or  null if the name is  null.","old_comment_raw":"Retreives an object from a heap with the specified name and type.","label":1,"pre_label":0,"AST_level":6,"line_counts":8,"new_code_token_num":42},{"new_code_raw":"private Integer findColumn(String columnName) throws SQLException { return columnNameCache.getIndexForColumnName( columnName, rs ); }","old_code_raw":"\tprivate int findColumn(String columnName) throws SQLException {\n\t\treturn columnNameCache.getIndexForColumnName( columnName, rs );\n\t}\n","new_comment_raw":"Locate the column index corresponding to the given column name via the cache.","old_comment_raw":"Locate the column index corresponding to the given column name via the cache.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"public static Predicate<Connectivity> hasState(final NetworkInfo.State... states) { return new Predicate<Connectivity>() { @Override public boolean test(@NonNull Connectivity connectivity) throws Exception { for (NetworkInfo.State state : states) { if (connectivity.state() == state) { return true; } } return false; } }; }","old_code_raw":"  public static Predicate<Connectivity> hasState(final NetworkInfo.State... states) {\n    return new Predicate<Connectivity>() {\n      @Override public boolean test(@NonNull Connectivity connectivity) throws Exception {\n        for (NetworkInfo.State state : states) {\n          if (connectivity.getState() == state) {\n            return true;\n          }\n        }\n        return false;\n      }\n    };\n  }\n","new_comment_raw":"Filter, which returns true if at least one given state occurred","old_comment_raw":"Filter, which returns true if at least one given state occurred","label":0,"pre_label":1,"AST_level":11,"line_counts":13,"new_code_token_num":63},{"new_code_raw":"public IntegrationFlow fromFile() { return IntegrationFlows.from( Files.inboundAdapter(new File(\"\/tmp\/in\")) .preventDuplicates(false) .patternFilter(\"*.txt\"), e -> e.poller(Pollers.fixedDelay(5000) .errorChannel(\"tfrErrors.input\"))) .handle(Files.splitter(true, true)) .<Object, Class<?>>route(Object::getClass, m -> m .channelMapping(FileSplitter.FileMarker.class, \"markers.input\") .channelMapping(String.class, \"lines.input\")) .get(); }","old_code_raw":"\tpublic IntegrationFlow fromFile() {\n\t\treturn IntegrationFlows.from(Files.inboundAdapter(new File(\"\/tmp\/in\"))\n\t\t\t\t\t.preventDuplicates(false)\n\t\t\t\t\t.patternFilter(\"*.txt\"), e -> e.poller(Pollers.fixedDelay(5000).errorChannel(tfrErrorChannel())))\n\t\t\t\t.handle(Files.splitter(true, true))\n\t\t\t\t.<Object, Class<?>>route(Object::getClass, m -> m\n\t\t\t\t\t\t.channelMapping(FileSplitter.FileMarker.class, \"markers.input\")\n\t\t\t\t\t\t.channelMapping(String.class, \"lines.input\"))\n\t\t\t\t.get();\n\t}\n","new_comment_raw":"Poll for files, add an error channel, split into lines route the start\/end markers to  #markers() and the lines to  #lines().","old_comment_raw":"Poll for files, add an error channel, split into lines route the start\/end markers to #markers() and the lines to #lines().","label":0,"pre_label":1,"AST_level":10,"line_counts":13,"new_code_token_num":106},{"new_code_raw":"public InetAddress getNumericalAddress() { return address; }","old_code_raw":"\tpublic long getNumericalAddress() {\r\n\t\treturn address;\r\n\t}\r\n","new_comment_raw":"Returns the address of the sender","old_comment_raw":"Returns the address of the sender as a long.","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":10},{"new_code_raw":"public static Iterable<Runnable> thread(final String title, Iterable<Runnable> runnables){ \/\/--Preparation \/\/(variables) final AtomicBoolean haveStarted = new AtomicBoolean(false); final ReentrantLock metaInfoLock = new ReentrantLock(); final AtomicInteger numPending = new AtomicInteger(0); final Iterator<Runnable> iter = runnables.iterator(); \/\/--Create Runnables return new IterableIterator<>(new Iterator<Runnable>() { @Override public boolean hasNext() { synchronized (iter) { return iter.hasNext(); } } @Override public synchronized Runnable next() { final Runnable runnable; synchronized (iter) { runnable = iter.next(); } \/\/ (don't flood the queu) while (numPending.get() > 100) { try { Thread.sleep(100); } catch (InterruptedException e) { } } numPending.incrementAndGet(); \/\/ (add the job) Runnable toReturn = new Runnable(){ public void run(){ boolean threadFinished = false; try{ \/\/(signal start of threads) metaInfoLock.lock(); if(!haveStarted.getAndSet(true)){ startThreads(title); \/\/<--this must be a blocking operation } metaInfoLock.unlock(); \/\/(run runnable) try{ runnable.run(); } catch (Exception e){ e.printStackTrace(); System.exit(1); } catch (AssertionError e) { e.printStackTrace(); System.exit(1); } \/\/(signal end of thread) finishThread(); threadFinished = true; \/\/(signal end of threads) int numStillPending = numPending.decrementAndGet(); synchronized (iter) { if (numStillPending <= 0 && !iter.hasNext()) { endThreads(title); } } } catch(Throwable t){ t.printStackTrace(); if (!threadFinished) { finishThread(); } } } }; return toReturn; } @Override public void remove() { synchronized (iter) { iter.remove(); } } }); }","old_code_raw":"    public static Iterable<Runnable> thread(final String title, Iterable<Runnable> runnables){\n      \/\/--Preparation\n      \/\/(variables)\n      final AtomicBoolean haveStarted = new AtomicBoolean(false);\n      final ReentrantLock metaInfoLock = new ReentrantLock();\n      final AtomicInteger numPending = new AtomicInteger(0);\n      final Iterator<Runnable> iter = runnables.iterator();\n      \/\/--Create Runnables\n      return new IterableIterator<>(new Iterator<Runnable>() {\n        @Override\n        public boolean hasNext() {\n          return iter.hasNext();\n        }\n        @Override\n        public synchronized Runnable next() {\n          final Runnable runnable = iter.next();\n          \/\/ (don't flood the queu)\n          while (numPending.get() > 100) {\n            try { Thread.sleep(100); }\n            catch (InterruptedException e) { }\n          }\n          numPending.incrementAndGet();\n          \/\/ (add the job)\n          Runnable toReturn = new Runnable(){\n            public void run(){\n              boolean threadFinished = false;\n              try{\n                \/\/(signal start of threads)\n                metaInfoLock.lock();\n                if(!haveStarted.getAndSet(true)){\n                  startThreads(title); \/\/<--this must be a blocking operation\n                }\n                metaInfoLock.unlock();\n                \/\/(run runnable)\n                try{\n                  runnable.run();\n                } catch (Exception e){\n                  e.printStackTrace();\n                  System.exit(1);\n                } catch (AssertionError e) {\n                  e.printStackTrace();\n                  System.exit(1);\n                }\n                \/\/(signal end of thread)\n                finishThread();\n                threadFinished = true;\n                \/\/(signal end of threads)\n                int numStillPending = numPending.decrementAndGet();\n                if(numStillPending <= 0 && !iter.hasNext()){\n                  endThreads(title);\n                }\n              } catch(Throwable t){\n                t.printStackTrace();\n                if (!threadFinished) { finishThread(); }\n              }\n            }\n          };\n          return toReturn;\n        }\n\n        @Override\n        public void remove() {\n          iter.remove();\n        }\n      });\n    }\n","new_comment_raw":"Wrap a collection of threads (Runnables) to be logged by Redwood.","old_comment_raw":"Wrap a collection of threads (Runnables) to be logged by Redwood.","label":0,"pre_label":1,"AST_level":17,"line_counts":76,"new_code_token_num":393},{"new_code_raw":"static Folder fromXml(Context context) { return (Folder) LayoutInflater.from(context).inflate(R.layout.user_folder, null); }","old_code_raw":"    static Folder fromXml(Launcher launcher) {\n        return (Folder) launcher.getLayoutInflater().inflate(R.layout.user_folder, null);\n    }\n","new_comment_raw":"Creates a new UserFolder, inflated from R.layout.user_folder.","old_comment_raw":"Creates a new UserFolder, inflated from R.layout.user_folder.","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":27},{"new_code_raw":"public static Folder resolveFolder(Folder dir, String relativePath) { final String[] fragments = StringUtils.split(relativePath, '\/'); if (ArrayUtils.isEmpty(fragments)) { return dir; } return resolveFolder(dir, Arrays.stream(fragments).iterator()); }","old_code_raw":"\tpublic static Folder resolveFolder(Folder dir, String relativePath) {\n\t\tfinal String[] fragments = StringUtils.split(relativePath, '\/');\n\t\tif (ArrayUtils.isEmpty(fragments)) {\n\t\t\tthrow new IllegalArgumentException(\"Empty relativePath\");\n\t\t}\n\t\treturn resolveFolder(dir, Arrays.stream(fragments).iterator());\n\t}\n","new_comment_raw":"Resolves a relative path (separated by '\/') to a folder, e.g.","old_comment_raw":"Resolves a relative path (separated by '\/') to a folder, e.g.","label":0,"pre_label":1,"AST_level":6,"line_counts":8,"new_code_token_num":56},{"new_code_raw":"public final int getBeginLine() { return this.bufline[this.tokenBegin]; }","old_code_raw":"    public final int getBeginLine() {\n        return bufline[tokenBegin];\n    }\n","new_comment_raw":"Get the line begin","old_comment_raw":"DOCUMENT ME!","label":1,"pre_label":0,"AST_level":7,"line_counts":5,"new_code_token_num":16},{"new_code_raw":"public ApiResponse<Void> deleteOrderWithHttpInfo(String orderId) throws ApiException { okhttp3.Call localVarCall = deleteOrderValidateBeforeCall(orderId, null, null); return localVarApiClient.execute(localVarCall); }","old_code_raw":"    public ApiResponse<Void> deleteOrderWithHttpInfo(String orderId) throws ApiException {\n        okhttp3.Call call = deleteOrderValidateBeforeCall(orderId, null, null);\n        return apiClient.execute(call);\n    }\n","new_comment_raw":"Delete purchase order by ID","old_comment_raw":"Delete purchase order by ID","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":31},{"new_code_raw":"public TimeOfDay setCopy(String text) { return setCopy(text, null); }","old_code_raw":"        public TimeOfDay setCopy(int value) {\n            int[] newValues = getField().set(iInstant, iFieldIndex, value);\n            return new TimeOfDay(iInstant, newValues);\n        }\n","new_comment_raw":"Sets this field in a copy of the TimeOfDay to a parsed text value.","old_comment_raw":"Sets this field in a copy of the TimeOfDay.","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":17},{"new_code_raw":"public static AnnotationMirror getAnnotationMirror(Element element, Class<? extends Annotation> clazz) { assert clazz != null; return getAnnotationMirror( element, clazz.getName() ); }","old_code_raw":"\tpublic static AnnotationMirror getAnnotationMirror(Element element, Class<? extends Annotation> clazz) {\n\t\tassert element != null;\n\t\tassert clazz != null;\n\n\t\tAnnotationMirror mirror = null;\n\t\tfor ( AnnotationMirror am : element.getAnnotationMirrors() ) {\n\t\t\tif ( isAnnotationMirrorOfType( am, clazz ) ) {\n\t\t\t\tmirror = am;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn mirror;\n\t}\n","new_comment_raw":"Checks whether the  Element hosts an annotation of the specified class.","old_comment_raw":"Returns the annotation mirror for the specified annotation class from the Element.","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":32},{"new_code_raw":"public DateTimeField year() { return UnsupportedDateTimeField.getInstance(DateTimeFieldType.year(), years()); }","old_code_raw":"    public DateTimeField year() {\n        return UnsupportedDateTimeField.getInstance(\"year\", years());\n    }\n","new_comment_raw":"Get the year field for this chronology.","old_comment_raw":"Get the year field for this chronology.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":21},{"new_code_raw":"public Element getElementByPath(String path) { \/* * Path is of type \"targetWidgetPath#componentPart\" or * \"targetWidgetPath\". *\/ String parts[] = path.split(SUBPART_SEPARATOR, 2); String widgetPath = parts[0]; Widget w = getWidgetFromPath(widgetPath); if (w == null) { return null; } if (parts.length == 1) { int pos = widgetPath.indexOf(\"domChild\"); if (pos == -1) { return w.getElement(); } \/\/ Contains dom reference to a sub element of the widget String subPath = widgetPath.substring(pos); return getElementByDOMPath(w.getElement(), subPath); } else if (parts.length == 2) { if (w instanceof SubPartAware) { return ((SubPartAware) w).getSubPartElement(parts[1]); } } return null; }","old_code_raw":"    public Element getElementByPath(String path) {\n        \/\/ ApplicationConnection.getConsole()\n        \/\/ .log(\"getElementByPath(\" + path + \")\");\n\n        \/\/ Path is of type \"PID\/componentPart\"\n        String parts[] = path.split(SUBPART_SEPARATOR, 2);\n        String widgetPath = parts[0];\n        Widget w = getWidgetFromPath(widgetPath);\n        if (w == null) {\n            return null;\n        }\n\n        if (parts.length == 1) {\n            int pos = widgetPath.indexOf(\"domChild\");\n            if (pos == -1) {\n                return w.getElement();\n            }\n\n            \/\/ Contains dom reference to a sub element of the widget\n            String subPath = widgetPath.substring(pos);\n            return getElementByDOMPath(w.getElement(), subPath);\n        } else if (parts.length == 2) {\n            if (w instanceof SubPartAware) {\n                \/\/ ApplicationConnection.getConsole().log(\n                \/\/ \"subPartAware: \" + parts[1]);\n                return ((SubPartAware) w).getSubPartElement(parts[1]);\n            } else {\n                \/\/ ApplicationConnection.getConsole().error(\n                \/\/ \"getElementByPath failed because \"\n                \/\/ + Util.getSimpleName(w)\n                \/\/ + \" is not SubPartAware\");\n                return null;\n            }\n        }\n\n        return null;\n    }\n","new_comment_raw":"Locates an element using a String locator (path) which identifies a DOM element.","old_comment_raw":"EXPERIMENTAL.","label":1,"pre_label":0,"AST_level":10,"line_counts":31,"new_code_token_num":162},{"new_code_raw":"private boolean searchForButton(String regex, int matches) { sleeper.sleep(); inst.waitForIdleSync(); Pattern p = Pattern.compile(regex); Matcher matcher; ArrayList<Button> buttonList = viewFetcher.getCurrentViews(Button.class); if(matches == 0) matches = 1; for(Button button : buttonList){ matcher = p.matcher(button.getText().toString()); if(matcher.find()){ countMatches++; } if (countMatches == matches) { countMatches = 0; return true; } } if (scroller.scroll(Scroller.Direction.DOWN)) { return searchForButton(regex, matches); } else { if (countMatches > 0) Log.d(LOG_TAG, \" There are only \" + countMatches + \" matches of \" + regex); countMatches = 0; return false; } }","old_code_raw":"\tprivate boolean searchForButton(String search, int matches) {\n\t\tsleeper.sleep();\n\t\tinst.waitForIdleSync();\n\t\tPattern p = Pattern.compile(search);\n\t\tMatcher matcher;\n\t\tArrayList<Button> buttonList = viewFetcher.getCurrentViews(Button.class);\n\t\tif(matches == 0)\n\t\t\tmatches = 1;\n\t\tfor(Button button : buttonList){\n\t\t\tmatcher = p.matcher(button.getText().toString());\n\t\t\tif(matcher.find()){\t\n\t\t\t\tcountMatches++;\n\t\t\t}\n\t\t\tif (countMatches == matches) {\n\t\t\t\tcountMatches = 0;\n\t\t\t\treturn true;\n\t\t\t} \t\n\t\t}\n\n\t\tif (scroller.scroll(Scroller.Direction.DOWN))\n\t\t{\n\t\t\treturn searchForButton(search, matches);\n\t\t} else {\n\t\t\tif (countMatches > 0)\n\t\t\t\tLog.d(LOG_TAG, \" There are only \" + countMatches + \" matches of \" + search);\n\t\t\tcountMatches = 0;\n\t\t\treturn false;\n\t\t}\n\n\t}\n","new_comment_raw":"Searches for a button with the given regex string and returns true if the searched button is found a given number of times","old_comment_raw":"Searches for a button with the given search string and returns true if the searched button is found a given number of times","label":1,"pre_label":0,"AST_level":11,"line_counts":31,"new_code_token_num":154},{"new_code_raw":"public Action doCometSupport(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException { req.setAttribute(BROADCASTER_FACTORY, broadcasterFactory); req.setAttribute(PROPERTY_USE_STREAM, useStreamForFlushingComments); req.setAttribute(BROADCASTER_CLASS, broadcasterClassName); req.setAttribute(ATMOSPHERE_CONFIG, config); AtmosphereRequest r = null; Action a = null; try { if (config.getInitParameter(ALLOW_QUERYSTRING_AS_REQUEST) != null && (isIECandidate(req) || req.getParameter(HeaderConfig.JSONP_CALLBACK_NAME) != null) && req.getAttribute(WebSocket.WEBSOCKET_SUSPEND) == null) { Map<String, String> headers = configureQueryStringAsRequest(req); String body = headers.remove(ATMOSPHERE_POST_BODY); if (body != null && body.isEmpty()) { body = null; } r = new AtmosphereRequest.Builder() .headers(headers) .method(body != null && req.getMethod().equalsIgnoreCase(\"GET\") ? \"POST\" : req.getMethod()) .body(body) .request(req).build(); a = cometSupport.service(r, res); } else { if (AtmosphereRequest.class.isAssignableFrom(req.getClass())) { return cometSupport.service(req, res); } else { return cometSupport.service(AtmosphereRequest.wrap(req), res); } } } catch (IllegalStateException ex) { if (ex.getMessage() != null && ex.getMessage().startsWith(\"Tomcat failed\")) { if (!isFilter) { logger.warn(\"Failed using comet support: {}, error: {} Is the Nio or Apr Connector enabled?\", cometSupport.getClass().getName(), ex.getMessage()); logger.warn(\"Using BlockingIOCometSupport.\"); } logger.trace(ex.getMessage(), ex); cometSupport = new BlockingIOCometSupport(config); doCometSupport(req, res); } else { logger.error(\"AtmosphereServlet exception\", ex); throw ex; } } finally { if (r != null && a != null && a.type != Action.TYPE.SUSPEND) { r.destroy(); } } return null; }","old_code_raw":"    public Action doCometSupport(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException {\n        req.setAttribute(BROADCASTER_FACTORY, broadcasterFactory);\n        req.setAttribute(PROPERTY_USE_STREAM, useStreamForFlushingComments);\n        req.setAttribute(BROADCASTER_CLASS, broadcasterClassName);\n        req.setAttribute(ATMOSPHERE_CONFIG, config);\n\n        AtmosphereRequest r = null;\n        Action a = null;\n        try {\n            if (config.getInitParameter(ALLOW_QUERYSTRING_AS_REQUEST) != null\n                    && (isIECandidate(req) || req.getParameter(HeaderConfig.JSONP_CALLBACK_NAME) != null)\n                    && req.getAttribute(WebSocket.WEBSOCKET_SUSPEND) == null) {\n\n                Map<String, String> headers = configureQueryStringAsRequest(req);\n                String body = headers.remove(ATMOSPHERE_POST_BODY);\n                if (body != null && body.isEmpty()) {\n                    body = null;\n                }\n\n                r = new AtmosphereRequest.Builder()\n                        .headers(headers)\n                        .method(body != null && req.getMethod().equalsIgnoreCase(\"GET\") ? \"POST\" : req.getMethod())\n                        .body(body)\n                        .request(req).build();\n\n                a = cometSupport.service(r, res);\n            } else {\n                return cometSupport.service(AtmosphereRequest.wrap(req), res);\n            }\n        } catch (IllegalStateException ex) {\n            if (ex.getMessage() != null && ex.getMessage().startsWith(\"Tomcat failed\")) {\n                if (!isFilter) {\n                    logger.warn(\"Failed using comet support: {}, error: {} Is the Nio or Apr Connector enabled?\", cometSupport.getClass().getName(),\n                            ex.getMessage());\n                    logger.warn(\"Using BlockingIOCometSupport.\");\n                }\n                logger.trace(ex.getMessage(), ex);\n\n                cometSupport = new BlockingIOCometSupport(config);\n                doCometSupport(req, res);\n            } else {\n                logger.error(\"AtmosphereServlet exception\", ex);\n                throw ex;\n            }\n        } finally {\n            if (r != null && a != null && a.type != Action.TYPE.SUSPEND) {\n                r.destroy();\n            }\n        }\n        return null;\n    }\n","new_comment_raw":"Invoke the proprietary  CometSupport","old_comment_raw":"Invoke the proprietary CometSupport","label":0,"pre_label":1,"AST_level":14,"line_counts":56,"new_code_token_num":394},{"new_code_raw":"public File getOpenEJBTomcatLoaderJar() { return findOpenEJBJar(\"tomee-loader\"); }","old_code_raw":"    public File getOpenEJBTomcatLoaderJar() {\n        return findOpenEJBJar(\"openejb-tomcat-loader\");\n    }\n","new_comment_raw":"Returns the tomee-loader.jar file","old_comment_raw":"Returns the openejb-tomcat-loader.jar file","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":17},{"new_code_raw":"public int headOfSpan(Span tokenSpan) { \/\/ Error checks if (tokenSpan.size() == 0) { throw new IllegalArgumentException(\"Cannot find head word of empty span!\"); } \/\/ Find where to start searching up the dependency tree int candidateStart = tokenSpan.end() - 1; Optional<Integer> parent; while ( !(parent = sentence.governor(candidateStart)).isPresent() ) { candidateStart -= 1; if (candidateStart < tokenSpan.start()) { \/\/ Case: nothing in this span has a head. Default to right-most element. return tokenSpan.end() - 1; } } int candidate = candidateStart; \/\/ Search up the dependency tree while (parent.isPresent() && parent.get() >= tokenSpan.start() && parent.get() < tokenSpan.end()) { candidate = parent.get(); parent = sentence.governor(candidate); } \/\/ Return return candidate; }","old_code_raw":"  public int headOfSpan(Span tokenSpan) {\n    \/\/ Error checks\n    if (tokenSpan.size() == 0) {\n      throw new IllegalArgumentException(\"Cannot find head word of empty span!\");\n    }\n    List<Optional<Integer>> governors = sentence.governors();\n    if (tokenSpan.start() >= governors.size()) {\n      throw new IllegalArgumentException(\"Span is out of range: \" + tokenSpan + \"; sentence: \" + sentence);\n    }\n    if (tokenSpan.end() > governors.size()) {\n      throw new IllegalArgumentException(\"Span is out of range: \" + tokenSpan + \"; sentence: \" + sentence);\n    }\n\n    \/\/ Find where to start searching up the dependency tree\n    int candidateStart = tokenSpan.end() - 1;\n    Optional<Integer> parent;\n    while ( !(parent = governors.get(candidateStart)).isPresent() ) {\n      candidateStart -= 1;\n      if (candidateStart < tokenSpan.start()) {\n        \/\/ Case: nothing in this span has a head. Default to right-most element.\n        return tokenSpan.end() - 1;\n      }\n    }\n    int candidate = candidateStart;\n\n    \/\/ Search up the dependency tree\n    Set<Integer> seen = new HashSet<>();\n    while (parent.isPresent() && parent.get() >= tokenSpan.start() && parent.get() < tokenSpan.end()) {\n      candidate = parent.get();\n      if (seen.contains(candidate)) {\n        return candidate;\n      }\n      seen.add(candidate);\n      parent = governors.get(candidate);\n    }\n\n    \/\/ Return\n    return candidate;\n  }\n","new_comment_raw":"Get the index of the head word for a given span, based off of the dependency parse.","old_comment_raw":"Get the index of the head word for a given span, based off of the dependency parse.","label":0,"pre_label":1,"AST_level":9,"line_counts":28,"new_code_token_num":178},{"new_code_raw":"@Processor @OAuthProtected @OAuthInvalidateAccessTokenOn(exception=OAuthTokenExpiredException.class) @Paged public PagingDelegate<CalendarList> getCalendarList( final @Optional @Default(\"false\") boolean showHidden, final PagingConfiguration pagingConfiguration) throws IOException { return new TokenBasedPagingDelegate<CalendarList>() { @Override public List<CalendarList> doGetPage() throws IOException { com.google.api.services.calendar.Calendar.CalendarList.List calendars = client.calendarList().list(); com.google.api.services.calendar.model.CalendarList list = calendars.setMaxResults(pagingConfiguration.getFetchSize()) .setPageToken(this.getPageToken()) .setShowHidden(showHidden) .execute(); setPageToken(list.getNextPageToken()); return CalendarList.valueOf(list.getItems(), CalendarList.class); } }; }","old_code_raw":"    @Processor\n    @Inject\n    @OAuthProtected\n\t@OAuthInvalidateAccessTokenOn(exception=OAuthTokenExpiredException.class)\n    public List<CalendarList> getCalendarList(\n    \t\tMuleMessage message,\n    \t\t@Optional @Default(\"100\") int maxResults,\n    \t\t@Optional String pageToken,\n    \t\t@Optional @Default(\"false\") boolean showHidden) throws IOException {\n\n    \tcom.google.api.services.calendar.Calendar.CalendarList.List calendars = this.client.calendarList().list();\n    \tcom.google.api.services.calendar.model.CalendarList list = calendars.setMaxResults(maxResults)\n    \t\t.setPageToken(pageToken)\n    \t\t.setShowHidden(showHidden)\n    \t\t.execute();\n    \t\n    \tthis.saveNextPageToken(list, message);\n    \treturn CalendarList.valueOf(list.getItems(), CalendarList.class);\n    }\n","new_comment_raw":"Returns a paginated iterator with instances of  org.mule.module.google.calendar.model.CalendarList listing the calendars of the user that owns the OAuth access token.","old_comment_raw":"Returns an instance of org.mule.module.google.calendar.model.CalendarList listing the calendars of the user that owns the OAuth access token.","label":1,"pre_label":0,"AST_level":14,"line_counts":25,"new_code_token_num":129},{"new_code_raw":"public Mono<Order> getOrderById(Long orderId) throws RestClientException { Object postBody = null; \/\/ verify the required parameter 'orderId' is set if (orderId == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'orderId' when calling getOrderById\"); } \/\/ create path and map variables final Map<String, Object> uriVariables = new HashMap<String, Object>(); uriVariables.put(\"order_id\", orderId); String path = UriComponentsBuilder.fromPath(\"\/store\/order\/{order_id}\").buildAndExpand(uriVariables).toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { \"application\/xml\", \"application\/json\" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<Order> returnType = new ParameterizedTypeReference<Order>() {}; return apiClient.invokeAPI(path, HttpMethod.GET, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType); }","old_code_raw":"    public Mono<Order> getOrderById(Long orderId) throws RestClientException {\n        Object postBody = null;\n        \n        \/\/ verify the required parameter 'orderId' is set\n        if (orderId == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'orderId' when calling getOrderById\");\n        }\n        \n        \/\/ create path and map variables\n        final Map<String, Object> uriVariables = new HashMap<String, Object>();\n        uriVariables.put(\"order_id\", orderId);\n        String path = UriComponentsBuilder.fromPath(\"\/store\/order\/{order_id}\").buildAndExpand(uriVariables).toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application\/xml\", \"application\/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<Order> returnType = new ParameterizedTypeReference<Order>() {};\n        return apiClient.invokeAPI(path, HttpMethod.GET, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n","new_comment_raw":"Find purchase order by ID","old_comment_raw":"Find purchase order by ID","label":0,"pre_label":1,"AST_level":8,"line_counts":31,"new_code_token_num":256},{"new_code_raw":"public static int killProcess(Process process) { if (thisIsWindows()) { return killWinProcess(process); } else { return killUnixProcess(process); } }","old_code_raw":"  public static int killProcess(Process process) {\n    int exitValue;\n\n    \/\/ first, wait a second to see if the process will die on it's own (we will likely have asked\n    \/\/ the process to kill itself just before calling this method\n    try {\n      exitValue = waitForProcessDeath(process, 1000);\n      closeAllStreamsAndDestroyProcess( process);\n      if (exitValue == 0) {\n        return exitValue;\n      }\n    } catch (Exception e) {\n      \/\/ no? ok, no biggie, now let's force kill it...\n    }\n\n    process.destroy();\n    try {\n      exitValue = waitForProcessDeath(process, 10000);\n      closeAllStreamsAndDestroyProcess( process);\n    } catch (ProcessStillAliveException ex) {\n      if (Platform.getCurrent().is(Platform.WINDOWS)) {\n        throw ex;\n      }\n      try {\n        log.info(\"Process didn't die after 10 seconds\");\n        kill9(process);\n        exitValue = waitForProcessDeath(process, 10000);\n        closeAllStreamsAndDestroyProcess( process);\n      } catch (Exception e) {\n        log.warning(\"Process refused to die after 10 seconds, and couldn't kill9 it\");\n        e.printStackTrace();\n        throw new RuntimeException(\n            \"Process refused to die after 10 seconds, and couldn't kill9 it: \" + e.getMessage(),\n            ex);\n      }\n    }\n    return exitValue;\n  }\n","new_comment_raw":"Forcibly kills a process, using OS tools like \"kill\" as a last resort","old_comment_raw":"Forcibly kills a process, using OS tools like \"kill\" as a last resort","label":0,"pre_label":1,"AST_level":7,"line_counts":8,"new_code_token_num":33},{"new_code_raw":"synchronized public Value put(Transaction tx, Key key, Value value) throws IOException { Value oldValue = null; if (lastGetNodeCache != null) { if(lastGetEntryCache.getKey().equals(key)) { oldValue = lastGetEntryCache.setValue(value); lastGetEntryCache.setValue(value); lastGetNodeCache.storeUpdate(tx); return oldValue; } \/\/ This searches from the last location of a call to get for the element to replace \/\/ all the way to the end of the ListIndex. Iterator<Map.Entry<Key, Value>> iterator = lastGetNodeCache.iterator(tx); while (iterator.hasNext()) { Map.Entry<Key, Value> entry = iterator.next(); if (entry.getKey().equals(key)) { oldValue = entry.setValue(value); ((ListIterator) iterator).getCurrent().storeUpdate(tx); return oldValue; } } } \/\/ Not found because the cache wasn't set or its not at the end of the list so we \/\/ start from the beginning and go to the cached location or the end, then we do \/\/ an add if its not found. Iterator<Map.Entry<Key, Value>> iterator = iterator(tx); while (iterator.hasNext() && ((ListIterator) iterator).getCurrent() != lastGetNodeCache) { Map.Entry<Key, Value> entry = iterator.next(); if (entry.getKey().equals(key)) { oldValue = entry.setValue(value); ((ListIterator) iterator).getCurrent().storeUpdate(tx); return oldValue; } } \/\/ Not found so add it last. return add(tx, key, value); }","old_code_raw":"    synchronized public Value put(Transaction tx, Key key, Value value) throws IOException {\n        return add(tx, key, value);\n    }\n","new_comment_raw":"Update the value of the item with the given key in the list if ot exists, otherwise it appends the value to the end of the list.","old_comment_raw":"appends to the list","label":1,"pre_label":0,"AST_level":12,"line_counts":43,"new_code_token_num":313},{"new_code_raw":"public ProcessingColorProvider getProcessingColorProvider() { return (fColorProvider == null) ? new ProcessingColorProvider() : fColorProvider; }","old_code_raw":"\t public ProcessingColorProvider getProcessingColorProvider() {\n\t \tif (fColorProvider == null)\n\t\t\tfColorProvider= new ProcessingColorProvider();\n\t\treturn fColorProvider;\n\t}\n","new_comment_raw":"Returns the shared color provider.","old_comment_raw":"Returns the shared color provider.","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"public boolean waitForText(String text, int minimumNumberOfMatches, long timeout, boolean scroll) { TextView textView = waiter.waitForText(text, minimumNumberOfMatches, timeout, scroll); return textView != null; }","old_code_raw":"\tpublic boolean waitForText(String text, int minimumNumberOfMatches, long timeout, boolean scroll) {\n\t\treturn waiter.waitForText(text, minimumNumberOfMatches, timeout, scroll);\n    }\n","new_comment_raw":"Waits for a text to be shown.","old_comment_raw":"Waits for a text to be shown.","label":0,"pre_label":1,"AST_level":6,"line_counts":6,"new_code_token_num":37},{"new_code_raw":"public boolean isRcsAssociated(final String phoneNumber) { boolean result = false; Cursor cur = ctx.getContentResolver().query(RichAddressBookData.CONTENT_URI, new String[]{RichAddressBookData.KEY_CONTACT_NUMBER}, RichAddressBookData.KEY_CONTACT_NUMBER + \"=?\", new String[]{phoneNumber}, null); if (cur!=null){ if (cur.moveToFirst()) { result = true; } cur.close(); }else{ result = false; } return result; }","old_code_raw":"    public boolean isRcsAssociated(final String phoneNumber) {\n    \treturn !getRcsRawContactIdFromPhoneNumber(phoneNumber).isEmpty();\n    }\n","new_comment_raw":"Utility to check if a phone number is associated to an entry in the rich address book provider","old_comment_raw":"Utility to check if a phone number is associated to a RCS account","label":1,"pre_label":0,"AST_level":9,"line_counts":19,"new_code_token_num":86},{"new_code_raw":"private ZapTextField getTxtPattern() { if (txtPattern == null) { txtPattern = new ZapTextField(); } return txtPattern; }","old_code_raw":"\tprivate JTextField getTxtPattern() {\n\t\tif (txtPattern == null) {\n\t\t\ttxtPattern = new JTextField();\n\t\t}\n\t\treturn txtPattern;\n\t}\n","new_comment_raw":"This method initializes txtPattern","old_comment_raw":"This method initializes txtPattern","label":0,"pre_label":1,"AST_level":8,"line_counts":7,"new_code_token_num":23},{"new_code_raw":"public String executeAs(Function<Response, Response> handler) { Type type = new TypeToken<String>(){}.getType(); return execute(handler).as(type); }","old_code_raw":"        public String executeAs(Function<Response, Response> handler) {\n            Type type = new TypeToken<String>(){}.getType();\n            return getJSON().deserialize(execute(handler).asString(), type);\n        }\n","new_comment_raw":"POST \/fake\/outer\/string","old_comment_raw":"POST \/fake\/outer\/string","label":0,"pre_label":1,"AST_level":8,"line_counts":5,"new_code_token_num":35},{"new_code_raw":"public QName getPortTypeName() { return portTypeName == null ? new QName(\"\") : portTypeName; }","old_code_raw":"    public QName getPortTypeName() {\n        return portName == null ? new QName(\"\") : portName;\n    }\n","new_comment_raw":"Returns the fully qualified name of the port type for this Call object (if there is one).","old_comment_raw":"Returns the fully qualified name of the port for this Call object (if there is one).","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":20},{"new_code_raw":"@Processor @OAuthProtected @OAuthInvalidateAccessTokenOn(exception=OAuthTokenExpiredException.class) @Paged public PagingDelegate<CommentReply> listCommentReplies( final String fileId, final String commentId, final @Optional @Default(\"false\") boolean includeDeleted, final @Optional @Default(\"100\") int maxResults, final PagingConfiguration pagingConfiguration ) throws IOException { return new TokenBasedPagingDelegate<CommentReply>() { @Override protected List<CommentReply> doGetPage() throws IOException { CommentReplyList response = client.replies().list(fileId, commentId) .setIncludeDeleted(includeDeleted) .setMaxResults(maxResults) .setPageToken(this.getPageToken()) .execute(); this.setPageToken(response.getNextPageToken()); return CommentReply.valueOf(response.getItems(), CommentReply.class); } }; }","old_code_raw":"\t@Processor\n    @OAuthProtected\n\t@OAuthInvalidateAccessTokenOn(exception=OAuthTokenExpiredException.class)\n\t@Inject\n\tpublic List<CommentReply> listCommentReplies(\n\t\t\tMuleMessage message,\n\t\t\tString fileId,\n\t\t\tString commentId, \n\t\t\t@Optional @Default(\"false\") boolean includeDeleted,\n\t\t\t@Optional @Default(\"100\") int maxResults,\n\t\t\t@Optional @Default(\"#[flowVars['GoogleDrive_NEXT_PAGE_TOKEN']]\") String pageToken\n\t\t\t) throws IOException {\n\t\t\n\t\tCommentReplyList response = this.client.replies().list(fileId, commentId)\n\t\t\t\t\t\t\t\t\t\t.setIncludeDeleted(includeDeleted)\n\t\t\t\t\t\t\t\t\t\t.setMaxResults(maxResults)\n\t\t\t\t\t\t\t\t\t\t.setPageToken(pageToken)\n\t\t\t\t\t\t\t\t\t\t.execute();\n\t\t\n\n\t\tPaginationUtils.savePageToken(NEXT_PAGE_TOKEN, response.getNextPageToken(), message);\n\t\treturn CommentReply.valueOf(response.getItems(), CommentReply.class);\n\t}\n","new_comment_raw":"Returns a paginated  Iterator with all the  org.mule.module.google.drive.model.CommentReply for a given comment @sample.xml ..\/..\/..\/doc\/GoogleDriveConnector.xml.sample google-drive:list-comment-replies","old_comment_raw":"Lists all replies for a given comment @sample.xml ..\/..\/..\/doc\/GoogleDriveConnector.xml.sample google-drive:list-comment-replies","label":1,"pre_label":0,"AST_level":11,"line_counts":29,"new_code_token_num":134},{"new_code_raw":"public JobInstance cancel(@PathVariable String jobId) { try { final JobInstance jobInstance = jobService.getJobInstance(jobId); jobService.cancelJob(jobInstance); return jobService.getJobInstance(jobId); } catch (Exception e) { logger.error(e.getLocalizedMessage(), e); throw new InternalErrorException(e); } }","old_code_raw":"    public JobInstance cancel(@PathVariable String jobId) {\n\n        try {\n            final JobInstance jobInstance = jobService.getJobInstance(jobId);\n            return jobService.cancelJob(jobInstance);\n        } catch (Exception e) {\n            logger.error(e.getLocalizedMessage(), e);\n            throw new InternalErrorException(e);\n        }\n    }\n","new_comment_raw":"Cancel\/discard a job","old_comment_raw":"Cancel\/discard a job","label":0,"pre_label":1,"AST_level":7,"line_counts":12,"new_code_token_num":61},{"new_code_raw":"public Object getValue(String columnName, PostgresType type, String fullType, Value rawValue, final PgConnectionSupplier connection, boolean includeUnknownDatatypes) { if (rawValue.isNull()) { \/\/ nulls are null return null; } if (type.isArrayType()) { try { final String dataString = rawValue.asString(); PgArray arrayData = new PgArray(connection.get(), type.getOid(), dataString); Object deserializedArray = arrayData.getArray(); return Arrays.asList((Object[])deserializedArray); } catch (SQLException e) { LOGGER.warn(\"Unexpected exception trying to process PgArray ({}) column '{}', {}\", fullType, columnName, e); } return null; } switch (type.getName()) { \/\/ include all types from https:\/\/www.postgresql.org\/docs\/current\/static\/datatype.html#DATATYPE-TABLE \/\/ plus aliases from the shorter names produced by older wal2json case \"boolean\": case \"bool\": return rawValue.asBoolean(); case \"integer\": case \"int\": case \"int4\": case \"smallint\": case \"int2\": case \"smallserial\": case \"serial\": case \"serial2\": case \"serial4\": case \"oid\": return rawValue.asInteger(); case \"bigint\": case \"bigserial\": case \"int8\": return rawValue.asLong(); case \"real\": case \"float4\": return rawValue.isNumber() ? rawValue.asFloat() : Float.valueOf(rawValue.asString()); case \"double precision\": case \"float8\": return rawValue.isNumber() ? rawValue.asDouble() : Double.valueOf(rawValue.asString()); case \"numeric\": case \"decimal\": if (rawValue.isInteger()) { return new SpecialValueDecimal(new BigDecimal(rawValue.asInteger())); } else if (rawValue.isLong()) { return new SpecialValueDecimal(new BigDecimal(rawValue.asLong())); } else if (rawValue.isBigInteger()) { return new SpecialValueDecimal(new BigDecimal(rawValue.asBigInteger())); } return SpecialValueDecimal.valueOf(rawValue.asString()); case \"character\": case \"char\": case \"character varying\": case \"varchar\": case \"bpchar\": case \"text\": return rawValue.asString(); case \"date\": return DateTimeFormat.get().date(rawValue.asString()); case \"timestamp with time zone\": case \"timestamptz\": return DateTimeFormat.get().timestampWithTimeZone(rawValue.asString()); case \"timestamp\": case \"timestamp without time zone\": final LocalDateTime serverLocal = Conversions.fromNanosToLocalDateTimeUTC(DateTimeFormat.get().timestamp(rawValue.asString())); final Instant utc = serverLocal.atOffset(serverTimezone).toInstant(); return Conversions.toEpochNanos(utc); case \"time\": case \"time without time zone\": return DateTimeFormat.get().time(rawValue.asString()); case \"time with time zone\": case \"timetz\": return DateTimeFormat.get().timeWithTimeZone(rawValue.asString()); case \"bytea\": return Strings.hexStringToByteArray(rawValue.asString()); \/\/ these are all PG-specific types and we use the JDBC representations \/\/ note that, with the exception of point, no converters for these types are implemented yet, \/\/ i.e. those values won't actually be propagated to the outbound message until that's the case case \"box\": try { return new PGbox(rawValue.asString()); } catch (final SQLException e) { LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e); throw new ConnectException(e); } case \"circle\": try { return new PGcircle(rawValue.asString()); } catch (final SQLException e) { LOGGER.error(\"Failed to parse circle {}, {}\", rawValue.asString(), e); throw new ConnectException(e); } case \"interval\": try { return new PGInterval(rawValue.asString()); } catch (final SQLException e) { LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e); throw new ConnectException(e); } case \"line\": try { return new PGline(rawValue.asString()); } catch (final SQLException e) { LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e); throw new ConnectException(e); } case \"lseg\": try { return new PGlseg(rawValue.asString()); } catch (final SQLException e) { LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e); throw new ConnectException(e); } case \"money\": try { return new PGmoney(rawValue.asString()).val; } catch (final SQLException e) { LOGGER.error(\"Failed to parse money {}, {}\", rawValue.asString(), e); throw new ConnectException(e); } case \"path\": try { return new PGpath(rawValue.asString()); } catch (final SQLException e) { LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e); throw new ConnectException(e); } case \"point\": try { return new PGpoint(rawValue.asString()); } catch (final SQLException e) { LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e); throw new ConnectException(e); } case \"polygon\": try { return new PGpolygon(rawValue.asString()); } catch (final SQLException e) { LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e); throw new ConnectException(e); } \/\/ PostGIS types are HexEWKB strings \/\/ ValueConverter turns them into the correct types case \"geometry\": case \"geography\": return rawValue.asString(); case \"bit\": case \"bit varying\": case \"varbit\": case \"json\": case \"jsonb\": case \"xml\": case \"uuid\": case \"tstzrange\": return rawValue.asString(); \/\/ catch-all for other known\/builtin PG types \/\/ TODO: improve with more specific\/useful classes here? case \"cidr\": case \"inet\": case \"macaddr\": case \"macaddr8\": case \"pg_lsn\": case \"tsquery\": case \"tsvector\": case \"txid_snapshot\": \/\/ catch-all for unknown (extension module\/custom) types default: break; } if (includeUnknownDatatypes) { \/\/ this includes things like PostGIS geometries or other custom types. \/\/ leave up to the downstream message recipient to deal with. LOGGER.debug(\"processing column '{}' with unknown data type '{}' as byte array\", columnName, fullType); return rawValue.asString(); } LOGGER.debug(\"Unknown column type {} for column {} \u00e2\u0080\u0093\u00c2 ignoring\", fullType, columnName); return null; }","old_code_raw":"    public Object getValue(String columnName, PostgresType type, String fullType, Value rawValue, final PgConnectionSupplier connection, boolean includeUnknownDatatypes) {\n        if (rawValue.isNull()) {\n            \/\/ nulls are null\n            return null;\n        }\n\n        if (type.isArrayType()) {\n            try {\n                final String dataString = rawValue.asString();\n                PgArray arrayData = new PgArray(connection.get(), type.getOid(), dataString);\n                Object deserializedArray = arrayData.getArray();\n                return Arrays.asList((Object[])deserializedArray);\n            }\n            catch (SQLException e) {\n                LOGGER.warn(\"Unexpected exception trying to process PgArray ({}) column '{}', {}\", fullType, columnName, e);\n            }\n            return null;\n        }\n\n        switch (type.getName()) {\n            \/\/ include all types from https:\/\/www.postgresql.org\/docs\/current\/static\/datatype.html#DATATYPE-TABLE\n            \/\/ plus aliases from the shorter names produced by older wal2json\n            case \"boolean\":\n            case \"bool\":\n                return rawValue.asBoolean();\n\n            case \"integer\":\n            case \"int\":\n            case \"int4\":\n            case \"smallint\":\n            case \"int2\":\n            case \"smallserial\":\n            case \"serial\":\n            case \"serial2\":\n            case \"serial4\":\n            case \"oid\":\n                return rawValue.asInteger();\n\n            case \"bigint\":\n            case \"bigserial\":\n            case \"int8\":\n                return rawValue.asLong();\n\n            case \"real\":\n            case \"float4\":\n                return rawValue.isNumber() ? rawValue.asFloat() : Float.valueOf(rawValue.asString());\n\n            case \"double precision\":\n            case \"float8\":\n                return rawValue.isNumber() ? rawValue.asDouble() : Double.valueOf(rawValue.asString());\n\n            case \"numeric\":\n            case \"decimal\":\n                if (rawValue.isInteger()) {\n                    return new SpecialValueDecimal(new BigDecimal(rawValue.asInteger()));\n                }\n                else if (rawValue.isLong()) {\n                    return new SpecialValueDecimal(new BigDecimal(rawValue.asLong()));\n                }\n                else if (rawValue.isBigInteger()) {\n                    return new SpecialValueDecimal(new BigDecimal(rawValue.asBigInteger()));\n                }\n                return SpecialValueDecimal.valueOf(rawValue.asString());\n\n            case \"character\":\n            case \"char\":\n            case \"character varying\":\n            case \"varchar\":\n            case \"bpchar\":\n            case \"text\":\n                return rawValue.asString();\n\n            case \"date\":\n                return DateTimeFormat.get().date(rawValue.asString());\n\n            case \"timestamp with time zone\":\n            case \"timestamptz\":\n                return DateTimeFormat.get().timestampWithTimeZone(rawValue.asString());\n\n            case \"timestamp\":\n            case \"timestamp without time zone\":\n                return DateTimeFormat.get().timestamp(rawValue.asString());\n\n            case \"time\":\n            case \"time without time zone\":\n                return DateTimeFormat.get().time(rawValue.asString());\n\n            case \"time with time zone\":\n            case \"timetz\":\n                return DateTimeFormat.get().timeWithTimeZone(rawValue.asString());\n\n            case \"bytea\":\n                return Strings.hexStringToByteArray(rawValue.asString());\n\n            \/\/ these are all PG-specific types and we use the JDBC representations\n            \/\/ note that, with the exception of point, no converters for these types are implemented yet,\n            \/\/ i.e. those values won't actually be propagated to the outbound message until that's the case\n            case \"box\":\n                try {\n                    return new PGbox(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"circle\":\n                try {\n                    return new PGcircle(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse circle {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"interval\":\n                try {\n                    return new PGInterval(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"line\":\n                try {\n                    return new PGline(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"lseg\":\n                try {\n                    return new PGlseg(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"money\":\n                try {\n                    return new PGmoney(rawValue.asString()).val;\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse money {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"path\":\n                try {\n                    return new PGpath(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"point\":\n                try {\n                    return new PGpoint(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"polygon\":\n                try {\n                    return new PGpolygon(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n\n            \/\/ PostGIS types are HexEWKB strings\n            \/\/ ValueConverter turns them into the correct types\n            case \"geometry\":\n            case \"geography\":\n                return rawValue.asString();\n\n            case \"bit\":\n            case \"bit varying\":\n            case \"varbit\":\n            case \"json\":\n            case \"jsonb\":\n            case \"xml\":\n            case \"uuid\":\n            case \"tstzrange\":\n                return rawValue.asString();\n            \/\/ catch-all for other known\/builtin PG types\n            \/\/ TODO: improve with more specific\/useful classes here?\n            case \"cidr\":\n            case \"inet\":\n            case \"macaddr\":\n            case \"macaddr8\":\n            case \"pg_lsn\":\n            case \"tsquery\":\n            case \"tsvector\":\n            case \"txid_snapshot\":\n            \/\/ catch-all for unknown (extension module\/custom) types\n            default:\n                break;\n        }\n\n        if (includeUnknownDatatypes) {\n            \/\/ this includes things like PostGIS geometries or other custom types.\n            \/\/ leave up to the downstream message recipient to deal with.\n            LOGGER.debug(\"processing column '{}' with unknown data type '{}' as byte array\", columnName,\n                    fullType);\n            return rawValue.asString();\n        }\n        LOGGER.debug(\"Unknown column type {} for column {} \u00e2\u0080\u0093\u00c2\u00a0ignoring\", fullType, columnName);\n        return null;\n    }\n","new_comment_raw":"Converts the value (string representation) coming from wal2json plugin to a Java value based on the type of the column from the message.","old_comment_raw":"Converts the value (string representation) coming from wal2json plugin to a Java value based on the type of the column from the message.","label":0,"pre_label":1,"AST_level":12,"line_counts":204,"new_code_token_num":1445},{"new_code_raw":"public URL getRoot() { return rootUrl; }","old_code_raw":"\tpublic IPath getRoot() {\n\t\treturn root;\n\t}\n","new_comment_raw":"Method getRoot.","old_comment_raw":"Gets the root.","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":10},{"new_code_raw":"public static ExpectedCondition<Boolean> and(final ExpectedCondition<?>... conditions) { return new ExpectedCondition<Boolean>() { @Override public Boolean apply(WebDriver driver) { for (ExpectedCondition<?> condition : conditions) { Object result = condition.apply(driver); if (result instanceof Boolean) { if (Boolean.FALSE.equals(result)) { return false; } } if (result == null) { return false; } } return true; } @Override public String toString() { StringBuilder message = new StringBuilder(\"all conditions to be valid: \"); Joiner.on(\" && \").appendTo(message, conditions); return message.toString(); } }; }","old_code_raw":"  public static ExpectedCondition<Boolean> and(final ExpectedCondition<?>... conditions) {\n    return new ExpectedCondition<Boolean>() {\n      @Override\n      public Boolean apply(WebDriver driver) {\n        for (ExpectedCondition<?> condition : conditions) {\n          try {\n            Object result = condition.apply(driver);\n            if (result == null) {\n              return Boolean.FALSE;\n            } else if (result instanceof Boolean) {\n              if (!(Boolean) result) {\n                return Boolean.FALSE;\n              }\n            }\n          } catch (Exception e) {\n            return Boolean.FALSE;\n          }\n        }\n        return Boolean.TRUE;\n      }\n\n      @Override\n      public String toString() {\n        String message = \"all conditions to be valid: \";\n        for (ExpectedCondition<?> condition : conditions) {\n          message += condition.toString();\n        }\n        return message;\n      }\n    };\n  }\n","new_comment_raw":"An expectation with the logical and condition of the given list of conditions.","old_comment_raw":"An expectation with the logical and condition of the given list of conditions.","label":0,"pre_label":1,"AST_level":13,"line_counts":29,"new_code_token_num":131},{"new_code_raw":"public RepoPackageVersion removePackageVersion(PackageVersion packageVersion) { if ((this.repoPackageVersions == null) || (packageVersion == null)) { return null; } RepoPackageVersion doomed = null; for (RepoPackageVersion cpv : this.repoPackageVersions) { if (packageVersion.equals(cpv.getRepoPackageVersionPK().getPackageVersion())) { doomed = cpv; break; } } if (doomed != null) { this.repoPackageVersions.remove(doomed); } return doomed; }","old_code_raw":"    public ChannelPackageVersion removePackageVersion(PackageVersion packageVersion) {\n        if ((this.channelPackageVersions == null) || (packageVersion == null)) {\n            return null;\n        }\n\n        ChannelPackageVersion doomed = null;\n\n        for (ChannelPackageVersion cpv : this.channelPackageVersions) {\n            if (packageVersion.equals(cpv.getChannelPackageVersionPK().getPackageVersion())) {\n                doomed = cpv;\n                break;\n            }\n        }\n\n        if (doomed != null) {\n            this.channelPackageVersions.remove(doomed);\n        }\n\n        return doomed;\n    }\n","new_comment_raw":"Removes the package version from this repo, if it exists.","old_comment_raw":"Removes the package version from this channel, if it exists.","label":1,"pre_label":0,"AST_level":9,"line_counts":22,"new_code_token_num":81},{"new_code_raw":"public static AccessType fromExternalName(String externalName) { if ( externalName == null ) { return null; } for ( AccessType accessType : AccessType.values() ) { if ( accessType.getExternalName().equals( externalName ) ) { return accessType; } } \/\/ Check to see if making upper-case matches an enum name. try { return AccessType.valueOf( externalName.toUpperCase( Locale.ROOT) ); } catch ( IllegalArgumentException e ) { throw new UnknownAccessTypeException( externalName ); } }","old_code_raw":"\tpublic static AccessType fromExternalName(String externalName) {\n\t\tif ( externalName == null ) {\n\t\t\treturn null;\n\t\t}\n\t\tfor ( AccessType accessType : AccessType.values() ) {\n\t\t\tif ( accessType.getExternalName().equals( externalName ) ) {\n\t\t\t\treturn accessType;\n\t\t\t}\n\t\t}\n\t\tthrow new UnknownAccessTypeException( externalName );\n\t}\n","new_comment_raw":"Resolve an AccessType from its external name.","old_comment_raw":"Resolve an AccessType from its external name.","label":0,"pre_label":1,"AST_level":8,"line_counts":18,"new_code_token_num":91},{"new_code_raw":"protected boolean parse(String data) throws Exception { if(data == null || data.isEmpty()) { return true; } \/\/ ZAP: Replace all \"\\n\" with \"\\r\\n\" to parse correctly String newData = data.replaceAll(\"(?<!\\r)\\n\", CRLF); \/\/ ZAP: always use CRLF to comply with HTTP specification \/\/ even if the data it's not directly used. mLineDelimiter = CRLF; String[] split = patternCRLF.split(newData); mStartLine = split[0]; String token = null, name = null, value = null; int pos = 0; StringBuilder sb = new StringBuilder(2048); for (int i=1; i<split.length; i++) { token = split[i]; if (token.equals(\"\")) { continue; } if((pos = token.indexOf(\":\")) < 0) { mMalformedHeader = true; return false; } name = token.substring(0, pos).trim(); value = token.substring(pos +1).trim(); if(name.equalsIgnoreCase(CONTENT_LENGTH)) { try { mContentLength = Integer.parseInt(value); } catch (NumberFormatException nfe){} } \/* if (name.equalsIgnoreCase(PROXY_CONNECTION)) { sb.append(name + \": \" + _CLOSE + mLineDelimiter); } else if (name.equalsIgnoreCase(CONNECTION)) { sb.append(name + \": \" + _CLOSE + mLineDelimiter); } else { *\/ sb.append(name + \": \" + value + mLineDelimiter); \/\/} addInternalHeaderFields(name, value); } mMsgHeader = sb.toString(); return true; }","old_code_raw":"    protected boolean parse(String data) throws Exception {\n\n        String \ttoken = null,\n\t\t\t\tname = null,\n\t\t\t\tvalue = null;\n        int pos = 0;\n        Pattern pattern = null;\n\n        if(data == null || data.equals(\"\")) {\n            return true;\n        }\n\n        if ((pos = data.indexOf(CRLF)) < 0) {\n        \tif ((pos = data.indexOf(LF)) < 0) {\n        \t\treturn false;\n        \t} else {\n        \t\tmLineDelimiter = LF;\n        \t\tpattern = patternLF;\n        \t}\n        } else {\n        \tmLineDelimiter = CRLF;\n        \tpattern = patternCRLF;\n        }\n        \n\t\tString[] split = pattern.split(data);\n\t\tmStartLine = split[0];\n\n\t\tStringBuffer sb = new StringBuffer(2048);\n\t\tfor (int i=1; i<split.length; i++)\n\t\t{\n\t\t\ttoken = split[i];\n\t\t\tif (token.equals(\"\")) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n            if((pos = token.indexOf(\":\")) < 0) {\n\t\t\t\tmMalformedHeader = true;\n                return false;\n            }\n            name  = token.substring(0, pos).trim();\n            value = token.substring(pos +1).trim();\n\n            if(name.equalsIgnoreCase(CONTENT_LENGTH)) {\n            \ttry {\n                \tmContentLength = Integer.parseInt(value);\n            \t} catch (NumberFormatException nfe){}\n            }\n\t\t\t\n            \/*\n            if (name.equalsIgnoreCase(PROXY_CONNECTION)) {\n            \tsb.append(name + \": \" + _CLOSE + mLineDelimiter);\n            } else if (name.equalsIgnoreCase(CONNECTION)) {\n            \tsb.append(name + \": \" + _CLOSE + mLineDelimiter);\n            } else {\n            *\/\n\t\t\tsb.append(name + \": \" + value + mLineDelimiter);\n\t\t\t\/\/}\n\t\t\t\n\t\t\taddInternalHeaderFields(name, value);\n\t\t}\n\n        mMsgHeader = sb.toString();\n\t\treturn true;\n\t}\n","new_comment_raw":"Parse this Http header using the String given.","old_comment_raw":"Parse this Http header using the String given.","label":0,"pre_label":1,"AST_level":11,"line_counts":57,"new_code_token_num":327},{"new_code_raw":"public MainWindowBase getSleakWindow() { \/\/<DEBUG to find undisposed system resources> DeviceData data = new DeviceData(); data.tracking = true; Display display = new Display(data); Sleak sleak = new Sleak(); sleak.open(); Shell shell = new Shell(display); window = new MainWindowBase(shell); return window; \/\/<\/DEBUG> }","old_code_raw":"\tpublic MainWindow getSleakWindow() {\n\t\t\/\/<DEBUG to find undisposed system resources>\n\t\tDeviceData data = new DeviceData();\n\t\tdata.tracking = true;\n\t\tDisplay display = new Display(data);\n\t\tSleak sleak = new Sleak();\n\t\tsleak.open();\n\t\t\n\t\tShell shell = new Shell(display);\n\t\twindow = new MainWindow(shell);\n\t\treturn window;\n\t\t\/\/<\/DEBUG>\n\t}\n","new_comment_raw":"Initiates an instance of  MainWindowBase that is monitored by Sleak.java, to monitor what handles (to OS device context) are in use.","old_comment_raw":"Initiates an instance of MainWindow that is monitored by Sleak.java, to monitor what handles (to OS device context) are in use.","label":1,"pre_label":0,"AST_level":6,"line_counts":15,"new_code_token_num":68},{"new_code_raw":"public static long safeSubtract(long val1, long val2) { long diff = val1 - val2; \/\/ If there is a sign change, but the two values have different signs... if ((val1 ^ diff) < 0 && (val1 ^ val2) < 0) { throw new ArithmeticException (\"The calculation caused an overflow: \" + val1 + \" - \" + val2); } return diff; }","old_code_raw":"    public static long safeSubtract(long val1, long val2) {\n        if (val2 == Long.MIN_VALUE) {\n            if (val1 <= 0L) {\n                return (val1 - val2);\n            }\n            throw new ArithmeticException(\"The calculation caused an overflow: \" + val1 +\" - \" + val2);\n        }\n        return safeAdd(val1, -val2);\n    }\n","new_comment_raw":"Subtracts two values throwing an exception if overflow occurs.","old_comment_raw":"Subtracts two values throwing an exception if overflow occurs.","label":0,"pre_label":1,"AST_level":10,"line_counts":10,"new_code_token_num":79},{"new_code_raw":"final public Map getGroups() { return this.groups; }","old_code_raw":"    final public Map getGroups() {\n        return groups;\n    }\n","new_comment_raw":"Get all Groups","old_comment_raw":"DOCUMENT ME!","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":12},{"new_code_raw":"public boolean equals(Object readableInterval) { if (this == readableInterval) { return true; } if (readableInterval instanceof ReadableInterval == false) { return false; } ReadableInterval other = (ReadableInterval) readableInterval; return (getStartMillis() == other.getStartMillis() && getEndMillis() == other.getEndMillis() && getChronology() == other.getChronology()); }","old_code_raw":"    public boolean equals(Object readableInterval) {\n        if (this == readableInterval) {\n            return true;\n        }\n        if (readableInterval instanceof ReadableInterval == false) {\n            return false;\n        }\n        ReadableInterval other = (ReadableInterval) readableInterval;\n        return (getStartMillis() == other.getStartMillis() &&\n                getEndMillis() == other.getEndMillis());\n    }\n","new_comment_raw":"Compares this object with the specified object for equality based on start and end millis plus the chronology.","old_comment_raw":"Compares this object with the specified object for equality based on start and end millis.","label":1,"pre_label":0,"AST_level":7,"line_counts":13,"new_code_token_num":67},{"new_code_raw":"public Number getElementIndex(String locator) { WebElement element = elementFinder.findElement(driver, locator); String script = \"var _isCommentOrEmptyTextNode = function(node) {\\n\" + \" return node.nodeType == 8 || ((node.nodeType == 3) && !(\/[^\\\\t\\\\n\\\\r ]\/.test(node.data)));\\n\" + \"}\\n\" + \" var element = arguments[0];\\n\" + \" var previousSibling;\\n\" + \" var index = 0;\\n\" + \" while ((previousSibling = element.previousSibling) != null) {\\n\" + \" if (!_isCommentOrEmptyTextNode(previousSibling)) {\\n\" + \" index++;\\n\" + \" }\\n\" + \" element = previousSibling;\\n\" + \" }\\n\" + \" return index;\"; return (Long) javascriptLibrary.executeScript(driver, script, element); }","old_code_raw":"  public Number getElementIndex(String locator) {\n    WebElement element = elementFinder.findElement(driver, locator);\n    String script = \n      \"var _isCommentOrEmptyTextNode = function(node) {\\n\" + \n      \"    return node.nodeType == 8 || ((node.nodeType == 3) && !(\/[^\\\\t\\\\n\\\\r ]\/.test(node.data)));\\n\" + \n      \"}\\n\" +\n      \"    var element = arguments[0];\\n\" +\n      \"    var previousSibling;\\n\" + \n      \"    var index = 0;\\n\" + \n      \"    while ((previousSibling = element.previousSibling) != null) {\\n\" + \n      \"        if (!_isCommentOrEmptyTextNode(previousSibling)) {\\n\" + \n      \"            index++;\\n\" + \n      \"        }\\n\" + \n      \"        element = previousSibling;\\n\" + \n      \"    }\\n\" + \n      \"    return index;\";\n    return (Long) executeScript(script, element);\n  }\n","new_comment_raw":"Get the relative index of an element to its parent (starting from 0).","old_comment_raw":"Get the relative index of an element to its parent (starting from 0).","label":0,"pre_label":1,"AST_level":17,"line_counts":19,"new_code_token_num":190},{"new_code_raw":"File getBaseDir(final File file1, final File file2) { if (file1 == null || file2 == null) { return null; } final Iterator file1Parents = getParents(file1).iterator(); final Iterator file2Parents = getParents(file2.getAbsoluteFile()).iterator(); File result = null; while (file1Parents.hasNext() && file2Parents.hasNext()) { File next = (File) file1Parents.next(); if (next.equals(file2Parents.next())) { result = next; } else { break; } } return result; }","old_code_raw":"    File getBaseDir(File base, File file) {\n        if (base == null) {\n            return file.getParentFile().getAbsoluteFile();\n        } else {\n            Iterator bases = getParents(base).iterator();\n            Iterator fileParents = getParents(file.getAbsoluteFile()).iterator();\n            File result = null;\n            while (bases.hasNext() && fileParents.hasNext()) {\n                File next = (File) bases.next();\n                if (next.equals(fileParents.next())) {\n                    result = next;\n                } else {\n                    break;\n                }\n            }\n            return result;\n        }\n    }\n","new_comment_raw":"Returns the common base directory between the passed file1 and file2.","old_comment_raw":"Returns the common base directory between a current base directory and a given file.","label":1,"pre_label":0,"AST_level":9,"line_counts":19,"new_code_token_num":105},{"new_code_raw":"private FileSelection expandIfNecessary(FileSelection selection) throws IOException { if (selection.isExpandedFully()) { return selection; } \/\/ use the cacheFileRoot if provided (e.g after partition pruning) Path metaFilePath = new Path(cacheFileRoot != null ? cacheFileRoot : selectionRoot, Metadata.METADATA_FILENAME); if (!fs.exists(metaFilePath)) { \/\/ no metadata cache if (selection.isExpandedPartial()) { logger.error(\"'{}' metadata file does not exist, but metadata directories cache file is present\", metaFilePath); metaContext.setMetadataCacheCorrupted(true); } return selection; } return expandSelectionFromMetadataCache(selection, metaFilePath); }","old_code_raw":"  private FileSelection expandIfNecessary(FileSelection selection) throws IOException {\n    if (selection.isExpandedFully()) {\n      return selection;\n    }\n\n    \/\/ use the cacheFileRoot if provided (e.g after partition pruning)\n    Path metaFilePath = new Path(cacheFileRoot != null ? cacheFileRoot : selectionRoot, Metadata.METADATA_FILENAME);\n    if (!fs.exists(metaFilePath)) { \/\/ no metadata cache\n      return selection;\n    }\n\n    FileSelection expandedSelection = initFromMetadataCache(selection, metaFilePath);\n    return expandedSelection;\n  }\n","new_comment_raw":"expands the selection's folders if metadata cache is found for the selection root.","old_comment_raw":"expands the selection's folders if metadata cache is found for the selection root.","label":0,"pre_label":1,"AST_level":9,"line_counts":19,"new_code_token_num":122},{"new_code_raw":"public Float getBottomValue() { return bottomValue; }","old_code_raw":"        public float getBottomValue() {\n            return bottomValue == null ? 0 : bottomValue.floatValue();\n        }\n","new_comment_raw":"Gets the 'bottom' attributes value using current units.","old_comment_raw":"Gets the 'bottom' CSS-attributes value in specified units.","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":10},{"new_code_raw":"public Builder argument(GraphQLArgument.Builder builder) { return argument(builder.build()); }","old_code_raw":"        public Builder argument(GraphQLArgument.Builder builder) {\n            this.arguments.add(builder.build());\n            return this;\n        }\n","new_comment_raw":"Same effect as the argument(GraphQLArgument).","old_comment_raw":"Same effect as the argument(GraphQLArgument).","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":19},{"new_code_raw":"public DateTimeFormatterBuilder appendHourOfDay(int minDigits) { return appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2); }","old_code_raw":"    public DateTimeFormatterBuilder appendHourOfDay(final int minDigits) {\n        return appendDecimal(iChronoUTC.hourOfDay(), minDigits, 2);\n    }\n","new_comment_raw":"Instructs the printer to emit a numeric hourOfDay field.","old_comment_raw":"Instructs the printer to emit a numeric hourOfDay field.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":22},{"new_code_raw":"public static String addPropertiesToURIFromBean(String uri, Object bean) throws Exception { Map<String, String> properties = PropertyUtil.getProperties(bean); return PropertyUtil.addPropertiesToURI(uri, properties); }","old_code_raw":"    public static String addPropertiesToURIFromBean(String uri, Object bean) throws Exception {\n        Map<String, String> props = PropertyUtil.getProperties(bean);\n        return PropertyUtil.addPropertiesToURI(uri, props);\n    }\n","new_comment_raw":"Enumerate the properties of the target object and add them as additional entries to the query string of the given string URI.","old_comment_raw":"Add bean properties to a URI","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":35},{"new_code_raw":"public List<RelDataType> collectOperandTypes() { return new AbstractList<RelDataType>() { public RelDataType get(int index) { return getOperandType(index); } public int size() { return getOperandCount(); } }; }","old_code_raw":"    public RelDataType [] collectOperandTypes()\n    {\n        RelDataType [] ret = new RelDataType[getOperandCount()];\n        for (int i = 0; i < ret.length; i++) {\n            ret[i] = getOperandType(i);\n        }\n        return ret;\n    }\n","new_comment_raw":"Collects the types of the bound operands into a list.","old_comment_raw":"Collects the types of the bound operands into an array.","label":1,"pre_label":0,"AST_level":8,"line_counts":13,"new_code_token_num":44},{"new_code_raw":"public Symbol generate(Schema sc, Map<LitS, Symbol> seen) { switch (sc.getType()) { case NULL: case BOOLEAN: case INT: case LONG: case FLOAT: case DOUBLE: case STRING: case BYTES: case FIXED: case UNION: return super.generate(sc, seen); case ENUM: return Symbol.seq(Symbol.enumLabelsAction(sc.getEnumSymbols()), Symbol.ENUM); case ARRAY: return Symbol.seq(Symbol.repeat(Symbol.ARRAY_END, Symbol.ITEM_END, generate(sc.getElementType(), seen)), Symbol.ARRAY_START); case MAP: return Symbol.seq(Symbol.repeat(Symbol.MAP_END, Symbol.ITEM_END, generate(sc.getValueType(), seen), Symbol.MAP_KEY_MARKER, Symbol.STRING), Symbol.MAP_START); case RECORD: { LitS wsc = new LitS(sc); Symbol rresult = seen.get(wsc); if (rresult == null) { Symbol[] production = new Symbol[sc.getFields().size() * 3 + 2]; rresult = Symbol.seq(production); seen.put(wsc, rresult); int i = production.length; int n = 0; production[--i] = Symbol.RECORD_START; for (Field f : sc.getFields()) { production[--i] = Symbol.fieldAdjustAction(n, f.name()); production[--i] = generate(f.schema(), seen); production[--i] = Symbol.FIELD_END; n++; } production[--i] = Symbol.RECORD_END; } return rresult; } default: throw new RuntimeException(\"Unexpected schema type\"); } }","old_code_raw":"  public Symbol generate(Schema sc, Map<LitS, Symbol> seen) {\n    switch (sc.getType()) {\n    case NULL:\n    case BOOLEAN:\n    case INT:\n    case LONG:\n    case FLOAT:\n    case DOUBLE:\n    case STRING:\n    case BYTES:\n    case FIXED:\n    case UNION:\n      return super.generate(sc, seen);\n    case ENUM:\n      return Symbol.seq(new Symbol.EnumLabelsAction(sc.getEnumSymbols()),\n          Symbol.ENUM);\n    case ARRAY:\n      return Symbol.seq(Symbol.repeat(Symbol.ARRAY_END,\n              Symbol.ITEM_END, generate(sc.getElementType(), seen)),\n          Symbol.ARRAY_START);\n    case MAP:\n      return Symbol.seq(Symbol.repeat(Symbol.MAP_END,\n              Symbol.ITEM_END, generate(sc.getValueType(), seen),\n              Symbol.MAP_KEY_MARKER, Symbol.STRING),\n          Symbol.MAP_START);\n    case RECORD: {\n      LitS wsc = new LitS(sc);\n      Symbol rresult = seen.get(wsc);\n      if (rresult == null) {\n        Symbol[] production = new Symbol[sc.getFields().size() * 3 + 2];\n        rresult = Symbol.seq(production);\n        seen.put(wsc, rresult);\n\n        int i = production.length;\n        int n = 0;\n        production[--i] = Symbol.RECORD_START;\n        for (Field f : sc.getFields()) {\n          production[--i] = new Symbol.FieldAdjustAction(n, f.name());\n          production[--i] = generate(f.schema(), seen);\n          production[--i] = Symbol.FIELD_END;\n          n++;\n        }\n        production[--i] = Symbol.RECORD_END;\n      }\n      return rresult;\n    }\n    default:\n      throw new RuntimeException(\"Unexpected schema type\");\n    }\n  }\n","new_comment_raw":"Returns the non-terminal that is the start symbol for grammar of the given schema sc.","old_comment_raw":"Returns the non-terminal that is the start symbol for grammar of the given schema sc.","label":0,"pre_label":1,"AST_level":14,"line_counts":51,"new_code_token_num":315},{"new_code_raw":"public String getName() { return this.fullName; }","old_code_raw":"    public String getName() {\n        return this.name;\n    }\n","new_comment_raw":"Returns the full name (i.e.","old_comment_raw":"Returns the name of the element.","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":11},{"new_code_raw":"public String getMergePolicy() { return mergePolicy; }","old_code_raw":"    public String getMergePolicy() {\n        return mergePolicyConfig.getPolicy();\n    }\n","new_comment_raw":"Gets the map merge policy  com.hazelcast.map.merge.MapMergePolicy","old_comment_raw":"Gets the merge policy.","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":10},{"new_code_raw":"public int destroy() { ExecuteWatchdog watchdog = executor.getWatchdog(); while (!watchdog.isWatching()){ try { Thread.sleep(50); } catch (InterruptedException e) { throw new WebDriverException(e); } } watchdog.destroyProcess(); if (handler.hasResult()) { return getExitCode(); } log.info(\"Process destruction entered a last-ditch phase that shouldn't happen. File an issue if you see this message\"); \/\/ Give the process a chance to die naturally. quiesceFor(3, SECONDS); if (!handler.hasResult()) { log.info( \"Command failed to close cleanly. Destroying forcefully. \" + this); ProcessUtils.killProcess(snitch.getProcess()); quiesceFor(1, SECONDS); } int exitCode; if (!handler.hasResult()) { log.severe(String.format( \"Unable to kill process with PID %s: %s\", snitch.getProcess(), this)); exitCode = -1; executor.setExitValue(exitCode); } else { exitCode = getExitCode(); } postRunCleanup(); return exitCode; }","old_code_raw":"  public int destroy() {\n    ExecuteWatchdog watchdog = executor.getWatchdog();\n    if (watchdog != null) {\n      watchdog.destroyProcess();\n    }\n\n    \/\/ Give the process a chance to die naturally.\n    quiesceFor(3, SECONDS);\n\n    if (!handler.hasResult()) {\n      log.info(\n          \"Command failed to close cleanly. Destroying forcefully. \" + this);\n      ProcessUtils.killProcess(snitch.getProcess());\n      quiesceFor(1, SECONDS);\n    }\n\n    int exitCode;\n    if (!handler.hasResult()) {\n      log.severe(String.format(\n          \"Unable to kill process with PID %s: %s\", snitch.getProcess(), this));\n      exitCode = -1;\n      executor.setExitValue(exitCode);\n    } else {\n      exitCode = getExitCode();\n    }\n\n    postRunCleanup();\n    return exitCode;\n  }\n","new_comment_raw":"Destroy the current command.","old_comment_raw":"Destroy the current command.","label":0,"pre_label":1,"AST_level":9,"line_counts":40,"new_code_token_num":220},{"new_code_raw":"public Path getEntirePartitionLocation() { return file; }","old_code_raw":"  public String getEntirePartitionLocation() {\n    return file;\n  }\n","new_comment_raw":"Return the full location of this partition","old_comment_raw":"Return the full location of this partition","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"private static Gobbling gobble( Treepath< SyntacticTree > gobbleStart, int indentation ) { Preconditions.checkArgument( gobbleStart.getTreeAtEnd().isOneOf( _PLACEHOLDER_ ) ) ; Treepath< SyntacticTree > start = gobbleStart ; do { if( TreepathTools.hasNextSibling( start ) ) { final Treepath< SyntacticTree > next = TreepathTools.getNextSibling( start ) ; if( isRawItem( next ) ) { final Treepath< SyntacticTree > minusNext = TreepathTools.removeNextSibling( start ) ; return new Gobbling( minusNext, makeEmbeddedListItem( next ), indentation ) ; } else { final SyntacticTree nextTree = next.getTreeAtEnd() ; if( nextTree.isOneOf( WHITESPACE_, LINE_BREAK_ ) ) { start = TreepathTools.removeNextSibling( start ) ; if( nextTree.isOneOf( WHITESPACE_ ) ) { indentation = getWhitespaceLength( next ) ; } continue ; } } } \/\/ If no next sibling at all, or no useful next sibling, then return. return new Gobbling( start ) ; } while( true ) ; }","old_code_raw":"  private static Gobbling gobble( Treepath< SyntacticTree > gobbleStart ) {\n    if( null == gobbleStart ) {\n      return null ;\n    }\n    Preconditions.checkArgument( gobbleStart.getTreeAtEnd().isOneOf( _PLACEHOLDER_ ) ) ;\n    gobbleStart = TreepathTools.getNextSibling( gobbleStart ) ;\n    \n    do {\n      if( isRawItem( gobbleStart ) ) {\n        if( TreepathTools.hasNextSibling( gobbleStart ) ) {\n          final Treepath< SyntacticTree > nextStart = TreepathTools.getNextSibling( gobbleStart ) ;\n          final Treepath< SyntacticTree > nextStartMinusPrevious =\n              TreepathTools.removePreviousSibling( nextStart ) ;\n          return new Gobbling( nextStartMinusPrevious, makeEmbeddedListItem( gobbleStart ), true ) ;\n        } else {\n          final Treepath< SyntacticTree > minusPrevious = TreepathTools.removeEnd( gobbleStart ) ;\n          return new Gobbling( minusPrevious, makeEmbeddedListItem( gobbleStart ), false ) ;\n        }\n      } else if( gobbleStart.getTreeAtEnd().isOneOf( WHITESPACE_, LINE_BREAK_ ) ) {\n        if( TreepathTools.hasNextSibling( gobbleStart ) ) {\n          gobbleStart = TreepathTools.getNextSibling( gobbleStart ) ;\n        }\n      } else {\n        return null ;\n      }\n    } while( true ) ;\n  }\n","new_comment_raw":"Gobbles one item node if possible.","old_comment_raw":"Gobble one item node if possible.","label":1,"pre_label":0,"AST_level":16,"line_counts":28,"new_code_token_num":165},{"new_code_raw":"protected String[] usualWindowsLauncherLocations() { return new String[] { WindowsUtils.getLocalAppDataPath() + \"\\\\Google\\\\Chrome\\\\Application\", WindowsUtils.getProgramFiles86Path() + \"\\\\Google\\\\Chrome\\\\Application\", WindowsUtils.getProgramFilesPath() + \"\\\\Google\\\\Chrome\\\\Application\" }; }","old_code_raw":"  protected String[] usualWindowsLauncherLocations() {\n    return new String[] {\n        WindowsUtils.getLocalAppDataPath() + \"\\\\Google\\\\Chrome\\\\Application\"\n    };\n  }\n","new_comment_raw":"Returns usual Google Chrome installation location on Windows.","old_comment_raw":"Returns usual Google Chrome installation location on Windows.","label":0,"pre_label":1,"AST_level":7,"line_counts":8,"new_code_token_num":67},{"new_code_raw":"private List<WorkerInfo> checkWorkers() { boolean failJob = true; int pollAttempt = 0; List<WorkerInfo> healthyWorkerInfoList = new ArrayList<WorkerInfo>(); List<WorkerInfo> unhealthyWorkerInfoList = new ArrayList<WorkerInfo>(); int totalResponses = -1; while (pollAttempt < maxPollAttempts) { getAllWorkerInfos( getSuperstep(), healthyWorkerInfoList, unhealthyWorkerInfoList); totalResponses = healthyWorkerInfoList.size() + unhealthyWorkerInfoList.size(); if ((totalResponses * 100.0f \/ maxWorkers) >= minPercentResponded) { failJob = false; break; } getContext().setStatus(getGraphMapper().getMapFunctions() + \" \" + \"checkWorkers: Only found \" + totalResponses + \" responses of \" + maxWorkers + \" needed to start superstep \" + getSuperstep()); if (getWorkerHealthRegistrationChangedEvent().waitMsecs( msecsPollPeriod)) { if (LOG.isDebugEnabled()) { LOG.debug(\"checkWorkers: Got event that health \" + \"registration changed, not using poll attempt\"); } getWorkerHealthRegistrationChangedEvent().reset(); continue; } if (LOG.isInfoEnabled()) { LOG.info(\"checkWorkers: Only found \" + totalResponses + \" responses of \" + maxWorkers + \" needed to start superstep \" + getSuperstep() + \". Sleeping for \" + msecsPollPeriod + \" msecs and used \" + pollAttempt + \" of \" + maxPollAttempts + \" attempts.\"); \/\/ Find the missing workers if there are only a few if ((maxWorkers - totalResponses) <= partitionLongTailMinPrint) { Set<Integer> partitionSet = new TreeSet<Integer>(); for (WorkerInfo workerInfo : healthyWorkerInfoList) { partitionSet.add(workerInfo.getPartitionId()); } for (WorkerInfo workerInfo : unhealthyWorkerInfoList) { partitionSet.add(workerInfo.getPartitionId()); } for (int i = 1; i <= maxWorkers; ++i) { if (partitionSet.contains(new Integer(i))) { continue; } else if (i == getTaskPartition()) { continue; } else { LOG.info(\"checkWorkers: No response from \"+ \"partition \" + i + \" (could be master)\"); } } } } ++pollAttempt; } if (failJob) { LOG.error(\"checkWorkers: Did not receive enough processes in \" + \"time (only \" + totalResponses + \" of \" + minWorkers + \" required). This occurs if you do not \" + \"have enough map tasks available simultaneously on \" + \"your Hadoop instance to fulfill the number of \" + \"requested workers.\"); return null; } if (healthyWorkerInfoList.size() < minWorkers) { LOG.error(\"checkWorkers: Only \" + healthyWorkerInfoList.size() + \" available when \" + minWorkers + \" are required.\"); return null; } return healthyWorkerInfoList; }","old_code_raw":"    private Map<String, JSONArray> checkWorkers() {\n        boolean failJob = true;\n        int pollAttempt = 0;\n        List<String> healthyWorkerList = new ArrayList<String>();\n        List<String> unhealthyWorkerList = new ArrayList<String>();\n        int totalResponses = -1;\n        while (pollAttempt < maxPollAttempts) {\n            getWorkers(\n                getSuperstep(), healthyWorkerList, unhealthyWorkerList);\n            totalResponses = healthyWorkerList.size() +\n                unhealthyWorkerList.size();\n            if ((totalResponses * 100.0f \/ maxWorkers) >=\n                    minPercentResponded) {\n                failJob = false;\n                break;\n            }\n            getContext().setStatus(getGraphMapper().getMapFunctions() + \" \" +\n                                   \"checkWorkers: Only found \" +\n                                   totalResponses +\n                                   \" responses of \" + maxWorkers +\n                                   \" needed to start superstep \" +\n                                   getSuperstep());\n            if (getWorkerHealthRegistrationChangedEvent().waitMsecs(\n                    msecsPollPeriod)) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"checkWorkers: Got event that health \" +\n                              \"registration changed, not using poll attempt\");\n                }\n                getWorkerHealthRegistrationChangedEvent().reset();\n                continue;\n            }\n            if (LOG.isInfoEnabled()) {\n                LOG.info(\"checkWorkers: Only found \" + totalResponses +\n                         \" responses of \" + maxWorkers +\n                         \" needed to start superstep \" +\n                         getSuperstep() + \".  Sleeping for \" +\n                         msecsPollPeriod + \" msecs and used \" + pollAttempt +\n                         \" of \" + maxPollAttempts + \" attempts.\");\n                \/\/ Find the missing workers if there are only a few\n                if ((maxWorkers - totalResponses) <= partitionLongTailMinPrint) {\n                    Set<Integer> partitionSet = new TreeSet<Integer>();\n                    for (String hostnamePartitionId : healthyWorkerList) {\n                        int lastIndex = hostnamePartitionId.lastIndexOf(\"_\");\n                        Integer partition = Integer.parseInt(\n                            hostnamePartitionId.substring(lastIndex + 1));\n                        partitionSet.add(partition);\n                    }\n                    for (String hostnamePartitionId : unhealthyWorkerList) {\n                        int lastIndex = hostnamePartitionId.lastIndexOf(\"_\");\n                        Integer partition = Integer.parseInt(\n                            hostnamePartitionId.substring(lastIndex + 1));\n                        partitionSet.add(partition);\n                    }\n                    for (int i = 1; i <= maxWorkers; ++i) {\n                        if (partitionSet.contains(new Integer(i))) {\n                            continue;\n                        } else if (i == getTaskPartition()) {\n                            continue;\n                        } else {\n                            LOG.info(\"checkWorkers: No response from \"+\n                                     \"partition \" + i + \" (could be master)\");\n                        }\n                    }\n                }\n            }\n            ++pollAttempt;\n        }\n        if (failJob) {\n            LOG.error(\"checkWorkers: Did not receive enough processes in \" +\n                      \"time (only \" + totalResponses + \" of \" +\n                      minWorkers + \" required).  This occurs if you do not \" +\n                      \"have enough map tasks available simultaneously on \" +\n                      \"your Hadoop instance to fulfill the number of \" +\n                      \"requested workers.\");\n            return null;\n        }\n\n        if (healthyWorkerList.size() < minWorkers) {\n            LOG.error(\"checkWorkers: Only \" + healthyWorkerList.size() +\n                      \" available when \" + minWorkers + \" are required.\");\n            return null;\n        }\n\n        Map<String, JSONArray> workerHostnamePortMap =\n            new HashMap<String, JSONArray>();\n        for (String healthyWorker: healthyWorkerList) {\n            String healthyWorkerPath = null;\n            try {\n                healthyWorkerPath =\n                    getWorkerHealthyPath(getApplicationAttempt(),\n                                         getSuperstep()) + \"\/\" +  healthyWorker;\n                JSONArray hostnamePortArray =\n                    new JSONArray(\n                        new String(getZkExt().getData(healthyWorkerPath,\n                                                      false,\n                                                      null)));\n                workerHostnamePortMap.put(healthyWorker, hostnamePortArray);\n            } catch (JSONException e) {\n                throw new RuntimeException(\n                    \"checkWorkers: Problem fetching hostname and port for \" +\n                    healthyWorker + \" in \" + healthyWorkerPath);\n            } catch (KeeperException e) {\n                throw new IllegalStateException(\n                    \"checkWorkers: KeeperException\", e);\n            } catch (InterruptedException e) {\n                throw new IllegalStateException(\n                    \"checkWorkers: IllegalStateException\", e);\n            }\n        }\n\n        return workerHostnamePortMap;\n    }\n","new_comment_raw":"Check all the  WorkerInfo objects to ensure that a minimum number of good workers exists out of the total that have reported.","old_comment_raw":"Check the workers to ensure that a minimum number of good workers exists out of the total that have reported.","label":1,"pre_label":0,"AST_level":21,"line_counts":82,"new_code_token_num":510},{"new_code_raw":"private ZapTextField getTxtReverseProxyIp() { if (txtReverseProxyIp == null) { txtReverseProxyIp = new ZapTextField(); } return txtReverseProxyIp; }","old_code_raw":"\tprivate JTextField getTxtReverseProxyIp() {\n\t\tif (txtReverseProxyIp == null) {\n\t\t\ttxtReverseProxyIp = new JTextField();\n\t\t}\n\t\treturn txtReverseProxyIp;\n\t}\n","new_comment_raw":"This method initializes txtProxyIpSSL","old_comment_raw":"This method initializes txtProxyIpSSL","label":0,"pre_label":1,"AST_level":8,"line_counts":7,"new_code_token_num":23},{"new_code_raw":"public final int getColumn() { return this.bufcolumn[this.bufpos]; }","old_code_raw":"    public final int getColumn() {\n        return bufcolumn[bufpos];\n    }\n","new_comment_raw":"Get the column position","old_comment_raw":"DOCUMENT ME!","label":1,"pre_label":0,"AST_level":7,"line_counts":5,"new_code_token_num":16},{"new_code_raw":"private ZapTextField getTxtProxyPort() { if (txtProxyPort == null) { txtProxyPort = new ZapTextField(); } return txtProxyPort; }","old_code_raw":"\tprivate JTextField getTxtProxyPort() {\n\t\tif (txtProxyPort == null) {\n\t\t\ttxtProxyPort = new JTextField();\n\t\t}\n\t\treturn txtProxyPort;\n\t}\n","new_comment_raw":"This method initializes txtProxyPort","old_comment_raw":"This method initializes txtProxyPort","label":0,"pre_label":1,"AST_level":8,"line_counts":7,"new_code_token_num":23},{"new_code_raw":"private static Consumer<List> mongoChecker(final String... expected) { return actual -> { if (expected == null) { Assert.assertThat(\"null mongo Query\", actual, CoreMatchers.nullValue()); return; } if (expected.length == 0) { CalciteAssert.assertArrayEqual(\"empty Mongo query\", expected, actual.toArray(new Object[0])); return; } final BsonDocument expectedBson = BsonDocument.parse(String.join(\",\", expected)); final BsonDocument actualBson = BsonDocument.parse(((List<?>) actual.get(0)) .stream() .map(Objects::toString) .collect(Collectors.joining(\"\\n\"))); \/\/ compare Bson (not string) representation if (!expectedBson.equals(actualBson)) { final JsonWriterSettings settings = JsonWriterSettings.builder().indent(true).build(); \/\/ used to pretty print Assertion error Assert.assertEquals(\"expected and actual Mongo queries do not match\", expectedBson.toJson(settings), actualBson.toJson(settings)); Assert.fail(\"Should have failed previously because (expected != actual) is already known\"); } }; }","old_code_raw":"  private static Consumer<List> mongoChecker(final String... strings) {\n    return actual -> {\n      Object[] actualArray =\n          actual == null || actual.isEmpty()\n              ? null\n              : ((List) actual.get(0)).toArray();\n      CalciteAssert.assertArrayEqual(\"expected MongoDB query not found\",\n          strings, actualArray);\n    };\n  }\n","new_comment_raw":"Returns a function that checks that a particular MongoDB query has been called.","old_comment_raw":"Returns a function that checks that a particular MongoDB pipeline is generated to implement a query.","label":1,"pre_label":0,"AST_level":11,"line_counts":31,"new_code_token_num":223},{"new_code_raw":"public TopicPublisher createPublisher(Topic topic) throws JMSException { checkClosed(); if (topic instanceof CustomDestination) { CustomDestination customDestination = (CustomDestination) topic; return customDestination.createPublisher(this); } return new ActiveMQTopicPublisher(this, ActiveMQMessageTransformation.transformDestination(topic)); }","old_code_raw":"    public TopicPublisher createPublisher(Topic topic) throws JMSException {\n        checkClosed();\n        return new ActiveMQTopicPublisher(this, ActiveMQMessageTransformation.transformDestination(topic));\n    }\n","new_comment_raw":"Creates a publisher for the specified topic.","old_comment_raw":"Creates a publisher for the specified topic.","label":0,"pre_label":1,"AST_level":8,"line_counts":10,"new_code_token_num":50},{"new_code_raw":"public Component[] getChildren() { ensureZOrder(); Component[] c = new Component[children.size()]; return (Component[])children.toArray(c); }","old_code_raw":"    public SuiComponent[] getChildren() {\r\n        ensureZOrder();\r\n        SuiComponent[] c = new SuiComponent[children.size()];\r\n        return (SuiComponent[])children.toArray(c);\r\n    }\r\n","new_comment_raw":"Returns an array of this Container's children.","old_comment_raw":"Returns an array of this SuiContainer's children.","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":38},{"new_code_raw":"public boolean addFile(File sourceFile) { String filename = sourceFile.getName(); File destFile = null; String codeExtension = null; boolean replacement = false; \/\/ if the file appears to be code related, drop it \/\/ into the code folder, instead of the data folder if (filename.toLowerCase().endsWith(\".class\") || filename.toLowerCase().endsWith(\".jar\") || filename.toLowerCase().endsWith(\".dll\") || filename.toLowerCase().endsWith(\".jnilib\") || filename.toLowerCase().endsWith(\".so\")) { \/\/if (!codeFolder.exists()) codeFolder.mkdirs(); prepareCodeFolder(); destFile = new File(codeFolder, filename); } else { for (String extension : mode.getExtensions()) { String lower = filename.toLowerCase(); if (lower.endsWith(\".\" + extension)) { destFile = new File(this.folder, filename); codeExtension = extension; } } if (codeExtension == null) { prepareDataFolder(); destFile = new File(dataFolder, filename); } } \/\/ check whether this file already exists if (destFile.exists()) { Object[] options = { Language.text(\"prompt.ok\"), Language.text(\"prompt.cancel\") }; String prompt = Language.interpolate(\"add_file.messages.confirm_replace\", filename); int result = JOptionPane.showOptionDialog(editor, prompt, \"Replace\", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options[0]); if (result == JOptionPane.YES_OPTION) { replacement = true; } else { return false; } } \/\/ If it's a replacement, delete the old file first, \/\/ otherwise case changes will not be preserved. \/\/ http:\/\/dev.processing.org\/bugs\/show_bug.cgi?id=969 if (replacement) { boolean muchSuccess = destFile.delete(); if (!muchSuccess) { Base.showWarning(Language.text(\"add_file.messages.error_adding\"), Language.interpolate(\"add_file.messages.cannot_delete.description\", filename), null); return false; } } \/\/ make sure they aren't the same file if ((codeExtension == null) && sourceFile.equals(destFile)) { Base.showWarning(Language.text(\"add_file.messages.same_file\"), Language.text(\"add_file.messages.same_file.description\"), null); return false; } \/\/ Handles \"Add File\" when a .pde is used. For beta 1, this no longer runs \/\/ on a separate thread because it's totally unnecessary (a .pde file is \/\/ not going to be so large that it's ever required) and otherwise we have \/\/ to introduce a threading block here. \/\/ https:\/\/github.com\/processing\/processing\/issues\/3383 if (!sourceFile.equals(destFile)) { try { Base.copyFile(sourceFile, destFile); } catch (IOException e) { Base.showWarning(Language.text(\"add_file.messages.error_adding\"), Language.interpolate(\"add_file.messages.cannot_add.description\", filename), e); return false; } } if (codeExtension != null) { SketchCode newCode = new SketchCode(destFile, codeExtension); if (replacement) { replaceCode(newCode); } else { insertCode(newCode); sortCode(); } setCurrentCode(filename); editor.header.repaint(); if (isUntitled()) { \/\/ TODO probably not necessary? problematic? \/\/ Mark the new code as modified so that the sketch is saved current.setModified(true); } } else { if (isUntitled()) { \/\/ TODO probably not necessary? problematic? \/\/ If a file has been added, mark the main code as modified so \/\/ that the sketch is properly saved. code[0].setModified(true); } } return true; }","old_code_raw":"  public boolean addFile(File sourceFile) {\n    String filename = sourceFile.getName();\n    File destFile = null;\n    String codeExtension = null;\n    boolean replacement = false;\n\n    \/\/ if the file appears to be code related, drop it\n    \/\/ into the code folder, instead of the data folder\n    if (filename.toLowerCase().endsWith(\".class\") ||\n        filename.toLowerCase().endsWith(\".jar\") ||\n        filename.toLowerCase().endsWith(\".dll\") ||\n        filename.toLowerCase().endsWith(\".jnilib\") ||\n        filename.toLowerCase().endsWith(\".so\")) {\n\n      \/\/if (!codeFolder.exists()) codeFolder.mkdirs();\n      prepareCodeFolder();\n      destFile = new File(codeFolder, filename);\n\n    } else {\n      for (String extension : mode.getExtensions()) {\n        String lower = filename.toLowerCase();\n        if (lower.endsWith(\".\" + extension)) {\n          destFile = new File(this.folder, filename);\n          codeExtension = extension;\n        }\n      }\n      if (codeExtension == null) {\n        prepareDataFolder();\n        destFile = new File(dataFolder, filename);\n      }\n    }\n\n    \/\/ check whether this file already exists\n    if (destFile.exists()) {\n      Object[] options = { Language.text(\"prompt.ok\"), Language.text(\"prompt.cancel\") };\n      String prompt = \"Replace the existing version of \" + filename + \"?\";\n      int result = JOptionPane.showOptionDialog(editor,\n                                                prompt,\n                                                \"Replace\",\n                                                JOptionPane.YES_NO_OPTION,\n                                                JOptionPane.QUESTION_MESSAGE,\n                                                null,\n                                                options,\n                                                options[0]);\n      if (result == JOptionPane.YES_OPTION) {\n        replacement = true;\n      } else {\n        return false;\n      }\n    }\n\n    \/\/ If it's a replacement, delete the old file first,\n    \/\/ otherwise case changes will not be preserved.\n    \/\/ http:\/\/dev.processing.org\/bugs\/show_bug.cgi?id=969\n    if (replacement) {\n      boolean muchSuccess = destFile.delete();\n      if (!muchSuccess) {\n        Base.showWarning(\"Error adding file\",\n                         \"Could not delete the existing '\" +\n                         filename + \"' file.\", null);\n        return false;\n      }\n    }\n\n    \/\/ make sure they aren't the same file\n    if ((codeExtension == null) && sourceFile.equals(destFile)) {\n      Base.showWarning(\"You can't fool me\",\n                       \"This file has already been copied to the\\n\" +\n                       \"location from which where you're trying to add it.\\n\" +\n                       \"I ain't not doin nuthin'.\", null);\n      return false;\n    }\n\n    \/\/ in case the user is \"adding\" the code in an attempt\n    \/\/ to update the sketch's tabs\n\tif (!sourceFile.equals(destFile)) {\n\t\tfinal File sourceFile2 = sourceFile;\n\t\tfinal File destFile2 = destFile;\n\t    \/\/ Create a new event dispatch thread- to display ProgressBar\n\t    \/\/ while Saving As\n    javax.swing.SwingUtilities.invokeLater(new Runnable() {\n      public void run() {\n        new ProgressFrame(sourceFile2, destFile2, editor);\n      }\n    });\n\t}\n\n    if (codeExtension != null) {\n      SketchCode newCode = new SketchCode(destFile, codeExtension);\n\n      if (replacement) {\n        replaceCode(newCode);\n\n      } else {\n        insertCode(newCode);\n        sortCode();\n      }\n      setCurrentCode(filename);\n      editor.header.repaint();\n      if (isUntitled()) {  \/\/ TODO probably not necessary? problematic?\n        \/\/ Mark the new code as modified so that the sketch is saved\n        current.setModified(true);\n      }\n\n    } else {\n      if (isUntitled()) {  \/\/ TODO probably not necessary? problematic?\n        \/\/ If a file has been added, mark the main code as modified so\n        \/\/ that the sketch is properly saved.\n        code[0].setModified(true);\n      }\n    }\n    return true;\n  }\n","new_comment_raw":"Add a file to the sketch.","old_comment_raw":"Add a file to the sketch.","label":0,"pre_label":1,"AST_level":13,"line_counts":119,"new_code_token_num":749},{"new_code_raw":"public final boolean hasValidResults() { return getLastAction() != null; }","old_code_raw":"    public final boolean hasValidResults() {\r\n        AbstractBuild<?, ?> build = getLastFinishedBuild();\r\n        if (build != null) {\r\n            BuildHistory history = new BuildHistory(build, resultActionType);\r\n\r\n            return history.hasPreviousResult();\r\n        }\r\n        return false;\r\n    }\r\n","new_comment_raw":"Returns whether this project has a valid result action attached.","old_comment_raw":"Returns whether we have enough valid results in order to draw a meaningful graph.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":15},{"new_code_raw":"protected String getExample(Schema schema) { if (schema.getExample() != null) { return schema.getExample().toString(); } else if (ModelUtils.isDateTimeSchema(schema)) { return \"2000-01-23T04:56:07.000Z\"; } else if (ModelUtils.isDateSchema(schema)) { return \"2000-01-23\"; } else if (ModelUtils.isBooleanSchema(schema)) { return \"true\"; } else if (ModelUtils.isNumberSchema(schema)) { if (ModelUtils.isFloatSchema(schema)) { \/\/ float return \"1.3579\"; } else { \/\/ double return \"3.149\"; } } else if (ModelUtils.isPasswordSchema(schema)) { return \"********\"; } else if (ModelUtils.isUUIDSchema(schema)) { return \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\"; \/\/ do these last in case the specific types above are derived from these classes } else if (ModelUtils.isStringSchema(schema)) { return \"aeiou\"; } else if (ModelUtils.isIntegerSchema(schema)) { if (ModelUtils.isLongSchema(schema)) { \/\/ long return \"123456789\"; } else { \/\/integer return \"123\"; } } else { LOGGER.debug(\"default example value not implemented for {}. Default to UNDEFINED_EXAMPLE_VALUE\", schema); return \"UNDEFINED_EXAMPLE_VALUE\"; } }","old_code_raw":"    protected String getExample(Property property) {\n        if (property.getExample() != null) {\n            return property.getExample().toString();\n        } else if (property instanceof DateTimeProperty) {\n            return \"2000-01-23T04:56:07.000Z\";\n        } else if (property instanceof DateProperty) {\n            return \"2000-01-23\";\n        } else if (property instanceof BooleanProperty) {\n            return \"true\";\n        } else if (property instanceof LongProperty) {\n            return \"123456789\";\n        } else if (property instanceof DoubleProperty) { \/\/ derived from DecimalProperty so make sure this is first\n            return \"3.149\";\n        }  else if (property instanceof DecimalProperty) {\n            return \"1.3579\";\n        } else if (property instanceof PasswordProperty) {\n            return \"********\";\n        } else if (property instanceof UUIDProperty) {\n            return \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\";\n        \/\/ do these last in case the specific types above are derived from these classes\n        } else if (property instanceof StringProperty) {\n            return \"aeiou\";\n        } else if (property instanceof BaseIntegerProperty) {\n            return \"123\";\n        } else if (property instanceof AbstractNumericProperty) {\n            return \"1.23\";\n        }\n        LOGGER.warn(\"default example value not implemented for \" + property);\n        return \"\";\n    }\n","new_comment_raw":"Get the example string value for the given schema.","old_comment_raw":"Get the example string value for the given Property.","label":1,"pre_label":0,"AST_level":16,"line_counts":34,"new_code_token_num":279},{"new_code_raw":"public static Set<ConfiguredClassHierarchy<EntityClass>> createEntityHierarchies(AnnotationBindingContext context) { ClassLoaderService classLoaderService = context.classLoaderService(); Map<ClassInfo, List<ClassInfo>> processedClassInfos = new HashMap<ClassInfo, List<ClassInfo>>(); for ( ClassInfo info : context.getIndex().getKnownClasses() ) { if ( !isEntityClass( info ) ) { continue; } if ( processedClassInfos.containsKey( info ) ) { continue; } List<ClassInfo> configuredClassList = new ArrayList<ClassInfo>(); ClassInfo tmpClassInfo = info; Class<?> clazz = classLoaderService.classForName( tmpClassInfo.toString() ); while ( clazz != null && !clazz.equals( Object.class ) ) { tmpClassInfo = context.getIndex().getClassByName( DotName.createSimple( clazz.getName() ) ); clazz = clazz.getSuperclass(); if ( tmpClassInfo == null ) { continue; } if ( existsHierarchyWithClassInfoAsLeaf( processedClassInfos, tmpClassInfo ) ) { List<ClassInfo> classInfoList = processedClassInfos.get( tmpClassInfo ); for ( ClassInfo tmpInfo : configuredClassList ) { classInfoList.add( tmpInfo ); processedClassInfos.put( tmpInfo, classInfoList ); } break; } else { configuredClassList.add( 0, tmpClassInfo ); processedClassInfos.put( tmpClassInfo, configuredClassList ); } } } Set<ConfiguredClassHierarchy<EntityClass>> hierarchies = new HashSet<ConfiguredClassHierarchy<EntityClass>>(); List<List<ClassInfo>> processedList = new ArrayList<List<ClassInfo>>(); for ( List<ClassInfo> classInfoList : processedClassInfos.values() ) { if ( !processedList.contains( classInfoList ) ) { hierarchies.add( ConfiguredClassHierarchy.createEntityClassHierarchy( classInfoList, context ) ); processedList.add( classInfoList ); } } return hierarchies; }","old_code_raw":"\tpublic static Set<ConfiguredClassHierarchy> createEntityHierarchies(Index index, ServiceRegistry serviceRegistry) {\n\t\tClassLoaderService classLoaderService = serviceRegistry.getService( ClassLoaderService.class );\n\t\tMap<ClassInfo, List<ClassInfo>> processedClassInfos = new HashMap<ClassInfo, List<ClassInfo>>();\n\n\t\tfor ( ClassInfo info : index.getKnownClasses() ) {\n\t\t\tif ( !isConfiguredClass( info ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( processedClassInfos.containsKey( info ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tList<ClassInfo> configuredClassList = new ArrayList<ClassInfo>();\n\t\t\tClassInfo tmpClassInfo = info;\n\t\t\tClass<?> clazz = classLoaderService.classForName( tmpClassInfo.toString() );\n\t\t\twhile ( clazz != null && !clazz.equals( Object.class ) ) {\n\t\t\t\ttmpClassInfo = index.getClassByName( DotName.createSimple( clazz.getName() ) );\n\t\t\t\tclazz = clazz.getSuperclass();\n\t\t\t\tif ( tmpClassInfo == null ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ( existsHierarchyWithClassInfoAsLeaf( processedClassInfos, tmpClassInfo ) ) {\n\t\t\t\t\tList<ClassInfo> classInfoList = processedClassInfos.get( tmpClassInfo );\n\t\t\t\t\tfor ( ClassInfo tmpInfo : configuredClassList ) {\n\t\t\t\t\t\tclassInfoList.add( tmpInfo );\n\t\t\t\t\t\tprocessedClassInfos.put( tmpInfo, classInfoList );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconfiguredClassList.add( 0, tmpClassInfo );\n\t\t\t\t\tprocessedClassInfos.put( tmpClassInfo, configuredClassList );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tAnnotationBindingContext context = new AnnotationBindingContext( index, serviceRegistry );\n\t\tSet<ConfiguredClassHierarchy> hierarchies = new HashSet<ConfiguredClassHierarchy>();\n\t\tList<List<ClassInfo>> processedList = new ArrayList<List<ClassInfo>>();\n\t\tfor ( List<ClassInfo> classInfoList : processedClassInfos.values() ) {\n\t\t\tif ( !processedList.contains( classInfoList ) ) {\n\t\t\t\thierarchies.add( ConfiguredClassHierarchy.create( classInfoList, context ) );\n\t\t\t\tprocessedList.add( classInfoList );\n\t\t\t}\n\t\t}\n\n\t\treturn hierarchies;\n\t}\n","new_comment_raw":"Pre-processes the annotated entities from the index and put them into a structure which can bound to the Hibernate metamodel.","old_comment_raw":"This methods pre-processes the annotated entities from the index and put them into a structure which can bound to the Hibernate metamodel.","label":1,"pre_label":0,"AST_level":13,"line_counts":50,"new_code_token_num":278},{"new_code_raw":"public static ActiveMQConnectionFactory createConnectionFactoryWithoutHA(JMSFactoryType jmsFactoryType, final TransportConfiguration... transportConfigurations) { ActiveMQConnectionFactory factory = null; if (jmsFactoryType.equals(JMSFactoryType.CF)) { factory = new ActiveMQJMSConnectionFactory(false, transportConfigurations); } else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_CF)) { factory = new ActiveMQQueueConnectionFactory(false, transportConfigurations); } else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_CF)) { factory = new ActiveMQTopicConnectionFactory(false, transportConfigurations); } else if (jmsFactoryType.equals(JMSFactoryType.XA_CF)) { factory = new ActiveMQXAConnectionFactory(false, transportConfigurations); } else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_XA_CF)) { factory = new ActiveMQXAQueueConnectionFactory(false, transportConfigurations); } else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_XA_CF)) { factory = new ActiveMQXATopicConnectionFactory(false, transportConfigurations); } return factory; }","old_code_raw":"   public static HornetQConnectionFactory createConnectionFactoryWithoutHA(JMSFactoryType jmsFactoryType, final TransportConfiguration... transportConfigurations)\n   {\n      HornetQConnectionFactory factory = null;\n      if (jmsFactoryType.equals(JMSFactoryType.CF))\n      {\n         factory = new HornetQJMSConnectionFactory(false, transportConfigurations);\n      }\n      else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_CF))\n      {\n         factory = new HornetQQueueConnectionFactory(false, transportConfigurations);\n      }\n      else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_CF))\n      {\n         factory = new HornetQTopicConnectionFactory(false, transportConfigurations);\n      }\n      else if (jmsFactoryType.equals(JMSFactoryType.XA_CF))\n      {\n         factory = new HornetQXAConnectionFactory(false, transportConfigurations);\n      }\n      else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_XA_CF))\n      {\n         factory = new HornetQXAQueueConnectionFactory(false, transportConfigurations);\n      }\n      else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_XA_CF))\n      {\n         factory = new HornetQXATopicConnectionFactory(false, transportConfigurations);\n      }\n\n      return factory;\n   }\n","new_comment_raw":"Create a ActiveMQConnectionFactory which creates session factories using a static list of transportConfigurations.","old_comment_raw":"Create a HornetQConnectionFactory which creates session factories using a static list of transportConfigurations.","label":1,"pre_label":0,"AST_level":13,"line_counts":32,"new_code_token_num":146},{"new_code_raw":"public boolean isLocked() { \/\/ check if locked by current process if (locked.get()) { return true; } \/\/ check if locked by other process if (!lock.exists()) { return false; } long now = System.currentTimeMillis(); long tsp = read(); LOG.trace(\"Lock timestamp {} now {} for {}\", tsp, now, webcam); if (tsp > now - INTERVAL * 2) { return true; } return false; }","old_code_raw":"\tpublic boolean isLocked() {\n\n\t\t\/\/ check if locked by current process\n\n\t\tif (locked.get()) {\n\t\t\treturn true;\n\t\t}\n\n\t\t\/\/ check if locked by other process\n\n\t\tlong tsp = PREFS.getLong(webcam.getName(), -1);\n\t\tlong now = System.currentTimeMillis();\n\n\t\tLOG.trace(\"Lock timestamp {} now {} for \", tsp, now, webcam);\n\n\t\tif (tsp > now - INTERVAL * 2) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n","new_comment_raw":"Check if webcam is locked.","old_comment_raw":"Check if webcam is locked.","label":0,"pre_label":1,"AST_level":7,"line_counts":26,"new_code_token_num":101},{"new_code_raw":"public static boolean isSameScriptEngine(String name, String engineName, String engineLanguage) { if (name == null) { return false; } \/\/ In the configs we just use the engine name, in the UI we use the language name as well if (name.indexOf(LANG_ENGINE_SEP) > 0) { if (name.equals(engineLanguage + LANG_ENGINE_SEP + engineName)) { return true; } return false; } return name.equals(engineName); }","old_code_raw":"\tpublic static boolean isSameScriptEngine(String name, String engineName, String engineLanguage) {\n\t\tif (name == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\t\/\/ In the configs we just use the engine name, in the UI we use the language name as well\n\t\tif (name.indexOf(LANG_ENGINE_SEP) > 0) {\n\t\t\tif (name.equals(engineLanguage + LANG_ENGINE_SEP + engineName)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tif (name.equals(engineName)) {\n\t\t\treturn true;\n\t\t}\n\n\t\t\/\/ Nasty, but sometime the engine names are reported differently, eg 'Mozilla Rhino' vs 'Rhino'\n\t\tif (name.endsWith(engineName)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (engineName.endsWith(name)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n","new_comment_raw":"Tells whether or not the given  name matches the given  engineName and  engineLanguage.","old_comment_raw":"Tells whether or not the given name matches the given engineName and engineLanguage.","label":0,"pre_label":1,"AST_level":9,"line_counts":16,"new_code_token_num":86},{"new_code_raw":"private Object createConversationID() { if (getConversationID() != null) { return getConversationID(); } else { return UUID.randomUUID().toString(); } }","old_code_raw":"    private Object createConversationID() {\n        if (conversationID == null) {\n            return UUID.randomUUID().toString();\n        }\n        return conversationID;\n    }\n","new_comment_raw":"Creates a new conversation id","old_comment_raw":"Creates a new conversational id","label":1,"pre_label":0,"AST_level":7,"line_counts":9,"new_code_token_num":34},{"new_code_raw":"private ObjectAnimator createNullAnimator(ImageView imageView) { return AnimatorUtils.ofObject(createMatrixProperty(imageView), new MatrixUtils.NullMatrixEvaluator(), MatrixUtils.IDENTITY_MATRIX, MatrixUtils.IDENTITY_MATRIX); }","old_code_raw":"    private ObjectAnimator createNullAnimator(ImageView imageView) {\n        return AnimatorUtils.ofObject(new ImageAnimator(imageView),\n                new MatrixUtils.NullMatrixEvaluator(),\n                MatrixUtils.IDENTITY_MATRIX, MatrixUtils.IDENTITY_MATRIX);\n    }\n","new_comment_raw":"Creates an Animator for ImageViews moving, changing dimensions, and\/or changing  android.widget.ImageView.ScaleType.","old_comment_raw":"Creates an Animator for ImageViews moving, changing dimensions, and\/or changing android.widget.ImageView.ScaleType.","label":0,"pre_label":1,"AST_level":7,"line_counts":6,"new_code_token_num":31},{"new_code_raw":"public static String getId( final Widget widget ) { \/\/ TODO [rh] consider overriding the id when Widget#setData is called \/\/ - safer 1: in case someone tries to obtain id directly from addapter \/\/ - safer 2: changing the id after widget was initialized could be \/\/ detected and prevented \/\/ - less memory: new HashMap created per widget to hold the id \/\/ - illegal id's could be rejected immediately (close to error source) \/\/ - faster (?): only \"return getAdapter( widget ).getId();\" in here String result = ( String )widget.getData( CUSTOM_WIDGET_ID ); if( result == null ) { result = getAdapter( widget ).getId(); } return result; }","old_code_raw":"  public static String getId( final Widget widget ) {\n    return getAdapter( widget ).getId();\n  }\n","new_comment_raw":"Returns the id of the given widget that is used to identify the widget on the client.","old_comment_raw":"Returns the id of the widget that is used to identify the widget on the client.","label":1,"pre_label":0,"AST_level":8,"line_counts":16,"new_code_token_num":147},{"new_code_raw":"public Node parseXML(String text, Document doc) { return null; }","old_code_raw":"        public DocumentFragment parseXML(String text, Document doc) {\n            return null;\n        }\n","new_comment_raw":"Parses the given XML string into a DocumentFragment of the given document or a new document if 'doc' is null.","old_comment_raw":"Parses the given XML string into a DocumentFragment of the given document.","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":15},{"new_code_raw":"public ParameterList getQueryStringParams() { try { ParameterList result = new ParameterList(); String queryString = new URL(url).getQuery(); result.addQuerystring(queryString); result.addAll(querystringParams); return result; } catch (MalformedURLException mue) { throw new OAuthException(\"Malformed URL\", mue); } }","old_code_raw":"  public Map<String, String> getQueryStringParams()\n  {\n    try\n    {\n      Map<String, String> params = new HashMap<String, String>();\n      String queryString = new URL(url).getQuery();\n      params.putAll(MapUtils.queryStringToMap(queryString));\n      params.putAll(this.querystringParams);\n      return params;\n    }\n    catch (MalformedURLException mue)\n    {\n      throw new OAuthException(\"Malformed URL\", mue);\n    }\n  }\n","new_comment_raw":"Get a  ParameterList with the query string parameters.","old_comment_raw":"Get a Map of the query string parameters.","label":1,"pre_label":0,"AST_level":7,"line_counts":17,"new_code_token_num":62},{"new_code_raw":"private Bitmap getWidgetPreview(AppWidgetProviderInfo info) { final PackageManager packageManager = mPackageManager; String packageName = info.provider.getPackageName(); Drawable drawable = null; if (info.previewImage != 0) { drawable = packageManager.getDrawable(packageName, info.previewImage, null); if (drawable == null) { Log.w(TAG, \"Can't load icon drawable 0x\" + Integer.toHexString(info.icon) + \" for provider: \" + info.provider); } } \/\/ If we don't have a preview image, create a default one if (drawable == null) { Resources resources = mLauncher.getResources(); \/\/ Create a new bitmap to hold the widget preview int width = (int) (Math.max(mMinWidgetPreviewDim, Math.min(mMaxWidgetPreviewDim, info.minWidth)) * sScaleFactor); int height = (int) (Math.max(mMinWidgetPreviewDim, Math.min(mMaxWidgetPreviewDim, info.minHeight)) * sScaleFactor); final Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888); final Drawable background = resources.getDrawable(R.drawable.default_widget_preview); renderDrawableToBitmap(background, bitmap, 0, 0, width, height, 1.0f, 1.0f); \/\/ Draw the icon flush left try { Drawable icon = null; if (info.icon > 0) { icon = packageManager.getDrawable(packageName, info.icon, null); } if (icon == null) { icon = resources.getDrawable(R.drawable.ic_launcher_application); } final int iconSize = mMinWidgetPreviewDim \/ 2; final int offset = iconSize \/ 4; renderDrawableToBitmap(icon, null, offset, offset, iconSize, iconSize, 1.0f, 1.0f); } catch (Resources.NotFoundException e) { \/\/ if we can't find the icon, then just don't draw it } return bitmap; } else { \/\/ Scale down the preview if necessary final float imageWidth = drawable.getIntrinsicWidth(); final float imageHeight = drawable.getIntrinsicHeight(); final float aspect = (float) imageWidth \/ imageHeight; final int scaledWidth = (int) (Math.max(mMinWidgetPreviewDim, Math.min(mMaxWidgetPreviewDim, imageWidth)) * sScaleFactor); final int scaledHeight = (int) (Math.max(mMinWidgetPreviewDim, Math.min(mMaxWidgetPreviewDim, imageHeight)) * sScaleFactor); int width; int height; if (aspect >= 1.0f) { width = scaledWidth; height = (int) (((float) scaledWidth \/ imageWidth) * imageHeight); } else { height = scaledHeight; width = (int) (((float) scaledHeight \/ imageHeight) * imageWidth); } final Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888); renderDrawableToBitmap(drawable, bitmap, 0, 0, width, height, 1.0f, 1.0f); return bitmap; } }","old_code_raw":"    private FastBitmapDrawable getWidgetPreview(AppWidgetProviderInfo info) {\n        final PackageManager packageManager = mPackageManager;\n        String packageName = info.provider.getPackageName();\n        Drawable drawable = null;\n        FastBitmapDrawable newDrawable = null;\n        if (info.previewImage != 0) {\n            drawable = packageManager.getDrawable(packageName, info.previewImage, null);\n            if (drawable == null) {\n                Log.w(TAG, \"Can't load icon drawable 0x\" + Integer.toHexString(info.icon)\n                        + \" for provider: \" + info.provider);\n            }\n        }\n\n        \/\/ If we don't have a preview image, create a default one\n        final int minDim = mWorkspaceWidgetLayout.estimateCellWidth(1);\n        final int maxDim = mWorkspaceWidgetLayout.estimateCellWidth(3);\n        if (drawable == null) {\n            Resources resources = mLauncher.getResources();\n\n            \/\/ Create a new bitmap to hold the widget preview\n            int width = (int) (Math.max(minDim, Math.min(maxDim, info.minWidth)) * sScaleFactor);\n            int height = (int) (Math.max(minDim, Math.min(maxDim, info.minHeight)) * sScaleFactor);\n            final Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888);\n            final Drawable background = resources.getDrawable(R.drawable.default_widget_preview);\n            renderDrawableToBitmap(background, bitmap, 0, 0, width, height, 1.0f, 1.0f);\n\n            \/\/ Draw the icon flush left\n            try {\n                Drawable icon = null;\n                if (info.icon > 0) {\n                    icon = packageManager.getDrawable(packageName, info.icon, null);\n                }\n                if (icon == null) {\n                    icon = resources.getDrawable(R.drawable.ic_launcher_application);\n                }\n\n                final int iconSize = minDim \/ 2;\n                final int offset = iconSize \/ 4;\n                renderDrawableToBitmap(icon, null, offset, offset, iconSize, iconSize, 1.0f, 1.0f);\n            } catch (Resources.NotFoundException e) {\n                \/\/ if we can't find the icon, then just don't draw it\n            }\n\n            newDrawable = new FastBitmapDrawable(bitmap);\n        } else {\n            \/\/ Scale down the preview if necessary\n            final float imageWidth = drawable.getIntrinsicWidth();\n            final float imageHeight = drawable.getIntrinsicHeight();\n            final float aspect = (float) imageWidth \/ imageHeight;\n            final int scaledWidth =\n                (int) (Math.max(minDim, Math.min(maxDim, imageWidth)) * sScaleFactor);\n            final int scaledHeight =\n                (int) (Math.max(minDim, Math.min(maxDim, imageHeight)) * sScaleFactor);\n            int width;\n            int height;\n            if (aspect >= 1.0f) {\n                width = scaledWidth;\n                height = (int) (((float) scaledWidth \/ imageWidth) * imageHeight);\n            } else {\n                height = scaledHeight;\n                width = (int) (((float) scaledHeight \/ imageHeight) * imageWidth);\n            }\n\n            final Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888);\n            renderDrawableToBitmap(drawable, bitmap, 0, 0, width, height, 1.0f, 1.0f);\n\n            newDrawable = new FastBitmapDrawable(bitmap);\n        }\n        newDrawable.setBounds(0, 0, newDrawable.getIntrinsicWidth(),\n                newDrawable.getIntrinsicHeight());\n        return newDrawable;\n    }\n","new_comment_raw":"This method will extract the preview image specified by the widget developer (if it exists), otherwise, it will try to generate a default image preview with the widget's package icon.","old_comment_raw":"This method will extract the preview image specified by the widget developer (if it exists), otherwise, it will try to generate a default image preview with the widget's package icon.","label":0,"pre_label":1,"AST_level":13,"line_counts":69,"new_code_token_num":515},{"new_code_raw":"public final int getBeginColumn() { return this.bufcolumn[this.tokenBegin]; }","old_code_raw":"    public final int getBeginColumn() {\n        return bufcolumn[tokenBegin];\n    }\n","new_comment_raw":"Get the column begin","old_comment_raw":"DOCUMENT ME!","label":1,"pre_label":0,"AST_level":7,"line_counts":5,"new_code_token_num":16},{"new_code_raw":"private String checkSubElementsNullability(Type propertyType, Object value) throws HibernateException { if ( propertyType.isComponentType() ) { return checkComponentNullability( value, (CompositeType) propertyType ); } if ( propertyType.isCollectionType() ) { \/\/ persistent collections may have components final CollectionType collectionType = (CollectionType) propertyType; final Type collectionElementType = collectionType.getElementType( session.getFactory() ); if ( collectionElementType.isComponentType() ) { \/\/ check for all components values in the collection final CompositeType componentType = (CompositeType) collectionElementType; final Iterator itr = CascadingActions.getLoadedElementsIterator( session, collectionType, value ); while ( itr.hasNext() ) { final Object compositeElement = itr.next(); if ( compositeElement != null ) { return checkComponentNullability( compositeElement, componentType ); } } } } return null; }","old_code_raw":"\tprivate String checkSubElementsNullability(Type propertyType, Object value) throws HibernateException {\n\t\t\/\/ IMPL NOTE : we currently skip checking \"any\" and \"many to any\" mappings.  This is not the best solution.\n\t\t\/\/\n\t\t\/\/ The problem I ran into with performing the checks on \"any\" and \"many to any\" mappings had to do  with\n\t\t\/\/ cascaded saves of transient associated entities not yet having assigned the identifier (this was\n\t\t\/\/ specifically in the \"many to any\" case).\n\n\t\tif ( propertyType.isAnyType() ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( propertyType.isComponentType() ) {\n\t\t\treturn checkComponentNullability( value, (CompositeType) propertyType );\n\t\t}\n\n\t\tif ( propertyType.isCollectionType() ) {\n\t\t\t\/\/persistent collections may have components\n\t\t\tfinal CollectionType collectionType = (CollectionType) propertyType;\n\t\t\tfinal Type collectionElementType = collectionType.getElementType( session.getFactory() );\n\n\t\t\tif ( collectionElementType.isAnyType() ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( collectionElementType.isComponentType() ) {\n\t\t\t\t\/\/check for all components values in the collection\n\t\t\t\tfinal CompositeType componentType = (CompositeType) collectionElementType;\n\t\t\t\tfinal Iterator itr = CascadingActions.getLoadedElementsIterator( session, collectionType, value );\n\t\t\t\twhile ( itr.hasNext() ) {\n\t\t\t\t\tfinal Object compValue = itr.next();\n\t\t\t\t\tif ( compValue != null ) {\n\t\t\t\t\t\treturn checkComponentNullability( compValue, componentType );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n","new_comment_raw":"check sub elements-nullability.","old_comment_raw":"check sub elements-nullability.","label":0,"pre_label":1,"AST_level":13,"line_counts":26,"new_code_token_num":146},{"new_code_raw":"public static String getProgramFilesPath() { return getEnvVarPath(\"ProgramFiles\", \"C:\\\\Program Files\"); }","old_code_raw":"  public static String getProgramFilesPath() {\n    loadEnvironment();\n    String pf = getEnvVarIgnoreCase(\"ProgramFiles\");\n    if (pf != null) {\n      File ProgramFiles = new File(pf);\n      if (ProgramFiles.exists()) {\n        return ProgramFiles.getAbsolutePath();\n      }\n    }\n    return new File(\"C:\\\\Program Files\").getAbsolutePath();\n  }\n","new_comment_raw":"Returns the path to the Windows Program Files.","old_comment_raw":"Returns the path to the Windows Program Files.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":25},{"new_code_raw":"public boolean undoChanges(Object savedState) { if (savedState instanceof SavedState) { if (((SavedState)savedState).revertState(this)) { iSavedState = savedState; return true; } } return false; }","old_code_raw":"    public boolean undoChanges(Object savedState) {\n        if (savedState instanceof SavedState) {\n            return ((SavedState)savedState).revertState(this);\n        }\n        return false;\n    }\n","new_comment_raw":"Undos any changes that were made to this bucket since the given state was saved.","old_comment_raw":"Undos any changes that were made to this bucket since the given state was saved.","label":0,"pre_label":1,"AST_level":9,"line_counts":10,"new_code_token_num":41},{"new_code_raw":"public Integer[] getVersions() { return vers; }","old_code_raw":"    public Integer[] getVersions() {\n        return versions.keySet().toArray(new Integer[versions.keySet().size()]);\n    }\n","new_comment_raw":"Get an array for all available versions (sorted)","old_comment_raw":"Get an iterator for all available versions","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":12},{"new_code_raw":"public static Predicate<Connectivity> hasType(final int... types) { final int[] extendedTypes = appendUnknownNetworkTypeToTypes(types); return new Predicate<Connectivity>() { @Override public boolean test(@NonNull Connectivity connectivity) throws Exception { for (int type : extendedTypes) { if (connectivity.type() == type) { return true; } } return false; } }; }","old_code_raw":"  public static Predicate<Connectivity> hasType(final int... types) {\n    final int[] extendedTypes = appendUnknownNetworkTypeToTypes(types);\n    return new Predicate<Connectivity>() {\n      @Override public boolean test(@NonNull Connectivity connectivity) throws Exception {\n        for (int type : extendedTypes) {\n          if (connectivity.getType() == type) {\n            return true;\n          }\n        }\n        return false;\n      }\n    };\n  }\n","new_comment_raw":"Filter, which returns true if at least one given type occurred","old_comment_raw":"Filter, which returns true if at least one given type occurred","label":0,"pre_label":1,"AST_level":11,"line_counts":14,"new_code_token_num":71},{"new_code_raw":"public Symbol generate(Schema sc, Map<LitS, Symbol> seen) { switch (sc.getType()) { case NULL: case BOOLEAN: case INT: case LONG: case FLOAT: case DOUBLE: case STRING: case BYTES: case FIXED: case UNION: return super.generate(sc, seen); case ENUM: return Symbol.seq(new Symbol.EnumLabelsAction(sc.getEnumSymbols()), Symbol.ENUM); case ARRAY: return Symbol.seq(Symbol.repeat(Symbol.ARRAY_END, Symbol.ITEM_END, generate(sc.getElementType(), seen)), Symbol.ARRAY_START); case MAP: return Symbol.seq(Symbol.repeat(Symbol.MAP_END, Symbol.ITEM_END, generate(sc.getValueType(), seen), Symbol.MAP_KEY_MARKER, Symbol.STRING), Symbol.MAP_START); case RECORD: { LitS wsc = new LitS(sc); Symbol rresult = seen.get(wsc); if (rresult == null) { Symbol[] production = new Symbol[sc.getFields().size() * 2 + 2]; rresult = Symbol.seq(production); seen.put(wsc, rresult); int i = production.length; int n = 0; production[--i] = Symbol.RECORD_START; for (Map.Entry<String, Field> f : sc.getFields().entrySet()) { production[--i] = new Symbol.FieldAdjustAction(n, f.getKey()); production[--i] = generate(f.getValue().schema(), seen); n++; } production[--i] = Symbol.RECORD_END; } return rresult; } default: throw new RuntimeException(\"Unexpected schema type\"); } }","old_code_raw":"  public Symbol generate(Schema sc, Map<LitS, Symbol> seen) {\n    switch (sc.getType()) {\n    case NULL:\n    case BOOLEAN:\n    case INT:\n    case LONG:\n    case FLOAT:\n    case DOUBLE:\n    case STRING:\n    case BYTES:\n    case FIXED:\n    case UNION:\n      return super.generate(sc, seen);\n    case ENUM:\n      return Symbol.seq(new Symbol.EnumLabelsAction(sc.getEnumSymbols()),\n          Symbol.ENUM);\n    case ARRAY:\n      return Symbol.seq(Symbol.ARRAY_END,\n          Symbol.repeat(Symbol.ARRAY_END,\n              Symbol.ITEM_END, generate(sc.getElementType(), seen)),\n          Symbol.ARRAY_START);\n    case MAP:\n      return Symbol.seq(Symbol.MAP_END,\n          Symbol.repeat(Symbol.MAP_END,\n              Symbol.ITEM_END, generate(sc.getValueType(), seen),\n              Symbol.MAP_KEY_MARKER, Symbol.STRING),\n          Symbol.MAP_START);\n    case RECORD: {\n      LitS wsc = new LitS(sc);\n      Symbol rresult = seen.get(wsc);\n      if (rresult == null) {\n        Symbol[] production = new Symbol[sc.getFields().size() * 2 + 2];\n        rresult = Symbol.seq(production);\n        seen.put(wsc, rresult);\n\n        int i = production.length;\n        int n = 0;\n        production[--i] = Symbol.RECORD_START;\n        for (Map.Entry<String, Field> f : sc.getFields().entrySet()) {\n          production[--i] = new Symbol.FieldAdjustAction(n, f.getKey());\n          production[--i] = generate(f.getValue().schema(), seen);\n          n++;\n        }\n        production[--i] = Symbol.RECORD_END;\n      }\n      return rresult;\n    }\n    default:\n      throw new RuntimeException(\"Unexpected schema type\");\n    }\n  }\n","new_comment_raw":"Returns the non-terminal that is the start symbol for grammar of the given schema sc.","old_comment_raw":"Returns the non-terminal that is the start symbol for grammar of the given schema sc.","label":0,"pre_label":1,"AST_level":14,"line_counts":50,"new_code_token_num":318},{"new_code_raw":"public static MemberID parse(String memberID, boolean isClassMember) { return parse(memberID, isClassMember, null); }","old_code_raw":"    public static MemberID parse(String signature, boolean isClassMember) {\n        return parse(signature, isClassMember, null);\n    }\n","new_comment_raw":"Parse a member ID, with or without classname, with or without descriptor.","old_comment_raw":"Parse a signature, with or without classname, with or without descriptor.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":23},{"new_code_raw":"public static MailboxMessage<HBaseId> messageMetaFromResult(Configuration conf, Result result) { HBaseMailboxMessage message = null; Flags flags = new Flags(); List<Property> propList = new ArrayList<Property>(); KeyValue[] keys = result.raw(); String mediaType = null, subType = null; Long modSeq = null, uid, bodyOctets = null, contentOctets = null, textualLineCount = null; Date internalDate = null; int i = 0; \/** it is VERY IMPORTANT that the byte arrays are kept ascending *\/ if (Bytes.equals(keys[i].getQualifier(), MESSAGE_BODY_OCTETS)) { bodyOctets = Bytes.toLong(keys[i].getValue()); i++; } if (Bytes.equals(keys[i].getQualifier(), MESSAGE_CONTENT_OCTETS)) { contentOctets = Bytes.toLong(keys[i].getValue()); i++; } if (Bytes.equals(keys[i].getQualifier(), MESSAGE_INTERNALDATE)) { internalDate = new Date(Bytes.toLong(keys[i].getValue())); i++; } \/\/ may be null so it will probably skip if (Bytes.equals(keys[i].getQualifier(), MESSAGE_TEXT_LINE_COUNT)) { textualLineCount = Bytes.toLong(keys[i].getValue()); i++; } if (Bytes.equals(keys[i].getQualifier(), MESSAGE_MODSEQ)) { modSeq = Bytes.toLong(keys[i].getValue()); i++; } if (Bytes.equals(keys[i].getQualifier(), MESSAGE_MEDIA_TYPE)) { mediaType = Bytes.toString(keys[i].getValue()); i++; } if (Bytes.equals(keys[i].getQualifier(), MESSAGE_SUB_TYPE)) { subType = Bytes.toString(keys[i].getValue()); i++; } \/\/ only TEXT_LINE_COUNT can be missing if message is binary if (i < 5) { throw new RuntimeException(\"HBase message column names not sorted.\"); } while (i < keys.length) { \/\/get message properties if (Bytes.startsWith(keys[i].getQualifier(), PREFIX_PROP_B)) { propList.add(getProperty(keys[i].getValue())); } else if (Bytes.startsWith(keys[i].getQualifier(), PREFIX_SFLAGS_B)) { \/\/ get system flags, stored as qualifiers if (Bytes.equals(MARKER_PRESENT, keys[i].getValue())) { flags.add(systemFlagFromBytes(keys[i].getQualifier())); } } else if (Bytes.startsWith(keys[i].getQualifier(), PREFIX_UFLAGS_B)) { \/\/ get user flags, stored as value qualifier flags.add(userFlagFromBytes(keys[i].getQualifier())); } i++; } HBaseId uuid = HBaseIdFromRowKey(result.getRow()); uid = Long.MAX_VALUE - Bytes.toLong(result.getRow(), 16); PropertyBuilder props = new PropertyBuilder(propList); props.setMediaType(mediaType); props.setSubType(subType); message = new HBaseMailboxMessage(conf, uuid, internalDate, flags, contentOctets, (int) (contentOctets - bodyOctets), props); message.setUid(uid); message.setModSeq(modSeq); message.setTextualLineCount(textualLineCount); return message; }","old_code_raw":"    public static Message<HBaseId> messageMetaFromResult(Configuration conf, Result result) {\n        HBaseMessage message = null;\n        Flags flags = new Flags();\n        List<Property> propList = new ArrayList<Property>();\n        KeyValue[] keys = result.raw();\n        String mediaType = null, subType = null;\n        Long modSeq = null, uid, bodyOctets = null, contentOctets = null, textualLineCount = null;\n        Date internalDate = null;\n\n        int i = 0;\n        \/** it is VERY IMPORTANT that the byte arrays are kept ascending *\/\n        if (Bytes.equals(keys[i].getQualifier(), MESSAGE_BODY_OCTETS)) {\n            bodyOctets = Bytes.toLong(keys[i].getValue());\n            i++;\n        }\n        if (Bytes.equals(keys[i].getQualifier(), MESSAGE_CONTENT_OCTETS)) {\n            contentOctets = Bytes.toLong(keys[i].getValue());\n            i++;\n        }\n        if (Bytes.equals(keys[i].getQualifier(), MESSAGE_INTERNALDATE)) {\n            internalDate = new Date(Bytes.toLong(keys[i].getValue()));\n            i++;\n        }\n        \/\/ may be null so it will probably skip\n        if (Bytes.equals(keys[i].getQualifier(), MESSAGE_TEXT_LINE_COUNT)) {\n            textualLineCount = Bytes.toLong(keys[i].getValue());\n            i++;\n        }\n\n        if (Bytes.equals(keys[i].getQualifier(), MESSAGE_MODSEQ)) {\n            modSeq = Bytes.toLong(keys[i].getValue());\n            i++;\n        }\n        if (Bytes.equals(keys[i].getQualifier(), MESSAGE_MEDIA_TYPE)) {\n            mediaType = Bytes.toString(keys[i].getValue());\n            i++;\n        }\n        if (Bytes.equals(keys[i].getQualifier(), MESSAGE_SUB_TYPE)) {\n            subType = Bytes.toString(keys[i].getValue());\n            i++;\n        }\n        \/\/ only TEXT_LINE_COUNT can be missing if message is binary\n        if (i < 5) {\n            throw new RuntimeException(\"HBase message column names not sorted.\");\n        }\n        while (i < keys.length) {\n            \/\/get message properties\n            if (Bytes.startsWith(keys[i].getQualifier(), PREFIX_PROP_B)) {\n                propList.add(getProperty(keys[i].getValue()));\n            } else if (Bytes.startsWith(keys[i].getQualifier(), PREFIX_SFLAGS_B)) {\n                \/\/ get system flags, stored as qualifiers\n                if (Bytes.equals(MARKER_PRESENT, keys[i].getValue())) {\n                    flags.add(systemFlagFromBytes(keys[i].getQualifier()));\n                }\n            } else if (Bytes.startsWith(keys[i].getQualifier(), PREFIX_UFLAGS_B)) {\n                \/\/ get user flags, stored as value qualifier\n                flags.add(userFlagFromBytes(keys[i].getQualifier()));\n            }\n            i++;\n        }\n        HBaseId uuid = HBaseIdFromRowKey(result.getRow());\n        uid = Long.MAX_VALUE - Bytes.toLong(result.getRow(), 16);\n        PropertyBuilder props = new PropertyBuilder(propList);\n        props.setMediaType(mediaType);\n        props.setSubType(subType);\n        message = new HBaseMessage(conf, uuid, internalDate, flags, contentOctets, (int) (contentOctets - bodyOctets), props);\n        message.setUid(uid);\n        message.setModSeq(modSeq);\n        message.setTextualLineCount(textualLineCount);\n        return message;\n    }\n","new_comment_raw":"Creates a HBaseMailboxMessage from a Result object.","old_comment_raw":"Creates a HBaseMessage from a Result object.","label":1,"pre_label":0,"AST_level":15,"line_counts":73,"new_code_token_num":627},{"new_code_raw":"public int copyMatchingMessages(ConnectionContext context, MessageReferenceFilter filter, ActiveMQDestination dest, int maximumMessages) throws Exception { int movedCounter = 0; int count = 0; List<MessageReference> list = null; do { pageInMessages(); synchronized (pagedInMessages) { list = new ArrayList<MessageReference>(pagedInMessages.values()); } for (MessageReference ref : list) { IndirectMessageReference r = (IndirectMessageReference) ref; if (filter.evaluate(context, r)) { \/\/ We should only copy messages that can be locked. if (lockMessage(r)) { r.incrementReferenceCount(); try { Message m = r.getMessage(); BrokerSupport.resend(context, m, dest); if (++movedCounter >= maximumMessages && maximumMessages > 0) { return movedCounter; } } finally { r.decrementReferenceCount(); } } } count++; } } while (count < this.destinationStatistics.getMessages().getCount()); return movedCounter; }","old_code_raw":"    public int copyMatchingMessages(ConnectionContext context, MessageReferenceFilter filter, ActiveMQDestination dest, int maximumMessages) throws Exception {\n        pageInMessages();\n        int counter = 0;\n        synchronized (pagedInMessages) {\n            for (Iterator<MessageReference> i = pagedInMessages.iterator(); i.hasNext();) {\n                MessageReference r = i.next();\n                if (filter.evaluate(context, r)) {\n                    r.incrementReferenceCount();\n                    try {\n                        Message m = r.getMessage();\n                        BrokerSupport.resend(context, m, dest);\n                        if (++counter >= maximumMessages && maximumMessages > 0) {\n                            break;\n                        }\n                    } finally {\n                        r.decrementReferenceCount();\n                    }\n                }\n            }\n        }\n        return counter;\n    }\n","new_comment_raw":"Copies the messages matching the given filter up to the maximum number of matched messages","old_comment_raw":"Copies the messages matching the given filter up to the maximum number of matched messages","label":0,"pre_label":1,"AST_level":15,"line_counts":33,"new_code_token_num":174},{"new_code_raw":"private boolean searchForToggleButton(String regex, int matches) { sleeper.sleep(); inst.waitForIdleSync(); Pattern p = Pattern.compile(regex); Matcher matcher; ArrayList<ToggleButton> toggleButtonList = viewFetcher.getCurrentViews(ToggleButton.class); if(matches == 0) matches = 1; for(ToggleButton toggleButton : toggleButtonList){ matcher = p.matcher(toggleButton.getText().toString()); if(matcher.find()){ countMatches++; } if (countMatches == matches) { countMatches=0; return true; } } if (scroller.scroll(Scroller.Direction.DOWN)) { return searchForToggleButton(regex, matches); } else { if(countMatches > 0) Log.d(LOG_TAG, \" There are only \" + countMatches + \" matches of \" + regex); countMatches = 0; return false; } }","old_code_raw":"\tprivate boolean searchForToggleButton(String search, int matches) {\n\t\tsleeper.sleep();\n\t\tinst.waitForIdleSync();\n\t\tPattern p = Pattern.compile(search);\n\t\tMatcher matcher;\n\t\tArrayList<ToggleButton> toggleButtonList = viewFetcher.getCurrentViews(ToggleButton.class);\n\t\tif(matches == 0)\n\t\t\tmatches = 1;\n\t\tfor(ToggleButton toggleButton : toggleButtonList){\n\t\t\tmatcher = p.matcher(toggleButton.getText().toString());\n\t\t\tif(matcher.find()){\t\n\t\t\t\tcountMatches++;\n\t\t\t}\n\t\t\tif (countMatches == matches) {\n\t\t\t\tcountMatches=0;\n\t\t\t\treturn true;\n\t\t\t} \n\t\t}\n\n\t\tif (scroller.scroll(Scroller.Direction.DOWN))\n\t\t{\n\t\t\treturn searchForToggleButton(search, matches);\n\t\t} else {\n\t\t\tif(countMatches > 0)\n\t\t\t\tLog.d(LOG_TAG, \" There are only \" + countMatches + \" matches of \" + search);\n\t\t\tcountMatches = 0;\n\t\t\treturn false;\n\t\t}\n\t\t\n\t}\n","new_comment_raw":"Searches for a toggle button with the given regex string and returns true if the searched toggle button is found a given number of times","old_comment_raw":"Searches for a toggle button with the given search string and returns true if the searched toggle button is found a given number of times","label":1,"pre_label":0,"AST_level":11,"line_counts":31,"new_code_token_num":154},{"new_code_raw":"public Client call123testSpecialTags(Client body) throws ApiException { Object localVarPostBody = body; \/\/ verify the required parameter 'body' is set if (body == null) { throw new ApiException(400, \"Missing the required parameter 'body' when calling call123testSpecialTags\"); } \/\/ create path and map variables String localVarPath = \"\/another-fake\/dummy\"; \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, String> localVarCookieParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { \"application\/json\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { \"application\/json\" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Client> localVarReturnType = new GenericType<Client>() {}; return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public Client call123testSpecialTags(Client body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    \/\/ verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling call123testSpecialTags\");\n    }\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/another-fake\/dummy\";\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application\/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application\/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"To test special tags","old_comment_raw":"To test special tags","label":0,"pre_label":1,"AST_level":8,"line_counts":38,"new_code_token_num":229},{"new_code_raw":"private int invoke_calculateBufferSize(int tdsVersion, int packetSize) { Class[] classes = new Class[]{int.class, int.class}; Object[] objects = new Object[]{new Integer(tdsVersion), new Integer(packetSize)}; return ((Integer) invokeStaticMethod(Support.class, \"calculateNamedPipeBufferSize\", classes, objects)).intValue(); }","old_code_raw":"    private int invoke_calculateBufferSize(int tdsVersion, int packetSize) {\n        Class[] classes = new Class[]{int.class, int.class};\n        Object[] objects = new Object[]{new Integer(tdsVersion), new Integer(packetSize)};\n\n        return ((Integer) invokeStaticMethod(SharedNamedPipe.class,\n                \"calculateBufferSize\", classes, objects)).intValue();\n    }\n","new_comment_raw":"Helper method to invoke  Support#calculateNamedPipeBufferSize(int, int) using reflection.","old_comment_raw":"Helper method to invoke SharedNamedPipe#calculateBufferSize(int, int) using reflection.","label":1,"pre_label":0,"AST_level":8,"line_counts":9,"new_code_token_num":73},{"new_code_raw":"private void getAndStoreFullRegistry() throws Throwable { long currentUpdateGeneration = fetchRegistryGeneration.get(); logger.info(\"Getting all instance registry info from the eureka server\"); Applications apps = null; if (shouldUseExperimentalTransport()) { EurekaHttpResponse<Applications> httpResponse = clientConfig.getRegistryRefreshSingleVipAddress() == null ? eurekaHttpClient.getApplications() : eurekaHttpClient.getVip(clientConfig.getRegistryRefreshSingleVipAddress()); if (httpResponse.getStatusCode() == Status.OK.getStatusCode()) { apps = httpResponse.getEntity(); } logger.info(\"The response status is {}\", httpResponse.getStatusCode()); } else { ClientResponse response = makeRemoteCall(Action.Refresh); try { if (response.getStatus() == Status.OK.getStatusCode()) { apps = response.getEntity(Applications.class); } logger.info(\"The response status is {}\", response.getStatus()); } finally { closeResponse(response); } } if (apps == null) { logger.error(\"The application is null for some reason. Not storing this information\"); } else if (fetchRegistryGeneration.compareAndSet(currentUpdateGeneration, currentUpdateGeneration + 1)) { localRegionApps.set(this.filterAndShuffle(apps)); logger.debug(\"Got full registry with apps hashcode {}\", apps.getAppsHashCode()); } else { logger.warn(\"Not updating applications as another thread is updating it already\"); } }","old_code_raw":"    private ClientResponse getAndStoreFullRegistry() throws Throwable {\n        long currentUpdateGeneration = fetchRegistryGeneration.get();\n        ClientResponse response = makeRemoteCall(Action.Refresh);\n        logger.info(\"Getting all instance registry info from the eureka server\");\n\n        Applications apps = null;\n        if (response.getStatus() == Status.OK.getStatusCode()) {\n            apps = response.getEntity(Applications.class);\n        }\n\n        if (apps == null) {\n            logger.error(\"The application is null for some reason. Not storing this information\");\n        } else if (fetchRegistryGeneration.compareAndSet(currentUpdateGeneration, currentUpdateGeneration + 1)) {\n            localRegionApps.set(this.filterAndShuffle(apps));\n            logger.debug(\"Got full registry with apps hashcode {}\", apps.getAppsHashCode());\n        } else {\n            logger.warn(\"Not updating applications as another thread is updating it already\");\n        }\n        logger.info(\"The response status is {}\", response.getStatus());\n        return response;\n    }\n","new_comment_raw":"Gets the full registry information from the eureka server and stores it locally.","old_comment_raw":"Gets the full registry information from the eureka server and stores it locally.","label":0,"pre_label":1,"AST_level":12,"line_counts":36,"new_code_token_num":257},{"new_code_raw":"private boolean shouldRegister(InstanceInfo myInfo) { if (!clientConfig.shouldRegisterWithEureka()) { return false; } else if ((myInfo != null) && (myInfo.getDataCenterInfo() .equals(DataCenterInfo.Name.Amazon))) { return true; } return true; }","old_code_raw":"    private boolean shouldRegister(InstanceInfo myInfo) {\n        if (!clientConfig.shouldRegisterWithEureka()) {\n            return false;\n        }\n\n        return true;\n    }\n","new_comment_raw":"Checks to see if the eureka client registration is enabled.","old_comment_raw":"Checks to see if the eureka client registration is enabled.","label":0,"pre_label":1,"AST_level":7,"line_counts":12,"new_code_token_num":53},{"new_code_raw":"public boolean get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }","old_code_raw":"    public boolean get(WithAttributes attributes) {\r\n        return attributes.getAttributes().get(this);\r\n    }\r\n","new_comment_raw":"Extracts the attribute map from the specified  WithAttributes and returns the value of this attribute from the map.","old_comment_raw":"Analogous to #get(WithAttributes) except returning a primitive boolean.","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":19},{"new_code_raw":"public Interval overlap(ReadableInterval interval) { interval = DateTimeUtils.getReadableInterval(interval); if (overlaps(interval) == false) { return null; } long start = Math.max(getStartMillis(), interval.getStartMillis()); long end = Math.min(getEndMillis(), interval.getEndMillis()); return new Interval(start, end, getChronology()); }","old_code_raw":"    public Interval overlap(ReadableInterval interval) {\n        interval = DateTimeUtils.getReadableInterval(interval);\n        if (overlaps(interval) == false) {\n            return null;\n        }\n        long start = Math.max(getStartMillis(), interval.getStartMillis());\n        long end = Math.min(getEndMillis(), interval.getEndMillis());\n        return new Interval(start, end);\n    }\n","new_comment_raw":"Gets the overlap between this interval and another interval.","old_comment_raw":"Gets the overlap where this interval and that specified.","label":1,"pre_label":0,"AST_level":6,"line_counts":10,"new_code_token_num":72},{"new_code_raw":"private synchronized static Supplier<Annotator> getOrCreate(AnnotatorFactory factory) { return () -> { Annotator rtn = customAnnotators.get(factory.signature()); if (rtn == null) { \/\/ Create the annotator rtn = factory.create(); \/\/ Register the annotator customAnnotators.put(factory.signature(), factory.create()); \/\/ Clean up memory if needed while (customAnnotators.size() > 10) { customAnnotators.keySet().iterator().remove(); } } return rtn; }; }","old_code_raw":"  private synchronized static Supplier<Annotator> getOrCreate(String name, Properties props, Supplier<Annotator> annotator) {\n    StanfordCoreNLP.AnnotatorSignature key = new StanfordCoreNLP.AnnotatorSignature(name, PropertiesUtils.getSignature(name, props));\n    customAnnotators.register(name, props, StanfordCoreNLP.GLOBAL_ANNOTATOR_CACHE.computeIfAbsent(key, (sig) -> Lazy.cache(annotator)));\n    return () -> customAnnotators.get(name);\n  }\n","new_comment_raw":"Either get a custom annotator which was recently defined, or create it if it has never been defined.","old_comment_raw":"Either get a custom annotator which was recently defined, or create it if it has never been defined.","label":0,"pre_label":1,"AST_level":11,"line_counts":17,"new_code_token_num":98},{"new_code_raw":"public synchronized VisualItem getItem(String itemClass, Entity entity, boolean create) { ItemEntry entry = (ItemEntry)m_entryMap.get(itemClass); if ( entry != null ) { VisualItem item = (VisualItem)entry.itemMap.get(entity); if ( !create ) { return item; } else if ( item == null ) { item = m_ifactory.getItem(itemClass); item.init(this, itemClass, entity); addItem(entry, entity, item); } if ( item instanceof NodeItem ) ((NodeItem)item).removeAllNeighbors(); item.setDirty(0); item.setVisible(true); return item; } else { throw new IllegalArgumentException(\"The input string must be a\" + \" recognized item class!\"); } } \/\/","old_code_raw":"\tpublic synchronized GraphItem getItem(String itemClass, Entity entity, boolean create) {\n\t\tItemEntry entry = (ItemEntry)m_entryMap.get(itemClass);\n\t\tif ( entry != null ) {\n\t\t\tGraphItem item = (GraphItem)entry.itemMap.get(entity);\n\t\t\tif ( !create ) {\n\t\t\t\treturn item;\n\t\t\t} else if ( item == null ) {\n\t\t\t\titem = m_ifactory.getItem(itemClass);\n\t\t\t\titem.init(this, itemClass, entity);\n\t\t\t\taddItem(entry, entity, item);\n\t\t\t}\n            if ( item instanceof NodeItem )\n                ((NodeItem)item).removeAllNeighbors();\n            item.setDirty(0);\n            item.setVisible(true);\n\t\t\treturn item;\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException(\"The input string must be a\"\n\t\t\t\t\t\t+ \" recognized item class!\");\n\t\t}\t\t\n\t} \/\/\n","new_comment_raw":"Requests a VisualItem of the specified item class corresponding to a given Entity, optionally creating the VisualItem if it doesn't already exist.","old_comment_raw":"Requests a GraphItem of the specified item class corresponding to a given Entity, optionally creating the GraphItem if it doesn't already exist.","label":1,"pre_label":0,"AST_level":11,"line_counts":23,"new_code_token_num":148},{"new_code_raw":"public Iterator<PersistentClass> getClassMappings() { return classes.values().iterator(); }","old_code_raw":"\tpublic Iterator getClassMappings() {\n\t\treturn classes.values().iterator();\n\t}\n","new_comment_raw":"Iterate the entity mappings","old_comment_raw":"Iterate the entity mappings","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":17},{"new_code_raw":"public String getExportDirectory() { return this.exportDirectory; }","old_code_raw":"    public String getExportDirectory() {\n        return exportDirectory;\n    }\n","new_comment_raw":"Returns the path to the export directory","old_comment_raw":"DOCUMENT ME!","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":11},{"new_code_raw":"public EurekaClient getEurekaClient() { return eurekaClient; }","old_code_raw":"    public EurekaClient getEurekaClient() {\n        return discoveryClient;\n    }\n","new_comment_raw":"Get the  EurekaClient implementation.","old_comment_raw":"Get the EurekaClient implementation.","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"public LookupService createLookupService() { return createLookupService(defaultEndpointUrl); }","old_code_raw":"    public LookupService createLookupService() {\n        return createLookupService(defaultServerUrl);\n    }\n","new_comment_raw":"C6reate and return a new lookup service with the default endpoint URL.","old_comment_raw":"C6reate and return a new lookup service with the default server URL.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":13},{"new_code_raw":"public MessageConsumer createConsumer(Destination destination, String messageSelector, boolean noLocal, MessageListener messageListener) throws JMSException { checkClosed(); if (destination instanceof CustomDestination) { CustomDestination customDestination = (CustomDestination)destination; return customDestination.createConsumer(this, messageSelector, noLocal); } ActiveMQPrefetchPolicy prefetchPolicy = connection.getPrefetchPolicy(); int prefetch = 0; if (destination instanceof Topic) { prefetch = prefetchPolicy.getTopicPrefetch(); } else { prefetch = prefetchPolicy.getQueuePrefetch(); } ActiveMQDestination activemqDestination = ActiveMQMessageTransformation.transformDestination(destination); return new ActiveMQMessageConsumer(this, getNextConsumerId(), activemqDestination, null, messageSelector, prefetch, prefetchPolicy.getMaximumPendingMessageLimit(), noLocal, false, asyncDispatch, messageListener); }","old_code_raw":"    public MessageConsumer createConsumer(Destination destination, String messageSelector, boolean noLocal) throws JMSException {\n        checkClosed();\n\n        if (destination instanceof CustomDestination) {\n            CustomDestination customDestination = (CustomDestination)destination;\n            return customDestination.createConsumer(this, messageSelector, noLocal);\n        }\n\n        ActiveMQPrefetchPolicy prefetchPolicy = connection.getPrefetchPolicy();\n        return new ActiveMQMessageConsumer(this, getNextConsumerId(), ActiveMQMessageTransformation.transformDestination(destination), null, messageSelector, prefetchPolicy\n            .getTopicPrefetch(), prefetchPolicy.getMaximumPendingMessageLimit(), noLocal, false, asyncDispatch);\n    }\n","new_comment_raw":"Creates MessageConsumer for the specified destination, using a message selector.","old_comment_raw":"Creates MessageConsumer for the specified destination, using a message selector.","label":0,"pre_label":1,"AST_level":8,"line_counts":20,"new_code_token_num":124},{"new_code_raw":"public static void to2D(double[] weights, List<Index<CRFLabel>> labelIndices, int[] map, double[][] newWeights) { int index = 0; for (int i = 0; i < map.length; i++) { int labelSize = labelIndices.get(map[i]).size(); System.arraycopy(weights, index, newWeights[i], 0, labelSize); index += labelSize; } }","old_code_raw":"  public static double[][] to2D(double[] weights, List<Index<CRFLabel>> labelIndices, int[] map) {\n    double[][] newWeights = new double[map.length][];\n    int index = 0;\n    for (int i = 0; i < map.length; i++) {\n      int labelSize = labelIndices.get(map[i]).size();\n      newWeights[i] = new double[labelSize];\n      try {\n        System.arraycopy(weights, index, newWeights[i], 0, labelSize);\n      } catch (Exception ex) {\n        log.info(\"weights: \" + Arrays.toString(weights));\n        log.info(\"newWeights[\"+i+\"]: \" + Arrays.toString(newWeights[i]));\n        throw new RuntimeException(ex);\n      }\n      index += labelSize;\n    }\n    return newWeights;\n  }\n","new_comment_raw":"Takes a double array of weights and populates a 2D array where: the first element is the mapped index of the clique size (e.g., node-0, edge-1) matching featuresIndex i the second element is the number of output classes for that clique size","old_comment_raw":"Takes a double array of weights and creates a 2D array where: the first element is the mapped index of the clique size (e.g., node-0, edge-1) matching featuresIndex i the second element is the number of output classes for that clique size","label":1,"pre_label":0,"AST_level":10,"line_counts":9,"new_code_token_num":84},{"new_code_raw":"public DateTime withFields(ReadablePartial partial) { if (partial == null) { return this; } return withMillis(getChronology().set(partial, getMillis())); }","old_code_raw":"    public DateTime withFields(ReadablePartial partial) {\n        if (partial == null) {\n            return this;\n        }\n        return partial.resolveDateTime(this);\n    }\n","new_comment_raw":"Gets a copy of this datetime with the partial set of fields replacing those from this instance.","old_comment_raw":"Gets a copy of this datetime with the partial set of fields replacing those from this instance.","label":0,"pre_label":1,"AST_level":7,"line_counts":7,"new_code_token_num":35},{"new_code_raw":"public String getName(long instant, Locale locale) { if (locale == null) { locale = Locale.getDefault(); } String nameKey = getNameKey(instant); if (nameKey == null) { return iID; } String name = cNameProvider.getName(locale, iID, nameKey); if (name != null) { return name; } return offsetFormatter().print(instant, this); }","old_code_raw":"    public String getName(long millis, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(millis);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return offsetFormatter().print(millis, this);\n    }\n","new_comment_raw":"Gets the long name of this datetime zone suitable for display using the specified locale.","old_comment_raw":"Gets the long name of this datetime zone suitable for display using the specified locale.","label":0,"pre_label":1,"AST_level":7,"line_counts":15,"new_code_token_num":76},{"new_code_raw":"public Object next() throws java.io.IOException { int zzInput; int zzAction; \/\/ cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; \/\/ set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { \/\/ store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); \/\/ get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } \/\/ store back cached position zzMarkedPos = zzMarkedPosL; if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { \/\/ prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); \/\/ System.err.println(\"At end of text making after: |\" + str + \"|\"); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); \/\/ System.err.println(\"prevWord is |\" + prevWord.get(CoreAnnotations.TextAnnotation.class) + \"|, its after is |\" + \/\/ prevWord.get(CoreAnnotations.AfterAnnotation.class) + \"|\"); prevWordAfter.setLength(0); } return null; } } else { switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { String str = yytext(); int first = str.codePointAt(0); String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } logger.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: logger.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 75: break; case 2: { return getNext(\"<\", yytext()); } case 76: break; case 3: { return getNext(); } case 77: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 78: break; case 5: { if (tokenizeNLs) { return getNext(AbstractTokenizer.NEWLINE_TOKEN, yytext()); \/\/ for tokenizing newliens } else if (invertible) { \/\/ System.err.println(\"Appending newline: |\" + yytext() + \"|\"); prevWordAfter.append(yytext()); } } case 79: break; case 6: { final String origTxt = yytext(); String tok = removeSoftHyphens(origTxt); if (americanize) { tok = Americanize.americanize(tok); } if (DEBUG) { logger.info(\"Used {WORD} (2) to recognize \" + origTxt + \" as \" + tok + \"; probablyLeft=\" + false); } return getNext(tok, origTxt); } case 80: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 81: break; case 8: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {QUOTES} (3) to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 82: break; case 9: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 83: break; case 10: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 84: break; case 11: { return getNext(\">\", yytext()); } case 85: break; case 12: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 86: break; case 13: { handleHyphenatedNumber(yytext()); if (DEBUG) { logger.info(\"Used {NUMBER} to recognize \" + yytext() + \" as \" + removeFromNumber(yytext())); } return getNext(removeFromNumber(yytext()), yytext()); } case 87: break; case 14: { return handleEllipsis(yytext()); } case 88: break; case 15: { \/\/ breakByHyphens(yytext()); \/\/ this is causing fail of attempted to pushback too much! String tok = yytext(); \/* A THING can contain quote like O'Malley *\/ String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {THING} (2) to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 89: break; case 16: { String txt = yytext(); String norm = normalizeFractions(yytext()); if (DEBUG) { logger.info(\"Used {FRAC2} to recognize \" + txt + \" as \" + norm + \"; normalizeFractions=\" + normalizeFractions + \", escapeForwardSlashAsterisk=\" + escapeForwardSlashAsterisk); } return getNext(norm, txt); } case 90: break; case 17: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(minimallyNormalizeCurrency(yytext()), yytext()); } } case 91: break; case 18: { if (normalizeOtherBrackets) { return getNext(\"-RSB-\", yytext()); } else { return getNext(); } } case 92: break; case 19: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 93: break; case 20: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 94: break; case 21: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 95: break; case 22: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 96: break; case 23: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 97: break; case 24: { if (normalizeOtherBrackets) { return getNext(\"-LSB-\", yytext()); } else { return getNext(); } } case 98: break; case 25: { if (invertible) { prevWordAfter.append(yytext()); } } case 99: break; case 26: { return getNext(\"\\u2022\", yytext()); } case 100: break; case 27: { return getNext(\"\\u2122\", yytext()); } case 101: break; case 28: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 102: break; case 29: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(); } case 103: break; case 30: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {REDAUX} (2) to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 104: break; case 31: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {APOWORD} to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 105: break; case 32: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); String norm = handleQuotes(tok, true); if (DEBUG) { logger.info(\"Used {DBLQUOT} to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + true); } return getNext(norm, tok); } case 106: break; case 33: { String tok = yytext(); if (DEBUG) { logger.info(\"Used {PROG_LANGS} to recognize \" + tok + \" as \" + tok); } return getNext(tok, tok); } case 107: break; case 34: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 108: break; case 35: { breakByHyphens(yytext()); if (DEBUG) { logger.info(\"Used {HTHING} to recognize \" + yytext() + \" as \" + removeSoftHyphens(yytext())); } return getNext(removeSoftHyphens(yytext()), yytext()); } case 109: break; case 36: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tok = removeSoftHyphens(origTxt); if (americanize) { tok = Americanize.americanize(tok); } if (DEBUG) { logger.info(\"Used {WORD} to recognize \" + origTxt + \" as \" + tok + \"; probablyLeft=\" + false); } return getNext(tok, origTxt); } case 110: break; case 37: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 111: break; case 38: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 112: break; case 39: { \/\/ this one should only match if we're basically at the end of file \/\/ since the last one matches two things, even newlines (if not tokenize per line) String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 113: break; case 40: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 114: break; case 41: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { \/\/ Extra context is to not match on ones like 'd but you do want words like \"a\" \/\/ can't have digit here because of cases like '90s String tok = yytext(); \/* invert single quote - often but not always right *\/ String norm = handleQuotes(tok, true); if (DEBUG) { logger.info(\"Used {QUOTES} to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + true); } return getNext(norm, tok); } case 115: break; case 42: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {REDAUX} to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 116: break; case 43: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { \/\/ Extra context is to not match on ones like 'd but you do want words like \"a\" \/\/ can't have digit here because of cases like '90s String tok = yytext(); \/* invert single quote - often but not always right *\/ String norm = handleQuotes(tok, true); if (DEBUG) { logger.info(\"Used {QUOTES} (2) to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + true); } return getNext(norm, tok); } case 117: break; case 44: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 118: break; case 45: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {SREDAUX} (2) to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 119: break; case 46: { if (splitAssimilations) { yypushback(2); } String tok = yytext(); if (DEBUG) { logger.info(\"Used {ASSIMILATIONS3} to recognize \" + tok + \" as \" + tok + \"; splitAssimilations=\" + splitAssimilations); } return getNext(tok, tok); } case 120: break; case 47: { String txt = yytext(); \/\/ if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space... if (strictTreebank3) { int spaceIndex = indexOfSpace(txt); if (spaceIndex >= 0) { yypushback(txt.length() - spaceIndex); return getNext(); } } if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, yytext()); } case 121: break; case 48: { return getNormalizedAmpNext(); } case 122: break; case 49: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, origTxt); } case 123: break; case 50: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space } return getNext(txt, origTxt); } case 124: break; case 51: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 125: break; case 52: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 17; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 126: break; case 53: { String txt = yytext(); String normTok = txt; if (escapeForwardSlashAsterisk) { normTok = delimit(normTok, '*'); } if (DEBUG) { logger.info(\"Used {SWEARING} to recognize \" + txt + \" as \" + normTok); } return getNext(normTok, txt); } case 127: break; case 54: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 128: break; case 55: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 129: break; case 56: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 22; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 130: break; case 57: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 18; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 19; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 131: break; case 58: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 132: break; case 59: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 21; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 133: break; case 60: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 134: break; case 61: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); breakByHyphens(tok); tok = yytext(); String norm = removeSoftHyphens(tok); if (DEBUG) { logger.info(\"Used {HTHING} (2) to recognize \" + tok + \" as \" + norm); } return getNext(norm, tok); } case 135: break; case 62: { if (splitAssimilations) { yypushback(3); } String tok = yytext(); if (DEBUG) { logger.info(\"Used {ASSIMILATIONS3} to recognize \" + tok + \" as \" + tok + \"; splitAssimilations=\" + splitAssimilations); } return getNext(tok, tok); } case 136: break; case 63: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNormalizedAmpNext(); } case 137: break; case 64: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 9; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 138: break; case 65: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { return getNext(); } case 139: break; case 66: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 140: break; case 67: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 141: break; case 68: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 13; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 142: break; case 69: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } return getNext(txt, yytext()); } case 143: break; case 70: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4); { return getNext(); } case 144: break; case 71: \/\/ lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { return getNext(); } case 145: break; case 72: { String txt = yytext(); if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } if (DEBUG) { logger.info(\"Used {PHONE} to recognize \" + yytext() + \" as \" + txt); } return getNext(txt, yytext()); } case 146: break; case 73: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 25; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 147: break; case 74: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 24; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 148: break; default: zzScanError(ZZ_NO_MATCH); } } } }","old_code_raw":"  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    \/\/ cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      \/\/ set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            \/\/ store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            \/\/ get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      \/\/ store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n        zzAtEOF = true;\n              {\n                if (invertible) {\n            \/\/ prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            \/\/ System.err.println(\"At end of text making after: |\" + str + \"|\");\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n            \/\/ System.err.println(\"prevWord is |\" + prevWord.get(CoreAnnotations.TextAnnotation.class) + \"|, its after is |\" +\n            \/\/         prevWord.get(CoreAnnotations.AfterAnnotation.class) + \"|\");\n            prevWordAfter.setLength(0);\n          }\n          return null;\n              }\n      }\n      else {\n        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n          case 1: \n            { String str = yytext();\n          int first = str.codePointAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\",\n                          yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n            }\n          case 74: break;\n          case 2: \n            { return getNext(\"<\", yytext());\n            }\n          case 75: break;\n          case 3: \n            { return getNext();\n            }\n          case 76: break;\n          case 4: \n            { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n            }\n          case 77: break;\n          case 5: \n            { if (tokenizeNLs) {\n                      return getNext(AbstractTokenizer.NEWLINE_TOKEN, yytext()); \/\/ for tokenizing newliens\n                  } else if (invertible) {\n                    \/\/ System.err.println(\"Appending newline: |\" + yytext() + \"|\");\n                    prevWordAfter.append(yytext());\n                  }\n            }\n          case 78: break;\n          case 6: \n            { final String origTxt = yytext();\n                          String tok = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tok = Americanize.americanize(tok);\n                          }\n                          if (DEBUG) { logger.info(\"Used {WORD} (2) to recognize \" + origTxt + \" as \" + tok +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(tok, origTxt);\n            }\n          case 79: break;\n          case 7: \n            { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n            }\n          case 80: break;\n          case 8: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} (3) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 81: break;\n          case 9: \n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 82: break;\n          case 10: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '\/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 83: break;\n          case 11: \n            { return getNext(\">\", yytext());\n            }\n          case 84: break;\n          case 12: \n            { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n            }\n          case 85: break;\n          case 13: \n            { handleHyphenatedNumber(yytext());\n                          if (DEBUG) { logger.info(\"Used {NUMBER} to recognize \" + yytext() + \" as \" + removeFromNumber(yytext())); }\n                          return getNext(removeFromNumber(yytext()), yytext());\n            }\n          case 86: break;\n          case 14: \n            { return handleEllipsis(yytext());\n            }\n          case 87: break;\n          case 15: \n            { \/\/ breakByHyphens(yytext()); \/\/ this is causing fail of attempted to pushback too much!\n                  String tok = yytext();\n                  \/* A THING can contain quote like O'Malley *\/\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {THING} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 88: break;\n          case 16: \n            { String txt = yytext();\n                  String norm = normalizeFractions(yytext());\n                  if (DEBUG) { logger.info(\"Used {FRAC2} to recognize \" + txt + \" as \" + norm +\n                                       \"; normalizeFractions=\" + normalizeFractions +\n                                       \", escapeForwardSlashAsterisk=\" + escapeForwardSlashAsterisk); }\n                  return getNext(norm, txt);\n            }\n          case 89: break;\n          case 17: \n            { if (normalizeCurrency) {\n                            return getNext(normalizeCurrency(yytext()), yytext());\n                        } else {\n                            return getNext(minimallyNormalizeCurrency(yytext()), yytext());\n                          }\n            }\n          case 90: break;\n          case 18: \n            { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 91: break;\n          case 19: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-RSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 92: break;\n          case 20: \n            { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 93: break;\n          case 21: \n            { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 94: break;\n          case 22: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 95: break;\n          case 23: \n            { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 96: break;\n          case 24: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-LSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 97: break;\n          case 25: \n            { if (invertible) {\n                            prevWordAfter.append(yytext());\n                        }\n            }\n          case 98: break;\n          case 26: \n            { return getNext(\"\\u2022\", yytext());\n            }\n          case 99: break;\n          case 27: \n            { return getNext(\"\\u2122\", yytext());\n            }\n          case 100: break;\n          case 28: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 15;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 101: break;\n          case 29: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext();\n            }\n          case 102: break;\n          case 30: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {REDAUX} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 103: break;\n          case 31: \n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {APOWORD} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 104: break;\n          case 32: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                                   String norm = handleQuotes(tok, true);\n                                   if (DEBUG) { logger.info(\"Used {DBLQUOT} to recognize \" + tok + \" as \" + norm +\n                                                            \"; probablyLeft=\" + true); }\n                                   return getNext(norm, tok);\n            }\n          case 105: break;\n          case 33: \n            { String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {PROG_LANGS} to recognize \" + tok + \" as \" + tok); }\n                    return getNext(tok, tok);\n            }\n          case 106: break;\n          case 34: \n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 107: break;\n          case 35: \n            { breakByHyphens(yytext());\n                  if (DEBUG) { logger.info(\"Used {HTHING} to recognize \" + yytext() + \" as \" + removeSoftHyphens(yytext())); }\n                  return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 108: break;\n          case 36: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 3;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 4;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String origTxt = yytext();\n                          String tok = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tok = Americanize.americanize(tok);\n                          }\n                          if (DEBUG) { logger.info(\"Used {WORD} to recognize \" + origTxt + \" as \" + tok +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(tok, origTxt);\n            }\n          case 109: break;\n          case 37: \n            { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '\/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 110: break;\n          case 38: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 111: break;\n          case 39: \n            { \/\/ this one should only match if we're basically at the end of file\n                          \/\/ since the last one matches two things, even newlines (if not tokenize per line)\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n                          return getNext(s, yytext());\n            }\n          case 112: break;\n          case 40: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 113: break;\n          case 41: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { \/\/ Extra context is to not match on ones like 'd but you do want words like \"a\"\n                  \/\/ can't have digit here because of cases like '90s\n                  String tok = yytext();\n                  \/* invert single quote - often but not always right *\/\n                  String norm = handleQuotes(tok, true);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + true); }\n                  return getNext(norm, tok);\n            }\n          case 114: break;\n          case 42: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {REDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 115: break;\n          case 43: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { \/\/ Extra context is to not match on ones like 'd but you do want words like \"a\"\n                  \/\/ can't have digit here because of cases like '90s\n                  String tok = yytext();\n                  \/* invert single quote - often but not always right *\/\n                  String norm = handleQuotes(tok, true);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + true); }\n                  return getNext(norm, tok);\n            }\n          case 116: break;\n          case 44: \n            { return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 117: break;\n          case 45: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {SREDAUX} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 118: break;\n          case 46: \n            { if (splitAssimilations) {\n                      yypushback(2);\n                    }\n                    String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {ASSIMILATIONS3} to recognize \" + tok + \" as \" + tok +\n                            \"; splitAssimilations=\" + splitAssimilations); }\n                    return getNext(tok, tok);\n            }\n          case 119: break;\n          case 47: \n            { String txt = yytext();\n                  \/\/ if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space...\n                  if (strictTreebank3) {\n                    int spaceIndex = indexOfSpace(txt);\n                    if (spaceIndex >= 0) {\n                      yypushback(txt.length() - spaceIndex);\n                      return getNext();\n                    }\n                  }\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '\/');\n                  }\n                  if (normalizeSpace) {\n                    txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                  }\n                  return getNext(txt, yytext());\n            }\n          case 120: break;\n          case 48: \n            { return getNormalizedAmpNext();\n            }\n          case 121: break;\n          case 49: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 122: break;\n          case 50: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 123: break;\n          case 51: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 5;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 6;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String txt = yytext();\n                          return getNext(removeSoftHyphens(txt),\n                                         txt);\n            }\n          case 124: break;\n          case 52: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 17;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 125: break;\n          case 53: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 126: break;\n          case 54: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 10;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 127: break;\n          case 55: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 22;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 128: break;\n          case 56: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 18;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 19;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 129: break;\n          case 57: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 10;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 130: break;\n          case 58: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 21;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 131: break;\n          case 59: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 132: break;\n          case 60: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                  breakByHyphens(tok);\n                  tok = yytext();\n                  String norm = removeSoftHyphens(tok);\n                  if (DEBUG) { logger.info(\"Used {HTHING} (2) to recognize \" + tok + \" as \" + norm); }\n                  return getNext(norm, tok);\n            }\n          case 133: break;\n          case 61: \n            { if (splitAssimilations) {\n                      yypushback(3);\n                    }\n                    String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {ASSIMILATIONS3} to recognize \" + tok + \" as \" + tok +\n                            \"; splitAssimilations=\" + splitAssimilations); }\n                    return getNext(tok, tok);\n            }\n          case 134: break;\n          case 62: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNormalizedAmpNext();\n            }\n          case 135: break;\n          case 63: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 9;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 136: break;\n          case 64: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { return getNext();\n            }\n          case 137: break;\n          case 65: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 14;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 138: break;\n          case 66: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 8;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 139: break;\n          case 67: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 13;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 140: break;\n          case 68: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 141: break;\n          case 69: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4);\n            { return getNext();\n            }\n          case 142: break;\n          case 70: \n            \/\/ lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);\n            { return getNext();\n            }\n          case 143: break;\n          case 71: \n            { String txt = yytext();\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          if (DEBUG) { logger.info(\"Used {PHONE} to recognize \" + yytext() + \" as \" + txt); }\n                          return getNext(txt, yytext());\n            }\n          case 144: break;\n          case 72: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 23;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 25;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 145: break;\n          case 73: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 23;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 24;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 146: break;\n          default:\n            zzScanError(ZZ_NO_MATCH);\n        }\n      }\n    }\n  }\n","new_comment_raw":"Resumes scanning until the next regular expression is matched, the end of input is encountered or an I\/O-Error occurs.","old_comment_raw":"Resumes scanning until the next regular expression is matched, the end of input is encountered or an I\/O-Error occurs.","label":0,"pre_label":1,"AST_level":21,"line_counts":1080,"new_code_token_num":7599},{"new_code_raw":"public Task<EncodedImage> get(List<CacheKey> keys, final AtomicBoolean isCancelled) { Preconditions.checkArgument(!keys.isEmpty()); for (CacheKey key : keys) { final EncodedImage pinnedImage = mStagingArea.get(key); if (pinnedImage != null) { return foundPinnedImage(key, pinnedImage); } } Task<EncodedImage> masterTask = getAsync(keys.get(0), isCancelled); if (keys.size() == 1) { return masterTask; } for (final CacheKey key : keys.subList(1, keys.size())) { masterTask = masterTask.continueWithTask( new Continuation<EncodedImage, Task<EncodedImage>>() { @Override public Task<EncodedImage> then(Task<EncodedImage> previousTask) throws Exception { \/\/ If we've got a hit, stop. If this is cancelled, stop. Otherwise, keep going. if (previousTask.isCancelled() || previousTask.getResult() != null) { return previousTask; } return getAsync(key, isCancelled); } }, mReadExecutor); } return masterTask; }","old_code_raw":"  public Task<EncodedImage> get(final CacheKey key, final AtomicBoolean isCancelled) {\n    Preconditions.checkNotNull(key);\n    Preconditions.checkNotNull(isCancelled);\n\n    final EncodedImage pinnedImage = mStagingArea.get(key);\n    if (pinnedImage != null) {\n      FLog.v(TAG, \"Found image for %s in staging area\", key.toString());\n      mImageCacheStatsTracker.onStagingAreaHit();\n      return Task.forResult(pinnedImage);\n    }\n\n    try {\n      return Task.call(\n          new Callable<EncodedImage>() {\n            @Override\n            public EncodedImage call()\n                throws Exception {\n              if (isCancelled.get()) {\n                throw new CancellationException();\n              }\n              EncodedImage result = mStagingArea.get(key);\n              if (result != null) {\n                FLog.v(TAG, \"Found image for %s in staging area\", key.toString());\n                mImageCacheStatsTracker.onStagingAreaHit();\n              } else {\n                FLog.v(TAG, \"Did not find image for %s in staging area\", key.toString());\n                mImageCacheStatsTracker.onStagingAreaMiss();\n\n                try {\n                  final PooledByteBuffer buffer = readFromDiskCache(key);\n                  CloseableReference<PooledByteBuffer> ref = CloseableReference.of(buffer);\n                  try {\n                    result = new EncodedImage(ref);\n                  } finally {\n                    CloseableReference.closeSafely(ref);\n                  }\n                } catch (Exception exception) {\n                  return null;\n                }\n              }\n\n              if (Thread.interrupted()) {\n                FLog.v(TAG, \"Host thread was interrupted, decreasing reference count\");\n                if (result != null) {\n                  result.close();\n                }\n                throw new InterruptedException();\n              } else {\n                return result;\n              }\n            }\n          },\n          mReadExecutor);\n    } catch (Exception exception) {\n      \/\/ Log failure\n      \/\/ TODO: 3697790\n      FLog.w(\n          TAG,\n          exception,\n          \"Failed to schedule disk-cache read for %s\",\n          key.toString());\n      return Task.forError(exception);\n    }\n  }\n","new_comment_raw":"Performs lookup of a series of disk cache keys in a single thread.","old_comment_raw":"Performs key-value look up in disk cache.","label":1,"pre_label":0,"AST_level":13,"line_counts":31,"new_code_token_num":190},{"new_code_raw":"public Constructor[] getConstructors() throws SecurityException { \/\/ BEGIN android-note \/\/ trying to get closer to the RI which returns a raw constructor array. \/\/ copied from newer version of harmony \/\/ END android-note checkPublicMemberAccess(); return getDeclaredConstructors(this, true); }","old_code_raw":"    public Constructor<T>[] getConstructors() throws SecurityException {\n        checkPublicMemberAccess();\n        return getDeclaredConstructors(this, true);\n    }\n","new_comment_raw":"Returns an array containing  Constructor objects for all public constructors for the class represented by this  Class.","old_comment_raw":"Returns an array containing Constructor objects describing all constructors which are visible from the current execution context.","label":1,"pre_label":0,"AST_level":5,"line_counts":10,"new_code_token_num":58},{"new_code_raw":"public boolean checkAlreadyExist(AccountDatabase.AccountName s) { \/\/ Query in the realm database RealmQuery<AccountDatabase> query = realm.where(AccountDatabase.class); \/\/ Checking if string equals to is exist or not query.equalTo(\"name\", s.toString()); RealmResults<AccountDatabase> result1 = query.findAll(); \/\/ Here checking if count of that values is greater than zero return result1.size() > 0; }","old_code_raw":"    public boolean checkAlreadyExist(AccountDatabase.AccountName s) {\n\n        \/\/ Query in the realm database\n        RealmQuery<AccountDatabase> query = realm.where(AccountDatabase.class);\n\n        \/\/ Checking if string equals to is exist or not\n        query.equalTo(\"name\", s.toString());\n        RealmResults<AccountDatabase> result1 = query.findAll();\n\n        \/\/ Here checking if count of that values is greater than zero\n        return (result1.size() > 0) ? true : false;\n    }\n","new_comment_raw":"This function check if the selected account is already existed.","old_comment_raw":"This function check if the selected account is already existed.","label":0,"pre_label":1,"AST_level":7,"line_counts":13,"new_code_token_num":79},{"new_code_raw":"private ASN1Object toASN1Object( X509Certificate cert) throws CertificateEncodingException { try { return new ASN1InputStream(cert.getEncoded()).readObject(); } catch (Exception e) { throw new CertificateEncodingException(\"Exception while encoding certificate: \" + e.toString()); } }","old_code_raw":"    private DERObject toASN1Object(\n        X509Certificate cert)\n        throws CertificateEncodingException\n    {\n        try\n        {\n            return new ASN1InputStream(cert.getEncoded()).readObject();\n        }\n        catch (Exception e)\n        {\n            throw new CertificateEncodingException(\"Exception while encoding certificate: \" + e.toString());\n        }\n    }\n","new_comment_raw":"Return a ASN1Object containing the encoded certificate.","old_comment_raw":"Return a DERObject containing the encoded certificate.","label":1,"pre_label":0,"AST_level":8,"line_counts":15,"new_code_token_num":52},{"new_code_raw":"private Expression translate0(RexNode expr, RexImpTable.NullAs nullAs) { if (expr instanceof RexInputRef) { final int index = ((RexInputRef) expr).getIndex(); Expression x = inputGetter.field(list, index); return list.append( \"v\", nullAs.handle( list.append(\"v\", x))); } if (expr instanceof RexLocalRef) { return translate( program.getExprList().get(((RexLocalRef) expr).getIndex()), nullAs); } if (expr instanceof RexLiteral) { return translateLiteral( expr, typeFactory.createTypeWithNullability( expr.getType(), isNullable(expr) && nullAs != RexImpTable.NullAs.NOT_POSSIBLE), typeFactory, nullAs); } if (expr instanceof RexCall) { final RexCall call = (RexCall) expr; final SqlOperator operator = call.getOperator(); RexImpTable.CallImplementor implementor = RexImpTable.INSTANCE.get(operator); if (implementor != null) { return implementor.implement(this, call, nullAs); } } switch (expr.getKind()) { default: throw new RuntimeException( \"cannot translate expression \" + expr); } }","old_code_raw":"    private Expression translate0(RexNode expr, RexImpTable.NullAs nullAs) {\n        if (expr instanceof RexInputRef) {\n            final int index = ((RexInputRef) expr).getIndex();\n            Expression x = inputGetter.field(list, index);\n            return nullAs.handle(list.append(\"v\", x));\n        }\n        if (expr instanceof RexLocalRef) {\n            return translate(\n                program.getExprList().get(((RexLocalRef) expr).getIndex()),\n                nullAs);\n        }\n        if (expr instanceof RexLiteral) {\n            return translateLiteral(\n                expr,\n                typeFactory.createTypeWithNullability(\n                    expr.getType(),\n                    isNullable(expr)\n                    && nullAs != RexImpTable.NullAs.NOT_POSSIBLE),\n                typeFactory,\n                nullAs);\n        }\n        if (expr instanceof RexCall) {\n            final RexCall call = (RexCall) expr;\n            final SqlOperator operator = call.getOperator();\n            RexImpTable.CallImplementor implementor =\n                RexImpTable.INSTANCE.get(operator);\n            if (implementor != null) {\n                return implementor.implement(this, call, nullAs);\n            }\n        }\n        switch (expr.getKind()) {\n        default:\n            throw new RuntimeException(\n                \"cannot translate expression \" + expr);\n        }\n    }\n","new_comment_raw":"Translates an expression that is not in the cache.","old_comment_raw":"Translates an expression that is not in the cache.","label":0,"pre_label":1,"AST_level":10,"line_counts":40,"new_code_token_num":214},{"new_code_raw":"public static String jenkinsJobName(BuildConfig bc) { String namespace = bc.getMetadata().getNamespace(); String name = bc.getMetadata().getName(); return jenkinsJobName(namespace, name); }","old_code_raw":"  public static String jenkinsJobName(BuildConfig bc, String defaultNamespace) {\n    String namespace = bc.getMetadata().getNamespace();\n    String name = bc.getMetadata().getName();\n    return jenkinsJobName(namespace, name, defaultNamespace);\n  }\n","new_comment_raw":"Finds the Jenkins job name for the given  BuildConfig.","old_comment_raw":"Finds the Jenkins job for the given BuildConfig and defaultNamespace","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":38},{"new_code_raw":"private ConnectionJDBC getConnection() throws SQLException { return (ConnectionJDBC) statement.getConnection(); }","old_code_raw":"    private ConnectionJDBC2 getConnection() throws SQLException {\n        return (ConnectionJDBC2) statement.getConnection();\n    }\n","new_comment_raw":"Returns the  ConnectionJDBC object referenced by the  #statement instance variable.","old_comment_raw":"Returns the ConnectionJDBC2 object referenced by the #statement instance variable.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":18},{"new_code_raw":"public String fakeOuterStringSerialize(String body) throws ApiException { Object localVarPostBody = body; \/\/ create path and map variables String localVarPath = \"\/fake\/outer\/string\"; \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<String> localVarReturnType = new GenericType<String>() {}; return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public String fakeOuterStringSerialize(String body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/fake\/outer\/string\";\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<String> localVarReturnType = new GenericType<String>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"Test serialization of outer string types","old_comment_raw":"Test serialization of outer string types","label":0,"pre_label":1,"AST_level":8,"line_counts":31,"new_code_token_num":166},{"new_code_raw":"public String toDefaultValue(Schema schema) { if (schema.getDefault() != null) { return schema.getDefault().toString(); } return getPropertyDefaultValue(schema); }","old_code_raw":"    public String toDefaultValue(Schema schema) {\n        if (schema.getDefault() != null) {\n            return schema.getDefault().toString();\n        }\n\n        if (ModelUtils.isBooleanSchema(schema)) {\n            return \"null\";\n        } else if (ModelUtils.isDateSchema(schema)) {\n            return \"null\";\n        } else if (ModelUtils.isDateTimeSchema(schema)) {\n            return \"null\";\n        } else if (ModelUtils.isNumberSchema(schema)) {\n            return \"null\";\n        } else if (ModelUtils.isIntegerSchema(schema)) {\n            return \"null\";\n        } else if (ModelUtils.isStringSchema(schema)) {\n            return \"null\";\n        } else if (ModelUtils.isObjectSchema(schema)) {\n            return \"null\";\n        } else {\n            return \"null\";\n        }\n    }\n","new_comment_raw":"Return the default value of the property","old_comment_raw":"Return the default value of the property","label":0,"pre_label":1,"AST_level":7,"line_counts":8,"new_code_token_num":35},{"new_code_raw":"public static TokenSequencePattern compile(SequencePattern.PatternExpr nodeSequencePattern) { return new TokenSequencePattern(null, nodeSequencePattern); }","old_code_raw":"  public static TokenSequencePattern compile(Env env, String... strings)\n  {\n    try {\n      List<SequencePattern.PatternExpr> patterns = new ArrayList<SequencePattern.PatternExpr>();\n      for (String string:strings) {\n        \/\/ TODO: Check token sequence parser?\n        SequencePattern.PatternExpr pattern = env.parser.parseSequence(env, string);\n        patterns.add(pattern);\n      }\n      SequencePattern.PatternExpr nodeSequencePattern = new SequencePattern.SequencePatternExpr(patterns);\n      return new TokenSequencePattern(StringUtils.join(strings), nodeSequencePattern);\n    } catch (Exception ex) {\n      throw new RuntimeException(ex);\n    }\n  }\n","new_comment_raw":"Compiles a PatternExpr into a TokenSequencePattern.","old_comment_raw":"Compiles a sequence of regular expression a TokenSequencePattern using the specified environment.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":20},{"new_code_raw":"private boolean isBreakOnOpcode(Integer opcode) { boolean shouldBreak = false; if (config.isBreakOnPingPong()) { \/\/ break on every message type shouldBreak = true; } else { \/\/ break only on non-ping\/pong boolean isPing = opcode.equals(WebSocketMessage.OPCODE_PING); boolean isPong = opcode.equals(WebSocketMessage.OPCODE_PONG); if (!isPing && !isPong) { shouldBreak = true; } } return shouldBreak; }","old_code_raw":"\tprivate boolean isBreakOnOpcode(Integer opcode) {\n\t\tif (config.isBreakOnPingPong()) {\n\t\t\t\/\/ break on every message type\n\t\t\treturn true;\n\t\t} else {\n\t\t\t\/\/ break only on non-ping\/pong\n\t\t\tboolean isPing = opcode.equals(WebSocketMessage.OPCODE_PING);\n\t\t\tboolean isPong = opcode.equals(WebSocketMessage.OPCODE_PONG);\n\t\t\t\n\t\t\tif (!isPing && !isPong) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n","new_comment_raw":"Check out if breakpoint should be applied on given  WebSocketMessageDTO#opcode.","old_comment_raw":"Check out if breakpoint should be applied on given WebSocketMessageDTO#opcode.","label":0,"pre_label":1,"AST_level":9,"line_counts":17,"new_code_token_num":80},{"new_code_raw":"public DataFetcher getDataFetcher(FieldCoordinates coordinates, GraphQLFieldDefinition fieldDefinition) { return getDataFetcherImpl(coordinates, fieldDefinition, dataFetcherMap, systemDataFetcherMap); }","old_code_raw":"    public DataFetcher getDataFetcher(GraphQLFieldsContainer parentType, GraphQLFieldDefinition fieldDefinition) {\n        return getDataFetcherImpl(parentType, fieldDefinition, dataFetcherMap, systemDataFetcherMap);\n    }\n","new_comment_raw":"Returns a data fetcher associated with a field located at specified coordinates.","old_comment_raw":"Returns a data fetcher associated with a field within a container type","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":24},{"new_code_raw":"private ASN1Primitive toASN1Object( X509Certificate cert ) throws CertificateEncodingException { try { return new ASN1InputStream(cert.getEncoded()).readObject(); } catch (Exception e) { throw new CertificateEncodingException(\"Exception while encoding certificate: \" + e.toString()); } }","old_code_raw":"    private DERObject toASN1Object(\n        X509Certificate cert )\n        throws CertificateEncodingException\n    {\n        try\n        {\n            return new ASN1InputStream(cert.getEncoded()).readObject();\n        }\n        catch (Exception e)\n        {\n            throw new CertificateEncodingException(\"Exception while encoding certificate: \" + e.toString());\n        }\n    }\n","new_comment_raw":"Return a ASN1Primitive containing the encoded certificate.","old_comment_raw":"Return a DERObject containing the encoded certificate.","label":1,"pre_label":0,"AST_level":8,"line_counts":15,"new_code_token_num":52},{"new_code_raw":"public static List<SLARegistrationBean> fromJSONArray(JSONArray array) { List<SLARegistrationBean> list = new ArrayList<SLARegistrationBean>(); for (Object obj : array) { list.add(new SLARegistrationBean((JSONObject) obj)); } return list; }","old_code_raw":"    public static List<SLAEvent> fromJSONArray(JSONArray array) {\n        List<SLAEvent> list = new ArrayList<SLAEvent>();\n        for (Object obj : array) {\n            list.add(new JsonSLARegistrationEvent((JSONObject) obj));\n        }\n        return list;\n    }\n","new_comment_raw":"Convert a JSONArray into a SLARegistrationBean list.","old_comment_raw":"Convert a JSONArray into a SLAEvent list.","label":1,"pre_label":0,"AST_level":9,"line_counts":9,"new_code_token_num":45},{"new_code_raw":"public static EString substring(Expr<String> left, int right) { return factory.createString(Ops.SUBSTR1ARG, left, factory.createConstant(right)); }","old_code_raw":"    public static EString substring(Expr<String> left, int right) {\n        return createString(Ops.SUBSTR1ARG, left, createConstant(right));\n    }\n","new_comment_raw":"Expr : left.substring(right)","old_comment_raw":"Expr : left.substring(right)","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":30},{"new_code_raw":"public boolean isEmpty() { return this.tags.isEmpty(); }","old_code_raw":"        public boolean isEmpty() {\n            return tags.isEmpty();\n        }\n","new_comment_raw":"Checks if the tag stack is empty","old_comment_raw":"DOCUMENT ME!","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":14},{"new_code_raw":"public ReadWritableInstantFieldProperty millisOfDay() { return new ReadWritableInstantFieldProperty(this, getChronology().millisOfDay()); }","old_code_raw":"    public MutableDateTimeFieldProperty millisOfDay() {\n        return new MutableDateTimeFieldProperty(this, getChronology().millisOfDay());\n    }\n","new_comment_raw":"Get the millis of day property","old_comment_raw":"Get the millis of day property","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":21},{"new_code_raw":"private boolean onTouchForwarded(MotionEvent srcEvent) { final View src = mSrcIcon; final DeepShortcutsContainer dst = mLauncher.getOpenShortcutsContainer(); if (dst == null) { return false; } if (!dst.isLaidOut()) { return true; } \/\/ Convert event to destination-local coordinates. final MotionEvent dstEvent = MotionEvent.obtainNoHistory(srcEvent); Utilities.translateEventCoordinates(src, dst, dstEvent); \/\/ Convert touch down event to destination-local coordinates. if (!mHasMappedTouchDownToContainerCoord) { mDragLayer.mapCoordInSelfToDescendent(dst, mTouchDown); mHasMappedTouchDownToContainerCoord = true; } \/\/ Forward converted event to destination view, then recycle it. final boolean handled = dst.onForwardedEvent(dstEvent, mActivePointerId, mTouchDown); dstEvent.recycle(); \/\/ Always cancel forwarding when the touch stream ends. final int action = srcEvent.getActionMasked(); final boolean keepForwarding = action != MotionEvent.ACTION_UP && action != MotionEvent.ACTION_CANCEL; return handled && keepForwarding; }","old_code_raw":"    private boolean onTouchForwarded(MotionEvent srcEvent) {\n        final View src = mSrcIcon;\n\n        final DeepShortcutsContainer dst = mLauncher.getOpenShortcutsContainer();\n        if (dst == null) {\n            return false;\n        }\n\n        \/\/ Convert event to destination-local coordinates.\n        final MotionEvent dstEvent = MotionEvent.obtainNoHistory(srcEvent);\n        Utilities.translateEventCoordinates(src, dst, dstEvent);\n\n        \/\/ Forward converted event to destination view, then recycle it.\n        \/\/ TODO: don't create objects in onForwardedEvent.\n        final boolean handled = dst.onForwardedEvent(dstEvent, mActivePointerId, mTouchDown);\n        dstEvent.recycle();\n\n        \/\/ Always cancel forwarding when the touch stream ends.\n        final int action = srcEvent.getActionMasked();\n        final boolean keepForwarding = action != MotionEvent.ACTION_UP\n                && action != MotionEvent.ACTION_CANCEL;\n\n        return handled && keepForwarding;\n    }\n","new_comment_raw":"Handles forwarded motion events and determines when to stop forwarding.","old_comment_raw":"Handles forwarded motion events and determines when to stop forwarding.","label":0,"pre_label":1,"AST_level":7,"line_counts":33,"new_code_token_num":170},{"new_code_raw":"public List<RelationTriple> extract(SemanticGraph parse, List<CoreLabel> tokens) { List<RelationTriple> extractions = new ArrayList<>(); Set<Triple<Span,String,Span>> alreadyExtracted = new HashSet<>(); \/\/ Run Token Patterns for (TokenSequencePattern tokenPattern : NOUN_TOKEN_PATTERNS) { TokenSequenceMatcher tokenMatcher = tokenPattern.matcher(tokens); while (tokenMatcher.find()) { \/\/ Create subject List<? extends CoreMap> subject = tokenMatcher.groupNodes(\"$subject\"); Span subjectSpan = Util.extractNER(tokens, Span.fromValues(((CoreLabel) subject.get(0)).index() - 1, ((CoreLabel) subject.get(subject.size() - 1)).index())); List<CoreLabel> subjectTokens = new ArrayList<>(); for (int i : subjectSpan) { subjectTokens.add(tokens.get(i)); } \/\/ Create object List<? extends CoreMap> object = tokenMatcher.groupNodes(\"$object\"); Span objectSpan = Util.extractNER(tokens, Span.fromValues(((CoreLabel) object.get(0)).index() - 1, ((CoreLabel) object.get(object.size() - 1)).index())); if (Span.overlaps(subjectSpan, objectSpan)) { continue; } List<CoreLabel> objectTokens = new ArrayList<>(); for (int i : objectSpan) { objectTokens.add(tokens.get(i)); } \/\/ Create relation if (subjectTokens.size() > 0 && objectTokens.size() > 0) { List<CoreLabel> relationTokens = new ArrayList<>(); \/\/ (add the 'be') relationTokens.add(new CoreLabel() {{ setWord(\"is\"); setLemma(\"be\"); setTag(\"VBZ\"); setNER(\"O\"); setBeginPosition(subjectTokens.get(subjectTokens.size() - 1).endPosition()); setEndPosition(subjectTokens.get(subjectTokens.size() - 1).endPosition()); setSentIndex(subjectTokens.get(subjectTokens.size() - 1).sentIndex()); setIndex(-1); }}); \/\/ (add a complement to the 'be') List<? extends CoreMap> beofComp = tokenMatcher.groupNodes(\"$beof_comp\"); if (beofComp != null) { \/\/ (add the complement for (CoreMap token : beofComp) { if (token instanceof CoreLabel) { relationTokens.add((CoreLabel) token); } else { relationTokens.add(new CoreLabel(token)); } } \/\/ (add the 'of') relationTokens.add(new CoreLabel() {{ setWord(\"of\"); setLemma(\"of\"); setTag(\"IN\"); setNER(\"O\"); setBeginPosition(objectTokens.get(0).beginPosition()); setEndPosition(objectTokens.get(0).beginPosition()); setSentIndex(objectTokens.get(0).sentIndex()); setIndex(-1); }}); } \/\/ Add extraction String relationGloss = StringUtils.join(relationTokens.stream().map(CoreLabel::word), \" \"); if (!alreadyExtracted.contains(Triple.makeTriple(subjectSpan, relationGloss, objectSpan))) { extractions.add(new RelationTriple(subjectTokens, relationTokens, objectTokens)); alreadyExtracted.add(Triple.makeTriple(subjectSpan, relationGloss, objectSpan)); } } } \/\/ Run Semgrex Matches for (SemgrexPattern semgrex : NOUN_DEPENDENCY_PATTERNS) { SemgrexMatcher matcher = semgrex.matcher(parse); while (matcher.find()) { \/\/ Create subject IndexedWord subject = matcher.getNode(\"subject\"); Span subjectSpan = Util.extractNER(tokens, Span.fromValues(subject.index() - 1, subject.index())); List<CoreLabel> subjectTokens = new ArrayList<>(); for (int i : subjectSpan) { subjectTokens.add(tokens.get(i)); } \/\/ Create object IndexedWord object = matcher.getNode(\"object\"); Span objectSpan = Util.extractNER(tokens, Span.fromValues(object.index() - 1, object.index())); List<CoreLabel> objectTokens = new ArrayList<>(); for (int i : objectSpan) { objectTokens.add(tokens.get(i)); } \/\/ Check that the pair is valid if (Span.overlaps(subjectSpan, objectSpan)) { continue; \/\/ We extracted an identity } if (subjectSpan.end() == objectSpan.start() - 1 && (tokens.get(subjectSpan.end()).word().matches(\"[\\\\.,:;\\\\('\\\"]\") || \"CC\".equals(tokens.get(subjectSpan.end()).tag()))) { continue; \/\/ We're straddling a clause } if (objectSpan.end() == subjectSpan.start() - 1 && (tokens.get(objectSpan.end()).word().matches(\"[\\\\.,:;\\\\('\\\"]\") || \"CC\".equals(tokens.get(objectSpan.end()).tag()))) { continue; \/\/ We're straddling a clause } \/\/ Get the relation if (subjectTokens.size() > 0 && objectTokens.size() > 0) { LinkedList<CoreLabel> relationTokens = new LinkedList<>(); IndexedWord relNode = matcher.getNode(\"relation\"); if (relNode != null) { \/\/ (add the relation) relationTokens.add(relNode.backingLabel()); \/\/ (check for aux information) String relaux = matcher.getRelnString(\"relaux\"); if (relaux != null && relaux.startsWith(\"nmod:\") && !\"nmod:poss\".equals(relaux)) { relationTokens.add(new CoreLabel() {{ setWord(relaux.substring(\"nmod:\".length())); setLemma(relaux.substring(\"nmod:\".length())); setTag(\"PP\"); setNER(\"O\"); setBeginPosition(subjectTokens.get(subjectTokens.size() - 1).endPosition()); setEndPosition(subjectTokens.get(subjectTokens.size() - 1).endPosition()); setSentIndex(subjectTokens.get(subjectTokens.size() - 1).sentIndex()); setIndex(-1); }}); } else if (relaux != null && \"nmod:poss\".equals(relaux)) { relationTokens.addFirst(new CoreLabel() {{ setWord(\"'s\"); setLemma(\"'s\"); setTag(\"PP\"); setNER(\"O\"); setBeginPosition(subjectTokens.get(subjectTokens.size() - 1).endPosition()); setEndPosition(subjectTokens.get(subjectTokens.size() - 1).endPosition()); setSentIndex(subjectTokens.get(subjectTokens.size() - 1).sentIndex()); setIndex(-1); }}); relationTokens.addLast(new CoreLabel() {{ setWord(\"is\"); setLemma(\"be\"); setTag(\"VBZ\"); setNER(\"O\"); setBeginPosition(subjectTokens.get(subjectTokens.size() - 1).endPosition()); setEndPosition(subjectTokens.get(subjectTokens.size() - 1).endPosition()); setSentIndex(subjectTokens.get(subjectTokens.size() - 1).sentIndex()); setIndex(-1); }}); } } else { \/\/ (add the 'be') relationTokens.add(new CoreLabel() {{ setWord(\"is\"); setLemma(\"be\"); setTag(\"VBZ\"); setNER(\"O\"); setBeginPosition(subjectTokens.get(subjectTokens.size() - 1).endPosition()); setEndPosition(subjectTokens.get(subjectTokens.size() - 1).endPosition()); setSentIndex(subjectTokens.get(subjectTokens.size() - 1).sentIndex()); setIndex(-1); }}); \/\/ (add an optional prep) String rel = matcher.getRelnString(\"relation\"); String prep = null; if (rel != null && rel.startsWith(\"nmod:\") && !\"nmod:poss\".equals(rel)) { prep = rel.substring(\"nmod:\".length()); } else if (rel != null && (rel.startsWith(\"acl:\") || rel.startsWith(\"advcl:\")) ) { prep = rel.substring(rel.indexOf(\":\")); } else if (rel != null && rel.equals(\"nmod:poss\")) { relationTokens.clear(); prep = \"'s\"; } if (prep != null) { final String p = prep; relationTokens.add(new CoreLabel() {{ setWord(p); setLemma(p); setTag(\"PP\"); setNER(\"O\"); setBeginPosition(subjectTokens.get(subjectTokens.size() - 1).endPosition()); setEndPosition(subjectTokens.get(subjectTokens.size() - 1).endPosition()); setSentIndex(subjectTokens.get(subjectTokens.size() - 1).sentIndex()); setIndex(-1); }}); } } \/\/ Add extraction String relationGloss = StringUtils.join(relationTokens.stream().map(CoreLabel::word), \" \"); if (!alreadyExtracted.contains(Triple.makeTriple(subjectSpan, relationGloss, objectSpan))) { extractions.add(new RelationTriple(subjectTokens, relationTokens, objectTokens)); alreadyExtracted.add(Triple.makeTriple(subjectSpan, relationGloss, objectSpan)); } } } } } \/\/ Filter downward polarity extractions Iterator<RelationTriple> iter = extractions.iterator(); while (iter.hasNext()) { RelationTriple term = iter.next(); boolean shouldRemove = false; for (CoreLabel token : term) { if (token.get(NaturalLogicAnnotations.PolarityAnnotation.class) != null && token.get(NaturalLogicAnnotations.PolarityAnnotation.class).isDownwards() ) { shouldRemove = true; } } if (shouldRemove) { iter.remove(); } \/\/ Don't extract things in downward polarity contexts. } \/\/ Return return extractions; }","old_code_raw":"  public List<RelationTriple> extract(SemanticGraph parse, List<CoreLabel> tokens) {\n    List<RelationTriple> extractions = new ArrayList<>();\n    Set<Triple<Span,String,Span>> alreadyExtracted = new HashSet<>();\n\n    \/\/\n    \/\/ Run Token Patterns\n    \/\/\n    for (TokenSequencePattern tokenPattern : NOUN_TOKEN_PATTERNS) {\n      TokenSequenceMatcher tokenMatcher = tokenPattern.matcher(tokens);\n      while (tokenMatcher.find()) {\n        boolean missingPrefixBe;\n        boolean missingSuffixOf = false;\n\n        \/\/ Create subject\n        List<? extends CoreMap> subject = tokenMatcher.groupNodes(\"$subject\");\n        Span subjectSpan = Util.extractNER(tokens, Span.fromValues(((CoreLabel) subject.get(0)).index() - 1, ((CoreLabel) subject.get(subject.size() - 1)).index()));\n        List<CoreLabel> subjectTokens = new ArrayList<>();\n        for (int i : subjectSpan) {\n          subjectTokens.add(tokens.get(i));\n        }\n\n        \/\/ Create object\n        List<? extends CoreMap> object = tokenMatcher.groupNodes(\"$object\");\n        Span objectSpan = Util.extractNER(tokens, Span.fromValues(((CoreLabel) object.get(0)).index() - 1, ((CoreLabel) object.get(object.size() - 1)).index()));\n        if (Span.overlaps(subjectSpan, objectSpan)) {\n          continue;\n        }\n        List<CoreLabel> objectTokens = new ArrayList<>();\n        for (int i : objectSpan) {\n          objectTokens.add(tokens.get(i));\n        }\n\n        \/\/ Create relation\n        if (subjectTokens.size() > 0 && objectTokens.size() > 0) {\n          List<CoreLabel> relationTokens = new ArrayList<>();\n          \/\/ (add the 'be')\n          missingPrefixBe = true;\n          \/\/ (add a complement to the 'be')\n          List<? extends CoreMap> beofComp = tokenMatcher.groupNodes(\"$beof_comp\");\n          if (beofComp != null) {\n            \/\/ (add the complement\n            for (CoreMap token : beofComp) {\n              if (token instanceof CoreLabel) {\n                relationTokens.add((CoreLabel) token);\n              } else {\n                relationTokens.add(new CoreLabel(token));\n              }\n            }\n            \/\/ (add the 'of')\n            missingSuffixOf = true;\n          }\n          \/\/ Add extraction\n          String relationGloss = StringUtils.join(relationTokens.stream().map(CoreLabel::word), \" \");\n          if (!alreadyExtracted.contains(Triple.makeTriple(subjectSpan, relationGloss, objectSpan))) {\n            RelationTriple extraction = new RelationTriple(subjectTokens, relationTokens, objectTokens);\n            \/\/noinspection ConstantConditions\n            extraction.isPrefixBe(missingPrefixBe);\n            extraction.isSuffixOf(missingSuffixOf);\n            extractions.add(extraction);\n            alreadyExtracted.add(Triple.makeTriple(subjectSpan, relationGloss, objectSpan));\n          }\n        }\n      }\n\n      \/\/\n      \/\/ Run Semgrex Matches\n      \/\/\n      for (SemgrexPattern semgrex : NOUN_DEPENDENCY_PATTERNS) {\n        SemgrexMatcher matcher = semgrex.matcher(parse);\n        while (matcher.find()) {\n          boolean missingPrefixBe = false;\n          boolean missingSuffixBe = false;\n          boolean istmod = false;\n\n          \/\/ Get relaux if applicable\n          String relaux = matcher.getRelnString(\"relaux\");\n          String ignoredArc = relaux;\n          if (ignoredArc == null) {\n            ignoredArc = matcher.getRelnString(\"arc\");\n          }\n\n          \/\/ Create subject\n          IndexedWord subject = matcher.getNode(\"subject\");\n          List<IndexedWord> subjectTokens = new ArrayList<>();\n          Span subjectSpan;\n          if (subject.ner() != null && !\"O\".equals(subject.ner())) {\n            subjectSpan = Util.extractNER(tokens, Span.fromValues(subject.index() - 1, subject.index()));\n            for (int i : subjectSpan) {\n              subjectTokens.add(new IndexedWord(tokens.get(i)));\n            }\n          } else {\n            subjectTokens = getValidChunk(parse, subject, VALID_SUBJECT_ARCS, Optional.ofNullable(ignoredArc), true).orElse(Collections.singletonList(subject));\n            subjectSpan = Util.tokensToSpan(subjectTokens);\n          }\n\n          \/\/ Create object\n          IndexedWord object = matcher.getNode(\"object\");\n          List<IndexedWord> objectTokens = new ArrayList<>();\n          Span objectSpan;\n          if (object.ner() != null && !\"O\".equals(object.ner())) {\n            objectSpan = Util.extractNER(tokens, Span.fromValues(object.index() - 1, object.index()));\n            for (int i : objectSpan) {\n              objectTokens.add(new IndexedWord(tokens.get(i)));\n            }\n          } else {\n            objectTokens = getValidChunk(parse, object, VALID_OBJECT_ARCS, Optional.ofNullable(ignoredArc), true).orElse(Collections.singletonList(object));\n            objectSpan = Util.tokensToSpan(objectTokens);\n          }\n\n          \/\/ Check that the pair is valid\n          if (Span.overlaps(subjectSpan, objectSpan)) {\n            continue;  \/\/ We extracted an identity\n          }\n          if (subjectSpan.end() == objectSpan.start() - 1 &&\n              (tokens.get(subjectSpan.end()).word().matches(\"[\\\\.,:;\\\\('\\\"]\") ||\n                  \"CC\".equals(tokens.get(subjectSpan.end()).tag()))) {\n            continue; \/\/ We're straddling a clause\n          }\n          if (objectSpan.end() == subjectSpan.start() - 1 &&\n              (tokens.get(objectSpan.end()).word().matches(\"[\\\\.,:;\\\\('\\\"]\") ||\n                  \"CC\".equals(tokens.get(objectSpan.end()).tag()))) {\n            continue; \/\/ We're straddling a clause\n          }\n\n          \/\/ Get any prepositional edges\n          String expected = relaux == null ? \"\" : relaux.substring(relaux.indexOf(\":\") + 1).replace(\"_\", \" \");\n          IndexedWord prepWord = null;\n          \/\/ (these usually come from the object)\n          boolean prepositionIsPrefix = false;\n          for (SemanticGraphEdge edge : parse.outgoingEdgeIterable(object)) {\n            if (edge.getRelation().toString().equals(\"case\")) {\n              prepWord = edge.getDependent();\n            }\n          }\n          \/\/ (...but sometimes from the subject)\n          if (prepWord == null) {\n            for (SemanticGraphEdge edge : parse.outgoingEdgeIterable(subject)) {\n              if (edge.getRelation().toString().equals(\"case\")) {\n                prepositionIsPrefix = true;\n                prepWord = edge.getDependent();\n              }\n            }\n          }\n          List<IndexedWord> prepChunk = Collections.EMPTY_LIST;\n          if (prepWord != null && !expected.equals(\"tmod\")) {\n            Optional<List<IndexedWord>> optionalPrepChunk = getValidChunk(parse, prepWord, Collections.singleton(\"mwe\"), Optional.empty(), true);\n            if (!optionalPrepChunk.isPresent()) { continue; }\n            prepChunk = optionalPrepChunk.get();\n            Collections.sort(prepChunk, (a, b) -> {\n              double val = a.pseudoPosition() - b.pseudoPosition();\n              if (val < 0) { return -1; }\n              if (val > 0) { return 1; }\n              else { return 0; }\n            });  \/\/ ascending sort\n          }\n\n          \/\/ Get the relation\n          if (subjectTokens.size() > 0 && objectTokens.size() > 0) {\n            LinkedList<IndexedWord> relationTokens = new LinkedList<>();\n            IndexedWord relNode = matcher.getNode(\"relation\");\n            if (relNode != null) {\n\n              \/\/ Case: we have a grounded relation span\n              \/\/ (add the relation)\n              relationTokens.add(relNode);\n              \/\/ (add any prepositional case markings)\n              if (prepositionIsPrefix) {\n                missingSuffixBe = true;  \/\/ We're almost certainly missing a suffix 'be'\n                for (int i = prepChunk.size() - 1; i >=0; --i) { relationTokens.addFirst(prepChunk.get(i)); }\n              } else {\n                relationTokens.addAll(prepChunk);\n              }\n              if (expected.equalsIgnoreCase(\"tmod\")) {\n                istmod = true;\n              }\n\n            } else {\n\n              \/\/ Case: we have a hallucinated relation span\n              \/\/ (mark it as missing a preceding 'be'\n              if (!expected.equals(\"poss\")) {\n                missingPrefixBe = true;\n              }\n              \/\/ (add any prepositional case markings)\n              if (prepositionIsPrefix) {\n                for (int i = prepChunk.size() - 1; i >=0; --i) { relationTokens.addFirst(prepChunk.get(i)); }\n              } else {\n                relationTokens.addAll(prepChunk);\n              }\n              if (expected.equalsIgnoreCase(\"tmod\")) {\n                istmod = true;\n              }\n              \/\/ (some fine-tuning)\n              if (allowNominalsWithoutNER && \"of\".equals(expected)) {\n                continue;  \/\/ prohibit things like \"conductor of electricity\" -> \"conductor; be of; electricity\"\n              }\n            }\n\n\n            \/\/ Add extraction\n            String relationGloss = StringUtils.join(relationTokens.stream().map(IndexedWord::word), \" \");\n            if (!alreadyExtracted.contains(Triple.makeTriple(subjectSpan, relationGloss, objectSpan))) {\n              RelationTriple extraction = new RelationTriple(\n                  subjectTokens.stream().map(IndexedWord::backingLabel).collect(Collectors.toList()),\n                  relationTokens.stream().map(IndexedWord::backingLabel).collect(Collectors.toList()),\n                  objectTokens.stream().map(IndexedWord::backingLabel).collect(Collectors.toList()));\n              extraction.istmod(istmod);\n              extraction.isPrefixBe(missingPrefixBe);\n              extraction.isSuffixBe(missingSuffixBe);\n              extractions.add(extraction);\n              alreadyExtracted.add(Triple.makeTriple(subjectSpan, relationGloss, objectSpan));\n            }\n          }\n        }\n      }\n    }\n\n    \/\/\n    \/\/ Filter downward polarity extractions\n    \/\/\n    Iterator<RelationTriple> iter = extractions.iterator();\n    while (iter.hasNext()) {\n      RelationTriple term = iter.next();\n      boolean shouldRemove = true;\n      for (CoreLabel token : term) {\n        if (token.get(NaturalLogicAnnotations.PolarityAnnotation.class) == null ||\n            !token.get(NaturalLogicAnnotations.PolarityAnnotation.class).isDownwards() ) {\n          shouldRemove = false;\n        }\n      }\n      if (shouldRemove) {\n        iter.remove();   \/\/ Don't extract things in downward polarity contexts.\n      }\n    }\n\n    \/\/ Return\n    return extractions;\n  }\n","new_comment_raw":"Extract the nominal patterns from this sentence.","old_comment_raw":"Extract the nominal patterns from this sentence.","label":0,"pre_label":1,"AST_level":20,"line_counts":211,"new_code_token_num":1959},{"new_code_raw":"public String toHexString(final int start, final int length) { Preconditions.checkArgument(start >= 0); final StringBuilder sb = new StringBuilder(\"buffer byte dump\"); final int end = Math.min(length, this.length - start); for (int i = 0; i < end; i++) { if (i % LOG_BYTES_PER_ROW == 0) { sb.append(String.format(\"%n [%05d-%05d]\", i + start, Math.min(i + LOG_BYTES_PER_ROW - 1, end - 1) + start)); } byte b = _getByte(i + start); sb.append(\" 0x\").append(HEX_CHAR[b >> 4]).append(HEX_CHAR[b & 0x0F]); } if (length > end) { sb.append(String.format(\"%n [%05d-%05d] <ioob>\", start + end, start + length)); } return sb.append(System.lineSeparator()).toString(); }","old_code_raw":"  public String toHexString(final int start, final int length) {\n    final int roundedStart = (start \/ LOG_BYTES_PER_ROW) * LOG_BYTES_PER_ROW;\n\n    final StringBuilder sb = new StringBuilder(\"buffer byte dump\\n\");\n    int index = roundedStart;\n    for (int nLogged = 0; nLogged < length; nLogged += LOG_BYTES_PER_ROW) {\n      sb.append(String.format(\" [%05d-%05d]\", index, index + LOG_BYTES_PER_ROW - 1));\n      for (int i = 0; i < LOG_BYTES_PER_ROW; ++i) {\n        try {\n          final byte b = getByte(index++);\n          sb.append(String.format(\" 0x%02x\", b));\n        } catch (IndexOutOfBoundsException ioob) {\n          sb.append(\" <ioob>\");\n        }\n      }\n      sb.append('\\n');\n    }\n    return sb.toString();\n  }\n","new_comment_raw":"Return the buffer's byte contents in the form of a hex dump.","old_comment_raw":"Return the buffer's byte contents in the form of a hex dump.","label":0,"pre_label":1,"AST_level":14,"line_counts":17,"new_code_token_num":195},{"new_code_raw":"public int yylex() throws java.io.IOException { int yy_input; int yy_action; \/\/ cached fields: int yy_currentPos_l; int yy_startRead_l; int yy_markedPos_l; int yy_endRead_l = yy_endRead; char[] yy_buffer_l = yy_buffer; char[] yycmap_l = yycmap; int[] yytrans_l = yytrans; int[] yy_rowMap_l = yy_rowMap; byte[] yy_attr_l = YY_ATTRIBUTE; while (true) { yy_markedPos_l = yy_markedPos; yy_action = -1; yy_startRead_l = yy_currentPos_l = yy_currentPos = yy_startRead = yy_markedPos_l; yy_state = yy_lexical_state; yy_forAction: { while (true) { if (yy_currentPos_l < yy_endRead_l) { yy_input = yy_buffer_l[yy_currentPos_l++]; } else if (yy_atEOF) { yy_input = YYEOF; break yy_forAction; } else { \/\/ store back cached positions yy_currentPos = yy_currentPos_l; yy_markedPos = yy_markedPos_l; boolean eof = yy_refill(); \/\/ get translated positions and possibly new buffer yy_currentPos_l = yy_currentPos; yy_markedPos_l = yy_markedPos; yy_buffer_l = yy_buffer; yy_endRead_l = yy_endRead; if (eof) { yy_input = YYEOF; break yy_forAction; } else { yy_input = yy_buffer_l[yy_currentPos_l++]; } } int yy_next = yytrans_l[yy_rowMap_l[yy_state] + yycmap_l[yy_input]]; if (yy_next == -1) { break yy_forAction; } yy_state = yy_next; int yy_attributes = yy_attr_l[yy_state]; if ((yy_attributes & 1) == 1) { yy_action = yy_state; yy_markedPos_l = yy_currentPos_l; if ((yy_attributes & 8) == 8) { break yy_forAction; } } } } \/\/ store back cached position yy_markedPos = yy_markedPos_l; switch (yy_action) { case 4: case 9: case 10: case 13: { return ACCEPT; } case 19: break; case 5: case 6: case 7: { return IGNORE; } case 20: break; case 2: { return IGNORE; } case 21: break; case 15: { yybegin(SENTENCE); \/* System.out.println(\"Beginning of sentence\"); *\/ return ACCEPT; } case 22: break; case 3: { System.out.print(yytext()); } case 23: break; case 16: case 17: { yybegin(YYINITIAL); \/* System.out.println(\"End of sentence\"); *\/ return ACCEPT; } case 24: break; default: if (yy_input == YYEOF && yy_startRead == yy_currentPos) { yy_atEOF = true; return YYEOF; } else { yy_ScanError(YY_NO_MATCH); } } } }","old_code_raw":"  public int yylex() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    \/\/ cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            \/\/ store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            \/\/ get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          int zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      \/\/ store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 5: \n          { yybegin(YYINITIAL);\n                     \/* System.out.println(\"End of sentence\"); *\/\n                            return ACCEPT;\n          }\n        case 6: break;\n        case 3: \n          { return ACCEPT;\n          }\n        case 7: break;\n        case 4: \n          { yybegin(SENTENCE);\n\t\t\t  \/* System.out.println(\"Beginning of sentence\"); *\/\n\t\t\t  return ACCEPT;\n          }\n        case 8: break;\n        case 2: \n          { System.out.print(yytext());\n          }\n        case 9: break;\n        case 1: \n          { return IGNORE;\n          }\n        case 10: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            return YYEOF;\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n","new_comment_raw":"Resumes scanning until the next regular expression is matched, the end of input is encountered or an I\/O-Error occurs.","old_comment_raw":"Resumes scanning until the next regular expression is matched, the end of input is encountered or an I\/O-Error occurs.","label":0,"pre_label":1,"AST_level":17,"line_counts":131,"new_code_token_num":441},{"new_code_raw":"public boolean equals(Object obj) { return this == obj || (obj instanceof Pair) && Util.equal(this.left, ((Pair) obj).left) && Util.equal(this.right, ((Pair) obj).right); }","old_code_raw":"    public boolean equals(Object obj)\n    {\n        return (obj instanceof Pair)\n            && Util.equal(this.left, ((Pair) obj).left)\n            && Util.equal(this.right, ((Pair) obj).right);\n    }\n","new_comment_raw":"Creates a Pair of appropriate type.","old_comment_raw":"Creates a Pair of appropriate type.","label":0,"pre_label":1,"AST_level":9,"line_counts":8,"new_code_token_num":52},{"new_code_raw":"public String getAuthor() { return this.author; }","old_code_raw":"    public String getAuthor() {\n        return author;\n    }\n","new_comment_raw":"Return the author","old_comment_raw":"Parse Content.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":11},{"new_code_raw":"public List<Pet> findPetsByTags(List<String> tags) throws ApiException { ApiResponse<List<Pet>> localVarResp = findPetsByTagsWithHttpInfo(tags); return localVarResp.getData(); }","old_code_raw":"    public List<Pet> findPetsByTags(List<String> tags) throws ApiException {\n        ApiResponse<List<Pet>> resp = findPetsByTagsWithHttpInfo(tags);\n        return resp.getData();\n    }\n","new_comment_raw":"Finds Pets by tags","old_comment_raw":"Finds Pets by tags","label":0,"pre_label":1,"AST_level":8,"line_counts":5,"new_code_token_num":28},{"new_code_raw":"public ClassLoader getClassLoader() { SecurityManager smgr = System.getSecurityManager(); ClassLoader loader = getClassLoaderImpl(); if (smgr != null && loader != null) { ClassLoader calling = VMStack.getCallingClassLoader(); if (calling != null && !calling.isAncestorOf(loader)) { smgr.checkPermission(new RuntimePermission(\"getClassLoader\")); } } if (this.isPrimitive()) { return null; } if (loader == null) { loader = BootClassLoader.getInstance(); } return loader; }","old_code_raw":"    public ClassLoader getClassLoader() {\n        SecurityManager smgr = System.getSecurityManager();\n        if (smgr != null) {\n            ClassLoader calling = VMStack.getCallingClassLoader();\n            ClassLoader current = getClassLoaderImpl();\n\n            if (calling != null && !calling.getClass().isInstance(current)) {\n                smgr.checkPermission(new RuntimePermission(\"getClassLoader\"));\n            }\n        }\n        \n        ClassLoader loader = getClassLoaderImpl();\n        if (loader == null) {\n            loader = BootClassLoader.getInstance();\n        }\n        \n        return loader;\n    }\n","new_comment_raw":"Returns the class loader which was used to load the class represented by this  Class.","old_comment_raw":"Returns the class loader which was used to load the class represented by the receiver.","label":1,"pre_label":0,"AST_level":10,"line_counts":23,"new_code_token_num":96},{"new_code_raw":"protected boolean performInitialSync() { try { delaySnapshotIfNeeded(); } catch (InterruptedException e) { logger.info(\"Interrupted while awaiting initial snapshot delay\"); return false; } logger.info(\"Beginning initial sync of '{}' at {}\", rsName, source.lastOffset(rsName)); source.startInitialSync(replicaSet.replicaSetName()); \/\/ Set up our recorder to buffer the last record ... try { bufferedRecorder.startBuffering(); } catch (InterruptedException e) { \/\/ Do nothing so that this thread is terminated ... logger.info(\"Interrupted while waiting to flush the buffer before starting an initial sync of '{}'\", rsName); return false; } \/\/ Get the current timestamp of this processor ... final long syncStart = clock.currentTimeInMillis(); \/\/ We need to copy each collection, so put the collection IDs into a queue ... final List<CollectionId> collections = primaryClient.collections(); final Queue<CollectionId> collectionsToCopy = new ConcurrentLinkedQueue<>(collections); final int numThreads = Math.min(collections.size(), context.getConnectionContext().maxNumberOfCopyThreads()); final CountDownLatch latch = new CountDownLatch(numThreads); final AtomicBoolean aborted = new AtomicBoolean(false); final AtomicInteger replicatorThreadCounter = new AtomicInteger(0); final AtomicInteger numCollectionsCopied = new AtomicInteger(); final AtomicLong numDocumentsCopied = new AtomicLong(); \/\/ And start threads to pull collection IDs from the queue and perform the copies ... logger.info(\"Preparing to use {} thread(s) to sync {} collection(s): {}\", numThreads, collections.size(), Strings.join(\", \", collections)); for (int i = 0; i != numThreads; ++i) { copyThreads.submit(() -> { context.configureLoggingContext(replicaSet.replicaSetName() + \"-sync\" + replicatorThreadCounter.incrementAndGet()); \/\/ Continue to pull a collection ID and copy the collection ... try { CollectionId id = null; while (!aborted.get() && (id = collectionsToCopy.poll()) != null) { long start = clock.currentTimeInMillis(); logger.info(\"Starting initial sync of '{}'\", id); long numDocs = copyCollection(id, syncStart); numCollectionsCopied.incrementAndGet(); numDocumentsCopied.addAndGet(numDocs); long duration = clock.currentTimeInMillis() - start; logger.info(\"Completing initial sync of {} documents from '{}' in {}\", numDocs, id, Strings.duration(duration)); } } catch (InterruptedException e) { \/\/ Do nothing so that this thread is terminated ... aborted.set(true); } finally { latch.countDown(); } }); } \/\/ Wait for all of the threads to complete ... try { latch.await(); } catch (InterruptedException e) { Thread.interrupted(); aborted.set(true); } this.copyThreads.shutdown(); \/\/ Stopping the replicator does not interrupt *our* thread but does interrupt the copy threads. \/\/ Therefore, check the aborted state here ... long syncDuration = clock.currentTimeInMillis() - syncStart; if (aborted.get()) { int remaining = collections.size() - numCollectionsCopied.get(); logger.info(\"Initial sync aborted after {} with {} of {} collections incomplete\", Strings.duration(syncDuration), remaining, collections.size()); return false; } \/\/ We completed the initial sync, so record this in the source ... source.stopInitialSync(replicaSet.replicaSetName()); try { \/\/ And immediately flush the last buffered source record with the updated offset ... bufferedRecorder.stopBuffering(source.lastOffset(rsName)); } catch (InterruptedException e) { logger.info(\"Interrupted while waiting for last initial sync record from replica set '{}' to be recorded\", rsName); return false; } logger.info(\"Initial sync of {} collections with a total of {} documents completed in {}\", collections.size(), numDocumentsCopied.get(), Strings.duration(syncDuration)); return true; }","old_code_raw":"    protected boolean performInitialSync() {\n        delaySnapshotIfNeeded();\n\n        logger.info(\"Beginning initial sync of '{}' at {}\", rsName, source.lastOffset(rsName));\n        source.startInitialSync(replicaSet.replicaSetName());\n\n        \/\/ Set up our recorder to buffer the last record ...\n        try {\n            bufferedRecorder.startBuffering();\n        } catch (InterruptedException e) {\n            \/\/ Do nothing so that this thread is terminated ...\n            logger.info(\"Interrupted while waiting to flush the buffer before starting an initial sync of '{}'\", rsName);\n            return false;\n        }\n\n        \/\/ Get the current timestamp of this processor ...\n        final long syncStart = clock.currentTimeInMillis();\n\n        \/\/ We need to copy each collection, so put the collection IDs into a queue ...\n        final List<CollectionId> collections = primaryClient.collections();\n        final Queue<CollectionId> collectionsToCopy = new ConcurrentLinkedQueue<>(collections);\n        final int numThreads = Math.min(collections.size(), context.getConnectionContext().maxNumberOfCopyThreads());\n        final CountDownLatch latch = new CountDownLatch(numThreads);\n        final AtomicBoolean aborted = new AtomicBoolean(false);\n        final AtomicInteger replicatorThreadCounter = new AtomicInteger(0);\n        final AtomicInteger numCollectionsCopied = new AtomicInteger();\n        final AtomicLong numDocumentsCopied = new AtomicLong();\n\n        \/\/ And start threads to pull collection IDs from the queue and perform the copies ...\n        logger.info(\"Preparing to use {} thread(s) to sync {} collection(s): {}\",\n                    numThreads, collections.size(), Strings.join(\", \", collections));\n        for (int i = 0; i != numThreads; ++i) {\n            copyThreads.submit(() -> {\n                context.configureLoggingContext(replicaSet.replicaSetName() + \"-sync\" + replicatorThreadCounter.incrementAndGet());\n                \/\/ Continue to pull a collection ID and copy the collection ...\n                try {\n                    CollectionId id = null;\n                    while (!aborted.get() && (id = collectionsToCopy.poll()) != null) {\n                        long start = clock.currentTimeInMillis();\n                        logger.info(\"Starting initial sync of '{}'\", id);\n                        long numDocs = copyCollection(id, syncStart);\n                        numCollectionsCopied.incrementAndGet();\n                        numDocumentsCopied.addAndGet(numDocs);\n                        long duration = clock.currentTimeInMillis() - start;\n                        logger.info(\"Completing initial sync of {} documents from '{}' in {}\", numDocs, id, Strings.duration(duration));\n                    }\n                } catch (InterruptedException e) {\n                    \/\/ Do nothing so that this thread is terminated ...\n                    aborted.set(true);\n                } finally {\n                    latch.countDown();\n                }\n            });\n        }\n\n        \/\/ Wait for all of the threads to complete ...\n        try {\n            latch.await();\n        } catch (InterruptedException e) {\n            Thread.interrupted();\n            aborted.set(true);\n        }\n        this.copyThreads.shutdown();\n\n        \/\/ Stopping the replicator does not interrupt *our* thread but does interrupt the copy threads.\n        \/\/ Therefore, check the aborted state here ...\n        long syncDuration = clock.currentTimeInMillis() - syncStart;\n        if (aborted.get()) {\n            int remaining = collections.size() - numCollectionsCopied.get();\n            logger.info(\"Initial sync aborted after {} with {} of {} collections incomplete\",\n                        Strings.duration(syncDuration), remaining, collections.size());\n            return false;\n        }\n\n        \/\/ We completed the initial sync, so record this in the source ...\n        source.stopInitialSync(replicaSet.replicaSetName());\n        try {\n            \/\/ And immediately flush the last buffered source record with the updated offset ...\n            bufferedRecorder.stopBuffering(source.lastOffset(rsName));\n        } catch (InterruptedException e) {\n            logger.info(\"Interrupted while waiting for last initial sync record from replica set '{}' to be recorded\", rsName);\n            return false;\n        }\n\n        logger.info(\"Initial sync of {} collections with a total of {} documents completed in {}\",\n                    collections.size(), numDocumentsCopied.get(), Strings.duration(syncDuration));\n        return true;\n    }\n","new_comment_raw":"Perform the initial sync of the collections in the replica set.","old_comment_raw":"Perform the initial sync of the collections in the replica set.","label":0,"pre_label":1,"AST_level":14,"line_counts":95,"new_code_token_num":780},{"new_code_raw":"public boolean hasParams() { return !cookieParams.isEmpty() || !urlParams.isEmpty() || !formParams.isEmpty() || !headerParams.isEmpty(); }","old_code_raw":"\tpublic boolean hasParams() {\n\t\treturn !cookieParams.isEmpty() || !urlParams.isEmpty() || !formParams.isEmpty();\n\t}\n","new_comment_raw":"Tells whether or not this site has any parameters (cookies, query, form parameters, or response header fields).","old_comment_raw":"Tells whether or not this site has any parameters (cookies, query or form parameters).","label":1,"pre_label":0,"AST_level":7,"line_counts":4,"new_code_token_num":35},{"new_code_raw":"public LocalDate getDate() { return new LocalDate(getLocalMillis(), getChronology()); }","old_code_raw":"    public LocalDate getDate() {\n        return new LocalDate(\n                getYear(), getMonthOfYear(), getDayOfMonth(), getChronology());\n    }\n","new_comment_raw":"Converts this object to a LocalDate with the same date and chronology.","old_comment_raw":"Converts this object to a LocalDate with the same date and chronology.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"public Future<HttpResponse> executeAsync(Executor executor) { FutureTask<HttpResponse> future = new FutureTask<HttpResponse>(new Callable<HttpResponse>() { public HttpResponse call() throws Exception { return execute(); } }); executor.execute(future); return future; }","old_code_raw":"  public Future<HttpResponse> executeAsync(Executor exec) {\n    final SettableFuture<HttpResponse> future = SettableFuture.create();\n    exec.execute(new Runnable() {\n      public void run() {\n        try {\n          future.set(execute());\n        } catch (IOException ex) {\n          future.setException(ex);\n        }\n      }\n    });\n    return future;\n  }\n","new_comment_raw":"Executes this request asynchronously in a single separate thread using the supplied executor.","old_comment_raw":"Executes this request asynchronously using #executeAsync(Executor) in a single separate thread using the supplied Executor.","label":1,"pre_label":0,"AST_level":9,"line_counts":12,"new_code_token_num":49},{"new_code_raw":"public Object readObject() throws JMSException { initializeReading(); try { this.dataIn.mark(65); int type = this.dataIn.read(); if (type == -1) { throw new MessageEOFException(\"reached end of data\"); } if (type == MarshallingSupport.NULL) { return null; } if (type == MarshallingSupport.BIG_STRING_TYPE) { return MarshallingSupport.readUTF8(dataIn); } if (type == MarshallingSupport.STRING_TYPE) { return this.dataIn.readUTF(); } if (type == MarshallingSupport.LONG_TYPE) { return Long.valueOf(this.dataIn.readLong()); } if (type == MarshallingSupport.INTEGER_TYPE) { return Integer.valueOf(this.dataIn.readInt()); } if (type == MarshallingSupport.SHORT_TYPE) { return Short.valueOf(this.dataIn.readShort()); } if (type == MarshallingSupport.BYTE_TYPE) { return Byte.valueOf(this.dataIn.readByte()); } if (type == MarshallingSupport.FLOAT_TYPE) { return new Float(this.dataIn.readFloat()); } if (type == MarshallingSupport.DOUBLE_TYPE) { return new Double(this.dataIn.readDouble()); } if (type == MarshallingSupport.BOOLEAN_TYPE) { return this.dataIn.readBoolean() ? Boolean.TRUE : Boolean.FALSE; } if (type == MarshallingSupport.CHAR_TYPE) { return Character.valueOf(this.dataIn.readChar()); } if (type == MarshallingSupport.BYTE_ARRAY_TYPE) { int len = this.dataIn.readInt(); byte[] value = new byte[len]; this.dataIn.readFully(value); return value; } else { this.dataIn.reset(); throw new MessageFormatException(\"unknown type\"); } } catch (NumberFormatException mfe) { try { this.dataIn.reset(); } catch (IOException ioe) { throw JMSExceptionSupport.create(ioe); } throw mfe; } catch (EOFException e) { JMSException jmsEx = new MessageEOFException(e.getMessage()); jmsEx.setLinkedException(e); throw jmsEx; } catch (IOException e) { JMSException jmsEx = new MessageFormatException(e.getMessage()); jmsEx.setLinkedException(e); throw jmsEx; } }","old_code_raw":"    public Object readObject() throws JMSException {\n        initializeReading();\n        try {\n            this.dataIn.mark(65);\n            int type = this.dataIn.read();\n            if (type == -1) {\n                throw new MessageEOFException(\"reached end of data\");\n            }\n            if (type == MarshallingSupport.NULL) {\n                return null;\n            }\n            if (type == MarshallingSupport.BIG_STRING_TYPE) {\n                return MarshallingSupport.readUTF8(dataIn);\n            }\n            if (type == MarshallingSupport.STRING_TYPE) {\n                return this.dataIn.readUTF();\n            }\n            if (type == MarshallingSupport.LONG_TYPE) {\n                return new Long(this.dataIn.readLong());\n            }\n            if (type == MarshallingSupport.INTEGER_TYPE) {\n                return new Integer(this.dataIn.readInt());\n            }\n            if (type == MarshallingSupport.SHORT_TYPE) {\n                return new Short(this.dataIn.readShort());\n            }\n            if (type == MarshallingSupport.BYTE_TYPE) {\n                return new Byte(this.dataIn.readByte());\n            }\n            if (type == MarshallingSupport.FLOAT_TYPE) {\n                return new Float(this.dataIn.readFloat());\n            }\n            if (type == MarshallingSupport.DOUBLE_TYPE) {\n                return new Double(this.dataIn.readDouble());\n            }\n            if (type == MarshallingSupport.BOOLEAN_TYPE) {\n                return this.dataIn.readBoolean() ? Boolean.TRUE : Boolean.FALSE;\n            }\n            if (type == MarshallingSupport.CHAR_TYPE) {\n                return new Character(this.dataIn.readChar());\n            }\n            if (type == MarshallingSupport.BYTE_ARRAY_TYPE) {\n                int len = this.dataIn.readInt();\n                byte[] value = new byte[len];\n                this.dataIn.readFully(value);\n                return value;\n            } else {\n                this.dataIn.reset();\n                throw new MessageFormatException(\"unknown type\");\n            }\n        } catch (NumberFormatException mfe) {\n            try {\n                this.dataIn.reset();\n            } catch (IOException ioe) {\n                throw JMSExceptionSupport.create(ioe);\n            }\n            throw mfe;\n\n        } catch (EOFException e) {\n            JMSException jmsEx = new MessageEOFException(e.getMessage());\n            jmsEx.setLinkedException(e);\n            throw jmsEx;\n        } catch (IOException e) {\n            JMSException jmsEx = new MessageFormatException(e.getMessage());\n            jmsEx.setLinkedException(e);\n            throw jmsEx;\n        }\n    }\n","new_comment_raw":"Reads an object from the stream message.","old_comment_raw":"Reads an object from the stream message.","label":0,"pre_label":1,"AST_level":9,"line_counts":69,"new_code_token_num":388},{"new_code_raw":"@Processor @OAuthProtected @OAuthInvalidateAccessTokenOn(exception=OAuthTokenExpiredException.class) @Paged public PagingDelegate<Change> listChanges( final @Optional @Default(\"true\") boolean includeDeleted, final @Optional @Default(\"true\") boolean includeSubscribed, final @Optional @Default(\"100\") int maxResults, final @Optional Long startChangeId, final PagingConfiguration pagingConfiguration ) throws IOException { return new TokenBasedPagingDelegate<Change>() { @Override protected List<Change> doGetPage() throws IOException { ChangeList response = client.changes().list() .setIncludeDeleted(includeDeleted) .setIncludeSubscribed(includeSubscribed) .setMaxResults(maxResults) .setPageToken(this.getPageToken()) .setStartChangeId(startChangeId) .execute(); this.setPageToken(response.getNextPageToken()); return Change.valueOf(response.getItems(), Change.class); } }; }","old_code_raw":"\t@Processor\n    @OAuthProtected\n\t@OAuthInvalidateAccessTokenOn(exception=OAuthTokenExpiredException.class)\n\t@Inject\n\tpublic List<Change> listChanges(\n\t\t\tMuleMessage message,\n\t\t\t@Optional @Default(\"true\") boolean includeDeleted,\n\t\t\t@Optional @Default(\"true\") boolean includeSubscribed,\n\t\t\t@Optional @Default(\"100\") int maxResults,\n\t\t\t@Optional @Default(\"#[flowVars['GoogleDrive_NEXT_PAGE_TOKEN']]\") String pageToken,\n\t\t\t@Optional Long startChangeId\n\t\t\t) throws IOException {\n\t\t\n\t\tChangeList response = this.client.changes().list()\n\t\t\t\t\t\t\t\t\t.setIncludeDeleted(includeDeleted)\n\t\t\t\t\t\t\t\t\t.setIncludeSubscribed(includeSubscribed)\n\t\t\t\t\t\t\t\t\t.setMaxResults(maxResults)\n\t\t\t\t\t\t\t\t\t.setPageToken(pageToken)\n\t\t\t\t\t\t\t\t\t.setStartChangeId(startChangeId)\n\t\t\t\t\t\t\t\t\t.execute();\n\t\t\n\t\tPaginationUtils.savePageToken(NEXT_PAGE_TOKEN, response.getNextPageToken(), message);\n\t\t\n\t\treturn Change.valueOf(response.getItems(), Change.class);\n\t}\n","new_comment_raw":"Returns a paginated  Iterator with the  org.mule.module.google.drive.model.Change objects for a user @sample.xml ..\/..\/..\/doc\/GoogleDriveConnector.xml.sample google-drive:list-changes","old_comment_raw":"Lists the changes for a user @sample.xml ..\/..\/..\/doc\/GoogleDriveConnector.xml.sample google-drive:list-changes","label":1,"pre_label":0,"AST_level":11,"line_counts":31,"new_code_token_num":150},{"new_code_raw":"public ArrayList<Activity> getAllOpenedActivities() { ArrayList<Activity> activities = new ArrayList<Activity>(); Iterator<WeakReference<Activity>> activityStackIterator = activityStack.iterator(); while(activityStackIterator.hasNext()){ Activity activity = activityStackIterator.next().get(); if(activity!=null) activities.add(activity); } return activities; }","old_code_raw":"\tpublic ArrayList<Activity> getAllOpenedActivities()\n\t{\n\t\treturn new ArrayList<Activity>(activityStack);\n\t}\n","new_comment_raw":"Returns a  List of all the opened\/active activities.","old_comment_raw":"Returns a List of all the opened\/active activities.","label":0,"pre_label":1,"AST_level":8,"line_counts":13,"new_code_token_num":60},{"new_code_raw":"public AtmosphereRequest getRequest() { return atmosphereRequest; }","old_code_raw":"    public HttpServletRequest getRequest() {\n        return atmosphereRequest;\n    }\n","new_comment_raw":"Return the associated  AtmosphereRequest","old_comment_raw":"Return the associated HttpServletRequest","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":10},{"new_code_raw":"public View getActiveDecorView() { final View [] views = getWindowDecorViews(); final Activity activity = activityUtils.getCurrentActivity(false); if(views !=null && views.length > 0) { int length = views.length; for(int i = length - 1; i >= 0; i--){ if(activity.hasWindowFocus() && getCurrentViews(TextView.class,(ViewGroup) views[i]).size()==1) { return views[i]; } else if(activity.hasWindowFocus() && activity.getWindow().getDecorView().equals(views[i])){ return views[i]; } else if(!activity.hasWindowFocus() && !activity.getWindow().getDecorView().equals(views[i])){ return views[i]; } } return views[views.length-1]; } else return null; }","old_code_raw":"\tpublic View getActiveDecorView()\n\t{\n\t\tView [] views = getWindowDecorViews();\n\t\tActivity activity = activityUtils.getCurrentActivity(false);\n\t\tif(views !=null && views.length > 0)\n\t\t{\n\t\t\tint length = views.length;\n\t\t\tfor(int i = length - 1; i >= 0; i--){\n\t\t\t\tif(activity.hasWindowFocus() && activity.getWindow().getDecorView().equals(views[i])){\n\t\t\t\t\treturn views[i];\n\t\t\t\t}\n\t\t\t\telse if(!activity.hasWindowFocus() && !activity.getWindow().getDecorView().equals(views[i])){ \n\t\t\t\t\treturn views[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn views[views.length-1];\n\t\t}\n\t\telse\n\t\t\treturn null;\n\t}\n","new_comment_raw":"Returns the active DecorView.","old_comment_raw":"Returns the active DecorView.","label":0,"pre_label":1,"AST_level":15,"line_counts":25,"new_code_token_num":173},{"new_code_raw":"public Mono<BigDecimal> fakeOuterNumberSerialize(BigDecimal body) throws RestClientException { Object postBody = body; String path = UriComponentsBuilder.fromPath(\"\/fake\/outer\/number\").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { \"*\/*\" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<BigDecimal> returnType = new ParameterizedTypeReference<BigDecimal>() {}; return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType); }","old_code_raw":"    public Mono<BigDecimal> fakeOuterNumberSerialize(BigDecimal body) throws RestClientException {\n        Object postBody = body;\n        \n        String path = UriComponentsBuilder.fromPath(\"\/fake\/outer\/number\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"*\/*\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<BigDecimal> returnType = new ParameterizedTypeReference<BigDecimal>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n","new_comment_raw":"Test serialization of outer number types 200 - Output number","old_comment_raw":"Test serialization of outer number types 200 - Output number","label":0,"pre_label":1,"AST_level":8,"line_counts":23,"new_code_token_num":177},{"new_code_raw":"public static String removeTags(String str) { return TAG_REGEXP.matcher(str).replaceAll(\"\"); }","old_code_raw":"\tpublic static String removeTags(String str)\n\t{\n\t\tStringBuilder builder = new StringBuilder(str.length());\n\t\tboolean inTag = false;\n\n\t\tfor (int i = 0; i < str.length(); i++)\n\t\t{\n\t\t\tchar currentChar = str.charAt(i);\n\n\t\t\tif (currentChar == '<')\n\t\t\t{\n\t\t\t\tinTag = true;\n\t\t\t}\n\t\t\telse if (currentChar == '>')\n\t\t\t{\n\t\t\t\tinTag = false;\n\t\t\t}\n\t\t\telse if (!inTag)\n\t\t\t{\n\t\t\t\tbuilder.append(currentChar);\n\t\t\t}\n\t\t}\n\n\t\treturn builder.toString();\n\t}\n","new_comment_raw":"Removes all tags from the given `str`.","old_comment_raw":"Removes all tags from the given `str`.","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":22},{"new_code_raw":"public Tree transformTree(Tree t) { if (VERBOSE) { System.err.println(\"Input to CoordinationTransformer: \" + t); } Tree tx = tn.transformTree(t); if (VERBOSE) { System.err.println(\"After DependencyTreeTransformer: \" + tx); } if (tx == null) { return tx; } Tree tt = UCPtransform(tx); if (VERBOSE) { System.err.println(\"After UCPTransformer: \" + t); } Tree ttt = CCtransform(tt); if (VERBOSE) { System.err.println(\"After CCTransformer: \" + t); } Tree tttt = qp.transformTree(ttt); if (VERBOSE) { System.err.println(\"After QPTreeTransformer: \" + t); } Tree ret = dates.transformTree(tttt); if (VERBOSE) { System.err.println(\"After DateTreeTransformer: \" + t); } return ret; }","old_code_raw":"  public Tree transformTree(Tree t) {\n    if (VERBOSE) {\n      System.err.println(\"Input to CoordinationTransformer: \" + t);\n    }\n    t = tn.transformTree(t);\n    if (VERBOSE) {\n      System.err.println(\"After DependencyTreeTransformer:  \" + t);\n    }\n    if (t == null) {\n      return t;\n    }\n\n    if (performMWETransformation) {\n      t = MWETransform(t);\n      if (VERBOSE) {\n        System.err.println(\"After MWETransform:               \" + t);\n      }\n\n      t = prepCCTransform(t);\n      if (VERBOSE) {\n        System.err.println(\"After prepCCTransform:               \" + t);\n      }\n    }\n\n    t = UCPtransform(t);\n    if (VERBOSE) {\n      System.err.println(\"After UCPTransformer:             \" + t);\n    }\n    t = CCtransform(t);\n    if (VERBOSE) {\n      System.err.println(\"After CCTransformer:              \" + t);\n    }\n    t = qp.transformTree(t);\n    if (VERBOSE) {\n      System.err.println(\"After QPTreeTransformer:          \" + t);\n    }\n    t = SQflatten(t);\n    if (VERBOSE) {\n      System.err.println(\"After SQ flattening:              \" + t);\n    }\n    t = dates.transformTree(t);\n    if (VERBOSE) {\n      System.err.println(\"After DateTreeTransformer:        \" + t);\n    }\n    t = removeXOverX(t);\n    if (VERBOSE) {\n      System.err.println(\"After removeXoverX:               \" + t);\n    }\n    t = combineConjp(t);\n    if (VERBOSE) {\n      System.err.println(\"After combineConjp:               \" + t);\n    }\n    t = moveRB(t);\n    if (VERBOSE) {\n      System.err.println(\"After moveRB:                     \" + t);\n    }\n    t = changeSbarToPP(t);\n    if (VERBOSE) {\n      System.err.println(\"After changeSbarToPP:             \" + t);\n    }\n    t = rearrangeNowThat(t);\n    if (VERBOSE) {\n      System.err.println(\"After rearrangeNowThat:           \" + t);\n    }\n\n    return t;\n  }\n","new_comment_raw":"Transforms t if it contains a coordination in a flat structure (CCtransform) and transforms UCP (UCPtransform).","old_comment_raw":"Transforms t if it contains a coordination in a flat structure (CCtransform) and transforms UCP (UCPtransform).","label":0,"pre_label":1,"AST_level":8,"line_counts":30,"new_code_token_num":175},{"new_code_raw":"@SuppressWarnings(\"unchecked\") public static String append(final String url, final Map<String, ?> params) { if (params == null || params.isEmpty()) return url; final StringBuilder result = new StringBuilder(url); \/\/ Add trailing slash if the base URL doesn't have any path segments. \/\/ The following test is checking for the last slash not being part of \/\/ the protocol to host separator ':\/\/'. int firstColon = url.indexOf(':'); int lastSlash = url.lastIndexOf('\/'); if (firstColon + 2 == lastSlash) result.append('\/'); result.append('?'); Entry<String, ?> entry; Object value; Iterator<?> iterator = params.entrySet().iterator(); entry = (Entry<String, ?>) iterator.next(); result.append(entry.getKey()); result.append('='); value = entry.getValue(); if (value != null) result.append(value); while (iterator.hasNext()) { result.append('&'); entry = (Entry<String, ?>) iterator.next(); result.append(entry.getKey()); result.append('='); value = entry.getValue(); if (value != null) result.append(value); } return result.toString(); }","old_code_raw":"\t@SuppressWarnings(\"unchecked\")\n\tpublic static String append(String url, final Map<String, ?> params) {\n\t\tif (params == null || params.isEmpty())\n\t\t\treturn url;\n\n\t\tStringBuilder result = new StringBuilder();\n\t\tif (!url.endsWith(\"\/\"))\n\t\t\turl += \"\/\";\n\n\t\tEntry<String, ?> entry;\n\t\tObject value;\n\t\tIterator<?> iterator = params.entrySet().iterator();\n\t\tentry = (Entry<String, ?>) iterator.next();\n\t\tresult.append(entry.getKey());\n\t\tresult.append('=');\n\t\tvalue = entry.getValue();\n\t\tif (value != null)\n\t\t\tresult.append(value);\n\n\t\twhile (iterator.hasNext()) {\n\t\t\tresult.append('&');\n\t\t\tentry = (Entry<String, ?>) iterator.next();\n\t\t\tresult.append(entry.getKey());\n\t\t\tresult.append('=');\n\t\t\tvalue = entry.getValue();\n\t\t\tif (value != null)\n\t\t\t\tresult.append(value);\n\t\t}\n\n\t\treturn url + '?' + result.toString();\n\t}\n","new_comment_raw":"Append given query parameters to base URL","old_comment_raw":"Append given parameters to base URL","label":1,"pre_label":0,"AST_level":10,"line_counts":40,"new_code_token_num":269},{"new_code_raw":"protected int getNormalLayoutResId() { return itemGridCellBinder.layout; }","old_code_raw":"    protected int getNormalLayoutResId() {\n        return R.layout.grid_item;\n    }\n","new_comment_raw":"the layout id for the normal data","old_comment_raw":"the layout id for the normal data","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":11},{"new_code_raw":"public Iterator<Component> getComponentIterator() { return Collections.unmodifiableList(components).iterator(); }","old_code_raw":"    public Iterator<Component> getComponentIterator() {\n        return java.util.Collections.unmodifiableList(components).iterator();\n    }\n","new_comment_raw":"Gets the component container iterator for going through all the components (tab contents).","old_comment_raw":"Gets the component container iterator for going trough all the components in the container.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":18},{"new_code_raw":"public ApiResponse<Void> logoutUserWithHttpInfo() throws ApiException { okhttp3.Call localVarCall = logoutUserValidateBeforeCall(null, null); return localVarApiClient.execute(localVarCall); }","old_code_raw":"    public ApiResponse<Void> logoutUserWithHttpInfo() throws ApiException {\n        okhttp3.Call call = logoutUserValidateBeforeCall(null, null);\n        return apiClient.execute(call);\n    }\n","new_comment_raw":"Logs out current logged in user session","old_comment_raw":"Logs out current logged in user session","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":27},{"new_code_raw":"static public IStructuredTextExpert getStatefulExpert(String type, StructuredTextEnvironment environment) { StructuredTextTypeHandler handler = StructuredTextTypeHandlerFactory.getHandler(type); if (handler == null) throw new IllegalArgumentException(\"Invalid type argument\"); \/\/$NON-NLS-1$ return getStatefulExpert(handler, environment); }","old_code_raw":"\tstatic public ISTextExpert getStatefulExpert(String type, STextEnvironment environment) {\n\t\tSTextTypeHandler handler = STextTypeHandlerFactory.getHandler(type);\n\t\tif (handler == null)\n\t\t\tthrow new IllegalArgumentException(\"Invalid type argument\"); \/\/$NON-NLS-1$\n\t\treturn getStatefulExpert(handler, environment);\n\t}\n","new_comment_raw":"Obtains a IStructuredTextExpert instance for processing structured text with the specified type handler and the specified environment.","old_comment_raw":"Obtains a ISTextExpert instance for processing structured text with the specified type handler and the specified environment.","label":1,"pre_label":0,"AST_level":6,"line_counts":8,"new_code_token_num":54},{"new_code_raw":"@PreAuthorize(Constant.ACCESS_HAS_ROLE_ADMIN + \" or hasPermission(#cube, 'ADMINISTRATION') or hasPermission(#cube, 'OPERATION') or hasPermission(#cube, 'MANAGEMENT')\") public CubeInstance enableCube(CubeInstance cube) throws IOException, JobException { String cubeName = cube.getName(); RealizationStatusEnum ostatus = cube.getStatus(); if (!cube.getStatus().equals(RealizationStatusEnum.DISABLED)) { throw new InternalErrorException(\"Only disabled cube can be enabled, status of \" + cubeName + \" is \" + ostatus); } if (cube.getSegments(SegmentStatusEnum.READY).size() == 0) { throw new InternalErrorException(\"Cube \" + cubeName + \" dosen't contain any READY segment\"); } final List<CubingJob> cubingJobs = listAllCubingJobs(cube.getName(), null, EnumSet.of(ExecutableState.READY, ExecutableState.RUNNING)); if (!cubingJobs.isEmpty()) { throw new JobException(\"Enable is not allowed with a running job.\"); } if (!cube.getDescriptor().calculateSignature().equals(cube.getDescriptor().getSignature())) { cube = this.releaseAllSegments(cube); } try { return getCubeManager().updateCube(cube, null, null, null, RealizationStatusEnum.READY); } catch (IOException e) { cube.setStatus(ostatus); throw e; } }","old_code_raw":"    @PreAuthorize(Constant.ACCESS_HAS_ROLE_ADMIN + \" or hasPermission(#cube, 'ADMINISTRATION') or hasPermission(#cube, 'OPERATION')  or hasPermission(#cube, 'MANAGEMENT')\")\n    public CubeInstance enableCube(CubeInstance cube) throws IOException, JobException {\n        String cubeName = cube.getName();\n\n        RealizationStatusEnum ostatus = cube.getStatus();\n        if (!cube.getStatus().equals(RealizationStatusEnum.DISABLED)) {\n            throw new InternalErrorException(\"Only disabled cube can be enabled, status of \" + cubeName + \" is \" + ostatus);\n        }\n\n        if (cube.getSegments(SegmentStatusEnum.READY).size() == 0) {\n            throw new InternalErrorException(\"Cube \" + cubeName + \" dosen't contain any READY segment\");\n        }\n\n        final List<CubingJob> cubingJobs = listAllCubingJobs(cube.getName(), null, EnumSet.of(ExecutableState.READY, ExecutableState.RUNNING));\n        if (!cubingJobs.isEmpty()) {\n            throw new JobException(\"Enable is not allowed with a running job.\");\n        }\n        if (!cube.getDescriptor().calculateSignature().equals(cube.getDescriptor().getSignature())) {\n            cube = this.releaseAllSegments(cube);\n        }\n\n        try {\n            return getCubeManager().updateCube(cube, null, null, null, RealizationStatusEnum.READY, true);\n        } catch (IOException e) {\n            cube.setStatus(ostatus);\n            throw e;\n        }\n    }\n","new_comment_raw":"Update a cube status from disable to ready.","old_comment_raw":"Update a cube status from disable to ready.","label":0,"pre_label":1,"AST_level":10,"line_counts":29,"new_code_token_num":259},{"new_code_raw":"public Boolean fakeOuterBooleanSerialize(Boolean body) throws ApiException { Object localVarPostBody = body; \/\/ create path and map variables String localVarPath = \"\/fake\/outer\/boolean\"; \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {}; return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public Boolean fakeOuterBooleanSerialize(Boolean body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/fake\/outer\/boolean\";\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"Test serialization of outer boolean types","old_comment_raw":"Test serialization of outer boolean types","label":0,"pre_label":1,"AST_level":8,"line_counts":31,"new_code_token_num":166},{"new_code_raw":"public Interval gap(ReadableInterval interval) { interval = DateTimeUtils.getReadableInterval(interval); if (overlaps(interval) || abuts(interval)) { return null; } long otherStart = interval.getStartMillis(); long otherEnd = interval.getEndMillis(); long thisStart = getStartMillis(); long thisEnd = getEndMillis(); if (thisStart >= otherEnd) { return new Interval(otherEnd, thisStart, getChronology()); } else { return new Interval(thisEnd, otherStart, getChronology()); } }","old_code_raw":"    public Interval gap(ReadableInterval interval) {\n        interval = DateTimeUtils.getReadableInterval(interval);\n        if (overlaps(interval) || abuts(interval)) {\n            return null;\n        }\n        long otherStart = interval.getStartMillis();\n        long otherEnd = interval.getEndMillis();\n        long thisStart = getStartMillis();\n        long thisEnd = getEndMillis();\n        if (thisStart >= otherEnd) {\n            return new Interval(otherEnd, thisStart);\n        } else {\n            return new Interval(thisEnd, otherStart);\n        }\n    }\n","new_comment_raw":"Gets the gap between this interval and another interval.","old_comment_raw":"Gets the gap between this interval and that specified.","label":1,"pre_label":0,"AST_level":7,"line_counts":16,"new_code_token_num":96},{"new_code_raw":"public ItemPrice getItemPrice(int itemId) throws IOException { ItemPrice itemPrice = itemPrices.getIfPresent(itemId); if (itemPrice != null && itemPrice != EMPTY) { return itemPrice == NONE ? null : itemPrice; } itemPrice = itemClient.lookupItemPrice(itemId); if (itemPrice == null) { itemPrices.put(itemId, NONE); return null; } itemPrices.put(itemId, itemPrice); return itemPrice; }","old_code_raw":"\tpublic ItemPrice getItemPrice(int itemId) throws IOException\n\t{\n\t\tItemPrice itemPrice = itemPrices.getIfPresent(itemId);\n\t\tif (itemPrice != null && itemPrice != EMPTY)\n\t\t{\n\t\t\treturn itemPrice == NONE ? null : itemPrice;\n\t\t}\n\n\t\titemPrice = itemClient.lookupItemPrice(itemId);\n\t\titemPrices.put(itemId, itemPrice);\n\t\treturn itemPrice;\n\t}\n","new_comment_raw":"Look up an item's price synchronously","old_comment_raw":"Look up an item's price synchronously","label":0,"pre_label":1,"AST_level":8,"line_counts":19,"new_code_token_num":76},{"new_code_raw":"public static RequestQueue newRequestQueue(IRestProtocol implRestConnection, int threadPoolSize) { return newRequestQueue(RestParser.getInstance(implRestConnection), threadPoolSize); }","old_code_raw":"    public static RequestQueue newRequestQueue(ImplRestConnection implRestConnection, int threadPoolSize) {\n        return newRequestQueue(HttpRestParser.getInstance(implRestConnection), threadPoolSize);\n    }\n","new_comment_raw":"Create a new request queue, using NoHttp default request executor  RestProtocol and default response parser  RestParser.","old_comment_raw":"Create a new request queue, using NoHttp default request executor HttpRestConnection and default response parser HttpRestParser.","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":25},{"new_code_raw":"private boolean isCached(Serializable collectionKey, CollectionPersister persister) { SessionImplementor session = context.getSession(); if ( session.getCacheMode().isGetEnabled() && persister.hasCache() ) { CollectionRegionAccessStrategy cache = persister.getCacheAccessStrategy(); CollectionCacheKey cacheKey = cache.generateCacheKey( collectionKey, persister, session.getFactory(), session.getTenantIdentifier() ); return CacheHelper.fromSharedCache( session, cacheKey, cache ) != null; } return false; }","old_code_raw":"\tprivate boolean isCached(Serializable collectionKey, CollectionPersister persister) {\n\t\tif ( context.getSession().getCacheMode().isGetEnabled() && persister.hasCache() ) {\n\t\t\tCacheKey cacheKey = context.getSession().generateCacheKey(\n\t\t\t\t\tcollectionKey,\n\t\t\t\t\tpersister.getKeyType(),\n\t\t\t\t\tpersister.getRole()\n\t\t\t);\n\t\t\treturn CacheHelper.fromSharedCache( context.getSession(), cacheKey, persister.getCacheAccessStrategy() ) != null;\n\t\t}\n\t\treturn false;\n\t}\n","new_comment_raw":"Get a batch of uninitialized collection keys for a given role","old_comment_raw":"Get a batch of uninitialized collection keys for a given role","label":0,"pre_label":1,"AST_level":8,"line_counts":15,"new_code_token_num":80},{"new_code_raw":"public static String deprocess(String str, STextProcessor processor) { if ((str == null) || (str.length() <= 1)) return str; \/\/ make sure that LRE\/PDF are added around the string STextEnvironment env = new STextEnvironment(null, false, STextEnvironment.ORIENT_UNKNOWN); if (!env.isProcessingNeeded()) return str; return STextEngine.fullToLeanText(processor, env, str, null); }","old_code_raw":"\tpublic static String deprocess(String str, STextProcessor processor) {\n\t\tif ((str == null) || (str.length() <= 1) || !isProcessingNeeded())\n\t\t\treturn str;\n\n\t\t\/\/ make sure that LRE\/PDF are added around the string\n\t\tSTextEnvironment env = new STextEnvironment(null, false, STextEnvironment.ORIENT_UNKNOWN);\n\t\treturn STextEngine.fullToLeanText(processor, env, str, null);\n\t}\n","new_comment_raw":"Removes directional formatting characters in the given string.","old_comment_raw":"Remove directional formatting characters in the given string that were inserted by the #processTyped processTyped method.","label":1,"pre_label":0,"AST_level":6,"line_counts":12,"new_code_token_num":82},{"new_code_raw":"public Expression getKey() { return key; }","old_code_raw":"  public StringLiteral getKey() {\n    return key;\n  }\n","new_comment_raw":"Return the expression computing the key with which the value will be associated.","old_comment_raw":"Return the key with which the value will be associated.","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":10},{"new_code_raw":"public JSONObject getJSONObject(String key) { Object object = this.get(key); if (object == null) { return null; } if (object instanceof JSONObject) { return (JSONObject)object; } throw new RuntimeException(\"JSONObject[\" + quote(key) + \"] is not a JSONObject.\"); }","old_code_raw":"  public JSONObject getJSONObject(String key) {\n    Object object = this.get(key);\n    if (object instanceof JSONObject) {\n      return (JSONObject)object;\n    }\n    throw new RuntimeException(\"JSONObject[\" + quote(key) + \"] is not a JSONObject.\");\n  }\n","new_comment_raw":"Get the JSONObject value associated with a key.","old_comment_raw":"Get the JSONObject value associated with a key.","label":0,"pre_label":1,"AST_level":8,"line_counts":11,"new_code_token_num":64},{"new_code_raw":"public static EString substring(Expr<String> left, int beginIndex, int endIndex) { return operationFactory.createString(Ops.SUBSTR2ARGS, left, exprFactory.createConstant(beginIndex), exprFactory.createConstant(endIndex)); }","old_code_raw":"    public static EString substring(Expr<String> left, int beginIndex, int endIndex) {\n        return factory.createString(Ops.SUBSTR2ARGS, left, factory.createConstant(beginIndex), factory.createConstant(endIndex));\n    }\n","new_comment_raw":"Expr : left.substring(beginIndex, endIndex)","old_comment_raw":"Expr : left.substring(beginIndex, endIndex)","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":39},{"new_code_raw":"public BigDecimal executeAs(Function<Response, Response> handler) { Type type = new TypeToken<BigDecimal>(){}.getType(); return execute(handler).as(type); }","old_code_raw":"        public BigDecimal executeAs(Function<Response, Response> handler) {\n            Type type = new TypeToken<BigDecimal>(){}.getType();\n            return getJSON().deserialize(execute(handler).asString(), type);\n        }\n","new_comment_raw":"POST \/fake\/outer\/number","old_comment_raw":"POST \/fake\/outer\/number","label":0,"pre_label":1,"AST_level":8,"line_counts":5,"new_code_token_num":35},{"new_code_raw":"public Property era() { return new Property(this, getChronology().era()); }","old_code_raw":"    public ReadWritableInstantFieldProperty era() {\n        return new ReadWritableInstantFieldProperty(this, getChronology().era());\n    }\n","new_comment_raw":"Get the era property.","old_comment_raw":"Get the era property.","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":21},{"new_code_raw":"public static Set<BitSet> getUniqueKeys(RelNode rel, boolean ignoreNulls) { final BuiltInMetadata.UniqueKeys metadata = rel.metadata(BuiltInMetadata.UniqueKeys.class); return metadata.getUniqueKeys(ignoreNulls); }","old_code_raw":"  public static Set<BitSet> getUniqueKeys(RelNode rel, boolean ignoreNulls) {\n    return (Set<BitSet>) rel.getCluster().getMetadataProvider()\n        .getRelMetadata(\n            rel,\n            \"getUniqueKeys\",\n            new Object[]{ignoreNulls});\n  }\n","new_comment_raw":"Returns the  BuiltInMetadata.UniqueKeys#getUniqueKeys(boolean) statistic.","old_comment_raw":"Determines the set of unique minimal keys for this expression, optionally ignoring nulls in the columns in the expression.","label":1,"pre_label":0,"AST_level":7,"line_counts":6,"new_code_token_num":33},{"new_code_raw":"public static MerkleTreeLeaf parseMerkleTreeLeaf(InputStream in) { int version = (int) readNumber(in, CTConstants.VERSION_LENGTH); if (version != Ct.Version.V1.getNumber()) { throw new SerializationException(String.format(\"Unknown version: %d\", version)); } int leafType = (int) readNumber(in, 1); if (leafType != Ct.MerkleLeafType.TIMESTAMPED_ENTRY_VALUE) { throw new SerializationException(String.format(\"Unknown entry type: %d\", leafType)); } return new MerkleTreeLeaf(Ct.Version.valueOf(version), Ct.MerkleLeafType.valueOf(leafType), parseTimestampedEntry(in)); }","old_code_raw":"  public static Ct.MerkleTreeLeaf parseMerkleTreeLeaf(InputStream in) {\n    Ct.MerkleTreeLeaf.Builder merkleTreeLeafBuilder = Ct.MerkleTreeLeaf.newBuilder();\n\n    int version = (int) readNumber(in, CTConstants.VERSION_LENGTH);\n    if (version != Ct.Version.V1.getNumber()) {\n      throw new SerializationException(String.format(\"Unknown version: %d\", version));\n    }\n    merkleTreeLeafBuilder.setVersion(Ct.Version.valueOf(version));\n\n    int leafType = (int) readNumber(in, 1);\n    if (leafType != Ct.MerkleLeafType.TIMESTAMPED_ENTRY_VALUE) {\n      throw new SerializationException(String.format(\"Unknown entry type: %d\", leafType));\n    }\n    merkleTreeLeafBuilder.setType(Ct.MerkleLeafType.valueOf(leafType));\n    merkleTreeLeafBuilder.setTimestampedEntry((parseTimestampedEntry(in)));\n\n    return merkleTreeLeafBuilder.build();\n  }\n","new_comment_raw":"Parses a  MerkleTreeLeaf from binary encoding.","old_comment_raw":"Parses a Ct.MerkleTreeLeaf from binary encoding.","label":1,"pre_label":0,"AST_level":8,"line_counts":15,"new_code_token_num":121},{"new_code_raw":"public DockerClientConfigBuilder withProperties(Properties p) { return withUri(p.getProperty(\"docker.io.url\")) .withVersion(p.getProperty(\"docker.io.version\")) .withUsername(p.getProperty(\"docker.io.username\")) .withPassword(p.getProperty(\"docker.io.password\")) .withEmail(p.getProperty(\"docker.io.email\")) .withReadTimeout(Integer.valueOf(p.getProperty(\"docker.io.readTimeout\", \"0\"))) .withLoggingFilter(Boolean.valueOf(p.getProperty(\"docker.io.enableLoggingFilter\", \"true\"))) .withKeystore(p.getProperty(\"docker.io.keystore\")) .withKeystorePassword(p.getProperty(\"docker.io.keystorePassword\")) .withTruststore(p.getProperty(\"docker.io.truststore\")) .withTruststorePassword(p.getProperty(\"docker.io.truststorePassword\")); }","old_code_raw":"        public DockerClientConfigBuilder withProperties(Properties p) {\n            return withUri(p.getProperty(\"docker.io.url\"))\n                    .withVersion(p.getProperty(\"docker.io.version\"))\n                    .withUsername(p.getProperty(\"docker.io.username\"))\n                    .withPassword(p.getProperty(\"docker.io.password\"))\n                    .withEmail(p.getProperty(\"docker.io.email\"))\n                    .withReadTimeout(Integer.valueOf(p.getProperty(\"docker.io.readTimeout\", \"0\")))\n                    .withLoggingFilter(Boolean.valueOf(p.getProperty(\"docker.io.enableLoggingFilter\", \"true\")));\n        }\n","new_comment_raw":"This will set all fields in the builder to those contained in the Properties object.","old_comment_raw":"This will set all fields in the builder to those contained in the Properties object.","label":0,"pre_label":1,"AST_level":8,"line_counts":14,"new_code_token_num":159},{"new_code_raw":"public Insets getBorderInsets(Component c) { return getBorderInsets(c, null); }","old_code_raw":"    public Insets getBorderInsets(Component c, Insets insets) {\n        if (this.insets != null) {\n            if (insets == null) {\n                insets = new Insets(this.insets.top, this.insets.left,\n                                  this.insets.bottom, this.insets.right);\n            }\n            else {\n                insets.top    = this.insets.top;\n                insets.bottom = this.insets.bottom;\n                insets.left   = this.insets.left;\n                insets.right  = this.insets.right;\n            }\n        }\n        else if (insets == null) {\n            insets = new Insets(0, 0, 0, 0);\n        }\n        else {\n            insets.top = insets.bottom = insets.left = insets.right = 0;\n        }\n        if (c instanceof JComponent) {\n            Region region = Region.getRegion((JComponent)c);\n            Insets margin = null;\n            if ((region == Region.ARROW_BUTTON || region == Region.BUTTON ||\n                 region == Region.CHECK_BOX ||\n                 region == Region.CHECK_BOX_MENU_ITEM ||\n                 region == Region.MENU || region == Region.MENU_ITEM ||\n                 region == Region.RADIO_BUTTON ||\n                 region == Region.RADIO_BUTTON_MENU_ITEM ||\n                 region == Region.TOGGLE_BUTTON) &&\n                       (c instanceof AbstractButton)) {\n                margin = ((AbstractButton)c).getMargin();\n            }\n            else if ((region == Region.EDITOR_PANE ||\n                      region == Region.FORMATTED_TEXT_FIELD ||\n                      region == Region.PASSWORD_FIELD ||\n                      region == Region.TEXT_AREA ||\n                      region == Region.TEXT_FIELD ||\n                      region == Region.TEXT_PANE) &&\n                        (c instanceof JTextComponent)) {\n                margin = ((JTextComponent)c).getMargin();\n            }\n            else if (region == Region.TOOL_BAR && (c instanceof JToolBar)) {\n                margin = ((JToolBar)c).getMargin();\n            }\n            else if (region == Region.MENU_BAR && (c instanceof JMenuBar)) {\n                margin = ((JMenuBar)c).getMargin();\n            }\n            if (margin != null) {\n                insets.top += margin.top;\n                insets.bottom += margin.bottom;\n                insets.left += margin.left;\n                insets.right += margin.right;\n            }\n        }\n        return insets;\n    }\n","new_comment_raw":"This default implementation returns a new Insets instance where the top, left, bottom, and right fields are set to 0.","old_comment_raw":"Reinitializes the insets parameter with this Border's current Insets.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":17},{"new_code_raw":"public boolean scrollUpList(int index) { return scroller.scrollList(waiter.waitForAndGetView(index, ListView.class), Scroller.UP, false); }","old_code_raw":"\tpublic boolean scrollUpList(int index) {\n\t\treturn scroller.scrollList(waiter.waitForAndGetView(index, ListView.class), Scroller.UP);\n\t}\n","new_comment_raw":"Scrolls up a list with a given index.","old_comment_raw":"Scrolls up a list with a given index.","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":28},{"new_code_raw":"public static Type<?> valueOf(String name) { return ModTheMod.getGame().getTypeManager().getType(name); }","old_code_raw":"\tpublic static Type valueOf(String name) {\n\t\treturn null; \/\/ TODO\n\t}\n","new_comment_raw":"Gets a  Type from its name.","old_comment_raw":"Returns a Type from its name.","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":24},{"new_code_raw":"protected Object defaultValue(Field field, Conversion<?> conversion) throws IOException { Schema schema = field.schema(); LogicalType logicalType = schema.getLogicalType(); Object rawDefaultValue = data.deepCopy(schema, data.getDefaultValue(field)); if (conversion == null || logicalType == null) { return rawDefaultValue; } else { return Conversions.convertToLogicalType(rawDefaultValue, schema, logicalType, conversion); } }","old_code_raw":"  protected Object defaultValue(Field field) throws IOException {\n    return data.deepCopy(field.schema(), data.getDefaultValue(field));\n  }\n","new_comment_raw":"Gets the default value of the given field, if any.","old_comment_raw":"Gets the default value of the given field, if any.","label":0,"pre_label":1,"AST_level":7,"line_counts":12,"new_code_token_num":73},{"new_code_raw":"private XmlAttributeNode getScriptSourcePath(XmlTagNode node) { for (XmlAttributeNode attribute : node.getAttributes()) { if (attribute.getName().getLexeme().equals(SRC)) { return attribute; } } return null; }","old_code_raw":"  private String getScriptSourcePath(XmlTagNode node) {\n    for (XmlAttributeNode attribute : node.getAttributes()) {\n      if (attribute.getName().getLexeme().equals(SRC)) {\n        String text = attribute.getText();\n        return text != null && text.length() > 0 ? text : null;\n      }\n    }\n    return null;\n  }\n","new_comment_raw":"Return the first source attribute for the given tag node, or  null if it does not exist.","old_comment_raw":"Return the value of the source attribute if it exists.","label":1,"pre_label":0,"AST_level":8,"line_counts":10,"new_code_token_num":43},{"new_code_raw":"public synchronized List<ColumnIdentifier> getColumns(TableIdentifier tbl) { String schema = getSchemaToUse(tbl.getSchema()); TableIdentifier toSearch = tbl.createCopy(); toSearch.adjustCase(dbConnection); if (toSearch.getSchema() == null) { toSearch.setSchema(schema); } List<ColumnIdentifier> cols = this.objects.get(toSearch); if (cols == null) { try { TableDefinition def = dbConnection.getMetadata().getTableDefinition(toSearch); addTable(def); } catch (SQLException sql) { LogMgr.logWarning(\"DbObjectCache.getColumns()\", \"Error retrieving table definition\", sql); return null; } } \/\/ To support Oracle public synonyms, try to find a table with that name but without a schema if (retrieveOraclePublicSynonyms && toSearch.getSchema() != null && cols == null) { toSearch.setSchema(null); toSearch.setType(null); cols = this.objects.get(toSearch); if (cols == null) { \/\/ retrieve Oracle PUBLIC synonyms this.getTables(\"PUBLIC\"); cols = this.objects.get(toSearch); } } if (CollectionUtil.isEmpty(cols)) { TableIdentifier tblToUse = null; \/\/ use the stored key because that might carry the correct type attribute \/\/ TabelIdentifier.equals() doesn't compare the type, only the expression \/\/ so we'll get a containsKey() == true even if the type is different \/\/ (which is necessary because the TableIdentifier passed to this \/\/ method will never contain a type!) \/\/ only using objects.get() would not return anything! if (objects.containsKey(toSearch)) { \/\/ we have already retrieved the list of tables, but not the columns for this table \/\/ the table identifier in the object map contains correct type and schema information, so we need \/\/ to use that tblToUse = findEntry(toSearch); } else { \/\/ retrieve the real table identifier based on the table name tblToUse = this.dbConnection.getMetadata().findObject(toSearch); } try { cols = this.dbConnection.getMetadata().getTableColumns(tblToUse); } catch (Throwable e) { LogMgr.logError(\"DbObjectCache.getColumns\", \"Error retrieving columns for \" + tblToUse, e); cols = null; } if (tblToUse != null && CollectionUtil.isNonEmpty(cols)) { this.objects.put(tblToUse, cols); } } return Collections.unmodifiableList(cols); }","old_code_raw":"\tpublic List<ColumnIdentifier> getColumns(TableIdentifier tbl)\n\t{\n\t\tString schema = getSchemaToUse(tbl.getSchema());\n\n\t\tif (this.objects.size() == 0 || !schemasInCache.contains(schema == null ? NULL_SCHEMA : schema))\n\t\t{\n\t\t\tthis.getTables(schema);\n\t\t}\n\n\t\tTableIdentifier toSearch = tbl.createCopy();\n\t\ttoSearch.adjustCase(dbConnection);\n\t\tif (toSearch.getSchema() == null)\n\t\t{\n\t\t\ttoSearch.setSchema(schema);\n\t\t}\n\n\t\tList<ColumnIdentifier> cols = this.objects.get(toSearch);\n\n\t\t\/\/ To support Oracle public synonyms, try to find a table with that name but without a schema\n\t\tif (retrieveOraclePublicSynonyms && toSearch.getSchema() != null && cols == null)\n\t\t{\n\t\t\ttoSearch.setSchema(null);\n\t\t\ttoSearch.setType(null);\n\t\t\tcols = this.objects.get(toSearch);\n\t\t\tif (cols == null)\n\t\t\t{\n\t\t\t\t\/\/ retrieve Oracle PUBLIC synonyms\n\t\t\t\tthis.getTables(\"PUBLIC\");\n\t\t\t\tcols = this.objects.get(toSearch);\n\t\t\t}\n\t\t}\n\n\t\tif (CollectionUtil.isEmpty(cols))\n\t\t{\n\t\t\tTableIdentifier tblToUse = null;\n\n\t\t\t\/\/ use the stored key because that might carry the correct type attribute\n\t\t\t\/\/ TabelIdentifier.equals() doesn't compare the type, only the expression\n\t\t\t\/\/ so we'll get a containsKey() == true even if the type is different\n\t\t\t\/\/ (which is necessary because the TableIdentifier passed to this\n\t\t\t\/\/ method will never contain a type!)\n\t\t\t\/\/ only using objects.get() would not return anything!\n\t\t\tif (objects.containsKey(toSearch))\n\t\t\t{\n\t\t\t\t\/\/ we have already retrieved the list of tables, but not the columns for this table\n\t\t\t\t\/\/ the table identifier in the object map contains correct type and schema information, so we need\n\t\t\t\t\/\/ to use that\n\t\t\t\ttblToUse = findEntry(toSearch);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t\/\/ retrieve the real table identifier based on the table name\n\t\t\t\ttblToUse = this.dbConnection.getMetadata().findObject(toSearch);\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tcols = this.dbConnection.getMetadata().getTableColumns(tblToUse);\n\t\t\t}\n\t\t\tcatch (Throwable e)\n\t\t\t{\n\t\t\t\tLogMgr.logError(\"DbObjectCache.getColumns\", \"Error retrieving columns for \" + tblToUse, e);\n\t\t\t\tcols = null;\n\t\t\t}\n\n\t\t\tif (tblToUse != null && CollectionUtil.isNonEmpty(cols))\n\t\t\t{\n\t\t\t\tthis.objects.put(tblToUse, cols);\n\t\t\t}\n\n\t\t}\n\t\treturn Collections.unmodifiableList(cols);\n\t}\n","new_comment_raw":"Return the columns for the given table.","old_comment_raw":"Return the columns for the given table","label":1,"pre_label":0,"AST_level":11,"line_counts":83,"new_code_token_num":459},{"new_code_raw":"@Override public final TYPE next() { if (next == null) { return fromIterator.next(); } else { final TYPE result = next; next = null; return result; } }","old_code_raw":"    @Override\n    public final TYPE next() {\n        TYPE result = next;\n        next = null;\n        result = (result == null ? fromIterator.next() : result);\n        return result;\n    }\n","new_comment_raw":"Returns the next element of the Iterable.","old_comment_raw":"Returns the next element of the iteration.","label":1,"pre_label":0,"AST_level":7,"line_counts":12,"new_code_token_num":37},{"new_code_raw":"private List<Long> getRcsRawContactIdFromPhoneNumber(String phoneNumber) { List<Long> contactsIds = new ArrayList<Long>(); String[] projection = { Data.RAW_CONTACT_ID }; String selection = Data.MIMETYPE + \"=? AND PHONE_NUMBERS_EQUAL(\" + Phone.NUMBER + \", ?)\"; String[] selectionArgs = { MIMETYPE_NUMBER, phoneNumber }; String sortOrder = Data.RAW_CONTACT_ID; Cursor cur = ctx.getContentResolver().query(Data.CONTENT_URI, projection, selection, selectionArgs, sortOrder); if (cur != null) { while (cur.moveToNext()) { long rcsRawContactId = cur.getLong(cur.getColumnIndex(Data.RAW_CONTACT_ID)); contactsIds.add(rcsRawContactId); } cur.close(); } return contactsIds; }","old_code_raw":"    private long getRcsRawContactIdFromPhoneNumber(String phoneNumber) {\n        String[] projection = { Data.RAW_CONTACT_ID };\n        String selection = Data.MIMETYPE + \"=? AND PHONE_NUMBERS_EQUAL(\" + Phone.NUMBER + \", ?)\";\n        String[] selectionArgs = { MIMETYPE_NUMBER, phoneNumber };\n        String sortOrder = Data.RAW_CONTACT_ID;\n\n        Cursor cur = ctx.getContentResolver().query(Data.CONTENT_URI, \n        \t\tprojection, \n        \t\tselection, \n        \t\tselectionArgs,\n                sortOrder);\n        if (cur != null) {\n            while (cur.moveToNext()) {\n            \tlong rcsRawContactId = cur.getLong(cur.getColumnIndex(Data.RAW_CONTACT_ID));\n            \tcur.close();\n            \treturn rcsRawContactId;\n            }\n            cur.close();\n        }\n\n        return INVALID_ID;\n    }\n","new_comment_raw":"Utility to find the RCS rawContactIds for a specific phone number.","old_comment_raw":"Utility to find the RCS rawContactId for a specific phone number.","label":1,"pre_label":0,"AST_level":11,"line_counts":25,"new_code_token_num":128},{"new_code_raw":"public MenuItem addItem(SafeHtml html, ScheduledCommand cmd) { return addItem(new MenuItem(html, cmd)); }","old_code_raw":"  public MenuItem addItem(String text, boolean asHTML, Command cmd) {\n    return addItem(new MenuItem(text, asHTML, cmd));\n  }\n","new_comment_raw":"Adds a menu item to the bar containing SafeHtml, that will fire the given command when it is selected.","old_comment_raw":"Adds a menu item to the bar, that will fire the given command when it is selected.","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":24},{"new_code_raw":"public ConcurrentEntityStatisticsImpl getEntityStatistics(String entityName) { ConcurrentEntityStatisticsImpl es = entityStatistics.get( entityName ); if ( es == null ) { es = new ConcurrentEntityStatisticsImpl( entityName ); ConcurrentEntityStatisticsImpl previous; if ( ( previous = entityStatistics.putIfAbsent( entityName, es ) ) != null ) { es = previous; } } return es; }","old_code_raw":"\tpublic EntityStatistics getEntityStatistics(String entityName) {\n\t\tConcurrentEntityStatisticsImpl es = (ConcurrentEntityStatisticsImpl) entityStatistics.get( entityName );\n\t\tif ( es == null ) {\n\t\t\tes = new ConcurrentEntityStatisticsImpl( entityName );\n\t\t\tConcurrentEntityStatisticsImpl previous;\n\t\t\tif ( ( previous = (ConcurrentEntityStatisticsImpl) entityStatistics.putIfAbsent(\n\t\t\t\t\tentityName, es\n\t\t\t) ) != null ) {\n\t\t\t\tes = previous;\n\t\t\t}\n\t\t}\n\t\treturn es;\n\t}\n","new_comment_raw":"find entity statistics per name","old_comment_raw":"find entity statistics per name","label":0,"pre_label":1,"AST_level":9,"line_counts":12,"new_code_token_num":57},{"new_code_raw":"public RepositoryMetadata lookupComponent(Class<?> repositoryClass) { if (repositoriesMetadata.containsKey(repositoryClass)) { return repositoriesMetadata.get(repositoryClass); } throw new RuntimeException(\"Unknown Repository class \" + repositoryClass.getName()); }","old_code_raw":"    public RepositoryMetadata lookupComponent(Class<?> repoClass)\r\n    {\r\n        if (repositoriesMetadata.containsKey(repoClass))\r\n        {\r\n            return repositoriesMetadata.get(repoClass);\r\n        }\r\n        throw new RuntimeException(\"Unknown Repository class \" + repoClass.getName());\r\n    }\r\n","new_comment_raw":"Lookup the  RepositoryMetadata for a specific Repository class.","old_comment_raw":"Repository access - lookup the Repository component meta data for a specific Repository class.","label":1,"pre_label":0,"AST_level":7,"line_counts":10,"new_code_token_num":43},{"new_code_raw":"public RequestBody serialize(Object obj, String contentType) throws ApiException { if (obj instanceof byte[]) { \/\/ Binary (byte array) body parameter support. return RequestBody.create(MediaType.parse(contentType), (byte[]) obj); } else if (obj instanceof File) { \/\/ File body parameter support. return RequestBody.create(MediaType.parse(contentType), (File) obj); } else if (isJsonMime(contentType)) { String content; if (obj != null) { content = json.serialize(obj); } else { content = null; } return RequestBody.create(MediaType.parse(contentType), content); } else { throw new ApiException(\"Content type \\\"\" + contentType + \"\\\" is not supported\"); } }","old_code_raw":"  public String serialize(Object obj, String contentType) throws ApiException {\n    if (isJsonMime(contentType)) {\n      if (obj != null)\n        return json.serialize(obj);\n      else\n        return null;\n    } else {\n      throw new ApiException(\"Content type \\\"\" + contentType + \"\\\" is not supported\");\n    }\n  }\n","new_comment_raw":"Serialize the given Java object into request body according to the object's class and the request Content-Type.","old_comment_raw":"Serialize the given Java object into request body string, according to the request Content-Type.","label":1,"pre_label":0,"AST_level":12,"line_counts":20,"new_code_token_num":155},{"new_code_raw":"public int[] set(PartialInstant instant, int fieldIndex, int[] values, int newValue) { FieldUtils.verifyValueBounds(this, newValue, getMinimumValue(instant), getMaximumValue(instant)); values[fieldIndex] = newValue; return values; }","old_code_raw":"    public long set(long instant, String text, Locale locale) {\n        try {\n            return set(instant, Integer.parseInt(text));\n        } catch (NumberFormatException ex) {\n            throw new IllegalArgumentException(\"Invalid \" + getName() + \" text: \" + text);\n        }\n    }\n","new_comment_raw":"Sets a value using the specified partial instant.","old_comment_raw":"Sets a value in the milliseconds supplied from a human-readable, text value.","label":1,"pre_label":0,"AST_level":7,"line_counts":6,"new_code_token_num":49},{"new_code_raw":"public VideoCallProvider getVideoCallProvider() { return mVideoCallProvider; }","old_code_raw":"    public ConnectionService.VideoCallProvider getVideoCallProvider() {\n        return mVideoCallProvider;\n    }\n","new_comment_raw":"Returns the  VideoCallProvider for the connection.","old_comment_raw":"Returns the ConnectionService.VideoCallProvider for the connection.","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":10},{"new_code_raw":"public BackupResultStatus backupSession( final Session session ) { if ( _log.isInfoEnabled() ) { _log.debug( \"Trying to store session in memcached: \" + session.getId() ); } final MemcachedBackupSession backupSession = (MemcachedBackupSession) session; final BackupSessionTask task = getOrCreateBackupSessionTask( backupSession ); final Map<String, Object> attributes = backupSession.getAttributesInternal(); final byte[] attributesData = _transcoderService.serializeAttributes( backupSession, attributes ); final int hashCode = Arrays.hashCode( attributesData ); if ( backupSession.getDataHashCode() != hashCode || task.sessionCookieWasRelocated() ) { final byte[] data = _transcoderService.serialize( backupSession, attributesData ); final BackupResult result = task.backupSession( data, attributesData ); if ( result.getAttributesData() != null ) { backupSession.setDataHashCode( Arrays.hashCode( result.getAttributesData() ) ); } return result.getStatus(); } else { return BackupResultStatus.SKIPPED; } }","old_code_raw":"    public BackupResult backupSession( final Session session ) {\n        if ( _log.isInfoEnabled() ) {\n            _log.debug( \"Trying to store session in memcached: \" + session.getId() );\n        }\n\n        final BackupSessionTask task = getOrCreateBackupSessionTask( (MemcachedBackupSession) session );\n        return task.backupSession();\n    }\n","new_comment_raw":"Store the provided session in memcached if the session was modified or if the session needs to be relocated.","old_comment_raw":"Store the provided session in memcached.","label":1,"pre_label":0,"AST_level":10,"line_counts":29,"new_code_token_num":165},{"new_code_raw":"public static final Test suite() { return null; }","old_code_raw":"        public static Test suite(String name) {\n            return new TestSuite(\n                    JtdsDataSourceUnitTest.Test_JtdsDataSource_getConnection.class, name);\n        }\n","new_comment_raw":"Provides a null test suite so that JUnit will not try to instantiate this class directly.","old_comment_raw":"Construct a test suite for this library.","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":12},{"new_code_raw":"public final int getLine() { return this.bufline[this.bufpos]; }","old_code_raw":"    public final int getLine() {\n        return bufline[bufpos];\n    }\n","new_comment_raw":"Get the line number","old_comment_raw":"DOCUMENT ME!","label":1,"pre_label":0,"AST_level":7,"line_counts":5,"new_code_token_num":16},{"new_code_raw":"public static DocumentFactory createDocumentFactory(ServiceManager manager, Session session) { DocumentFactory factory; DocumentManager docManager = null; try { docManager = (DocumentManager) manager.lookup(DocumentManager.ROLE); factory = docManager.createDocumentIdentityMap(session); } catch (ServiceException e) { throw new RuntimeException(e); } finally { if (docManager != null) { manager.release(docManager); } } return factory; }","old_code_raw":"    public static DocumentFactory createDocumentFactory(ServiceManager manager, Session session) {\n        DocumentFactory map;\n        DocumentManager docManager = null;\n        try {\n            docManager = (DocumentManager) manager.lookup(DocumentManager.ROLE);\n            map = docManager.createDocumentIdentityMap(session);\n        } catch (ServiceException e) {\n            throw new RuntimeException(e);\n        } finally {\n            if (docManager != null) {\n                manager.release(docManager);\n            }\n        }\n        return map;\n    }\n","new_comment_raw":"Creates a document factory.","old_comment_raw":"Creates a document identity map.","label":1,"pre_label":0,"AST_level":8,"line_counts":17,"new_code_token_num":75},{"new_code_raw":"public static FxEnvironment getFilteredEnvironment() { return new FxFilteredEnvironment(getEnvironment()); }","old_code_raw":"    public static FxEnvironment getFilteredEnvironment() {\n        return new FilteredEnvironment(getEnvironment());\n    }\n","new_comment_raw":"Return a  com.flexive.shared.structure.FxFilteredEnvironment for the calling user.","old_comment_raw":"Return a FilteredEnvironment for the calling user.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":17},{"new_code_raw":"public Menu getControlMenu(final Control c) { Menu controlMenu = ControlHandler.getInstance().getMenu(c); if(controlMenu == null) { throw new CoreLayerException(c.getClass() +\" Has no menu\"); } return controlMenu; }","old_code_raw":"\tpublic Menu getControlMenu(final Control c) {\n\n\t\tMenu menu = Display.syncExec(new ResultRunnable<Menu>() {\n\n\t\t\t@Override\n\t\t\tpublic Menu run() {\n\t\t\t\tMenu m = c.getMenu();\n\t\t\t\treturn m;\n\t\t\t}\n\t\t});\n\n\t\tif (menu == null) {\n\t\t\tthrow new CoreLayerException(\n\t\t\t\t\tc.getClass() +\" Has no menu\");\n\t\t}\n\n\t\treturn menu;\t\n\t}\n","new_comment_raw":"Returns menu of given control","old_comment_raw":"Gets Menu of specified control.","label":1,"pre_label":0,"AST_level":8,"line_counts":9,"new_code_token_num":47},{"new_code_raw":"public ReadableInstant withDateTimeZone(DateTimeZone newDateTimeZone) { final Chronology originalChrono = getChronology(); if (originalChrono == null) { \/\/ Without an original chronology, no new time zone can be \/\/ set. Call withMillis to allow subclass to decide if a clone \/\/ should be made or not. return withMillis(getMillis()); } return withChronology(originalChrono.withDateTimeZone(newDateTimeZone)); }","old_code_raw":"    public ReadableInstant withDateTimeZone(DateTimeZone newDateTimeZone) {\n        Chronology newChronology = getChronology();\n        newChronology = newChronology == null ? ISOChronology.getInstance(newDateTimeZone)\n            : newChronology.withDateTimeZone(newDateTimeZone);\n        return withChronology(newChronology);\n    }\n","new_comment_raw":"Gets a copy of this instant with a different time zone, preserving the millisecond instant.","old_comment_raw":"Gets a copy of this instant with a different time zone.","label":1,"pre_label":0,"AST_level":7,"line_counts":11,"new_code_token_num":74},{"new_code_raw":"public Node transform(QueryVisitor queryVisitor) { NodeVisitorImpl nodeVisitor = new NodeVisitorImpl(queryVisitor, new QueryVisitorStub()); Map<Class<?>, Object> rootVars = new LinkedHashMap<>(); rootVars.put(QueryTraversalContext.class, new QueryTraversalContext(rootParentType, rootParentType, null, null)); Node root = roots.stream().findFirst() .orElseThrow(() -> new IllegalArgumentException(\"Single root node is required for transformation.\")); TraverserVisitor<Node> nodeTraverserVisitor = new TraverserVisitor<Node>() { @Override public TraversalControl enter(TraverserContext<Node> context) { context.setVar(LeaveOrEnter.class, LeaveOrEnter.ENTER); return context.thisNode().accept(context, nodeVisitor); } @Override public TraversalControl leave(TraverserContext<Node> context) { context.setVar(LeaveOrEnter.class, LeaveOrEnter.LEAVE); return context.thisNode().accept(context, nodeVisitor); } }; return new TreeTransformer<>(AST_NODE_ADAPTER).transform(root, nodeTraverserVisitor, rootVars); }","old_code_raw":"    public Node transform(QueryVisitor queryVisitor) {\n        NodeVisitorImpl nodeVisitor = new NodeVisitorImpl(queryVisitor, new QueryVisitorStub());\n        Map<Class<?>, Object> rootVars = new LinkedHashMap<>();\n        rootVars.put(QueryTraversalContext.class, new QueryTraversalContext(rootParentType, rootParentType, null, null));\n\n        Node root = roots.stream().findFirst()\n                .orElseThrow(() -> new IllegalArgumentException(\"Single root node is required for transformation.\"));\n        return new AstTransformer().transform(root, nodeVisitor, rootVars);\n    }\n","new_comment_raw":"Visits the Document in pre-order and allows to transform it using  graphql.util.TreeTransformerUtil methods.","old_comment_raw":"Visits the Document in pre-order and allows to transform it using graphql.language.AstTransformerUtil methods.","label":1,"pre_label":0,"AST_level":10,"line_counts":24,"new_code_token_num":175},{"new_code_raw":"public final char readChar() throws IOException { if (this.inBuf > 0) { --this.inBuf; if (++this.bufpos == this.bufsize) { this.bufpos = 0; } return this.buffer[this.bufpos]; } if (++this.bufpos >= this.maxNextCharInd) { fillBuff(); } char c = this.buffer[this.bufpos]; updateLineColumn(c); return (c); }","old_code_raw":"    public final char readChar() throws java.io.IOException {\n        if (inBuf > 0) {\n            --inBuf;\n\n            if (++bufpos == bufsize) {\n                bufpos = 0;\n            }\n\n            return buffer[bufpos];\n        }\n\n        if (++bufpos >= maxNextCharInd) {\n            FillBuff();\n        }\n\n        char c = buffer[bufpos];\n\n        UpdateLineColumn(c);\n\n        return (c);\n    }\n","new_comment_raw":"Read the next character","old_comment_raw":"DOCUMENT ME!","label":1,"pre_label":0,"AST_level":10,"line_counts":23,"new_code_token_num":80},{"new_code_raw":"public static String export() { RequestLog current = RLOG.get(); record(new Durations(current.aggregateDurations())); record(new Threads(current.threadIds)); return LogFormatterProvider.getInstance().format(current.info); }","old_code_raw":"    public static String export() {\n        RequestLog current = RLOG.get();\n        record(new Durations(current.aggregateDurations()));\n        record(new Threads(current.threadIds));\n        try {\n            return current.mapper.writeValueAsString(current.info);\n        } catch (JsonProcessingException jpe) {\n            String msg = String.format(\"Exporting mega log line with id: '%s' to JSON failed.\", current.logId);\n            LOG.warn(msg, jpe);\n            return msg;\n        }\n    }\n","new_comment_raw":"Exports current thread's request log object as a formatted string without resetting it.","old_comment_raw":"Exports current thread's request log object as a JSON string without resetting it.","label":1,"pre_label":0,"AST_level":6,"line_counts":8,"new_code_token_num":48},{"new_code_raw":"public static Parameter getReferencedParameter(OpenAPI openAPI, Parameter parameter) { if (parameter != null && StringUtils.isNotEmpty(parameter.get$ref())) { String name = getSimpleRef(parameter.get$ref()); Parameter referencedParameter = getParameter(openAPI, name); if(referencedParameter != null) { return referencedParameter; } } return parameter; }","old_code_raw":"    public static Parameter getReferencedParameter(OpenAPI openAPI, Parameter parameter) {\n        if (parameter != null && StringUtils.isNotEmpty(parameter.get$ref())) {\n            String name = getSimpleRef(parameter.get$ref());\n            return getParameter(openAPI, name);\n        }\n        return parameter;\n    }\n","new_comment_raw":"If a Parameter contains a reference to an other Parameter with '$ref', returns the referenced Parameter if it is found or the actual Parameter in the other cases.","old_comment_raw":"If a Parameter contains a reference to an other Parameter with '$ref', returns the referenced Parameter or the actual Parameter in the other cases.","label":1,"pre_label":0,"AST_level":8,"line_counts":11,"new_code_token_num":68},{"new_code_raw":"public Collection<Tree> getRelatedNodes(Tree t, Tree root) { if (root.value() == null) { root.setValue(\"ROOT\"); \/\/ todo: cdm: it doesn't seem like this line should be here } Set<Tree> nodeList = new LinkedHashSet<Tree>(); for (TregexPattern p : targetPatterns) { \/\/ cdm: I deleted: && nodeList.isEmpty() TregexMatcher m = p.matcher(root); while (m.findAt(t)) { nodeList.add(m.getNode(\"target\")); \/\/System.out.println(\"found \" + this + \"(\" + t + \", \" + m.getNode(\"target\") + \") using pattern \" + p); } } return nodeList; }","old_code_raw":"  public Collection<TreeGraphNode> getRelatedNodes(TreeGraphNode t, TreeGraphNode root, HeadFinder headFinder) {\n    Set<TreeGraphNode> nodeList = new ArraySet<TreeGraphNode>();\n    for (TregexPattern p : targetPatterns) {    \/\/ cdm: I deleted: && nodeList.isEmpty()\n      \/\/ Initialize the TregexMatcher with the HeadFinder so that we\n      \/\/ can use the same HeadFinder through the entire process of\n      \/\/ building the dependencies\n      TregexMatcher m = p.matcher(root, headFinder);\n      while (m.findAt(t)) {\n        TreeGraphNode target = (TreeGraphNode) m.getNode(\"target\");\n        if (target == null) {\n          throw new AssertionError(\"Expression has no target: \" + p);\n        }\n        nodeList.add(target);\n        if (DEBUG) {\n          System.err.println(\"found \" + this + \"(\" + t + \"-\" + t.headWordNode() + \", \" + m.getNode(\"target\") + \"-\" + ((TreeGraphNode) m.getNode(\"target\")).headWordNode() + \") using pattern \" + p);\n          for (String nodeName : m.getNodeNames()) {\n            if (nodeName.equals(\"target\"))\n              continue;\n            System.err.println(\"  node \" + nodeName + \": \" + m.getNode(nodeName));\n          }\n        }\n      }\n    }\n    return nodeList;\n  }\n","new_comment_raw":"Given a Tree node t, attempts to return a list of nodes to which node t has this grammatical relation.","old_comment_raw":"Given a Tree node t, attempts to return a list of nodes to which node t has this grammatical relation, with t as the governor.","label":1,"pre_label":0,"AST_level":10,"line_counts":15,"new_code_token_num":151},{"new_code_raw":"public static String getClassName(String memberID, boolean isClassMember) { int pos = memberID.indexOf(ALT_MEMBER_SEPARATOR); \/\/ uses alternative separator, easy if (pos != -1) return memberID.substring(0, pos); pos = memberID.indexOf('('); if ( pos != -1 ) { \/\/ has a descriptor, is a method ID, strip last member part pos = memberID.lastIndexOf('.', pos); return pos != -1 ? memberID.substring(0, pos) : \"\"; } if (isClassMember) { \/\/ field or class name, cannot decide, assume it is a field pos = memberID.lastIndexOf('.'); return pos != -1 ? memberID.substring(0, pos) : \"\"; } else { \/\/ assume it is a class name return memberID; } }","old_code_raw":"    public static String getClassName(String signature, boolean isClassMember) {\n        int pos = signature.indexOf(ALT_MEMBER_SEPARATOR);\n        \/\/ uses alternative separator, easy\n        if (pos != -1) return signature.substring(0, pos);\n\n        pos = signature.indexOf('(');\n        if ( pos != -1 ) {\n            \/\/ has a descriptor, is a method signature, strip last member part\n            pos = signature.lastIndexOf('.', pos);\n            return pos != -1 ? signature.substring(0, pos) : \"\";\n        }\n\n        if (isClassMember) {\n            \/\/ field or class name, cannot decide, assume it is a field\n            pos = signature.lastIndexOf('.');\n            return pos != -1 ? signature.substring(0, pos) : \"\";\n        } else {\n            \/\/ assume it is a class name\n            return signature;\n        }\n    }\n","new_comment_raw":"Parse a member ID, with or without classname, with or without descriptor.","old_comment_raw":"Parse a signature, with or without classname, with or without descriptor.","label":1,"pre_label":0,"AST_level":8,"line_counts":23,"new_code_token_num":164},{"new_code_raw":"public final FacebookException getError() { return error; }","old_code_raw":"    public final FacebookRequestError getError() {\n        return error;\n    }\n","new_comment_raw":"Returns the error returned for this request, if any.","old_comment_raw":"Returns information about any errors that may have occurred during the request.","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":11},{"new_code_raw":"private String terminalToShowWhenClosing(String handle) { int terminalClosing = terminals_.indexOfTerminal(handle); if (terminalClosing > 0) return terminals_.terminalHandleAtIndex(terminalClosing - 1); else if (terminalClosing + 1 < terminals_.terminalCount()) return terminals_.terminalHandleAtIndex(terminalClosing + 1); else return null; }","old_code_raw":"   private int terminalToShowWhenClosing(int terminalClosing)\n   {\n      if (terminalClosing > 0)\n         return terminalClosing - 1;\n      else if (terminalClosing + 1 < getTerminalCount())\n         return terminalClosing + 1;\n      else\n         return -1;\n   }\n","new_comment_raw":"Handle of terminal to show after closing indicated terminal.","old_comment_raw":"Index of terminal to show after closing indicated terminal index","label":1,"pre_label":0,"AST_level":8,"line_counts":11,"new_code_token_num":55},{"new_code_raw":"public IncidentsTask createReportsTask() { return new IncidentsTask(url); }","old_code_raw":"\tpublic ReportsTask createReportsTask() {\n\t\treturn new ReportsTask(url);\n\t}\n","new_comment_raw":"Create incidents task object","old_comment_raw":"Create report task object","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":14},{"new_code_raw":"public NVP<Long, Double> reset(final long newStartMs, final long newCount) { final long[] priorWindow = TIME_WINDOW_UPDATER.getAndSet(this, windowRangeFromMs(newStartMs, windowWidth)); final long priorCount = count; count = newCount; return new NVP<Long, Double>(priorWindow[1], calcRate(priorCount, windowWidth)); }","old_code_raw":"\tpublic long reset() {\n\t\tfinal long priorCount = count;\n\t\tcount = 0;\n\t\treturn priorCount;\n\t}\n","new_comment_raw":"Resets the count to zero and sets the time window according to the passed ms timestamp","old_comment_raw":"Resets the count to zero","label":1,"pre_label":0,"AST_level":7,"line_counts":8,"new_code_token_num":63},{"new_code_raw":"private int[] getEnteredTime(Boolean[] enteredZeros) { int amOrPm = -1; int startIndex = 1; if (!mIs24HourMode && isTypedTimeFullyLegal()) { int keyCode = mTypedTimes.get(mTypedTimes.size() - 1); if (keyCode == getAmOrPmKeyCode(AM)) { amOrPm = AM; } else if (keyCode == getAmOrPmKeyCode(PM)){ amOrPm = PM; } startIndex = 2; } int minute = -1; int hour = -1; int second = 0; int shift = mEnableSeconds ? 2 : 0; for (int i = startIndex; i <= mTypedTimes.size(); i++) { int val = getValFromKeyCode(mTypedTimes.get(mTypedTimes.size() - i)); if (mEnableSeconds) { if (i == startIndex) { second = val; } else if (i == startIndex + 1) { second += 10*val; if (enteredZeros != null && val == 0) { enteredZeros[2] = true; } } } if (i == startIndex + shift) { minute = val; } else if (i == startIndex + shift + 1) { minute += 10*val; if (enteredZeros != null && val == 0) { enteredZeros[1] = true; } } else if (i == startIndex + shift + 2) { hour = val; } else if (i == startIndex + shift + 3) { hour += 10*val; if (enteredZeros != null && val == 0) { enteredZeros[0] = true; } } } return new int[] {hour, minute, second, amOrPm}; }","old_code_raw":"    private int[] getEnteredTime(Boolean[] enteredZeros) {\n        int amOrPm = -1;\n        int startIndex = 1;\n        if (!mIs24HourMode && isTypedTimeFullyLegal()) {\n            int keyCode = mTypedTimes.get(mTypedTimes.size() - 1);\n            if (keyCode == getAmOrPmKeyCode(AM)) {\n                amOrPm = AM;\n            } else if (keyCode == getAmOrPmKeyCode(PM)){\n                amOrPm = PM;\n            }\n            startIndex = 2;\n        }\n        int minute = -1;\n        int hour = -1;\n        for (int i = startIndex; i <= mTypedTimes.size(); i++) {\n            int val = getValFromKeyCode(mTypedTimes.get(mTypedTimes.size() - i));\n            if (i == startIndex) {\n                minute = val;\n            } else if (i == startIndex+1) {\n                minute += 10*val;\n                if (enteredZeros != null && val == 0) {\n                    enteredZeros[1] = true;\n                }\n            } else if (i == startIndex+2) {\n                hour = val;\n            } else if (i == startIndex+3) {\n                hour += 10*val;\n                if (enteredZeros != null && val == 0) {\n                    enteredZeros[0] = true;\n                }\n            }\n        }\n\n        return new int[] {hour, minute, amOrPm};\n    }\n","new_comment_raw":"Get the currently-entered time, as integer values of the hours, minutes and seconds typed.","old_comment_raw":"Get the currently-entered time, as integer values of the hours and minutes typed.","label":1,"pre_label":0,"AST_level":16,"line_counts":48,"new_code_token_num":297},{"new_code_raw":"public int get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }","old_code_raw":"    public int get(WithAttributes attributes) {\r\n        return attributes.getAttributes().get(this);\r\n    }\r\n","new_comment_raw":"Extracts the attribute map from the specified  WithAttributes and returns the value of this attribute from the map.","old_comment_raw":"Analogous to #get(WithAttributes) except returning a primitive int.","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":19},{"new_code_raw":"public boolean isOK() { return (serialIO != null); }","old_code_raw":"    public boolean isOK() {\n        if (serialIO != null) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n","new_comment_raw":"Checks if the serial communication channel is open.","old_comment_raw":"checks if connection is ok.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":14},{"new_code_raw":"public static String deprocess(String str) { if ((str == null) || (str.length() <= 1)) return str; STextEnvironment env = new STextEnvironment(null, false, STextEnvironment.ORIENT_UNKNOWN); if (!env.isProcessingNeeded()) return str; StringBuffer buf = new StringBuffer(); int strLen = str.length(); for (int i = 0; i < strLen; i++) { char c = str.charAt(i); switch (c) { case LRM : continue; case LRE : continue; case PDF : continue; default : buf.append(c); } } return buf.toString(); }","old_code_raw":"\tpublic static String deprocess(String str) {\n\t\tif ((str == null) || (str.length() <= 1) || !isProcessingNeeded())\n\t\t\treturn str;\n\n\t\tStringBuffer buf = new StringBuffer();\n\t\tint strLen = str.length();\n\t\tfor (int i = 0; i < strLen; i++) {\n\t\t\tchar c = str.charAt(i);\n\t\t\tswitch (c) {\n\t\t\t\tcase LRM :\n\t\t\t\t\tcontinue;\n\t\t\t\tcase LRE :\n\t\t\t\t\tcontinue;\n\t\t\t\tcase PDF :\n\t\t\t\t\tcontinue;\n\t\t\t\tdefault :\n\t\t\t\t\tbuf.append(c);\n\t\t\t}\n\t\t}\n\t\treturn buf.toString();\n\t}\n","new_comment_raw":"Removes directional formatting characters in the given string.","old_comment_raw":"Remove directional formatting characters in the given string that were inserted by one of the #process process methods.","label":1,"pre_label":0,"AST_level":9,"line_counts":26,"new_code_token_num":125},{"new_code_raw":"public static char[] union(char[]... list) { StringBuilder sb = new StringBuilder(); for (char[] characters : list) { for (int i = 0; i < list.length; i++) { if (!contains(sb, characters[i])) sb.append(list[i]); } } char[] toReturn = new char[sb.length()]; sb.getChars(0, sb.length(), toReturn, 0); Arrays.sort(toReturn); return toReturn; }","old_code_raw":"    public static char[] union(char[] c1, char[] c2) {\r\n    \tStringBuilder sb = new StringBuilder();\r\n        for (int i = 0; i < c1.length; i++) {\r\n            if (!contains(sb, c1[i]))\r\n                sb.append(c1[i]);\r\n        }\r\n        for (int i = 0; i < c2.length; i++) {\r\n            if (!contains(sb, c2[i]))\r\n                sb.append(c2[i]);\r\n        }\r\n        char[] c3 = new char[sb.length()];\r\n        sb.getChars(0, sb.length(), c3, 0);\r\n        Arrays.sort(c3);\r\n        return c3;\r\n    }\r\n","new_comment_raw":"Union multiple character arrays.","old_comment_raw":"Union two character arrays.","label":1,"pre_label":0,"AST_level":12,"line_counts":17,"new_code_token_num":107},{"new_code_raw":"public String getSourceTableName() { return ((source != null) ? source.getTableName() : null); }","old_code_raw":"\n\tpublic String getSourceTableName()\n\t{\n\t\treturn ( ( tableName != null) ? tableName.getTableName() : \n\t\t\t\t\t((source != null) ? source.getTableName() : null));\n\t}\n","new_comment_raw":"Get the name of the underlying(base) table this column comes from, if any.","old_comment_raw":"Get the name of the table this column comes from.","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":23},{"new_code_raw":"public ScheduledReporter build() { ScheduledReporter reporter; switch (influxdbVersion) { case V08: Influxdb influxdb = buildInfluxdb(); reporter = (executor == null) ? new ReporterV08(registry, influxdb, clock, prefix, rateUnit, durationUnit, filter, skipIdleMetrics) : new ReporterV08(registry, influxdb, clock, prefix, rateUnit, durationUnit, filter, skipIdleMetrics, executor) ; break; default: Sender s = buildSender(); reporter = executor == null ? new MeasurementReporter(s, registry, filter, rateUnit, durationUnit, clock, tags, transformer) : new MeasurementReporter(s, registry, filter, rateUnit, durationUnit, clock, tags, transformer, executor) ; } return reporter; }","old_code_raw":"\t\tpublic ScheduledReporter build(Influxdb influxdb) {\n\t\t\treturn executor == null\n\t\t\t\t\t? new ReporterV08(registry, influxdb, clock, prefix, rateUnit, durationUnit, filter, skipIdleMetrics)\n\t\t\t\t\t: new ReporterV08(registry, influxdb, clock, prefix, rateUnit, durationUnit, filter, skipIdleMetrics, executor)\n\t\t\t\t\t;\n\t\t}\n","new_comment_raw":"Builds a  ScheduledReporter with the given properties, sending metrics using the given InfluxDB.","old_comment_raw":"Builds a InfluxdbReporter with the given properties, sending metrics using the given Influxdb client.","label":1,"pre_label":0,"AST_level":9,"line_counts":22,"new_code_token_num":132},{"new_code_raw":"protected long getTimeout( Session session ) { return session.getTimeout(); }","old_code_raw":"    protected int getTimeout( Session session ) {\n        return getGlobalSessionTimeout();\n    }\n","new_comment_raw":"Subclass template hook in case per-session timeout is not based on  org.jsecurity.session.Session#getTimeout().","old_comment_raw":"Returns the time in seconds the specified session may remain idle before expiring.","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":15},{"new_code_raw":"public Element writeSchema(Class javaType, Types types) throws Exception { \/\/ If an array the component type should be processed first String componentTypeName = null; Class componentType = null; if (javaType.isArray()) { String dimString = \"[]\"; componentType = javaType.getComponentType(); if (componentType.isArray()) { while (componentType.isArray()) { dimString += \"[]\"; componentType = componentType.getComponentType(); } } componentTypeName = types.getQNameString(types.getTypeQName(componentType)) + dimString; } \/\/ Use Types helper method to actually create the complexType return types.createArrayElement(componentTypeName); }","old_code_raw":"    public boolean writeSchema(Types types) throws Exception {\n        return false;\n    }\n","new_comment_raw":"Return XML schema for the specified type, suitable for insertion into the &lt;types&gt; element of a WSDL document, or underneath an &lt;element&gt; or &lt;attribute&gt; declaration.","old_comment_raw":"Return XML schema for the specified type, suitable for insertion into the element of a WSDL document.","label":1,"pre_label":0,"AST_level":11,"line_counts":23,"new_code_token_num":118},{"new_code_raw":"public static EBoolean endsWith(Expr<String> left, Expr<String> right) { return operationFactory.createBoolean(Ops.ENDSWITH, left, right); }","old_code_raw":"    public static EBoolean endsWith(Expr<String> left, Expr<String> right, boolean caseSensitive) {\n        if (caseSensitive){\n            return endsWith(left, right);            \n        }else{\n            return operationFactory.createBoolean(Ops.ENDSWITH_IC, left, right);\n        }\n    }\n","new_comment_raw":"Expr : left.endsWith(right)","old_comment_raw":"Expr : left.endsWith(right) (ignore case)","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":27},{"new_code_raw":"public static List<Vulnerability> getAllVulnerabilities() { initializeIfEmpty(); return Collections.unmodifiableList(vulnerabilitiesI18NMap.getVulnerabilityList(Constant.getLocale().toString())); }","old_code_raw":"\tpublic static List<Vulnerability> getAllVulnerabilities() {\n\t\tif (vulns == null) {\n\t\t\tinit();\n\t\t}\n\t\treturn vulns;\n\t}\n","new_comment_raw":"Gets an unmodifiable  List containing all the  Vulnerability for the current active Locale.","old_comment_raw":"Gets an unmodifiable List containing all the Vulnerability loaded from the path Constant.VULNS_CONFIG.","label":1,"pre_label":0,"AST_level":7,"line_counts":5,"new_code_token_num":30},{"new_code_raw":"public ApiResponse<ModelApiResponse> uploadFileWithRequiredFileWithHttpInfo(Long petId, File requiredFile, String additionalMetadata) throws ApiException { Object localVarPostBody = new Object(); \/\/ verify the required parameter 'petId' is set if (petId == null) { throw new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\"); } \/\/ verify the required parameter 'requiredFile' is set if (requiredFile == null) { throw new ApiException(400, \"Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile\"); } \/\/ create path and map variables String localVarPath = \"\/fake\/{petId}\/uploadImageWithRequiredFile\" .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString())); \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); if (additionalMetadata != null) localVarFormParams.put(\"additionalMetadata\", additionalMetadata); if (requiredFile != null) localVarFormParams.put(\"requiredFile\", requiredFile); final String[] localVarAccepts = { \"application\/json\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { \"multipart\/form-data\" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { \"petstore_auth\" }; GenericType<ModelApiResponse> localVarReturnType = new GenericType<ModelApiResponse>() {}; return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public ApiResponse<ModelApiResponse> uploadFileWithRequiredFileWithHttpInfo(Long petId, File file, String additionalMetadata) throws ApiException {\n    Object localVarPostBody = new Object();\n    \n    \/\/ verify the required parameter 'petId' is set\n    if (petId == null) {\n      throw new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\");\n    }\n    \n    \/\/ verify the required parameter 'file' is set\n    if (file == null) {\n      throw new ApiException(400, \"Missing the required parameter 'file' when calling uploadFileWithRequiredFile\");\n    }\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/fake\/{petId}\/uploadImageWithRequiredFile\"\n      .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString()));\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    if (additionalMetadata != null)\n      localVarFormParams.put(\"additionalMetadata\", additionalMetadata);\nif (file != null)\n      localVarFormParams.put(\"file\", file);\n\n    final String[] localVarAccepts = {\n      \"application\/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"multipart\/form-data\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] { \"petstore_auth\" };\n\n    GenericType<ModelApiResponse> localVarReturnType = new GenericType<ModelApiResponse>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@param requiredFile file to upload (required)","old_comment_raw":"@param file file to upload (required)","label":1,"pre_label":0,"AST_level":9,"line_counts":45,"new_code_token_num":317},{"new_code_raw":"public double distanceTo(double x, double y, double z) { final double a = this.x - x; final double b = this.y - y; final double c = this.z - z; return Math.sqrt(a * a + b * b + c * c); }","old_code_raw":"\tpublic float distanceTo(float x, float y, float z) {\n\t\tfinal float a = this.x - x;\n\t\tfinal float b = this.y - y;\n\t\tfinal float c = this.z - z;\n\t\treturn (float) Math.sqrt(a * a + b * b + c * c);\n\t}\n","new_comment_raw":"@param double x The point x coordinate.","old_comment_raw":"@param float x The point x coordinate.","label":1,"pre_label":0,"AST_level":8,"line_counts":8,"new_code_token_num":56},{"new_code_raw":"public static Area getClickbox(@Nonnull Client client, Model model, int orientation, int localX, int localY) { if (model == null) { return null; } List<Triangle> triangles = model.getTriangles().stream() .map(triangle -> triangle.rotate(orientation)) .collect(Collectors.toList()); List<Vertex> vertices = model.getVertices().stream() .map(v -> v.rotate(orientation)) .collect(Collectors.toList()); Area clickBox = get2DGeometry(client, triangles, orientation, localX, localY); Area visibleAABB = getAABB(client, vertices, orientation, localX, localY); if (visibleAABB == null || clickBox == null) { return null; } clickBox.intersect(visibleAABB); return clickBox; }","old_code_raw":"\tpublic static Area getClickbox(@Nonnull Client client, Model model, int orientation, int tileX, int tileY)\n\t{\n\t\tif (model == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tList<Triangle> triangles = model.getTriangles().stream()\n\t\t\t.map(triangle -> triangle.rotate(orientation))\n\t\t\t.collect(Collectors.toList());\n\n\t\tList<Vertex> vertices = model.getVertices().stream()\n\t\t\t\t.map(v -> v.rotate(orientation))\n\t\t\t\t.collect(Collectors.toList());\n\n\t\tArea clickBox = get2DGeometry(client, triangles, orientation, tileX, tileY);\n\t\tArea visibleAABB = getAABB(client, vertices, orientation, tileX, tileY);\n\n\t\tif (visibleAABB == null || clickBox == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tclickBox.intersect(visibleAABB);\n\t\treturn clickBox;\n\t}\n","new_comment_raw":"@param localY the y-axis coordinate of the tile","old_comment_raw":"@param tileY the y-axis coordinate of the tile","label":1,"pre_label":0,"AST_level":9,"line_counts":27,"new_code_token_num":143},{"new_code_raw":"public String invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); b.append(\"?\"); if (queryParams != null){ for (Pair queryParam : queryParams){ if (!queryParam.getName().isEmpty()) { b.append(escapeString(queryParam.getName())); b.append(\"=\"); b.append(escapeString(queryParam.getValue())); b.append(\"&\"); } } } String querystring = b.substring(0, b.length() - 1); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(\"GET\".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (\"POST\".equals(method)) { if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (\"PUT\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (\"DELETE\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, \"unknown method type \" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return \"\"; } } else { String message = \"error\"; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { \/\/ e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }","old_code_raw":"  public String invokeAPI(String path, String method, Set<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          \/\/ e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n","new_comment_raw":"@param queryParams The query parameters","old_comment_raw":"@param queryParams The query parameters","label":0,"pre_label":1,"AST_level":16,"line_counts":113,"new_code_token_num":736},{"new_code_raw":"public boolean isValid(Litmus litmus) { if (inputRowType == null) { return litmus.fail(null); } if (exprs == null) { return litmus.fail(null); } if (projects == null) { return litmus.fail(null); } if (outputRowType == null) { return litmus.fail(null); } \/\/ If the input row type is a struct (contains fields) then the leading \/\/ expressions must be references to those fields. But we don't require \/\/ this if the input row type is, say, a java class. if (inputRowType.isStruct()) { if (!RexUtil.containIdentity(exprs, inputRowType, litmus)) { return litmus.fail(null); } \/\/ None of the other fields should be inputRefs. for (int i = inputRowType.getFieldCount(); i < exprs.size(); i++) { RexNode expr = exprs.get(i); if (expr instanceof RexInputRef) { return litmus.fail(null); } } } \/\/ todo: enable \/\/ CHECKSTYLE: IGNORE 1 if (false && RexUtil.containNoCommonExprs(exprs, litmus)) { return litmus.fail(null); } if (!RexUtil.containNoForwardRefs(exprs, inputRowType, litmus)) { return litmus.fail(null); } if (!RexUtil.containNoNonTrivialAggs(exprs, litmus)) { return litmus.fail(null); } final Checker checker = new Checker( litmus, inputRowType, new AbstractList<RelDataType>() { public RelDataType get(int index) { return exprs.get(index).getType(); } @Override public int size() { return exprs.size(); } \/\/ CHECKSTYLE: IGNORE 1 }); if (condition != null) { if (!SqlTypeUtil.inBooleanFamily(condition.getType())) { return litmus.fail(\"condition must be boolean\"); } condition.accept(checker); if (checker.failCount > 0) { return litmus.fail(null); } } for (int i = 0; i < projects.size(); i++) { projects.get(i).accept(checker); if (checker.failCount > 0) { return litmus.fail(null); } } for (int i = 0; i < exprs.size(); i++) { exprs.get(i).accept(checker); if (checker.failCount > 0) { return litmus.fail(null); } } return litmus.succeed(); }","old_code_raw":"  public boolean isValid(boolean fail) {\n    if (inputRowType == null) {\n      assert !fail;\n      return false;\n    }\n    if (exprs == null) {\n      assert !fail;\n      return false;\n    }\n    if (projects == null) {\n      assert !fail;\n      return false;\n    }\n    if (outputRowType == null) {\n      assert !fail;\n      return false;\n    }\n\n    \/\/ If the input row type is a struct (contains fields) then the leading\n    \/\/ expressions must be references to those fields. But we don't require\n    \/\/ this if the input row type is, say, a java class.\n    if (inputRowType.isStruct()) {\n      if (!RexUtil.containIdentity(exprs, inputRowType, fail)) {\n        assert !fail;\n        return false;\n      }\n\n      \/\/ None of the other fields should be inputRefs.\n      for (int i = inputRowType.getFieldCount(); i < exprs.size(); i++) {\n        RexNode expr = exprs.get(i);\n        if (expr instanceof RexInputRef) {\n          assert !fail;\n          return false;\n        }\n      }\n    }\n    \/\/ todo: enable\n    \/\/ CHECKSTYLE: IGNORE 1\n    if (false && RexUtil.containCommonExprs(exprs, fail)) {\n      assert !fail;\n      return false;\n    }\n    if (RexUtil.containForwardRefs(exprs, inputRowType, fail)) {\n      assert !fail;\n      return false;\n    }\n    if (RexUtil.containNonTrivialAggs(exprs, fail)) {\n      assert !fail;\n      return false;\n    }\n    final Checker checker =\n        new Checker(\n            fail,\n            inputRowType,\n            new AbstractList<RelDataType>() {\n              public RelDataType get(int index) {\n                return exprs.get(index).getType();\n              }\n\n              @Override public int size() {\n                return exprs.size();\n              }\n              \/\/ CHECKSTYLE: IGNORE 1\n            });\n    if (condition != null) {\n      if (!SqlTypeUtil.inBooleanFamily(condition.getType())) {\n        assert !fail : \"condition must be boolean\";\n        return false;\n      }\n      condition.accept(checker);\n      if (checker.failCount > 0) {\n        assert !fail;\n        return false;\n      }\n    }\n    for (int i = 0; i < projects.size(); i++) {\n      projects.get(i).accept(checker);\n      if (checker.failCount > 0) {\n        assert !fail;\n        return false;\n      }\n    }\n    for (int i = 0; i < exprs.size(); i++) {\n      exprs.get(i).accept(checker);\n      if (checker.failCount > 0) {\n        assert !fail;\n        return false;\n      }\n    }\n    return true;\n  }\n","new_comment_raw":"@param litmus What to do if an error is detected","old_comment_raw":"@param fail Whether to fail","label":1,"pre_label":0,"AST_level":11,"line_counts":79,"new_code_token_num":478},{"new_code_raw":"public static BufferedImage alphaOffset(final Image rawImg, final float percentage) { BufferedImage image = toARGB(rawImg); final int numComponents = image.getColorModel().getNumComponents(); final float[] scales = new float[numComponents]; final float[] offsets = new float[numComponents]; Arrays.fill(scales, 1f); Arrays.fill(offsets, 0f); scales[numComponents - 1] = percentage; return offset(image, scales, offsets); }","old_code_raw":"\tpublic static BufferedImage alphaOffset(final BufferedImage image, final float percentage)\n\t{\n\t\tfinal int numComponents = image.getColorModel().getNumComponents();\n\t\tfinal float[] scales = new float[numComponents];\n\t\tfinal float[] offsets = new float[numComponents];\n\n\t\tArrays.fill(scales, 1f);\n\t\tArrays.fill(offsets, 0f);\n\t\tscales[numComponents - 1] = percentage;\n\t\treturn offset(image, scales, offsets);\n\t}\n","new_comment_raw":"@param percentage The ratio to modify the image's alpha component with. Values above 1 will increase transparency, and values below 1 will decrease transparency.","old_comment_raw":"@param percentage The ratio to modify the image's alpha component with. Values above 1 will increase transparency, and values below 1 will decrease transparency.","label":0,"pre_label":1,"AST_level":8,"line_counts":13,"new_code_token_num":89},{"new_code_raw":"public Action timedout(AtmosphereRequest request, AtmosphereResponse response) throws IOException, ServletException { AtmosphereResourceImpl r = null; try { if (trackActiveRequest) { long l = (Long) request.getAttribute(MAX_INACTIVE); if (l == -1) { \/\/ The closedDetector closed the connection. return timedoutAction; } request.setAttribute(MAX_INACTIVE, (long) -1); } logger.debug(\"Timing out the connection for request {}\", request); \/\/ Something went wrong. if (request == null || response == null) { logger.warn(\"Invalid Request\/Response: {}\/{}\", request, response); return timedoutAction; } r = (AtmosphereResourceImpl) request.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE); if (r != null && r.getAtmosphereResourceEvent().isSuspended()) { r.getAtmosphereResourceEvent().setIsResumedOnTimeout(true); Broadcaster b = r.getBroadcaster(); if (b instanceof DefaultBroadcaster) { ((DefaultBroadcaster) b).broadcastOnResume(r); } if (request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT) != null) { r.getAtmosphereResourceEvent().setIsResumedOnTimeout( (Boolean) request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT)); } invokeAtmosphereHandler(r); } } catch (Throwable t) { logger.error(\"failed to timeout resource {}\", r, t); } finally { try { if (r != null) { r.notifyListeners(); r.setIsInScope(false); r.cancel(); } } catch (Throwable t) { logger.trace(\"timedout\", t); } finally { try { response.getOutputStream().close(); } catch (Throwable t) { try { response.getWriter().close(); } catch (Throwable t2) { } } if (r != null) { destroyResource(r); } } } return timedoutAction; }","old_code_raw":"    public Action timedout(HttpServletRequest request, HttpServletResponse response)\n            throws IOException, ServletException {\n\n        AtmosphereResourceImpl r = null;\n        try {\n            if (trackActiveRequest) {\n                long l = (Long) request.getAttribute(MAX_INACTIVE);\n                if (l == -1) {\n                    \/\/ The closedDetector closed the connection.\n                    return timedoutAction;\n                }\n                request.setAttribute(MAX_INACTIVE, (long) -1);\n            }\n\n            logger.debug(\"Timing out the connection for request {}\", request);\n\n            \/\/ Something went wrong.\n            if (request == null || response == null) {\n                logger.warn(\"Invalid Request\/Response: {}\/{}\", request, response);\n                return timedoutAction;\n            }\n\n            r = (AtmosphereResourceImpl) request.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE);\n\n            if (r != null && r.getAtmosphereResourceEvent().isSuspended()) {\n                r.getAtmosphereResourceEvent().setIsResumedOnTimeout(true);\n\n                Broadcaster b = r.getBroadcaster();\n                if (b instanceof DefaultBroadcaster) {\n                    ((DefaultBroadcaster) b).broadcastOnResume(r);\n                }\n\n                if (request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT) != null) {\n                    r.getAtmosphereResourceEvent().setIsResumedOnTimeout(\n                            (Boolean) request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT));\n                }\n\n                invokeAtmosphereHandler(r);\n            }\n        } catch (Throwable t) {\n            logger.error(\"failed to timeout resource {}\", r, t);\n        } finally {\n            try {\n                if (r != null) {\n                    r.notifyListeners();\n                    r.setIsInScope(false);\n                    r.cancel();\n                }\n            } catch (Throwable t) {\n                logger.trace(\"timedout\", t);\n            } finally {\n\n                try {\n                    response.getOutputStream().close();\n                } catch (Throwable t) {\n                    try {\n                        response.getWriter().close();\n                    } catch (Throwable t2) {\n                    }\n                }\n\n                if (r != null) {\n                    destroyResource(r);\n                }\n            }\n        }\n\n        return timedoutAction;\n    }\n","new_comment_raw":"@param request the  AtmosphereRequest","old_comment_raw":"@param request the HttpServletRequest","label":1,"pre_label":0,"AST_level":13,"line_counts":70,"new_code_token_num":351},{"new_code_raw":"public int compareTo(BaseSingleFieldPeriod other) { if (other.getClass() != getClass()) { throw new ClassCastException(getClass() + \" cannot be compared to \" + other.getClass()); } int otherValue = other.getValue(); int thisValue = getValue(); if (thisValue > otherValue) { return 1; } if (thisValue < otherValue) { return -1; } return 0; }","old_code_raw":"    public int compareTo(Object other) {\n        if (other.getClass() != getClass()) {\n            throw new ClassCastException(getClass() + \" cannot be compared to \" + other.getClass());\n        }\n        int otherValue = ((BaseSingleFieldPeriod) other).getValue();\n        int thisValue = getValue();\n        if (thisValue > otherValue) {\n            return 1;\n        }\n        if (thisValue < otherValue) {\n            return -1;\n        }\n        return 0;\n    }\n","new_comment_raw":"@param other the other period, must not be null","old_comment_raw":"@param other the other period, must not be null","label":0,"pre_label":1,"AST_level":9,"line_counts":15,"new_code_token_num":80},{"new_code_raw":"private RectF drawBoxWithShadow(Canvas c, int width, int height) { Resources res = mContext.getResources(); float shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur); float keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance); float corner = res.getDimension(R.dimen.widget_preview_corner_radius); RectF bounds = new RectF(shadowBlur, shadowBlur, width - shadowBlur, height - shadowBlur - keyShadowDistance); ShadowGenerator.drawShadow(c, bounds, Color.WHITE, shadowBlur, keyShadowDistance, corner); return bounds; }","old_code_raw":"    private RectF drawBoxWithShadow(Canvas c, Paint p, int width, int height) {\n        Resources res = mContext.getResources();\n        float shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur);\n        float keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance);\n        float corner = res.getDimension(R.dimen.widget_preview_corner_radius);\n\n        RectF bounds = new RectF(shadowBlur, shadowBlur,\n                width - shadowBlur, height - shadowBlur - keyShadowDistance);\n        p.setColor(Color.WHITE);\n\n        \/\/ Key shadow\n        p.setShadowLayer(shadowBlur, 0, keyShadowDistance,\n                ShadowGenerator.KEY_SHADOW_ALPHA << 24);\n        c.drawRoundRect(bounds, corner, corner, p);\n\n        \/\/ Ambient shadow\n        p.setShadowLayer(shadowBlur, 0, 0,\n                ColorUtils.setAlphaComponent(Color.BLACK, ShadowGenerator.AMBIENT_SHADOW_ALPHA));\n        c.drawRoundRect(bounds, corner, corner, p);\n\n        p.clearShadowLayer();\n        return bounds;\n    }\n","new_comment_raw":"@param preview bitmap that can be recycled","old_comment_raw":"@param preview bitmap that can be recycled","label":0,"pre_label":1,"AST_level":8,"line_counts":12,"new_code_token_num":92},{"new_code_raw":"private static String toString(Collection<TypedDependency> dependencies, boolean extraSep, boolean includeTags) { String labelFormat = (includeTags) ? \"value-tag-index\" : \"value-index\"; StringBuilder buf = new StringBuilder(); if (extraSep) { List<TypedDependency> extraDeps = new ArrayList<TypedDependency>(); for (TypedDependency td : dependencies) { if (td.extra()) { extraDeps.add(td); } else { buf.append(td.toString(labelFormat)).append('\\n'); } } \/\/ now we print the separator for extra dependencies, and print these if there are some if (!extraDeps.isEmpty()) { buf.append(\"======\\n\"); for (TypedDependency td : extraDeps) { buf.append(td.toString(labelFormat)).append('\\n'); } } } else { for (TypedDependency td : dependencies) { buf.append(td.toString(labelFormat)).append('\\n'); } } return buf.toString(); }","old_code_raw":"  private static String toString(Collection<TypedDependency> dependencies, boolean extraSep) {\n    StringBuilder buf = new StringBuilder();\n    if (extraSep) {\n      List<TypedDependency> extraDeps =  new ArrayList<TypedDependency>();\n      for (TypedDependency td : dependencies) {\n        if (td.extra()) {\n          extraDeps.add(td);\n        } else {\n          buf.append(td.toString(\"value-tag-index\")).append('\\n');\n        }\n      }\n      \/\/ now we print the separator for extra dependencies, and print these if there are some\n      if (!extraDeps.isEmpty()) {\n        buf.append(\"======\\n\");\n        for (TypedDependency td : extraDeps) {\n          buf.append(td.toString(\"value-tag-index\")).append('\\n');\n        }\n      }\n    } else {\n      for (TypedDependency td : dependencies) {\n        buf.append(td.toString(\"value-tag-index\")).append('\\n');\n      }\n    }\n    return buf.toString();\n  }\n","new_comment_raw":"@param dependencies The TypedDependencies to print","old_comment_raw":"@param dependencies The TypedDependencies to print","label":0,"pre_label":1,"AST_level":12,"line_counts":27,"new_code_token_num":201},{"new_code_raw":"public FilterRegistration.Dynamic addFilter(String name, Class<? extends Filter> klass) { final FilterHolder holder = new FilterHolder(checkNotNull(klass)); holder.setName(name); handler.getServletHandler().addFilter(holder); return holder.getRegistration(); }","old_code_raw":"    public FilterBuilder addFilter(Class<? extends Filter> klass,\n                                   String urlPattern) {\n        final FilterHolder holder = new FilterHolder(checkNotNull(klass));\n        final FilterBuilder filterConfig = new FilterBuilder(holder, handler);\n        filterConfig.addUrlPattern(checkNotNull(urlPattern));\n        return filterConfig;\n    }\n","new_comment_raw":"@param klass the filter class","old_comment_raw":"@param urlPattern the URL pattern for requests that should be handled by instances of klass","label":1,"pre_label":0,"AST_level":7,"line_counts":8,"new_code_token_num":49},{"new_code_raw":"private boolean paramAppend(StringBuilder sb, String name, String value, ParameterParser parser) { boolean isEdited = false; if (name != null) { sb.append(name); isEdited = true; } if (value != null) { sb.append(parser.getDefaultKeyValueSeparator()); sb.append(value); isEdited = true; } return isEdited; }","old_code_raw":"    private boolean paramAppend(StringBuilder sb, String name, String value) {\n        boolean isEdited = false;\n        \n        if (name != null) {\n            sb.append(name);\n            isEdited = true;\n        }\n        \n        if (value != null) {\n            sb.append('=');\n            sb.append(value);\n            isEdited = true;\n        }\n        \n        return isEdited;\n    }\n","new_comment_raw":"@param name Null = not to append parameter.","old_comment_raw":"@param name Null = not to append parameter.","label":0,"pre_label":1,"AST_level":7,"line_counts":17,"new_code_token_num":68},{"new_code_raw":"public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws ApiException { return uploadFileWithRequiredFileWithHttpInfo(petId, requiredFile, additionalMetadata).getData(); }","old_code_raw":"  public ModelApiResponse uploadFileWithRequiredFile(Long petId, File file, String additionalMetadata) throws ApiException {\n    return uploadFileWithRequiredFileWithHttpInfo(petId, file, additionalMetadata).getData();\n      }\n","new_comment_raw":"@param requiredFile file to upload (required)","old_comment_raw":"@param file file to upload (required)","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":30},{"new_code_raw":"public Optional<GraphQLError> add(SDLDefinition definition) { \/\/ extensions if (definition instanceof ObjectTypeExtensionDefinition) { ObjectTypeExtensionDefinition newEntry = (ObjectTypeExtensionDefinition) definition; return defineExt(typeExtensions, newEntry, ObjectTypeExtensionDefinition::getName); } else if (definition instanceof InterfaceTypeExtensionDefinition) { InterfaceTypeExtensionDefinition newEntry = (InterfaceTypeExtensionDefinition) definition; return defineExt(interfaceTypeExtensions, newEntry, InterfaceTypeExtensionDefinition::getName); } else if (definition instanceof UnionTypeExtensionDefinition) { UnionTypeExtensionDefinition newEntry = (UnionTypeExtensionDefinition) definition; return defineExt(unionTypeExtensions, newEntry, UnionTypeExtensionDefinition::getName); } else if (definition instanceof EnumTypeExtensionDefinition) { EnumTypeExtensionDefinition newEntry = (EnumTypeExtensionDefinition) definition; return defineExt(enumTypeExtensions, newEntry, EnumTypeExtensionDefinition::getName); } else if (definition instanceof ScalarTypeExtensionDefinition) { ScalarTypeExtensionDefinition newEntry = (ScalarTypeExtensionDefinition) definition; return defineExt(scalarTypeExtensions, newEntry, ScalarTypeExtensionDefinition::getName); } else if (definition instanceof InputObjectTypeExtensionDefinition) { InputObjectTypeExtensionDefinition newEntry = (InputObjectTypeExtensionDefinition) definition; return defineExt(inputObjectTypeExtensions, newEntry, InputObjectTypeExtensionDefinition::getName); \/\/ \/\/ normal } else if (definition instanceof ScalarTypeDefinition) { ScalarTypeDefinition newEntry = (ScalarTypeDefinition) definition; return define(scalarTypes, scalarTypes, newEntry); } else if (definition instanceof TypeDefinition) { TypeDefinition newEntry = (TypeDefinition) definition; return define(types, types, newEntry); } else if (definition instanceof DirectiveDefinition) { DirectiveDefinition newEntry = (DirectiveDefinition) definition; return define(directiveDefinitions, directiveDefinitions, newEntry); } else if (definition instanceof SchemaDefinition) { SchemaDefinition newSchema = (SchemaDefinition) definition; if (schema != null) { return Optional.of(new SchemaRedefinitionError(this.schema, newSchema)); } else { schema = newSchema; } } else { return Assert.assertShouldNeverHappen(); } return Optional.empty(); }","old_code_raw":"    public Optional<GraphQLError> add(Definition definition) {\n        \/\/ extensions\n        if (definition instanceof ObjectTypeExtensionDefinition) {\n            ObjectTypeExtensionDefinition newEntry = (ObjectTypeExtensionDefinition) definition;\n            return defineExt(typeExtensions, newEntry, ObjectTypeExtensionDefinition::getName);\n        } else if (definition instanceof InterfaceTypeExtensionDefinition) {\n            InterfaceTypeExtensionDefinition newEntry = (InterfaceTypeExtensionDefinition) definition;\n            return defineExt(interfaceTypeExtensions, newEntry, InterfaceTypeExtensionDefinition::getName);\n        } else if (definition instanceof UnionTypeExtensionDefinition) {\n            UnionTypeExtensionDefinition newEntry = (UnionTypeExtensionDefinition) definition;\n            return defineExt(unionTypeExtensions, newEntry, UnionTypeExtensionDefinition::getName);\n        } else if (definition instanceof EnumTypeExtensionDefinition) {\n            EnumTypeExtensionDefinition newEntry = (EnumTypeExtensionDefinition) definition;\n            return defineExt(enumTypeExtensions, newEntry, EnumTypeExtensionDefinition::getName);\n        } else if (definition instanceof ScalarTypeExtensionDefinition) {\n            ScalarTypeExtensionDefinition newEntry = (ScalarTypeExtensionDefinition) definition;\n            return defineExt(scalarTypeExtensions, newEntry, ScalarTypeExtensionDefinition::getName);\n        } else if (definition instanceof InputObjectTypeExtensionDefinition) {\n            InputObjectTypeExtensionDefinition newEntry = (InputObjectTypeExtensionDefinition) definition;\n            return defineExt(inputObjectTypeExtensions, newEntry, InputObjectTypeExtensionDefinition::getName);\n            \/\/\n            \/\/ normal\n        } else if (definition instanceof ScalarTypeDefinition) {\n            ScalarTypeDefinition newEntry = (ScalarTypeDefinition) definition;\n            return define(scalarTypes, scalarTypes, newEntry);\n        } else if (definition instanceof TypeDefinition) {\n            TypeDefinition newEntry = (TypeDefinition) definition;\n            return define(types, types, newEntry);\n        } else if (definition instanceof DirectiveDefinition) {\n            DirectiveDefinition newEntry = (DirectiveDefinition) definition;\n            return define(directiveDefinitions, directiveDefinitions, newEntry);\n        } else if (definition instanceof SchemaDefinition) {\n            SchemaDefinition newSchema = (SchemaDefinition) definition;\n            if (schema != null) {\n                return Optional.of(new SchemaRedefinitionError(this.schema, newSchema));\n            } else {\n                schema = newSchema;\n            }\n        }\n        return Optional.empty();\n    }\n","new_comment_raw":"@param definition the definition to add","old_comment_raw":"@param definition the definition to add","label":0,"pre_label":1,"AST_level":20,"line_counts":44,"new_code_token_num":328},{"new_code_raw":"public Action timedout(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { AtmosphereResourceImpl re; long l = (Long) request.getAttribute(MAX_INACTIVE); if (l == -1) { \/\/ The closedDetector closed the connection. return timedoutAction; } request.setAttribute(MAX_INACTIVE, (long) -1); \/\/ Something went wrong. if (request == null || response == null) { logger.warn(\"Invalid Request\/Response: {}\/{}\", request, response); return timedoutAction; } re = (AtmosphereResourceImpl) request.getAttribute(AtmosphereServlet.ATMOSPHERE_RESOURCE); if (re != null) { re.getAtmosphereResourceEvent().setIsResumedOnTimeout(true); Broadcaster b = re.getBroadcaster(); if (b instanceof DefaultBroadcaster) { ((DefaultBroadcaster)b).broadcastOnResume(re); } if (re.getRequest().getAttribute(AtmosphereServlet.RESUMED_ON_TIMEOUT) != null) { re.getAtmosphereResourceEvent().setIsResumedOnTimeout( (Boolean) re.getRequest().getAttribute(AtmosphereServlet.RESUMED_ON_TIMEOUT)); } invokeAtmosphereHandler(re); } return timedoutAction; }","old_code_raw":"    public Action timedout(HttpServletRequest req, HttpServletResponse res)\n            throws IOException, ServletException {\n\n        AtmosphereResourceImpl re;\n        long l = (Long) req.getAttribute(MAX_INACTIVE);\n        if (l == -1) {\n            \/\/ The closedDetector closed the connection.\n            return timedoutAction;            \n        }\n        req.setAttribute(MAX_INACTIVE, (long)-1);\n\n        \/\/ Something went wrong.\n        if (req == null || res == null) {\n            logger.warning(\"Invalid Request\/Response: \" + req + \"\/\" + res);\n            return timedoutAction;\n        }\n\n        re = (AtmosphereResourceImpl) req.getAttribute(AtmosphereServlet.ATMOSPHERE_RESOURCE);\n\n        if (re != null) {\n            re.getAtmosphereResourceEvent().setIsResumedOnTimeout(true);\n\n            Broadcaster b = re.getBroadcaster();\n            if (b instanceof DefaultBroadcaster) {\n                ((DefaultBroadcaster)b).broadcastOnResume(re);\n            }\n\n            if (re.getRequest().getAttribute(AtmosphereServlet.RESUMED_ON_TIMEOUT) != null) {\n                re.getAtmosphereResourceEvent().setIsResumedOnTimeout(\n                        (Boolean) re.getRequest().getAttribute(AtmosphereServlet.RESUMED_ON_TIMEOUT));\n            }\n            invokeAtmosphereHandler(re);\n        }\n\n        return timedoutAction;\n    }\n","new_comment_raw":"@param response the  HttpServletResponse","old_comment_raw":"@param res the HttpServletResponse","label":1,"pre_label":0,"AST_level":13,"line_counts":37,"new_code_token_num":198},{"new_code_raw":"public boolean searchWithTimeoutFor(Class<? extends TextView> viewClass, String regex, int expectedMinimumNumberOfMatches, boolean scroll, boolean visible) { final long endTime = System.currentTimeMillis() + TIMEOUT; while (System.currentTimeMillis() < endTime) { sleeper.sleep(); final boolean foundAnyMatchingView = searchFor(viewClass, regex, expectedMinimumNumberOfMatches, scroll, visible); if (foundAnyMatchingView){ return true; } } return false; }","old_code_raw":"\tpublic boolean searchWithTimeoutFor(Class<? extends TextView> viewClass, String regex, int expectedMinimumNumberOfMatches, boolean scroll) {\n\t\tfinal long endTime = System.currentTimeMillis() + TIMEOUT;\n\n\t\twhile (System.currentTimeMillis() < endTime) {\n\t\t\tsleeper.sleep();\n\t\t\tfinal boolean foundAnyMatchingView = searchFor(viewClass, regex, expectedMinimumNumberOfMatches, scroll);\n\t\t\tif (foundAnyMatchingView){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n","new_comment_raw":"@param viewClass what kind of  View to search for, e.g.  Button.class or  TextView.class","old_comment_raw":"@param viewClass what kind of View to search for, e.g. Button.class or TextView.class","label":0,"pre_label":1,"AST_level":8,"line_counts":14,"new_code_token_num":77},{"new_code_raw":"public static int availablePort(int preferred) { int rtn = -1; try { rtn = tryPort(preferred); } catch (IOException ignored) { } return rtn; }","old_code_raw":"    public static int availablePort(int prefered) {\n        int rtn = -1;\n        try {\n            rtn = tryPort(prefered);\n        } catch (IOException e) {\n\n        }\n        return rtn;\n    }\n","new_comment_raw":"@param preferred preferred port","old_comment_raw":"@param prefered","label":1,"pre_label":0,"AST_level":7,"line_counts":9,"new_code_token_num":34},{"new_code_raw":"public Collection<Tree> getRelatedNodes(Tree t, Tree root) { if (root.value() == null) { root.setValue(\"ROOT\"); \/\/ todo: cdm: it doesn't seem like this line should be here } Set<Tree> nodeList = new LinkedHashSet<Tree>(); for (TregexPattern p : targetPatterns) { \/\/ cdm: I deleted: && nodeList.isEmpty() TregexMatcher m = p.matcher(root); while (m.findAt(t)) { nodeList.add(m.getNode(\"target\")); if (DEBUG) { System.err.println(\"found \" + this + \"(\" + t + \", \" + m.getNode(\"target\") + \") using pattern \" + p); for (String nodeName : m.getNodeNames()) { if (nodeName.equals(\"target\")) continue; System.err.println(\" node \" + nodeName + \": \" + m.getNode(nodeName)); } } } } return nodeList; }","old_code_raw":"  public Collection<TreeGraphNode> getRelatedNodes(TreeGraphNode t, TreeGraphNode root, HeadFinder headFinder) {\n    Set<TreeGraphNode> nodeList = new ArraySet<>();\n    for (TregexPattern p : targetPatterns) {    \/\/ cdm: I deleted: && nodeList.isEmpty()\n      \/\/ Initialize the TregexMatcher with the HeadFinder so that we\n      \/\/ can use the same HeadFinder through the entire process of\n      \/\/ building the dependencies\n      TregexMatcher m = p.matcher(root, headFinder);\n      while (m.findAt(t)) {\n        TreeGraphNode target = (TreeGraphNode) m.getNode(\"target\");\n        if (target == null) {\n          throw new AssertionError(\"Expression has no target: \" + p);\n        }\n        nodeList.add(target);\n        if (DEBUG) {\n          System.err.println(\"found \" + this + \"(\" + t + \"-\" + t.headWordNode() + \", \" + m.getNode(\"target\") + \"-\" + ((TreeGraphNode) m.getNode(\"target\")).headWordNode() + \") using pattern \" + p);\n          for (String nodeName : m.getNodeNames()) {\n            if (nodeName.equals(\"target\"))\n              continue;\n            System.err.println(\"  node \" + nodeName + \": \" + m.getNode(nodeName));\n          }\n        }\n      }\n    }\n    return nodeList;\n  }\n","new_comment_raw":"@param root The root of the Tree","old_comment_raw":"@param root The root of the Tree","label":0,"pre_label":1,"AST_level":18,"line_counts":22,"new_code_token_num":200},{"new_code_raw":"static public IStructuredTextExpert getStatefulExpert(String type, StructuredTextEnvironment environment) { StructuredTextTypeHandler handler = StructuredTextTypeHandlerFactory.getHandler(type); if (handler == null) throw new IllegalArgumentException(\"Invalid type argument\"); \/\/$NON-NLS-1$ return getStatefulExpert(handler, environment); }","old_code_raw":"\tstatic public ISTextExpert getStatefulExpert(String type, STextEnvironment environment) {\n\t\tSTextTypeHandler handler = STextTypeHandlerFactory.getHandler(type);\n\t\tif (handler == null)\n\t\t\tthrow new IllegalArgumentException(\"Invalid type argument\"); \/\/$NON-NLS-1$\n\t\treturn getStatefulExpert(handler, environment);\n\t}\n","new_comment_raw":"@param type the identifier for the required type handler. This identifier may be one of those listed in  StructuredTextTypeHandlerFactory or it may be have been registered by a plug-in.","old_comment_raw":"@param type the identifier for the required type handler. This identifier may be one of those listed in STextTypeHandlerFactory or it may be have been registered by a plug-in.","label":1,"pre_label":0,"AST_level":6,"line_counts":8,"new_code_token_num":54},{"new_code_raw":"private boolean scanSingleNode(Plugin plugin, StructuralNode node) { Thread thread; Plugin test; HttpMessage msg; log.debug(\"scanSingleNode node plugin=\" + plugin.getName() + \" node=\" + node.getName()); \/\/ do not poll for isStop here to allow every plugin to run but terminate immediately. \/\/if (isStop()) return; try { if (node == null || node.getHistoryReference() == null) { log.debug(\"scanSingleNode node or href null, returning: node=\" + node); return false; } if (HistoryReference.TYPE_SCANNER == node.getHistoryReference().getHistoryType()) { log.debug(\"Ignoring \\\"scanner\\\" type href\"); return false; } if (!nodeInScope(node.getName())) { log.debug(\"scanSingleNode node not in scope\"); return false; } msg = node.getHistoryReference().getHttpMessage(); if (msg == null) { \/\/ Likely to be a temporary node log.debug(\"scanSingleNode msg null\"); return false; } test = plugin.getClass().newInstance(); test.setConfig(plugin.getConfig()); test.setDelayInMs(plugin.getDelayInMs()); test.setDefaultAlertThreshold(plugin.getAlertThreshold()); test.setDefaultAttackStrength(plugin.getAttackStrength()); test.setTechSet(getTechSet()); test.init(msg, this); notifyHostProgress(plugin.getName() + \": \" + msg.getRequestHeader().getURI().toString()); } catch (Exception e) { log.error(e.getMessage() + \" \" + node.getName(), e); return false; } do { if (this.isStop()) { return false; } thread = threadPool.getFreeThreadAndRun(test); if (thread == null) { Util.sleep(200); } } while (thread == null); return true; }","old_code_raw":"    private boolean scanSingleNode(Plugin plugin, SiteNode node) {\n        Thread thread;\n        Plugin test;\n        HttpMessage msg;\n        \n        log.debug(\"scanSingleNode node plugin=\" + plugin.getName() + \" node=\" + node);\n\n        \/\/ do not poll for isStop here to allow every plugin to run but terminate immediately.\n        \/\/if (isStop()) return;\n\n        try {\n            if (node == null || node.getHistoryReference() == null) {\n                log.debug(\"scanSingleNode node or href null, returning: node=\" + node);\n                return false;\n            }\n            \n            if (HistoryReference.TYPE_SCANNER == node.getHistoryReference().getHistoryType()) {\n                log.debug(\"Ignoring \\\"scanner\\\" type href\");\n                return false;\n            }\n\n            if (!nodeInScope(node)) {\n                log.debug(\"scanSingleNode node not in scope\");\n                return false;\n            }\n            \n            msg = node.getHistoryReference().getHttpMessage();\n\n            if (msg == null) {\n                \/\/ Likely to be a temporary node\n                log.debug(\"scanSingleNode msg null\");\n                return false;\n            }\n\n            test = plugin.getClass().newInstance();\n            test.setConfig(plugin.getConfig());\n            test.setDelayInMs(plugin.getDelayInMs());\n            test.setDefaultAlertThreshold(plugin.getAlertThreshold());\n            test.setDefaultAttackStrength(plugin.getAttackStrength());\n            test.setTechSet(getTechSet());\n            test.init(msg, this);\n            notifyHostProgress(plugin.getName() + \": \" + msg.getRequestHeader().getURI().toString());\n\n        } catch (Exception e) {\n            if (node != null) {\n                log.error(e.getMessage() + \" \" + node.getNodeName(), e);\n                \n            } else {\n                log.error(e.getMessage(), e);\n            }\n            \n            return false;\n        }\n\n        do {\n            thread = threadPool.getFreeThreadAndRun(test);\n            if (thread == null) {\n                Util.sleep(200);\n            }\n            \n        } while (thread == null);\n\n        return true;\n    }\n","new_comment_raw":"@param plugin","old_comment_raw":"@param plugin","label":0,"pre_label":1,"AST_level":9,"line_counts":62,"new_code_token_num":364},{"new_code_raw":"public Order placeOrder(Order order) throws ApiException { ApiResponse<Order> resp = placeOrderWithHttpInfo(order); return resp.getData(); }","old_code_raw":"    public Order placeOrder(Order body) throws ApiException {\n        ApiResponse<Order> resp = placeOrderWithHttpInfo(body);\n        return resp.getData();\n    }\n","new_comment_raw":"@param order order placed for purchasing the pet (required)","old_comment_raw":"@param body order placed for purchasing the pet (required)","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":25},{"new_code_raw":"public FilterBuilder addFilter(Class<? extends Filter> klass, String urlPattern) { final FilterHolder holder = new FilterHolder(checkNotNull(klass)); final FilterBuilder filterConfig = new FilterBuilder(holder, handler); filterConfig.addUrlPattern(checkNotNull(urlPattern)); return filterConfig; }","old_code_raw":"    public FilterRegistration.Dynamic addFilter(String name, Class<? extends Filter> klass) {\n        final FilterHolder holder = new FilterHolder(checkNotNull(klass));\n        holder.setName(name);\n        handler.getServletHandler().addFilter(holder);\n        return holder.getRegistration();\n    }\n","new_comment_raw":"@param klass the filter class","old_comment_raw":"@param name the filter's name","label":1,"pre_label":0,"AST_level":7,"line_counts":9,"new_code_token_num":50},{"new_code_raw":"protected Object convertSetToString(List<String> options, Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return \"\"; } if (data instanceof String) { \/\/ JDBC should return strings ... return data; } if (data instanceof Long) { \/\/ The binlog will contain a long with the indexes of the options in the set value ... long indexes = ((Long) data).longValue(); return convertSetValue(indexes, options); } return handleUnknownData(column, fieldDefn, data); }","old_code_raw":"    protected Object convertSetToString(String options, Column column, Field fieldDefn, Object data) {\n        if (data == null) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return \"\";\n        }\n        if (data instanceof String) {\n            \/\/ JDBC should return strings ...\n            return data;\n        }\n        if (data instanceof Long) {\n            \/\/ The binlog will contain a long with the indexes of the options in the set value ...\n            long indexes = ((Long) data).longValue();\n            return convertSetValue(indexes, options);\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n","new_comment_raw":"@param fieldDefn the field definition; never null","old_comment_raw":"@param fieldDefn the field definition; never null","label":0,"pre_label":1,"AST_level":8,"line_counts":20,"new_code_token_num":129},{"new_code_raw":"public final List<ModuleReference> getDependentModulesRecursively(final ModuleReference ref) throws Exception { return getDependentModulesRecursively(ref, new ArrayList<ModuleReference>()); }","old_code_raw":"    public synchronized final List<String> getDependentModulesRecursively(final String id) throws Exception {\r\n        final List<String> res = new ArrayList<String>();\r\n        for (final String depModule : getDependentModules(id)) {\r\n            res.add(depModule);\r\n            \/\/ the graph has no cycle, so we don't need to protected against infinite loop\r\n\r\n            res.addAll(this.getDependentModulesRecursively(depModule));\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n","new_comment_raw":"@param ref the module.","old_comment_raw":"@param id the module.","label":1,"pre_label":0,"AST_level":8,"line_counts":5,"new_code_token_num":26},{"new_code_raw":"public FilterBuilder addFilter(Filter filter, String urlPattern) { final FilterHolder holder = new FilterHolder(checkNotNull(filter)); final FilterBuilder builder = new FilterBuilder(holder, handler); builder.addUrlPattern(checkNotNull(urlPattern)); return builder; }","old_code_raw":"    public FilterRegistration.Dynamic addFilter(String name, Filter filter) {\n        final FilterHolder holder = new FilterHolder(checkNotNull(filter));\n        holder.setName(name);\n        handler.getServletHandler().addFilter(holder);\n        return holder.getRegistration();\n    }\n","new_comment_raw":"@param filter the filter instance","old_comment_raw":"@param name the filter's name","label":1,"pre_label":0,"AST_level":7,"line_counts":9,"new_code_token_num":47},{"new_code_raw":"public String getTypeName(int code, long length, int precision, int scale) throws HibernateException { String result = typeNames.get( code, length, precision, scale ); if ( result == null ) { throw new HibernateException( \"No type mapping for java.sql.Types code: \" + code + \", length: \" + length ); } return result; }","old_code_raw":"\tpublic String getTypeName(int code, int length, int precision, int scale) throws HibernateException {\n\t\tString result = typeNames.get( code, length, precision, scale );\n\t\tif ( result == null ) {\n\t\t\tthrow new HibernateException(\n\t\t\t\t\t\"No type mapping for java.sql.Types code: \" +\n\t\t\t\t\tcode +\n\t\t\t\t\t\", length: \" +\n\t\t\t\t\tlength\n\t\t\t);\n\t\t}\n\t\treturn result;\n\t}\n","new_comment_raw":"@param scale The datatype scale","old_comment_raw":"@param scale The datatype scale","label":0,"pre_label":1,"AST_level":10,"line_counts":13,"new_code_token_num":71},{"new_code_raw":"public static SummaryEntry[] querySummaries(Variations variationPatterns, String scenarioPattern) { return getDefault().internalQuerySummaries(variationPatterns, scenarioPattern); }","old_code_raw":"    public static SummaryEntry[] querySummaries(Variations variationPatterns, boolean global) {\n        return getDefault().internalQuerySummaries(variationPatterns, null);\n    }\n","new_comment_raw":"@param scenarioPattern","old_comment_raw":"@param global","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":26},{"new_code_raw":"public PMetadata getCache(PGraphics renderer) { if (cacheMap == null) return null; return cacheMap.get(renderer); }","old_code_raw":"  public Object getCache(Object parent) {\n    if (cacheMap == null) return null;\n    return cacheMap.get(parent);\n  }\n","new_comment_raw":"@param renderer The PGraphics renderer associated to the image","old_comment_raw":"@param parent The PGraphics object (or any object, really) associated","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":24},{"new_code_raw":"private FileSelection expandSelectionFromMetadataCache(FileSelection selection, List<Path> metaFilePaths) throws IOException { \/\/ get the metadata for the root directory by reading the metadata file \/\/ parquetTableMetadata contains the metadata for all files in the selection root folder, but we need to make sure \/\/ we only select the files that are part of selection (by setting fileSet appropriately) \/\/ get (and set internal field) the metadata for the directory by reading the metadata file FileSystem processUserFileSystem = ImpersonationUtil.createFileSystem(ImpersonationUtil.getProcessUserName(), fs.getConf()); parquetTableMetadata = Metadata.readBlockMeta(processUserFileSystem, metaFilePaths, metaContext, readerConfig); if (ignoreExpandingSelection(parquetTableMetadata)) { return selection; } if (corruptDatesAutoCorrected) { ParquetReaderUtility.correctDatesInMetadataCache(this.parquetTableMetadata); } ParquetReaderUtility.transformBinaryInMetadataCache(parquetTableMetadata, readerConfig); List<FileStatus> fileStatuses = selection.getStatuses(fs); if (fileSet == null) { fileSet = new HashSet<>(); } final Path first = fileStatuses.get(0).getPath(); if (fileStatuses.size() == 1 && selection.getSelectionRoot().equals(first)) { \/\/ we are selecting all files from selection root. Expand the file list from the cache for (MetadataBase.ParquetFileMetadata file : parquetTableMetadata.getFiles()) { fileSet.add(file.getPath()); } } else if (selection.isExpandedPartial() && !selection.hadWildcard() && cacheFileRoot != null) { if (selection.wasAllPartitionsPruned()) { \/\/ if all partitions were previously pruned, we only need to read 1 file (for the schema) fileSet.add(this.parquetTableMetadata.getFiles().get(0).getPath()); } else { \/\/ we are here if the selection is in the expanded_partial state (i.e it has directories). We get the \/\/ list of files from the metadata cache file that is present in the cacheFileRoot directory and populate \/\/ the fileSet. However, this is *not* the final list of files that will be scanned in execution since the \/\/ second phase of partition pruning will apply on the files and modify the file selection appropriately. for (MetadataBase.ParquetFileMetadata file : this.parquetTableMetadata.getFiles()) { fileSet.add(file.getPath()); } } } else { \/\/ we need to expand the files from fileStatuses for (FileStatus status : fileStatuses) { Path currentCacheFileRoot = status.getPath(); if (status.isDirectory()) { \/\/ TODO [DRILL-4496] read the metadata cache files in parallel \/\/ Depending on the version of metadata this may represent more than 1 metadata file paths. List<Path> metaPaths = populateMetaPaths(currentCacheFileRoot, fs); MetadataBase.ParquetTableMetadataBase metadata = Metadata.readBlockMeta(processUserFileSystem, metaPaths, metaContext, readerConfig); if (ignoreExpandingSelection(metadata)) { return selection; } for (MetadataBase.ParquetFileMetadata file : metadata.getFiles()) { fileSet.add(file.getPath()); } } else { final Path path = Path.getPathWithoutSchemeAndAuthority(currentCacheFileRoot); fileSet.add(path); } } } if (fileSet.isEmpty()) { \/\/ no files were found, most likely we tried to query some empty sub folders logger.warn(\"The table is empty but with outdated invalid metadata cache files. Please, delete them.\"); return null; } List<Path> fileNames = new ArrayList<>(fileSet); \/\/ when creating the file selection, set the selection root without the URI prefix \/\/ The reason is that the file names above have been created in the form \/\/ \/a\/b\/c.parquet and the format of the selection root must match that of the file names \/\/ otherwise downstream operations such as partition pruning can break. Path metaRootPath = Path.getPathWithoutSchemeAndAuthority(selection.getSelectionRoot()); this.selectionRoot = metaRootPath; \/\/ Use the FileSelection constructor directly here instead of the FileSelection.create() method \/\/ because create() changes the root to include the scheme and authority; In future, if create() \/\/ is the preferred way to instantiate a file selection, we may need to do something different... \/\/ WARNING: file statuses and file names are inconsistent FileSelection newSelection = new FileSelection(selection.getStatuses(fs), fileNames, metaRootPath, cacheFileRoot, selection.wasAllPartitionsPruned()); newSelection.setExpandedFully(); newSelection.setMetaContext(metaContext); return newSelection; }","old_code_raw":"  private FileSelection expandSelectionFromMetadataCache(FileSelection selection, Path metaFilePath) throws IOException {\n    \/\/ get the metadata for the root directory by reading the metadata file\n    \/\/ parquetTableMetadata contains the metadata for all files in the selection root folder, but we need to make sure\n    \/\/ we only select the files that are part of selection (by setting fileSet appropriately)\n\n    \/\/ get (and set internal field) the metadata for the directory by reading the metadata file\n    FileSystem processUserFileSystem = ImpersonationUtil.createFileSystem(ImpersonationUtil.getProcessUserName(), fs.getConf());\n    parquetTableMetadata = Metadata.readBlockMeta(processUserFileSystem, metaFilePath, metaContext, readerConfig);\n    if (ignoreExpandingSelection(parquetTableMetadata)) {\n      return selection;\n    }\n    if (corruptDatesAutoCorrected) {\n      ParquetReaderUtility.correctDatesInMetadataCache(this.parquetTableMetadata);\n    }\n    ParquetReaderUtility.transformBinaryInMetadataCache(parquetTableMetadata, readerConfig);\n    List<FileStatus> fileStatuses = selection.getStatuses(fs);\n\n    if (fileSet == null) {\n      fileSet = new HashSet<>();\n    }\n\n    final Path first = fileStatuses.get(0).getPath();\n    if (fileStatuses.size() == 1 && selection.getSelectionRoot().equals(first)) {\n      \/\/ we are selecting all files from selection root. Expand the file list from the cache\n      for (MetadataBase.ParquetFileMetadata file : parquetTableMetadata.getFiles()) {\n        fileSet.add(file.getPath());\n      }\n\n    } else if (selection.isExpandedPartial() && !selection.hadWildcard() && cacheFileRoot != null) {\n      if (selection.wasAllPartitionsPruned()) {\n        \/\/ if all partitions were previously pruned, we only need to read 1 file (for the schema)\n        fileSet.add(this.parquetTableMetadata.getFiles().get(0).getPath());\n      } else {\n        \/\/ we are here if the selection is in the expanded_partial state (i.e it has directories).  We get the\n        \/\/ list of files from the metadata cache file that is present in the cacheFileRoot directory and populate\n        \/\/ the fileSet. However, this is *not* the final list of files that will be scanned in execution since the\n        \/\/ second phase of partition pruning will apply on the files and modify the file selection appropriately.\n        for (MetadataBase.ParquetFileMetadata file : this.parquetTableMetadata.getFiles()) {\n          fileSet.add(file.getPath());\n        }\n      }\n    } else {\n      \/\/ we need to expand the files from fileStatuses\n      for (FileStatus status : fileStatuses) {\n        Path currentCacheFileRoot = status.getPath();\n        if (status.isDirectory()) {\n          \/\/TODO [DRILL-4496] read the metadata cache files in parallel\n          Path metaPath = new Path(currentCacheFileRoot, Metadata.METADATA_FILENAME);\n          MetadataBase.ParquetTableMetadataBase metadata = Metadata.readBlockMeta(processUserFileSystem, metaPath, metaContext, readerConfig);\n          if (ignoreExpandingSelection(metadata)) {\n            return selection;\n          }\n          for (MetadataBase.ParquetFileMetadata file : metadata.getFiles()) {\n            fileSet.add(file.getPath());\n          }\n        } else {\n          final Path path = Path.getPathWithoutSchemeAndAuthority(currentCacheFileRoot);\n          fileSet.add(path);\n        }\n      }\n    }\n\n    if (fileSet.isEmpty()) {\n      \/\/ no files were found, most likely we tried to query some empty sub folders\n      logger.warn(\"The table is empty but with outdated invalid metadata cache files. Please, delete them.\");\n      return null;\n    }\n\n    List<Path> fileNames = new ArrayList<>(fileSet);\n\n    \/\/ when creating the file selection, set the selection root without the URI prefix\n    \/\/ The reason is that the file names above have been created in the form\n    \/\/ \/a\/b\/c.parquet and the format of the selection root must match that of the file names\n    \/\/ otherwise downstream operations such as partition pruning can break.\n    Path metaRootPath = Path.getPathWithoutSchemeAndAuthority(selection.getSelectionRoot());\n    this.selectionRoot = metaRootPath;\n\n    \/\/ Use the FileSelection constructor directly here instead of the FileSelection.create() method\n    \/\/ because create() changes the root to include the scheme and authority; In future, if create()\n    \/\/ is the preferred way to instantiate a file selection, we may need to do something different...\n    \/\/ WARNING: file statuses and file names are inconsistent\n    FileSelection newSelection = new FileSelection(selection.getStatuses(fs), fileNames, metaRootPath, cacheFileRoot,\n        selection.wasAllPartitionsPruned());\n\n    newSelection.setExpandedFully();\n    newSelection.setMetaContext(metaContext);\n    return newSelection;\n  }\n","new_comment_raw":"@param metaFilePaths metadata cache file path","old_comment_raw":"@param metaFilePath metadata cache file path","label":1,"pre_label":0,"AST_level":14,"line_counts":90,"new_code_token_num":815},{"new_code_raw":"public PendingMessageCursor getSubscriberPendingMessageCursor(Broker broker,String clientId, String name, int maxBatchSize, DurableTopicSubscription sub) { return new FilePendingMessageCursor(broker,name,AbstractPendingMessageCursor.isPrioritizedMessageSubscriber(broker, sub)); }","old_code_raw":"    public PendingMessageCursor getSubscriberPendingMessageCursor(Broker broker,String clientId, String name, int maxBatchSize, Subscription sub) {\n        return new FilePendingMessageCursor(broker,name,AbstractPendingMessageCursor.isPrioritizedMessageSubscriber(broker, sub));\n    }\n","new_comment_raw":"@param broker","old_comment_raw":"@param broker","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":38},{"new_code_raw":"protected String setEscapedParameter(HttpMessage message, String param, String value) { return variant.setEscapedParameter(message, originalPair, param, value); }","old_code_raw":"    protected String setEscapedParameter(HttpMessage msg, String param, String value) {\n        return variant.setEscapedParameter(msg, originalPair, param, value);\n    }\n","new_comment_raw":"@param value the value of the parameter","old_comment_raw":"@param value","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":28},{"new_code_raw":"public PumpEnactResult applyAPSRequest(APSResult request) { request.rate = applyBasalConstraints(request.rate); PumpEnactResult result; if (!isInitialized()) { result = new PumpEnactResult(); result.comment = MainApp.sResources.getString(R.string.pumpNotInitialized); result.enacted = false; result.success = false; log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpNotInitialized)); return result; } if (isSuspended()) { result = new PumpEnactResult(); result.comment = MainApp.sResources.getString(R.string.pumpsuspended); result.enacted = false; result.success = false; log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpsuspended)); return result; } if (Config.logCongigBuilderActions) log.debug(\"applyAPSRequest: \" + request.toString()); if ((request.rate == 0 && request.duration == 0) || Math.abs(request.rate - getBaseBasalRate()) < getPumpDescription().basalStep) { if (isTempBasalInProgress()) { if (Config.logCongigBuilderActions) log.debug(\"applyAPSRequest: cancelTempBasal()\"); result = cancelTempBasal(false); } else { result = new PumpEnactResult(); result.absolute = request.rate; result.duration = 0; result.enacted = false; result.comment = \"Basal set correctly\"; result.success = true; if (Config.logCongigBuilderActions) log.debug(\"applyAPSRequest: Basal set correctly\"); } } else if (isTempBasalInProgress() && getTempBasalRemainingMinutesFromHistory() > 5 && Math.abs(request.rate - getTempBasalAbsoluteRateHistory()) < getPumpDescription().basalStep) { result = new PumpEnactResult(); result.absolute = getTempBasalAbsoluteRateHistory(); result.duration = getTempBasalFromHistory(System.currentTimeMillis()).getPlannedRemainingMinutes(); result.enacted = false; result.comment = \"Temp basal set correctly\"; result.success = true; if (Config.logCongigBuilderActions) log.debug(\"applyAPSRequest: Temp basal set correctly\"); } else { if (Config.logCongigBuilderActions) log.debug(\"applyAPSRequest: setTempBasalAbsolute()\"); result = setTempBasalAbsolute(request.rate, request.duration); } return result; }","old_code_raw":"    public boolean applyAPSRequest(APSResult request, Callback callback) {\n        PumpInterface pump = getActivePump();\n        request.rate = applyBasalConstraints(request.rate);\n\n        if (!pump.isInitialized()) {\n            log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpNotInitialized));\n            if (callback != null) {\n                callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpNotInitialized)).enacted(false).success(false)).run();\n            }\n            return false;\n        }\n\n        if (pump.isSuspended()) {\n            log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpsuspended));\n            if (callback != null) {\n                callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpsuspended)).enacted(false).success(false)).run();\n            }\n            return false;\n        }\n\n        if (request.smb != 0) {\n            long lastSMBTime = getLastBolusTime();\n            if (lastSMBTime != 0 && lastSMBTime + 4.5 * 60 * 1000 > System.currentTimeMillis()) {\n                log.debug(\"SMB requsted but still in 5 min interval\");\n            } else {\n                DetailedBolusInfo detailedBolusInfo = new DetailedBolusInfo();\n                detailedBolusInfo.eventType = CareportalEvent.CORRECTIONBOLUS;\n                detailedBolusInfo.insulin = request.smb;\n                detailedBolusInfo.isSMB = true;\n                detailedBolusInfo.source = Source.USER;\n                getCommandQueue().bolus(detailedBolusInfo, callback);\n            }\n        }\n\n        if (Config.logCongigBuilderActions)\n            log.debug(\"applyAPSRequest: \" + request.toString());\n        if ((request.rate == 0 && request.duration == 0) || Math.abs(request.rate - pump.getBaseBasalRate()) < pump.getPumpDescription().basalStep) {\n            if (isTempBasalInProgress()) {\n                if (Config.logCongigBuilderActions)\n                    log.debug(\"applyAPSRequest: cancelTempBasal()\");\n                getCommandQueue().cancelTempBasal(false, callback);\n                return true;\n            } else {\n                if (Config.logCongigBuilderActions)\n                    log.debug(\"applyAPSRequest: Basal set correctly\");\n                if (callback != null) {\n                    callback.result(new PumpEnactResult().absolute(request.rate).duration(0).enacted(false).success(true).comment(\"Basal set correctly\")).run();\n                }\n                return false;\n            }\n        } else if (isTempBasalInProgress()\n                && getTempBasalRemainingMinutesFromHistory() > 5\n                && Math.abs(request.rate - getTempBasalAbsoluteRateHistory()) < pump.getPumpDescription().basalStep) {\n            if (Config.logCongigBuilderActions)\n                log.debug(\"applyAPSRequest: Temp basal set correctly\");\n            if (callback != null) {\n                callback.result(new PumpEnactResult().absolute(getTempBasalAbsoluteRateHistory()).duration(getTempBasalFromHistory(System.currentTimeMillis()).getPlannedRemainingMinutes()).enacted(false).success(true).comment(\"Temp basal set correctly\")).run();\n            }\n            return false;\n        } else {\n            if (Config.logCongigBuilderActions)\n                log.debug(\"applyAPSRequest: setTempBasalAbsolute()\");\n            getCommandQueue().tempBasalAbsolute(request.rate, request.duration, false, callback);\n            return true;\n        }\n    }\n","new_comment_raw":"@param request","old_comment_raw":"@param request","label":0,"pre_label":1,"AST_level":10,"line_counts":58,"new_code_token_num":385},{"new_code_raw":"protected AtmosphereHandlerWrapper map(AtmosphereRequest req) throws ServletException { String path; if (req.getPathInfo() != null) { path = req.getServletPath() + req.getPathInfo(); } else { path = req.getServletPath(); } if (path == null || path.length() <= 1) { path = \"\/all\"; } AtmosphereHandlerWrapper atmosphereHandlerWrapper = map(path); if (atmosphereHandlerWrapper == null) { atmosphereHandlerWrapper = map(\"\/all\"); } if (atmosphereHandlerWrapper == null) { throw new AtmosphereMappingException(\"No AtmosphereHandler maps request for \" + path); } config.getBroadcasterFactory().add(atmosphereHandlerWrapper.broadcaster, atmosphereHandlerWrapper.broadcaster.getID()); return atmosphereHandlerWrapper; }","old_code_raw":"    protected AtmosphereHandlerWrapper map(HttpServletRequest req) throws ServletException {\n        String path;\n        if (req.getPathInfo() != null) {\n            path = req.getServletPath() + req.getPathInfo();\n        } else {\n            path = req.getServletPath();\n        }\n        if (path == null || path.length() <= 1) {\n            path = \"\/all\";\n        }\n\n        AtmosphereHandlerWrapper atmosphereHandlerWrapper = map(path);\n        if (atmosphereHandlerWrapper == null) {\n            atmosphereHandlerWrapper = map(\"\/all\");\n        }\n\n        if (atmosphereHandlerWrapper == null) {\n            throw new AtmosphereMappingException(\"No AtmosphereHandler maps request for \" + path);\n        }\n        config.getBroadcasterFactory().add(atmosphereHandlerWrapper.broadcaster,\n                atmosphereHandlerWrapper.broadcaster.getID());\n        return atmosphereHandlerWrapper;\n    }\n","new_comment_raw":"@param req the  AtmosphereResponse","old_comment_raw":"@param req the HttpServletResponse","label":1,"pre_label":0,"AST_level":8,"line_counts":24,"new_code_token_num":129},{"new_code_raw":"public static boolean simpleMatch(Collection<String> patterns, String str) { if (patterns != null) { for (String pattern : patterns) { if (simpleMatch(pattern, str)) { return true; } } } return false; }","old_code_raw":"    public static boolean simpleMatch(List<String> patterns, String str) {\n        if (patterns != null) {\n            for (String pattern : patterns) {\n                if (simpleMatch(pattern, str)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n","new_comment_raw":"@param str the String to match","old_comment_raw":"@param str the String to match","label":0,"pre_label":1,"AST_level":10,"line_counts":11,"new_code_token_num":48},{"new_code_raw":"public int compareTo(Object reference) { ServiceReference other = (ServiceReference) reference; Long id = (Long) getProperty(Constants.SERVICE_ID); Long otherId = (Long) other.getProperty(Constants.SERVICE_ID); if (id.equals(otherId)) { return 0; \/\/ same service } Integer rank = (Integer) getProperty(Constants.SERVICE_RANKING); Integer otherRank = (Integer) other .getProperty(Constants.SERVICE_RANKING); \/\/ If no rank, then spec says it defaults to zero. rank = (rank == null) ? new Integer(0) : rank; otherRank = (otherRank == null) ? new Integer(0) : otherRank; \/\/ Sort by rank in ascending order. if (rank.compareTo(otherRank) < 0) { return -1; \/\/ lower rank } else if (rank.compareTo(otherRank) > 0) { return 1; \/\/ higher rank } \/\/ If ranks are equal, then sort by service id in descending order. return (id.compareTo(otherId) < 0) ? 1 : -1; }","old_code_raw":"    public int compareTo(Object arg0) {\r\n        throw new UnsupportedOperationException(\"This feature has not yet been implemented.\");\r\n\r\n    }\r\n","new_comment_raw":"@param reference the service reference","old_comment_raw":"@param arg0 the object","label":1,"pre_label":0,"AST_level":7,"line_counts":31,"new_code_token_num":196},{"new_code_raw":"public boolean onCollapseStart(CommonCardView viewCard) { Card card = viewCard.getCard(); if (card!=null){ String itemId = card.getId(); if (mExpandedIds.contains(itemId)) { return true; } } return false; }","old_code_raw":"    public boolean onCollapseStart(CardView viewCard) {\n        Card card = viewCard.getCard();\n        if (card!=null){\n            String itemId = card.getId();\n            if (mExpandedIds.contains(itemId)) {\n                return true;\n            }\n        }\n        return false;\n    }\n","new_comment_raw":"@param viewCard","old_comment_raw":"@param viewCard","label":0,"pre_label":1,"AST_level":8,"line_counts":11,"new_code_token_num":47},{"new_code_raw":"private static CoreLabel fromProto(CoreNLPProtos.Token proto) { CoreLabel word = new CoreLabel(); \/\/ Required fields word.setWord(proto.getWord()); \/\/ Optional fields if (proto.hasPos()) { word.setTag(proto.getPos()); } if (proto.hasValue()) { word.setValue(proto.getValue()); } if (proto.hasCategory()) { word.setCategory(proto.getCategory()); } if (proto.hasBefore()) { word.setBefore(proto.getBefore()); } if (proto.hasAfter()) { word.setAfter(proto.getAfter()); } if (proto.hasOriginalText()) { word.setOriginalText(proto.getOriginalText()); } if (proto.hasNer()) { word.setNER(proto.getNer()); } if (proto.hasLemma()) { word.setLemma(proto.getLemma()); } if (proto.hasBeginChar()) { word.setBeginPosition(proto.getBeginChar()); } if (proto.hasEndChar()) { word.setEndPosition(proto.getEndChar()); } if (proto.hasSpeaker()) { word.set(SpeakerAnnotation.class, proto.getSpeaker()); } if (proto.hasUtterance()) { word.set(UtteranceAnnotation.class, proto.getUtterance()); } if (proto.hasBeginIndex()) { word.set(BeginIndexAnnotation.class, proto.getBeginIndex()); } if (proto.hasEndIndex()) { word.set(EndIndexAnnotation.class, proto.getEndIndex()); } if (proto.hasTokenBeginIndex()) { word.set(TokenBeginAnnotation.class, proto.getTokenBeginIndex()); } if (proto.hasTokenEndIndex()) { word.set(TokenEndAnnotation.class, proto.getTokenEndIndex()); } if (proto.hasNormalizedNER()) { word.set(NormalizedNamedEntityTagAnnotation.class, proto.getNormalizedNER()); } if (proto.hasTimexValue()) { word.set(TimexAnnotation.class, fromProto(proto.getTimexValue())); } if (proto.getXmlContextCount() > 0) { word.set(XmlContextAnnotation.class, proto.getXmlContextList()); } if (proto.hasCorefClusterID()) { word.set(CorefClusterIdAnnotation.class, proto.getCorefClusterID()); } \/\/ Non-default annotators if (proto.hasGender()) { word.set(GenderAnnotation.class, proto.getGender()); } if (proto.hasTrueCase()) { word.set(TrueCaseAnnotation.class, proto.getTrueCase()); } if (proto.hasTrueCaseText()) { word.set(TrueCaseTextAnnotation.class, proto.getTrueCaseText()); } \/\/ Return return word; }","old_code_raw":"  private static CoreLabel fromProto(CoreMapProtos.CoreLabel proto) {\n    CoreLabel word = new CoreLabel();\n    \/\/ Required fields\n    word.setWord(proto.getWord());\n    \/\/ Optional fields\n    if (proto.hasPos()) { word.setTag(proto.getPos()); }\n    if (proto.hasValue()) { word.setValue(proto.getValue()); }\n    if (proto.hasCategory()) { word.setCategory(proto.getCategory()); }\n    if (proto.hasBefore()) { word.setBefore(proto.getBefore()); }\n    if (proto.hasAfter()) { word.setAfter(proto.getAfter()); }\n    if (proto.hasOriginalText()) { word.setOriginalText(proto.getOriginalText()); }\n    if (proto.hasNer()) { word.setNER(proto.getNer()); }\n    if (proto.hasLemma()) { word.setLemma(proto.getLemma()); }\n    if (proto.hasBeginChar()) { word.setBeginPosition(proto.getBeginChar()); }\n    if (proto.hasEndChar()) { word.setEndPosition(proto.getEndChar()); }\n    if (proto.hasSpeaker()) { word.set(SpeakerAnnotation.class, proto.getSpeaker()); }\n    if (proto.hasUtterance()) { word.set(UtteranceAnnotation.class, proto.getUtterance()); }\n    if (proto.hasBeginIndex()) { word.set(BeginIndexAnnotation.class, proto.getBeginIndex()); }\n    if (proto.hasEndIndex()) { word.set(EndIndexAnnotation.class, proto.getEndIndex()); }\n    if (proto.hasTokenBeginIndex()) { word.set(TokenBeginAnnotation.class, proto.getTokenBeginIndex()); }\n    if (proto.hasTokenEndIndex()) { word.set(TokenEndAnnotation.class, proto.getTokenEndIndex()); }\n    if (proto.hasNormalizedNER()) { word.set(NormalizedNamedEntityTagAnnotation.class, proto.getNormalizedNER()); }\n    \/\/ Return\n    return word;\n  }\n","new_comment_raw":"@param proto The serialized protobuf to read the CoreLabel from.","old_comment_raw":"@param proto The serialized protobuf to read the CoreLabel from.","label":0,"pre_label":1,"AST_level":8,"line_counts":33,"new_code_token_num":504},{"new_code_raw":"protected static TableId parse(String[] parts, int numParts, boolean useCatalogBeforeSchema) { if (numParts == 0) return null; if (numParts == 1) return new TableId(null, null, parts[0]); \/\/ table only if (numParts == 2) { if (useCatalogBeforeSchema) return new TableId(parts[0], null, parts[1]); \/\/ catalog & table only return new TableId(null, parts[0], parts[1]); \/\/ catalog & table only } return new TableId(parts[0], parts[1], parts[2]); \/\/ catalog & table only }","old_code_raw":"    public static TableId parse(String str, char delimiter, boolean useCatalogBeforeSchema) {\n        String[] parts = str.split(\"[\\\\\" + delimiter + \"]\");\n        if (parts.length == 0) return null;\n        if (parts.length == 1) return new TableId(null, null, parts[0]); \/\/ table only\n        if (parts.length == 2) {\n            if (useCatalogBeforeSchema) return new TableId(parts[0], null, parts[1]); \/\/ catalog & table only\n            return new TableId(null, parts[0], parts[1]); \/\/ catalog & table only\n        }\n        return new TableId(parts[0], parts[1], parts[2]); \/\/ catalog & table only\n    }\n","new_comment_raw":"@param parts the parts of the identifier; may not be null","old_comment_raw":"@param str the input string","label":1,"pre_label":0,"AST_level":10,"line_counts":10,"new_code_token_num":132},{"new_code_raw":"public Client testSpecialTags(Client client, Map<String, Object> params) throws IOException { HttpResponse response = testSpecialTagsForHttpResponse(client, params); TypeReference typeRef = new TypeReference<Client>() {}; return apiClient.getObjectMapper().readValue(response.getContent(), typeRef); }","old_code_raw":"    public Client testSpecialTags(Client body, Map<String, Object> params) throws IOException {\n        HttpResponse response = testSpecialTagsForHttpResponse(body, params);\n        TypeReference typeRef = new TypeReference<Client>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    }\n","new_comment_raw":"@param client client model","old_comment_raw":"@param body client model","label":1,"pre_label":0,"AST_level":8,"line_counts":6,"new_code_token_num":51},{"new_code_raw":"private int constituents(Set<Constituent> constituentsSet, int left, ConstituentFactory cf, boolean charLevel, Predicate<Tree> filter, int maxDepth, int depth) { if(isPreTerminal()) return left + ((charLevel) ? firstChild().value().length() : 1); int position = left; \/\/ System.err.println(\"In bracketing trees left is \" + left); \/\/ System.err.println(\" label is \" + label() + \/\/ \"; num daughters: \" + children().length); Tree[] kids = children(); for (Tree kid : kids) { position = kid.constituents(constituentsSet, position, cf, charLevel, filter, maxDepth, depth + 1); \/\/ System.err.println(\" position went to \" + position); } if ((filter == null || filter.test(this)) && (maxDepth < 0 || depth <= maxDepth)) { \/\/Compute span of entire tree at the end of recursion constituentsSet.add(cf.newConstituent(left, position - 1, label(), score())); } \/\/ System.err.println(\" added \" + label()); return position; }","old_code_raw":"  private int constituents(Set<Constituent> constituentsSet, int left, ConstituentFactory cf, boolean charLevel, Filter<Tree> filter, int maxDepth, int depth) {\n\n    if(isPreTerminal())\n      return left + ((charLevel) ? firstChild().value().length() : 1);\n\n    int position = left;\n\n    \/\/ System.err.println(\"In bracketing trees left is \" + left);\n    \/\/ System.err.println(\"  label is \" + label() +\n    \/\/                       \"; num daughters: \" + children().length);\n    Tree[] kids = children();\n    for (Tree kid : kids) {\n      position = kid.constituents(constituentsSet, position, cf, charLevel, filter, maxDepth, depth + 1);\n      \/\/ System.err.println(\"  position went to \" + position);\n    }\n\n    if ((filter == null || filter.accept(this)) &&\n        (maxDepth < 0 || depth <= maxDepth)) {\n      \/\/Compute span of entire tree at the end of recursion\n      constituentsSet.add(cf.newConstituent(left, position - 1, label(), score()));\n    }\n    \/\/ System.err.println(\"  added \" + label());\n    return position;\n  }\n","new_comment_raw":"@param left left position to begin labeling the bracketings with","old_comment_raw":"@param left left position to begin labeling the bracketings with","label":0,"pre_label":1,"AST_level":9,"line_counts":25,"new_code_token_num":238},{"new_code_raw":"public static boolean filter(String path, Collection<String> includes, Collection<String> excludes, boolean allowPartialMatches) { includes = (includes == null ? Collections.<String> emptyList() : includes); excludes = (excludes == null ? Collections.<String> emptyList() : excludes); if (includes.isEmpty() && excludes.isEmpty()) { return true; } if (Regex.simpleMatch(excludes, path)) { return false; } boolean exactIncludeMatch = false; \/\/ true if the current position was specifically mentioned boolean pathIsPrefixOfAnInclude = false; \/\/ true if potentially a sub scope can be included if (includes.isEmpty()) { \/\/ implied match anything exactIncludeMatch = true; } else { for (String include : includes) { \/\/ check for prefix matches as well to see if we need to zero in, something like: obj1.arr1.* or *.field \/\/ note, this does not work well with middle matches, like obj1.*.obj3 if (include.charAt(0) == '*') { if (Regex.simpleMatch(include, path)) { exactIncludeMatch = true; break; } \/\/ pathIsPrefixOfAnInclude = true; \/\/ continue; } if (include.startsWith(path)) { if (include.length() == path.length()) { exactIncludeMatch = true; break; } else if (include.length() > path.length() && include.charAt(path.length()) == '.') { \/\/ include might may match deeper paths. Dive deeper. pathIsPrefixOfAnInclude = true; continue; } } if (Regex.simpleMatch(include, path)) { exactIncludeMatch = true; break; } } } \/\/ if match or part of the path (based on the passed param) if (exactIncludeMatch || (allowPartialMatches && pathIsPrefixOfAnInclude)) { return true; } return false; }","old_code_raw":"    public static boolean filter(String path, Collection<String> includes, Collection<String> excludes) {\n        includes = (includes == null ? Collections.<String> emptyList() : includes);\n        excludes = (excludes == null ? Collections.<String> emptyList() : excludes);\n\n        if (includes.isEmpty() && excludes.isEmpty()) {\n            return true;\n        }\n\n        if (Regex.simpleMatch(excludes, path)) {\n            return false;\n        }\n\n        boolean exactIncludeMatch = false; \/\/ true if the current position was specifically mentioned\n        boolean pathIsPrefixOfAnInclude = false; \/\/ true if potentially a sub scope can be included\n        if (includes.isEmpty()) {\n            \/\/ implied match anything\n            exactIncludeMatch = true;\n        }\n        else {\n            for (String include : includes) {\n                \/\/ check for prefix matches as well to see if we need to zero in, something like: obj1.arr1.* or *.field\n                \/\/ note, this does not work well with middle matches, like obj1.*.obj3\n                if (include.charAt(0) == '*') {\n                    if (Regex.simpleMatch(include, path)) {\n                        exactIncludeMatch = true;\n                        break;\n                    }\n\/\/                    pathIsPrefixOfAnInclude = true;\n\/\/                    continue;\n                }\n                if (include.startsWith(path)) {\n                    if (include.length() == path.length()) {\n                        exactIncludeMatch = true;\n                        break;\n                    }\n                    else if (include.length() > path.length() && include.charAt(path.length()) == '.') {\n                        \/\/ include might may match deeper paths. Dive deeper.\n                        pathIsPrefixOfAnInclude = true;\n                        continue;\n                    }\n                }\n                if (Regex.simpleMatch(include, path)) {\n                    exactIncludeMatch = true;\n                    break;\n                }\n            }\n        }\n\n        if (pathIsPrefixOfAnInclude || exactIncludeMatch) {\n            \/\/ if match or part of the path\n            return true;\n        }\n        \n        return false;\n    }\n","new_comment_raw":"@param includes","old_comment_raw":"@param includes","label":0,"pre_label":1,"AST_level":14,"line_counts":56,"new_code_token_num":344},{"new_code_raw":"public Object buildResultRow(Object[] data, ResultSet resultSet, boolean hasTransformer, SharedSessionContractImplementor session) throws SQLException, HibernateException { final Object[] resultRow = buildResultRow( data, resultSet, session ); if ( hasTransformer ) { return resultRow; } else { return resultRow.length == 1 ? resultRow[0] : resultRow; } }","old_code_raw":"\tpublic Object buildResultRow(Object[] data, ResultSet resultSet, boolean hasTransformer, SessionImplementor session)\n\t\t\tthrows SQLException, HibernateException {\n\t\tfinal Object[] resultRow = buildResultRow( data, resultSet, session );\n\t\tif ( hasTransformer ) {\n\t\t\treturn resultRow;\n\t\t}\n\t\telse {\n\t\t\treturn resultRow.length == 1\n\t\t\t\t\t? resultRow[0]\n\t\t\t\t\t: resultRow;\n\t\t}\n\t}\n","new_comment_raw":"@param resultSet The JDBC result set (positioned at the row currently being processed).","old_comment_raw":"@param resultSet The JDBC result set (positioned at the row currently being processed).","label":0,"pre_label":1,"AST_level":9,"line_counts":13,"new_code_token_num":62},{"new_code_raw":"private long[][][] createGrid(int[][][] typeArray) throws Exception { long[][][] ids = new long[typeArray.length][][]; for (int i = 0; i < typeArray.length; i++) { \/\/ Add screen to DB long screenId = LauncherAppState.getLauncherProvider().generateNewScreenId(); ContentValues v = new ContentValues(); v.put(LauncherSettings.WorkspaceScreens._ID, screenId); v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i); getMockContentResolver().insert(LauncherSettings.WorkspaceScreens.CONTENT_URI, v); ids[i] = new long[typeArray[i].length][]; for (int y = 0; y < typeArray[i].length; y++) { ids[i][y] = new long[typeArray[i][y].length]; for (int x = 0; x < typeArray[i][y].length; x++) { if (typeArray[i][y][x] < 0) { \/\/ Empty cell ids[i][y][x] = -1; } else { ids[i][y][x] = addItem(typeArray[i][y][x], screenId, DESKTOP, x, y); } } } } return ids; }","old_code_raw":"    private long[][][] createGrid(int[][][] typeArray, long startScreen) throws Exception {\n        LauncherSettings.Settings.call(getMockContentResolver(),\n                LauncherSettings.Settings.METHOD_CREATE_EMPTY_DB);\n        long[][][] ids = new long[typeArray.length][][];\n\n        for (int i = 0; i < typeArray.length; i++) {\n            \/\/ Add screen to DB\n            long screenId = startScreen + i;\n\n            \/\/ Keep the screen id counter up to date\n            LauncherSettings.Settings.call(getMockContentResolver(),\n                    LauncherSettings.Settings.METHOD_NEW_SCREEN_ID);\n\n            ContentValues v = new ContentValues();\n            v.put(LauncherSettings.WorkspaceScreens._ID, screenId);\n            v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);\n            getMockContentResolver().insert(LauncherSettings.WorkspaceScreens.CONTENT_URI, v);\n\n            ids[i] = new long[typeArray[i].length][];\n            for (int y = 0; y < typeArray[i].length; y++) {\n                ids[i][y] = new long[typeArray[i][y].length];\n                for (int x = 0; x < typeArray[i][y].length; x++) {\n                    if (typeArray[i][y][x] < 0) {\n                        \/\/ Empty cell\n                        ids[i][y][x] = -1;\n                    } else {\n                        ids[i][y][x] = addItem(typeArray[i][y][x], screenId, DESKTOP, x, y);\n                    }\n                }\n            }\n        }\n        return ids;\n    }\n","new_comment_raw":"@param typeArray A 3d array of item types. @see #addItem(int, long, long, int, int) for type definitions. The first dimension represents the screens and the next two represent the workspace grid.","old_comment_raw":"@param typeArray A 3d array of item types. @see #addItem(int, long, long, int, int) for type definitions. The first dimension represents the screens and the next two represent the workspace grid.","label":0,"pre_label":1,"AST_level":16,"line_counts":27,"new_code_token_num":261},{"new_code_raw":"public Client testClientModel(Client client) throws ApiException { Object localVarPostBody = client; \/\/ verify the required parameter 'client' is set if (client == null) { throw new ApiException(400, \"Missing the required parameter 'client' when calling testClientModel\"); } \/\/ create path and map variables String localVarPath = \"\/fake\"; \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { \"application\/json\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { \"application\/json\" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Client> localVarReturnType = new GenericType<Client>() {}; return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public Client testClientModel(Client body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    \/\/ verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling testClientModel\");\n    }\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/fake\";\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application\/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application\/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@param client client model (required)","old_comment_raw":"@param body client model (required)","label":1,"pre_label":0,"AST_level":8,"line_counts":36,"new_code_token_num":210},{"new_code_raw":"public static boolean isValidTimeFloor(RexNode rexNode) { if (rexNode.getKind() != SqlKind.FLOOR) { return false; } final RexCall call = (RexCall) rexNode; if (call.operands.size() != 2) { return false; } final RexLiteral flag = (RexLiteral) call.operands.get(1); final TimeUnitRange timeUnit = (TimeUnitRange) flag.getValue(); return timeUnit != null && VALID_TIME_EXTRACT.contains(timeUnit); }","old_code_raw":"  public static boolean isValidTimeFloor(RexCall call) {\n    if (call.getKind() != SqlKind.FLOOR) {\n      return false;\n    }\n    final RexLiteral flag = (RexLiteral) call.operands.get(1);\n    final TimeUnitRange timeUnit = (TimeUnitRange) flag.getValue();\n    return timeUnit != null && VALID_TIME_EXTRACT.contains(timeUnit);\n  }\n","new_comment_raw":"@param rexNode Extract expression","old_comment_raw":"@param call Extract expression","label":1,"pre_label":0,"AST_level":7,"line_counts":13,"new_code_token_num":84},{"new_code_raw":"private ColumnState buildUnionList(ContainerState parent, ColumnMetadata columnSchema) { \/\/ The variant must start out empty. assert columnSchema.variantSchema().size() == 0; \/\/ Create the union writer, bound to an empty list shim. final UnionWriterImpl unionWriter = new UnionWriterImpl(columnSchema); unionWriter.bindShim(new EmptyListShim()); final VariantObjectWriter unionObjWriter = new VariantObjectWriter(unionWriter); \/\/ Create the list vector. Starts with the default (dummy) data \/\/ vector which corresponds to the empty union shim above. \/\/ Don't get the list vector from the vector cache. List vectors may \/\/ have content that varies from batch to batch. Only the leaf \/\/ vectors can be cached. final ListVector listVector = new ListVector(columnSchema.schema(), parent.loader().allocator(), null); \/\/ Create the list vector state that tracks the list vector lifecycle. final ListVectorState vectorState = new ListVectorState(unionWriter, listVector); \/\/ Create the list writer: an array of unions. final AbstractObjectWriter listWriter = new ArrayObjectWriter( new ListWriterImpl(columnSchema, listVector, unionObjWriter)); \/\/ Create the manager for the columns within the list (which may or \/\/ may not be grouped into a union.) final ListState listState = new ListState(parent.loader(), parent.vectorCache().childCache(columnSchema.name())); \/\/ Bind the union state to the union writer to handle column additions. unionWriter.bindListener(listState); \/\/ Assemble it all into a union column state. return new UnionColumnState(parent.loader(), listWriter, vectorState, listState); }","old_code_raw":"  private ColumnState buildUnionList(ContainerState parent, ColumnReadProjection colProj) {\n    ColumnMetadata columnSchema = colProj.providedSchema();\n\n    \/\/ The variant must start out empty.\n\n    assert columnSchema.variantSchema().size() == 0;\n\n    \/\/ Create the union writer, bound to an empty list shim.\n\n    final UnionWriterImpl unionWriter = new UnionWriterImpl(columnSchema);\n    unionWriter.bindShim(new EmptyListShim());\n    final VariantObjectWriter unionObjWriter = new VariantObjectWriter(unionWriter);\n\n    \/\/ Create the list vector. Starts with the default (dummy) data\n    \/\/ vector which corresponds to the empty union shim above.\n    \/\/ Don't get the list vector from the vector cache. List vectors may\n    \/\/ have content that varies from batch to batch. Only the leaf\n    \/\/ vectors can be cached.\n\n    final ListVector listVector = new ListVector(columnSchema.schema(),\n        parent.loader().allocator(), null);\n\n    \/\/ Create the list vector state that tracks the list vector lifecycle.\n\n    final ListVectorState vectorState = new ListVectorState(unionWriter, listVector);\n\n    \/\/ Create the list writer: an array of unions.\n\n    final AbstractObjectWriter listWriter = new ArrayObjectWriter(\n        new ListWriterImpl(columnSchema, listVector, unionObjWriter));\n\n    \/\/ Create the manager for the columns within the list (which may or\n    \/\/ may not be grouped into a union.)\n\n    final ListState listState = new ListState(parent.loader(),\n        parent.vectorCache().childCache(columnSchema.name()));\n\n    \/\/ Bind the union state to the union writer to handle column additions.\n\n    unionWriter.bindListener(listState);\n\n    \/\/ Assemble it all into a union column state.\n\n    return new UnionColumnState(parent.loader(),\n        listWriter, vectorState, listState);\n  }\n","new_comment_raw":"@param parent the parent (tuple, union or list) that holds this list","old_comment_raw":"@param parent the parent (tuple, union or list) that holds this list","label":0,"pre_label":1,"AST_level":8,"line_counts":38,"new_code_token_num":299},{"new_code_raw":"public QuoteAnnotator(Properties props, boolean verbose) { USE_SINGLE = Boolean.parseBoolean(props.getProperty(\"singleQuotes\", \"false\")); MAX_LENGTH = Integer.parseInt(props.getProperty(\"maxLength\", \"-1\")); ASCII_QUOTES = Boolean.parseBoolean(props.getProperty(\"asciiQuotes\", \"false\")); ALLOW_EMBEDDED_SAME = Boolean.parseBoolean(props.getProperty(\"allowEmbeddedSame\", \"false\")); SMART_QUOTES = Boolean.parseBoolean(props.getProperty(\"smartQuotes\", \"false\")); EXTRACT_UNCLOSED = Boolean.parseBoolean(props.getProperty(\"extractUnclosedQuotes\", \"false\")); VERBOSE = verbose; Timing timer = null; if (VERBOSE) { timer = new Timing(); log.info(\"Preparing quote annotator...\"); } if (VERBOSE) { timer.stop(\"done.\"); } }","old_code_raw":"  public QuoteAnnotator(String name, Properties props, boolean verbose) {\n    USE_SINGLE = Boolean.parseBoolean(props.getProperty(name + \".\" + \"singleQuotes\", \"false\"));\n    MAX_LENGTH = Integer.parseInt(props.getProperty(name + \".\" + \"maxLength\", \"-1\"));\n    ASCII_QUOTES = Boolean.parseBoolean(props.getProperty(name + \".\" + \"asciiQuotes\", \"false\"));\n    ALLOW_EMBEDDED_SAME = Boolean.parseBoolean(props.getProperty(name + \".\" + \"allowEmbeddedSame\", \"false\"));\n    SMART_QUOTES = Boolean.parseBoolean(props.getProperty(name + \".\" + \"smartQuotes\", \"false\"));\n    EXTRACT_UNCLOSED = Boolean.parseBoolean(props.getProperty(name + \".\" + \"extractUnclosedQuotes\", \"false\"));\n    ATTRIBUTE_QUOTES = Boolean.parseBoolean(props.getProperty(name + \".\" + \"attributeQuotes\", \"true\"));\n\n    VERBOSE = verbose;\n    Timing timer = null;\n    if (VERBOSE) {\n      timer = new Timing();\n      log.info(\"Preparing quote annotator...\");\n    }\n    if (ATTRIBUTE_QUOTES)\n      quoteAttributionAnnotator = new QuoteAttributionAnnotator(props);\n\n    if (VERBOSE) {\n      timer.stop(\"done.\");\n    }\n  }\n","new_comment_raw":"@param verbose whether or not to output verbose information.","old_comment_raw":"@param verbose whether or not to output verbose information.","label":0,"pre_label":1,"AST_level":8,"line_counts":20,"new_code_token_num":157},{"new_code_raw":"public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws ApiException { Object localVarPostBody = new Object(); \/\/ verify the required parameter 'petId' is set if (petId == null) { throw new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\"); } \/\/ verify the required parameter 'requiredFile' is set if (requiredFile == null) { throw new ApiException(400, \"Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile\"); } \/\/ create path and map variables String localVarPath = \"\/fake\/{petId}\/uploadImageWithRequiredFile\".replaceAll(\"\\\\{format\\\\}\",\"json\") .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString())); \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); if (additionalMetadata != null) localVarFormParams.put(\"additionalMetadata\", additionalMetadata); if (requiredFile != null) localVarFormParams.put(\"requiredFile\", requiredFile); final String[] localVarAccepts = { \"application\/json\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { \"multipart\/form-data\" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { \"petstore_auth\" }; GenericType<ModelApiResponse> localVarReturnType = new GenericType<ModelApiResponse>() {}; return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public ModelApiResponse uploadFileWithRequiredFile(Long petId, File file, String additionalMetadata) throws ApiException {\n    Object localVarPostBody = new Object();\n    \n    \/\/ verify the required parameter 'petId' is set\n    if (petId == null) {\n      throw new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\");\n    }\n    \n    \/\/ verify the required parameter 'file' is set\n    if (file == null) {\n      throw new ApiException(400, \"Missing the required parameter 'file' when calling uploadFileWithRequiredFile\");\n    }\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/fake\/{petId}\/uploadImageWithRequiredFile\".replaceAll(\"\\\\{format\\\\}\",\"json\")\n      .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString()));\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    if (additionalMetadata != null)\n      localVarFormParams.put(\"additionalMetadata\", additionalMetadata);\nif (file != null)\n      localVarFormParams.put(\"file\", file);\n\n    final String[] localVarAccepts = {\n      \"application\/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"multipart\/form-data\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] { \"petstore_auth\" };\n\n    GenericType<ModelApiResponse> localVarReturnType = new GenericType<ModelApiResponse>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@param requiredFile file to upload (required)","old_comment_raw":"@param file file to upload (required)","label":1,"pre_label":0,"AST_level":9,"line_counts":45,"new_code_token_num":332},{"new_code_raw":"public Task<Boolean> contains(final List<CacheKey> keys) { if (keys.isEmpty()) { return Task.forResult(false); } for (CacheKey key : keys) { EncodedImage pinnedImage = mStagingArea.get(key); if (pinnedImage != null) { pinnedImage.close(); FLog.v(TAG, \"Found image for %s in staging area\", key.toString()); mImageCacheStatsTracker.onStagingAreaHit(); return Task.forResult(true); } } Task<Boolean> masterTask = containsAsync(keys.get(0)); if (keys.size() == 1) { return masterTask; } for (final CacheKey key : keys.subList(1, keys.size())) { masterTask = masterTask.continueWithTask( new Continuation<Boolean, Task<Boolean>>() { @Override public Task<Boolean> then(Task<Boolean> previousTask) throws Exception { if (previousTask.isCancelled() || previousTask.getResult()) { return previousTask; } return containsAsync(key); } }, mReadExecutor); } return masterTask; }","old_code_raw":"  public Task<Boolean> contains(final CacheKey key) {\n    Preconditions.checkNotNull(key);\n\n    final EncodedImage pinnedImage = mStagingArea.get(key);\n    if (pinnedImage != null) {\n      pinnedImage.close();\n      FLog.v(TAG, \"Found image for %s in staging area\", key.toString());\n      mImageCacheStatsTracker.onStagingAreaHit();\n      return Task.forResult(true);\n    }\n\n    try {\n      return Task.call(\n          new Callable<Boolean>() {\n            @Override\n            public Boolean call() throws Exception {\n              EncodedImage result = mStagingArea.get(key);\n              if (result != null) {\n                result.close();\n                FLog.v(TAG, \"Found image for %s in staging area\", key.toString());\n                mImageCacheStatsTracker.onStagingAreaHit();\n                return true;\n              } else {\n                FLog.v(TAG, \"Did not find image for %s in staging area\", key.toString());\n                mImageCacheStatsTracker.onStagingAreaMiss();\n                try {\n                  return mFileCache.hasKey(key);\n                } catch (Exception exception) {\n                  return false;\n                }\n              }\n            }\n          },\n          mReadExecutor);\n    } catch (Exception exception) {\n      \/\/ Log failure\n      \/\/ TODO: 3697790\n      FLog.w(\n          TAG,\n          exception,\n          \"Failed to schedule disk-cache read for %s\",\n          key.toString());\n      return Task.forError(exception);\n    }\n  }\n","new_comment_raw":"@param keys","old_comment_raw":"@param key","label":1,"pre_label":0,"AST_level":13,"line_counts":33,"new_code_token_num":196},{"new_code_raw":"public List<String> dependencyPathBetween(int start, int end) { \/\/ Get paths from a node to the root of the sentence LinkedList<Integer> rootToStart = new LinkedList<>(); LinkedList<Integer> rootToEnd = new LinkedList<>(); int startAncestor = start; while (sentence.governor(startAncestor).isPresent() && sentence.governor(startAncestor).get() >= 0) { rootToStart.addFirst(startAncestor); startAncestor = sentence.governor(startAncestor).get(); } if (startAncestor == -1) { rootToStart.addFirst(-1); } int endAncestor = start; while (sentence.governor(endAncestor).isPresent() && sentence.governor(endAncestor).get() >= 0) { rootToEnd.addFirst(endAncestor); endAncestor = sentence.governor(endAncestor).get(); } if (endAncestor == -1) { rootToEnd.addFirst(-1); } \/\/ Get least common node return null; \/\/ TODO(gabor) write me! }","old_code_raw":"  public List<String> dependencyPathBetween(int start, int end, Function<Sentence, List<String>> selector) {\n    \/\/ Get paths from a node to the root of the sentence\n    LinkedList<Integer> rootToStart = new LinkedList<>();\n    LinkedList<Integer> rootToEnd = new LinkedList<>();\n    int startAncestor = start;\n    List<Optional<Integer>> governors = sentence.governors();\n    Set<Integer> seenVertices = new HashSet<>();\n    while (startAncestor >= 0 && governors.get(startAncestor).isPresent()) {\n      if (seenVertices.contains(startAncestor)) {\n        return Collections.EMPTY_LIST;\n      }\n      seenVertices.add(startAncestor);\n      rootToStart.addFirst(startAncestor);\n      startAncestor = governors.get(startAncestor).get();\n    }\n    if (startAncestor == -1) {\n      rootToStart.addFirst(-1);\n    }\n    int endAncestor = end;\n    seenVertices.clear();\n    while (endAncestor >= 0 && governors.get(endAncestor).isPresent()) {\n      if (seenVertices.contains(endAncestor)) {\n        return Collections.EMPTY_LIST;\n      }\n      seenVertices.add(endAncestor);\n      rootToEnd.addFirst(endAncestor);\n      endAncestor = governors.get(endAncestor).get();\n    }\n    if (endAncestor == -1) {\n      rootToEnd.addFirst(-1);\n    }\n\n    \/\/ Get least common node\n    int leastCommonNodeIndex = (rootToStart.size() == 0 || rootToEnd.size() == 0 || !rootToStart.get(0).equals(rootToEnd.get(0))) ? -1 : 0;\n    for (int i = 1; i < Math.min(rootToStart.size(), rootToEnd.size()); ++i) {\n      if (rootToStart.get(i).equals(rootToEnd.get(i))) {\n        leastCommonNodeIndex = i;\n      }\n    }\n\n    \/\/ Construct the path\n    if (leastCommonNodeIndex < 0) {\n      return Collections.EMPTY_LIST;\n    }\n    List<String> path = new ArrayList<>();\n    for (int i = rootToStart.size() - 1; i > leastCommonNodeIndex; --i) {\n      path.add(selector.apply(sentence).get(rootToStart.get(i)));\n      path.add(\"<-\" + sentence.incomingDependencyLabel(rootToStart.get(i)).orElse(\"dep\") + \"-\");\n    }\n    path.add(selector.apply(sentence).get(rootToStart.get(leastCommonNodeIndex)));\n    for (int i = leastCommonNodeIndex + 1; i < rootToEnd.size(); ++i) {\n      path.add(\"-\" + sentence.incomingDependencyLabel(rootToEnd.get(i)).orElse(\"dep\") + \"->\");\n      path.add(selector.apply(sentence).get(rootToEnd.get(i)));\n    }\n    return path;\n  }\n","new_comment_raw":"@param selector The property of the sentence we are getting the mode of. For example, Sentence::posTags","old_comment_raw":"@param selector The property of the sentence we are getting the mode of. For example, Sentence::posTags","label":0,"pre_label":1,"AST_level":8,"line_counts":27,"new_code_token_num":178},{"new_code_raw":"private static ResultPoint[] findVertices180(BitMatrix matrix, boolean tryHarder) { int height = matrix.getHeight(); int width = matrix.getWidth(); int halfWidth = width >> 1; ResultPoint[] result = new ResultPoint[8]; boolean found = false; int[] counters = new int[START_PATTERN_REVERSE.length]; int rowStep = Math.max(1, height >> (tryHarder ? 9 : 7)); \/\/ Top Left for (int i = height - 1; i > 0; i -= rowStep) { int[] loc = findGuardPattern(matrix, halfWidth, i, halfWidth, true, START_PATTERN_REVERSE, counters); if (loc != null) { result[0] = new ResultPoint(loc[1], i); result[4] = new ResultPoint(loc[0], i); found = true; break; } } \/\/ Bottom Left if (found) { \/\/ Found the Top Left vertex found = false; for (int i = 0; i < height; i += rowStep) { int[] loc = findGuardPattern(matrix, halfWidth, i, halfWidth, true, START_PATTERN_REVERSE, counters); if (loc != null) { result[1] = new ResultPoint(loc[1], i); result[5] = new ResultPoint(loc[0], i); found = true; break; } } } counters = new int[STOP_PATTERN_REVERSE.length]; \/\/ Top Right if (found) { \/\/ Found the Bottom Left vertex found = false; for (int i = height - 1; i > 0; i -= rowStep) { int[] loc = findGuardPattern(matrix, 0, i, halfWidth, false, STOP_PATTERN_REVERSE, counters); if (loc != null) { result[2] = new ResultPoint(loc[0], i); result[6] = new ResultPoint(loc[1], i); found = true; break; } } } \/\/ Bottom Right if (found) { \/\/ Found the Top Right vertex found = false; for (int i = 0; i < height; i += rowStep) { int[] loc = findGuardPattern(matrix, 0, i, halfWidth, false, STOP_PATTERN_REVERSE, counters); if (loc != null) { result[3] = new ResultPoint(loc[0], i); result[7] = new ResultPoint(loc[1], i); found = true; break; } } } return found ? result : null; }","old_code_raw":"  private static ResultPoint[] findVertices180(BitMatrix matrix) {\n    int height = matrix.getHeight();\n    int width = matrix.getWidth();\n    int halfWidth = width >> 1;\n\n    ResultPoint[] result = new ResultPoint[8];\n    boolean found = false;\n\n    \/\/ Top Left\n    for (int i = height - 1; i > 0; i--) {\n      int[] loc = findGuardPattern(matrix, halfWidth, i, halfWidth, true, START_PATTERN_REVERSE);\n      if (loc != null) {\n        result[0] = new ResultPoint(loc[1], i);\n        result[4] = new ResultPoint(loc[0], i);\n        found = true;\n        break;\n      }\n    }\n    \/\/ Bottom Left\n    if (found) { \/\/ Found the Top Left vertex\n      found = false;\n      for (int i = 0; i < height; i++) {\n        int[] loc = findGuardPattern(matrix, halfWidth, i, halfWidth, true, START_PATTERN_REVERSE);\n        if (loc != null) {\n          result[1] = new ResultPoint(loc[1], i);\n          result[5] = new ResultPoint(loc[0], i);\n          found = true;\n          break;\n        }\n      }\n    }\n    \/\/ Top Right\n    if (found) { \/\/ Found the Bottom Left vertex\n      found = false;\n      for (int i = height - 1; i > 0; i--) {\n        int[] loc = findGuardPattern(matrix, 0, i, halfWidth, false, STOP_PATTERN_REVERSE);\n        if (loc != null) {\n          result[2] = new ResultPoint(loc[0], i);\n          result[6] = new ResultPoint(loc[1], i);\n          found = true;\n          break;\n        }\n      }\n    }\n    \/\/ Bottom Right\n    if (found) { \/\/ Found the Top Right vertex\n      found = false;\n      for (int i = 0; i < height; i++) {\n        int[] loc = findGuardPattern(matrix, 0, i, halfWidth, false, STOP_PATTERN_REVERSE);\n        if (loc != null) {\n          result[3] = new ResultPoint(loc[0], i);\n          result[7] = new ResultPoint(loc[1], i);\n          found = true;\n          break;\n        }\n      }\n    }\n    return found ? result : null;\n  }\n","new_comment_raw":"@param matrix the scanned barcode image.","old_comment_raw":"@param matrix the scanned barcode image.","label":0,"pre_label":1,"AST_level":14,"line_counts":67,"new_code_token_num":475},{"new_code_raw":"public static AnnotationMirror getAnnotationMirror(Element element, String fqcn) { assert element != null; assert fqcn != null; AnnotationMirror mirror = null; for ( AnnotationMirror am : element.getAnnotationMirrors() ) { if ( isAnnotationMirrorOfType( am, fqcn ) ) { mirror = am; break; } } return mirror; }","old_code_raw":"\tpublic static AnnotationMirror getAnnotationMirror(Element element, Class<? extends Annotation> clazz) {\n\t\tassert clazz != null;\n\t\treturn getAnnotationMirror( element, clazz.getName() );\n\t}\n","new_comment_raw":"@param fqcn the fully qualified class name of the annotation to check for","old_comment_raw":"@param clazz the annotation class to check for","label":1,"pre_label":0,"AST_level":9,"line_counts":14,"new_code_token_num":58},{"new_code_raw":"private boolean isCached(Serializable collectionKey, CollectionPersister persister) { if ( persister.hasCache() ) { CacheKey cacheKey = context.getSession().generateCacheKey( collectionKey, persister.getKeyType(), persister.getRole() ); return persister.getCacheAccessStrategy().get( cacheKey, context.getSession().getTimestamp() ) != null; } return false; }","old_code_raw":"\tprivate boolean isCached(EntityKey entityKey, EntityPersister persister) {\n\t\tif ( persister.hasCache() ) {\n\t\t\tCacheKey key = context.getSession().generateCacheKey(\n\t\t\t\t\tentityKey.getIdentifier(),\n\t\t\t\t\tpersister.getIdentifierType(),\n\t\t\t\t\tentityKey.getEntityName()\n\t\t\t);\n\t\t\treturn persister.getCacheAccessStrategy().get( key, context.getSession().getTimestamp() ) != null;\n\t\t}\n\t\treturn false;\n\t}\n","new_comment_raw":"@param id A key that must be included in the batch fetch","old_comment_raw":"@param id The identifier of the entity currently demanding load.","label":1,"pre_label":0,"AST_level":10,"line_counts":12,"new_code_token_num":65},{"new_code_raw":"public String toDefaultValueWithParam(String name, Schema schema) { return \" = data.\" + name + \";\"; }","old_code_raw":"    public String toDefaultValueWithParam(String name, Property p) {\n        return \" = data.\" + name + \";\";\n    }\n","new_comment_raw":"@param schema Property schema","old_comment_raw":"@param p Swagger property object","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":23},{"new_code_raw":"protected boolean isDisconnectRequest(AtmosphereRequest request) { if (\"GET\".equals(request.getMethod())) { if (request.getParameterMap().containsKey(\"disconnect\")) { return true; } } else if (\"POST\".equals(request.getMethod())) { try { String data = decodePostData(request.getContentType(), extractString(request.getReader())); request.setAttribute(POST_MESSAGE_RECEIVED, data); if (data != null && data.length() > 0) { List<SocketIOPacketImpl> list = SocketIOPacketImpl.parse(data); if (!list.isEmpty()) { if (SocketIOPacketImpl.PacketType.DISCONNECT.equals(list.get(0).getFrameType())) { return true; } } } } catch (IOException e) { e.printStackTrace(); } } return false; }","old_code_raw":"    protected boolean isDisconnectRequest(HttpServletRequest request) {\n\n        if (\"GET\".equals(request.getMethod())) {\n\n            if (request.getParameterMap().containsKey(\"disconnect\")) {\n                return true;\n            }\n\n        } else if (\"POST\".equals(request.getMethod())) {\n            try {\n                String data = decodePostData(request.getContentType(), extractString(request.getReader()));\n                request.setAttribute(POST_MESSAGE_RECEIVED, data);\n                if (data != null && data.length() > 0) {\n                    List<SocketIOPacketImpl> list = SocketIOPacketImpl.parse(data);\n                    if (!list.isEmpty()) {\n                        if (SocketIOPacketImpl.PacketType.DISCONNECT.equals(list.get(0).getFrameType())) {\n                            return true;\n                        }\n                    }\n\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n\n        }\n\n        return false;\n    }\n","new_comment_raw":"@param request","old_comment_raw":"@param request","label":0,"pre_label":1,"AST_level":14,"line_counts":30,"new_code_token_num":158},{"new_code_raw":"public Client testSpecialTags(Client client) throws ApiException { ApiResponse<Client> resp = testSpecialTagsWithHttpInfo(client); return resp.getData(); }","old_code_raw":"    public Client testSpecialTags(Client body) throws ApiException {\n        ApiResponse<Client> resp = testSpecialTagsWithHttpInfo(body);\n        return resp.getData();\n    }\n","new_comment_raw":"@param client client model (required)","old_comment_raw":"@param body client model (required)","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":25},{"new_code_raw":"public TableSchema create(String schemaPrefix, String envelopSchemaName, Table table, ColumnNameFilter filter, ColumnMappers mappers, CustomKeyMapper keysMapper) { if (schemaPrefix == null) { schemaPrefix = \"\"; } \/\/ Build the schemas ... final TableId tableId = table.id(); final String tableIdStr = tableSchemaName(tableId); final String schemaNamePrefix = schemaPrefix + tableIdStr; LOGGER.debug(\"Mapping table '{}' to schemas under '{}'\", tableId, schemaNamePrefix); SchemaBuilder valSchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Value\")); SchemaBuilder keySchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Key\")); AtomicBoolean hasPrimaryKey = new AtomicBoolean(false); Key tableKey = new Key.Builder(table).customKeyMapper(keysMapper).build(); tableKey.keyColumns().forEach(column -> { addField(keySchemaBuilder, column, null); hasPrimaryKey.set(true); }); table.columns() .stream() .filter(column -> filter == null || filter.matches(tableId.catalog(), tableId.schema(), tableId.table(), column.name())) .forEach(column -> { ColumnMapper mapper = mappers == null ? null : mappers.mapperFor(tableId, column); addField(valSchemaBuilder, column, mapper); }); Schema valSchema = valSchemaBuilder.optional().build(); Schema keySchema = hasPrimaryKey.get() ? keySchemaBuilder.build() : null; if (LOGGER.isDebugEnabled()) { LOGGER.debug(\"Mapped primary key for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(keySchema)); LOGGER.debug(\"Mapped columns for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(valSchema)); } Envelope envelope = Envelope.defineSchema() .withName(schemaNameAdjuster.adjust(envelopSchemaName)) .withRecord(valSchema) .withSource(sourceInfoSchema) .build(); \/\/ Create the generators ... Function<Object[], Object> keyGenerator = createKeyGenerator(keySchema, tableId, tableKey.keyColumns()); Function<Object[], Struct> valueGenerator = createValueGenerator(valSchema, tableId, table.columns(), filter, mappers); \/\/ And the table schema ... return new TableSchema(tableId, keySchema, keyGenerator, envelope, valSchema, valueGenerator); }","old_code_raw":"    public TableSchema create(String schemaPrefix, String envelopSchemaName, Table table, ColumnNameFilter filter, ColumnMappers mappers) {\n        if (schemaPrefix == null) {\n            schemaPrefix = \"\";\n        }\n\n        \/\/ Build the schemas ...\n        final TableId tableId = table.id();\n        final String tableIdStr = tableSchemaName(tableId);\n        final String schemaNamePrefix = schemaPrefix + tableIdStr;\n        LOGGER.debug(\"Mapping table '{}' to schemas under '{}'\", tableId, schemaNamePrefix);\n        SchemaBuilder valSchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Value\"));\n        SchemaBuilder keySchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Key\"));\n        AtomicBoolean hasPrimaryKey = new AtomicBoolean(false);\n        table.columns().forEach(column -> {\n            if (table.isPrimaryKeyColumn(column.name())) {\n                \/\/ The column is part of the primary key, so ALWAYS add it to the PK schema ...\n                addField(keySchemaBuilder, column, null);\n                hasPrimaryKey.set(true);\n            }\n            if (filter == null || filter.matches(tableId.catalog(), tableId.schema(), tableId.table(), column.name())) {\n                \/\/ Add the column to the value schema only if the column has not been filtered ...\n                ColumnMapper mapper = mappers == null ? null : mappers.mapperFor(tableId, column);\n                addField(valSchemaBuilder, column, mapper);\n            }\n        });\n        Schema valSchema = valSchemaBuilder.optional().build();\n        Schema keySchema = hasPrimaryKey.get() ? keySchemaBuilder.build() : null;\n\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"Mapped primary key for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(keySchema));\n            LOGGER.debug(\"Mapped columns for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(valSchema));\n        }\n\n        Envelope envelope = Envelope.defineSchema()\n                .withName(schemaNameAdjuster.adjust(envelopSchemaName))\n                .withRecord(valSchema)\n                .withSource(sourceInfoSchema)\n                .build();\n\n\n        \/\/ Create the generators ...\n        Function<Object[], Object> keyGenerator = createKeyGenerator(keySchema, tableId, table.primaryKeyColumns());\n        Function<Object[], Struct> valueGenerator = createValueGenerator(valSchema, tableId, table.columns(), filter, mappers);\n\n        \/\/ And the table schema ...\n        return new TableSchema(tableId, keySchema, keyGenerator, envelope, valSchema, valueGenerator);\n    }\n","new_comment_raw":"@param schemaPrefix the prefix added to the table identifier to construct the schema names; may be null if there is no prefix","old_comment_raw":"@param schemaPrefix the prefix added to the table identifier to construct the schema names; may be null if there is no prefix","label":0,"pre_label":1,"AST_level":11,"line_counts":51,"new_code_token_num":433},{"new_code_raw":"public int[] indices(Collection<E> elements) { int[] indices = new int[elements.size()]; int i = 0; for (E elem : elements) { indices[i++] = indexOf(elem); } return indices; }","old_code_raw":"  public int[] indices(Collection<E> elems) {\n    int[] indices = new int[elems.size()];\n    int i = 0;\n    for (E elem : elems) {\n      indices[i++] = indexOf(elem);\n    }\n    return indices;\n  }\n","new_comment_raw":"@param elements The list of items","old_comment_raw":"@param elems The list of items","label":1,"pre_label":0,"AST_level":9,"line_counts":9,"new_code_token_num":52},{"new_code_raw":"public void updatePetWithForm (String petId, String name, String status) throws TimeoutException, ExecutionException, InterruptedException, ApiException { Object postBody = null; \/\/ verify the required parameter 'petId' is set if (petId == null) { VolleyError error = new VolleyError(\"Missing the required parameter 'petId' when calling updatePetWithForm\", new ApiException(400, \"Missing the required parameter 'petId' when calling updatePetWithForm\")); } \/\/ create path and map variables String path = \"\/pet\/{petId}\".replaceAll(\"\\\\{format\\\\}\",\"json\").replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiInvoker.escapeString(petId.toString())); \/\/ query params List<Pair> queryParams = new ArrayList<Pair>(); \/\/ header params Map<String, String> headerParams = new HashMap<String, String>(); \/\/ form params Map<String, String> formParams = new HashMap<String, String>(); String[] contentTypes = { \"application\/x-www-form-urlencoded\" }; String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\"; if (contentType.startsWith(\"multipart\/form-data\")) { \/\/ file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); if (name != null) { localVarBuilder.addTextBody(\"name\", ApiInvoker.parameterToString(name), ApiInvoker.TEXT_PLAIN_UTF8); } if (status != null) { localVarBuilder.addTextBody(\"status\", ApiInvoker.parameterToString(status), ApiInvoker.TEXT_PLAIN_UTF8); } HttpEntity httpEntity = localVarBuilder.build(); postBody = httpEntity; } else { \/\/ normal form params formParams.put(\"name\", ApiInvoker.parameterToString(name)); formParams.put(\"status\", ApiInvoker.parameterToString(status)); } String[] authNames = new String[] { \"petstore_auth\" }; try { String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames); if (localVarResponse != null) { return ; } else { return ; } } catch (ApiException ex) { throw ex; } catch (InterruptedException ex) { throw ex; } catch (ExecutionException ex) { if (ex.getCause() instanceof VolleyError) { VolleyError volleyError = (VolleyError)ex.getCause(); if (volleyError.networkResponse != null) { throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage()); } } throw ex; } catch (TimeoutException ex) { throw ex; } }","old_code_raw":"  public void updatePetWithForm (Long petId, String name, String status) throws TimeoutException, ExecutionException, InterruptedException, ApiException {\n    Object postBody = null;\n    \/\/ verify the required parameter 'petId' is set\n    if (petId == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'petId' when calling updatePetWithForm\",\n        new ApiException(400, \"Missing the required parameter 'petId' when calling updatePetWithForm\"));\n    }\n\n    \/\/ create path and map variables\n    String path = \"\/pet\/{petId}\".replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiInvoker.escapeString(petId.toString()));\n\n    \/\/ query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    \/\/ header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    \/\/ form params\n    Map<String, String> formParams = new HashMap<String, String>();\n    String[] contentTypes = {\n      \"application\/x-www-form-urlencoded\"\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\";\n\n    if (contentType.startsWith(\"multipart\/form-data\")) {\n      \/\/ file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      if (name != null) {\n        localVarBuilder.addTextBody(\"name\", ApiInvoker.parameterToString(name), ApiInvoker.TEXT_PLAIN_UTF8);\n      }\n      if (status != null) {\n        localVarBuilder.addTextBody(\"status\", ApiInvoker.parameterToString(status), ApiInvoker.TEXT_PLAIN_UTF8);\n      }\n      HttpEntity httpEntity = localVarBuilder.build();\n      postBody = httpEntity;\n    } else {\n      \/\/ normal form params\n      formParams.put(\"name\", ApiInvoker.parameterToString(name));\n      formParams.put(\"status\", ApiInvoker.parameterToString(status));\n    }\n\n    String[] authNames = new String[] { \"petstore_auth\" };\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames);\n      if (localVarResponse != null) {\n         return ;\n      } else {\n         return ;\n      }\n    } catch (ApiException ex) {\n       throw ex;\n    } catch (InterruptedException ex) {\n       throw ex;\n    } catch (ExecutionException ex) {\n      if (ex.getCause() instanceof VolleyError) {\n        VolleyError volleyError = (VolleyError)ex.getCause();\n        if (volleyError.networkResponse != null) {\n          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());\n        }\n      }\n      throw ex;\n    } catch (TimeoutException ex) {\n      throw ex;\n    }\n  }\n","new_comment_raw":"@param name Updated name of the pet","old_comment_raw":"@param name Updated name of the pet","label":0,"pre_label":1,"AST_level":11,"line_counts":65,"new_code_token_num":491},{"new_code_raw":"public Client call123testSpecialTags(Client body, Map<String, Object> params) throws IOException { HttpResponse response = call123testSpecialTagsForHttpResponse(body, params); TypeReference typeRef = new TypeReference<Client>() {}; return apiClient.getObjectMapper().readValue(response.getContent(), typeRef); }","old_code_raw":"    public Client call123testSpecialTags(Client client, Map<String, Object> params) throws IOException {\n        HttpResponse response = call123testSpecialTagsForHttpResponse(client, params);\n        TypeReference typeRef = new TypeReference<Client>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    }\n","new_comment_raw":"@param body client model","old_comment_raw":"@param client client model","label":1,"pre_label":0,"AST_level":8,"line_counts":6,"new_code_token_num":51},{"new_code_raw":"public static WebDavMount mount(URI uri) throws CommandFailedException { return chooseStrategy().mount(uri); }","old_code_raw":"\tpublic static WebDavMount mount(int localPort) throws CommandFailedException {\n\t\treturn chooseStrategy().mount(localPort);\n\t}\n","new_comment_raw":"@param uri URI of the webdav share","old_comment_raw":"@param localPort local TCP port of the webdav share","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":21},{"new_code_raw":"private static ResultPoint[] findVertices(BitMatrix matrix, boolean tryHarder) { int height = matrix.getHeight(); int width = matrix.getWidth(); ResultPoint[] result = new ResultPoint[8]; boolean found = false; int[] counters = new int[START_PATTERN.length]; int rowStep = Math.max(1, height >> (tryHarder ? 9 : 7)); \/\/ Top Left for (int i = 0; i < height; i += rowStep) { int[] loc = findGuardPattern(matrix, 0, i, width, false, START_PATTERN, counters); if (loc != null) { result[0] = new ResultPoint(loc[0], i); result[4] = new ResultPoint(loc[1], i); found = true; break; } } \/\/ Bottom left if (found) { \/\/ Found the Top Left vertex found = false; for (int i = height - 1; i > 0; i -= rowStep) { int[] loc = findGuardPattern(matrix, 0, i, width, false, START_PATTERN, counters); if (loc != null) { result[1] = new ResultPoint(loc[0], i); result[5] = new ResultPoint(loc[1], i); found = true; break; } } } counters = new int[STOP_PATTERN.length]; \/\/ Top right if (found) { \/\/ Found the Bottom Left vertex found = false; for (int i = 0; i < height; i += rowStep) { int[] loc = findGuardPattern(matrix, 0, i, width, false, STOP_PATTERN, counters); if (loc != null) { result[2] = new ResultPoint(loc[1], i); result[6] = new ResultPoint(loc[0], i); found = true; break; } } } \/\/ Bottom right if (found) { \/\/ Found the Top right vertex found = false; for (int i = height - 1; i > 0; i -= rowStep) { int[] loc = findGuardPattern(matrix, 0, i, width, false, STOP_PATTERN, counters); if (loc != null) { result[3] = new ResultPoint(loc[1], i); result[7] = new ResultPoint(loc[0], i); found = true; break; } } } return found ? result : null; }","old_code_raw":"  private static ResultPoint[] findVertices(BitMatrix matrix) {\n    int height = matrix.getHeight();\n    int width = matrix.getWidth();\n\n    ResultPoint[] result = new ResultPoint[8];\n    boolean found = false;\n\n    \/\/ Top Left\n    for (int i = 0; i < height; i++) {\n      int[] loc = findGuardPattern(matrix, 0, i, width, false, START_PATTERN);\n      if (loc != null) {\n        result[0] = new ResultPoint(loc[0], i);\n        result[4] = new ResultPoint(loc[1], i);\n        found = true;\n        break;\n      }\n    }\n    \/\/ Bottom left\n    if (found) { \/\/ Found the Top Left vertex\n      found = false;\n      for (int i = height - 1; i > 0; i--) {\n        int[] loc = findGuardPattern(matrix, 0, i, width, false, START_PATTERN);\n        if (loc != null) {\n          result[1] = new ResultPoint(loc[0], i);\n          result[5] = new ResultPoint(loc[1], i);\n          found = true;\n          break;\n        }\n      }\n    }\n    \/\/ Top right\n    if (found) { \/\/ Found the Bottom Left vertex\n      found = false;\n      for (int i = 0; i < height; i++) {\n        int[] loc = findGuardPattern(matrix, 0, i, width, false, STOP_PATTERN);\n        if (loc != null) {\n          result[2] = new ResultPoint(loc[1], i);\n          result[6] = new ResultPoint(loc[0], i);\n          found = true;\n          break;\n        }\n      }\n    }\n    \/\/ Bottom right\n    if (found) { \/\/ Found the Top right vertex\n      found = false;\n      for (int i = height - 1; i > 0; i--) {\n        int[] loc = findGuardPattern(matrix, 0, i, width, false, STOP_PATTERN);\n        if (loc != null) {\n          result[3] = new ResultPoint(loc[1], i);\n          result[7] = new ResultPoint(loc[0], i);\n          found = true;\n          break;\n        }\n      }\n    }\n    return found ? result : null;\n  }\n","new_comment_raw":"@param matrix the scanned barcode image.","old_comment_raw":"@param matrix the scanned barcode image.","label":0,"pre_label":1,"AST_level":14,"line_counts":66,"new_code_token_num":470},{"new_code_raw":"public Configuration setCacheConcurrencyStrategy(String entityName, String concurrencyStrategy) { setCacheConcurrencyStrategy( entityName, concurrencyStrategy, entityName ); return this; }","old_code_raw":"\tpublic Configuration setCacheConcurrencyStrategy(String clazz, String concurrencyStrategy)\n\t\t\tthrows MappingException {\n\t\tsetCacheConcurrencyStrategy( clazz, concurrencyStrategy, clazz );\n\t\treturn this;\n\t}\n","new_comment_raw":"@param entityName The name of the entity to which we shoudl associate these cache settings","old_comment_raw":"@param clazz","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":24},{"new_code_raw":"public void createUsersWithArrayInput (java.util.List<User> body) throws ApiException { Object postBody = body; \/\/ create path and map variables String path = \"\/user\/createWithArray\".replaceAll(\"\\\\{format\\\\}\",\"json\"); \/\/ query params java.util.List<Pair> queryParams = new java.util.ArrayList<Pair>(); java.util.Map<String, String> headerParams = new java.util.HashMap<String, String>(); java.util.Map<String, Object> formParams = new java.util.HashMap<String, Object>(); final String[] accepts = { \"application\/json\", \"application\/xml\" }; final String accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final String contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; apiClient.invokeAPI(path, \"POST\", queryParams, postBody, headerParams, formParams, accept, contentType, authNames, null); }","old_code_raw":"  public void createUsersWithArrayInput (List<User> body) throws ApiException {\n    Object postBody = body;\n    \n    \/\/ create path and map variables\n    String path = \"\/user\/createWithArray\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    \/\/ query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    Map<String, String> headerParams = new HashMap<String, String>();\n    Map<String, Object> formParams = new HashMap<String, Object>();\n\n    \n\n    \n\n    \n\n    final String[] accepts = {\n      \"application\/json\", \"application\/xml\"\n    };\n    final String accept = apiClient.selectHeaderAccept(accepts);\n\n    final String[] contentTypes = {\n      \n    };\n    final String contentType = apiClient.selectHeaderContentType(contentTypes);\n\n    String[] authNames = new String[] {  };\n\n    \n    apiClient.invokeAPI(path, \"POST\", queryParams, postBody, headerParams, formParams, accept, contentType, authNames, null);\n    \n  }\n","new_comment_raw":"@param body List of user object","old_comment_raw":"@param body List of user object","label":0,"pre_label":1,"AST_level":10,"line_counts":34,"new_code_token_num":183},{"new_code_raw":"public List<String> dependencyPathBetween(int start, int end, Optional<Function<Sentence, List<String>>> selector) { \/\/ Get paths from a node to the root of the sentence LinkedList<Integer> rootToStart = new LinkedList<>(); LinkedList<Integer> rootToEnd = new LinkedList<>(); int startAncestor = start; List<Optional<Integer>> governors = sentence.governors(); Set<Integer> seenVertices = new HashSet<>(); while (startAncestor >= 0 && governors.get(startAncestor).isPresent()) { if (seenVertices.contains(startAncestor)) { \/\/ Found loopiness -- revert to BFS return loopyDependencyPathBetween(start, end, selector); } seenVertices.add(startAncestor); rootToStart.addFirst(startAncestor); startAncestor = governors.get(startAncestor).get(); } if (startAncestor == -1) { rootToStart.addFirst(-1); } int endAncestor = end; seenVertices.clear(); while (endAncestor >= 0 && governors.get(endAncestor).isPresent()) { if (seenVertices.contains(endAncestor)) { \/\/ Found loopiness -- revert to BFS return loopyDependencyPathBetween(start, end, selector); } seenVertices.add(endAncestor); rootToEnd.addFirst(endAncestor); endAncestor = governors.get(endAncestor).get(); } if (endAncestor == -1) { rootToEnd.addFirst(-1); } \/\/ Get least common node int leastCommonNodeIndex = (rootToStart.size() == 0 || rootToEnd.size() == 0 || !rootToStart.get(0).equals(rootToEnd.get(0))) ? -1 : 0; for (int i = 1; i < Math.min(rootToStart.size(), rootToEnd.size()); ++i) { if (rootToStart.get(i).equals(rootToEnd.get(i))) { leastCommonNodeIndex = i; } } \/\/ Construct the path if (leastCommonNodeIndex < 0) { return Collections.emptyList(); } List<String> path = new ArrayList<>(); Optional<List<String>> words = selector.map(x -> x.apply(sentence)); for (int i = rootToStart.size() - 1; i > leastCommonNodeIndex; --i) { final int index = i; words.ifPresent(x -> path.add(x.get(rootToStart.get(index)))); path.add(\"<-\" + sentence.incomingDependencyLabel(rootToStart.get(i)).orElse(\"dep\") + \"-\"); } if (words.isPresent()) { path.add(words.get().get(rootToStart.get(leastCommonNodeIndex))); } for (int i = leastCommonNodeIndex + 1; i < rootToEnd.size(); ++i) { final int index = i; path.add(\"-\" + sentence.incomingDependencyLabel(rootToEnd.get(i)).orElse(\"dep\") + \"->\"); words.ifPresent(x -> path.add(x.get(rootToEnd.get(index)))); } return path; }","old_code_raw":"  public List<String> dependencyPathBetween(int start, int end, Function<Sentence, List<String>> selector) {\n    \/\/ Get paths from a node to the root of the sentence\n    LinkedList<Integer> rootToStart = new LinkedList<>();\n    LinkedList<Integer> rootToEnd = new LinkedList<>();\n    int startAncestor = start;\n    List<Optional<Integer>> governors = sentence.governors();\n    Set<Integer> seenVertices = new HashSet<>();\n    while (startAncestor >= 0 && governors.get(startAncestor).isPresent()) {\n      if (seenVertices.contains(startAncestor)) {\n        return Collections.EMPTY_LIST;\n      }\n      seenVertices.add(startAncestor);\n      rootToStart.addFirst(startAncestor);\n      startAncestor = governors.get(startAncestor).get();\n    }\n    if (startAncestor == -1) {\n      rootToStart.addFirst(-1);\n    }\n    int endAncestor = end;\n    seenVertices.clear();\n    while (endAncestor >= 0 && governors.get(endAncestor).isPresent()) {\n      if (seenVertices.contains(endAncestor)) {\n        return Collections.EMPTY_LIST;\n      }\n      seenVertices.add(endAncestor);\n      rootToEnd.addFirst(endAncestor);\n      endAncestor = governors.get(endAncestor).get();\n    }\n    if (endAncestor == -1) {\n      rootToEnd.addFirst(-1);\n    }\n\n    \/\/ Get least common node\n    int leastCommonNodeIndex = (rootToStart.size() == 0 || rootToEnd.size() == 0 || !rootToStart.get(0).equals(rootToEnd.get(0))) ? -1 : 0;\n    for (int i = 1; i < Math.min(rootToStart.size(), rootToEnd.size()); ++i) {\n      if (rootToStart.get(i).equals(rootToEnd.get(i))) {\n        leastCommonNodeIndex = i;\n      }\n    }\n\n    \/\/ Construct the path\n    if (leastCommonNodeIndex < 0) {\n      return Collections.EMPTY_LIST;\n    }\n    List<String> path = new ArrayList<>();\n    for (int i = rootToStart.size() - 1; i > leastCommonNodeIndex; --i) {\n      path.add(selector.apply(sentence).get(rootToStart.get(i)));\n      path.add(\"<-\" + sentence.incomingDependencyLabel(rootToStart.get(i)).orElse(\"dep\") + \"-\");\n    }\n    path.add(selector.apply(sentence).get(rootToStart.get(leastCommonNodeIndex)));\n    for (int i = leastCommonNodeIndex + 1; i < rootToEnd.size(); ++i) {\n      path.add(\"-\" + sentence.incomingDependencyLabel(rootToEnd.get(i)).orElse(\"dep\") + \"->\");\n      path.add(selector.apply(sentence).get(rootToEnd.get(i)));\n    }\n    return path;\n  }\n","new_comment_raw":"@param selector The selector for the strings between the path, if any. If left empty, these will be omitted from the list.","old_comment_raw":"@param The type of the element we are getting.","label":1,"pre_label":0,"AST_level":11,"line_counts":64,"new_code_token_num":555},{"new_code_raw":"public static Annotation fromProto(CoreNLPProtos.Document proto) { \/\/ Set text Annotation ann = new Annotation(proto.getText()); \/\/ Add tokens List<CoreLabel> tokens = new ArrayList<CoreLabel>(proto.getTokenCount()); for (CoreNLPProtos.Token token : proto.getTokenList()) { CoreLabel coreLabel = fromProto(token); \/\/ Set docid if (proto.hasDocID()) { coreLabel.setDocID(proto.getDocID()); } tokens.add(coreLabel); } if (!tokens.isEmpty()) { ann.set(TokensAnnotation.class, tokens); } \/\/ Add sentences List<CoreMap> sentences = new ArrayList<CoreMap>(proto.getSentenceCount()); for (int sentIndex = 0; sentIndex < proto.getSentenceCount(); ++sentIndex) { CoreNLPProtos.Sentence sentence = proto.getSentence(sentIndex); CoreMap map = fromProto(sentence); if (!tokens.isEmpty() && sentence.hasTokenOffsetBegin() && sentence.hasTokenOffsetEnd()) { \/\/ Set tokens for sentence map.set(TokensAnnotation.class, tokens.subList(sentence.getTokenOffsetBegin(), sentence.getTokenOffsetEnd())); \/\/ Set sentence index + token index + paragraph index for (int i = sentence.getTokenOffsetBegin(); i < sentence.getTokenOffsetEnd(); ++i) { tokens.get(i).setSentIndex(sentIndex); tokens.get(i).setIndex(i - sentence.getTokenOffsetBegin() + 1); if (sentence.hasParagraph()) { tokens.get(i).set(ParagraphAnnotation.class, sentence.getParagraph()); } } \/\/ Set text map.set(TextAnnotation.class, proto.getText().substring(sentence.getCharacterOffsetBegin(), sentence.getCharacterOffsetEnd())); } \/\/ End iteration sentences.add(map); } if (!sentences.isEmpty()) { ann.set(SentencesAnnotation.class, sentences); } \/\/ Set DocID String docid = null; if (proto.hasDocID()) { docid = proto.getDocID(); ann.set(DocIDAnnotation.class, docid); } \/\/ Set coref chain Map<Integer, CorefChain> corefChains = new HashMap<Integer, CorefChain>(); for (CoreNLPProtos.CorefChain chainProto : proto.getCorefChainList()) { CorefChain chain = fromProto(chainProto, ann); corefChains.put(chain.getChainID(), chain); } if (!corefChains.isEmpty()) { ann.set(CorefChainAnnotation.class, corefChains); } \/\/ Set dependency graphs \/\/ We need to wait until here, since this is the first time we see tokens for (int i = 0; i < proto.getSentenceCount(); ++i) { CoreNLPProtos.Sentence sentence = proto.getSentenceList().get(i); CoreMap map = sentences.get(i); List<CoreLabel> sentenceTokens = map.get(TokensAnnotation.class); if (sentence.hasBasicDependencies()) { map.set(BasicDependenciesAnnotation.class, fromProto(sentence.getBasicDependencies(), sentenceTokens, docid)); } if (sentence.hasCollapsedDependencies()) { map.set(CollapsedDependenciesAnnotation.class, fromProto(sentence.getCollapsedDependencies(), sentenceTokens, docid)); } if (sentence.hasCollapsedCCProcessedDependencies()) { map.set(CollapsedCCProcessedDependenciesAnnotation.class, fromProto(sentence.getCollapsedCCProcessedDependencies(), sentenceTokens, docid)); } } \/\/ Redo some light annotation for (CoreMap sentence : sentences) { if (sentence.containsKey(TokensAnnotation.class)) { sentence.set(NumerizedTokensAnnotation.class, NumberNormalizer.findAndMergeNumbers(sentence)); } } \/\/ Return return ann; }","old_code_raw":"  public static Annotation fromProto(CoreMapProtos.Document proto) {\n    \/\/ Set text\n    Annotation ann = new Annotation(proto.getText());\n\n    \/\/ Add tokens\n    List<CoreLabel> tokens = new ArrayList<CoreLabel>(proto.getTokenCount());\n    for (CoreMapProtos.CoreLabel token : proto.getTokenList()) {\n      CoreLabel coreLabel = fromProto(token);\n      \/\/ Set docid\n      if (proto.hasDocID()) { coreLabel.setDocID(proto.getDocID()); }\n      tokens.add(coreLabel);\n    }\n    if (!tokens.isEmpty()) { ann.set(TokensAnnotation.class, tokens); }\n\n    \/\/ Add sentences\n    List<CoreMap> sentences = new ArrayList<CoreMap>(proto.getSentenceCount());\n    for (int sentIndex = 0; sentIndex < proto.getSentenceCount(); ++sentIndex) {\n      CoreMapProtos.Sentence sentence = proto.getSentence(sentIndex);\n      CoreMap map = fromProto(sentence);\n      if (!tokens.isEmpty() && sentence.hasTokenOffsetBegin() && sentence.hasTokenOffsetEnd()) {\n        \/\/ Set tokens for sentence\n        map.set(TokensAnnotation.class, tokens.subList(sentence.getTokenOffsetBegin(), sentence.getTokenOffsetEnd()));\n        \/\/ Set sentence index + token index + paragraph index\n        for (int i = sentence.getTokenOffsetBegin(); i < sentence.getTokenOffsetEnd(); ++i) {\n          tokens.get(i).setSentIndex(sentIndex);\n          tokens.get(i).setIndex(i - sentence.getTokenOffsetBegin() + 1);\n          if (sentence.hasParagraph()) { tokens.get(i).set(ParagraphAnnotation.class, sentence.getParagraph()); }\n        }\n        \/\/ Set text\n        map.set(TextAnnotation.class, proto.getText().substring(sentence.getCharacterOffsetBegin(), sentence.getCharacterOffsetEnd()));\n      }\n      \/\/ End iteration\n      sentences.add(map);\n    }\n    if (!sentences.isEmpty()) { ann.set(SentencesAnnotation.class, sentences); }\n\n    \/\/ Set DocID\n    String docid = null;\n    if (proto.hasDocID()) {\n      docid = proto.getDocID();\n      ann.set(DocIDAnnotation.class, docid);\n    }\n\n    \/\/ Set coref chain\n    Map<Integer, CorefChain> corefChains = new HashMap<Integer, CorefChain>();\n    for (CoreMapProtos.CorefChain chainProto : proto.getCorefChainList()) {\n      CorefChain chain = fromProto(chainProto, ann);\n      corefChains.put(chain.getChainID(), chain);\n    }\n    if (!corefChains.isEmpty()) { ann.set(CorefChainAnnotation.class, corefChains); }\n\n    \/\/ Set dependency graphs\n    \/\/ We need to wait until here, since this is the first time we see tokens\n    for (int i = 0; i < proto.getSentenceCount(); ++i) {\n      CoreMapProtos.Sentence sentence = proto.getSentenceList().get(i);\n      CoreMap map = sentences.get(i);\n      List<CoreLabel> sentenceTokens = map.get(TokensAnnotation.class);\n      if (sentence.hasBasicDependencies()) {\n        map.set(BasicDependenciesAnnotation.class, fromProto(sentence.getBasicDependencies(), sentenceTokens, docid));\n      }\n      if (sentence.hasCollapsedDependencies()) {\n        map.set(CollapsedDependenciesAnnotation.class, fromProto(sentence.getCollapsedDependencies(), sentenceTokens, docid));\n      }\n      if (sentence.hasCollapsedCCProcessedDependencies()) {\n        map.set(CollapsedCCProcessedDependenciesAnnotation.class, fromProto(sentence.getCollapsedCCProcessedDependencies(), sentenceTokens, docid));\n      }\n    }\n\n    \/\/ Redo some light annotation\n    for (CoreMap sentence : sentences) {\n      if (sentence.containsKey(TokensAnnotation.class)) {\n        sentence.set(NumerizedTokensAnnotation.class, NumberNormalizer.findAndMergeNumbers(sentence));\n      }\n    }\n\n    \/\/ Return\n    return ann;\n  }\n","new_comment_raw":"@param proto The protocol buffer to read the document from.","old_comment_raw":"@param proto The protocol buffer to read the document from.","label":0,"pre_label":1,"AST_level":15,"line_counts":79,"new_code_token_num":653},{"new_code_raw":"private SQLResponse execute(String correctedSql, SQLRequest sqlRequest, Connection conn) throws Exception { Statement stat = null; ResultSet resultSet = null; Boolean isPushDown = false; List<List<String>> results = Lists.newArrayList(); List<SelectedColumnMeta> columnMetas = Lists.newArrayList(); try { \/\/ special case for prepare query. if (BackdoorToggles.getPrepareOnly()) { return getPrepareOnlySqlResponse(correctedSql, conn, isPushDown, results, columnMetas); } stat = conn.createStatement(); processStatementAttr(stat, sqlRequest); resultSet = stat.executeQuery(correctedSql); ResultSetMetaData metaData = resultSet.getMetaData(); int columnCount = metaData.getColumnCount(); \/\/ Fill in selected column meta for (int i = 1; i <= columnCount; ++i) { columnMetas.add(new SelectedColumnMeta(metaData.isAutoIncrement(i), metaData.isCaseSensitive(i), metaData.isSearchable(i), metaData.isCurrency(i), metaData.isNullable(i), metaData.isSigned(i), metaData.getColumnDisplaySize(i), metaData.getColumnLabel(i), metaData.getColumnName(i), metaData.getSchemaName(i), metaData.getCatalogName(i), metaData.getTableName(i), metaData.getPrecision(i), metaData.getScale(i), metaData.getColumnType(i), metaData.getColumnTypeName(i), metaData.isReadOnly(i), metaData.isWritable(i), metaData.isDefinitelyWritable(i))); } \/\/ fill in results while (resultSet.next()) { List<String> oneRow = Lists.newArrayListWithCapacity(columnCount); for (int i = 0; i < columnCount; i++) { oneRow.add((resultSet.getString(i + 1))); } results.add(oneRow); } } catch (SQLException sqlException) { isPushDown = PushDownUtil.doPushDownQuery(sqlRequest.getProject(), correctedSql, conn.getSchema(), results, columnMetas, sqlException); if (!isPushDown) { throw sqlException; } } finally { close(resultSet, stat, null);\/\/conn is passed in, not my duty to close } return getSqlResponse(isPushDown, results, columnMetas); }","old_code_raw":"    private SQLResponse execute(String correctedSql, SQLRequest sqlRequest) throws Exception {\n        Connection conn = null;\n        Statement stat = null;\n        ResultSet resultSet = null;\n        Boolean isPushDown = false;\n\n        List<List<String>> results = Lists.newArrayList();\n        List<SelectedColumnMeta> columnMetas = Lists.newArrayList();\n\n        try {\n            conn = QueryConnection.getConnection(sqlRequest.getProject());\n\n            \/\/ special case for prepare query. \n            if (BackdoorToggles.getPrepareOnly()) {\n                return getPrepareOnlySqlResponse(correctedSql, conn, isPushDown, results, columnMetas);\n            }\n\n            stat = conn.createStatement();\n            processStatementAttr(stat, sqlRequest);\n            resultSet = stat.executeQuery(correctedSql);\n\n            ResultSetMetaData metaData = resultSet.getMetaData();\n            int columnCount = metaData.getColumnCount();\n\n            \/\/ Fill in selected column meta\n            for (int i = 1; i <= columnCount; ++i) {\n                columnMetas.add(new SelectedColumnMeta(metaData.isAutoIncrement(i), metaData.isCaseSensitive(i),\n                        metaData.isSearchable(i), metaData.isCurrency(i), metaData.isNullable(i), metaData.isSigned(i),\n                        metaData.getColumnDisplaySize(i), metaData.getColumnLabel(i), metaData.getColumnName(i),\n                        metaData.getSchemaName(i), metaData.getCatalogName(i), metaData.getTableName(i),\n                        metaData.getPrecision(i), metaData.getScale(i), metaData.getColumnType(i),\n                        metaData.getColumnTypeName(i), metaData.isReadOnly(i), metaData.isWritable(i),\n                        metaData.isDefinitelyWritable(i)));\n            }\n\n            \/\/ fill in results\n            while (resultSet.next()) {\n                List<String> oneRow = Lists.newArrayListWithCapacity(columnCount);\n                for (int i = 0; i < columnCount; i++) {\n                    oneRow.add((resultSet.getString(i + 1)));\n                }\n\n                results.add(oneRow);\n            }\n        } catch (SQLException sqlException) {\n            isPushDown = PushDownUtil.doPushDownQuery(sqlRequest.getProject(), correctedSql, conn.getSchema(), results, columnMetas,\n                    sqlException);\n            if (!isPushDown) {\n                throw sqlException;\n            }\n        } finally {\n            close(resultSet, stat, conn);\n        }\n\n        return getSqlResponse(isPushDown, results, columnMetas);\n    }\n","new_comment_raw":"@param sqlRequest","old_comment_raw":"@param sqlRequest","label":0,"pre_label":1,"AST_level":12,"line_counts":55,"new_code_token_num":389},{"new_code_raw":"public static ParquetTableMetadata_v4 getParquetTableMetadata(FileSystem fs, Path path, ParquetReaderConfig readerConfig) throws IOException { Metadata metadata = new Metadata(readerConfig); return metadata.getParquetTableMetadata(path, fs); }","old_code_raw":"  public static ParquetTableMetadata_v4 getParquetTableMetadata(FileSystem fs, String path, ParquetReaderConfig readerConfig) throws IOException {\n    Metadata metadata = new Metadata(readerConfig);\n    return metadata.getParquetTableMetadata(path, fs);\n  }\n","new_comment_raw":"@param fs file system","old_comment_raw":"@param fs file system","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":35},{"new_code_raw":"public List<CodegenSecurity> fromSecurity(Map<String, SecurityScheme> securitySchemeMap) { if (securitySchemeMap == null) { return Collections.emptyList(); } List<CodegenSecurity> codegenSecurities = new ArrayList<CodegenSecurity>(securitySchemeMap.size()); for (String key : securitySchemeMap.keySet()) { final SecurityScheme securityScheme = securitySchemeMap.get(key); CodegenSecurity cs = CodegenModelFactory.newInstance(CodegenModelType.SECURITY); cs.name = key; cs.type = securityScheme.getType().toString(); cs.isCode = cs.isPassword = cs.isApplication = cs.isImplicit = false; if (SecurityScheme.Type.APIKEY.equals(securityScheme.getType())) { cs.isBasic = cs.isOAuth = false; cs.isApiKey = true; cs.keyParamName = securityScheme.getName(); cs.isKeyInHeader = securityScheme.getIn() == SecurityScheme.In.HEADER; cs.isKeyInQuery = !cs.isKeyInHeader; } else if (SecurityScheme.Type.HTTP.equals(securityScheme.getType())) { cs.isKeyInHeader = cs.isKeyInQuery = cs.isApiKey = cs.isOAuth = false; cs.isBasic = true; } else if (SecurityScheme.Type.OAUTH2.equals(securityScheme.getType())) { cs.isKeyInHeader = cs.isKeyInQuery = cs.isApiKey = cs.isBasic = false; cs.isOAuth = true; final OAuthFlows flows = securityScheme.getFlows(); if (securityScheme.getFlows() == null) { throw new RuntimeException(\"missing oauth flow in \" + cs.name); } if (flows.getPassword() != null) { setOauth2Info(cs, flows.getPassword()); cs.isPassword = true; cs.flow = \"password\"; } else if (flows.getImplicit() != null) { setOauth2Info(cs, flows.getImplicit()); cs.isImplicit = true; cs.flow = \"implicit\"; } else if (flows.getClientCredentials() != null) { setOauth2Info(cs, flows.getClientCredentials()); cs.isApplication = true; cs.flow = \"application\"; } else if (flows.getAuthorizationCode() != null) { setOauth2Info(cs, flows.getAuthorizationCode()); cs.isCode = true; cs.flow = \"accessCode\"; } else { throw new RuntimeException(\"Could not identify any oauth2 flow in \" + cs.name); } } codegenSecurities.add(cs); } \/\/ sort auth methods to maintain the same order Collections.sort(codegenSecurities, new Comparator<CodegenSecurity>() { @Override public int compare(CodegenSecurity one, CodegenSecurity another) { return ObjectUtils.compare(one.name, another.name); } }); \/\/ set 'hasMore' Iterator<CodegenSecurity> it = codegenSecurities.iterator(); while (it.hasNext()) { final CodegenSecurity security = it.next(); security.hasMore = it.hasNext(); } return codegenSecurities; }","old_code_raw":"    public List<CodegenSecurity> fromSecurity(Map<String, SecuritySchemeDefinition> schemes) {\n        if (schemes == null) {\n            return Collections.emptyList();\n        }\n\n        List<CodegenSecurity> secs = new ArrayList<CodegenSecurity>(schemes.size());\n        for (Iterator<Map.Entry<String, SecuritySchemeDefinition>> it = schemes.entrySet().iterator(); it.hasNext(); ) {\n            final Map.Entry<String, SecuritySchemeDefinition> entry = it.next();\n            final SecuritySchemeDefinition schemeDefinition = entry.getValue();\n\n            CodegenSecurity sec = CodegenModelFactory.newInstance(CodegenModelType.SECURITY);\n            sec.name = entry.getKey();\n            sec.type = schemeDefinition.getType();\n            sec.isCode = sec.isPassword = sec.isApplication = sec.isImplicit = false;\n            sec.vendorExtensions = schemeDefinition.getVendorExtensions();\n\n            if (schemeDefinition instanceof ApiKeyAuthDefinition) {\n                final ApiKeyAuthDefinition apiKeyDefinition = (ApiKeyAuthDefinition) schemeDefinition;\n                sec.isBasic = sec.isOAuth = false;\n                sec.isApiKey = true;\n                sec.keyParamName = apiKeyDefinition.getName();\n                sec.isKeyInHeader = apiKeyDefinition.getIn() == In.HEADER;\n                sec.isKeyInQuery = !sec.isKeyInHeader;\n            } else if(schemeDefinition instanceof BasicAuthDefinition) {\n                sec.isKeyInHeader = sec.isKeyInQuery = sec.isApiKey = sec.isOAuth = false;\n                sec.isBasic = true;\n            } else {\n                final OAuth2Definition oauth2Definition = (OAuth2Definition) schemeDefinition;\n                sec.isKeyInHeader = sec.isKeyInQuery = sec.isApiKey = sec.isBasic = false;\n                sec.isOAuth = true;\n                sec.flow = oauth2Definition.getFlow();\n                if (sec.flow == null) {\n                    throw new RuntimeException(\"missing oauth flow in \" + sec.name);\n                }\n                switch(sec.flow) {\n                    case \"accessCode\":\n                        sec.isCode = true;\n                        break;\n                    case \"password\":\n                        sec.isPassword = true;\n                        break;\n                    case \"application\":\n                        sec.isApplication = true;\n                        break;\n                    case \"implicit\":\n                        sec.isImplicit = true;\n                        break;\n                    default:\n                        throw new RuntimeException(\"unknown oauth flow: \" + sec.flow);\n                }\n                sec.authorizationUrl = oauth2Definition.getAuthorizationUrl();\n                sec.tokenUrl = oauth2Definition.getTokenUrl();\n                if (oauth2Definition.getScopes() != null) {\n                    List<Map<String, Object>> scopes = new ArrayList<Map<String, Object>>();\n                    int count = 0, numScopes = oauth2Definition.getScopes().size();\n                    for(Map.Entry<String, String> scopeEntry : oauth2Definition.getScopes().entrySet()) {\n                        Map<String, Object> scope = new HashMap<String, Object>();\n                        scope.put(\"scope\", scopeEntry.getKey());\n                        scope.put(\"description\", escapeText(scopeEntry.getValue()));\n\n                        count += 1;\n                        if (count < numScopes) {\n                            scope.put(\"hasMore\", \"true\");\n                        } else {\n                            scope.put(\"hasMore\", null);\n                        }\n\n                        scopes.add(scope);\n                    }\n                    sec.scopes = scopes;\n                }\n            }\n\n            secs.add(sec);\n        }\n\n        \/\/ sort auth methods to maintain the same order\n        Collections.sort(secs, new Comparator<CodegenSecurity>() {\n            @Override\n            public int compare(CodegenSecurity one, CodegenSecurity another) {\n                return ObjectUtils.compare(one.name, another.name);\n            }\n        });\n        \/\/ set 'hasMore'\n        Iterator<CodegenSecurity> it = secs.iterator();\n        while (it.hasNext()) {\n            final CodegenSecurity security = it.next();\n            security.hasMore = it.hasNext();\n        }\n\n        return secs;\n    }\n","new_comment_raw":"@param securitySchemeMap a map of OAS SecuritySchemeDefinition object","old_comment_raw":"@param schemes a map of Swagger SecuritySchemeDefinition object","label":1,"pre_label":0,"AST_level":17,"line_counts":71,"new_code_token_num":478},{"new_code_raw":"private StringBuilder appendIfNotNull(StringBuilder source, String addStr, String delimiter) { if (addStr != null) { if (addStr.length() == 0) { delimiter = \"\"; } return source.append(addStr).append(delimiter); } return source; }","old_code_raw":"    private String appendIfNotNull(String sourceStr, String appendStr, String delimiter) {\n        if (appendStr != null) {\n            if (appendStr.length() == 0) {\n                delimiter = \"\";\n            }\n            sourceStr += delimiter + appendStr;\n        }\n        return sourceStr;\n    }\n","new_comment_raw":"@param addStrStr The String to append","old_comment_raw":"@param appendStr The String to append","label":1,"pre_label":0,"AST_level":9,"line_counts":12,"new_code_token_num":51},{"new_code_raw":"public Action cancelled(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException { synchronized (req) { AtmosphereResourceImpl r = null; try { if (trackActiveRequest) { long l = (Long) req.getAttribute(MAX_INACTIVE); if (l == -1) { \/\/ The closedDetector closed the connection. return timedoutAction; } req.setAttribute(MAX_INACTIVE, (long) -1); } logger.debug(\"Cancelling the connection for request {}\", req); r = (AtmosphereResourceImpl) req.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE); if (r != null) { r.getAtmosphereResourceEvent().setCancelled(true); invokeAtmosphereHandler(r); try { r.getResponse().sendError(503); r.getResponse().getOutputStream().close(); } catch (Throwable t) { try { r.getResponse().getWriter().close(); } catch (Throwable t2) { } } } } catch (Throwable ex) { \/\/ Something wrong happenned, ignore the exception logger.debug(\"failed to cancel resource: \" + r, ex); } finally { try { if (r != null) { r.notifyListeners(); r.setIsInScope(false); r.cancel(); } } catch (Throwable t) { logger.trace(\"cancel\", t); } finally { if (r != null) { destroyResource(r); } } } } return cancelledAction; }","old_code_raw":"    public Action cancelled(HttpServletRequest req, HttpServletResponse res)\n            throws IOException, ServletException {\n\n        synchronized (req) {\n            AtmosphereResourceImpl r = null;\n            try {\n                if (trackActiveRequest) {\n                    long l = (Long) req.getAttribute(MAX_INACTIVE);\n                    if (l == -1) {\n                        \/\/ The closedDetector closed the connection.\n                        return timedoutAction;\n                    }\n                    req.setAttribute(MAX_INACTIVE, (long) -1);\n                }\n\n                logger.debug(\"Cancelling the connection for request {}\", req);\n\n                r = (AtmosphereResourceImpl) req.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE);\n                if (r != null) {\n                    r.getAtmosphereResourceEvent().setCancelled(true);\n                    invokeAtmosphereHandler(r);\n\n                    try {\n                        r.getResponse().sendError(503);\n                        r.getResponse().getOutputStream().close();\n                    } catch (Throwable t) {\n                        try {\n                            r.getResponse().getWriter().close();\n                        } catch (Throwable t2) {\n                        }\n                    }\n                }\n            } catch (Throwable ex) {\n                \/\/ Something wrong happenned, ignore the exception\n                logger.debug(\"failed to cancel resource: \" + r, ex);\n            } finally {\n                try {\n                    if (r != null) {\n                        r.notifyListeners();\n                        r.setIsInScope(false);\n                        r.cancel();\n                    }\n                } catch (Throwable t) {\n                    logger.trace(\"cancel\", t);\n                } finally {\n                    if (r != null) {\n                        destroyResource(r);\n                    }\n                }\n            }\n        }\n\n        return cancelledAction;\n    }\n","new_comment_raw":"@param req the  AtmosphereRequest","old_comment_raw":"@param req the HttpServletRequest","label":1,"pre_label":0,"AST_level":12,"line_counts":55,"new_code_token_num":274},{"new_code_raw":"public int recordObject(CollectionId id, Document object, Instant timestamp) throws InterruptedException { source.collectionEvent(replicaSetName, id); final Struct sourceValue = source.struct(); final Map<String, ?> offset = source.lastOffset(replicaSetName); String objId = idObjToJson(object); assert objId != null; return createRecords(sourceValue, offset, Operation.READ, objId, object, timestamp); }","old_code_raw":"        public int recordObject(CollectionId id, Document object, long timestamp) throws InterruptedException {\n            source.collectionEvent(replicaSetName, id);\n            final Struct sourceValue = source.struct();\n            final Map<String, ?> offset = source.lastOffset(replicaSetName);\n            String objId = idObjToJson(object);\n            assert objId != null;\n            return createRecords(sourceValue, offset, Operation.READ, objId, object, timestamp);\n        }\n","new_comment_raw":"@param object the document; may not be null","old_comment_raw":"@param object the document; may not be null","label":0,"pre_label":1,"AST_level":6,"line_counts":9,"new_code_token_num":74},{"new_code_raw":"protected static User decode(int contextId, String encodedString, ExtensionAuthentication authenticationExtension) { String[] pieces = encodedString.split(FIELD_SEPARATOR); User user = null; try { int id = Integer.parseInt(pieces[0]); if (id >= ID_SOURCE) ID_SOURCE = id + 1; boolean enabled = pieces[2].equals(\"true\"); String name = new String(Base64.decodeBase64(pieces[3])); int authTypeId = Integer.parseInt(pieces[4]); user = new User(contextId, name, id); user.setEnabled(enabled); AuthenticationCredentials cred = authenticationExtension .getAuthenticationMethodTypeForIdentifier(authTypeId).createAuthenticationCredentials(); cred.decode(pieces[5]); user.setAuthenticationCredentials(cred); } catch (Exception ex) { log.error(\"An error occured while decoding user from: \" + encodedString, ex); return null; } if (log.isDebugEnabled()) log.debug(\"Decoded user: \" + user); return user; }","old_code_raw":"\tprotected static User decode(String encodedString, ExtensionAuthentication authenticationExtension) {\n\t\tString[] pieces = encodedString.split(FIELD_SEPARATOR);\n\t\tUser user = null;\n\t\ttry {\n\t\t\tint id = Integer.parseInt(pieces[0]);\n\t\t\tif (id >= ID_SOURCE)\n\t\t\t\tID_SOURCE = id + 1;\n\t\t\tint contextId = Integer.parseInt(pieces[1]);\n\t\t\tboolean enabled = pieces[2].equals(\"true\");\n\t\t\tString name = new String(Base64.decodeBase64(pieces[3]));\n\t\t\tint authTypeId = Integer.parseInt(pieces[4]);\n\t\t\tuser = new User(contextId, name, id);\n\t\t\tuser.setEnabled(enabled);\n\n\t\t\tAuthenticationCredentials cred = authenticationExtension\n\t\t\t\t\t.getAuthenticationMethodTypeForIdentifier(authTypeId).createAuthenticationCredentials();\n\t\t\tcred.decode(pieces[5]);\n\t\t\tuser.setAuthenticationCredentials(cred);\n\t\t} catch (Exception ex) {\n\t\t\tlog.error(\"An error occured while decoding user from: \" + encodedString, ex);\n\t\t\treturn null;\n\t\t}\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"Decoded user: \" + user);\n\t\treturn user;\n\t}\n","new_comment_raw":"@param encodedString the encoded string","old_comment_raw":"@param encodedString the encoded string","label":0,"pre_label":1,"AST_level":10,"line_counts":26,"new_code_token_num":187},{"new_code_raw":"public void addPet (Pet pet) throws TimeoutException, ExecutionException, InterruptedException, ApiException { Object postBody = pet; \/\/ verify the required parameter 'pet' is set if (pet == null) { VolleyError error = new VolleyError(\"Missing the required parameter 'pet' when calling addPet\", new ApiException(400, \"Missing the required parameter 'pet' when calling addPet\")); } \/\/ create path and map variables String path = \"\/pet\"; \/\/ query params List<Pair> queryParams = new ArrayList<Pair>(); \/\/ header params Map<String, String> headerParams = new HashMap<String, String>(); \/\/ form params Map<String, String> formParams = new HashMap<String, String>(); String[] contentTypes = { }; String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\"; if (contentType.startsWith(\"multipart\/form-data\")) { \/\/ file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); HttpEntity httpEntity = localVarBuilder.build(); postBody = httpEntity; } else { \/\/ normal form params } String[] authNames = new String[] { \"petstore_auth\" }; try { String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames); if (localVarResponse != null) { return ; } else { return ; } } catch (ApiException ex) { throw ex; } catch (InterruptedException ex) { throw ex; } catch (ExecutionException ex) { if (ex.getCause() instanceof VolleyError) { VolleyError volleyError = (VolleyError)ex.getCause(); if (volleyError.networkResponse != null) { throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage()); } } throw ex; } catch (TimeoutException ex) { throw ex; } }","old_code_raw":"  public void addPet (Pet body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {\n    Object postBody = body;\n    \/\/ verify the required parameter 'body' is set\n    if (body == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'body' when calling addPet\",\n        new ApiException(400, \"Missing the required parameter 'body' when calling addPet\"));\n    }\n\n    \/\/ create path and map variables\n    String path = \"\/pet\";\n\n    \/\/ query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    \/\/ header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    \/\/ form params\n    Map<String, String> formParams = new HashMap<String, String>();\n    String[] contentTypes = {\n      \"application\/json\",\n      \"application\/xml\"\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\";\n\n    if (contentType.startsWith(\"multipart\/form-data\")) {\n      \/\/ file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      HttpEntity httpEntity = localVarBuilder.build();\n      postBody = httpEntity;\n    } else {\n      \/\/ normal form params\n    }\n\n    String[] authNames = new String[] { \"petstore_auth\" };\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames);\n      if (localVarResponse != null) {\n         return ;\n      } else {\n         return ;\n      }\n    } catch (ApiException ex) {\n       throw ex;\n    } catch (InterruptedException ex) {\n       throw ex;\n    } catch (ExecutionException ex) {\n      if (ex.getCause() instanceof VolleyError) {\n        VolleyError volleyError = (VolleyError)ex.getCause();\n        if (volleyError.networkResponse != null) {\n          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());\n        }\n      }\n      throw ex;\n    } catch (TimeoutException ex) {\n      throw ex;\n    }\n  }\n","new_comment_raw":"@param pet Pet object that needs to be added to the store","old_comment_raw":"@param body Pet object that needs to be added to the store","label":1,"pre_label":0,"AST_level":11,"line_counts":56,"new_code_token_num":349},{"new_code_raw":"public Lock acquirePutFromLoadLock(SharedSessionContractImplementor session, Object key, long txTimestamp) { if (trace) { log.tracef(\"acquirePutFromLoadLock(%s#%s, %d)\", cache.getName(), key, txTimestamp); } boolean locked = false; PendingPutMap pending = pendingPuts.get( key ); for (;;) { try { if (pending != null) { locked = pending.acquireLock(100, TimeUnit.MILLISECONDS); if (locked) { boolean valid = false; try { if (pending.isRemoved()) { \/\/ this deals with a race between retrieving the map from cache vs. removing that \/\/ and locking the map pending.releaseLock(); locked = false; pending = null; if (trace) { log.tracef(\"Record removed when waiting for the lock.\"); } continue; } final PendingPut toCancel = pending.remove(session); if (toCancel != null) { valid = !toCancel.completed; toCancel.completed = true; } else { \/\/ this is a naked put if (pending.hasInvalidator()) { valid = false; } \/\/ we need this check since registerPendingPut (creating new pp) can get between invalidation \/\/ and naked put caused by the invalidation else if (pending.lastInvalidationEnd != Long.MIN_VALUE) { \/\/ if this transaction started afterQuery last invalidation we can continue valid = txTimestamp > pending.lastInvalidationEnd; } else { valid = txTimestamp > regionInvalidationTimestamp; } } return valid ? pending : null; } finally { if (!valid && pending != null) { pending.releaseLock(); locked = false; } if (trace) { log.tracef(\"acquirePutFromLoadLock(%s#%s, %d) ended with %s, valid: %s\", cache.getName(), key, txTimestamp, pending, valid); } } } else { if (trace) { log.tracef(\"acquirePutFromLoadLock(%s#%s, %d) failed to lock\", cache.getName(), key, txTimestamp); } \/\/ oops, we have leaked record for this owner, but we don't want to wait here return null; } } else { long regionInvalidationTimestamp = this.regionInvalidationTimestamp; if (txTimestamp <= regionInvalidationTimestamp) { if (trace) { log.tracef(\"acquirePutFromLoadLock(%s#%s, %d) failed due to region invalidated at %d\", cache.getName(), key, txTimestamp, regionInvalidationTimestamp); } return null; } else { if (trace) { log.tracef(\"Region invalidated at %d, this transaction started at %d\", regionInvalidationTimestamp, txTimestamp); } } PendingPut pendingPut = new PendingPut(session); pending = new PendingPutMap(pendingPut); PendingPutMap existing = pendingPuts.putIfAbsent(key, pending); if (existing != null) { pending = existing; } \/\/ continue in next loop with lock acquisition } } catch (Throwable t) { if (locked) { pending.releaseLock(); } if (t instanceof RuntimeException) { throw (RuntimeException) t; } else if (t instanceof Error) { throw (Error) t; } else { throw new RuntimeException(t); } } } }","old_code_raw":"\tpublic Lock acquirePutFromLoadLock(SessionImplementor session, Object key, long txTimestamp) {\n\t\tif (trace) {\n\t\t\tlog.tracef(\"acquirePutFromLoadLock(%s#%s, %d)\", cache.getName(), key, txTimestamp);\n\t\t}\n\t\tboolean locked = false;\n\n\t\tPendingPutMap pending = pendingPuts.get( key );\n\t\tfor (;;) {\n\t\t\ttry {\n\t\t\t\tif (pending != null) {\n\t\t\t\t\tlocked = pending.acquireLock(100, TimeUnit.MILLISECONDS);\n\t\t\t\t\tif (locked) {\n\t\t\t\t\t\tboolean valid = false;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (pending.isRemoved()) {\n\t\t\t\t\t\t\t\t\/\/ this deals with a race between retrieving the map from cache vs. removing that\n\t\t\t\t\t\t\t\t\/\/ and locking the map\n\t\t\t\t\t\t\t\tpending.releaseLock();\n\t\t\t\t\t\t\t\tlocked = false;\n\t\t\t\t\t\t\t\tpending = null;\n\t\t\t\t\t\t\t\tif (trace) {\n\t\t\t\t\t\t\t\t\tlog.tracef(\"Record removed when waiting for the lock.\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfinal PendingPut toCancel = pending.remove(session);\n\t\t\t\t\t\t\tif (toCancel != null) {\n\t\t\t\t\t\t\t\tvalid = !toCancel.completed;\n\t\t\t\t\t\t\t\ttoCancel.completed = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\/\/ this is a naked put\n\t\t\t\t\t\t\t\tif (pending.hasInvalidator()) {\n\t\t\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\/\/ we need this check since registerPendingPut (creating new pp) can get between invalidation\n\t\t\t\t\t\t\t\t\/\/ and naked put caused by the invalidation\n\t\t\t\t\t\t\t\telse if (pending.lastInvalidationEnd != Long.MIN_VALUE) {\n\t\t\t\t\t\t\t\t\t\/\/ if this transaction started afterQuery last invalidation we can continue\n\t\t\t\t\t\t\t\t\tvalid = txTimestamp > pending.lastInvalidationEnd;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tvalid = txTimestamp > regionInvalidationTimestamp;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn valid ? pending : null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfinally {\n\t\t\t\t\t\t\tif (!valid && pending != null) {\n\t\t\t\t\t\t\t\tpending.releaseLock();\n\t\t\t\t\t\t\t\tlocked = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (trace) {\n\t\t\t\t\t\t\t\tlog.tracef(\"acquirePutFromLoadLock(%s#%s, %d) ended with %s, valid: %s\", cache.getName(), key, txTimestamp, pending, valid);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (trace) {\n\t\t\t\t\t\t\tlog.tracef(\"acquirePutFromLoadLock(%s#%s, %d) failed to lock\", cache.getName(), key, txTimestamp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\/\/ oops, we have leaked record for this owner, but we don't want to wait here\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlong regionInvalidationTimestamp = this.regionInvalidationTimestamp;\n\t\t\t\t\tif (txTimestamp <= regionInvalidationTimestamp) {\n\t\t\t\t\t\tif (trace) {\n\t\t\t\t\t\t\tlog.tracef(\"acquirePutFromLoadLock(%s#%s, %d) failed due to region invalidated at %d\", cache.getName(), key, txTimestamp, regionInvalidationTimestamp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (trace) {\n\t\t\t\t\t\t\tlog.tracef(\"Region invalidated at %d, this transaction started at %d\", regionInvalidationTimestamp, txTimestamp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tPendingPut pendingPut = new PendingPut(session);\n\t\t\t\t\tpending = new PendingPutMap(pendingPut);\n\t\t\t\t\tPendingPutMap existing = pendingPuts.putIfAbsent(key, pending);\n\t\t\t\t\tif (existing != null) {\n\t\t\t\t\t\tpending = existing;\n\t\t\t\t\t}\n\t\t\t\t\t\/\/ continue in next loop with lock acquisition\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable t) {\n\t\t\t\tif (locked) {\n\t\t\t\t\tpending.releaseLock();\n\t\t\t\t}\n\n\t\t\t\tif (t instanceof RuntimeException) {\n\t\t\t\t\tthrow (RuntimeException) t;\n\t\t\t\t}\n\t\t\t\telse if (t instanceof Error) {\n\t\t\t\t\tthrow (Error) t;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new RuntimeException(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n","new_comment_raw":"@param txTimestamp","old_comment_raw":"@param txTimestamp","label":0,"pre_label":1,"AST_level":19,"line_counts":106,"new_code_token_num":608},{"new_code_raw":"public boolean searchText(String text, int minimumNumberOfMatches, boolean scroll) { return searcher.searchWithTimeoutFor(TextView.class, text, minimumNumberOfMatches, scroll); }","old_code_raw":"\tpublic boolean searchText(String regex, int expectedMinimumNumberOfMatches, boolean scroll) {\n\t\treturn searcher.searchWithTimeoutFor(TextView.class, regex, expectedMinimumNumberOfMatches, scroll);\n\t}\n","new_comment_raw":"@param minimumNumberOfMatches the minimum number of matches expected to be found.  0 matches means that one or more matches are expected to be found","old_comment_raw":"@param expectedMinimumNumberOfMatches the minimum number of matches expected to be found. 0 matches means that one or more matches are expected to be found","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":29},{"new_code_raw":"public static BooleanOperation predicate(Operator operation, Expression<?>... args) { return new BooleanOperation(operation, args); }","old_code_raw":"    public static BooleanOperation predicate(Operator operator, Expression<?>... args) {\n        return new BooleanOperation(operator, args);\n    }\n","new_comment_raw":"@param operation","old_comment_raw":"@param operator operator","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":23},{"new_code_raw":"public View waitForView(int id, int index, int timeout, boolean scroll){ Set<View> uniqueViewsMatchingId = new HashSet<View>(); long endTime = SystemClock.uptimeMillis() + timeout; while (SystemClock.uptimeMillis() <= endTime) { sleeper.sleep(); for (View view : viewFetcher.getAllViews(false)) { Integer idOfView = Integer.valueOf(view.getId()); if (idOfView.equals(id)) { uniqueViewsMatchingId.add(view); if(uniqueViewsMatchingId.size() > index) { return view; } } } if(scroll) scroller.scroll(Scroller.DOWN); } return null; }","old_code_raw":"\tpublic View waitForView(int id, int index){\n\t\tArrayList<View> viewsMatchingId = new ArrayList<View>();\n\t\tlong endTime = SystemClock.uptimeMillis() + SMALL_TIMEOUT;\n\n\t\twhile (SystemClock.uptimeMillis() <= endTime) {\n\t\t\tsleeper.sleep();\n\n\t\t\tfor (View view : viewFetcher.getAllViews(false)) {\n\t\t\t\tInteger idOfView = Integer.valueOf(view.getId());\n\n\t\t\t\tif (idOfView.equals(id)) {\n\t\t\t\t\tviewsMatchingId.add(view);\n\n\t\t\t\t\tif(viewsMatchingId.size() > index) {\n\t\t\t\t\t\treturn viewsMatchingId.get(index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tviewsMatchingId.clear();\n\t\t}\n\t\treturn null;\n\t}\n","new_comment_raw":"@param view the id of the view to wait for","old_comment_raw":"@param view the id of the view to wait for","label":0,"pre_label":1,"AST_level":12,"line_counts":24,"new_code_token_num":118},{"new_code_raw":"public RexProgram normalize(RexBuilder rexBuilder, RexSimplify simplify) { \/\/ Normalize program by creating program builder from the program, then \/\/ converting to a program. getProgram does not need to normalize \/\/ because the builder was normalized on creation. assert isValid(Litmus.THROW, null); final RexProgramBuilder builder = RexProgramBuilder.create(rexBuilder, inputRowType, exprs, projects, condition, outputRowType, true, simplify); return builder.getProgram(false); }","old_code_raw":"  public RexProgram normalize(RexBuilder rexBuilder, boolean simplify) {\n    \/\/ Normalize program by creating program builder from the program, then\n    \/\/ converting to a program. getProgram does not need to normalize\n    \/\/ because the builder was normalized on creation.\n    assert isValid(Litmus.THROW, null);\n    final RexProgramBuilder builder =\n        RexProgramBuilder.create(rexBuilder, inputRowType, exprs, projects,\n            condition, outputRowType, true, simplify);\n    return builder.getProgram(false);\n  }\n","new_comment_raw":"@param simplify Simplifier to simplify (in addition to normalizing), or null to not simplify","old_comment_raw":"@param simplify Whether to simplify (in addition to normalizing)","label":1,"pre_label":0,"AST_level":6,"line_counts":11,"new_code_token_num":85},{"new_code_raw":"public static RemoteProxy getNewBasicRemoteProxy(String appName, String url,Registry registry) { RegistrationRequest req = new RegistrationRequest(); Map<String, Object> capability = new HashMap<String, Object>(); capability.put(\"applicationName\", appName); req.addDesiredCapabilitiy(capability); Map<String, Object> config = new HashMap<String, Object>(); config.put(\"url\", url); req.setConfiguration(config); return new RemoteProxy(req,registry); }","old_code_raw":"\tpublic static RemoteProxy getNewBasicRemoteProxy(String appName, String url) {\n\n\t\tRegistrationRequest req = new RegistrationRequest();\n\n\t\tMap<String, Object> capability = new HashMap<String, Object>();\n\t\tcapability.put(\"applicationName\", appName);\n\t\treq.addDesiredCapabilitiy(capability);\n\n\t\tMap<String, Object> config = new HashMap<String, Object>();\n\t\tconfig.put(\"url\", url);\n\t\treq.setConfiguration(config);\n\t\treturn new RemoteProxy(req);\n\n\t}\n","new_comment_raw":"@param appName","old_comment_raw":"@param appName","label":0,"pre_label":1,"AST_level":8,"line_counts":15,"new_code_token_num":90},{"new_code_raw":"public static String getObjectName(AssetFile asset, ObjectPath path) { Deserializer deser = new Deserializer(asset); String name = null; try { UnityObject obj = deser.deserialize(path); name = obj.getValue(\"m_Name\"); } catch (OutOfMemoryError ex) { \/\/ Deserializer choked on an array size and clogged the heap, try \/\/ to clean up this mess deser = null; System.gc(); } catch (Throwable ex) { } return name; }","old_code_raw":"    public static String getObjectName(AssetFile asset, AssetObjectPath path) {\n        Deserializer deser = new Deserializer(asset);\n        String name = null;\n        \n        try {\n            UnityObject obj = deser.deserialize(path);\n            name = obj.getValue(\"m_Name\");\n        } catch (OutOfMemoryError ex) {\n            \/\/ Deserializer choked on an array size and clogged the heap, try\n            \/\/ to clean up this mess\n            deser = null;\n            System.gc();\n        } catch (Throwable ex) {\n        }\n        \n        return name;\n    }\n","new_comment_raw":"@param path object path","old_comment_raw":"@param path object path","label":0,"pre_label":1,"AST_level":7,"line_counts":18,"new_code_token_num":91},{"new_code_raw":"public static <T> Method findMethod(Class<?> implClass, Operation<T> operation) throws NoSuchMethodException { String name = operation.getName(); Class<?>[] paramTypes = getPhysicalTypes(operation); return implClass.getMethod(name, paramTypes); }","old_code_raw":"    public static Method findMethod(Operation<?> operation, Method[] methods) {\n        for (Method method : methods) {\n            if (match(operation, method)) {\n                return method;\n            }\n        }\n        return null;\n    }\n","new_comment_raw":"@param operation the operation to match","old_comment_raw":"@param methods the methods to match against","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":44},{"new_code_raw":"private int scanURL(String url, User user, int maxChildren) throws ApiException { log.debug(\"API Spider scanning url: \" + url); URI startURI; try { \/\/ Try to build uri startURI = new URI(url, true); } catch (URIException e) { throw new ApiException(ApiException.Type.BAD_FORMAT); } SiteNode startNode = Model.getSingleton().getSession().getSiteTree().findNode(startURI); String scheme = startURI.getScheme(); if (scheme == null || (!scheme.equalsIgnoreCase(\"http\") && !scheme.equalsIgnoreCase(\"https\"))) { throw new ApiException(ApiException.Type.BAD_FORMAT); } Target target = new Target(startNode); target.setRecurse(true); Object[] objs = null; if (maxChildren > 0) { \/\/ Add the filters to filter on maximum number of children MaxChildrenFetchFilter maxChildrenFetchFilter = new MaxChildrenFetchFilter(); maxChildrenFetchFilter.setMaxChildren(maxChildren); maxChildrenFetchFilter.setModel(extension.getModel()); MaxChildrenParseFilter maxChildrenParseFilter = new MaxChildrenParseFilter(); maxChildrenParseFilter.setMaxChildren(maxChildren); maxChildrenParseFilter.setModel(extension.getModel()); objs = new Object[] { maxChildrenFetchFilter, maxChildrenParseFilter }; } return extension.startScan(target.getDisplayName(), target, user, objs); }","old_code_raw":"\tprivate int scanURL(String url, User user) throws ApiException {\n\t\tlog.debug(\"API Spider scanning url: \" + url);\n\n\t\tURI startURI;\n\t\ttry {\n\t\t\t\/\/ Try to build uri\n\t\t\tstartURI = new URI(url, true);\n\t\t} catch (URIException e) {\n\t\t\tthrow new ApiException(ApiException.Type.BAD_FORMAT);\n\t\t}\n\n\t\tSiteNode startNode = Model.getSingleton().getSession().getSiteTree().findNode(startURI);\n\t\tString scheme = startURI.getScheme();\n\t\tif (scheme == null || (!scheme.equalsIgnoreCase(\"http\") && !scheme.equalsIgnoreCase(\"https\"))) {\n\t\t\tthrow new ApiException(ApiException.Type.BAD_FORMAT);\n\t\t}\n\t\tTarget target = new Target(startNode);\n\t\ttarget.setRecurse(true);\n\t\treturn extension.startScan(target.getDisplayName(), target, user, null);\n\t}\n","new_comment_raw":"@param user the user to scan as, or null if the scan is done without the perspective of any user","old_comment_raw":"@param user the user to scan as, or null if the scan is done without the perspective of any user","label":0,"pre_label":1,"AST_level":9,"line_counts":38,"new_code_token_num":240},{"new_code_raw":"public String getShortName(long instant, Locale locale) { if (locale == null) { locale = Locale.getDefault(); } String nameKey = getNameKey(instant); if (nameKey == null) { return iID; } String name = cNameProvider.getShortName(locale, iID, nameKey); if (name != null) { return name; } return offsetFormatter().print(instant, this); }","old_code_raw":"    public String getShortName(long millis, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(millis);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getShortName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return offsetFormatter().print(millis, this);\n    }\n","new_comment_raw":"@param instant milliseconds from 1970-01-01T00:00:00Z to get the name for","old_comment_raw":"@param millis milliseconds from 1970-01-01T00:00:00Z to get the name for","label":1,"pre_label":0,"AST_level":7,"line_counts":15,"new_code_token_num":76},{"new_code_raw":"private String runHTMLSuite(String browser, String browserURL, String suiteURL, File outputFile, long timeoutInSeconds, boolean multiWindow, String defaultLogLevel) throws IOException { outputFile.createNewFile(); if (!outputFile.canWrite()) { throw new IOException(\"Can't write to outputFile: \" + outputFile.getAbsolutePath()); } long timeoutInMs = 1000l * timeoutInSeconds; if (timeoutInMs < 0) { log.warn(\"Looks like the timeout overflowed, so resetting it to the maximum.\"); timeoutInMs = Long.MAX_VALUE; } RemoteControlConfiguration configuration = remoteControl.getConfiguration(); remoteControl.handleHTMLRunnerResults(this); String sessionId = Long.toString(System.currentTimeMillis() % 1000000); FrameGroupCommandQueueSet.makeQueueSet( sessionId, configuration.getPortDriversShouldContact(), configuration); BrowserConfigurationOptions browserOptions = new BrowserConfigurationOptions(); configuration.copySettingsIntoBrowserOptions(browserOptions); browserOptions.setSingleWindow(!multiWindow); BrowserLauncher launcher = getBrowserLauncher(browser, sessionId, configuration, browserOptions); BrowserSessionInfo sessionInfo = new BrowserSessionInfo(sessionId, browser, browserURL, launcher, null); remoteControl.registerBrowserSession(sessionInfo); \/\/ JB: -- aren't these URLs in the wrong order according to declaration? launcher.launchHTMLSuite(suiteURL, browserURL); sleepTight(timeoutInMs); launcher.close(); remoteControl.deregisterBrowserSession(sessionInfo); if (results == null) { throw new SeleniumCommandTimedOutException(); } writeResults(outputFile); return results.getResult().toUpperCase(); }","old_code_raw":"    private String runHTMLSuite(String browser, String browserURL, String suiteURL, File outputFile, int timeoutInSeconds, boolean multiWindow, String defaultLogLevel) throws IOException {\n        outputFile.createNewFile();\n        if (!outputFile.canWrite()) {\n        \tthrow new IOException(\"Can't write to outputFile: \" + outputFile.getAbsolutePath());\n        }\n    \tlong timeoutInMs = 1000l * timeoutInSeconds;\n        if (timeoutInMs < 0) {\n            log.warn(\"Looks like the timeout overflowed, so resetting it to the maximum.\");\n            timeoutInMs = Long.MAX_VALUE;\n        }\n        \n        RemoteControlConfiguration configuration = remoteControl.getConfiguration();\n        remoteControl.handleHTMLRunnerResults(this);\n\n        String sessionId = Long.toString(System.currentTimeMillis() % 1000000);\n        FrameGroupCommandQueueSet.makeQueueSet(\n                sessionId, configuration.getPortDriversShouldContact(), configuration);\n\n        BrowserConfigurationOptions browserOptions = new BrowserConfigurationOptions();\n        \n        configuration.copySettingsIntoBrowserOptions(browserOptions);\n        \n        browserOptions.setSingleWindow(!multiWindow);\n        \n        BrowserLauncher launcher = getBrowserLauncher(browser, sessionId, configuration, browserOptions);\n        BrowserSessionInfo sessionInfo = new BrowserSessionInfo(sessionId, \n            browser, browserURL, launcher, null);\n        \n        remoteControl.registerBrowserSession(sessionInfo);\n        \n        \/\/ JB: -- aren't these URLs in the wrong order according to declaration?\n        launcher.launchHTMLSuite(suiteURL, browserURL);\n        \n        sleepTight(timeoutInMs);\n        \n        launcher.close();\n        \n        remoteControl.deregisterBrowserSession(sessionInfo);\n        \n        if (results == null) {\n            throw new SeleniumCommandTimedOutException();\n        }\n        \n        writeResults(outputFile);\n        \n        return results.getResult().toUpperCase();\n    }\n","new_comment_raw":"@param outputFile - The file to which we'll output the HTML results","old_comment_raw":"@param outputFile - The file to which we'll output the HTML results","label":0,"pre_label":1,"AST_level":8,"line_counts":48,"new_code_token_num":264},{"new_code_raw":"protected static TableId parse(String[] parts, int numParts, boolean useCatalogBeforeSchema) { if (numParts == 0) return null; if (numParts == 1) return new TableId(null, null, parts[0]); \/\/ table only if (numParts == 2) { if (useCatalogBeforeSchema) return new TableId(parts[0], null, parts[1]); \/\/ catalog & table only return new TableId(null, parts[0], parts[1]); \/\/ catalog & table only } return new TableId(parts[0], parts[1], parts[2]); \/\/ catalog & table only }","old_code_raw":"    public static TableId parse(String str, char delimiter, boolean useCatalogBeforeSchema) {\n        String[] parts = str.split(\"[\\\\\" + delimiter + \"]\");\n        if (parts.length == 0) return null;\n        if (parts.length == 1) return new TableId(null, null, parts[0]); \/\/ table only\n        if (parts.length == 2) {\n            if (useCatalogBeforeSchema) return new TableId(parts[0], null, parts[1]); \/\/ catalog & table only\n            return new TableId(null, parts[0], parts[1]); \/\/ catalog & table only\n        }\n        return new TableId(parts[0], parts[1], parts[2]); \/\/ catalog & table only\n    }\n","new_comment_raw":"@param numParts the number of parts to use for the table identifier","old_comment_raw":"@param delimiter the delimiter between parts","label":1,"pre_label":0,"AST_level":10,"line_counts":10,"new_code_token_num":132},{"new_code_raw":"public boolean isFlagSet(int flagsToCheck) { return (flags & flagsToCheck) != 0; }","old_code_raw":"    public boolean isFlagSet(int flag) {\n        return (flags & flag) != 0;\n    }\n","new_comment_raw":"@param flagsToCheck the flags to check","old_comment_raw":"@param flag the flag to check","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":18},{"new_code_raw":"public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); for(String key : queryParams.keySet()) { String value = queryParams.get(key); if (value != null){ if(b.toString().length() == 0) b.append(\"?\"); else b.append(\"&\"); b.append(escapeString(key)).append(\"=\").append(escapeString(value)); } } String querystring = b.toString(); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(\"GET\".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (\"POST\".equals(method)) { if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (\"PUT\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (\"DELETE\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, \"unknown method type \" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return \"\"; } } else { String message = \"error\"; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { \/\/ e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }","old_code_raw":"  public String invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          \/\/ e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n","new_comment_raw":"@param accept The request's Accept header","old_comment_raw":"@param accept The request's Accept header","label":0,"pre_label":1,"AST_level":16,"line_counts":111,"new_code_token_num":730},{"new_code_raw":"private long localToUTC(long localInstant) { DateTimeZone zone = getZone(); int offset = zone.getOffsetFromLocal(localInstant); localInstant -= offset; if (offset != zone.getOffset(localInstant)) { throw new IllegalInstantException(localInstant, zone.getID()); } return localInstant; }","old_code_raw":"    private long localToUTC(long instant) {\n        DateTimeZone zone = getZone();\n        int offset = zone.getOffsetFromLocal(instant);\n        instant -= offset;\n        if (offset != zone.getOffset(instant)) {\n            throw new IllegalArgumentException\n                (\"Illegal instant due to time zone offset transition: \" +\n                    DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instant)));\n        }\n        return instant;\n    }\n","new_comment_raw":"@param localInstant the instant from 1970-01-01T00:00:00 local time","old_comment_raw":"@param instant instant from 1970-01-01T00:00:00 local time","label":1,"pre_label":0,"AST_level":7,"line_counts":10,"new_code_token_num":54},{"new_code_raw":"public boolean searchText(String text) { boolean found = searcher.searchWithTimeoutFor(TextView.class, search, 0, true); return found; }","old_code_raw":"\tpublic boolean searchText(String regex) {\n\t\tboolean found = searcher.searchWithTimeoutFor(TextView.class, regex, 0, true);\n\t\treturn found;\n\t}\n","new_comment_raw":"@param text the text to search for. The parameter will be interpreted as a regular expression","old_comment_raw":"@param regex the text to search for. The parameter will be interpreted as a regular expression.","label":1,"pre_label":0,"AST_level":7,"line_counts":5,"new_code_token_num":27},{"new_code_raw":"public Object nullSafeGet(ResultSet rs, String name, SharedSessionContractImplementor session, Object owner) throws SQLException { return nullSafeGet( rs, new String[] { name }, session, owner ); }","old_code_raw":"\tpublic Object nullSafeGet(ResultSet rs, String name, SessionImplementor session, Object owner) throws SQLException {\n\t\treturn nullSafeGet( rs, new String[] { name }, session, owner );\n\t}\n","new_comment_raw":"@param session The session from which the request is originating.","old_comment_raw":"@param session The session from which the request is originating.","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":38},{"new_code_raw":"public CodegenModel fromModel(String name, Schema model, Map<String, Schema> allDefinitions) { CodegenModel codegenModel = super.fromModel(name, model, allDefinitions); return codegenModel; }","old_code_raw":"    public CodegenModel fromModel(String name, Model model, Map<String, Model> allDefinitions) {\n        CodegenModel codegenModel = super.fromModel(name, model, allDefinitions);\n        return codegenModel;\n    }\n","new_comment_raw":"@param allDefinitions a map of all OpenAPI models from the spec","old_comment_raw":"@param allDefinitions a map of all Swagger models from the spec","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":33},{"new_code_raw":"public List<String> dependencyPathBetween(int start, int end) { \/\/ Get paths from a node to the root of the sentence LinkedList<Integer> rootToStart = new LinkedList<>(); LinkedList<Integer> rootToEnd = new LinkedList<>(); int startAncestor = start; while (sentence.governor(startAncestor).isPresent() && sentence.governor(startAncestor).get() >= 0) { rootToStart.addFirst(startAncestor); startAncestor = sentence.governor(startAncestor).get(); } if (startAncestor == -1) { rootToStart.addFirst(-1); } int endAncestor = start; while (sentence.governor(endAncestor).isPresent() && sentence.governor(endAncestor).get() >= 0) { rootToEnd.addFirst(endAncestor); endAncestor = sentence.governor(endAncestor).get(); } if (endAncestor == -1) { rootToEnd.addFirst(-1); } \/\/ Get least common node return null; \/\/ TODO(gabor) write me! }","old_code_raw":"  public List<String> dependencyPathBetween(int start, int end, Function<Sentence, List<String>> selector) {\n    \/\/ Get paths from a node to the root of the sentence\n    LinkedList<Integer> rootToStart = new LinkedList<>();\n    LinkedList<Integer> rootToEnd = new LinkedList<>();\n    int startAncestor = start;\n    List<Optional<Integer>> governors = sentence.governors();\n    Set<Integer> seenVertices = new HashSet<>();\n    while (startAncestor >= 0 && governors.get(startAncestor).isPresent()) {\n      if (seenVertices.contains(startAncestor)) {\n        return Collections.EMPTY_LIST;\n      }\n      seenVertices.add(startAncestor);\n      rootToStart.addFirst(startAncestor);\n      startAncestor = governors.get(startAncestor).get();\n    }\n    if (startAncestor == -1) {\n      rootToStart.addFirst(-1);\n    }\n    int endAncestor = end;\n    seenVertices.clear();\n    while (endAncestor >= 0 && governors.get(endAncestor).isPresent()) {\n      if (seenVertices.contains(endAncestor)) {\n        return Collections.EMPTY_LIST;\n      }\n      seenVertices.add(endAncestor);\n      rootToEnd.addFirst(endAncestor);\n      endAncestor = governors.get(endAncestor).get();\n    }\n    if (endAncestor == -1) {\n      rootToEnd.addFirst(-1);\n    }\n\n    \/\/ Get least common node\n    int leastCommonNodeIndex = (rootToStart.size() == 0 || rootToEnd.size() == 0 || !rootToStart.get(0).equals(rootToEnd.get(0))) ? -1 : 0;\n    for (int i = 1; i < Math.min(rootToStart.size(), rootToEnd.size()); ++i) {\n      if (rootToStart.get(i).equals(rootToEnd.get(i))) {\n        leastCommonNodeIndex = i;\n      }\n    }\n\n    \/\/ Construct the path\n    if (leastCommonNodeIndex < 0) {\n      return Collections.EMPTY_LIST;\n    }\n    List<String> path = new ArrayList<>();\n    for (int i = rootToStart.size() - 1; i > leastCommonNodeIndex; --i) {\n      path.add(selector.apply(sentence).get(rootToStart.get(i)));\n      path.add(\"<-\" + sentence.incomingDependencyLabel(rootToStart.get(i)).orElse(\"dep\") + \"-\");\n    }\n    path.add(selector.apply(sentence).get(rootToStart.get(leastCommonNodeIndex)));\n    for (int i = leastCommonNodeIndex + 1; i < rootToEnd.size(); ++i) {\n      path.add(\"-\" + sentence.incomingDependencyLabel(rootToEnd.get(i)).orElse(\"dep\") + \"->\");\n      path.add(selector.apply(sentence).get(rootToEnd.get(i)));\n    }\n    return path;\n  }\n","new_comment_raw":"@param  The type of the element we are getting.","old_comment_raw":"@param The type of the element we are getting.","label":0,"pre_label":1,"AST_level":8,"line_counts":27,"new_code_token_num":178},{"new_code_raw":"public static Path relativize(Path baseDir, Path childPath) { Path fullPathWithoutSchemeAndAuthority = Path.getPathWithoutSchemeAndAuthority(childPath); Path basePathWithoutSchemeAndAuthority = Path.getPathWithoutSchemeAndAuthority(baseDir); \/\/ Since hadoop Path hasn't relativize() we use uri.relativize() to get relative path Path relativeFilePath = new Path(basePathWithoutSchemeAndAuthority.toUri() .relativize(fullPathWithoutSchemeAndAuthority.toUri())); if (relativeFilePath.isAbsolute()) { throw new IllegalStateException(String.format(\"Path %s is not a subpath of %s.\", basePathWithoutSchemeAndAuthority.toUri().getPath(), fullPathWithoutSchemeAndAuthority.toUri().getPath())); } return relativeFilePath; }","old_code_raw":"  public static String relativize(String baseDir, String childPath) {\n    Path fullPathWithoutSchemeAndAuthority = Path.getPathWithoutSchemeAndAuthority(new Path(childPath));\n    Path basePathWithoutSchemeAndAuthority = Path.getPathWithoutSchemeAndAuthority(new Path(baseDir));\n\n    \/\/ Since hadoop Path hasn't relativize() we use uri.relativize() to get relative path\n    Path relativeFilePath = new Path(basePathWithoutSchemeAndAuthority.toUri()\n        .relativize(fullPathWithoutSchemeAndAuthority.toUri()));\n    if (relativeFilePath.isAbsolute()) {\n      throw new IllegalStateException(String.format(\"Path %s is not a subpath of %s.\",\n          basePathWithoutSchemeAndAuthority.toUri().getPath(), fullPathWithoutSchemeAndAuthority.toUri().getPath()));\n    }\n    return relativeFilePath.toUri().getPath();\n  }\n","new_comment_raw":"@param childPath full absolute path","old_comment_raw":"@param childPath full absolute path","label":0,"pre_label":1,"AST_level":9,"line_counts":14,"new_code_token_num":118},{"new_code_raw":"public Boolean fakeOuterBooleanSerialize(Boolean booleanPostBody) throws ApiException { Object localVarPostBody = booleanPostBody; \/\/ create path and map variables String localVarPath = \"\/fake\/outer\/boolean\".replaceAll(\"\\\\{format\\\\}\",\"json\"); \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { \"*\/*\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {}; return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public Boolean fakeOuterBooleanSerialize(Boolean body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/fake\/outer\/boolean\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@param booleanPostBody Input boolean as post body (optional)","old_comment_raw":"@param body Input boolean as post body (optional)","label":1,"pre_label":0,"AST_level":8,"line_counts":30,"new_code_token_num":176},{"new_code_raw":"public Call buildCall(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException { Request request = buildRequest(path, method, queryParams, collectionQueryParams, body, headerParams, formParams, authNames, callback); return httpClient.newCall(request); }","old_code_raw":"    public Call buildCall(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {\n        Request request = buildRequest(path, method, queryParams, collectionQueryParams, body, headerParams, formParams, authNames, progressRequestListener);\n\n        return httpClient.newCall(request);\n    }\n","new_comment_raw":"@param body The request body object","old_comment_raw":"@param body The request body object","label":0,"pre_label":1,"AST_level":6,"line_counts":6,"new_code_token_num":75},{"new_code_raw":"public WebElement augment(RemoteWebElement element) { \/\/ TODO(simon): We should really add a \"SelfDescribing\" interface for this RemoteWebDriver parent = (RemoteWebDriver) element.getWrappedDriver(); if (parent == null) { return element; } Map<String, AugmenterProvider> augmentors = elementAugmentors; CompoundHandler handler = determineAugmentation(parent, augmentors); RemoteWebElement remote = create(handler, element); remote.setId(element.getId()); remote.setParent(parent); return remote; }","old_code_raw":"  public WebDriver augment(WebDriver driver) {\n    \/\/ TODO(simon): We should really add a \"SelfDescribing\" interface for this\n    if (!(driver instanceof RemoteWebDriver)) {\n      return driver;\n    }\n\n    Map<String, ?> capabilities = ((RemoteWebDriver) driver).getCapabilities().asMap();\n\n    CompoundHandler handler = new CompoundHandler((RemoteWebDriver) driver);\n\n    for (Map.Entry<String, ?> capablityName : capabilities.entrySet()) {\n      AugmenterProvider augmenter = augmentors.get(capablityName.getKey());\n      if (augmenter == null) {\n        continue;\n      }\n\n      Object value = capablityName.getValue();\n      if (value instanceof Boolean && !((Boolean) value).booleanValue()) {\n        continue;\n      }\n\n      handler.addCapabilityHander(augmenter.getDescribedInterface(),\n          augmenter.getImplementation(value));\n    }\n\n    if (handler.isNeedingApplication()) {\n      \/\/ Gather the existing interfaces\n      Set<Class<?>> interfaces = new HashSet<Class<?>>();\n      interfaces.addAll(handler.getInterfaces());\n      interfaces.addAll(getInterfacesFrom(driver.getClass()));\n\n      Enhancer enhancer = new Enhancer();\n      enhancer.setInterfaces(interfaces.toArray(new Class<?>[interfaces.size()]));\n      enhancer.setCallback(handler);\n      enhancer.setSuperclass(driver.getClass());\n\n      RemoteWebDriver remote = (RemoteWebDriver) enhancer.create();\n      remote.setCommandExecutor(((RemoteWebDriver) driver).getCommandExecutor());\n      remote.setElementConverter(((RemoteWebDriver) driver).getElementConverter());\n      return remote;\n    }\n\n    return driver;\n  }\n","new_comment_raw":"@param element The driver to enhance.","old_comment_raw":"@param driver The driver to enhance","label":1,"pre_label":0,"AST_level":6,"line_counts":17,"new_code_token_num":90},{"new_code_raw":"private ColumnState buildUnionList(ContainerState parent, ColumnReadProjection colProj) { ColumnMetadata columnSchema = colProj.providedSchema(); \/\/ The variant must start out empty. assert columnSchema.variantSchema().size() == 0; \/\/ Create the union writer, bound to an empty list shim. final UnionWriterImpl unionWriter = new UnionWriterImpl(columnSchema); unionWriter.bindShim(new EmptyListShim()); final VariantObjectWriter unionObjWriter = new VariantObjectWriter(unionWriter); \/\/ Create the list vector. Starts with the default (dummy) data \/\/ vector which corresponds to the empty union shim above. \/\/ Don't get the list vector from the vector cache. List vectors may \/\/ have content that varies from batch to batch. Only the leaf \/\/ vectors can be cached. final ListVector listVector = new ListVector(columnSchema.schema(), parent.loader().allocator(), null); \/\/ Create the list vector state that tracks the list vector lifecycle. final ListVectorState vectorState = new ListVectorState(unionWriter, listVector); \/\/ Create the list writer: an array of unions. final AbstractObjectWriter listWriter = new ArrayObjectWriter( new ListWriterImpl(columnSchema, listVector, unionObjWriter)); \/\/ Create the manager for the columns within the list (which may or \/\/ may not be grouped into a union.) final ListState listState = new ListState(parent.loader(), parent.vectorCache().childCache(columnSchema.name())); \/\/ Bind the union state to the union writer to handle column additions. unionWriter.bindListener(listState); \/\/ Assemble it all into a union column state. return new UnionColumnState(parent.loader(), listWriter, vectorState, listState); }","old_code_raw":"  private ColumnState buildUnionList(ContainerState parent, ColumnTransform outputCol) {\n    ColumnMetadata columnSchema = outputCol.outputSchema();\n\n    \/\/ The variant must start out empty.\n\n    assert columnSchema.variantSchema().size() == 0;\n\n    \/\/ Create the union writer, bound to an empty list shim.\n\n    final UnionWriterImpl unionWriter = new UnionWriterImpl(columnSchema);\n    unionWriter.bindShim(new EmptyListShim());\n    final VariantObjectWriter unionObjWriter = new VariantObjectWriter(unionWriter);\n\n    \/\/ Create the list vector. Starts with the default (dummy) data\n    \/\/ vector which corresponds to the empty union shim above.\n    \/\/ Don't get the list vector from the vector cache. List vectors may\n    \/\/ have content that varies from batch to batch. Only the leaf\n    \/\/ vectors can be cached.\n\n    final ListVector listVector = new ListVector(columnSchema.schema(),\n        parent.loader().allocator(), null);\n\n    \/\/ Create the list vector state that tracks the list vector lifecycle.\n\n    final ListVectorState vectorState = new ListVectorState(unionWriter, listVector);\n\n    \/\/ Create the list writer: an array of unions.\n\n    final AbstractObjectWriter listWriter = new ArrayObjectWriter(\n        new ListWriterImpl(columnSchema, listVector, unionObjWriter));\n\n    \/\/ Create the manager for the columns within the list (which may or\n    \/\/ may not be grouped into a union.)\n\n    final ListState listState = new ListState(parent.loader(),\n        parent.vectorCache().childCache(columnSchema.name()),\n        ImpliedTupleRequest.ALL_MEMBERS);\n\n    \/\/ Bind the union state to the union writer to handle column additions.\n\n    unionWriter.bindListener(listState);\n\n    \/\/ Assemble it all into a union column state.\n\n    return new UnionColumnState(parent.loader(),\n        listWriter, vectorState, listState);\n  }\n","new_comment_raw":"@param columnSchema metadata description of the list (must be empty of subtypes)","old_comment_raw":"@param columnSchema metadata description of the list (must be empty of subtypes)","label":0,"pre_label":1,"AST_level":8,"line_counts":47,"new_code_token_num":306},{"new_code_raw":"public int create(Object[] row, Instant ts) throws InterruptedException { return create(row, ts, 0, 1); }","old_code_raw":"        public int create(Object[] row, long ts) throws InterruptedException {\n            return create(row, ts, 0, 1);\n        }\n","new_comment_raw":"@param row the values of the row, in the same order as the columns in the  Table definition in the  MySqlSchema.","old_comment_raw":"@param row the values of the row, in the same order as the columns in the Table definition in the MySqlSchema.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":28},{"new_code_raw":"public boolean add(E o) { return super.add(o); }","old_code_raw":"    public boolean add(E e) {\n        return offer(e);\n    }\n","new_comment_raw":"@param o the element to add","old_comment_raw":"@param e the element to add","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":16},{"new_code_raw":"public SeleneseCommand handleCommandResult(String commandResult, FrameAddress incomingFrameAddress, String uniqueId) { SeleneseQueue queue; if (!SeleniumServer.isProxyInjectionMode()) { queue = getSeleneseQueue(); } else { if (incomingFrameAddress.getWindowName().equals(SELENIUM_WINDOW_NAME_UNKNOWN_POPUP)) { boolean foundFrameAddressOfUnknownPopup = false; for (FrameAddress knownFrameAddress : frameAddressToSeleneseQueue.keySet()) { \/\/ the situation being handled here: a pop-up window has either just loaded or reloaded, and therefore \/\/ doesn't know its name. It uses SELENIUM_WINDOW_NAME_UNKNOWN_POPUP as a placeholder. \/\/ Meanwhile, on the selenium server-side, a thread is waiting for this result. \/\/ \/\/ To determine if this has happened, we cycle through all of the SeleneseQueue objects, \/\/ looking for ones with a matching local frame address (e.g., top.frames[1]), is also a \/\/ pop-up, and which has a thread waiting on a result. If all of these conditions hold, \/\/ then we figure this queue is the one that we want: if (knownFrameAddress.getLocalFrameAddress().equals(incomingFrameAddress.getLocalFrameAddress()) && !knownFrameAddress.getWindowName().equals(DEFAULT_SELENIUM_WINDOW_NAME) && frameAddressToSeleneseQueue.get(knownFrameAddress).getCommandResultHolder().hasBlockedGetter()) { incomingFrameAddress = knownFrameAddress; foundFrameAddressOfUnknownPopup = true; break; } } if (!foundFrameAddressOfUnknownPopup) { SeleniumServer.log(\"WARNING: unknown popup \" + incomingFrameAddress + \" was not resolved\"); } } queue = getSeleneseQueue(incomingFrameAddress); } queue.setUniqueId(uniqueId); return queue.handleCommandResult(commandResult); }","old_code_raw":"    public SeleneseCommand handleCommandResult(String commandResult, FrameAddress frameAddress, String uniqueId) {\n        SeleneseQueue queue;\n        if (!SeleniumServer.isProxyInjectionMode()) {\n            queue = getSeleneseQueue();\n        }\n        else {\n            if (frameAddress.getWindowName().equals(SELENIUM_WINDOW_NAME_UNKNOWN_POPUP)) {\n                boolean foundFrameAddressOfUnknownPopup = false;\n                for (FrameAddress f : frameAddressToSeleneseQueue.keySet()) {\n                    \/\/ the situation being handled here: a pop-up window has either just loaded or reloaded, and therefore\n                    \/\/ doesn't know its name.  It uses SELENIUM_WINDOW_NAME_UNKNOWN_POPUP as a placeholder.\n                    \/\/ Meanwhile, on the selenium server-side, a thread is waiting for this result.\n                    \/\/\n                    \/\/ To determine if this has happened, we cycle through all of the SeleneseQueue objects,\n                    \/\/ looking for ones with a matching local frame address (e.g., top.frames[1]), is also a\n                    \/\/ pop-up, and which has a thread waiting on a result.  If all of these conditions hold,\n                    \/\/ then we figure this queue is the one that we want:\n                    if (f.getLocalFrameAddress().equals(frameAddress.getLocalFrameAddress())\n                            && !f.getWindowName().equals(DEFAULT_SELENIUM_WINDOW_NAME)\n                            && frameAddressToSeleneseQueue.get(f).getCommandResultHolder().hasBlockedGetter()) {\n                        frameAddress = f;\n                        foundFrameAddressOfUnknownPopup = true;\n                        break;\n                    }\n                }\n                if (!foundFrameAddressOfUnknownPopup) {\n                    SeleniumServer.log(\"WARNING: unknown popup \" + frameAddress + \" was not resolved\");\n                }\n            }\n            queue = getSeleneseQueue(frameAddress);\n        }\n        queue.setUniqueId(uniqueId);\n        return queue.handleCommandResult(commandResult);\n    }\n","new_comment_raw":"@param incomingFrameAddress - frame from which the reply came","old_comment_raw":"@param frameAddress - frame from which the reply came","label":1,"pre_label":0,"AST_level":14,"line_counts":35,"new_code_token_num":293},{"new_code_raw":"public static Point getCanvasTextLocation(Client client, Graphics2D graphics, LocalPoint localLocation, String text, int zOffset) { int plane = client.getPlane(); Point p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset); if (p == null) { return null; } FontMetrics fm = graphics.getFontMetrics(); Rectangle2D bounds = fm.getStringBounds(text, graphics); int xOffset = p.getX() - (int) (bounds.getWidth() \/ 2); return new Point(xOffset, p.getY()); }","old_code_raw":"\tpublic static Point getCanvasTextLocation(Client client, Graphics2D graphics, Point localLocation, String text, int zOffset)\n\t{\n\t\tint plane = client.getPlane();\n\n\t\tPoint p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset);\n\n\t\tif (p == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tFontMetrics fm = graphics.getFontMetrics();\n\t\tRectangle2D bounds = fm.getStringBounds(text, graphics);\n\t\tint xOffset = p.getX() - (int) (bounds.getWidth() \/ 2);\n\n\t\treturn new Point(xOffset, p.getY());\n\t}\n","new_comment_raw":"@param graphics","old_comment_raw":"@param graphics","label":0,"pre_label":1,"AST_level":8,"line_counts":18,"new_code_token_num":109},{"new_code_raw":"public boolean get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }","old_code_raw":"    public boolean get(WithAttributes attributes) {\r\n        return attributes.getAttributes().get(this);\r\n    }\r\n","new_comment_raw":"@param withAttributes an object containing an AttributeMap","old_comment_raw":"@param attributes an object containing an AttributeMap","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":19},{"new_code_raw":"private SQLResponse execute(String correctedSql, SQLRequest sqlRequest) throws Exception { Connection conn = null; Statement stat = null; ResultSet resultSet = null; Boolean isPushDown = false; List<List<String>> results = Lists.newArrayList(); List<SelectedColumnMeta> columnMetas = Lists.newArrayList(); try { conn = cacheService.getOLAPDataSource(sqlRequest.getProject()).getConnection(); \/\/ special case for prepare query. if (BackdoorToggles.getPrepareOnly()) { return getPrepareOnlySqlResponse(correctedSql, conn, isPushDown, results, columnMetas); } stat = conn.createStatement(); processStatementAttr(stat, sqlRequest); resultSet = stat.executeQuery(correctedSql); ResultSetMetaData metaData = resultSet.getMetaData(); int columnCount = metaData.getColumnCount(); \/\/ Fill in selected column meta for (int i = 1; i <= columnCount; ++i) { columnMetas.add(new SelectedColumnMeta(metaData.isAutoIncrement(i), metaData.isCaseSensitive(i), metaData.isSearchable(i), metaData.isCurrency(i), metaData.isNullable(i), metaData.isSigned(i), metaData.getColumnDisplaySize(i), metaData.getColumnLabel(i), metaData.getColumnName(i), metaData.getSchemaName(i), metaData.getCatalogName(i), metaData.getTableName(i), metaData.getPrecision(i), metaData.getScale(i), metaData.getColumnType(i), metaData.getColumnTypeName(i), metaData.isReadOnly(i), metaData.isWritable(i), metaData.isDefinitelyWritable(i))); } \/\/ fill in results while (resultSet.next()) { List<String> oneRow = Lists.newArrayListWithCapacity(columnCount); for (int i = 0; i < columnCount; i++) { oneRow.add((resultSet.getString(i + 1))); } results.add(oneRow); } } catch (SQLException sqlException) { isPushDown = PushDownUtil.doPushDownQuery(sqlRequest.getProject(), correctedSql, results, columnMetas, sqlException); } finally { close(resultSet, stat, conn); } return getSqlResponse(isPushDown, results, columnMetas); }","old_code_raw":"    private SQLResponse execute(String correctedSql, SQLRequest sqlRequest, Connection conn) throws Exception {\n        Statement stat = null;\n        ResultSet resultSet = null;\n        Boolean isPushDown = false;\n\n        List<List<String>> results = Lists.newArrayList();\n        List<SelectedColumnMeta> columnMetas = Lists.newArrayList();\n\n        try {\n\n            \/\/ special case for prepare query. \n            if (BackdoorToggles.getPrepareOnly()) {\n                return getPrepareOnlySqlResponse(correctedSql, conn, isPushDown, results, columnMetas);\n            }\n\n            stat = conn.createStatement();\n            processStatementAttr(stat, sqlRequest);\n            resultSet = stat.executeQuery(correctedSql);\n\n            ResultSetMetaData metaData = resultSet.getMetaData();\n            int columnCount = metaData.getColumnCount();\n\n            \/\/ Fill in selected column meta\n            for (int i = 1; i <= columnCount; ++i) {\n                columnMetas.add(new SelectedColumnMeta(metaData.isAutoIncrement(i), metaData.isCaseSensitive(i),\n                        metaData.isSearchable(i), metaData.isCurrency(i), metaData.isNullable(i), metaData.isSigned(i),\n                        metaData.getColumnDisplaySize(i), metaData.getColumnLabel(i), metaData.getColumnName(i),\n                        metaData.getSchemaName(i), metaData.getCatalogName(i), metaData.getTableName(i),\n                        metaData.getPrecision(i), metaData.getScale(i), metaData.getColumnType(i),\n                        metaData.getColumnTypeName(i), metaData.isReadOnly(i), metaData.isWritable(i),\n                        metaData.isDefinitelyWritable(i)));\n            }\n\n            \/\/ fill in results\n            while (resultSet.next()) {\n                List<String> oneRow = Lists.newArrayListWithCapacity(columnCount);\n                for (int i = 0; i < columnCount; i++) {\n                    oneRow.add((resultSet.getString(i + 1)));\n                }\n\n                results.add(oneRow);\n            }\n        } catch (SQLException sqlException) {\n            isPushDown = PushDownUtil.doPushDownQuery(sqlRequest.getProject(), correctedSql, conn.getSchema(), results,\n                    columnMetas, sqlException);\n            if (!isPushDown) {\n                throw sqlException;\n            }\n        } finally {\n            close(resultSet, stat, null);\/\/conn is passed in, not my duty to close\n        }\n\n        return getSqlResponse(isPushDown, results, columnMetas);\n    }\n","new_comment_raw":"@param sqlRequest","old_comment_raw":"@param sqlRequest","label":0,"pre_label":1,"AST_level":12,"line_counts":54,"new_code_token_num":376},{"new_code_raw":"protected InstrumentedClientConnManager createConnectionManager(SchemeRegistry registry, String name) { final long ttl = configuration.getTimeToLive().toMilliseconds(); final InstrumentedClientConnManager manager = new InstrumentedClientConnManager(metricRegistry, registry, ttl, TimeUnit.MILLISECONDS, resolver, name); manager.setDefaultMaxPerRoute(configuration.getMaxConnectionsPerRoute()); manager.setMaxTotal(configuration.getMaxConnections()); return manager; }","old_code_raw":"    protected InstrumentedClientConnManager createConnectionManager(SchemeRegistry registry) {\n        final long ttl = configuration.getTimeToLive().toMilliseconds();\n        final InstrumentedClientConnManager manager =\n                new InstrumentedClientConnManager(Metrics.defaultRegistry(),\n                                                  registry,\n                                                  ttl,\n                                                  TimeUnit.MILLISECONDS,\n                                                  resolver);\n        manager.setDefaultMaxPerRoute(configuration.getMaxConnectionsPerRoute());\n        manager.setMaxTotal(configuration.getMaxConnections());\n        return manager;\n    }\n","new_comment_raw":"@param registry the SchemeRegistry","old_comment_raw":"@param registry the SchemeRegistry","label":0,"pre_label":1,"AST_level":6,"line_counts":14,"new_code_token_num":64},{"new_code_raw":"public Action suspended(AtmosphereRequest request, AtmosphereResponse response) throws IOException, ServletException { return action(request, response); }","old_code_raw":"    public Action suspended(HttpServletRequest request, HttpServletResponse response)\n            throws IOException, ServletException {\n        return action(request, response);\n    }\n","new_comment_raw":"@param request the  AtmosphereRequest","old_comment_raw":"@param request the HttpServletRequest","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":24},{"new_code_raw":"private boolean isKeepLock(String lockClient, String lockPath) { try { if (zkClient.checkExists().forPath(lockPath) != null) { byte[] data = zkClient.getData().forPath(lockPath); String lockServerName = new String(data, Charset.forName(\"UTF-8\")); return lockServerName.equalsIgnoreCase(lockClient); } } catch (Exception e) { logger.error(\"fail to get the lockClient for the path: \" + lockPath, e); } return false; }","old_code_raw":"\n    private boolean isKeepLock(String serverName, String lockPath) {\n        try {\n            if (zkClient.checkExists().forPath(lockPath) != null) {\n                byte[] data = zkClient.getData().forPath(lockPath);\n                String lockServerName = new String(data, Charset.forName(\"UTF-8\"));\n                return lockServerName.equalsIgnoreCase(serverName);\n            }\n        } catch (Exception e) {\n            logger.error(\"fail to get the serverName for the path: \" + lockPath, e);\n        }\n        return false;\n    }\n","new_comment_raw":"@param lockClient the mark of client","old_comment_raw":"@param serverName the hostname of job server","label":1,"pre_label":0,"AST_level":10,"line_counts":15,"new_code_token_num":98},{"new_code_raw":"private double[] makeDatumUsingEmbedding(List<IN> info, int loc, FeatureFactory<IN> featureFactory, PaddedList<IN> pInfo, List<String> featuresC, List<Clique> windowCliques) { double[] featureValArr; List<double[]> embeddingList = new ArrayList<double[]>(); int concatEmbeddingLen = 0; String currentWord = null; for (int currLoc = loc-2; currLoc <= loc+2; currLoc++) { double[] embedding = null; if (currLoc >=0 && currLoc < info.size()) { currentWord = info.get(loc).get(CoreAnnotations.TextAnnotation.class); String word = currentWord.toLowerCase(); word = word.replaceAll(\"(-)?\\\\d+(\\\\.\\\\d*)?\", \"0\"); if (embeddings.containsKey(word)) embedding = embeddings.get(word); else embedding = embeddings.get(\"UNKNOWN\"); } else { embedding = embeddings.get(\"PADDING\"); } for (int e = 0; e < embedding.length; e++) { featuresC.add(\"EMBEDDING-(\" + (currLoc-loc) + \")-\" + e); } if (flags.addCapitalFeatures) { int numOfCapitalFeatures = 4; double[] newEmbedding = new double[embedding.length + numOfCapitalFeatures]; int currLen = embedding.length; System.arraycopy(embedding, 0, newEmbedding, 0, currLen); for (int e = 0; e < numOfCapitalFeatures; e++) featuresC.add(\"CAPITAL-(\" + (currLoc-loc) + \")-\" + e); if (currLoc >=0 && currLoc < info.size()) { \/\/ skip PADDING \/\/ check if word is all caps if (currentWord.toUpperCase().equals(currentWord)) newEmbedding[currLen] = 1; else { currLen += 1; \/\/ check if word is all lower if (currentWord.toLowerCase().equals(currentWord)) newEmbedding[currLen] = 1; else { currLen += 1; \/\/ check first letter cap if (Character.isUpperCase(currentWord.charAt(0))) newEmbedding[currLen] = 1; else { currLen += 1; \/\/ check if at least one non-initial letter is cap String remainder = currentWord.substring(1); if (!remainder.toLowerCase().equals(remainder)) newEmbedding[currLen] = 1; } } } } embedding = newEmbedding; } embeddingList.add(embedding); concatEmbeddingLen += embedding.length; } double[] concatEmbedding = new double[concatEmbeddingLen]; int currPos = 0; for (double[] em: embeddingList) { System.arraycopy(em, 0, concatEmbedding, currPos, em.length); currPos += em.length; } if (flags.prependEmbedding) { int additionalFeatureCount = 0; for (Clique c : windowCliques) { Collection<String> fCol = featureFactory.getCliqueFeatures(pInfo, loc, c); \/\/todo useless copy because of typing reasons featuresC.addAll(fCol); additionalFeatureCount += fCol.size(); } featureValArr = new double[concatEmbedding.length + additionalFeatureCount]; System.arraycopy(concatEmbedding, 0, featureValArr, 0, concatEmbedding.length); Arrays.fill(featureValArr, concatEmbedding.length, featureValArr.length, 1.0); } else { featureValArr = concatEmbedding; } if (flags.addBiasToEmbedding) { featuresC.add(\"BIAS-FEATURE\"); double[] newFeatureValArr = new double[featureValArr.length + 1]; System.arraycopy(featureValArr, 0, newFeatureValArr, 0, featureValArr.length); newFeatureValArr[newFeatureValArr.length-1] = 1; featureValArr = newFeatureValArr; } return featureValArr; }","old_code_raw":"  private double[] makeDatumUsingEmbedding(List<IN> info, int loc, List<FeatureFactory<IN>> featureFactories, PaddedList<IN> pInfo, List<String> featuresC, List<Clique> windowCliques) {\n    double[] featureValArr;\n    List<double[]> embeddingList = new ArrayList<double[]>();\n    int concatEmbeddingLen = 0;\n    String currentWord = null;\n    for (int currLoc = loc-2; currLoc <= loc+2; currLoc++) {\n      double[] embedding = null;\n      if (currLoc >=0 && currLoc < info.size()) {\n        currentWord = info.get(loc).get(CoreAnnotations.TextAnnotation.class);\n        String word = currentWord.toLowerCase();\n        word = word.replaceAll(\"(-)?\\\\d+(\\\\.\\\\d*)?\", \"0\");\n        if (embeddings.containsKey(word))\n          embedding = embeddings.get(word);\n        else\n          embedding = embeddings.get(\"UNKNOWN\");\n      } else {\n        embedding = embeddings.get(\"PADDING\");\n      }\n\n      for (int e = 0; e < embedding.length; e++) {\n        featuresC.add(\"EMBEDDING-(\" + (currLoc-loc) + \")-\" + e);\n      }\n\n      if (flags.addCapitalFeatures) {\n        int numOfCapitalFeatures = 4;\n        double[] newEmbedding = new double[embedding.length + numOfCapitalFeatures];\n        int currLen = embedding.length;\n        System.arraycopy(embedding, 0, newEmbedding, 0, currLen);\n        for (int e = 0; e < numOfCapitalFeatures; e++)\n          featuresC.add(\"CAPITAL-(\" + (currLoc-loc) + \")-\" + e);\n\n        if (currLoc >=0 && currLoc < info.size()) { \/\/ skip PADDING\n          \/\/ check if word is all caps\n          if (currentWord.toUpperCase().equals(currentWord))\n            newEmbedding[currLen] = 1;\n          else {\n            currLen += 1;\n            \/\/ check if word is all lower\n            if (currentWord.toLowerCase().equals(currentWord))\n              newEmbedding[currLen] = 1;\n            else {\n              currLen += 1;\n              \/\/ check first letter cap\n              if (Character.isUpperCase(currentWord.charAt(0)))\n                newEmbedding[currLen] = 1;\n              else {\n                currLen += 1;\n                \/\/ check if at least one non-initial letter is cap\n                String remainder = currentWord.substring(1);\n                if (!remainder.toLowerCase().equals(remainder))\n                  newEmbedding[currLen] = 1;\n              }\n            }\n          }\n        }\n        embedding = newEmbedding;\n      }\n\n      embeddingList.add(embedding);\n      concatEmbeddingLen += embedding.length;\n    }\n    double[] concatEmbedding = new double[concatEmbeddingLen];\n    int currPos = 0;\n    for (double[] em: embeddingList) {\n      System.arraycopy(em, 0, concatEmbedding, currPos, em.length);\n      currPos += em.length;\n    }\n\n    if (flags.prependEmbedding) {\n      int additionalFeatureCount = 0;\n      for (Clique c : windowCliques) {\n        for (FeatureFactory featureFactory : featureFactories) {\n          Collection<String> fCol = featureFactory.getCliqueFeatures(pInfo, loc, c); \/\/todo useless copy because of typing reasons\n          featuresC.addAll(fCol);\n          additionalFeatureCount += fCol.size();\n        }\n      }\n      featureValArr = new double[concatEmbedding.length + additionalFeatureCount];\n      System.arraycopy(concatEmbedding, 0, featureValArr, 0, concatEmbedding.length);\n      Arrays.fill(featureValArr, concatEmbedding.length, featureValArr.length, 1.0);\n    } else {\n      featureValArr = concatEmbedding;\n    }\n\n    if (flags.addBiasToEmbedding) {\n      featuresC.add(\"BIAS-FEATURE\");\n      double[] newFeatureValArr = new double[featureValArr.length + 1];\n      System.arraycopy(featureValArr, 0, newFeatureValArr, 0, featureValArr.length);\n      newFeatureValArr[newFeatureValArr.length-1] = 1;\n      featureValArr = newFeatureValArr;\n    }\n    return featureValArr;\n  }\n","new_comment_raw":"@param featureFactory The FeatureFactory to use to extract features","old_comment_raw":"@param featureFactories The FeatureFactories to use to extract features","label":1,"pre_label":0,"AST_level":20,"line_counts":92,"new_code_token_num":672},{"new_code_raw":"public Client testClassname(Client client) throws ApiException { Object localVarPostBody = client; \/\/ verify the required parameter 'client' is set if (client == null) { throw new ApiException(400, \"Missing the required parameter 'client' when calling testClassname\"); } \/\/ create path and map variables String localVarPath = \"\/fake_classname_test\".replaceAll(\"\\\\{format\\\\}\",\"json\"); \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { \"application\/json\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { \"application\/json\" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { \"api_key_query\" }; GenericType<Client> localVarReturnType = new GenericType<Client>() {}; return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public Client testClassname(Client body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    \/\/ verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling testClassname\");\n    }\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/fake_classname_test\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application\/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application\/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] { \"api_key_query\" };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@param client client model (required)","old_comment_raw":"@param body client model (required)","label":1,"pre_label":0,"AST_level":8,"line_counts":35,"new_code_token_num":218},{"new_code_raw":"private RectF drawBoxWithShadow(Canvas c, Paint p, int width, int height) { Resources res = mContext.getResources(); float shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur); float keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance); float corner = res.getDimension(R.dimen.widget_preview_corner_radius); RectF bounds = new RectF(shadowBlur, shadowBlur, width - shadowBlur, height - shadowBlur - keyShadowDistance); p.setColor(Color.WHITE); \/\/ Key shadow p.setShadowLayer(shadowBlur, 0, keyShadowDistance, ShadowGenerator.KEY_SHADOW_ALPHA << 24); c.drawRoundRect(bounds, corner, corner, p); \/\/ Ambient shadow p.setShadowLayer(shadowBlur, 0, 0, ColorUtils.setAlphaComponent(Color.BLACK, ShadowGenerator.AMBIENT_SHADOW_ALPHA)); c.drawRoundRect(bounds, corner, corner, p); p.clearShadowLayer(); return bounds; }","old_code_raw":"    private RectF drawBoxWithShadow(Canvas c, int width, int height) {\n        Resources res = mContext.getResources();\n\n        ShadowGenerator.Builder builder = new ShadowGenerator.Builder(Color.WHITE);\n        builder.shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur);\n        builder.radius = res.getDimension(R.dimen.widget_preview_corner_radius);\n        builder.keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance);\n\n        builder.bounds.set(builder.shadowBlur, builder.shadowBlur,\n                width - builder.shadowBlur,\n                height - builder.shadowBlur - builder.keyShadowDistance);\n        builder.drawShadow(c);\n        return builder.bounds;\n    }\n","new_comment_raw":"@param preview bitmap that can be recycled","old_comment_raw":"@param preview bitmap that can be recycled","label":0,"pre_label":1,"AST_level":8,"line_counts":24,"new_code_token_num":156},{"new_code_raw":"public PendingMessageCursor getSubscriberPendingMessageCursor(Broker broker,String clientId, String name,int maxBatchSize, DurableTopicSubscription sub) { return new VMPendingMessageCursor(AbstractPendingMessageCursor.isPrioritizedMessageSubscriber(broker, sub)); }","old_code_raw":"    public PendingMessageCursor getSubscriberPendingMessageCursor(Broker broker,String clientId, String name,int maxBatchSize, Subscription sub) {\n        return new VMPendingMessageCursor(AbstractPendingMessageCursor.isPrioritizedMessageSubscriber(broker, sub));\n    }\n","new_comment_raw":"@param sub","old_comment_raw":"@param sub","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":34},{"new_code_raw":"public Client call123testSpecialTags(Client body) throws ApiException { Object localVarPostBody = body; \/\/ verify the required parameter 'body' is set if (body == null) { throw new ApiException(400, \"Missing the required parameter 'body' when calling call123testSpecialTags\"); } \/\/ create path and map variables String localVarPath = \"\/another-fake\/dummy\".replaceAll(\"\\\\{format\\\\}\",\"json\"); \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { \"application\/json\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { \"application\/json\" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Client> localVarReturnType = new GenericType<Client>() {}; return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public Client call123testSpecialTags(Client client) throws ApiException {\n    Object localVarPostBody = client;\n    \n    \/\/ verify the required parameter 'client' is set\n    if (client == null) {\n      throw new ApiException(400, \"Missing the required parameter 'client' when calling call123testSpecialTags\");\n    }\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/another-fake\/dummy\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application\/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application\/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@param body client model (required)","old_comment_raw":"@param client client model (required)","label":1,"pre_label":0,"AST_level":8,"line_counts":35,"new_code_token_num":219},{"new_code_raw":"public DateTime withZone(DateTimeZone newZone) { return withChronology(getChronology().withZone(newZone)); }","old_code_raw":"    public DateTime withZone(DateTimeZone newDateTimeZone) {\n        return withChronology(getChronology().withZone(newDateTimeZone));\n    }\n","new_comment_raw":"@param newZone the new time zone","old_comment_raw":"@param newDateTimeZone the new time zone","label":1,"pre_label":0,"AST_level":7,"line_counts":4,"new_code_token_num":21},{"new_code_raw":"public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); final String url = buildUrl(path, queryParams); final Request.Builder reqBuilder = new Request.Builder().url(url); processHeaderParams(headerParams, reqBuilder); String contentType = (String) headerParams.get(\"Content-Type\"); \/\/ ensuring a default content type if (contentType == null) contentType = \"application\/json\"; RequestBody reqBody; if (!HttpMethod.permitsRequestBody(method)) { reqBody = null; } else if (\"application\/x-www-form-urlencoded\".equals(contentType)) { reqBody = buildRequestBodyFormEncoding(formParams); } else if (\"multipart\/form-data\".equals(contentType)) { reqBody = buildRequestBodyMultipart(formParams); } else if (body == null) { if (\"DELETE\".equals(method)) { \/\/ allow calling DELETE without sending a request body reqBody = null; } else { \/\/ use an empty request body (for POST, PUT and PATCH) reqBody = RequestBody.create(MediaType.parse(contentType), \"\"); } } else { reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType)); } Request request = null; if(progressRequestListener != null) { ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, progressRequestListener); request = reqBuilder.method(method, progressRequestBody).build(); } else { request = reqBuilder.method(method, reqBody).build(); } return httpClient.newCall(request); }","old_code_raw":"  public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    final String url = buildUrl(path, queryParams);\n    final Request.Builder reqBuilder = new Request.Builder().url(url);\n    processHeaderParams(headerParams, reqBuilder);\n\n    String contentType = (String) headerParams.get(\"Content-Type\");\n    \/\/ ensuring a default content type\n    if (contentType == null) contentType = \"application\/json\";\n\n    RequestBody reqBody;\n    if (!HttpMethod.permitsRequestBody(method)) {\n      reqBody = null;\n    } else if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n      reqBody = buildRequestBodyFormEncoding(formParams);\n    } else if (\"multipart\/form-data\".equals(contentType)) {\n      reqBody = buildRequestBodyMultipart(formParams);\n    } else if (body == null) {\n      if (\"DELETE\".equals(method)) {\n        \/\/ allow calling DELETE without sending a request body\n        reqBody = null;\n      } else {\n        \/\/ use an empty request body (for POST, PUT and PATCH)\n        reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n      }\n    } else {\n      reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType));\n    }\n\n    Request request = reqBuilder.method(method, reqBody).build();\n    return httpClient.newCall(request);\n  }\n","new_comment_raw":"@param body The request body object","old_comment_raw":"@param body The request body object","label":0,"pre_label":1,"AST_level":14,"line_counts":42,"new_code_token_num":325},{"new_code_raw":"public String applyLocksToSql(String sql, Map aliasedLockOptions, Map keyColumnNames) { return sql + new ForUpdateFragment( this, aliasedLockOptions, keyColumnNames ).toFragmentString(); }","old_code_raw":"\tpublic String applyLocksToSql(String sql, Map aliasedLockModes, Map keyColumnNames) {\n\t\treturn sql + new ForUpdateFragment( this, aliasedLockModes, keyColumnNames ).toFragmentString();\n\t}\n","new_comment_raw":"@param aliasedLockOptions a map of lock options indexed by aliased table names.","old_comment_raw":"@param aliasedLockModes a map of lock modes indexed by aliased table names.","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":31},{"new_code_raw":"public BrowserLauncher getBrowserLauncher(String browser, String sessionId, RemoteControlConfiguration configuration, Capabilities browserOptions) { if (browser == null) { throw new IllegalArgumentException(\"browser may not be null\"); } String executablePath = null; if (BrowserOptions.hasOptionsSet(browserOptions)) { executablePath = BrowserOptions.getExecutablePath(browserOptions); } else { configuration.copySettingsIntoBrowserOptions(browserOptions); } for (String key : supportedBrowsers.keySet()) { final BrowserStringParser.Result result; result = new BrowserStringParser().parseBrowserStartCommand(key, browser); if (result.match()) { if (executablePath == null) { executablePath = result.customLauncher(); browserOptions = BrowserOptions.setExecutablePath(browserOptions, executablePath); } LOGGER.debug(\"Requested browser string '\" + browser + \"' matches *\" + key + \" \"); return createBrowserLauncher(supportedBrowsers.get(key), executablePath, sessionId, configuration, browserOptions); } } LOGGER.debug(\"Requested browser string '\" + browser + \"' does not match any known browser, treating it as a custom browser...\"); Matcher CustomMatcher = CUSTOM_PATTERN.matcher(browser); if (CustomMatcher.find()) { String browserStartCommand = CustomMatcher.group(1); if (browserStartCommand == null) { throw new RuntimeException( \"You must specify the path to an executable when using *custom!\\n\\n\"); } browserStartCommand = browserStartCommand.substring(1); return new CustomBrowserLauncher(browserStartCommand, sessionId, configuration, browserOptions); } throw browserNotSupported(browser); }","old_code_raw":"  public BrowserLauncher getBrowserLauncher(String browser, String sessionId, RemoteControlConfiguration configuration, BrowserConfigurationOptions browserOptions) {\n    if (browser == null) {\n      throw new IllegalArgumentException(\"browser may not be null\");\n    }\n    String executablePath = null;\n    if (browserOptions.hasOptions()) {\n      executablePath = BrowserOptions.getExecutablePath(browserOptions.asCapabilities());\n    } else {\n      configuration.copySettingsIntoBrowserOptions(browserOptions);\n    }\n\n    for (String key : supportedBrowsers.keySet()) {\n      final BrowserStringParser.Result result;\n      result = new BrowserStringParser().parseBrowserStartCommand(key, browser);\n      if (result.match()) {\n        if (executablePath == null) {\n          executablePath = result.customLauncher();\n          browserOptions.setExecutablePath(executablePath);\n        }\n        LOGGER.debug(\"Requested browser string '\" + browser + \"' matches *\" + key + \" \");\n        return createBrowserLauncher(supportedBrowsers.get(key), executablePath, sessionId,\n            configuration, browserOptions);\n      }\n    }\n\n    LOGGER.debug(\"Requested browser string '\" + browser\n                 + \"' does not match any known browser, treating it as a custom browser...\");\n    Matcher CustomMatcher = CUSTOM_PATTERN.matcher(browser);\n    if (CustomMatcher.find()) {\n      String browserStartCommand = CustomMatcher.group(1);\n      if (browserStartCommand == null) {\n        throw new RuntimeException(\n            \"You must specify the path to an executable when using *custom!\\n\\n\");\n      }\n      browserStartCommand = browserStartCommand.substring(1);\n      return new CustomBrowserLauncher(browserStartCommand, sessionId, configuration,\n          browserOptions);\n    }\n    throw browserNotSupported(browser);\n  }\n","new_comment_raw":"@param sessionId the sessionId to launch","old_comment_raw":"@param sessionId the sessionId to launch","label":0,"pre_label":1,"AST_level":13,"line_counts":41,"new_code_token_num":283},{"new_code_raw":"Tuple2<Boolean, String> setFwkMetadata(String name, String sqlExpr, boolean createTable) throws SQLException { if (Boolean.getBoolean(NOAUTO_CREATE_METADATA)) return Tuple2.create(false, null); final SQLSystem sys = getServer().getSQLSystem(); final SQLSyntax syntax = sys.getSyntax(); final SQLDataSource ds = this.getDBSystemRoot().getDataSource(); synchronized (this.getTreeMutex()) { \/\/ don't refresh until after the insert, that way if the refresh triggers an access to \/\/ the metadata name will already be set to value. final boolean shouldRefresh; if (createTable && !this.contains(METADATA_TABLENAME)) { final SQLCreateMoveableTable create = getCreateMetadata(syntax); ds.execute(create.asString(getDBRoot().getName())); shouldRefresh = true; } else { shouldRefresh = false; } final Tuple2<Boolean, String> res; if (createTable || this.contains(METADATA_TABLENAME)) { \/\/ don't use SQLRowValues, cause it means getting the SQLTable and thus calling \/\/ fetchTables(), but setFwkMetadata() might itself be called by fetchTables() \/\/ furthermore SQLRowValues support only rowable tables final List<String> queries = new ArrayList<String>(); final SQLName tableName = new SQLName(this.getBase().getName(), this.getName(), METADATA_TABLENAME); final String where = \" WHERE \" + SQLBase.quoteIdentifier(\"NAME\") + \" = \" + getBase().quoteString(name); queries.add(\"DELETE FROM \" + tableName.quote() + where); final String returning = sys == SQLSystem.POSTGRESQL ? \" RETURNING \" + SQLBase.quoteIdentifier(\"VALUE\") : \"\"; final String ins = syntax.getInsertOne(tableName, Arrays.asList(\"NAME\", \"VALUE\"), getBase().quoteString(name), sqlExpr) + returning; queries.add(ins); final List<? extends ResultSetHandler> handlers; if (returning.length() == 0) { queries.add(\"SELECT \" + SQLBase.quoteIdentifier(\"VALUE\") + \" FROM \" + tableName.quote() + where); handlers = Arrays.asList(null, null, SQLDataSource.SCALAR_HANDLER); } else { handlers = Arrays.asList(null, SQLDataSource.SCALAR_HANDLER); } final List<?> ress = SQLUtils.executeMultiple(getDBSystemRoot(), queries, handlers); res = Tuple2.create(true, (String) ress.get(ress.size() - 1)); } else { res = Tuple2.create(false, null); } if (shouldRefresh) this.fetchTable(METADATA_TABLENAME); return res; } }","old_code_raw":"    boolean setFwkMetadata(String name, String value, boolean createTable) throws SQLException {\r\n        if (Boolean.getBoolean(NOAUTO_CREATE_METADATA))\r\n            return false;\r\n\r\n        synchronized (this.getTreeMutex()) {\r\n            \/\/ don't refresh until after the insert, that way if the refresh triggers an access to\r\n            \/\/ the metadata name will already be set to value.\r\n            final boolean shouldRefresh;\r\n            if (createTable && !this.contains(METADATA_TABLENAME)) {\r\n                final SQLCreateMoveableTable create = getCreateMetadata(getServer().getSQLSystem().getSyntax());\r\n                this.getBase().getDataSource().execute(create.asString(getDBRoot().getName()));\r\n                shouldRefresh = true;\r\n            } else\r\n                shouldRefresh = false;\r\n\r\n            final boolean res;\r\n            if (createTable || this.contains(METADATA_TABLENAME)) {\r\n                \/\/ don't use SQLRowValues, cause it means getting the SQLTable and thus calling\r\n                \/\/ fetchTables(), but setFwkMetadata() might itself be called by fetchTables()\r\n                \/\/ furthermore SQLRowValues support only rowable tables\r\n                final SQLName tableName = new SQLName(this.getBase().getName(), this.getName(), METADATA_TABLENAME);\r\n                final String del = SQLSelect.quote(\"DELETE FROM %i WHERE %i = %s\", tableName, \"NAME\", name);\r\n                final String ins = SQLSelect.quote(\"INSERT INTO %i(%i,%i) VALUES(%s,%s)\", tableName, \"NAME\", \"VALUE\", name, value);\r\n                SQLUtils.executeAtomic(this.getBase().getDataSource(), new SQLFactory<Object>() {\r\n                    public Object create() throws SQLException {\r\n                        getBase().getDataSource().execute(del);\r\n                        getBase().getDataSource().execute(ins);\r\n                        return null;\r\n                    }\r\n                });\r\n                res = true;\r\n            } else\r\n                res = false;\r\n            if (shouldRefresh)\r\n                this.fetchTable(METADATA_TABLENAME);\r\n            return res;\r\n        }\r\n    }\r\n","new_comment_raw":"@param sqlExpr SQL value of the metadata, e.g. \"'ACME, inc'\".","old_comment_raw":"@param value value of the metadata, eg \"ACME, inc\".","label":1,"pre_label":0,"AST_level":15,"line_counts":55,"new_code_token_num":484},{"new_code_raw":"public Client testClientModel(Client body) throws IOException { HttpResponse response = testClientModelForHttpResponse(body); TypeReference typeRef = new TypeReference<Client>() {}; return apiClient.getObjectMapper().readValue(response.getContent(), typeRef); }","old_code_raw":"    public Client testClientModel(Client client) throws IOException {\n        HttpResponse response = testClientModelForHttpResponse(client);\n        TypeReference typeRef = new TypeReference<Client>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    }\n","new_comment_raw":"@param body client model","old_comment_raw":"@param client client model","label":1,"pre_label":0,"AST_level":8,"line_counts":6,"new_code_token_num":43},{"new_code_raw":"public CaseForEqBuilder<T> when(T other){ return new CaseForEqBuilder<T>(this, new ConstantImpl<T>(other)); }","old_code_raw":"    public CaseForEqBuilder<D> when(D other){\n        return new CaseForEqBuilder<D>(this, new ConstantImpl<D>(other));\n    }\n","new_comment_raw":"@param other","old_comment_raw":"@param other","label":0,"pre_label":1,"AST_level":8,"line_counts":4,"new_code_token_num":25},{"new_code_raw":"private static CoreLabel createDatum(String token, String label, int index) { CoreLabel newTok = new CoreLabel(); newTok.set(CoreAnnotations.CharAnnotation.class, token); newTok.set(CoreAnnotations.AnswerAnnotation.class, label); newTok.set(CoreAnnotations.GoldAnswerAnnotation.class, label); newTok.setIndex(index); return newTok; }","old_code_raw":"  private static CoreLabel createDatum(CoreLabel cl, String token, String label) {\n    CoreLabel newTok = new CoreLabel();\n    newTok.set(CoreAnnotations.TextAnnotation.class, token);\n    newTok.set(CoreAnnotations.CharAnnotation.class, token);\n    newTok.set(CoreAnnotations.AnswerAnnotation.class, label);\n    newTok.set(CoreAnnotations.GoldAnswerAnnotation.class, label);\n    if (cl != null && cl.containsKey(CoreAnnotations.DomainAnnotation.class))\n      newTok.set(CoreAnnotations.DomainAnnotation.class,\n                 cl.get(CoreAnnotations.DomainAnnotation.class));\n    return newTok;\n  }\n","new_comment_raw":"@param token","old_comment_raw":"@param cl","label":1,"pre_label":0,"AST_level":6,"line_counts":9,"new_code_token_num":62},{"new_code_raw":"public Action suspended(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { logger.debug(\"(suspend) invoked:\\n HttpServletRequest: {}\\n HttpServletResponse: {}\", request, response); return action(request, response); }","old_code_raw":"    public Action suspended(HttpServletRequest req, HttpServletResponse res)\n            throws IOException, ServletException {\n        if (logger.isLoggable(Level.FINE)) {\n            logger.fine(\"(suspend) invoked:\\n HttpServletRequest: \" + req\n                    + \"\\n HttpServletResponse: \" + res);\n        }\n        return action(req, res);\n    }\n","new_comment_raw":"@param request the  HttpServletRequest","old_comment_raw":"@param req the HttpServletRequest","label":1,"pre_label":0,"AST_level":5,"line_counts":6,"new_code_token_num":52},{"new_code_raw":"public static Point getCanvasTextLocation(Client client, Graphics2D graphics, LocalPoint localLocation, String text, int zOffset) { int plane = client.getPlane(); Point p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset); if (p == null) { return null; } FontMetrics fm = graphics.getFontMetrics(); Rectangle2D bounds = fm.getStringBounds(text, graphics); int xOffset = p.getX() - (int) (bounds.getWidth() \/ 2); return new Point(xOffset, p.getY()); }","old_code_raw":"\tpublic static Point getCanvasTextLocation(Client client, Graphics2D graphics, Point localLocation, String text, int zOffset)\n\t{\n\t\tint plane = client.getPlane();\n\n\t\tPoint p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset);\n\n\t\tif (p == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tFontMetrics fm = graphics.getFontMetrics();\n\t\tRectangle2D bounds = fm.getStringBounds(text, graphics);\n\t\tint xOffset = p.getX() - (int) (bounds.getWidth() \/ 2);\n\n\t\treturn new Point(xOffset, p.getY());\n\t}\n","new_comment_raw":"@param text string for width measurement","old_comment_raw":"@param text string for width measurement","label":0,"pre_label":1,"AST_level":8,"line_counts":18,"new_code_token_num":109},{"new_code_raw":"public static DataFileReadResult decompress(byte[] b, int[] keys) { InputStream stream = new InputStream(b); int compression = stream.readUnsignedByte(); int compressedLength = stream.readInt(); if (compressedLength < 0 || compressedLength > 1000000) throw new RuntimeException(\"Invalid data\"); Crc32 crc32 = new Crc32(); crc32.update(b, 0, 5); \/\/ compression + length byte[] data; int revision = -1; switch (compression) { case CompressionType.NONE: { byte[] encryptedData = new byte[compressedLength]; stream.readBytes(encryptedData, 0, compressedLength); crc32.update(encryptedData, 0, compressedLength); byte[] decryptedData = decrypt(encryptedData, encryptedData.length, keys); if (stream.remaining() >= 2) { revision = stream.readUnsignedShort(); assert revision != -1; } data = decryptedData; break; } case CompressionType.BZ2: { byte[] encryptedData = new byte[compressedLength + 4]; stream.readBytes(encryptedData); crc32.update(encryptedData, 0, encryptedData.length); byte[] decryptedData = decrypt(encryptedData, encryptedData.length, keys); if (stream.remaining() >= 2) { revision = stream.readUnsignedShort(); assert revision != -1; } stream = new InputStream(decryptedData); int decompressedLength = stream.readInt(); data = BZip2.decompress(stream.getRemaining(), compressedLength); if (data == null) { return null; } assert data.length == decompressedLength; break; } case CompressionType.GZ: { byte[] encryptedData = new byte[compressedLength + 4]; stream.readBytes(encryptedData); crc32.update(encryptedData, 0, encryptedData.length); byte[] decryptedData = decrypt(encryptedData, encryptedData.length, keys); if (stream.remaining() >= 2) { revision = stream.readUnsignedShort(); assert revision != -1; } stream = new InputStream(decryptedData); int decompressedLength = stream.readInt(); data = GZip.decompress(stream.getRemaining(), compressedLength); if (data == null) { return null; } assert data.length == decompressedLength; break; } default: throw new RuntimeException(\"Unknown decompression type\"); } DataFileReadResult res = new DataFileReadResult(); res.data = data; res.revision = revision; int length = revision != -1 ? b.length - 2 : b.length;; res.crc = crc32.getHash(); res.whirlpool = Whirlpool.getHash(b, length); res.compression = compression; return res; }","old_code_raw":"\tpublic static DataFileReadResult decompress(byte[] b)\n\t{\n\t\tInputStream stream = new InputStream(b);\n\t\t\n\t\tint compression = stream.readUnsignedByte();\n\t\tint compressedLength = stream.readInt();\n\t\tif (compressedLength < 0 || compressedLength > 1000000)\n\t\t\tthrow new RuntimeException(\"Invalid data\");\n\t\t\n\t\tbyte[] data;\n\t\tint revision;\n\t\tswitch (compression)\n\t\t{\n\t\t\tcase CompressionType.NONE:\n\t\t\t\tdata = new byte[compressedLength];\n\t\t\t\trevision = checkRevision(stream, compressedLength);\n\t\t\t\tstream.readBytes(data, 0, compressedLength);\n\t\t\t\tbreak;\n\t\t\tcase CompressionType.BZ2:\n\t\t\t{\n\t\t\t\tint length = stream.readInt();\n\t\t\t\trevision = checkRevision(stream, compressedLength);\n\t\t\t\tdata = BZip2.decompress(stream.getRemaining(), compressedLength);\n\t\t\t\tassert data.length == length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CompressionType.GZ:\n\t\t\t{\n\t\t\t\tint length = stream.readInt();\n\t\t\t\trevision = checkRevision(stream, compressedLength);\n\t\t\t\tdata = GZip.decompress(stream.getRemaining(), compressedLength);\n\t\t\t\tassert data.length == length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new RuntimeException(\"Unknown decompression type\");\n\t\t}\n\t\t\n\t\tDataFileReadResult res = new DataFileReadResult();\n\t\tres.data = data;\n\t\tres.revision = revision;\n\t\tint length = revision != -1 ? b.length - 2 : b.length;\n\t\tres.crc = CRC32HGenerator.getHash(b, length);\n\t\tres.whirlpool = Whirlpool.getHash(b, length);\n\t\tres.compression = compression;\n\t\treturn res;\n\t}\n","new_comment_raw":"@param archiveId expected archive of contents being read","old_comment_raw":"@param archiveId","label":1,"pre_label":0,"AST_level":10,"line_counts":104,"new_code_token_num":469},{"new_code_raw":"private RectF drawBoxWithShadow(Canvas c, int width, int height) { Resources res = mContext.getResources(); float shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur); float keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance); float corner = res.getDimension(R.dimen.widget_preview_corner_radius); RectF bounds = new RectF(shadowBlur, shadowBlur, width - shadowBlur, height - shadowBlur - keyShadowDistance); ShadowGenerator.drawShadow(c, bounds, Color.WHITE, shadowBlur, keyShadowDistance, corner); return bounds; }","old_code_raw":"    private RectF drawBoxWithShadow(Canvas c, Paint p, int width, int height) {\n        Resources res = mContext.getResources();\n        float shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur);\n        float keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance);\n        float corner = res.getDimension(R.dimen.widget_preview_corner_radius);\n\n        RectF bounds = new RectF(shadowBlur, shadowBlur,\n                width - shadowBlur, height - shadowBlur - keyShadowDistance);\n        p.setColor(Color.WHITE);\n\n        \/\/ Key shadow\n        p.setShadowLayer(shadowBlur, 0, keyShadowDistance,\n                ShadowGenerator.KEY_SHADOW_ALPHA << 24);\n        c.drawRoundRect(bounds, corner, corner, p);\n\n        \/\/ Ambient shadow\n        p.setShadowLayer(shadowBlur, 0, 0,\n                ColorUtils.setAlphaComponent(Color.BLACK, ShadowGenerator.AMBIENT_SHADOW_ALPHA));\n        c.drawRoundRect(bounds, corner, corner, p);\n\n        p.clearShadowLayer();\n        return bounds;\n    }\n","new_comment_raw":"@param info information about the widget","old_comment_raw":"@param info information about the widget","label":0,"pre_label":1,"AST_level":8,"line_counts":12,"new_code_token_num":92},{"new_code_raw":"public ArrayList<View> getViews(View parent, boolean onlySufficientlyVisible) { final ArrayList<View> views = new ArrayList<View>(); final View parentToUse; if (parent == null){ inst.waitForIdleSync(); return getAllViews(onlySufficientlyVisible); }else{ parentToUse = parent; views.add(parentToUse); if (parentToUse instanceof ViewGroup) { addChildren(views, (ViewGroup) parentToUse, onlySufficientlyVisible); } } return views; }","old_code_raw":"\tpublic ArrayList<View> getViews(View parent, boolean onlyFullyVisible) {\n\t\tfinal ArrayList<View> views = new ArrayList<View>();\n\t\tfinal View parentToUse;\n\n\t\tif (parent == null){\n\t\t\tinst.waitForIdleSync();\n\t\t\treturn getAllViews(onlyFullyVisible);\n\t\t}else{\n\t\t\tparentToUse = parent;\n\n\t\t\tviews.add(parentToUse);\n\n\t\t\tif (parentToUse instanceof ViewGroup) {\n\t\t\t\taddChildren(views, (ViewGroup) parentToUse, onlyFullyVisible);\n\t\t\t}\n\t\t}\n\n\n\t\treturn views;\n\t}\n","new_comment_raw":"@param onlySufficientlyVisible if only sufficiently visible views should be returned","old_comment_raw":"@param onlyFullyVisible if only fully visible views should be returned","label":1,"pre_label":0,"AST_level":10,"line_counts":21,"new_code_token_num":80},{"new_code_raw":"private SQLResponse execute(String correctedSql, SQLRequest sqlRequest, Connection conn) throws Exception { Statement stat = null; ResultSet resultSet = null; Boolean isPushDown = false; List<List<String>> results = Lists.newArrayList(); List<SelectedColumnMeta> columnMetas = Lists.newArrayList(); try { \/\/ special case for prepare query. if (BackdoorToggles.getPrepareOnly()) { return getPrepareOnlySqlResponse(correctedSql, conn, isPushDown, results, columnMetas); } stat = conn.createStatement(); processStatementAttr(stat, sqlRequest); resultSet = stat.executeQuery(correctedSql); ResultSetMetaData metaData = resultSet.getMetaData(); int columnCount = metaData.getColumnCount(); \/\/ Fill in selected column meta for (int i = 1; i <= columnCount; ++i) { columnMetas.add(new SelectedColumnMeta(metaData.isAutoIncrement(i), metaData.isCaseSensitive(i), metaData.isSearchable(i), metaData.isCurrency(i), metaData.isNullable(i), metaData.isSigned(i), metaData.getColumnDisplaySize(i), metaData.getColumnLabel(i), metaData.getColumnName(i), metaData.getSchemaName(i), metaData.getCatalogName(i), metaData.getTableName(i), metaData.getPrecision(i), metaData.getScale(i), metaData.getColumnType(i), metaData.getColumnTypeName(i), metaData.isReadOnly(i), metaData.isWritable(i), metaData.isDefinitelyWritable(i))); } \/\/ fill in results while (resultSet.next()) { List<String> oneRow = Lists.newArrayListWithCapacity(columnCount); for (int i = 0; i < columnCount; i++) { oneRow.add((resultSet.getString(i + 1))); } results.add(oneRow); } } catch (SQLException sqlException) { isPushDown = PushDownUtil.doPushDownQuery(sqlRequest.getProject(), correctedSql, conn.getSchema(), results, columnMetas, sqlException); if (!isPushDown) { throw sqlException; } } finally { close(resultSet, stat, null);\/\/conn is passed in, not my duty to close } return getSqlResponse(isPushDown, results, columnMetas); }","old_code_raw":"    private SQLResponse execute(String correctedSql, SQLRequest sqlRequest) throws Exception {\n        Connection conn = null;\n        Statement stat = null;\n        ResultSet resultSet = null;\n        Boolean isPushDown = false;\n\n        List<List<String>> results = Lists.newArrayList();\n        List<SelectedColumnMeta> columnMetas = Lists.newArrayList();\n\n        try {\n            conn = QueryConnection.getConnection(sqlRequest.getProject());\n\n            \/\/ special case for prepare query. \n            if (BackdoorToggles.getPrepareOnly()) {\n                return getPrepareOnlySqlResponse(correctedSql, conn, isPushDown, results, columnMetas);\n            }\n\n            stat = conn.createStatement();\n            processStatementAttr(stat, sqlRequest);\n            resultSet = stat.executeQuery(correctedSql);\n\n            ResultSetMetaData metaData = resultSet.getMetaData();\n            int columnCount = metaData.getColumnCount();\n\n            \/\/ Fill in selected column meta\n            for (int i = 1; i <= columnCount; ++i) {\n                columnMetas.add(new SelectedColumnMeta(metaData.isAutoIncrement(i), metaData.isCaseSensitive(i),\n                        metaData.isSearchable(i), metaData.isCurrency(i), metaData.isNullable(i), metaData.isSigned(i),\n                        metaData.getColumnDisplaySize(i), metaData.getColumnLabel(i), metaData.getColumnName(i),\n                        metaData.getSchemaName(i), metaData.getCatalogName(i), metaData.getTableName(i),\n                        metaData.getPrecision(i), metaData.getScale(i), metaData.getColumnType(i),\n                        metaData.getColumnTypeName(i), metaData.isReadOnly(i), metaData.isWritable(i),\n                        metaData.isDefinitelyWritable(i)));\n            }\n\n            \/\/ fill in results\n            while (resultSet.next()) {\n                List<String> oneRow = Lists.newArrayListWithCapacity(columnCount);\n                for (int i = 0; i < columnCount; i++) {\n                    oneRow.add((resultSet.getString(i + 1)));\n                }\n\n                results.add(oneRow);\n            }\n        } catch (SQLException sqlException) {\n            isPushDown = PushDownUtil.doPushDownQuery(sqlRequest.getProject(), correctedSql, conn.getSchema(), results, columnMetas,\n                    sqlException);\n            if (!isPushDown) {\n                throw sqlException;\n            }\n        } finally {\n            close(resultSet, stat, conn);\n        }\n\n        return getSqlResponse(isPushDown, results, columnMetas);\n    }\n","new_comment_raw":"@param correctedSql","old_comment_raw":"@param correctedSql","label":0,"pre_label":1,"AST_level":12,"line_counts":55,"new_code_token_num":389},{"new_code_raw":"public List<WebElement> apply(WebDriver driver) { WebElement current = findElement(parent, driver); List<WebElement> allChildren = current.findElements(childLocator); \/\/ The original code only checked the first element. Fair enough. if (!allChildren.isEmpty() && allChildren.get(0).isDisplayed()) { return allChildren; } return null; }","old_code_raw":"      public List<WebElement> apply(WebDriver webDriver) {\n        Boolean displayed = false;\n        Boolean exists = false;\n        try {\n          exists = findElement(locator, webDriver).findElements(sub_locator).size() > 0;\n          displayed =\n            findElement(locator, webDriver).findElement(sub_locator).isDisplayed();\n        } catch (Exception e) {\n          int i = 0;\n        }\n        return (exists && displayed) ?\n               findElement(locator, webDriver).findElements(sub_locator) :\n               null;\n      }\n","new_comment_raw":"@param parent used to check parent element. For example table with locator By.id(\"fish\")","old_comment_raw":"@param locator used to check parent element. For example table with locator By.xpath(\"\/\/table\")","label":1,"pre_label":0,"AST_level":6,"line_counts":12,"new_code_token_num":66},{"new_code_raw":"private static String canonicalize(final SortedSet<QueryParameter> sortedParameters) { if (sortedParameters == null || sortedParameters.isEmpty()) { return \"\"; } final StringBuilder sb = new StringBuilder(100); for (QueryParameter parameter : sortedParameters) { final String name = parameter.getName().toLowerCase(); \/\/ Ignore irrelevant parameters if (IRRELEVANT_PARAMETERS.contains(name) || name.startsWith(\"utm_\")) { continue; } if (sb.length() > 0) { sb.append('&'); } sb.append(parameter.getName()); if (!parameter.getValue().isEmpty()) { sb.append('='); sb.append(parameter.getValue()); } } return sb.toString(); }","old_code_raw":"\tprivate static String canonicalize(final SortedMap<String, String> sortedParamMap) {\n\t\tif (sortedParamMap == null || sortedParamMap.isEmpty()) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tfinal StringBuilder sb = new StringBuilder(100);\n\t\tfor (Map.Entry<String, String> pair : sortedParamMap.entrySet()) {\n\t\t\tfinal String key = pair.getKey().toLowerCase();\n\t\t\t\/\/ Ignore irrelevant parameters\n\t\t\tif (IRRELEVANT_PARAMETERS.contains(key) || key.startsWith(\"utm_\")) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (sb.length() > 0) {\n\t\t\t\tsb.append('&');\n\t\t\t}\n\t\t\tsb.append(pair.getKey());\n\t\t\tif (!pair.getValue().isEmpty()) {\n\t\t\t\tsb.append('=');\n\t\t\t\tsb.append(pair.getValue());\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n","new_comment_raw":"@param sortedParameters Parameter name-value pairs in lexicographical order.","old_comment_raw":"@param sortedParamMap Parameter name-value pairs in lexicographical order.","label":1,"pre_label":0,"AST_level":9,"line_counts":24,"new_code_token_num":146},{"new_code_raw":"public static BroadcasterFactory buildAndReplaceDefaultfactory(Class<? extends Broadcaster> clazz, AtmosphereServlet.AtmosphereConfig c) throws InstantiationException, IllegalAccessException { factory = new DefaultBroadcasterFactory(clazz); config = c; return factory; }","old_code_raw":"    public static BroadcasterFactory buildAndReplaceDefaultfactory(Class<? extends Broadcaster> clazz, BroadcasterConfig config)\n            throws InstantiationException, IllegalAccessException {\n\n        factory = new DefaultBroadcasterFactory(clazz);\n        return factory;\n    }\n","new_comment_raw":"@param clazz A class implementing  Broadcaster","old_comment_raw":"@param clazz A class implementing Broadcaster","label":0,"pre_label":1,"AST_level":6,"line_counts":8,"new_code_token_num":34},{"new_code_raw":"public Builder argument(UnaryOperator<GraphQLArgument.Builder> builderFunction) { GraphQLArgument.Builder builder = GraphQLArgument.newArgument(); builder = builderFunction.apply(builder); return argument(builder); }","old_code_raw":"        public Builder argument(BuilderFunction<GraphQLArgument.Builder> builderFunction) {\n            GraphQLArgument.Builder builder = GraphQLArgument.newArgument();\n            builder = builderFunction.apply(builder);\n            return argument(builder);\n        }\n","new_comment_raw":"@param builderFunction a supplier for the builder impl","old_comment_raw":"@param builderFunction a supplier for the builder impl","label":0,"pre_label":1,"AST_level":7,"line_counts":6,"new_code_token_num":32},{"new_code_raw":"public int[] set(ReadablePartial partial, int fieldIndex, int[] values, int newValue) { FieldUtils.verifyValueBounds(this, newValue, getMinimumValue(partial, values), getMaximumValue(partial, values)); values[fieldIndex] = newValue; \/\/ may need to adjust smaller fields if (fieldIndex < partial.size()) { for (int i = fieldIndex + 1; i < partial.size(); i++) { DateTimeField field = partial.getField(i); if (values[i] > field.getMaximumValue(partial, values)) { values[i] = field.getMaximumValue(partial, values); } if (values[i] < field.getMinimumValue(partial, values)) { values[i] = field.getMinimumValue(partial, values); } } } return values; }","old_code_raw":"    public int[] set(ReadablePartial instant, int fieldIndex, int[] values, int newValue) {\n        FieldUtils.verifyValueBounds(this, newValue, getMinimumValue(instant, values), getMaximumValue(instant, values));\n        values[fieldIndex] = newValue;\n        \n        \/\/ may need to adjust smaller fields\n        if (fieldIndex < instant.getFieldSize()) {\n            for (int i = fieldIndex + 1; i < instant.getFieldSize(); i++) {\n                DateTimeField field = instant.getField(i);\n                if (values[i] > field.getMaximumValue(instant, values)) {\n                    values[i] = field.getMaximumValue(instant, values);\n                }\n                if (values[i] < field.getMinimumValue(instant, values)) {\n                    values[i] = field.getMinimumValue(instant, values);\n                }\n            }\n        }\n        return values;\n    }\n","new_comment_raw":"@param partial the partial instant","old_comment_raw":"@param instant the partial instant","label":1,"pre_label":0,"AST_level":13,"line_counts":19,"new_code_token_num":155},{"new_code_raw":"public static String uniquify(String name, Set<String> nameList) { if (name == null) { name = \"EXPR$\"; } if (nameList.add(name)) { return name; } String aliasBase = name; for (int j = 0;; j++) { name = aliasBase + j; if (nameList.add(name)) { return name; } } }","old_code_raw":"    public static String uniquify(String name, Collection<String> nameList)\n    {\n        if (name == null) {\n            name = \"EXPR$\";\n        }\n        if (nameList.contains(name)) {\n            String aliasBase = name;\n            for (int j = 0;; j++) {\n                name = aliasBase + j;\n                if (!nameList.contains(name)) {\n                    break;\n                }\n            }\n        }\n        nameList.add(name);\n        return name;\n    }\n","new_comment_raw":"@param nameList Collection of names already used","old_comment_raw":"@param nameList Collection of names already used","label":0,"pre_label":1,"AST_level":8,"line_counts":17,"new_code_token_num":75},{"new_code_raw":"public ApiResponse<Client> testSpecialTagsWithHttpInfo(Client client) throws ApiException { Object localVarPostBody = client; \/\/ verify the required parameter 'client' is set if (client == null) { throw new ApiException(400, \"Missing the required parameter 'client' when calling testSpecialTags\"); } \/\/ create path and map variables String localVarPath = \"\/another-fake\/dummy\"; \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { \"application\/json\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { \"application\/json\" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Client> localVarReturnType = new GenericType<Client>() {}; return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public ApiResponse<Client> testSpecialTagsWithHttpInfo(Client body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    \/\/ verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling testSpecialTags\");\n    }\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/another-fake\/dummy\";\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application\/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application\/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@param client client model (required)","old_comment_raw":"@param body client model (required)","label":1,"pre_label":0,"AST_level":8,"line_counts":35,"new_code_token_num":204},{"new_code_raw":"protected Object convertEnumToString(List<String> options, Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return \"\"; } if (data instanceof String) { \/\/ JDBC should return strings ... return data; } if (data instanceof Integer) { if (options != null) { \/\/ The binlog will contain an int with the 1-based index of the option in the enum value ... int index = ((Integer) data).intValue() - 1; \/\/ 'options' is 0-based if (index < options.size()) { return options.get(index); } } return null; } return handleUnknownData(column, fieldDefn, data); }","old_code_raw":"    protected Object convertEnumToString(String options, Column column, Field fieldDefn, Object data) {\n        if (data == null) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return \"\";\n        }\n        if (data instanceof String) {\n            \/\/ JDBC should return strings ...\n            return data;\n        }\n        if (data instanceof Integer) {\n            \/\/ The binlog will contain an int with the 1-based index of the option in the enum value ...\n            int index = ((Integer) data).intValue() - 1; \/\/ 'options' is 0-based\n            if (index < options.length()) {\n                return options.substring(index, index + 1);\n            }\n            return null;\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n","new_comment_raw":"@param column the column definition describing the  data value; never null","old_comment_raw":"@param column the column definition describing the data value; never null","label":0,"pre_label":1,"AST_level":11,"line_counts":26,"new_code_token_num":163},{"new_code_raw":"private boolean paramAppend(StringBuilder sb, String name, String value) { boolean isEdited = false; if (name != null) { sb.append(name); isEdited = true; } if (value != null) { sb.append('='); sb.append(value); isEdited = true; } return isEdited; }","old_code_raw":"    private boolean paramAppend(StringBuffer sb, String name, String value) {\n        boolean isEdited = false;\n        if (name != null) {\n            sb.append(name);\n            isEdited = true;\n        }\n        if (value != null) {\n            sb.append('=');\n            sb.append(value);\n            isEdited = true;\n        }\n        return isEdited;\n    }\n","new_comment_raw":"@param name Null = not to append parameter.","old_comment_raw":"@param name Null = not to append parameter.","label":0,"pre_label":1,"AST_level":7,"line_counts":14,"new_code_token_num":63},{"new_code_raw":"private boolean hasSingleValue(ColumnStatistics columnStatistics, long rowCount) { return columnStatistics != null && isSingleVal(columnStatistics, rowCount); }","old_code_raw":"  private boolean hasSingleValue(ColumnMetadata columnChunkMetaData, long rowCount) {\n    return (columnChunkMetaData != null) && (columnChunkMetaData.hasSingleValue(rowCount));\n  }\n","new_comment_raw":"@param columnStatistics metadata to check","old_comment_raw":"@param columnChunkMetaData metadata to check","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":25},{"new_code_raw":"private HttpURLConnection createHttpURLConnection(IBasicRequest request) throws Exception { \/\/ 1.Pre operation notice request.onPreExecute(); \/\/ 2.Build URL String urlStr = request.url(); Logger.i(\"Request address: \" + urlStr); URL url = new URL(urlStr); HttpURLConnection connection; Proxy proxy = request.getProxy(); if (proxy == null) connection = (HttpURLConnection) url.openConnection(); else connection = (HttpURLConnection) url.openConnection(proxy); connection.setConnectTimeout(request.getConnectTimeout()); connection.setReadTimeout(request.getReadTimeout()); connection.setInstanceFollowRedirects(false); if (connection instanceof HttpsURLConnection) { SSLSocketFactory sslSocketFactory = request.getSSLSocketFactory(); if (sslSocketFactory != null) ((HttpsURLConnection) connection).setSSLSocketFactory(sslSocketFactory); HostnameVerifier hostnameVerifier = request.getHostnameVerifier(); if (hostnameVerifier != null) ((HttpsURLConnection) connection).setHostnameVerifier(hostnameVerifier); } \/\/ 3. Base attribute RequestMethod requestMethod = request.getRequestMethod(); String requestMethodStr = requestMethod.toString(); Logger.i(\"Request method: \" + requestMethodStr); \/\/ Fix delete patch error. try { connection.setRequestMethod(requestMethodStr); } catch (ProtocolException protocol) { try { Field methodField = connection.getClass().getDeclaredField(\"method\"); methodField.setAccessible(true); methodField.set(connection, requestMethodStr); } catch (Exception noSuchFieldIllegalAccess) { throw protocol; } } connection.setDoInput(true); connection.setDoOutput(requestMethod.allowRequestBody()); \/\/ 4.Set request headers setHeaders(url.toURI(), connection, request); \/\/ 5. Connect connection.connect(); return connection; }","old_code_raw":"    protected HttpURLConnection createHttpURLConnection(BasicServerRequest request) throws IOException, URISyntaxException {\n        \/\/ 1.Pre operation notice\n        request.onPreExecute();\n\n        \/\/ 2.Build URL\n        String urlStr = request.url();\n        Logger.i(\"Request address: \" + urlStr);\n        URL url = new URL(urlStr);\n        HttpURLConnection connection;\n        Proxy proxy = request.getProxy();\n        if (proxy == null)\n            connection = (HttpURLConnection) url.openConnection();\n        else\n            connection = (HttpURLConnection) url.openConnection(proxy);\n\n        connection.setConnectTimeout(request.getConnectTimeout());\n        connection.setReadTimeout(request.getReadTimeout());\n        connection.setInstanceFollowRedirects(false);\n\n        if (connection instanceof HttpsURLConnection) {\n            SSLSocketFactory sslSocketFactory = request.getSSLSocketFactory();\n            if (sslSocketFactory != null)\n                ((HttpsURLConnection) connection).setSSLSocketFactory(sslSocketFactory);\n            HostnameVerifier hostnameVerifier = request.getHostnameVerifier();\n            if (hostnameVerifier != null)\n                ((HttpsURLConnection) connection).setHostnameVerifier(hostnameVerifier);\n        }\n\n        \/\/ 3. Base attribute\n        RequestMethod requestMethod = request.getRequestMethod();\n        Logger.i(\"Request method: \" + requestMethod.toString());\n        \/\/ Fix delete patch error.\n        try {\n            connection.setRequestMethod(requestMethod.toString());\n        } catch (ProtocolException protocol) {\n            try {\n                Field methodField = connection.getClass().getDeclaredField(\"method\");\n                methodField.setAccessible(true);\n                methodField.set(connection, requestMethod.toString());\n            } catch (Exception noSuchFieldIllegalAccess) {\n                throw protocol;\n            }\n        }\n\n        connection.setDoInput(true);\n        connection.setDoOutput(requestMethod.allowRequestBody());\n\n        \/\/ 4.Set request headers\n        URI uri = null;\n        try {\n            uri = url.toURI();\n        } catch (URISyntaxException e) {\n            Logger.w(e);\n        }\n        setHeaders(uri, connection, request);\n\n        \/\/ 5. Connect\n        connection.connect();\n\n        \/\/ 6. Write request body\n        if (requestMethod.allowRequestBody()) {\n            Logger.i(\"-------Send request data start-------\");\n            OutputStream outputStream = IOUtils.toBufferedOutputStream(connection.getOutputStream());\n            request.onWriteRequestBody(outputStream);\n            IOUtils.flushQuietly(outputStream);\n            IOUtils.closeQuietly(outputStream);\n            Logger.i(\"-------Send request data end-------\");\n        }\n\n        return connection;\n    }\n","new_comment_raw":"@param request  IBasicRequest.","old_comment_raw":"@param request BasicServerRequest.","label":1,"pre_label":0,"AST_level":10,"line_counts":56,"new_code_token_num":307},{"new_code_raw":"public static float length(float x, float y, float z) { return (float) Math.sqrt(length2(x, y, z)); }","old_code_raw":"\tpublic static double length(double x, double y, double z) {\n\t\treturn Math.sqrt(length2(x, y, z));\n\t}\n","new_comment_raw":"@param z float The z component.","old_comment_raw":"@param z double The z component.","label":1,"pre_label":0,"AST_level":7,"line_counts":5,"new_code_token_num":33},{"new_code_raw":"public static Point getCanvasTextMiniMapLocation(Client client, Graphics2D graphics, LocalPoint localLocation, String text) { Point p = Perspective.worldToMiniMap(client, localLocation.getX(), localLocation.getY()); if (p == null) { return null; } FontMetrics fm = graphics.getFontMetrics(); Rectangle2D bounds = fm.getStringBounds(text, graphics); int xOffset = p.getX() - (int) (bounds.getWidth() \/ 2); int yOffset = p.getY() - (int) (bounds.getHeight() \/ 2) + fm.getAscent(); return new Point(xOffset, yOffset); }","old_code_raw":"\tpublic static Point getCanvasTextMiniMapLocation(Client client, Graphics2D graphics, Point localLocation, String text)\n\t{\n\t\tPoint p = Perspective.worldToMiniMap(client, localLocation.getX(), localLocation.getY());\n\n\t\tif (p == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tFontMetrics fm = graphics.getFontMetrics();\n\t\tRectangle2D bounds = fm.getStringBounds(text, graphics);\n\t\tint xOffset = p.getX() - (int) (bounds.getWidth() \/ 2);\n\t\tint yOffset = p.getY() - (int) (bounds.getHeight() \/ 2) + fm.getAscent();\n\n\t\treturn new Point(xOffset, yOffset);\n\t}\n","new_comment_raw":"@param client","old_comment_raw":"@param client","label":0,"pre_label":1,"AST_level":9,"line_counts":17,"new_code_token_num":116},{"new_code_raw":"public static DownloadRequest createDownloadRequest(String url, RequestMethod requestMethod, String fileFolder, String filename, boolean isRange, boolean isDeleteOld) { return new RestDownloadRequestor(url, requestMethod, fileFolder, filename, isRange, isDeleteOld); }","old_code_raw":"    public static DownloadRequest createDownloadRequest(String url, RequestMethod requestMethod, String fileFloder, String filename, boolean isRange, boolean isDeleteOld) {\n        return new RestDownloadRequestor(url, requestMethod, fileFloder, filename, isRange, isDeleteOld);\n    }\n","new_comment_raw":"@param isRange Whether the breakpoint continuingly","old_comment_raw":"@param isRange Whether the breakpoint continuingly","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":42},{"new_code_raw":"public JdbcConnection prepareQuery(String[] multiQuery, StatementPreparer preparer, BlockingMultiResultSetConsumer resultConsumer) throws SQLException, InterruptedException { final Connection conn = connection(); final ResultSet[] resultSets = new ResultSet[multiQuery.length]; final PreparedStatement[] preparedStatements = new PreparedStatement[multiQuery.length]; try { for (int i = 0; i < multiQuery.length; i++) { final String query = multiQuery[i]; if (LOGGER.isTraceEnabled()) { LOGGER.trace(\"running '{}'\", query); } final PreparedStatement statement = conn.prepareStatement(query); preparedStatements[i] = statement; preparer.accept(statement); resultSets[i] = statement.executeQuery(); } if (resultConsumer != null) { resultConsumer.accept(resultSets); } } finally { for (ResultSet rs: resultSets) { if (rs != null) { try { rs.close(); } catch (Exception ei) { } } } for (PreparedStatement ps: preparedStatements) { if (ps != null) { try { ps.close(); } catch (Exception ei) { } } } } return this; }","old_code_raw":"    public JdbcConnection prepareQuery(String[] multiQuery, StatementPreparer preparer, MultiResultSetConsumer resultConsumer) throws SQLException {\n        final Connection conn = connection();\n        final ResultSet[] resultSets = new ResultSet[multiQuery.length];\n        final PreparedStatement[] preparedStatements = new PreparedStatement[multiQuery.length];\n\n        try {\n            for (int i = 0; i < multiQuery.length; i++) {\n                final String query = multiQuery[i];\n                if (LOGGER.isTraceEnabled()) {\n                    LOGGER.trace(\"running '{}'\", query);\n                }\n                final PreparedStatement statement = conn.prepareStatement(query);\n                preparedStatements[i] = statement;\n                preparer.accept(statement);\n                resultSets[i] = statement.executeQuery();\n            }\n            if (resultConsumer != null) {\n                resultConsumer.accept(resultSets);\n            }\n        }\n        finally {\n            for (ResultSet rs: resultSets) {\n                if (rs != null) {\n                    try {\n                        rs.close();\n                    }\n                    catch (Exception ei) {\n                    }\n                }\n            }\n            for (PreparedStatement ps: preparedStatements) {\n                if (ps != null) {\n                    try {\n                        ps.close();\n                    }\n                    catch (Exception ei) {\n                    }\n                }\n            }\n        }\n        return this;\n    }\n","new_comment_raw":"@param preparer the function that supplied arguments to the prepared statement; may not be null","old_comment_raw":"@param preparer the function that supplied arguments to the prepared statement; may not be null","label":0,"pre_label":1,"AST_level":10,"line_counts":43,"new_code_token_num":216},{"new_code_raw":"public String invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); b.append(\"?\"); if (queryParams != null){ for (Pair queryParam : queryParams){ if (!queryParam.getName().isEmpty()) { b.append(escapeString(queryParam.getName())); b.append(\"=\"); b.append(escapeString(queryParam.getValue())); b.append(\"&\"); } } } String querystring = b.substring(0, b.length() - 1); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(\"GET\".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (\"POST\".equals(method)) { if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (\"PUT\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (\"DELETE\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, \"unknown method type \" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return \"\"; } } else { String message = \"error\"; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { \/\/ e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }","old_code_raw":"  public String invokeAPI(String path, String method, Set<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          \/\/ e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n","new_comment_raw":"@param formParams The form parameters","old_comment_raw":"@param formParams The form parameters","label":0,"pre_label":1,"AST_level":16,"line_counts":113,"new_code_token_num":736},{"new_code_raw":"public int compareTo(ReadablePartial partial) { if (partial == null) { throw new IllegalArgumentException(\"The instant must not be null\"); } int thisValue = get(); int otherValue = partial.get(getFieldType()); if (thisValue < otherValue) { return -1; } else if (thisValue > otherValue) { return 1; } else { return 0; } }","old_code_raw":"    public int compareTo(ReadableInstant instant) {\n        if (instant == null) {\n            throw new IllegalArgumentException(\"The instant must not be null\");\n        }\n        int thisValue = get();\n        int otherValue = instant.get(getField());\n        if (thisValue < otherValue) {\n            return -1;\n        } else if (thisValue > otherValue) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n","new_comment_raw":"@param partial the partial to compare to","old_comment_raw":"@param instant the instant to compare to","label":1,"pre_label":0,"AST_level":7,"line_counts":15,"new_code_token_num":74},{"new_code_raw":"private HttpSession getMatchingHttpSession(List<HttpCookie> cookies, final Set<String> tokens) { \/\/ Pre-checks if (sessions.isEmpty()) { return null; } List<HttpSession> matchingSessions = new LinkedList<>(sessions); for (String token : tokens) { \/\/ Get the corresponding cookie from the cookies list HttpCookie matchingCookie = null; for (HttpCookie cookie : cookies) { if (cookie.getName().equals(token)) { matchingCookie = cookie; break; } } \/\/ Filter the sessions that do not match the cookie value Iterator<HttpSession> it = matchingSessions.iterator(); while (it.hasNext()) { if (!it.next().matchesToken(token, matchingCookie)) { it.remove(); } } } \/\/ Return the matching session if (matchingSessions.size() >= 1) { if (matchingSessions.size() > 1) { log.warn(\"Multiple sessions matching the cookies from response for site: \" + getSite() + \". Using first one.\"); } return matchingSessions.get(0); } return null; }","old_code_raw":"\tprivate HttpSession getMatchingHttpSession(List<HttpCookie> cookies, final HttpSessionTokensSet siteTokens) {\n\n\t\treturn CookieBasedSessionManagementHelper.getMatchingHttpSession(sessions, cookies, siteTokens);\n\t}\n","new_comment_raw":"@param tokens the tokens","old_comment_raw":"@param siteTokens the tokens","label":1,"pre_label":0,"AST_level":11,"line_counts":38,"new_code_token_num":204},{"new_code_raw":"private URL determineSuiteUrl(String startURL, String suiteURL) throws IOException { if (suiteURL.startsWith(\"https:\/\/\") || suiteURL.startsWith(\"http:\/\/\")) { return verifySuiteUrl(new URL(suiteURL)); } \/\/ Is the suiteURL a file? Path path = Paths.get(suiteURL); if (Files.exists(path)) { \/\/ Not all drivers can read files from the disk, so we need to host the suite somewhere. try (SocketLock lock = new SocketLock()) { server = new Server(); HttpConfiguration httpConfig = new HttpConfiguration(); ServerConnector http = new ServerConnector(server, new HttpConnectionFactory(httpConfig)); int port = PortProber.findFreePort(); http.setPort(port); http.setIdleTimeout(500000); server.setConnectors(new Connector[]{http}); ResourceHandler handler = new ResourceHandler(); handler.setDirectoriesListed(true); handler.setWelcomeFiles(new String[]{path.getFileName().toString(), \"index.html\"}); handler.setBaseResource(new PathResource(path.toFile().getParentFile().toPath().toRealPath())); ContextHandler context = new ContextHandler(\"\/tests\"); context.setHandler(handler); server.setHandler(context); server.start(); PortProber.waitForPortUp(port, 15, SECONDS); URL serverUrl = server.getURI().toURL(); return new URL(serverUrl.getProtocol(), serverUrl.getHost(), serverUrl.getPort(), \"\/tests\/\"); } catch (Exception e) { throw new IOException(e); } } \/\/ Well then, it must be a URL relative to whatever the browserUrl. Probe and find out. URL browser = new URL(startURL); return verifySuiteUrl(new URL(browser, suiteURL)); }","old_code_raw":"  private URL determineSuiteUrl(String browserUrl, String suiteURL) throws IOException {\n    if (suiteURL.startsWith(\"https:\/\/\") || suiteURL.startsWith(\"http:\/\/\")) {\n      return verifySuiteUrl(new URL(suiteURL));\n    }\n\n    \/\/ Is the suiteURL a file?\n    Path path = Paths.get(suiteURL);\n    if (Files.exists(path)) {\n      \/\/ Not all drivers can read files from the disk, so we need to host the suite somewhere.\n      try (SocketLock lock = new SocketLock()) {\n        server = new Server();\n        HttpConfiguration httpConfig = new HttpConfiguration();\n\n        ServerConnector http = new ServerConnector(server, new HttpConnectionFactory(httpConfig));\n        int port = PortProber.findFreePort();\n        http.setPort(port);\n        http.setIdleTimeout(500000);\n        server.setConnectors(new Connector[]{http});\n\n        ResourceHandler handler = new ResourceHandler();\n        handler.setDirectoriesListed(true);\n        handler.setWelcomeFiles(new String[]{path.getFileName().toString(), \"index.html\"});\n        handler.setBaseResource(new PathResource(path.toFile().getParentFile().toPath().toRealPath()));\n\n        ContextHandler context = new ContextHandler(\"\/tests\");\n        context.setHandler(handler);\n\n        server.setHandler(context);\n        server.start();\n\n        PortProber.waitForPortUp(port, 15, SECONDS);\n\n        URL serverUrl = server.getURI().toURL();\n        return new URL(serverUrl.getProtocol(), serverUrl.getHost(), serverUrl.getPort(),\n                       \"\/tests\/\");\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n\n    \/\/ Well then, it must be a URL relative to whatever the browserUrl. Probe and find out.\n    URL browser = new URL(browserUrl);\n    return verifySuiteUrl(new URL(browser, suiteURL));\n  }\n","new_comment_raw":"@param browser - the browserString (\"firefox\", \"iexplore\" or an executable path)","old_comment_raw":"@param browser - the browserString (\"firefox\", \"iexplore\" or an executable path)","label":0,"pre_label":1,"AST_level":11,"line_counts":45,"new_code_token_num":351},{"new_code_raw":"public ASTNode getASTNodeAt(int javaOffset) { Messages.log(\"* getASTNodeAt\"); PreprocessedSketch ps = errorCheckerService.latestResult; ASTNode node = NodeFinder.perform(ps.compilationUnit, javaOffset, 0); if (node == null) { Messages.log(\"no node found\"); return null; } Messages.log(\"found \" + node.toString()); return node; }","old_code_raw":"  public ASTNode getASTNodeAt(int offset) {\n    Messages.log(\"* getASTNodeAt\");\n\n    PreprocessedSketch ps = errorCheckerService.latestResult;\n    int tabIndex = ps.sketch.getCodeIndex(editor.getCurrentTab());\n    int javaOffset = ps.tabOffsetToJavaOffset(tabIndex, offset);\n    ASTNode node = NodeFinder.perform(ps.compilationUnit, javaOffset, 0);\n\n    if (node == null) {\n      Messages.log(\"no node found\");\n      return null;\n    }\n\n    Messages.log(\"found \" + node.toString());\n    return node;\n  }\n","new_comment_raw":"@param offset - line start nonwhitespace offset","old_comment_raw":"@param offset - line start nonwhitespace offset","label":0,"pre_label":1,"AST_level":7,"line_counts":15,"new_code_token_num":72},{"new_code_raw":"public Tree prune(Filter<Tree> filter, TreeFactory tf) { \/\/ is the current node to be pruned? if ( ! filter.accept(this)) { return null; } \/\/ if not, recurse over all children List<Tree> l = new ArrayList<Tree>(); Tree[] kids = children(); for (int i = 0; i < kids.length; i++) { Tree prunedChild = kids[i].prune(filter, tf); if (prunedChild != null) { l.add(prunedChild); } } \/\/ and check if this node has lost all its children if (l.isEmpty() && !(kids.length == 0)) { return null; } \/\/ if we're still ok, copy the node if (isLeaf()) { return tf.newLeaf(label()); } return tf.newTreeNode(label(), l); }","old_code_raw":"  public Tree prune(Predicate<Tree> filter, TreeFactory tf) {\n    \/\/ is the current node to be pruned?\n    if ( ! filter.test(this)) {\n      return null;\n    }\n    \/\/ if not, recurse over all children\n    List<Tree> l = new ArrayList<>();\n    Tree[] kids = children();\n    for (Tree kid : kids) {\n      Tree prunedChild = kid.prune(filter, tf);\n      if (prunedChild != null) {\n        l.add(prunedChild);\n      }\n    }\n    \/\/ and check if this node has lost all its children\n    if (l.isEmpty() && !(kids.length == 0)) {\n      return null;\n    }\n    \/\/ if we're still ok, copy the node\n    if (isLeaf()) {\n      return tf.newLeaf(label());\n    }\n    return tf.newTreeNode(label(), l);\n  }\n","new_comment_raw":"@param tf the TreeFactory to be used to make new Tree nodes if needed","old_comment_raw":"@param tf the TreeFactory to be used to make new Tree nodes if needed","label":0,"pre_label":1,"AST_level":9,"line_counts":25,"new_code_token_num":178},{"new_code_raw":"@CheckForNull public final SCMRevision fetch(@NonNull String thingName, @CheckForNull TaskListener listener) throws IOException, InterruptedException { return retrieve(thingName, defaultListener(listener)); }","old_code_raw":"    @CheckForNull\n    public final SCMRevision fetch(@NonNull String revision, @CheckForNull TaskListener listener)\n            throws IOException, InterruptedException {\n        return retrieve(revision, defaultListener(listener));\n    }\n","new_comment_raw":"@param thingName might be a branch name, a tag name, a cryptographic hash, a thingName number, etc.","old_comment_raw":"@param revision might be a branch name, a tag name, a cryptographic hash, a revision number, etc.","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":34},{"new_code_raw":"private String getChildSuffix(StructuralNode node, boolean performRecursiveCheck) { String resultSuffix = \"\"; String suffix = null; StructuralNode child = null; try { for (int i = 0; i < staticSuffixList.length; i++) { suffix = staticSuffixList[i]; Iterator<StructuralNode> iter = node.getChildIterator(); while (iter.hasNext()) { child = iter.next(); try { if (child.getURI().getPath().endsWith(suffix)) { return suffix; } } catch (Exception e) { } } } if (performRecursiveCheck) { Iterator<StructuralNode> iter = node.getChildIterator(); while (iter.hasNext()) { child = iter.next(); resultSuffix = getChildSuffix(child, performRecursiveCheck); if (!resultSuffix.equals(\"\")) { return resultSuffix; } } } } catch (Exception e) { } return resultSuffix; }","old_code_raw":"    private String getChildSuffix(SiteNode node, boolean performRecursiveCheck) {\n\n        String resultSuffix = \"\";\n        String suffix = null;\n        SiteNode child = null;\n        HistoryReference ref = null;\n        try {\n\n            for (int i = 0; i < staticSuffixList.length; i++) {\n                suffix = staticSuffixList[i];\n                for (int j = 0; j < node.getChildCount(); j++) {\n                    child = (SiteNode) node.getChildAt(j);\n                    ref = child.getHistoryReference();\n                    try {\n                        if (ref.getURI().getPath().endsWith(suffix)) {\n                            return suffix;\n                        }\n                    } catch (Exception e) {\n                    }\n                }\n            }\n\n            if (performRecursiveCheck) {\n                for (int j = 0; j < node.getChildCount(); j++) {\n                    resultSuffix = getChildSuffix((SiteNode) node.getChildAt(j), performRecursiveCheck);\n                    if (!resultSuffix.equals(\"\")) {\n                        return resultSuffix;\n                    }\n                }\n            }\n\n        } catch (Exception e) {\n        }\n\n        return resultSuffix;\n    }\n","new_comment_raw":"@param entity The current entity.","old_comment_raw":"@param entity The current entity.","label":0,"pre_label":1,"AST_level":12,"line_counts":38,"new_code_token_num":164},{"new_code_raw":"public FluentWait<T> withTimeout(Duration timeout) { this.timeout = timeout; return this; }","old_code_raw":"  public FluentWait<T> withTimeout(java.time.Duration timeout) {\n    this.timeout = timeout;\n    return this;\n  }\n","new_comment_raw":"@param timeout The timeout duration.","old_comment_raw":"@param timeout The timeout duration.","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":17},{"new_code_raw":"protected String getExample(Schema schema) { if (schema.getExample() != null) { return schema.getExample().toString(); } else if (ModelUtils.isDateTimeSchema(schema)) { return \"2000-01-23T04:56:07.000Z\"; } else if (ModelUtils.isDateSchema(schema)) { return \"2000-01-23\"; } else if (ModelUtils.isBooleanSchema(schema)) { return \"true\"; } else if (ModelUtils.isNumberSchema(schema)) { if (ModelUtils.isFloatSchema(schema)) { \/\/ float return \"1.3579\"; } else { \/\/ double return \"3.149\"; } } else if (ModelUtils.isPasswordSchema(schema)) { return \"********\"; } else if (ModelUtils.isUUIDSchema(schema)) { return \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\"; \/\/ do these last in case the specific types above are derived from these classes } else if (ModelUtils.isStringSchema(schema)) { return \"aeiou\"; } else if (ModelUtils.isIntegerSchema(schema)) { if (ModelUtils.isLongSchema(schema)) { \/\/ long return \"123456789\"; } else { \/\/integer return \"123\"; } } else { LOGGER.debug(\"default example value not implemented for {}. Default to UNDEFINED_EXAMPLE_VALUE\", schema); return \"UNDEFINED_EXAMPLE_VALUE\"; } }","old_code_raw":"    protected String getExample(Property property) {\n        if (property.getExample() != null) {\n            return property.getExample().toString();\n        } else if (property instanceof DateTimeProperty) {\n            return \"2000-01-23T04:56:07.000Z\";\n        } else if (property instanceof DateProperty) {\n            return \"2000-01-23\";\n        } else if (property instanceof BooleanProperty) {\n            return \"true\";\n        } else if (property instanceof LongProperty) {\n            return \"123456789\";\n        } else if (property instanceof DoubleProperty) { \/\/ derived from DecimalProperty so make sure this is first\n            return \"3.149\";\n        }  else if (property instanceof DecimalProperty) {\n            return \"1.3579\";\n        } else if (property instanceof PasswordProperty) {\n            return \"********\";\n        } else if (property instanceof UUIDProperty) {\n            return \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\";\n        \/\/ do these last in case the specific types above are derived from these classes\n        } else if (property instanceof StringProperty) {\n            return \"aeiou\";\n        } else if (property instanceof BaseIntegerProperty) {\n            return \"123\";\n        } else if (property instanceof AbstractNumericProperty) {\n            return \"1.23\";\n        }\n        LOGGER.warn(\"default example value not implemented for \" + property);\n        return \"\";\n    }\n","new_comment_raw":"@param schema Schema to get example string for","old_comment_raw":"@param property Property to get example string for","label":1,"pre_label":0,"AST_level":16,"line_counts":34,"new_code_token_num":279},{"new_code_raw":"public static Point getCanvasTextLocation(Client client, Graphics2D graphics, LocalPoint localLocation, String text, int zOffset) { int plane = client.getPlane(); Point p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset); if (p == null) { return null; } FontMetrics fm = graphics.getFontMetrics(); Rectangle2D bounds = fm.getStringBounds(text, graphics); int xOffset = p.getX() - (int) (bounds.getWidth() \/ 2); return new Point(xOffset, p.getY()); }","old_code_raw":"\tpublic static Point getCanvasTextLocation(Client client, Graphics2D graphics, Point localLocation, String text, int zOffset)\n\t{\n\t\tint plane = client.getPlane();\n\n\t\tPoint p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset);\n\n\t\tif (p == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tFontMetrics fm = graphics.getFontMetrics();\n\t\tRectangle2D bounds = fm.getStringBounds(text, graphics);\n\t\tint xOffset = p.getX() - (int) (bounds.getWidth() \/ 2);\n\n\t\treturn new Point(xOffset, p.getY());\n\t}\n","new_comment_raw":"@param zOffset offset from ground plane","old_comment_raw":"@param zOffset offset from ground plane","label":0,"pre_label":1,"AST_level":8,"line_counts":18,"new_code_token_num":109},{"new_code_raw":"public Client testClassname(Client client) throws ApiException { return testClassnameWithHttpInfo(client).getData(); }","old_code_raw":"  public Client testClassname(Client body) throws ApiException {\n    return testClassnameWithHttpInfo(body).getData();\n      }\n","new_comment_raw":"@param client client model (required)","old_comment_raw":"@param body client model (required)","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"public String createFileName(URL url, String prefixSubstitute, String substituteReplacement) { File file = new File(directory_prefix + File.separator + url.getFile()); return file.getAbsolutePath().replaceAll(prefixSubstitute, substituteReplacement); }","old_code_raw":"    public String createFileName(URL url) {\n        File file = new File(directory_prefix + File.separator + url.getFile());\n\n        return file.getAbsolutePath();\n    }\n","new_comment_raw":"@param url URL of resource, which has been downloaded and shall be saved","old_comment_raw":"@param url DOCUMENT ME!","label":1,"pre_label":0,"AST_level":8,"line_counts":6,"new_code_token_num":43},{"new_code_raw":"public MultiIterator init(IteratorSource iteratorSource){ this.iteratorSource = iteratorSource; this.iterators = new Iterator<?>[sources.size()]; this.lastEntry = new boolean[iterators.length]; this.values = new Object[iterators.length]; return this; }","old_code_raw":"    public MultiIterator init(IndexSupport indexSupport){\n        this.indexSupport = indexSupport;\n        this.iterators = new Iterator<?>[sources.size()];\n        this.lastEntry = new boolean[iterators.length];\n        this.values = new Object[iterators.length];\n        return this;\n    }\n","new_comment_raw":"@param indexSupport","old_comment_raw":"@param indexSupport","label":0,"pre_label":1,"AST_level":7,"line_counts":8,"new_code_token_num":46},{"new_code_raw":"public int recordEvent(Document oplogEvent, Instant timestamp) throws InterruptedException { return recordEvent(oplogEvent, oplogEvent, timestamp, 0); }","old_code_raw":"        public int recordEvent(Document oplogEvent, long timestamp) throws InterruptedException {\n            return recordEvent(oplogEvent, oplogEvent, timestamp, 0);\n        }\n","new_comment_raw":"@param oplogEvent the event; may not be null","old_comment_raw":"@param oplogEvent the event; may not be null","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":26},{"new_code_raw":"public Single<Client> rxTestClassname(Client client) { return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> { delegate.testClassname(client, fut); })); }","old_code_raw":"    public Single<Client> rxTestClassname(Client body) {\n        return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> {\n            delegate.testClassname(body, fut);\n        }));\n    }\n","new_comment_raw":"@param client client model (required)","old_comment_raw":"@param body client model (required)","label":1,"pre_label":0,"AST_level":10,"line_counts":6,"new_code_token_num":36},{"new_code_raw":"public static MemberID parse(String memberID, boolean isClassMember) { return parse(memberID, isClassMember, null); }","old_code_raw":"    public static MemberID parse(String signature, boolean isClassMember) {\n        return parse(signature, isClassMember, null);\n    }\n","new_comment_raw":"@param isClassMember If the ID is ambiguous, if true always assume that the last simple member name is a method or field, else assume it is a class name.","old_comment_raw":"@param isClassMember If the signature is ambiguous, if true always assume that the last simple member name is a method or field, else assume it is a class name.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":23},{"new_code_raw":"public int[] findModified(Object[] old, Object[] current, Object entity, SharedSessionContractImplementor session) throws HibernateException { int[] props = TypeHelper.findModified( entityMetamodel.getProperties(), current, old, propertyColumnUpdateable, hasUninitializedLazyProperties( entity ), session ); if ( props == null ) { return null; } else { logDirtyProperties( props ); return props; } }","old_code_raw":"\tpublic int[] findModified(Object[] old, Object[] current, Object entity, SessionImplementor session)\n\t\t\tthrows HibernateException {\n\t\tint[] props = TypeHelper.findModified(\n\t\t\t\tentityMetamodel.getProperties(),\n\t\t\t\tcurrent,\n\t\t\t\told,\n\t\t\t\tpropertyColumnUpdateable,\n\t\t\t\thasUninitializedLazyProperties( entity ),\n\t\t\t\tsession\n\t\t);\n\t\tif ( props == null ) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tlogDirtyProperties( props );\n\t\t\treturn props;\n\t\t}\n\t}\n","new_comment_raw":"@param current The current state of the entity.","old_comment_raw":"@param current The current state of the entity.","label":0,"pre_label":1,"AST_level":7,"line_counts":19,"new_code_token_num":73},{"new_code_raw":"String evaluate(String url, String host) throws ScriptException { try { return (String) pacImpl.invokeFunction(\"FindProxyForURL\", url, host); } catch (NoSuchMethodException | ScriptAbuseException e) { throw new ScriptException(e); } }","old_code_raw":"    public String evaluate(String destURL, String destHost) throws ScriptException {\n        try {\n            return (String) pacImpl.invokeFunction(\"FindProxyForURL\", destURL, destHost);\n        } catch (NoSuchMethodException | ScriptAbuseException e) {\n            throw new ScriptException(e);\n        }\n    }\n","new_comment_raw":"@param url the url param of FindProxyForURL(url, host)","old_comment_raw":"@param destURL the url param of FindProxyForURL(url, host)","label":1,"pre_label":0,"AST_level":7,"line_counts":8,"new_code_token_num":48},{"new_code_raw":"public void redirectOutput(){ if (System.getenv(\"REDIRECT\") == null || !System.getenv(\"REDIRECT\").equals(\"true\")) { return; } String DEFAULT_OUT_TARGET_FILE = JStormUtils.getLogFileName(); if (DEFAULT_OUT_TARGET_FILE == null) { DEFAULT_OUT_TARGET_FILE = \"\/dev\/null\"; } else { DEFAULT_OUT_TARGET_FILE += \".out\"; } String outputFile = ConfigExtension.getWorkerRedirectOutputFile(workerData.getStormConf()); if (outputFile == null) { outputFile = DEFAULT_OUT_TARGET_FILE; }else { try { File file = new File(outputFile); if (file.exists() == false) { PathUtils.touch(outputFile); }else { if (file.isDirectory() == true) { LOG.warn(\"Failed to write \" + outputFile); outputFile = DEFAULT_OUT_TARGET_FILE; }else if (file.canWrite() == false) { LOG.warn(\"Failed to write \" + outputFile); outputFile = DEFAULT_OUT_TARGET_FILE; } } }catch(Exception e) { LOG.warn(\"Failed to touch \" + outputFile, e); outputFile = DEFAULT_OUT_TARGET_FILE; } } try { JStormUtils.redirectOutput(outputFile); }catch(Exception e) { LOG.warn(\"Failed to redirect to \" + outputFile, e); } }","old_code_raw":"\tpublic static void redirectOutput(String port) throws Exception {\n\n\t\tif (System.getenv(\"REDIRECT\") == null\n\t\t\t\t|| !System.getenv(\"REDIRECT\").equals(\"true\")) {\n\t\t\treturn;\n\t\t}\n\n\t\tString OUT_TARGET_FILE = JStormUtils.getLogFileName();\n\t\tif (OUT_TARGET_FILE == null) {\n\t\t\tOUT_TARGET_FILE = \"\/dev\/null\";\n\t\t} else {\n\t\t\tOUT_TARGET_FILE += \".out\";\n\t\t}\n\n\t\tJStormUtils.redirectOutput(OUT_TARGET_FILE);\n\n\t}\n","new_comment_raw":"@param port","old_comment_raw":"@param port","label":0,"pre_label":1,"AST_level":14,"line_counts":46,"new_code_token_num":229},{"new_code_raw":"public static DataFileReadResult decompress(byte[] b, int[] keys) { InputStream stream = new InputStream(b); int compression = stream.readUnsignedByte(); int compressedLength = stream.readInt(); if (compressedLength < 0 || compressedLength > 1000000) throw new RuntimeException(\"Invalid data\"); Crc32 crc32 = new Crc32(); crc32.update(b, 0, 5); \/\/ compression + length byte[] data; int revision = -1; switch (compression) { case CompressionType.NONE: { byte[] encryptedData = new byte[compressedLength]; stream.readBytes(encryptedData, 0, compressedLength); crc32.update(encryptedData, 0, compressedLength); byte[] decryptedData = decrypt(encryptedData, encryptedData.length, keys); if (stream.remaining() >= 2) { revision = stream.readUnsignedShort(); assert revision != -1; } data = decryptedData; break; } case CompressionType.BZ2: { byte[] encryptedData = new byte[compressedLength + 4]; stream.readBytes(encryptedData); crc32.update(encryptedData, 0, encryptedData.length); byte[] decryptedData = decrypt(encryptedData, encryptedData.length, keys); if (stream.remaining() >= 2) { revision = stream.readUnsignedShort(); assert revision != -1; } stream = new InputStream(decryptedData); int decompressedLength = stream.readInt(); data = BZip2.decompress(stream.getRemaining(), compressedLength); if (data == null) { return null; } assert data.length == decompressedLength; break; } case CompressionType.GZ: { byte[] encryptedData = new byte[compressedLength + 4]; stream.readBytes(encryptedData); crc32.update(encryptedData, 0, encryptedData.length); byte[] decryptedData = decrypt(encryptedData, encryptedData.length, keys); if (stream.remaining() >= 2) { revision = stream.readUnsignedShort(); assert revision != -1; } stream = new InputStream(decryptedData); int decompressedLength = stream.readInt(); data = GZip.decompress(stream.getRemaining(), compressedLength); if (data == null) { return null; } assert data.length == decompressedLength; break; } default: throw new RuntimeException(\"Unknown decompression type\"); } DataFileReadResult res = new DataFileReadResult(); res.data = data; res.revision = revision; int length = revision != -1 ? b.length - 2 : b.length;; res.crc = crc32.getHash(); res.whirlpool = Whirlpool.getHash(b, length); res.compression = compression; return res; }","old_code_raw":"\tpublic static DataFileReadResult decompress(byte[] b)\n\t{\n\t\tInputStream stream = new InputStream(b);\n\t\t\n\t\tint compression = stream.readUnsignedByte();\n\t\tint compressedLength = stream.readInt();\n\t\tif (compressedLength < 0 || compressedLength > 1000000)\n\t\t\tthrow new RuntimeException(\"Invalid data\");\n\t\t\n\t\tbyte[] data;\n\t\tint revision;\n\t\tswitch (compression)\n\t\t{\n\t\t\tcase CompressionType.NONE:\n\t\t\t\tdata = new byte[compressedLength];\n\t\t\t\trevision = checkRevision(stream, compressedLength);\n\t\t\t\tstream.readBytes(data, 0, compressedLength);\n\t\t\t\tbreak;\n\t\t\tcase CompressionType.BZ2:\n\t\t\t{\n\t\t\t\tint length = stream.readInt();\n\t\t\t\trevision = checkRevision(stream, compressedLength);\n\t\t\t\tdata = BZip2.decompress(stream.getRemaining(), compressedLength);\n\t\t\t\tassert data.length == length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CompressionType.GZ:\n\t\t\t{\n\t\t\t\tint length = stream.readInt();\n\t\t\t\trevision = checkRevision(stream, compressedLength);\n\t\t\t\tdata = GZip.decompress(stream.getRemaining(), compressedLength);\n\t\t\t\tassert data.length == length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new RuntimeException(\"Unknown decompression type\");\n\t\t}\n\t\t\n\t\tDataFileReadResult res = new DataFileReadResult();\n\t\tres.data = data;\n\t\tres.revision = revision;\n\t\tint length = revision != -1 ? b.length - 2 : b.length;\n\t\tres.crc = CRC32HGenerator.getHash(b, length);\n\t\tres.whirlpool = Whirlpool.getHash(b, length);\n\t\tres.compression = compression;\n\t\treturn res;\n\t}\n","new_comment_raw":"@param indexId expected index of archive of contents being read","old_comment_raw":"@param indexId","label":1,"pre_label":0,"AST_level":10,"line_counts":104,"new_code_token_num":469},{"new_code_raw":"public static MemberID parse(String memberID, boolean isClassMember) { return parse(memberID, isClassMember, null); }","old_code_raw":"    public static MemberID parse(String signature, boolean isClassMember) {\n        return parse(signature, isClassMember, null);\n    }\n","new_comment_raw":"@param memberID the memberID to parse.","old_comment_raw":"@param signature the signature to parse.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":23},{"new_code_raw":"public RelationalFunctionCall(Class<? extends T> type, String function, Object... args) { super(type); this.args = normalizeArgs(args); this.template = createTemplate(function, args.length); }","old_code_raw":"    public RelationalFunctionCall(Class<? extends T> type, String template, Expression<?>... args) {\n        super(type);\n        this.args = Arrays.asList(Assert.notNull(args,\"args\"));\n        this.template = TemplateFactory.DEFAULT.create(Assert.notNull(template,\"template\"));\n    }    \n","new_comment_raw":"@param function","old_comment_raw":"@param template","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":39},{"new_code_raw":"public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); final String url = buildUrl(path, queryParams); final Request.Builder reqBuilder = new Request.Builder().url(url); processHeaderParams(headerParams, reqBuilder); String contentType = (String) headerParams.get(\"Content-Type\"); \/\/ ensuring a default content type if (contentType == null) contentType = \"application\/json\"; RequestBody reqBody; if (!HttpMethod.permitsRequestBody(method)) { reqBody = null; } else if (\"application\/x-www-form-urlencoded\".equals(contentType)) { reqBody = buildRequestBodyFormEncoding(formParams); } else if (\"multipart\/form-data\".equals(contentType)) { reqBody = buildRequestBodyMultipart(formParams); } else if (body == null) { if (\"DELETE\".equals(method)) { \/\/ allow calling DELETE without sending a request body reqBody = null; } else { \/\/ use an empty request body (for POST, PUT and PATCH) reqBody = RequestBody.create(MediaType.parse(contentType), \"\"); } } else { reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType)); } Request request = reqBuilder.method(method, reqBody).build(); return httpClient.newCall(request); }","old_code_raw":"  public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    final String url = buildUrl(path, queryParams);\n    final Request.Builder reqBuilder = new Request.Builder().url(url);\n    processHeaderParams(headerParams, reqBuilder);\n\n    String contentType = (String) headerParams.get(\"Content-Type\");\n    \/\/ ensuring a default content type\n    if (contentType == null) {\n      contentType = \"application\/json\";\n    }\n\n    RequestBody reqBody;\n    if (!HttpMethod.permitsRequestBody(method)) {\n      reqBody = null;\n    } else if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n      reqBody = buildRequestBodyFormEncoding(formParams);\n    } else if (\"multipart\/form-data\".equals(contentType)) {\n      reqBody = buildRequestBodyMultipart(formParams);\n    } else if (body == null) {\n      if (\"DELETE\".equals(method)) {\n        \/\/ allow calling DELETE without sending a request body\n        reqBody = null;\n      } else {\n        \/\/ use an empty request body (for POST, PUT and PATCH)\n        reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n      }\n    } else {\n      reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType));\n    }\n\n    Request request = null;\n\n    if(progressRequestListener != null && reqBody != null) {\n      ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, progressRequestListener);\n      request = reqBuilder.method(method, progressRequestBody).build();\n    } else {\n      request = reqBuilder.method(method, reqBody).build();\n    }\n\n    return httpClient.newCall(request);\n  }\n","new_comment_raw":"@param authNames The authentications to apply","old_comment_raw":"@param authNames The authentications to apply","label":0,"pre_label":1,"AST_level":14,"line_counts":34,"new_code_token_num":285},{"new_code_raw":"public Boolean fakeOuterBooleanSerialize(Boolean booleanPostBody) throws ApiException { return fakeOuterBooleanSerializeWithHttpInfo(booleanPostBody).getData(); }","old_code_raw":"  public Boolean fakeOuterBooleanSerialize(Boolean body) throws ApiException {\n    return fakeOuterBooleanSerializeWithHttpInfo(body).getData();\n      }\n","new_comment_raw":"@param booleanPostBody Input boolean as post body (optional)","old_comment_raw":"@param body Input boolean as post body (optional)","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"public boolean waitForSpace(long timeout, int highWaterMark) throws InterruptedException { if (parent != null) { if (!parent.waitForSpace(timeout, highWaterMark)) { return false; } } synchronized (usageMutex) { percentUsage=caclPercentUsage(); if (percentUsage >= highWaterMark) { long deadline = timeout > 0 ? System.currentTimeMillis() + timeout : Long.MAX_VALUE; long timeleft = deadline; while (timeleft > 0) { percentUsage=caclPercentUsage(); if (percentUsage >= highWaterMark) { usageMutex.wait(pollingTime); timeleft = deadline - System.currentTimeMillis(); } else { break; } } } return percentUsage < highWaterMark; } }","old_code_raw":"    public boolean waitForSpace(long timeout) throws InterruptedException {\n        if (parent != null) {\n            if (!parent.waitForSpace(timeout)) {\n                return false;\n            }\n        }\n        synchronized (usageMutex) {\n            percentUsage=caclPercentUsage();\n            if (percentUsage >= 100) {\n                long deadline = timeout > 0 ? System.currentTimeMillis() + timeout : Long.MAX_VALUE;\n                long timeleft = deadline;\n                while (timeleft > 0) {\n                    percentUsage=caclPercentUsage();\n                    if (percentUsage >= 100) {\n                        usageMutex.wait(pollingTime);\n                        timeleft = deadline - System.currentTimeMillis();\n                    } else {\n                        break;\n                    }\n                }\n            }\n            return percentUsage < 100;\n        }\n    }\n","new_comment_raw":"@param timeout","old_comment_raw":"@param timeout","label":0,"pre_label":1,"AST_level":13,"line_counts":25,"new_code_token_num":117},{"new_code_raw":"public boolean waitForActivity(Class<? extends Activity> activityClass, int timeout){ final long endTime = SystemClock.uptimeMillis() + timeout; Activity currentActivity = activityUtils.getCurrentActivity(false); while(SystemClock.uptimeMillis() < endTime){ if(currentActivity != null && currentActivity.getClass().equals(activityClass)) return true; currentActivity = activityUtils.getCurrentActivity(); } return false; }","old_code_raw":"\tpublic boolean waitForActivity(Class<? extends Activity> clazz, int timeout){\n\t\tfinal long endTime = SystemClock.uptimeMillis() + timeout;\n\t\tActivity currentActivity = activityUtils.getCurrentActivity(false);\n\n\t\twhile(SystemClock.uptimeMillis() < endTime){\n\t\t\tif(currentActivity != null && currentActivity.getClass().equals(clazz))\n\t\t\t\treturn true;\n\n\t\t\tcurrentActivity = activityUtils.getCurrentActivity();\n\t\t}\n\t\treturn false;\n\t}\n","new_comment_raw":"@param timeout the amount of time in milliseconds to wait","old_comment_raw":"@param timeout the amount of time in milliseconds to wait","label":0,"pre_label":1,"AST_level":9,"line_counts":13,"new_code_token_num":71},{"new_code_raw":"public static QName getXSIType(Parameter param) { if (param.getMIMEType() != null) { return getMIMETypeQName(param.getMIMEType()); } QName xmlType = null; TypeEntry te = param.getType(); \/\/ If the TypeEntry describes an Element, get \/\/ the referenced Type. if (te != null && te instanceof Element && te.getRefType() != null) { te = te.getRefType(); } \/\/ If the TypeEntry is a CollectionType, use \/\/ the TypeEntry representing the component Type \/\/ So for example a parameter that takes a \/\/ collection type for \/\/ <element name=\"A\" type=\"xsd:string\" maxOccurs=\"unbounded\"\/> \/\/ will be \/\/ new ParameterDesc(<QName of A>, IN, \/\/ <QName of xsd:string>, \/\/ String[]) if (te != null && te instanceof CollectionType && te.getRefType() != null) { te = te.getRefType(); } if (te != null) { xmlType = te.getQName(); } return xmlType; }","old_code_raw":"    public static QName getXSIType(TypeEntry te) {\n        QName xmlType = null;\n\n        \/\/ If the TypeEntry describes an Element, get\n        \/\/ the referenced Type.\n        if (te != null &&\n            te instanceof Element &&\n            te.getRefType() != null) {\n            te = te.getRefType();\n        } \n        \/\/ If the TypeEntry is a CollectionType, use\n        \/\/ the TypeEntry representing the component Type\n        \/\/ So for example a parameter that takes a \n        \/\/ collection type for\n        \/\/ <element name=\"A\" type=\"xsd:string\" maxOccurs=\"unbounded\"\/>\n        \/\/ will be \n        \/\/ new ParameterDesc(<QName of A>, IN,\n        \/\/                   <QName of xsd:string>,\n        \/\/                   String[])\n        if (te != null &&\n            te instanceof CollectionType &&\n            te.getRefType() != null) {\n            te = te.getRefType();\n        }\n        if (te != null) {\n            xmlType = te.getQName();\n        }\n        return xmlType;\n    }\n","new_comment_raw":"@param param is a parameter","old_comment_raw":"@param te is the typeEntry from the Parameters object, which represents the parameter","label":1,"pre_label":0,"AST_level":7,"line_counts":36,"new_code_token_num":207},{"new_code_raw":"public static Schema unaliasSchema(OpenAPI openAPI, Schema schema) { Map<String, Schema> allSchemas = getSchemas(openAPI); if (allSchemas == null || allSchemas.isEmpty()) { \/\/ skip the warning as the spec can have no model defined \/\/LOGGER.warn(\"allSchemas cannot be null\/empty in unaliasSchema. Returned 'schema'\"); return schema; } if (schema != null && StringUtils.isNotEmpty(schema.get$ref())) { Schema ref = allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())); if (ref == null) { LOGGER.warn(\"{} is not defined\", schema.get$ref()); return schema; } else if (ref.getEnum() != null && !ref.getEnum().isEmpty()) { \/\/ top-level enum class return schema; } else if (isArraySchema(ref)) { if (generateAliasAsModel) { return schema; \/\/ generate a model extending array } else { return unaliasSchema(openAPI, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()))); } } else if (isComposedSchema(ref)) { return schema; } else if (isMapSchema(ref)) { if (ref.getProperties() != null && !ref.getProperties().isEmpty()) \/\/ has at least one property return schema; \/\/ treat it as model else { if (generateAliasAsModel) { return schema; \/\/ generate a model extending map } else { \/\/ treat it as a typical map return unaliasSchema(openAPI, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()))); } } } else if (isObjectSchema(ref)) { \/\/ model if (ref.getProperties() != null && !ref.getProperties().isEmpty()) { \/\/ has at least one property return schema; } else { \/\/ free form object (type: object) return unaliasSchema(openAPI, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()))); } } else { return unaliasSchema(openAPI, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()))); } } return schema; }","old_code_raw":"    public static Schema unaliasSchema(Map<String, Schema> allSchemas, Schema schema) {\n        if (allSchemas == null || allSchemas.isEmpty()) {\n            \/\/ skip the warning as the spec can have no model defined\n            \/\/LOGGER.warn(\"allSchemas cannot be null\/empty in unaliasSchema. Returned 'schema'\");\n            return schema;\n        }\n\n        if (schema != null && StringUtils.isNotEmpty(schema.get$ref())) {\n            Schema ref = allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()));\n            if (ref == null) {\n                LOGGER.warn(\"{} is not defined\", schema.get$ref());\n                return schema;\n            } else if (ref.getEnum() != null && !ref.getEnum().isEmpty()) {\n                \/\/ top-level enum class\n                return schema;\n            } else if (isArraySchema(ref)) {\n                if (generateAliasAsModel) {\n                    return schema; \/\/ generate a model extending array\n                } else {\n                    return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));\n                }\n            } else if (isComposedSchema(ref)) {\n                return schema;\n            } else if (isMapSchema(ref)) {\n                if (ref.getProperties() != null && !ref.getProperties().isEmpty()) \/\/ has at least one property\n                    return schema; \/\/ treat it as model\n                else {\n                    if (generateAliasAsModel) {\n                        return schema; \/\/ generate a model extending map\n                    } else {\n                        \/\/ treat it as a typical map\n                        return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));\n                    }\n                }\n            } else if (isObjectSchema(ref)) { \/\/ model\n                if (ref.getProperties() != null && !ref.getProperties().isEmpty()) { \/\/ has at least one property\n                    return schema;\n                } else { \/\/ free form object (type: object)\n                    return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));\n                }\n            } else {\n                return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));\n            }\n        }\n        return schema;\n    }\n","new_comment_raw":"@param openAPI specification being checked","old_comment_raw":"@param allSchemas all schemas","label":1,"pre_label":0,"AST_level":19,"line_counts":48,"new_code_token_num":435},{"new_code_raw":"public static EBoolean endsWith(Expr<String> left, String right) { return operationFactory.createBoolean(Ops.ENDSWITH, left, exprFactory .createConstant(right)); }","old_code_raw":"    public static EBoolean endsWith(Expr<String> left, String right, boolean caseSensitive) {\n        if (caseSensitive){\n            return endsWith(left, right);            \n        }else{\n            return operationFactory.createBoolean(Ops.ENDSWITH_IC, left, exprFactory.createConstant(right));\n        }                \n    }\n","new_comment_raw":"@param left","old_comment_raw":"@param left","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":30},{"new_code_raw":"public static DownloadRequest createDownloadRequest(String url, RequestMethod requestMethod, String fileFolder, String filename, boolean isRange, boolean isDeleteOld) { return new RestDownloadRequestor(url, requestMethod, fileFolder, filename, isRange, isDeleteOld); }","old_code_raw":"    public static DownloadRequest createDownloadRequest(String url, RequestMethod requestMethod, String fileFloder, String filename, boolean isRange, boolean isDeleteOld) {\n        return new RestDownloadRequestor(url, requestMethod, fileFloder, filename, isRange, isDeleteOld);\n    }\n","new_comment_raw":"@param fileFolder Folder to save file","old_comment_raw":"@param fileFloder Folder to save file","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":42},{"new_code_raw":"private ColumnState buildSimpleList(ContainerState parent, ColumnReadProjection colProj) { ColumnMetadata columnSchema = colProj.providedSchema(); \/\/ The variant must have the one and only type. assert columnSchema.variantSchema().size() == 1; assert columnSchema.variantSchema().isSimple(); \/\/ Create the manager for the one and only column within the list. final ListState listState = new ListState(parent.loader(), parent.vectorCache().childCache(columnSchema.name())); \/\/ Create the child vector, writer and state. final ColumnMetadata memberSchema = columnSchema.variantSchema().listSubtype(); final ColumnState memberState = buildColumn(listState, memberSchema); listState.setSubColumn(memberState); \/\/ Create the list vector. Contains a single type. final ListVector listVector = new ListVector(columnSchema.schema().cloneEmpty(), parent.loader().allocator(), null); listVector.setChildVector(memberState.vector()); \/\/ Create the list writer: an array of the one type. final ListWriterImpl listWriter = new ListWriterImpl(columnSchema, listVector, memberState.writer()); final AbstractObjectWriter listObjWriter = new ArrayObjectWriter(listWriter); \/\/ Create the list vector state that tracks the list vector lifecycle. final ListVectorState vectorState = new ListVectorState(listWriter, memberState.writer().events(), listVector); \/\/ Assemble it all into a union column state. return new UnionColumnState(parent.loader(), listObjWriter, vectorState, listState); }","old_code_raw":"  private ColumnState buildSimpleList(ContainerState parent, ColumnTransform outputCol) {\n    ColumnMetadata columnSchema = outputCol.outputSchema();\n\n    \/\/ The variant must have the one and only type.\n\n    assert columnSchema.variantSchema().size() == 1;\n    assert columnSchema.variantSchema().isSimple();\n\n    \/\/ Create the manager for the one and only column within the list.\n\n    final ListState listState = new ListState(parent.loader(),\n        parent.vectorCache().childCache(columnSchema.name()),\n        new ImpliedTupleRequest(true));\n\n    \/\/ Create the child vector, writer and state.\n\n    final ColumnMetadata memberSchema = columnSchema.variantSchema().listSubtype();\n    final ColumnState memberState = buildColumn(listState, memberSchema);\n    listState.setSubColumn(memberState);\n\n    \/\/ Create the list vector. Contains a single type.\n\n    final ListVector listVector = new ListVector(columnSchema.schema().cloneEmpty(),\n        parent.loader().allocator(), null);\n    listVector.setChildVector(memberState.vector());\n\n    \/\/ Create the list writer: an array of the one type.\n\n    final ListWriterImpl listWriter = new ListWriterImpl(columnSchema,\n        listVector, memberState.writer());\n    final AbstractObjectWriter listObjWriter = new ArrayObjectWriter(listWriter);\n\n    \/\/ Create the list vector state that tracks the list vector lifecycle.\n\n    final ListVectorState vectorState = new ListVectorState(listWriter,\n        memberState.writer().events(), listVector);\n\n    \/\/ Assemble it all into a union column state.\n\n    return new UnionColumnState(parent.loader(),\n        listObjWriter, vectorState, listState);\n  }\n","new_comment_raw":"@param parent the parent (tuple, union or list) that holds this list","old_comment_raw":"@param parent the parent (tuple, union or list) that holds this list","label":0,"pre_label":1,"AST_level":8,"line_counts":42,"new_code_token_num":264},{"new_code_raw":"public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws ApiException { Object localVarPostBody = null; \/\/ verify the required parameter 'petId' is set if (petId == null) { throw new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\"); } \/\/ verify the required parameter 'requiredFile' is set if (requiredFile == null) { throw new ApiException(400, \"Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile\"); } \/\/ create path and map variables String localVarPath = \"\/fake\/{petId}\/uploadImageWithRequiredFile\" .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString())); \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); if (additionalMetadata != null) localVarFormParams.put(\"additionalMetadata\", additionalMetadata); if (requiredFile != null) localVarFormParams.put(\"requiredFile\", requiredFile); final String[] localVarAccepts = { \"application\/json\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { \"multipart\/form-data\" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { \"petstore_auth\" }; GenericType<ModelApiResponse> localVarReturnType = new GenericType<ModelApiResponse>() {}; return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public ModelApiResponse uploadFileWithRequiredFile(Long petId, File file, String additionalMetadata) throws ApiException {\n    Object localVarPostBody = null;\n    \n    \/\/ verify the required parameter 'petId' is set\n    if (petId == null) {\n      throw new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\");\n    }\n    \n    \/\/ verify the required parameter 'file' is set\n    if (file == null) {\n      throw new ApiException(400, \"Missing the required parameter 'file' when calling uploadFileWithRequiredFile\");\n    }\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/fake\/{petId}\/uploadImageWithRequiredFile\"\n      .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString()));\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    if (additionalMetadata != null)\n      localVarFormParams.put(\"additionalMetadata\", additionalMetadata);\nif (file != null)\n      localVarFormParams.put(\"file\", file);\n\n    final String[] localVarAccepts = {\n      \"application\/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"multipart\/form-data\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] { \"petstore_auth\" };\n\n    GenericType<ModelApiResponse> localVarReturnType = new GenericType<ModelApiResponse>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@param requiredFile file to upload (required)","old_comment_raw":"@param file file to upload (required)","label":1,"pre_label":0,"AST_level":9,"line_counts":46,"new_code_token_num":324},{"new_code_raw":"public TableSchema create(String schemaPrefix, String envelopSchemaName, Table table, ColumnNameFilter filter, ColumnMappers mappers, KeyMapper keysMapper) { if (schemaPrefix == null) { schemaPrefix = \"\"; } \/\/ Build the schemas ... final TableId tableId = table.id(); final String tableIdStr = tableSchemaName(tableId); final String schemaNamePrefix = schemaPrefix + tableIdStr; LOGGER.debug(\"Mapping table '{}' to schemas under '{}'\", tableId, schemaNamePrefix); SchemaBuilder valSchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Value\")); SchemaBuilder keySchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Key\")); AtomicBoolean hasPrimaryKey = new AtomicBoolean(false); Key tableKey = new Key.Builder(table).customKeyMapper(keysMapper).build(); tableKey.keyColumns().forEach(column -> { addField(keySchemaBuilder, column, null); hasPrimaryKey.set(true); }); table.columns() .stream() .filter(column -> filter == null || filter.matches(tableId.catalog(), tableId.schema(), tableId.table(), column.name())) .forEach(column -> { ColumnMapper mapper = mappers == null ? null : mappers.mapperFor(tableId, column); addField(valSchemaBuilder, column, mapper); }); Schema valSchema = valSchemaBuilder.optional().build(); Schema keySchema = hasPrimaryKey.get() ? keySchemaBuilder.build() : null; if (LOGGER.isDebugEnabled()) { LOGGER.debug(\"Mapped primary key for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(keySchema)); LOGGER.debug(\"Mapped columns for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(valSchema)); } Envelope envelope = Envelope.defineSchema() .withName(schemaNameAdjuster.adjust(envelopSchemaName)) .withRecord(valSchema) .withSource(sourceInfoSchema) .build(); \/\/ Create the generators ... Function<Object[], Object> keyGenerator = createKeyGenerator(keySchema, tableId, tableKey.keyColumns()); Function<Object[], Struct> valueGenerator = createValueGenerator(valSchema, tableId, table.columns(), filter, mappers); \/\/ And the table schema ... return new TableSchema(tableId, keySchema, keyGenerator, envelope, valSchema, valueGenerator); }","old_code_raw":"    public TableSchema create(String schemaPrefix, String envelopSchemaName, Table table, ColumnNameFilter filter, ColumnMappers mappers, CustomKeyMapper keysMapper) {\n        if (schemaPrefix == null) {\n            schemaPrefix = \"\";\n        }\n\n        \/\/ Build the schemas ...\n        final TableId tableId = table.id();\n        final String tableIdStr = tableSchemaName(tableId);\n        final String schemaNamePrefix = schemaPrefix + tableIdStr;\n        LOGGER.debug(\"Mapping table '{}' to schemas under '{}'\", tableId, schemaNamePrefix);\n        SchemaBuilder valSchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Value\"));\n        SchemaBuilder keySchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Key\"));\n        AtomicBoolean hasPrimaryKey = new AtomicBoolean(false);\n        \n        Key tableKey = new Key.Builder(table).customKeyMapper(keysMapper).build();\n        tableKey.keyColumns().forEach(column -> {\n            addField(keySchemaBuilder, column, null);\n            hasPrimaryKey.set(true);\n        });\n        \n        table.columns()\n            .stream()\n            .filter(column -> filter == null || filter.matches(tableId.catalog(), tableId.schema(), tableId.table(), column.name()))\n            .forEach(column -> {\n                ColumnMapper mapper = mappers == null ? null : mappers.mapperFor(tableId, column);\n                addField(valSchemaBuilder, column, mapper);\n            });\n        \n        Schema valSchema = valSchemaBuilder.optional().build();\n        Schema keySchema = hasPrimaryKey.get() ? keySchemaBuilder.build() : null;\n\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"Mapped primary key for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(keySchema));\n            LOGGER.debug(\"Mapped columns for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(valSchema));\n        }\n\n        Envelope envelope = Envelope.defineSchema()\n                .withName(schemaNameAdjuster.adjust(envelopSchemaName))\n                .withRecord(valSchema)\n                .withSource(sourceInfoSchema)\n                .build();\n\n\n        \/\/ Create the generators ...\n        Function<Object[], Object> keyGenerator = createKeyGenerator(keySchema, tableId, tableKey.keyColumns());\n        Function<Object[], Struct> valueGenerator = createValueGenerator(valSchema, tableId, table.columns(), filter, mappers);\n\n        \/\/ And the table schema ...\n        return new TableSchema(tableId, keySchema, keyGenerator, envelope, valSchema, valueGenerator);\n    }\n","new_comment_raw":"@param schemaPrefix the prefix added to the table identifier to construct the schema names; may be null if there is no prefix","old_comment_raw":"@param schemaPrefix the prefix added to the table identifier to construct the schema names; may be null if there is no prefix","label":0,"pre_label":1,"AST_level":11,"line_counts":51,"new_code_token_num":433},{"new_code_raw":"public static boolean canEdit(Permissions perms, Permissions user2Perms) { if(isAdmin(perms)) return true; if(isAdmin(user2Perms)) return false; return getManagementLevel(perms) > getManagementLevel(user2Perms); }","old_code_raw":"\tpublic static boolean canEdit(User manager, User toEdit)\r\n\t{\r\n\t\tif(isAdmin(manager))\r\n\t\t\treturn true;\r\n\t\tif(isAdmin(toEdit))\r\n\t\t\treturn false;\r\n\r\n\t\treturn getManagementLevel(manager) > getManagementLevel(toEdit);\r\n\t}\r\n","new_comment_raw":"@param perms The permissions of the user trying to edit the given user","old_comment_raw":"@param manager The manager user (the one accessing the application)","label":1,"pre_label":0,"AST_level":6,"line_counts":11,"new_code_token_num":43},{"new_code_raw":"private void constructFragmentDependencyGraph(Fragment rootFragment, PlanningSet planningSet) { \/\/ Set up dependency of fragments based on the affinity of exchange that separates the fragments. for(Wrapper currentFragment : planningSet) { ExchangeFragmentPair sendingXchgForCurrFrag = currentFragment.getNode().getSendingExchangePair(); if (sendingXchgForCurrFrag != null) { ParallelizationDependency dependency = sendingXchgForCurrFrag.getExchange().getParallelizationDependency(); Wrapper receivingFragmentWrapper = planningSet.get(sendingXchgForCurrFrag.getNode()); \/\/Mostly Receivers of the current fragment depend on the sender of the child fragments. However there is a special case \/\/for DeMux Exchanges where the Sender of the current fragment depends on the receiver of the parent fragment. if (dependency == ParallelizationDependency.RECEIVER_DEPENDS_ON_SENDER) { receivingFragmentWrapper.addFragmentDependency(currentFragment); } else if (dependency == ParallelizationDependency.SENDER_DEPENDS_ON_RECEIVER) { currentFragment.addFragmentDependency(receivingFragmentWrapper); } } } planningSet.findRootWrapper(rootFragment); }","old_code_raw":"  private static Set<Wrapper> constructFragmentDependencyGraph(PlanningSet planningSet) {\n\n    \/\/ Set up dependency of fragments based on the affinity of exchange that separates the fragments.\n    for (Wrapper currentFragmentWrapper : planningSet) {\n      ExchangeFragmentPair sendingExchange = currentFragmentWrapper.getNode().getSendingExchangePair();\n      if (sendingExchange != null) {\n        ParallelizationDependency dependency = sendingExchange.getExchange().getParallelizationDependency();\n        Wrapper receivingFragmentWrapper = planningSet.get(sendingExchange.getNode());\n\n        if (dependency == ParallelizationDependency.RECEIVER_DEPENDS_ON_SENDER) {\n          receivingFragmentWrapper.addFragmentDependency(currentFragmentWrapper);\n        } else if (dependency == ParallelizationDependency.SENDER_DEPENDS_ON_RECEIVER) {\n          currentFragmentWrapper.addFragmentDependency(receivingFragmentWrapper);\n        }\n      }\n    }\n\n    \/\/ Identify leaf fragments. Leaf fragments are fragments that have no other fragments depending on them for\n    \/\/ parallelization info. First assume all fragments are leaf fragments. Go through the fragments one by one and\n    \/\/ remove the fragment on which the current fragment depends.\n\n    final Set<Wrapper> roots = Sets.newHashSet();\n    for (Wrapper w : planningSet) {\n      roots.add(w);\n    }\n\n    for (Wrapper wrapper : planningSet) {\n      final List<Wrapper> fragmentDependencies = wrapper.getFragmentDependencies();\n      if (fragmentDependencies != null && fragmentDependencies.size() > 0) {\n        for (Wrapper dependency : fragmentDependencies) {\n          if (roots.contains(dependency)) {\n            roots.remove(dependency);\n          }\n        }\n      }\n    }\n\n    return roots;\n  }\n","new_comment_raw":"@param planningSet","old_comment_raw":"@param planningSet","label":0,"pre_label":1,"AST_level":12,"line_counts":21,"new_code_token_num":154},{"new_code_raw":"public Struct update(Object before, Struct after, Struct source, Long timestamp) { Struct struct = new Struct(schema); struct.put(FieldName.OPERATION, Operation.UPDATE.code()); if (before != null) struct.put(FieldName.BEFORE, before); struct.put(FieldName.AFTER, after); if (source != null) struct.put(FieldName.SOURCE, source); if (timestamp != null) struct.put(FieldName.TIMESTAMP, timestamp); return struct; }","old_code_raw":"    public Struct update(Struct before, Struct after, Struct source, Long timestamp) {\n        Struct struct = new Struct(schema);\n        struct.put(FieldName.OPERATION, Operation.UPDATE.code());\n        if (before != null) struct.put(FieldName.BEFORE, before);\n        struct.put(FieldName.AFTER, after);\n        if (source != null) struct.put(FieldName.SOURCE, source);\n        if (timestamp != null) struct.put(FieldName.TIMESTAMP, timestamp);\n        return struct;\n    }\n","new_comment_raw":"@param before the state of the record before the update; may be null","old_comment_raw":"@param before the state of the record before the update; may be null","label":0,"pre_label":1,"AST_level":6,"line_counts":10,"new_code_token_num":96},{"new_code_raw":"long getLoad(MigratableHandler handler) { return handlerLoadCounter.get(handler); }","old_code_raw":"    long getLoad(MigratablePipeline pipeline) {\n        return handlerLoadCounter.get(pipeline);\n    }\n","new_comment_raw":"@param handler","old_comment_raw":"@param pipeline","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":15},{"new_code_raw":"private RectF drawBoxWithShadow(Canvas c, Paint p, int width, int height) { Resources res = mContext.getResources(); float shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur); float keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance); float corner = res.getDimension(R.dimen.widget_preview_corner_radius); RectF bounds = new RectF(shadowBlur, shadowBlur, width - shadowBlur, height - shadowBlur - keyShadowDistance); p.setColor(Color.WHITE); \/\/ Key shadow p.setShadowLayer(shadowBlur, 0, keyShadowDistance, ShadowGenerator.KEY_SHADOW_ALPHA << 24); c.drawRoundRect(bounds, corner, corner, p); \/\/ Ambient shadow p.setShadowLayer(shadowBlur, 0, 0, ColorUtils.setAlphaComponent(Color.BLACK, ShadowGenerator.AMBIENT_SHADOW_ALPHA)); c.drawRoundRect(bounds, corner, corner, p); p.clearShadowLayer(); return bounds; }","old_code_raw":"    private RectF drawBoxWithShadow(Canvas c, int width, int height) {\n        Resources res = mContext.getResources();\n\n        ShadowGenerator.Builder builder = new ShadowGenerator.Builder(Color.WHITE);\n        builder.shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur);\n        builder.radius = res.getDimension(R.dimen.widget_preview_corner_radius);\n        builder.keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance);\n\n        builder.bounds.set(builder.shadowBlur, builder.shadowBlur,\n                width - builder.shadowBlur,\n                height - builder.shadowBlur - builder.keyShadowDistance);\n        builder.drawShadow(c);\n        return builder.bounds;\n    }\n","new_comment_raw":"@param launcher","old_comment_raw":"@param launcher","label":0,"pre_label":1,"AST_level":8,"line_counts":24,"new_code_token_num":156},{"new_code_raw":"public DateTime withPeriodAdded(ReadablePeriod period, int scalar) { if (period == null || scalar == 0) { return this; } long instant = getChronology().add(getMillis(), period, scalar); return withMillis(instant); }","old_code_raw":"    public DateTime withPeriodAdded(ReadablePeriod periodToAdd, int scalar) {\n        if (periodToAdd == null || scalar == 0) {\n            return this;\n        }\n        long instant = periodToAdd.addTo(getMillis(), scalar, getChronology());\n        return withMillis(instant);\n    }\n","new_comment_raw":"@param period the period to add to this one, null means zero","old_comment_raw":"@param periodToAdd the period to add to this one, null means zero","label":1,"pre_label":0,"AST_level":7,"line_counts":8,"new_code_token_num":48},{"new_code_raw":"public static EBoolean isNotEmpty(EMap<?,?> map) { return operationFactory.createBoolean(Ops.MAP_ISNOTEMPTY,(Expr<?>) map); }","old_code_raw":"    public static EBoolean isNotEmpty(PMap<?,?> map) {\n        return operationFactory.createBoolean(Ops.MAP_ISNOTEMPTY,(Expr<?>) map);\n    }\n","new_comment_raw":"@param collection","old_comment_raw":"@param collection","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":27},{"new_code_raw":"public WebElement searchForWebElement(final By by, int minimumNumberOfMatches, int timeout, boolean scroll){ if(minimumNumberOfMatches < 1){ minimumNumberOfMatches = 1; } List<WebElement> viewsFromScreen = webUtils.getCurrentWebElements(by); addViewsToList (webElements, viewsFromScreen); return getViewFromList(webElements, minimumNumberOfMatches); }","old_code_raw":"\tpublic WebElement searchForWebElement(final By by, int match, int timeout, boolean scroll){\n\n\t\tif(match < 1){\n\t\t\tmatch = 1;\n\t\t}\n\n\t\tList<WebElement> viewsFromScreen = webUtils.getCurrentWebElements(by);\n\t\taddViewsToList (webElements, viewsFromScreen);\n\n\t\treturn getViewFromList(webElements, match);\n\t}\n","new_comment_raw":"@param by the By object e.g. By.id(\"id\");","old_comment_raw":"@param by the By object e.g. By.id(\"id\");","label":0,"pre_label":1,"AST_level":7,"line_counts":12,"new_code_token_num":53},{"new_code_raw":"public Field withValidation(Validator... validators) { Validator actualValidator = validator; for (Validator validator : validators) { if (validator != null) actualValidator = validator.and(actualValidator); } return new Field(name(), displayName(), type(), width(), description(), importance(), dependents, defaultValueGenerator, actualValidator, recommender); }","old_code_raw":"    public Field withValidation(Predicate<String>... predicates) {\n        return new Field(name(), description(), defaultValueGenerator, (config, field, problems) -> {\n            String value = config.getString(field);\n            for (Predicate<String> predicate : predicates) {\n                if (predicate != null) {\n                    try {\n                        if (!predicate.test(value)) {\n                            problems.accept(\"The \" + field.name() + \" value '\" + value + \"' is not valid\");\n                            return 1;\n                        }\n                    } catch (Throwable t) {\n                        problems.accept(\"The \" + field.name() + \" value '\" + value + \"' is not allowed: \" + t.getMessage());\n                        return 1;\n                    }\n                }\n            }\n            return 0;\n        });\n    }\n","new_comment_raw":"@param validators the additional validation function(s); may be null","old_comment_raw":"@param predicates the functions that attempt to validate the object; may be null","label":1,"pre_label":0,"AST_level":9,"line_counts":9,"new_code_token_num":72},{"new_code_raw":"protected SourceInfo update(Long lsn, Instant commitTime, Long txId, TableId tableId) { this.lsn = lsn; this.useconds = Conversions.toEpochMicros(commitTime); this.txId = txId; if (tableId != null && tableId.schema() != null) { this.schemaName = tableId.schema(); } if (tableId != null && tableId.table() != null) { this.tableName = tableId.table(); } return this; }","old_code_raw":"    protected SourceInfo update(Long lsn, Long useconds, Long txId, TableId tableId) {\n        this.lsn = lsn;\n        this.useconds = useconds;\n        this.txId = txId;\n        if (tableId != null && tableId.schema() != null) {\n            this.schemaName = tableId.schema();\n        }\n        if (tableId != null && tableId.table() != null) {\n            this.tableName = tableId.table();\n        }\n        return this;\n    }\n","new_comment_raw":"@param txId the ID of the transaction that generated the transaction; may be null if this information nis not available","old_comment_raw":"@param txId the ID of the transaction that generated the transaction; may be null if this information nis not available","label":0,"pre_label":1,"AST_level":8,"line_counts":13,"new_code_token_num":83},{"new_code_raw":"private List<HttpCookie> prepareCookies(String uriS) { if (parent.getSpiderParam().isSendCookies()) { java.net.URI uri = null; try { uri = new java.net.URI(uriS); } catch (URISyntaxException e) { log.error(\"Error while preparing cookies. \", e); } return parent.getCookieManager().getCookieStore().get(uri); } return null; }","old_code_raw":"\tprivate List<HttpCookie> prepareCookies(HttpMessage msg) {\n\t\tif (parent.getSpiderParam().isSendCookies()) {\n\t\t\tjava.net.URI uri = null;\n\t\t\ttry {\n\t\t\t\turi = new java.net.URI(msg.getRequestHeader().getURI().toString());\n\t\t\t} catch (URISyntaxException e) {\n\t\t\t\tlog.error(\"Error while preparing cookies. \", e);\n\t\t\t}\n\t\t\treturn parent.getCookieManager().getCookieStore().get(uri);\n\t\t}\n\t\treturn null;\n\t}\n","new_comment_raw":"@param uriS the uri","old_comment_raw":"@param msg the response message where the uri was found","label":1,"pre_label":0,"AST_level":11,"line_counts":13,"new_code_token_num":76},{"new_code_raw":"public Action timedout(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException { logger.trace(\"Timing out {}\", req); if (trackActiveRequest(req) && completeLifecycle(req.resource(), false)) { config.framework().notify(Action.TYPE.TIMEOUT, req, res); } return timedoutAction; }","old_code_raw":"    public Action timedout(AtmosphereRequest request, AtmosphereResponse response)\n            throws IOException, ServletException {\n\n        AtmosphereResourceImpl r = null;\n\n        try {\n            SessionTimeoutSupport.restoreTimeout(request);\n\n            if (trackActiveRequest) {\n                long l = (Long) request.getAttribute(MAX_INACTIVE);\n                if (l == -1) {\n                    \/\/ The closedDetector closed the connection.\n                    return timedoutAction;\n                }\n                request.setAttribute(MAX_INACTIVE, (long) -1);\n            }\n\n            logger.debug(\"Timing out the connection for request {}\", request);\n\n            \/\/ Something went wrong.\n            if (request == null || response == null) {\n                logger.warn(\"Invalid Request\/Response: {}\/{}\", request, response);\n                return timedoutAction;\n            }\n\n            r = (AtmosphereResourceImpl) request.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE);\n\n            if (r != null && r.isCancelled()) {\n                return cancelledAction;\n            }\n\n            if (r == null) {\n                logger.debug(\"AtmosphereResource was null, failed to timeout AtmosphereRequest {}\", request);\n            }\n\n            if (r != null && r.getAtmosphereResourceEvent().isSuspended()) {\n                r.getAtmosphereResourceEvent().setIsResumedOnTimeout(true);\n\n                Broadcaster b = r.getBroadcaster();\n                if (b instanceof DefaultBroadcaster) {\n                    ((DefaultBroadcaster) b).broadcastOnResume(r);\n                }\n\n                if (request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT) != null) {\n                    r.getAtmosphereResourceEvent().setIsResumedOnTimeout(\n                            (Boolean) request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT));\n                }\n\n                invokeAtmosphereHandler(r);\n            }\n        } catch (Throwable t) {\n            logger.error(\"failed to timeout resource {}\", r, t);\n        } finally {\n            config.framework().notify(Action.TYPE.TIMEOUT, request, response);\n            try {\n                if (r != null) {\n                    r.notifyListeners();\n                    r.setIsInScope(false);\n                    r.cancel();\n                }\n            } catch (Throwable t) {\n                logger.trace(\"timedout\", t);\n            } finally {\n                try {\n                    response.getOutputStream().close();\n                } catch (Throwable t) {\n                    try {\n                        response.getWriter().close();\n                    } catch (Throwable t2) {\n                    }\n                }\n\n                if (r != null) {\n                    r._destroy();\n                }\n            }\n        }\n\n        return timedoutAction;\n    }\n","new_comment_raw":"@param res the  AtmosphereResponse","old_comment_raw":"@param response the AtmosphereResponse","label":1,"pre_label":0,"AST_level":8,"line_counts":10,"new_code_token_num":67},{"new_code_raw":"public static Token seek(Parser parser, String path) { \/\/ return current token if no path is given if (!StringUtils.hasText(path)) { return null; } List<String> tokens = StringUtils.tokenize(path, \".\"); return seek(parser, tokens.toArray(new String[tokens.size()])); }","old_code_raw":"    public static Token seek(String path, Parser parser) {\n        \/\/ return current token if no path is given\n        if (!StringUtils.hasText(path)) {\n            return null;\n        }\n\n        List<String> tokens = StringUtils.tokenize(path, \".\");\n        return seek(parser, tokens.toArray(new String[tokens.size()]));\n    }\n","new_comment_raw":"@param parser","old_comment_raw":"@param parser","label":0,"pre_label":1,"AST_level":7,"line_counts":10,"new_code_token_num":68},{"new_code_raw":"public static Properties getPartitionMetadata(final HivePartition partition, final HiveTableWithColumnCache table) { final Properties properties; restoreColumns(table, partition); properties = MetaStoreUtils.getPartitionMetadata(partition, table); \/\/ SerDe expects properties from Table, but above call doesn't add Table properties. \/\/ Include Table properties in final list in order to not to break SerDes that depend on \/\/ Table properties. For example AvroSerDe gets the schema from properties (passed as second argument) for (Map.Entry<String, String> entry : table.getParameters().entrySet()) { if (entry.getKey() != null && entry.getKey() != null) { properties.put(entry.getKey(), entry.getValue()); } } return properties; }","old_code_raw":"  public static Properties getPartitionMetadata(final Partition partition, final Table table) {\n    final Properties properties = MetaStoreUtils.getPartitionMetadata(partition, table);\n\n    \/\/ SerDe expects properties from Table, but above call doesn't add Table properties.\n    \/\/ Include Table properties in final list in order to not to break SerDes that depend on\n    \/\/ Table properties. For example AvroSerDe gets the schema from properties (passed as second argument)\n    for (Map.Entry<String, String> entry : table.getParameters().entrySet()) {\n      if (entry.getKey() != null && entry.getKey() != null) {\n        properties.put(entry.getKey(), entry.getValue());\n      }\n    }\n\n    return properties;\n  }\n","new_comment_raw":"@param table the source of table level parameters","old_comment_raw":"@param table","label":1,"pre_label":0,"AST_level":9,"line_counts":17,"new_code_token_num":143},{"new_code_raw":"public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws RestClientException { Object postBody = new Object(); \/\/ verify the required parameter 'petId' is set if (petId == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\"); } \/\/ verify the required parameter 'requiredFile' is set if (requiredFile == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile\"); } \/\/ create path and map variables final Map<String, Object> uriVariables = new HashMap<String, Object>(); uriVariables.put(\"petId\", petId); String path = UriComponentsBuilder.fromPath(\"\/fake\/{petId}\/uploadImageWithRequiredFile\").buildAndExpand(uriVariables).toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); if (additionalMetadata != null) formParams.add(\"additionalMetadata\", additionalMetadata); if (requiredFile != null) formParams.add(\"requiredFile\", new FileSystemResource(requiredFile)); final String[] accepts = { \"application\/json\" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { \"multipart\/form-data\" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { \"petstore_auth\" }; ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {}; return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }","old_code_raw":"    public ModelApiResponse uploadFileWithRequiredFile(Long petId, File file, String additionalMetadata) throws RestClientException {\n        Object postBody = new Object();\n        \n        \/\/ verify the required parameter 'petId' is set\n        if (petId == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\");\n        }\n        \n        \/\/ verify the required parameter 'file' is set\n        if (file == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'file' when calling uploadFileWithRequiredFile\");\n        }\n        \n        \/\/ create path and map variables\n        final Map<String, Object> uriVariables = new HashMap<String, Object>();\n        uriVariables.put(\"petId\", petId);\n        String path = UriComponentsBuilder.fromPath(\"\/fake\/{petId}\/uploadImageWithRequiredFile\").buildAndExpand(uriVariables).toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n        \n        if (additionalMetadata != null)\n            formParams.add(\"additionalMetadata\", additionalMetadata);\n        if (file != null)\n            formParams.add(\"file\", new FileSystemResource(file));\n\n        final String[] accepts = { \n            \"application\/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"multipart\/form-data\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] { \"petstore_auth\" };\n\n        ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n","new_comment_raw":"@param additionalMetadata Additional data to pass to server","old_comment_raw":"@param additionalMetadata Additional data to pass to server","label":0,"pre_label":1,"AST_level":8,"line_counts":42,"new_code_token_num":327},{"new_code_raw":"private static String getSpecificQuality(String scannerName, Object scanner) { String scannerPackage=scanner.getClass().getCanonicalName(); String quality = \"\"; if (BETA_REGEX.matcher(scannerPackage).matches()) quality = QUALITY_BETA; else if (ALPHA_REGEX.matcher(scannerPackage).matches()) quality = QUALITY_ALPHA; else if (SCRIPT_RULES_REGEX.matcher(scannerName).matches()) quality = QUALITY_SCRIPT_RULES; else \/\/ We haven't matched yet so it must be Release quality = QUALITY_RELEASE; return quality; }","old_code_raw":"\tprivate static String getSpecificQuality(String scannerName, String scannerPackage) {\n\n        String quality = \"\";\n        \n        if (BETA_REGEX.matcher(scannerPackage).matches())\n        \tquality = QUALITY_BETA;\n        else if (ALPHA_REGEX.matcher(scannerPackage).matches()) \n        \tquality = QUALITY_ALPHA;\n        else if (SCRIPT_RULES_REGEX.matcher(scannerPackage).matches()) \n        \tquality = QUALITY_SCRIPT_RULES;\n        else  \/\/ We haven't matched yet so it must be Release\n        \tquality = QUALITY_RELEASE;\n        \n        return quality;\n\t}\n","new_comment_raw":"@param scanner the scanner for which quality is being identified","old_comment_raw":"@param scannerPackage the name of the scanner package","label":1,"pre_label":0,"AST_level":8,"line_counts":17,"new_code_token_num":92},{"new_code_raw":"public List<TypedDependency> typedDependenciesCCprocessed(Extras includeExtras) { List<TypedDependency> tdl = typedDependencies(includeExtras); collapseDependencies(tdl, true, includeExtras); return tdl; }","old_code_raw":"  public List<TypedDependency> typedDependenciesCCprocessed(boolean includeExtras) {\n    List<TypedDependency> tdl = typedDependencies(includeExtras);\n    collapseDependencies(tdl, true, includeExtras);\n    return tdl;\n  }\n","new_comment_raw":"@param includeExtras If true, the list of typed dependencies returned may include \"extras\", such as controlled subject links.","old_comment_raw":"@param includeExtras If true, the list of typed dependencies returned may include \"extras\", such as controlled subject links.","label":0,"pre_label":1,"AST_level":6,"line_counts":6,"new_code_token_num":30},{"new_code_raw":"public static boolean filter(String path, Collection<String> includes, Collection<String> excludes) { includes = (includes == null ? Collections.<String> emptyList() : includes); excludes = (excludes == null ? Collections.<String> emptyList() : excludes); if (includes.isEmpty() && excludes.isEmpty()) { return true; } if (Regex.simpleMatch(excludes, path)) { return false; } boolean exactIncludeMatch = false; \/\/ true if the current position was specifically mentioned boolean pathIsPrefixOfAnInclude = false; \/\/ true if potentially a sub scope can be included if (includes.isEmpty()) { \/\/ implied match anything exactIncludeMatch = true; } else { for (String include : includes) { \/\/ check for prefix matches as well to see if we need to zero in, something like: obj1.arr1.* or *.field \/\/ note, this does not work well with middle matches, like obj1.*.obj3 if (include.charAt(0) == '*') { if (Regex.simpleMatch(include, path)) { exactIncludeMatch = true; break; } pathIsPrefixOfAnInclude = true; continue; } if (include.startsWith(path)) { if (include.length() == path.length()) { exactIncludeMatch = true; break; } else if (include.length() > path.length() && include.charAt(path.length()) == '.') { \/\/ include might may match deeper paths. Dive deeper. pathIsPrefixOfAnInclude = true; continue; } } if (Regex.simpleMatch(include, path)) { exactIncludeMatch = true; break; } } } if (!(pathIsPrefixOfAnInclude || exactIncludeMatch)) { \/\/ skip subkeys, not interesting. return false; } else if (exactIncludeMatch) { return true; } return false; }","old_code_raw":"    public static boolean filter(String path, List<String> includes, List<String> excludes) {\n        includes = (includes == null ? Collections.<String> emptyList() : includes);\n        excludes = (excludes == null ? Collections.<String> emptyList() : excludes);\n\n        if (includes.isEmpty() && excludes.isEmpty()) {\n            return true;\n        }\n\n        if (Regex.simpleMatch(excludes, path)) {\n            return false;\n        }\n\n        boolean exactIncludeMatch = false; \/\/ true if the current position was specifically mentioned\n        boolean pathIsPrefixOfAnInclude = false; \/\/ true if potentially a sub scope can be included\n        if (includes.isEmpty()) {\n            \/\/ implied match anything\n            exactIncludeMatch = true;\n        }\n        else {\n            for (String include : includes) {\n                \/\/ check for prefix matches as well to see if we need to zero in, something like: obj1.arr1.* or *.field\n                \/\/ note, this does not work well with middle matches, like obj1.*.obj3\n                if (include.charAt(0) == '*') {\n                    if (Regex.simpleMatch(include, path)) {\n                        exactIncludeMatch = true;\n                        break;\n                    }\n                    pathIsPrefixOfAnInclude = true;\n                    continue;\n                }\n                if (include.startsWith(path)) {\n                    if (include.length() == path.length()) {\n                        exactIncludeMatch = true;\n                        break;\n                    }\n                    else if (include.length() > path.length() && include.charAt(path.length()) == '.') {\n                        \/\/ include might may match deeper paths. Dive deeper.\n                        pathIsPrefixOfAnInclude = true;\n                        continue;\n                    }\n                }\n                if (Regex.simpleMatch(include, path)) {\n                    exactIncludeMatch = true;\n                    break;\n                }\n            }\n        }\n\n        if (!(pathIsPrefixOfAnInclude || exactIncludeMatch)) {\n            \/\/ skip subkeys, not interesting.\n            return false;\n        }\n\n        else if (exactIncludeMatch) {\n            return true;\n        }\n        return true;\n    }\n","new_comment_raw":"@param includes","old_comment_raw":"@param includes","label":0,"pre_label":1,"AST_level":14,"line_counts":59,"new_code_token_num":336},{"new_code_raw":"public String getAsText(long instant, Locale locale) { return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToText(get(instant)); }","old_code_raw":"    public String getAsText(long millis, Locale locale) {\n        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToText(get(millis));\n    }\n","new_comment_raw":"@param instant the time instant in millis to query","old_comment_raw":"@param millis the time instant in millis to query","label":1,"pre_label":0,"AST_level":7,"line_counts":4,"new_code_token_num":26},{"new_code_raw":"protected QualifiedName determineGeneratorTableName(Properties params, JdbcEnvironment jdbcEnvironment) { final String tableName = ConfigurationHelper.getString( TABLE_PARAM, params, DEF_TABLE ); if ( tableName.contains( \".\" ) ) { return QualifiedNameParser.INSTANCE.parse( tableName ); } else { \/\/ todo : need to incorporate implicit catalog and schema names final Identifier catalog = jdbcEnvironment.getIdentifierHelper().toIdentifier( ConfigurationHelper.getString( CATALOG, params ) ); final Identifier schema = jdbcEnvironment.getIdentifierHelper().toIdentifier( ConfigurationHelper.getString( SCHEMA, params ) ); return new QualifiedNameParser.NameParts( catalog, schema, jdbcEnvironment.getIdentifierHelper().toIdentifier( tableName ) ); } }","old_code_raw":"\tprotected QualifiedName determineGeneratorTableName(Properties params, Dialect dialect) {\n\t\tfinal ObjectNameNormalizer normalizer = (ObjectNameNormalizer) params.get( IDENTIFIER_NORMALIZER );\n\n\t\treturn QualifiedNameParser.INSTANCE.parse(\n\t\t\t\tConfigurationHelper.getString( TABLE_PARAM, params, DEF_TABLE ),\n\t\t\t\tnormalizer.normalizeIdentifierQuoting( params.getProperty( CATALOG ) ),\n\t\t\t\tnormalizer.normalizeIdentifierQuoting( params.getProperty( SCHEMA ) )\n\t\t);\n\t}\n","new_comment_raw":"@param jdbcEnvironment The JDBC environment","old_comment_raw":"@param dialect The dialect in effect","label":1,"pre_label":0,"AST_level":10,"line_counts":22,"new_code_token_num":114},{"new_code_raw":"public Struct delete(Object before, Struct source, Instant timestamp) { Struct struct = new Struct(schema); struct.put(FieldName.OPERATION, Operation.DELETE.code()); if (before != null) { struct.put(FieldName.BEFORE, before); } if (source != null) { struct.put(FieldName.SOURCE, source); } if (timestamp != null) { struct.put(FieldName.TIMESTAMP, timestamp.toEpochMilli()); } return struct; }","old_code_raw":"    public Struct delete(Object before, Struct source, Long timestamp) {\n        Struct struct = new Struct(schema);\n        struct.put(FieldName.OPERATION, Operation.DELETE.code());\n        if (before != null) {\n            struct.put(FieldName.BEFORE, before);\n        }\n        if (source != null) {\n            struct.put(FieldName.SOURCE, source);\n        }\n        if (timestamp != null) {\n            struct.put(FieldName.TIMESTAMP, timestamp);\n        }\n        return struct;\n    }\n","new_comment_raw":"@param before the state of the record before the delete; may be null","old_comment_raw":"@param before the state of the record before the delete; may be null","label":0,"pre_label":1,"AST_level":7,"line_counts":15,"new_code_token_num":93},{"new_code_raw":"public Client call123testSpecialTags(Client body) throws ApiException { Object localVarPostBody = body; \/\/ verify the required parameter 'body' is set if (body == null) { throw new ApiException(400, \"Missing the required parameter 'body' when calling call123testSpecialTags\"); } \/\/ create path and map variables String localVarPath = \"\/another-fake\/dummy\"; \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { \"application\/json\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { \"application\/json\" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Client> localVarReturnType = new GenericType<Client>() {}; return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public Client call123testSpecialTags(Client client) throws ApiException {\n    Object localVarPostBody = client;\n    \n    \/\/ verify the required parameter 'client' is set\n    if (client == null) {\n      throw new ApiException(400, \"Missing the required parameter 'client' when calling call123testSpecialTags\");\n    }\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/another-fake\/dummy\";\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application\/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application\/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@param body client model (required)","old_comment_raw":"@param client client model (required)","label":1,"pre_label":0,"AST_level":8,"line_counts":36,"new_code_token_num":214},{"new_code_raw":"protected boolean isNull(Object owner, SharedSessionContractImplementor session) { return false; }","old_code_raw":"\tprotected boolean isNull(Object owner, SessionImplementor session) {\n\t\treturn false;\n\t}\n","new_comment_raw":"@param session The orginating session.","old_comment_raw":"@param session The orginating session.","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":15},{"new_code_raw":"public Single<Client> rxCall123testSpecialTags(Client body) { return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> { delegate.call123testSpecialTags(body, fut); })); }","old_code_raw":"    public Single<Client> rxCall123testSpecialTags(Client client) {\n        return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> {\n            delegate.call123testSpecialTags(client, fut);\n        }));\n    }\n","new_comment_raw":"@param body client model (required)","old_comment_raw":"@param client client model (required)","label":1,"pre_label":0,"AST_level":10,"line_counts":6,"new_code_token_num":36},{"new_code_raw":"public List<TypedDependency> typedDependenciesCCprocessed(boolean includeExtras) { List<TypedDependency> tdl = typedDependencies(false); \/\/ Adds stuff to the basic dependencies. \/\/ We don't want to simply call typedDependencies with \/\/ \"includeExtras\" because the collapseDependencies method may add \/\/ the extras in a way that makes more logical sense. For \/\/ example, the English dependencies, when CC processed, have more \/\/ nsubjs than they originally do. If we wait until that occurs \/\/ to add xsubj for xcomp dependencies, we get better coverage. if (includeExtras) { getTreeDeps(root(), tdl, new NoPunctTypedDependencyFilter(puncFilter), extraTreeDepFilter()); } collapseDependencies(tdl, true, includeExtras); return tdl; }","old_code_raw":"  public List<TypedDependency> typedDependenciesCCprocessed(Extras includeExtras) {\n    List<TypedDependency> tdl = typedDependencies(includeExtras);\n    collapseDependencies(tdl, true, includeExtras);\n    return tdl;\n  }\n","new_comment_raw":"@param includeExtras If true, the list of typed dependencies returned may include \"extras\", such as controlled subject links.","old_comment_raw":"@param includeExtras If true, the list of typed dependencies returned may include \"extras\", such as controlled subject links.","label":0,"pre_label":1,"AST_level":8,"line_counts":16,"new_code_token_num":139},{"new_code_raw":"public Order placeOrder(Order order) throws ApiException { Object localVarPostBody = order; \/\/ verify the required parameter 'order' is set if (order == null) { throw new ApiException(400, \"Missing the required parameter 'order' when calling placeOrder\"); } \/\/ create path and map variables String localVarPath = \"\/store\/order\".replaceAll(\"\\\\{format\\\\}\",\"json\"); \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { \"application\/xml\", \"application\/json\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Order> localVarReturnType = new GenericType<Order>() {}; return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public Order placeOrder(Order body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    \/\/ verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling placeOrder\");\n    }\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/store\/order\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application\/xml\", \"application\/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Order> localVarReturnType = new GenericType<Order>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@param order order placed for purchasing the pet (required)","old_comment_raw":"@param body order placed for purchasing the pet (required)","label":1,"pre_label":0,"AST_level":8,"line_counts":35,"new_code_token_num":218},{"new_code_raw":"public static TupleMetadata expandMetadata(TupleMetadata base, ImplicitColumnManager metadataProj, int dirCount) { TupleMetadata metadataSchema = new TupleSchema(); for (ColumnMetadata col : base) { metadataSchema.addColumn(col); } for (FileMetadataColumnDefn fileColDefn : metadataProj.fileMetadataColDefns()) { metadataSchema.add(MaterializedField.create(fileColDefn.colName(), fileColDefn.dataType())); } for (int i = 0; i < dirCount; i++) { metadataSchema.add(MaterializedField.create(metadataProj.partitionName(i), PartitionColumn.dataType())); } return metadataSchema; }","old_code_raw":"  public static TupleMetadata expandMetadata(TupleMetadata base, FileMetadataManager metadataProj, int dirCount) {\n    TupleMetadata metadataSchema = new TupleSchema();\n    for (ColumnMetadata col : base) {\n      metadataSchema.addColumn(col);\n    }\n    for (FileMetadataColumnDefn fileColDefn : metadataProj.fileMetadataColDefns()) {\n      metadataSchema.add(MaterializedField.create(fileColDefn.colName(), fileColDefn.dataType()));\n    }\n    for (int i = 0; i < dirCount; i++) {\n      metadataSchema.add(MaterializedField.create(metadataProj.partitionName(i),\n          PartitionColumn.dataType()));\n    }\n    return metadataSchema;\n  }\n","new_comment_raw":"@param dirCount number of partition directories","old_comment_raw":"@param dirCount number of partition directories","label":0,"pre_label":1,"AST_level":9,"line_counts":15,"new_code_token_num":105},{"new_code_raw":"public Object get(String name) { if (bean != null) { Method method = getReadMethod(name); if (method != null) { try { return method.invoke(bean, NULL_ARGUMENTS); } catch (IllegalAccessException e) { logWarn(e); } catch (IllegalArgumentException e) { logWarn(e); } catch (InvocationTargetException e) { logWarn(e); } catch (NullPointerException e) { logWarn(e); } } } return null; }","old_code_raw":"    public Object get(Object name) {\n        if ( bean != null ) {\n            Method method = getReadMethod( name );\n            if ( method != null ) {\n                try {\n                    return method.invoke( bean, NULL_ARGUMENTS );\n                }\n                catch (  IllegalAccessException e ) {\n                    logWarn( e );\n                }\n                catch ( IllegalArgumentException e ) {\n                    logWarn(  e );\n                }\n                catch ( InvocationTargetException e ) {\n                    logWarn(  e );\n                }\n                catch ( NullPointerException e ) {\n                    logWarn(  e );\n                }\n            }\n        }\n        return null;\n    }\n","new_comment_raw":"@param name the name of the property whose value to return","old_comment_raw":"@param name the name of the property whose value to return","label":0,"pre_label":1,"AST_level":11,"line_counts":20,"new_code_token_num":95},{"new_code_raw":"public boolean searchWithTimeoutFor(Class<? extends TextView> viewClass, String regex, int expectedMinimumNumberOfMatches, boolean scroll, boolean visible) { final long endTime = System.currentTimeMillis() + TIMEOUT; while (System.currentTimeMillis() < endTime) { sleeper.sleep(); final boolean foundAnyMatchingView = searchFor(viewClass, regex, expectedMinimumNumberOfMatches, scroll, visible); if (foundAnyMatchingView){ return true; } } return false; }","old_code_raw":"\tpublic boolean searchWithTimeoutFor(Class<? extends TextView> viewClass, String regex, int expectedMinimumNumberOfMatches, boolean scroll) {\n\t\tfinal long endTime = System.currentTimeMillis() + TIMEOUT;\n\n\t\twhile (System.currentTimeMillis() < endTime) {\n\t\t\tsleeper.sleep();\n\t\t\tfinal boolean foundAnyMatchingView = searchFor(viewClass, regex, expectedMinimumNumberOfMatches, scroll);\n\t\t\tif (foundAnyMatchingView){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n","new_comment_raw":"@param expectedMinimumNumberOfMatches the minimum number of matches expected to be found.  0 matches means that one or more matches are expected to be found","old_comment_raw":"@param expectedMinimumNumberOfMatches the minimum number of matches expected to be found. 0 matches means that one or more matches are expected to be found","label":0,"pre_label":1,"AST_level":8,"line_counts":14,"new_code_token_num":77},{"new_code_raw":"public StringBuilder toStringBuilder(StringBuilder sb, boolean printOnlyLabelValue) { if (isLeaf()) { if (label() != null) { if(printOnlyLabelValue) { sb.append(label().value()); } else { sb.append(label()); } } return sb; } else { sb.append('('); if (label() != null) { if (printOnlyLabelValue) { if (value() != null) { sb.append(label().value()); } \/\/ don't print a null, just nothing! } else { sb.append(label()); } } Tree[] kids = children(); if (kids != null) { for (Tree kid : kids) { sb.append(' '); kid.toStringBuilder(sb, printOnlyLabelValue); } } return sb.append(')'); } }","old_code_raw":"  public StringBuilder toStringBuilder(StringBuilder sb, Function<Label,String> labelFormatter) {\n    if (isLeaf()) {\n      if (label() != null) {\n        sb.append(labelFormatter.apply(label()));\n      }\n      return sb;\n    } else {\n      sb.append('(');\n      if (label() != null) {\n        sb.append(labelFormatter.apply(label()));\n      }\n      Tree[] kids = children();\n      if (kids != null) {\n        for (Tree kid : kids) {\n          sb.append(' ');\n          kid.toStringBuilder(sb, labelFormatter);\n        }\n      }\n      return sb.append(')');\n    }\n  }\n","new_comment_raw":"@param printOnlyLabelValue If true, print only the value() of each node's label","old_comment_raw":"@param labelFormatter Formatting routine for how to print a Label","label":1,"pre_label":0,"AST_level":14,"line_counts":33,"new_code_token_num":181},{"new_code_raw":"private RectF drawBoxWithShadow(Canvas c, Paint p, int width, int height) { Resources res = mContext.getResources(); float shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur); float keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance); float corner = res.getDimension(R.dimen.widget_preview_corner_radius); RectF bounds = new RectF(shadowBlur, shadowBlur, width - shadowBlur, height - shadowBlur - keyShadowDistance); p.setColor(Color.WHITE); \/\/ Key shadow p.setShadowLayer(shadowBlur, 0, keyShadowDistance, ShadowGenerator.KEY_SHADOW_ALPHA << 24); c.drawRoundRect(bounds, corner, corner, p); \/\/ Ambient shadow p.setShadowLayer(shadowBlur, 0, 0, ColorUtils.setAlphaComponent(Color.BLACK, ShadowGenerator.AMBIENT_SHADOW_ALPHA)); c.drawRoundRect(bounds, corner, corner, p); p.clearShadowLayer(); return bounds; }","old_code_raw":"    private RectF drawBoxWithShadow(Canvas c, int width, int height) {\n        Resources res = mContext.getResources();\n\n        ShadowGenerator.Builder builder = new ShadowGenerator.Builder(Color.WHITE);\n        builder.shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur);\n        builder.radius = res.getDimension(R.dimen.widget_preview_corner_radius);\n        builder.keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance);\n\n        builder.bounds.set(builder.shadowBlur, builder.shadowBlur,\n                width - builder.shadowBlur,\n                height - builder.shadowBlur - builder.keyShadowDistance);\n        builder.drawShadow(c);\n        return builder.bounds;\n    }\n","new_comment_raw":"@param info information about the widget","old_comment_raw":"@param info information about the widget","label":0,"pre_label":1,"AST_level":8,"line_counts":24,"new_code_token_num":156},{"new_code_raw":"public static Criterion between(String propertyName, Object low, Object high) { return new BetweenExpression( propertyName, low, high ); }","old_code_raw":"\tpublic static Criterion between(String propertyName, Object lo, Object hi) {\n\t\treturn new BetweenExpression( propertyName, lo, hi );\n\t}\n","new_comment_raw":"@param high The high value","old_comment_raw":"@param hi The high value","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":27},{"new_code_raw":"public Builder builder(RelNode rel, Clause... clauses) { final Clause maxClause = maxClause(); boolean needNew = false; \/\/ If old and new clause are equal and belong to below set, \/\/ then new SELECT wrap is not required Set<Clause> nonWrapSet = ImmutableSet.of(Clause.SELECT); for (Clause clause : clauses) { if (maxClause.ordinal() > clause.ordinal() || (maxClause.equals(clause) && !nonWrapSet.contains(clause))) { needNew = true; } } SqlSelect select; Expressions.FluentList<Clause> clauseList = Expressions.list(); if (needNew) { select = subSelect(); } else { select = asSelect(); clauseList.addAll(this.clauses); } clauseList.appendAll(clauses); Context newContext; final SqlNodeList selectList = select.getSelectList(); if (selectList != null) { newContext = new Context(selectList.size()) { public SqlNode field(int ordinal) { final SqlNode selectItem = selectList.get(ordinal); switch (selectItem.getKind()) { case AS: return ((SqlCall) selectItem).operand(0); } return selectItem; } }; } else { newContext = aliasContext(aliases, aliases.size() > 1); } return new Builder(rel, clauseList, select, newContext); }","old_code_raw":"    public Builder builder(JdbcRel rel, Clause... clauses) {\n      final Clause maxClause = maxClause();\n      boolean needNew = false;\n      for (Clause clause : clauses) {\n        if (maxClause.ordinal() >= clause.ordinal()) {\n          needNew = true;\n        }\n      }\n      SqlSelect select;\n      Expressions.FluentList<Clause> clauseList = Expressions.list();\n      if (needNew) {\n        select = subSelect();\n      } else {\n        select = asSelect();\n        clauseList.addAll(this.clauses);\n      }\n      clauseList.appendAll(clauses);\n      Context newContext;\n      final SqlNodeList selectList = select.getSelectList();\n      if (selectList != null) {\n        newContext = new Context(selectList.size()) {\n          @Override public SqlNode field(int ordinal) {\n            final SqlNode selectItem = selectList.get(ordinal);\n            switch (selectItem.getKind()) {\n            case AS:\n              return ((SqlCall) selectItem).operand(0);\n            }\n            return selectItem;\n          }\n        };\n      } else {\n        newContext = aliasContext(aliases, aliases.size() > 1);\n      }\n      return new Builder(rel, clauseList, select, newContext);\n    }\n","new_comment_raw":"@param rel Relational expression being implemented","old_comment_raw":"@param rel Relational expression being implemented","label":0,"pre_label":1,"AST_level":13,"line_counts":40,"new_code_token_num":247},{"new_code_raw":"public static RuleSet getDrillBasicRules(OptimizerRulesContext optimizerRulesContext) { if (DRILL_BASIC_RULES == null) { DRILL_BASIC_RULES = new DrillRuleSet(ImmutableSet.<RelOptRule> builder().add( \/\/ \/\/ Add support for Distinct Union (by using Union-All followed by Distinct) UnionToDistinctRule.INSTANCE, \/\/ Add support for WHERE style joins. DrillFilterJoinRules.DRILL_FILTER_ON_JOIN, DrillFilterJoinRules.DRILL_JOIN, \/\/ End support for WHERE style joins. \/* Filter push-down related rules *\/ DrillPushFilterPastProjectRule.INSTANCE, FilterSetOpTransposeRule.INSTANCE, FilterMergeRule.INSTANCE, AggregateRemoveRule.INSTANCE, ProjectRemoveRule.NAME_CALC_INSTANCE, SortRemoveRule.INSTANCE, DrillMergeProjectRule.getInstance(true, RelFactories.DEFAULT_PROJECT_FACTORY, optimizerRulesContext.getFunctionRegistry()), AggregateExpandDistinctAggregatesRule.INSTANCE, DrillReduceAggregatesRule.INSTANCE, \/* Projection push-down related rules *\/ DrillPushProjectPastFilterRule.INSTANCE, DrillPushProjectPastJoinRule.INSTANCE, DrillPushProjIntoScan.INSTANCE, DrillProjectSetOpTransposeRule.INSTANCE, PruneScanRule.getFilterOnProject(optimizerRulesContext), PruneScanRule.getFilterOnScan(optimizerRulesContext), PruneScanRule.getFilterOnProjectParquet(optimizerRulesContext), PruneScanRule.getFilterOnScanParquet(optimizerRulesContext), \/* Convert from Calcite Logical to Drill Logical Rules. *\/ ExpandConversionRule.INSTANCE, DrillScanRule.INSTANCE, DrillFilterRule.INSTANCE, DrillProjectRule.INSTANCE, DrillWindowRule.INSTANCE, DrillAggregateRule.INSTANCE, DrillLimitRule.INSTANCE, DrillSortRule.INSTANCE, DrillJoinRule.INSTANCE, DrillUnionAllRule.INSTANCE, DrillValuesRule.INSTANCE ) .build()); } return DRILL_BASIC_RULES; }","old_code_raw":"  public static RuleSet getDrillBasicRules(QueryContext context) {\n    if (DRILL_BASIC_RULES == null) {\n\n      DRILL_BASIC_RULES = new DrillRuleSet(ImmutableSet.<RelOptRule> builder().add( \/\/\n      \/\/ Add support for Distinct Union (by using Union-All followed by Distinct)\n      UnionToDistinctRule.INSTANCE,\n\n      \/\/ Add support for WHERE style joins.\n      DrillFilterJoinRules.DRILL_FILTER_ON_JOIN,\n      DrillFilterJoinRules.DRILL_JOIN,\n      \/\/ End support for WHERE style joins.\n\n      \/*\n       Filter push-down related rules\n       *\/\n      DrillPushFilterPastProjectRule.INSTANCE,\n      FilterSetOpTransposeRule.INSTANCE,\n\n      FilterMergeRule.INSTANCE,\n      AggregateRemoveRule.INSTANCE,\n      ProjectRemoveRule.NAME_CALC_INSTANCE,\n      SortRemoveRule.INSTANCE,\n\n      DrillMergeProjectRule.getInstance(true, RelFactories.DEFAULT_PROJECT_FACTORY, context.getFunctionRegistry()),\n      AggregateExpandDistinctAggregatesRule.INSTANCE,\n      DrillReduceAggregatesRule.INSTANCE,\n\n      \/*\n       Projection push-down related rules\n       *\/\n      DrillPushProjectPastFilterRule.INSTANCE,\n      DrillPushProjectPastJoinRule.INSTANCE,\n      DrillPushProjIntoScan.INSTANCE,\n      DrillProjectSetOpTransposeRule.INSTANCE,\n\n      PruneScanRule.getFilterOnProject(context),\n      PruneScanRule.getFilterOnScan(context),\n      PruneScanRule.getFilterOnProjectParquet(context),\n      PruneScanRule.getFilterOnScanParquet(context),\n\n      \/*\n       Convert from Calcite Logical to Drill Logical Rules.\n       *\/\n      ExpandConversionRule.INSTANCE,\n      DrillScanRule.INSTANCE,\n      DrillFilterRule.INSTANCE,\n      DrillProjectRule.INSTANCE,\n      DrillWindowRule.INSTANCE,\n      DrillAggregateRule.INSTANCE,\n\n      DrillLimitRule.INSTANCE,\n      DrillSortRule.INSTANCE,\n      DrillJoinRule.INSTANCE,\n      DrillUnionAllRule.INSTANCE,\n      DrillValuesRule.INSTANCE\n      )\n      .build());\n    }\n\n    return DRILL_BASIC_RULES;\n  }\n","new_comment_raw":"@param optimizerRulesContext - shared state used during planning, currently used here to gain access to the function registry described above.","old_comment_raw":"@param context - shared state used during planning, currently used here to gain access to the fucntion registry described above.","label":1,"pre_label":0,"AST_level":11,"line_counts":63,"new_code_token_num":219},{"new_code_raw":"public static RemoteProxy getNewBasicRemoteProxy(List<Map<String, Object>> caps, String url,Registry registry) { RegistrationRequest req = new RegistrationRequest(); req.setCapabilities(caps); Map<String, Object> config = new HashMap<String, Object>(); config.put(\"url\", url); req.setConfiguration(config); return new RemoteProxy(req,registry); }","old_code_raw":"\tpublic static RemoteProxy getNewBasicRemoteProxy(List<Map<String, Object>> caps, String url) {\n\n\t\tRegistrationRequest req = new RegistrationRequest();\n\n\t\treq.setCapabilities(caps);\n\n\t\tMap<String, Object> config = new HashMap<String, Object>();\n\t\tconfig.put(\"url\", url);\n\t\treq.setConfiguration(config);\n\t\treturn new RemoteProxy(req);\n\n\t}\n","new_comment_raw":"@param url","old_comment_raw":"@param url","label":0,"pre_label":1,"AST_level":8,"line_counts":13,"new_code_token_num":71},{"new_code_raw":"public OuterComposite fakeOuterCompositeSerialize(OuterComposite outerComposite) throws ApiException { Object localVarPostBody = outerComposite; \/\/ create path and map variables String localVarPath = \"\/fake\/outer\/composite\"; \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { \"*\/*\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<OuterComposite> localVarReturnType = new GenericType<OuterComposite>() {}; return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public OuterComposite fakeOuterCompositeSerialize(OuterComposite body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/fake\/outer\/composite\";\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<OuterComposite> localVarReturnType = new GenericType<OuterComposite>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@param outerComposite Input composite as post body (optional)","old_comment_raw":"@param body Input composite as post body (optional)","label":1,"pre_label":0,"AST_level":8,"line_counts":31,"new_code_token_num":171},{"new_code_raw":"private URL determineSuiteUrl(String startURL, String suiteURL) throws IOException { if (suiteURL.startsWith(\"https:\/\/\") || suiteURL.startsWith(\"http:\/\/\")) { return verifySuiteUrl(new URL(suiteURL)); } \/\/ Is the suiteURL a file? Path path = Paths.get(suiteURL); if (Files.exists(path)) { \/\/ Not all drivers can read files from the disk, so we need to host the suite somewhere. try (SocketLock lock = new SocketLock()) { server = new Server(); HttpConfiguration httpConfig = new HttpConfiguration(); ServerConnector http = new ServerConnector(server, new HttpConnectionFactory(httpConfig)); int port = PortProber.findFreePort(); http.setPort(port); http.setIdleTimeout(500000); server.setConnectors(new Connector[]{http}); ResourceHandler handler = new ResourceHandler(); handler.setDirectoriesListed(true); handler.setWelcomeFiles(new String[]{path.getFileName().toString(), \"index.html\"}); handler.setBaseResource(new PathResource(path.toFile().getParentFile().toPath().toRealPath())); ContextHandler context = new ContextHandler(\"\/tests\"); context.setHandler(handler); server.setHandler(context); server.start(); PortProber.waitForPortUp(port, 15, SECONDS); URL serverUrl = server.getURI().toURL(); return new URL(serverUrl.getProtocol(), serverUrl.getHost(), serverUrl.getPort(), \"\/tests\/\"); } catch (Exception e) { throw new IOException(e); } } \/\/ Well then, it must be a URL relative to whatever the browserUrl. Probe and find out. URL browser = new URL(startURL); return verifySuiteUrl(new URL(browser, suiteURL)); }","old_code_raw":"  private URL determineSuiteUrl(String browserUrl, String suiteURL) throws IOException {\n    if (suiteURL.startsWith(\"https:\/\/\") || suiteURL.startsWith(\"http:\/\/\")) {\n      return verifySuiteUrl(new URL(suiteURL));\n    }\n\n    \/\/ Is the suiteURL a file?\n    Path path = Paths.get(suiteURL);\n    if (Files.exists(path)) {\n      \/\/ Not all drivers can read files from the disk, so we need to host the suite somewhere.\n      try (SocketLock lock = new SocketLock()) {\n        server = new Server();\n        HttpConfiguration httpConfig = new HttpConfiguration();\n\n        ServerConnector http = new ServerConnector(server, new HttpConnectionFactory(httpConfig));\n        int port = PortProber.findFreePort();\n        http.setPort(port);\n        http.setIdleTimeout(500000);\n        server.setConnectors(new Connector[]{http});\n\n        ResourceHandler handler = new ResourceHandler();\n        handler.setDirectoriesListed(true);\n        handler.setWelcomeFiles(new String[]{path.getFileName().toString(), \"index.html\"});\n        handler.setBaseResource(new PathResource(path.toFile().getParentFile().toPath().toRealPath()));\n\n        ContextHandler context = new ContextHandler(\"\/tests\");\n        context.setHandler(handler);\n\n        server.setHandler(context);\n        server.start();\n\n        PortProber.waitForPortUp(port, 15, SECONDS);\n\n        URL serverUrl = server.getURI().toURL();\n        return new URL(serverUrl.getProtocol(), serverUrl.getHost(), serverUrl.getPort(),\n                       \"\/tests\/\");\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n\n    \/\/ Well then, it must be a URL relative to whatever the browserUrl. Probe and find out.\n    URL browser = new URL(browserUrl);\n    return verifySuiteUrl(new URL(browser, suiteURL));\n  }\n","new_comment_raw":"@param outputFile - The file to which we'll output the HTML results","old_comment_raw":"@param outputFile - The file to which we'll output the HTML results","label":0,"pre_label":1,"AST_level":11,"line_counts":45,"new_code_token_num":351},{"new_code_raw":"public static int bitCount(long lng) { lng = (lng & 0x5555555555555555L) + ((lng >> 1) & 0x5555555555555555L); lng = (lng & 0x3333333333333333L) + ((lng >> 2) & 0x3333333333333333L); \/\/ adjust for 64-bit integer int i = (int) ((lng >>> 32) + lng); i = (i & 0x0F0F0F0F) + ((i >> 4) & 0x0F0F0F0F); i = (i & 0x00FF00FF) + ((i >> 8) & 0x00FF00FF); i = (i & 0x0000FFFF) + ((i >> 16) & 0x0000FFFF); return i; }","old_code_raw":"    public static int bitCount(long v) {\n        \/\/ Combines techniques from several sources\n        v -=  (v >>> 1) & 0x5555555555555555L;\n        v = (v & 0x3333333333333333L) + ((v >> 2) & 0x3333333333333333L);\n        int i =  ((int)(v >>> 32)) + (int) v;\n        i = (i & 0x0F0F0F0F) + ((i >> 4) & 0x0F0F0F0F);\n        i += i >>> 8;\n        i += i >>> 16;\n        return i  & 0x0000007F;\n    }\n","new_comment_raw":"@param lng the long to examine.","old_comment_raw":"@param v the long to examine.","label":1,"pre_label":0,"AST_level":8,"line_counts":12,"new_code_token_num":115},{"new_code_raw":"public Request buildRequest(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); final String url = buildUrl(path, queryParams, collectionQueryParams); final Request.Builder reqBuilder = new Request.Builder().url(url); processHeaderParams(headerParams, reqBuilder); String contentType = (String) headerParams.get(\"Content-Type\"); \/\/ ensuring a default content type if (contentType == null) { contentType = \"application\/json\"; } RequestBody reqBody; if (!HttpMethod.permitsRequestBody(method)) { reqBody = null; } else if (\"application\/x-www-form-urlencoded\".equals(contentType)) { reqBody = buildRequestBodyFormEncoding(formParams); } else if (\"multipart\/form-data\".equals(contentType)) { reqBody = buildRequestBodyMultipart(formParams); } else if (body == null) { if (\"DELETE\".equals(method)) { \/\/ allow calling DELETE without sending a request body reqBody = null; } else { \/\/ use an empty request body (for POST, PUT and PATCH) reqBody = RequestBody.create(MediaType.parse(contentType), \"\"); } } else { reqBody = serialize(body, contentType); } \/\/ Associate callback with request (if not null) so interceptor can \/\/ access it when creating ProgressResponseBody reqBuilder.tag(callback); Request request = null; if (callback != null && reqBody != null) { ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, callback); request = reqBuilder.method(method, progressRequestBody).build(); } else { request = reqBuilder.method(method, reqBody).build(); } return request; }","old_code_raw":"    public Request buildRequest(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {\n        updateParamsForAuth(authNames, queryParams, headerParams);\n\n        final String url = buildUrl(path, queryParams, collectionQueryParams);\n        final Request.Builder reqBuilder = new Request.Builder().url(url);\n        processHeaderParams(headerParams, reqBuilder);\n\n        String contentType = (String) headerParams.get(\"Content-Type\");\n        \/\/ ensuring a default content type\n        if (contentType == null) {\n            contentType = \"application\/json\";\n        }\n\n        RequestBody reqBody;\n        if (!HttpMethod.permitsRequestBody(method)) {\n            reqBody = null;\n        } else if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n            reqBody = buildRequestBodyFormEncoding(formParams);\n        } else if (\"multipart\/form-data\".equals(contentType)) {\n            reqBody = buildRequestBodyMultipart(formParams);\n        } else if (body == null) {\n            if (\"DELETE\".equals(method)) {\n                \/\/ allow calling DELETE without sending a request body\n                reqBody = null;\n            } else {\n                \/\/ use an empty request body (for POST, PUT and PATCH)\n                reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n            }\n        } else {\n            reqBody = serialize(body, contentType);\n        }\n\n        Request request = null;\n\n        if(progressRequestListener != null && reqBody != null) {\n            ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, progressRequestListener);\n            request = reqBuilder.method(method, progressRequestBody).build();\n        } else {\n            request = reqBuilder.method(method, reqBody).build();\n        }\n\n        return request;\n    }\n","new_comment_raw":"@param path The sub-path of the HTTP URL","old_comment_raw":"@param path The sub-path of the HTTP URL","label":0,"pre_label":1,"AST_level":14,"line_counts":48,"new_code_token_num":350},{"new_code_raw":"public ArrayList<View> getAllViews(boolean onlySufficientlyVisible) { Activity activity = activityUtils.getCurrentActivity(false); final View [] views = getWindowDecorViews(); final ArrayList<View> allViews = new ArrayList<View>(); final View [] nonDecorViews = getNonDecorViews(views); if(views !=null && views.length > 0) { if(!activity.hasWindowFocus()){ for(View view : views){ if(!activity.getWindow().getDecorView().equals(view)){ try{ addChildren(allViews,(ViewGroup) view, onlySufficientlyVisible); } catch (Exception ignored) {} } } } else{ for(View view : nonDecorViews){ try{ addChildren(allViews,(ViewGroup) view, onlySufficientlyVisible); } catch (Exception ignored) {} } try{ addChildren(allViews,(ViewGroup) getRecentDecorView(views), onlySufficientlyVisible); } catch (Exception ignored) {} } } return allViews; }","old_code_raw":"\tpublic ArrayList<View> getAllViews(boolean onlyFullyVisible)\n\t{\n\t\tActivity activity = activityUtils.getCurrentActivity(false);\n\t\tfinal View [] views = getWindowDecorViews();\n\t\tfinal ArrayList<View> allViews = new ArrayList<View>();\n\t\tfinal View [] nonDecorViews = getNonDecorViews(views);\n\t\tif(views !=null && views.length > 0)\n\t\t{\n\t\t\tif(!activity.hasWindowFocus()){\n\t\t\t\tfor(View view : views){\n\t\t\t\t\tif(!activity.getWindow().getDecorView().equals(view)){\n\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\taddChildren(allViews,(ViewGroup) view, onlyFullyVisible);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ignored) {}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(View view : nonDecorViews){\n\t\t\t\t\ttry{\n\t\t\t\t\t\taddChildren(allViews,(ViewGroup) view, onlyFullyVisible);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ignored) {}\n\t\t\t\t}\t\n\t\t\t\ttry{\n\t\t\t\t\taddChildren(allViews,(ViewGroup) getRecentDecorView(views), onlyFullyVisible);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ignored) {}\n\t\t\t}\n\t\t}\n\t\treturn allViews;\n\t}\n","new_comment_raw":"@param onlySufficientlyVisible if only sufficiently visible views should be returned","old_comment_raw":"@param onlyFullyVisible if only fully visible views should be returned","label":1,"pre_label":0,"AST_level":15,"line_counts":34,"new_code_token_num":180},{"new_code_raw":"public String getLimitString(String querySqlString, boolean hasOffset) { StringBuilder sb = new StringBuilder(querySqlString.trim().toLowerCase()); int orderByIndex = sb.indexOf(\"order by\"); CharSequence orderby = orderByIndex > 0 ? sb.subSequence(orderByIndex, sb.length()) : \"ORDER BY CURRENT_TIMESTAMP\"; \/\/ Delete the order by clause at the end of the query if (orderByIndex > 0) { sb.delete(orderByIndex, orderByIndex + orderby.length()); } \/\/ HHH-5715 bug fix replaceDistinctWithGroupBy(sb); insertRowNumberFunction(sb, orderby); \/\/ Wrap the query within a with statement: sb.insert(0, \"WITH query AS (\").append(\") SELECT * FROM query \"); \/\/sb.append(\"WHERE __hibernate_row_nr__ BETWEEN \").append(offset + 1).append(\" AND \").append(limit); sb.append(\"WHERE __hibernate_row_nr__ BETWEEN ? AND ?\"); return sb.toString(); }","old_code_raw":"\tpublic String getLimitString(String querySqlString, int offset, int limit) {\n\t\tStringBuilder sb = new StringBuilder(querySqlString.trim().toLowerCase());\n\n\t\tint orderByIndex = sb.indexOf(\"order by\");\n\t\tCharSequence orderby = orderByIndex > 0 ? sb.subSequence(orderByIndex, sb.length())\n\t\t\t\t: \"ORDER BY CURRENT_TIMESTAMP\";\n\n\t\t\/\/ Delete the order by clause at the end of the query\n\t\tif (orderByIndex > 0) {\n\t\t\tsb.delete(orderByIndex, orderByIndex + orderby.length());\n\t\t}\n\n\t\t\/\/ HHH-5715 bug fix\n\t\treplaceDistinctWithGroupBy(sb);\n\n\t\tinsertRowNumberFunction(sb, orderby);\n\n\t\t\/\/ Wrap the query within a with statement:\n\t\tsb.insert(0, \"WITH query AS (\").append(\") SELECT * FROM query \");\n\t\tsb.append(\"WHERE __hibernate_row_nr__ BETWEEN \").append(offset + 1).append(\" AND \").append(limit);\n\n\t\treturn sb.toString();\n\t}\n","new_comment_raw":"@param offset Offset of the first row to be returned by the query (zero-based)","old_comment_raw":"@param offset Offset of the first row to be returned by the query (zero-based)","label":0,"pre_label":1,"AST_level":8,"line_counts":25,"new_code_token_num":191},{"new_code_raw":"public Duration withMillis(long duration) { if (duration == getMillis()) { return this; } return new Duration(duration); }","old_code_raw":"    public Duration withMillis(long length) {\n        if (length == getMillis()) {\n            return this;\n        }\n        return new Duration(length);\n    }\n","new_comment_raw":"@param duration the new length of the duration","old_comment_raw":"@param length the new length","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":28},{"new_code_raw":"public static Boolean areColumnsUnique(RelNode rel, ImmutableBitSet columns) { final BuiltInMetadata.ColumnUniqueness metadata = rel.metadata(BuiltInMetadata.ColumnUniqueness.class); return metadata.areColumnsUnique(columns, false); }","old_code_raw":"  public static Boolean areColumnsUnique(RelNode rel, BitSet columns) {\n    final BuiltInMetadata.ColumnUniqueness metadata =\n        rel.metadata(BuiltInMetadata.ColumnUniqueness.class);\n    return metadata.areColumnsUnique(columns, false);\n  }\n","new_comment_raw":"@param rel the relational expression","old_comment_raw":"@param rel the relational expression","label":0,"pre_label":1,"AST_level":7,"line_counts":6,"new_code_token_num":34},{"new_code_raw":"public static String getClassName(String memberID, boolean isClassMember) { int pos = memberID.indexOf(ALT_MEMBER_SEPARATOR); \/\/ uses alternative separator, easy if (pos != -1) return memberID.substring(0, pos); pos = memberID.indexOf('('); if ( pos != -1 ) { \/\/ has a descriptor, is a method ID, strip last member part pos = memberID.lastIndexOf('.', pos); return pos != -1 ? memberID.substring(0, pos) : \"\"; } if (isClassMember) { \/\/ field or class name, cannot decide, assume it is a field pos = memberID.lastIndexOf('.'); return pos != -1 ? memberID.substring(0, pos) : \"\"; } else { \/\/ assume it is a class name return memberID; } }","old_code_raw":"    public static String getClassName(String signature, boolean isClassMember) {\n        int pos = signature.indexOf(ALT_MEMBER_SEPARATOR);\n        \/\/ uses alternative separator, easy\n        if (pos != -1) return signature.substring(0, pos);\n\n        pos = signature.indexOf('(');\n        if ( pos != -1 ) {\n            \/\/ has a descriptor, is a method signature, strip last member part\n            pos = signature.lastIndexOf('.', pos);\n            return pos != -1 ? signature.substring(0, pos) : \"\";\n        }\n\n        if (isClassMember) {\n            \/\/ field or class name, cannot decide, assume it is a field\n            pos = signature.lastIndexOf('.');\n            return pos != -1 ? signature.substring(0, pos) : \"\";\n        } else {\n            \/\/ assume it is a class name\n            return signature;\n        }\n    }\n","new_comment_raw":"@param memberID the member ID to parse.","old_comment_raw":"@param signature the signature to parse.","label":1,"pre_label":0,"AST_level":8,"line_counts":23,"new_code_token_num":164},{"new_code_raw":"public boolean checkAlreadyExist(AccountDatabase.AccountName s) { \/\/ Query in the realm database RealmQuery<AccountDatabase> query = realm.where(AccountDatabase.class); \/\/ Checking if string equals to is exist or not query.equalTo(\"name\", s.toString()); RealmResults<AccountDatabase> result1 = query.findAll(); \/\/ Here checking if count of that values is greater than zero return (result1.size() > 0) ? true : false; }","old_code_raw":"    public boolean checkAlreadyExist(String s) {\n\n        \/\/ Query in the realm database\n        RealmQuery<AccountDatabase> query = realm.where(AccountDatabase.class);\n\n        \/\/ Checking if string equals to is exist or not\n        query.equalTo(\"name\", s);\n        RealmResults<AccountDatabase> result1 = query.findAll();\n\n        \/\/ Here checking if count of that values is greater than zero\n        return (result1.size() > 0) ? true : false;\n    }\n","new_comment_raw":"@param s Name of the account from accountList e.g. Twitter","old_comment_raw":"@param s Name of the account from accountList e.g. Twitter","label":0,"pre_label":1,"AST_level":7,"line_counts":13,"new_code_token_num":85},{"new_code_raw":"public int get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }","old_code_raw":"    public int get(WithAttributes attributes) {\r\n        return attributes.getAttributes().get(this);\r\n    }\r\n","new_comment_raw":"@param withAttributes an object containing an AttributeMap","old_comment_raw":"@param attributes an object containing an AttributeMap","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":19},{"new_code_raw":"public String invokeAPI(String path, String method, Set<QueryParam> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); b.append(\"?\"); if (queryParams != null){ for (QueryParam queryParam : queryParams){ if (!queryParam.getName().isEmpty()) { b.append(escapeString(queryParam.getName())); b.append(\"=\"); b.append(escapeString(queryParam.getValue())); b.append(\"&\"); } } } String querystring = b.substring(0, b.length() - 1); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(\"GET\".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (\"POST\".equals(method)) { if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (\"PUT\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (\"DELETE\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, \"unknown method type \" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return \"\"; } } else { String message = \"error\"; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { \/\/ e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }","old_code_raw":"  public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    for(String key : queryParams.keySet()) {\n      String value = queryParams.get(key);\n      if (value != null){\n        if(b.toString().length() == 0)\n          b.append(\"?\");\n        else\n          b.append(\"&\");\n        b.append(escapeString(key)).append(\"=\").append(escapeString(value));\n      }\n    }\n    String querystring = b.toString();\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          \/\/ e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n","new_comment_raw":"@param contentType The request's Content-Type header","old_comment_raw":"@param contentType The request's Content-Type header","label":0,"pre_label":1,"AST_level":16,"line_counts":113,"new_code_token_num":736},{"new_code_raw":"private String getArrayTypeDeclaration(ArraySchema arr) { \/\/ TODO: collection type here should be fully qualified namespace to avoid model conflicts \/\/ This supports arrays of arrays. String arrayType = typeMapping.get(\"array\"); StringBuilder instantiationType = new StringBuilder(arrayType); Schema items = arr.getItems(); String nestedType = getTypeDeclaration(items); \/\/ TODO: We may want to differentiate here between generics and primitive arrays. instantiationType.append(\"<\").append(nestedType).append(\">\"); return instantiationType.toString(); }","old_code_raw":"    private String getArrayTypeDeclaration(ArrayProperty arr) {\n        \/\/ TODO: collection type here should be fully qualified namespace to avoid model conflicts\n        \/\/ This supports arrays of arrays.\n        String arrayType = typeMapping.get(\"array\");\n        StringBuilder instantiationType = new StringBuilder(arrayType);\n        Property items = arr.getItems();\n        String nestedType = getTypeDeclaration(items);\n        \/\/ TODO: We may want to differentiate here between generics and primitive arrays.\n        instantiationType.append(\"<\").append(nestedType).append(\">\");\n        return instantiationType.toString();\n    }\n","new_comment_raw":"@param arr Array schema","old_comment_raw":"@param arr","label":1,"pre_label":0,"AST_level":6,"line_counts":12,"new_code_token_num":101},{"new_code_raw":"public List<String> dependencyPathBetween(int start, int end, Function<Sentence, List<String>> selector) { \/\/ Get paths from a node to the root of the sentence LinkedList<Integer> rootToStart = new LinkedList<>(); LinkedList<Integer> rootToEnd = new LinkedList<>(); int startAncestor = start; while (sentence.governor(startAncestor).isPresent() && sentence.governor(startAncestor).get() >= 0) { rootToStart.addFirst(startAncestor); startAncestor = sentence.governor(startAncestor).get(); } if (startAncestor == -1) { rootToStart.addFirst(-1); } int endAncestor = end; while (sentence.governor(endAncestor).isPresent() && sentence.governor(endAncestor).get() >= 0) { rootToEnd.addFirst(endAncestor); endAncestor = sentence.governor(endAncestor).get(); } if (endAncestor == -1) { rootToEnd.addFirst(-1); } \/\/ Get least common node int leastCommonNodeIndex = (rootToStart.size() == 0 || rootToEnd.size() == 0 || !rootToStart.get(0).equals(rootToEnd.get(0))) ? -1 : 0; for (int i = 1; i < Math.min(rootToStart.size(), rootToEnd.size()); ++i) { if (rootToStart.get(i).equals(rootToEnd.get(i))) { leastCommonNodeIndex = i; } } \/\/ Construct the path if (leastCommonNodeIndex < 0) { return Collections.EMPTY_LIST; } List<String> path = new ArrayList<>(); for (int i = rootToStart.size() - 1; i > leastCommonNodeIndex; --i) { path.add(selector.apply(sentence).get(rootToStart.get(i))); path.add(\"<-\" + sentence.incomingDependencyLabel(rootToStart.get(i)).orElse(\"dep\") + \"-\"); } path.add(selector.apply(sentence).get(rootToStart.get(leastCommonNodeIndex))); for (int i = leastCommonNodeIndex + 1; i < rootToEnd.size(); ++i) { path.add(\"-\" + sentence.incomingDependencyLabel(rootToEnd.get(i)).orElse(\"dep\") + \"->\"); path.add(selector.apply(sentence).get(rootToEnd.get(i))); } return path; }","old_code_raw":"  public List<String> dependencyPathBetween(int start, int end) {\n    \/\/ Get paths from a node to the root of the sentence\n    LinkedList<Integer> rootToStart = new LinkedList<>();\n    LinkedList<Integer> rootToEnd = new LinkedList<>();\n    int startAncestor = start;\n    while (sentence.governor(startAncestor).isPresent() && sentence.governor(startAncestor).get() >= 0) {\n      rootToStart.addFirst(startAncestor);\n      startAncestor = sentence.governor(startAncestor).get();\n    }\n    if (startAncestor == -1) {\n      rootToStart.addFirst(-1);\n    }\n    int endAncestor = start;\n    while (sentence.governor(endAncestor).isPresent() && sentence.governor(endAncestor).get() >= 0) {\n      rootToEnd.addFirst(endAncestor);\n      endAncestor = sentence.governor(endAncestor).get();\n    }\n    if (endAncestor == -1) {\n      rootToEnd.addFirst(-1);\n    }\n\n    \/\/ Get least common node\n    return null;   \/\/ TODO(gabor) write me!\n\n\n  }\n","new_comment_raw":"@param  The type of the element we are getting.","old_comment_raw":"@param The type of the element we are getting.","label":0,"pre_label":1,"AST_level":11,"line_counts":46,"new_code_token_num":436},{"new_code_raw":"public int compareTo(ReadablePartial other) { if (this == other) { return 0; } if (size() != other.size()) { throw new ClassCastException(\"ReadablePartial objects must have matching field types\"); } for (int i = 0, isize = size(); i < isize; i++) { if (getFieldType(i) != other.getFieldType(i)) { throw new ClassCastException(\"ReadablePartial objects must have matching field types\"); } } \/\/ fields are ordered largest first for (int i = 0, isize = size(); i < isize; i++) { if (getValue(i) > other.getValue(i)) { return 1; } if (getValue(i) < other.getValue(i)) { return -1; } } return 0; }","old_code_raw":"    public int compareTo(Object partial) {\n        if (this == partial) {\n            return 0;\n        }\n        ReadablePartial other = (ReadablePartial) partial;\n        if (size() != other.size()) {\n            throw new ClassCastException(\"ReadablePartial objects must have matching field types\");\n        }\n        for (int i = 0, isize = size(); i < isize; i++) {\n            if (getFieldType(i) != other.getFieldType(i)) {\n                throw new ClassCastException(\"ReadablePartial objects must have matching field types\");\n            }\n        }\n        \/\/ fields are ordered largest first\n        for (int i = 0, isize = size(); i < isize; i++) {\n            if (getValue(i) > other.getValue(i)) {\n                return 1;\n            }\n            if (getValue(i) < other.getValue(i)) {\n                return -1;\n            }\n        }\n        return 0;\n    }\n","new_comment_raw":"@param other an object to check against","old_comment_raw":"@param partial an object to check against","label":1,"pre_label":0,"AST_level":9,"line_counts":24,"new_code_token_num":162},{"new_code_raw":"private static EntityKey getOptionalObjectKey(QueryParameters queryParameters, SharedSessionContractImplementor session) { final Object optionalObject = queryParameters.getOptionalObject(); final Serializable optionalId = queryParameters.getOptionalId(); final String optionalEntityName = queryParameters.getOptionalEntityName(); if ( optionalObject != null && optionalEntityName != null ) { return session.generateEntityKey( optionalId, session.getEntityPersister( optionalEntityName, optionalObject ) ); } else { return null; } }","old_code_raw":"\tprivate static EntityKey getOptionalObjectKey(QueryParameters queryParameters, SessionImplementor session) {\n\t\tfinal Object optionalObject = queryParameters.getOptionalObject();\n\t\tfinal Serializable optionalId = queryParameters.getOptionalId();\n\t\tfinal String optionalEntityName = queryParameters.getOptionalEntityName();\n\n\t\tif ( optionalObject != null && optionalEntityName != null ) {\n\t\t\treturn session.generateEntityKey(\n\t\t\t\t\toptionalId, session.getEntityPersister(\n\t\t\t\t\t\t\toptionalEntityName,\n\t\t\t\t\t\t\toptionalObject\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\n\t}\n","new_comment_raw":"@param queryParameters The query parameters specified by the user.","old_comment_raw":"@param queryParameters The query parameters specified by the user.","label":0,"pre_label":1,"AST_level":8,"line_counts":19,"new_code_token_num":71},{"new_code_raw":"public ApiResponse<Client> testClientModelWithHttpInfo(Client client) throws ApiException { Object localVarPostBody = client; \/\/ verify the required parameter 'client' is set if (client == null) { throw new ApiException(400, \"Missing the required parameter 'client' when calling testClientModel\"); } \/\/ create path and map variables String localVarPath = \"\/fake\"; \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { \"application\/json\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { \"application\/json\" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Client> localVarReturnType = new GenericType<Client>() {}; return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public ApiResponse<Client> testClientModelWithHttpInfo(Client body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    \/\/ verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling testClientModel\");\n    }\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/fake\";\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application\/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application\/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@param client client model (required)","old_comment_raw":"@param body client model (required)","label":1,"pre_label":0,"AST_level":8,"line_counts":35,"new_code_token_num":200},{"new_code_raw":"public Object getCollection(Serializable key, SharedSessionContractImplementor session, Object owner) { CollectionPersister persister = getPersister( session ); final PersistenceContext persistenceContext = session.getPersistenceContext(); final EntityMode entityMode = persister.getOwnerEntityPersister().getEntityMode(); \/\/ check if collection is currently being loaded PersistentCollection collection = persistenceContext.getLoadContexts().locateLoadingCollection( persister, key ); if ( collection == null ) { \/\/ check if it is already completely loaded, but unowned collection = persistenceContext.useUnownedCollection( new CollectionKey(persister, key, entityMode) ); if ( collection == null ) { collection = persistenceContext.getCollection( new CollectionKey(persister, key, entityMode) ); if ( collection == null ) { \/\/ create a new collection wrapper, to be initialized later collection = instantiate( session, persister, key ); collection.setOwner( owner ); persistenceContext.addUninitializedCollection( persister, collection, key ); \/\/ some collections are not lazy: if ( initializeImmediately() ) { session.initializeCollection( collection, false ); } else if ( !persister.isLazy() ) { persistenceContext.addNonLazyCollection( collection ); } if ( hasHolder() ) { session.getPersistenceContext().addCollectionHolder( collection ); } } } if ( LOG.isTraceEnabled() ) { LOG.tracef( \"Created collection wrapper: %s\", MessageHelper.collectionInfoString( persister, collection, key, session ) ); } } collection.setOwner(owner); return collection.getValue(); }","old_code_raw":"\tpublic Object getCollection(Serializable key, SessionImplementor session, Object owner) {\n\n\t\tCollectionPersister persister = getPersister( session );\n\t\tfinal PersistenceContext persistenceContext = session.getPersistenceContext();\n\t\tfinal EntityMode entityMode = persister.getOwnerEntityPersister().getEntityMode();\n\n\t\t\/\/ check if collection is currently being loaded\n\t\tPersistentCollection collection = persistenceContext.getLoadContexts().locateLoadingCollection( persister, key );\n\t\t\n\t\tif ( collection == null ) {\n\t\t\t\n\t\t\t\/\/ check if it is already completely loaded, but unowned\n\t\t\tcollection = persistenceContext.useUnownedCollection( new CollectionKey(persister, key, entityMode) );\n\t\t\t\n\t\t\tif ( collection == null ) {\n\n\t\t\t\tcollection = persistenceContext.getCollection( new CollectionKey(persister, key, entityMode) );\n\n\t\t\t\tif ( collection == null ) {\n\t\t\t\t\t\/\/ create a new collection wrapper, to be initialized later\n\t\t\t\t\tcollection = instantiate( session, persister, key );\n\n\t\t\t\t\tcollection.setOwner( owner );\n\n\t\t\t\t\tpersistenceContext.addUninitializedCollection( persister, collection, key );\n\n\t\t\t\t\t\/\/ some collections are not lazy:\n\t\t\t\t\tif ( initializeImmediately() ) {\n\t\t\t\t\t\tsession.initializeCollection( collection, false );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( !persister.isLazy() ) {\n\t\t\t\t\t\tpersistenceContext.addNonLazyCollection( collection );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasHolder() ) {\n\t\t\t\t\t\tsession.getPersistenceContext().addCollectionHolder( collection );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracef( \"Created collection wrapper: %s\",\n\t\t\t\t\t\tMessageHelper.collectionInfoString( persister, collection,\n\t\t\t\t\t\t\t\tkey, session ) );\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tcollection.setOwner(owner);\n\n\t\treturn collection.getValue();\n\t}\n","new_comment_raw":"@param session The session from which the request is originating.","old_comment_raw":"@param session The session from which the request is originating.","label":0,"pre_label":1,"AST_level":14,"line_counts":54,"new_code_token_num":268},{"new_code_raw":"public static FileSelection create(List<FileStatus> statuses, List<Path> files, Path root) { return FileSelection.create(statuses, files, root, null, false); }","old_code_raw":"  public static FileSelection create(final List<FileStatus> statuses, final List<String> files, final String root) {\n    return FileSelection.create(statuses, files, root, null, false);\n  }\n","new_comment_raw":"@param statuses list of file statuses","old_comment_raw":"@param statuses list of file statuses","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":33},{"new_code_raw":"public Collection<Tree> getRelatedNodes(Tree t, Tree root) { if (root.value() == null) { root.setValue(\"ROOT\"); \/\/ todo: cdm: it doesn't seem like this line should be here } Set<Tree> nodeList = new LinkedHashSet<Tree>(); for (TregexPattern p : targetPatterns) { \/\/ cdm: I deleted: && nodeList.isEmpty() TregexMatcher m = p.matcher(root); while (m.findAt(t)) { nodeList.add(m.getNode(\"target\")); if (DEBUG) { System.err.println(\"found \" + this + \"(\" + t + \", \" + m.getNode(\"target\") + \") using pattern \" + p); for (String nodeName : m.getNodeNames()) { if (nodeName.equals(\"target\")) continue; System.err.println(\" node \" + nodeName + \": \" + m.getNode(nodeName)); } } } } return nodeList; }","old_code_raw":"  public Collection<Tree> getRelatedNodes(Tree t, Tree root, HeadFinder headFinder) {\n    Set<Tree> nodeList = new ArraySet<Tree>();\n    for (TregexPattern p : targetPatterns) {    \/\/ cdm: I deleted: && nodeList.isEmpty()\n      \/\/ Initialize the TregexMatcher with the HeadFinder so that we\n      \/\/ can use the same HeadFinder through the entire process of\n      \/\/ building the dependencies\n      TregexMatcher m = p.matcher(root, headFinder);\n      while (m.findAt(t)) {\n        nodeList.add(m.getNode(\"target\"));\n        if (DEBUG) {\n          System.err.println(\"found \" + this + \"(\" + t + \", \" + m.getNode(\"target\") + \") using pattern \" + p);\n          for (String nodeName : m.getNodeNames()) {\n            if (nodeName.equals(\"target\"))\n              continue;\n            System.err.println(\"  node \" + nodeName + \": \" + m.getNode(nodeName));\n          }\n        }\n      }\n    }\n    return nodeList;\n  }\n","new_comment_raw":"@param t Target for finding governors of t related by this GR","old_comment_raw":"@param t Target for finding dependents of t related by this GR","label":1,"pre_label":0,"AST_level":18,"line_counts":22,"new_code_token_num":200},{"new_code_raw":"public boolean parseMoreData(final EncodedImage encodedImage) { if (mParserState == NOT_A_JPEG) { return false; } final int dataBufferSize = encodedImage.getSize(); \/\/ Is there any new data to parse? \/\/ mBytesParsed might be greater than size of dataBuffer - that happens when \/\/ we skip more data than is available to read inside doParseMoreData method if (dataBufferSize <= mBytesParsed) { return false; } final InputStream bufferedDataStream = new PooledByteArrayBufferedInputStream( encodedImage.getInputStream(), mByteArrayPool.get(BUFFER_SIZE), mByteArrayPool); try { StreamUtil.skip(bufferedDataStream, mBytesParsed); return doParseMoreData(bufferedDataStream); } catch (IOException ioe) { \/\/ Does not happen - streams returned by PooledByteBuffers do not throw IOExceptions Throwables.propagate(ioe); return false; } finally { Closeables.closeQuietly(bufferedDataStream); } }","old_code_raw":"  public boolean parseMoreData(final CloseableReference<PooledByteBuffer> dataBufferRef) {\n    if (mParserState == NOT_A_JPEG) {\n      return false;\n    }\n\n    final PooledByteBuffer dataBuffer = dataBufferRef.get();\n    final int dataBufferSize = dataBuffer.size();\n\n    \/\/ Is there any new data to parse?\n    \/\/ mBytesParsed might be greater than size of dataBuffer - that happens when\n    \/\/ we skip more data than is available to read inside doParseMoreData method\n    if (dataBufferSize <= mBytesParsed) {\n      return false;\n    }\n\n    final InputStream bufferedDataStream = new PooledByteArrayBufferedInputStream(\n        new PooledByteBufferInputStream(dataBuffer),\n        mByteArrayPool.get(BUFFER_SIZE),\n        mByteArrayPool);\n    try {\n      StreamUtil.skip(bufferedDataStream, mBytesParsed);\n      return doParseMoreData(bufferedDataStream);\n    } catch (IOException ioe) {\n      \/\/ Does not happen - streams returned by PooledByteBuffers do not throw IOExceptions\n      Throwables.propagate(ioe);\n      return false;\n    } finally {\n      Closeables.closeQuietly(bufferedDataStream);\n    }\n  }\n","new_comment_raw":"@param encodedImage Next set of bytes received by the caller","old_comment_raw":"@param dataBufferRef Next set of bytes received by the caller","label":1,"pre_label":0,"AST_level":7,"line_counts":30,"new_code_token_num":152},{"new_code_raw":"public Boolean fakeOuterBooleanSerialize(Boolean body) throws RestClientException { Object postBody = body; String path = UriComponentsBuilder.fromPath(\"\/fake\/outer\/boolean\").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { \"*\/*\" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<Boolean> returnType = new ParameterizedTypeReference<Boolean>() {}; return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }","old_code_raw":"    public Boolean fakeOuterBooleanSerialize(Boolean booleanPostBody) throws RestClientException {\n        Object postBody = booleanPostBody;\n        \n        String path = UriComponentsBuilder.fromPath(\"\/fake\/outer\/boolean\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"*\/*\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<Boolean> returnType = new ParameterizedTypeReference<Boolean>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n","new_comment_raw":"@param body Input boolean as post body","old_comment_raw":"@param booleanPostBody Input boolean as post body","label":1,"pre_label":0,"AST_level":8,"line_counts":22,"new_code_token_num":160},{"new_code_raw":"public Collection<Tree> getRelatedNodes(Tree t, Tree root) { if (root.value() == null) { root.setValue(\"ROOT\"); \/\/ todo: cdm: it doesn't seem like this line should be here } Set<Tree> nodeList = new LinkedHashSet<Tree>(); for (TregexPattern p : targetPatterns) { \/\/ cdm: I deleted: && nodeList.isEmpty() TregexMatcher m = p.matcher(root); while (m.findAt(t)) { nodeList.add(m.getNode(\"target\")); \/\/System.out.println(\"found \" + this + \"(\" + t + \", \" + m.getNode(\"target\") + \") using pattern \" + p); } } return nodeList; }","old_code_raw":"  public Collection<TreeGraphNode> getRelatedNodes(TreeGraphNode t, TreeGraphNode root, HeadFinder headFinder) {\n    Set<TreeGraphNode> nodeList = new ArraySet<TreeGraphNode>();\n    for (TregexPattern p : targetPatterns) {    \/\/ cdm: I deleted: && nodeList.isEmpty()\n      \/\/ Initialize the TregexMatcher with the HeadFinder so that we\n      \/\/ can use the same HeadFinder through the entire process of\n      \/\/ building the dependencies\n      TregexMatcher m = p.matcher(root, headFinder);\n      while (m.findAt(t)) {\n        TreeGraphNode target = (TreeGraphNode) m.getNode(\"target\");\n        if (target == null) {\n          throw new AssertionError(\"Expression has no target: \" + p);\n        }\n        nodeList.add(target);\n        if (DEBUG) {\n          System.err.println(\"found \" + this + \"(\" + t + \"-\" + t.headWordNode() + \", \" + m.getNode(\"target\") + \"-\" + ((TreeGraphNode) m.getNode(\"target\")).headWordNode() + \") using pattern \" + p);\n          for (String nodeName : m.getNodeNames()) {\n            if (nodeName.equals(\"target\"))\n              continue;\n            System.err.println(\"  node \" + nodeName + \": \" + m.getNode(nodeName));\n          }\n        }\n      }\n    }\n    return nodeList;\n  }\n","new_comment_raw":"@param root The root of the Tree","old_comment_raw":"@param root The root of the Tree","label":0,"pre_label":1,"AST_level":10,"line_counts":15,"new_code_token_num":151},{"new_code_raw":"public Order placeOrder (Order order) throws ApiException { Object localVarPostBody = order; \/\/ verify the required parameter 'order' is set if (order == null) { throw new ApiException(400, \"Missing the required parameter 'order' when calling placeOrder\"); } \/\/ create path and map variables String localVarPath = \"\/store\/order\".replaceAll(\"\\\\{format\\\\}\",\"json\"); \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); \/\/ header params Map<String, String> localVarHeaderParams = new HashMap<String, String>(); \/\/ form params Map<String, String> localVarFormParams = new HashMap<String, String>(); String[] localVarContentTypes = { \"application\/json\" }; String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : \"application\/json\"; if (localVarContentType.startsWith(\"multipart\/form-data\")) { \/\/ file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); localVarPostBody = localVarBuilder.build(); } else { \/\/ normal form params } try { String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType); if(localVarResponse != null){ return (Order) ApiInvoker.deserialize(localVarResponse, \"\", Order.class); } else { return null; } } catch (ApiException ex) { throw ex; } }","old_code_raw":"  public Order  placeOrder (Order body) throws ApiException {\n    Object localVarPostBody = body;\n    \/\/ verify the required parameter 'body' is set\n    if (body == null) {\n       throw new ApiException(400, \"Missing the required parameter 'body' when calling placeOrder\");\n    }\n\n    \/\/ create path and map variables\n    String localVarPath = \"\/store\/order\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    \/\/ header params\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    \/\/ form params\n    Map<String, String> localVarFormParams = new HashMap<String, String>();\n\n\n\n    String[] localVarContentTypes = {\n      \n    };\n    String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : \"application\/json\";\n\n    if (localVarContentType.startsWith(\"multipart\/form-data\")) {\n      \/\/ file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      \n\n      localVarPostBody = localVarBuilder.build();\n    } else {\n      \/\/ normal form params\n          }\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType);\n      if(localVarResponse != null){\n        return (Order) ApiInvoker.deserialize(localVarResponse, \"\", Order.class);\n      }\n      else {\n        return null;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n","new_comment_raw":"@param order order placed for purchasing the pet","old_comment_raw":"@param body order placed for purchasing the pet","label":1,"pre_label":0,"AST_level":10,"line_counts":47,"new_code_token_num":269},{"new_code_raw":"private RexNode convertUsing(SqlValidatorNamespace leftNamespace, SqlValidatorNamespace rightNamespace, List<String> nameList) { final List<RexNode> list = Lists.newArrayList(); for (String name : nameList) { List<RexNode> operands = new ArrayList<>(); int offset = 0; for (SqlValidatorNamespace n : ImmutableList.of(leftNamespace, rightNamespace)) { final RelDataType rowType = n.getRowType(); final RelDataTypeField field = catalogReader.field(rowType, name); operands.add(rexBuilder.makeInputRef(field.getType(), offset + field.getIndex())); offset += rowType.getFieldList().size(); } list.add(rexBuilder.makeCall(SqlStdOperatorTable.EQUALS, operands)); } return RexUtil.composeConjunction(rexBuilder, list, false); }","old_code_raw":"    private RexNode convertUsing(RelNode leftRel, RelNode rightRel, List<String> nameList) {\n        final List<RexNode> list = Lists.newArrayList();\n        for (String name : nameList) {\n            final RelDataType leftRowType = leftRel.getRowType();\n            RelDataTypeField leftField = catalogReader.field(leftRowType, name);\n            RexNode left = rexBuilder.makeInputRef(leftField.getType(), leftField.getIndex());\n            final RelDataType rightRowType = rightRel.getRowType();\n            RelDataTypeField rightField = catalogReader.field(rightRowType, name);\n            RexNode right = rexBuilder.makeInputRef(rightField.getType(), leftRowType.getFieldList().size() + rightField.getIndex());\n            RexNode equalsCall = rexBuilder.makeCall(SqlStdOperatorTable.EQUALS, left, right);\n            list.add(equalsCall);\n        }\n        return RexUtil.composeConjunction(rexBuilder, list, false);\n    }\n","new_comment_raw":"@param nameList List of column names to join on","old_comment_raw":"@param nameList List of column names to join on","label":0,"pre_label":1,"AST_level":11,"line_counts":16,"new_code_token_num":134},{"new_code_raw":"public Actions release(WebElement target) { if (isBuildingActions()) { action.addAction(new ButtonReleaseAction(jsonMouse, (Locatable) target)); return this; } return moveToElement(target).release(); }","old_code_raw":"  public Actions release(WebElement onElement) {\n    action.addAction(new ButtonReleaseAction(mouse, (Locatable) onElement));\n    return this;\n  }\n","new_comment_raw":"@param target Element to release the mouse button above.","old_comment_raw":"@param onElement Element to release the mouse button above.","label":1,"pre_label":0,"AST_level":9,"line_counts":8,"new_code_token_num":44},{"new_code_raw":"public ApiResponse<Order> getOrderByIdWithHttpInfo(String orderId) throws ApiException { Call call = getOrderByIdCall(orderId, null, null); Type localVarReturnType = new TypeToken<Order>(){}.getType(); return apiClient.execute(call, localVarReturnType); }","old_code_raw":"  public ApiResponse<Order> getOrderByIdWithHttpInfo(Long orderId) throws ApiException {\n    Call call = getOrderByIdCall(orderId, null, null);\n    Type localVarReturnType = new TypeToken<Order>(){}.getType();\n    return apiClient.execute(call, localVarReturnType);\n  }\n","new_comment_raw":"@param orderId ID of pet that needs to be fetched (required)","old_comment_raw":"@param orderId ID of pet that needs to be fetched (required)","label":0,"pre_label":1,"AST_level":8,"line_counts":6,"new_code_token_num":45},{"new_code_raw":"public boolean searchText(String text, int minimumNumberOfMatches, boolean scroll) { return searcher.searchWithTimeoutFor(TextView.class, text, minimumNumberOfMatches, scroll); }","old_code_raw":"\tpublic boolean searchText(String regex, int expectedMinimumNumberOfMatches, boolean scroll) {\n\t\treturn searcher.searchWithTimeoutFor(TextView.class, regex, expectedMinimumNumberOfMatches, scroll);\n\t}\n","new_comment_raw":"@param text the text to search for. The parameter will be interpreted as a regular expression.","old_comment_raw":"@param regex the text to search for. The parameter will be interpreted as a regular expression.","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":29},{"new_code_raw":"protected TextMessage objectToText(Session session, ObjectMessage objectMessage) throws JMSException { TextMessage answer = session.createTextMessage(marshall(session, objectMessage)); copyProperties(objectMessage, answer); return answer; }","old_code_raw":"    protected Message objectToText(Session session, Message message) throws JMSException {\n        if (message instanceof ObjectMessage) {\n            TextMessage answer = session.createTextMessage(marshall(session, (ObjectMessage) message));\n            copyProperties(message, answer);\n            return answer;\n        }\n        return message;\n\t}\n","new_comment_raw":"@param objectMessage - object message to transform to text message","old_comment_raw":"@param message - if this is an ObjectMessage, it will be transformed to a TextMessage","label":1,"pre_label":0,"AST_level":7,"line_counts":7,"new_code_token_num":37},{"new_code_raw":"public boolean searchButton(String regex, int matches) { long now = System.currentTimeMillis(); final long endTime = now + TIMEOUT; while (!searchForButton(regex, matches) && now < endTime) { now = System.currentTimeMillis(); } if(now < endTime) return true; else return false; }","old_code_raw":"\tpublic boolean searchButton(String search, int matches) {\n\t\t\n        long now = System.currentTimeMillis();\n        final long endTime = now + TIMEOUT;\n        while (!searchForButton(search, matches) && now < endTime)\n        {\n        \tnow = System.currentTimeMillis();\n        }\n        if(now < endTime)\n        \treturn true;\n        else\n        \treturn false;\n\t}\n","new_comment_raw":"@param regex the text to search for. The parameter will be interpreted as a regular expression.","old_comment_raw":"@param search the string to be searched. The parameter will be interpreted as a regular expression.","label":1,"pre_label":0,"AST_level":7,"line_counts":14,"new_code_token_num":60},{"new_code_raw":"public String invokeAPI(String path, String method, Set<QueryParam> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); b.append(\"?\"); if (queryParams != null){ for (QueryParam queryParam : queryParams){ if (!queryParam.getName().isEmpty()) { b.append(escapeString(queryParam.getName())); b.append(\"=\"); b.append(escapeString(queryParam.getValue())); b.append(\"&\"); } } } String querystring = b.substring(0, b.length() - 1); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(\"GET\".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (\"POST\".equals(method)) { if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (\"PUT\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (\"DELETE\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, \"unknown method type \" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return \"\"; } } else { String message = \"error\"; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { \/\/ e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }","old_code_raw":"  public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    for(String key : queryParams.keySet()) {\n      String value = queryParams.get(key);\n      if (value != null){\n        if(b.toString().length() == 0)\n          b.append(\"?\");\n        else\n          b.append(\"&\");\n        b.append(escapeString(key)).append(\"=\").append(escapeString(value));\n      }\n    }\n    String querystring = b.toString();\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          \/\/ e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n","new_comment_raw":"@param body The request body object","old_comment_raw":"@param body The request body object","label":0,"pre_label":1,"AST_level":16,"line_counts":113,"new_code_token_num":736},{"new_code_raw":"public int compareTo(ByteArrayWritable that) { return WritableComparator.compareBytes(this.data, this.offset, this.length, that.data, that.offset, that.length); }","old_code_raw":"    public int compareTo(final byte[] that) {\n        return WritableComparator.compareBytes(this.data, this.offset, this.length, that, 0, that.length);\n    }\n","new_comment_raw":"@param that The other bytes writable","old_comment_raw":"@param that","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":32},{"new_code_raw":"private boolean isKeepLock(String lockClient, String lockPath) { try { if (zkClient.checkExists().forPath(lockPath) != null) { byte[] data = zkClient.getData().forPath(lockPath); String lockServerName = new String(data, Charset.forName(\"UTF-8\")); return lockServerName.equalsIgnoreCase(lockClient); } } catch (Exception e) { logger.error(\"fail to get the lockClient for the path: \" + lockPath, e); } return false; }","old_code_raw":"\n    private boolean isKeepLock(String serverName, String lockPath) {\n        try {\n            if (zkClient.checkExists().forPath(lockPath) != null) {\n                byte[] data = zkClient.getData().forPath(lockPath);\n                String lockServerName = new String(data, Charset.forName(\"UTF-8\"));\n                return lockServerName.equalsIgnoreCase(serverName);\n            }\n        } catch (Exception e) {\n            logger.error(\"fail to get the serverName for the path: \" + lockPath, e);\n        }\n        return false;\n    }\n","new_comment_raw":"@param lockPath the zookeeper node path for the lock","old_comment_raw":"@param lockPath the zookeeper node path of segment","label":1,"pre_label":0,"AST_level":10,"line_counts":15,"new_code_token_num":98},{"new_code_raw":"private boolean limitTranslation(Matrix transform, boolean shouldLimitX, boolean shouldLimitY) { if (!shouldLimitX && !shouldLimitY) { return false; } RectF b = mTempRect; b.set(mImageBounds); transform.mapRect(b); float offsetLeft = !shouldLimitX ? 0 : getOffset(b.left, b.right, mViewBounds.left, mViewBounds.right, mImageBounds.centerX()); float offsetTop = !shouldLimitY ? 0 : getOffset(b.top, b.bottom, mViewBounds.top, mViewBounds.bottom, mImageBounds.centerY()); if (offsetLeft != 0 || offsetTop != 0) { transform.postTranslate(offsetLeft, offsetTop); return true; } return false; }","old_code_raw":"  private boolean limitTranslation(Matrix transform, boolean limitX, boolean limitY) {\n    RectF bounds = mTempRect;\n    bounds.set(mImageBounds);\n    transform.mapRect(bounds);\n    float offsetLeft = limitX ?\n        getOffset(bounds.left, bounds.right, mViewBounds.left, mViewBounds.right) : 0;\n    float offsetTop = limitY ?\n        getOffset(bounds.top, bounds.bottom, mViewBounds.top, mViewBounds.bottom) : 0;\n    if (offsetLeft != 0 || offsetTop != 0) {\n      transform.postTranslate(offsetLeft, offsetTop);\n      return true;\n    }\n    return false;\n  }\n","new_comment_raw":"@param shouldLimitY whether to apply the limit on the y-axis","old_comment_raw":"@param limitY whether to apply the limit on the y-axis","label":1,"pre_label":0,"AST_level":7,"line_counts":18,"new_code_token_num":126},{"new_code_raw":"public String getAuthorizationUrl(OAuth1RequestToken requestToken) { return api.getAuthorizationUrl(requestToken); }","old_code_raw":"    public String getAuthorizationUrl(Token requestToken) {\n        return api.getAuthorizationUrl(requestToken);\n    }\n","new_comment_raw":"@param requestToken the request token you need to authorize","old_comment_raw":"@param requestToken the request token you need to authorize","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":16},{"new_code_raw":"public Object readPayload(DataInput dataIn) throws IOException{ return dataIn.readUTF(); }","old_code_raw":"    public Object readPayload(DataInputStream dataIn) throws IOException{\n        return dataIn.readUTF();\n    }\n","new_comment_raw":"@param dataIn","old_comment_raw":"@param dataIn","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":17},{"new_code_raw":"public Serializable generate(SharedSessionContractImplementor session, Object object) throws HibernateException { return optimizer.generate( databaseStructure.buildCallback( session ) ); }","old_code_raw":"\tpublic Serializable generate(SessionImplementor session, Object object) throws HibernateException {\n\t\treturn optimizer.generate( databaseStructure.buildCallback( session ) );\n\t}\n","new_comment_raw":"@param initialValue The initial value.","old_comment_raw":"@param initialValue The initial value.","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":25},{"new_code_raw":"private boolean scrollScrollView(int direction, ArrayList<ScrollView> scrollViews){ int[] xy = new int[2]; ScrollView scroll = viewFetcher.getView(ScrollView.class, scrollViews, 0); scroll.getLocationOnScreen(xy); int height = scroll.getHeight(); int to = 0; if (direction == DOWN) { to = (height); } else if (direction == UP) { to = (-height); } scrollAmount = scroll.getScrollY(); scrollScrollViewTo(scroll,0, to); if (scrollAmount == scroll.getScrollY()) { return false; } else{ return true; } }","old_code_raw":"\tprivate boolean scrollScrollView(Direction direction, ArrayList<ScrollView> scrollViews){\n\t\tint yStart = 0;\n\t\tint yEnd = 0;\n\t\tint[] xy = new int[2];\n\t\tint x = activityUtils.getCurrentActivity(false).getWindowManager()\n\t\t.getDefaultDisplay().getWidth() \/ 2;\n\t\tScrollView scroll = viewFetcher.getView(ScrollView.class, scrollViews, 0);\n\t\tscroll.getLocationOnScreen(xy);\n\n\t\tif (direction == Direction.DOWN) {\n\t\t\tyStart = ((xy[1] + scroll.getHeight()) - 20);\n\t\t\tyEnd = (xy[1] + 30);\n\t\t}\n\t\telse if (direction == Direction.UP){\n\t\t\tyStart = (xy[1] + 20);\n\t\t\tyEnd = ((xy[1] + scroll.getHeight()) - 30);\n\t\t}\n\n\t\tscrollAmount = scroll.getScrollY();\n\t\tdrag(x, x,getDragablePosition(yStart, direction), yEnd, 40);\n\t\tif (scrollAmount == scroll.getScrollY()) {\n\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t\treturn true;\n\t}\n","new_comment_raw":"@param direction the direction to be scrolled","old_comment_raw":"@param direction the direction to be scrolled","label":0,"pre_label":1,"AST_level":8,"line_counts":24,"new_code_token_num":113},{"new_code_raw":"private boolean limitTranslation(Matrix transform, boolean shouldLimitX, boolean shouldLimitY) { if (!shouldLimitX && !shouldLimitY) { return false; } RectF b = mTempRect; b.set(mImageBounds); transform.mapRect(b); float offsetLeft = !shouldLimitX ? 0 : getOffset(b.left, b.right, mViewBounds.left, mViewBounds.right, mImageBounds.centerX()); float offsetTop = !shouldLimitY ? 0 : getOffset(b.top, b.bottom, mViewBounds.top, mViewBounds.bottom, mImageBounds.centerY()); if (offsetLeft != 0 || offsetTop != 0) { transform.postTranslate(offsetLeft, offsetTop); return true; } return false; }","old_code_raw":"  private boolean limitTranslation(Matrix transform, boolean limitX, boolean limitY) {\n    RectF bounds = mTempRect;\n    bounds.set(mImageBounds);\n    transform.mapRect(bounds);\n    float offsetLeft = limitX ?\n        getOffset(bounds.left, bounds.right, mViewBounds.left, mViewBounds.right) : 0;\n    float offsetTop = limitY ?\n        getOffset(bounds.top, bounds.bottom, mViewBounds.top, mViewBounds.bottom) : 0;\n    if (offsetLeft != 0 || offsetTop != 0) {\n      transform.postTranslate(offsetLeft, offsetTop);\n      return true;\n    }\n    return false;\n  }\n","new_comment_raw":"@param shouldLimitX whether to apply the limit on the x-axis","old_comment_raw":"@param limitX whether to apply the limit on the x-axis","label":1,"pre_label":0,"AST_level":7,"line_counts":18,"new_code_token_num":126},{"new_code_raw":"protected boolean isNull(Object owner, SharedSessionContractImplementor session) { return false; }","old_code_raw":"\tprotected boolean isNull(Object owner, SessionImplementor session) {\n\t\treturn false;\n\t}\n","new_comment_raw":"@param id The entity id to resolve","old_comment_raw":"@param id The entity id to resolve","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":15},{"new_code_raw":"public ArrayList<TextView> clickInList(int line, int index) { return clicker.clickInList(line, index); }","old_code_raw":"\tpublic ArrayList<TextView> clickInList(int line, int listIndex) {\n\t\treturn clicker.clickInList(line, listIndex);\n\t}\n","new_comment_raw":"@param index the index of the list. 1 if two lists are available","old_comment_raw":"@param listIndex the index of the list. 1 if two lists are available","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":22},{"new_code_raw":"public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) { if (fieldType == null) { throw new IllegalArgumentException(\"Field type must not be null\"); } DateTimeField field = fieldType.getField(iChronoUTC); return append0(new TextField(iChrono, field, iLocale, true)); }","old_code_raw":"    public DateTimeFormatterBuilder appendShortText(final DateTimeField field) {\n        return append0(new TextField(iChrono, field, iLocale, true));\n    }\n","new_comment_raw":"@param fieldType type of field to append","old_comment_raw":"@param field field should operate in UTC or be time zone agnostic","label":1,"pre_label":0,"AST_level":7,"line_counts":8,"new_code_token_num":54},{"new_code_raw":"public Index parseAndUpdateIndex(List<JaxbRoot<XMLEntityMappings>> mappings, Index annotationIndex) { for ( JaxbRoot<XMLEntityMappings> root : mappings ) { root.getRoot().toString(); } return annotationIndex; }","old_code_raw":"\tpublic Index parseAndUpdateIndex(Set<String> mappingFileNames, Index annotationIndex) {\n\t\tClassLoaderService classLoaderService = meta.getServiceRegistry().getService( ClassLoaderService.class );\n\t\tSet<InputStream> mappingStreams = new HashSet<InputStream>();\n\t\tfor ( String fileName : mappingFileNames ) {\n\n\t\t\tXMLEntityMappings entityMappings;\n\t\t\ttry {\n\t\t\t\tentityMappings = XmlHelper.unmarshallXml(\n\t\t\t\t\t\tfileName, ORM2_MAPPING_XSD, XMLEntityMappings.class, classLoaderService\n\t\t\t\t).getRoot();\n\t\t\t}\n\t\t\tcatch ( JAXBException orm2Exception ) {\n\t\t\t\t\/\/ if we cannot parse against orm_2_0.xsd we try orm_1_0.xsd for backwards compatibility\n\t\t\t\ttry {\n\t\t\t\t\tentityMappings = XmlHelper.unmarshallXml(\n\t\t\t\t\t\t\tfileName, ORM1_MAPPING_XSD, XMLEntityMappings.class, classLoaderService\n\t\t\t\t\t).getRoot();\n\t\t\t\t}\n\t\t\t\tcatch ( JAXBException orm1Exception ) {\n\t\t\t\t\tthrow new AnnotationException( \"Unable to parse xml configuration.\", orm1Exception );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tentityMappings.toString();\n\t\t}\n\n\t\treturn null;\n\t}\n","new_comment_raw":"@param mappings list of  XMLEntityMappings created from the specified orm xml files","old_comment_raw":"@param mappingFileNames the file names of the xml files to parse","label":1,"pre_label":0,"AST_level":8,"line_counts":7,"new_code_token_num":35},{"new_code_raw":"private void collectFields(FieldCollectorParameters parameters, SelectionSet selectionSet, List<String> visitedFragments, Map<String, List<Field>> fields) { for (Selection selection : selectionSet.getSelections()) { if (selection instanceof Field) { collectField(parameters, fields, (Field) selection); } else if (selection instanceof InlineFragment) { collectInlineFragment(parameters, visitedFragments, fields, (InlineFragment) selection); } else if (selection instanceof FragmentSpread) { collectFragmentSpread(parameters, visitedFragments, fields, (FragmentSpread) selection); } } }","old_code_raw":"    public MergedSelectionSet collectFields(FieldCollectorParameters parameters, SelectionSet selectionSet) {\n        Map<String, MergedFields> subFields = new LinkedHashMap<>();\n        List<String> visitedFragments = new ArrayList<>();\n        this.collectFields(parameters, selectionSet, visitedFragments, subFields);\n        return newMergedSelectionSet().subFields(subFields).build();\n    }\n","new_comment_raw":"@param parameters the parameters to this method","old_comment_raw":"@param parameters the parameters to this method","label":0,"pre_label":1,"AST_level":12,"line_counts":13,"new_code_token_num":101},{"new_code_raw":"private RexNode adjustCondition(LogicalProject project, SemiJoin semiJoin) { \/\/ create two RexPrograms -- the bottom one representing a \/\/ concatenation of the project and the RHS of the semijoin and the \/\/ top one representing the semijoin condition RexBuilder rexBuilder = project.getCluster().getRexBuilder(); RelDataTypeFactory typeFactory = rexBuilder.getTypeFactory(); RelNode rightChild = semiJoin.getRight(); \/\/ for the bottom RexProgram, the input is a concatenation of the \/\/ child of the project and the RHS of the semijoin RelDataType bottomInputRowType = Join.deriveJoinRowType( project.getInput().getRowType(), rightChild.getRowType(), JoinRelType.INNER, typeFactory, null, semiJoin.getSystemFieldList()); RexProgramBuilder bottomProgramBuilder = new RexProgramBuilder(bottomInputRowType, rexBuilder); \/\/ add the project expressions, then add input references for the RHS \/\/ of the semijoin for (Pair<RexNode, String> pair : project.getNamedProjects()) { bottomProgramBuilder.addProject(pair.left, pair.right); } int nLeftFields = project.getInput().getRowType().getFieldCount(); List<RelDataTypeField> rightFields = rightChild.getRowType().getFieldList(); int nRightFields = rightFields.size(); for (int i = 0; i < nRightFields; i++) { final RelDataTypeField field = rightFields.get(i); RexNode inputRef = rexBuilder.makeInputRef( field.getType(), i + nLeftFields); bottomProgramBuilder.addProject(inputRef, field.getName()); } RexProgram bottomProgram = bottomProgramBuilder.getProgram(); \/\/ input rowtype into the top program is the concatenation of the \/\/ project and the RHS of the semijoin RelDataType topInputRowType = Join.deriveJoinRowType( project.getRowType(), rightChild.getRowType(), JoinRelType.INNER, typeFactory, null, semiJoin.getSystemFieldList()); RexProgramBuilder topProgramBuilder = new RexProgramBuilder( topInputRowType, rexBuilder); topProgramBuilder.addIdentity(); topProgramBuilder.addCondition(semiJoin.getCondition()); RexProgram topProgram = topProgramBuilder.getProgram(); \/\/ merge the programs and expand out the local references to form \/\/ the new semijoin condition; it now references a concatenation of \/\/ the project's child and the RHS of the semijoin RexProgram mergedProgram = RexProgramBuilder.mergePrograms( topProgram, bottomProgram, rexBuilder); return mergedProgram.expandLocalRef( mergedProgram.getCondition()); }","old_code_raw":"  private RexNode adjustCondition(ProjectRel project, SemiJoinRel semiJoin) {\n    \/\/ create two RexPrograms -- the bottom one representing a\n    \/\/ concatenation of the project and the RHS of the semijoin and the\n    \/\/ top one representing the semijoin condition\n\n    RexBuilder rexBuilder = project.getCluster().getRexBuilder();\n    RelDataTypeFactory typeFactory = rexBuilder.getTypeFactory();\n    RelNode rightChild = semiJoin.getRight();\n\n    \/\/ for the bottom RexProgram, the input is a concatenation of the\n    \/\/ child of the project and the RHS of the semijoin\n    RelDataType bottomInputRowType =\n        JoinRelBase.deriveJoinRowType(\n            project.getChild().getRowType(),\n            rightChild.getRowType(),\n            JoinRelType.INNER,\n            typeFactory,\n            null,\n            semiJoin.getSystemFieldList());\n    RexProgramBuilder bottomProgramBuilder =\n        new RexProgramBuilder(bottomInputRowType, rexBuilder);\n\n    \/\/ add the project expressions, then add input references for the RHS\n    \/\/ of the semijoin\n    for (Pair<RexNode, String> pair : project.getNamedProjects()) {\n      bottomProgramBuilder.addProject(pair.left, pair.right);\n    }\n    int nLeftFields = project.getChild().getRowType().getFieldCount();\n    List<RelDataTypeField> rightFields =\n        rightChild.getRowType().getFieldList();\n    int nRightFields = rightFields.size();\n    for (int i = 0; i < nRightFields; i++) {\n      final RelDataTypeField field = rightFields.get(i);\n      RexNode inputRef =\n          rexBuilder.makeInputRef(\n              field.getType(), i + nLeftFields);\n      bottomProgramBuilder.addProject(inputRef, field.getName());\n    }\n    RexProgram bottomProgram = bottomProgramBuilder.getProgram();\n\n    \/\/ input rowtype into the top program is the concatenation of the\n    \/\/ project and the RHS of the semijoin\n    RelDataType topInputRowType =\n        JoinRelBase.deriveJoinRowType(\n            project.getRowType(),\n            rightChild.getRowType(),\n            JoinRelType.INNER,\n            typeFactory,\n            null,\n            semiJoin.getSystemFieldList());\n    RexProgramBuilder topProgramBuilder =\n        new RexProgramBuilder(\n            topInputRowType,\n            rexBuilder);\n    topProgramBuilder.addIdentity();\n    topProgramBuilder.addCondition(semiJoin.getCondition());\n    RexProgram topProgram = topProgramBuilder.getProgram();\n\n    \/\/ merge the programs and expand out the local references to form\n    \/\/ the new semijoin condition; it now references a concatenation of\n    \/\/ the project's child and the RHS of the semijoin\n    RexProgram mergedProgram =\n        RexProgramBuilder.mergePrograms(\n            topProgram,\n            bottomProgram,\n            rexBuilder);\n\n    return mergedProgram.expandLocalRef(\n        mergedProgram.getCondition());\n  }\n","new_comment_raw":"@param project LogicalProject on the LHS of the semijoin","old_comment_raw":"@param project ProjectRel on the LHS of the semijoin","label":1,"pre_label":0,"AST_level":9,"line_counts":71,"new_code_token_num":411},{"new_code_raw":"public String invokeAPI(String path, String method, Set<QueryParam> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); b.append(\"?\"); if (queryParams != null){ for (QueryParam queryParam : queryParams){ if (!queryParam.getName().isEmpty()) { b.append(escapeString(queryParam.getName())); b.append(\"=\"); b.append(escapeString(queryParam.getValue())); b.append(\"&\"); } } } String querystring = b.substring(0, b.length() - 1); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(\"GET\".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (\"POST\".equals(method)) { if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (\"PUT\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (\"DELETE\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, \"unknown method type \" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return \"\"; } } else { String message = \"error\"; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { \/\/ e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }","old_code_raw":"  public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    for(String key : queryParams.keySet()) {\n      String value = queryParams.get(key);\n      if (value != null){\n        if(b.toString().length() == 0)\n          b.append(\"?\");\n        else\n          b.append(\"&\");\n        b.append(escapeString(key)).append(\"=\").append(escapeString(value));\n      }\n    }\n    String querystring = b.toString();\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          \/\/ e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n","new_comment_raw":"@param authNames The authentications to apply","old_comment_raw":"@param authNames The authentications to apply","label":0,"pre_label":1,"AST_level":16,"line_counts":113,"new_code_token_num":736},{"new_code_raw":"public ProtonJMessage convert(Message message) throws JMSException, UnsupportedEncodingException { Header header = new Header(); Properties props = new Properties(); Map<Symbol, Object> daMap = null; Map<Symbol, Object> maMap = null; Map<String,Object> apMap = null; Map<Object, Object> footerMap = null; Section body = null; body = convertBody(message); header.setDurable(message.getJMSDeliveryMode() == DeliveryMode.PERSISTENT ? true : false); header.setPriority(new UnsignedByte((byte) message.getJMSPriority())); if (message.getJMSType() != null) { props.setSubject(message.getJMSType()); } if (message.getJMSMessageID() != null) { props.setMessageId(vendor.getOriginalMessageId(message)); } if (message.getJMSDestination() != null) { props.setTo(vendor.toAddress(message.getJMSDestination())); if (maMap == null) { maMap = new HashMap<Symbol, Object>(); } maMap.put(JMS_DEST_TYPE_MSG_ANNOTATION, destinationType(message.getJMSDestination())); \/\/ Deprecated: used by legacy QPid AMQP 1.0 JMS client maMap.put(LEGACY_JMS_DEST_TYPE_MSG_ANNOTATION, destinationAttributes(message.getJMSDestination())); } if (message.getJMSReplyTo() != null) { props.setReplyTo(vendor.toAddress(message.getJMSReplyTo())); if (maMap == null) { maMap = new HashMap<Symbol, Object>(); } maMap.put(JMS_REPLY_TO_TYPE_MSG_ANNOTATION, destinationType(message.getJMSReplyTo())); \/\/ Deprecated: used by legacy QPid AMQP 1.0 JMS client maMap.put(LEGACY_JMS_REPLY_TO_TYPE_MSG_ANNOTATION, destinationAttributes(message.getJMSReplyTo())); } if (message.getJMSCorrelationID() != null) { String correlationId = message.getJMSCorrelationID(); try { props.setCorrelationId(AMQPMessageIdHelper.INSTANCE.toIdObject(correlationId)); } catch (AmqpProtocolException e) { props.setCorrelationId(correlationId); } } if (message.getJMSExpiration() != 0) { long ttl = message.getJMSExpiration() - System.currentTimeMillis(); if (ttl < 0) { ttl = 1; } header.setTtl(new UnsignedInteger((int) ttl)); props.setAbsoluteExpiryTime(new Date(message.getJMSExpiration())); } if (message.getJMSTimestamp() != 0) { props.setCreationTime(new Date(message.getJMSTimestamp())); } @SuppressWarnings(\"unchecked\") final Enumeration<String> keys = message.getPropertyNames(); while (keys.hasMoreElements()) { String key = keys.nextElement(); if (key.equals(messageFormatKey) || key.equals(nativeKey) || key.equals(AMQP_ORIGINAL_ENCODING_KEY)) { \/\/ skip transformer appended properties } else if (key.equals(firstAcquirerKey)) { header.setFirstAcquirer(message.getBooleanProperty(key)); } else if (key.startsWith(\"JMSXDeliveryCount\")) { \/\/ The AMQP delivery-count field only includes prior failed delivery attempts, \/\/ whereas JMSXDeliveryCount includes the first\/current delivery attempt. int amqpDeliveryCount = message.getIntProperty(key) - 1; if (amqpDeliveryCount > 0) { header.setDeliveryCount(new UnsignedInteger(amqpDeliveryCount)); } } else if (key.startsWith(\"JMSXUserID\")) { String value = message.getStringProperty(key); props.setUserId(new Binary(value.getBytes(\"UTF-8\"))); } else if (key.startsWith(\"JMSXGroupID\")) { String value = message.getStringProperty(key); props.setGroupId(value); if (apMap == null) { apMap = new HashMap<String, Object>(); } apMap.put(key, value); } else if (key.startsWith(\"JMSXGroupSeq\")) { UnsignedInteger value = new UnsignedInteger(message.getIntProperty(key)); props.setGroupSequence(value); if (apMap == null) { apMap = new HashMap<String, Object>(); } apMap.put(key, value); } else if (key.startsWith(prefixDeliveryAnnotationsKey)) { if (daMap == null) { daMap = new HashMap<Symbol, Object>(); } String name = key.substring(prefixDeliveryAnnotationsKey.length()); daMap.put(Symbol.valueOf(name), message.getObjectProperty(key)); } else if (key.startsWith(prefixMessageAnnotationsKey)) { if (maMap == null) { maMap = new HashMap<Symbol, Object>(); } String name = key.substring(prefixMessageAnnotationsKey.length()); maMap.put(Symbol.valueOf(name), message.getObjectProperty(key)); } else if (key.equals(contentTypeKey)) { props.setContentType(Symbol.getSymbol(message.getStringProperty(key))); } else if (key.equals(contentEncodingKey)) { props.setContentEncoding(Symbol.getSymbol(message.getStringProperty(key))); } else if (key.equals(replyToGroupIDKey)) { props.setReplyToGroupId(message.getStringProperty(key)); } else if (key.startsWith(prefixFooterKey)) { if (footerMap == null) { footerMap = new HashMap<Object, Object>(); } String name = key.substring(prefixFooterKey.length()); footerMap.put(name, message.getObjectProperty(key)); } else { if (apMap == null) { apMap = new HashMap<String, Object>(); } apMap.put(key, message.getObjectProperty(key)); } } MessageAnnotations ma = null; if (maMap != null) { ma = new MessageAnnotations(maMap); } DeliveryAnnotations da = null; if (daMap != null) { da = new DeliveryAnnotations(daMap); } ApplicationProperties ap = null; if (apMap != null) { ap = new ApplicationProperties(apMap); } Footer footer = null; if (footerMap != null) { footer = new Footer(footerMap); } return (ProtonJMessage) org.apache.qpid.proton.message.Message.Factory.create(header, da, ma, props, ap, body, footer); }","old_code_raw":"    public ProtonJMessage convert(Message msg) throws JMSException, UnsupportedEncodingException {\n        Header header = new Header();\n        Properties props = new Properties();\n        HashMap<Symbol, Object> daMap = null;\n        HashMap<Symbol, Object> maMap = null;\n        HashMap apMap = null;\n        Section body = null;\n        HashMap footerMap = null;\n        if (msg instanceof BytesMessage) {\n            BytesMessage m = (BytesMessage) msg;\n            byte data[] = new byte[(int) m.getBodyLength()];\n            m.readBytes(data);\n            m.reset(); \/\/ Need to reset after readBytes or future readBytes\n                       \/\/ calls (ex: redeliveries) will fail and return -1\n            body = new Data(new Binary(data));\n        }\n        if (msg instanceof TextMessage) {\n            body = new AmqpValue(((TextMessage) msg).getText());\n        }\n        if (msg instanceof MapMessage) {\n            final HashMap<String, Object> map = new HashMap<String, Object>();\n            final MapMessage m = (MapMessage) msg;\n            final Enumeration<String> names = m.getMapNames();\n            while (names.hasMoreElements()) {\n                String key = names.nextElement();\n                map.put(key, m.getObject(key));\n            }\n            body = new AmqpValue(map);\n        }\n        if (msg instanceof StreamMessage) {\n            ArrayList<Object> list = new ArrayList<Object>();\n            final StreamMessage m = (StreamMessage) msg;\n            try {\n                while (true) {\n                    list.add(m.readObject());\n                }\n            } catch (MessageEOFException e) {\n            }\n            body = new AmqpSequence(list);\n        }\n        if (msg instanceof ObjectMessage) {\n            body = new AmqpValue(((ObjectMessage) msg).getObject());\n        }\n\n        header.setDurable(msg.getJMSDeliveryMode() == DeliveryMode.PERSISTENT ? true : false);\n        header.setPriority(new UnsignedByte((byte) msg.getJMSPriority()));\n        if (msg.getJMSType() != null) {\n            props.setSubject(msg.getJMSType());\n        }\n        if (msg.getJMSMessageID() != null) {\n            ActiveMQMessage amqMsg = (ActiveMQMessage) msg;\n\n            MessageId msgId = amqMsg.getMessageId();\n            if (msgId.getTextView() != null) {\n                try {\n                    props.setMessageId(AMQPMessageIdHelper.INSTANCE.toIdObject(msgId.getTextView()));\n                } catch (AmqpProtocolException e) {\n                    props.setMessageId(msgId.getTextView().toString());\n                }\n            } else {\n                props.setMessageId(msgId.toString());\n            }\n        }\n        if (msg.getJMSDestination() != null) {\n            props.setTo(vendor.toAddress(msg.getJMSDestination()));\n            if (maMap == null) {\n                maMap = new HashMap<Symbol, Object>();\n            }\n            maMap.put(JMS_DEST_TYPE_MSG_ANNOTATION, destinationType(msg.getJMSDestination()));\n\n            \/\/ Deprecated: used by legacy QPid AMQP 1.0 JMS client\n            maMap.put(LEGACY_JMS_DEST_TYPE_MSG_ANNOTATION, destinationAttributes(msg.getJMSDestination()));\n        }\n        if (msg.getJMSReplyTo() != null) {\n            props.setReplyTo(vendor.toAddress(msg.getJMSReplyTo()));\n            if (maMap == null) {\n                maMap = new HashMap<Symbol, Object>();\n            }\n            maMap.put(JMS_REPLY_TO_TYPE_MSG_ANNOTATION, destinationType(msg.getJMSReplyTo()));\n\n            \/\/ Deprecated: used by legacy QPid AMQP 1.0 JMS client\n            maMap.put(LEGACY_JMS_REPLY_TO_TYPE_MSG_ANNOTATION, destinationAttributes(msg.getJMSReplyTo()));\n        }\n        if (msg.getJMSCorrelationID() != null) {\n            String correlationId = msg.getJMSCorrelationID();\n            try {\n                props.setCorrelationId(AMQPMessageIdHelper.INSTANCE.toIdObject(correlationId));\n            } catch (AmqpProtocolException e) {\n                props.setCorrelationId(correlationId);\n            }\n        }\n        if (msg.getJMSExpiration() != 0) {\n            long ttl = msg.getJMSExpiration() - System.currentTimeMillis();\n            if (ttl < 0) {\n                ttl = 1;\n            }\n            header.setTtl(new UnsignedInteger((int) ttl));\n\n            props.setAbsoluteExpiryTime(new Date(msg.getJMSExpiration()));\n        }\n        if (msg.getJMSTimestamp() != 0) {\n            props.setCreationTime(new Date(msg.getJMSTimestamp()));\n        }\n\n        final Enumeration<String> keys = msg.getPropertyNames();\n        while (keys.hasMoreElements()) {\n            String key = keys.nextElement();\n            if (key.equals(messageFormatKey) || key.equals(nativeKey)) {\n                \/\/ skip..\n            } else if (key.equals(firstAcquirerKey)) {\n                header.setFirstAcquirer(msg.getBooleanProperty(key));\n            } else if (key.startsWith(\"JMSXDeliveryCount\")) {\n                \/\/ The AMQP delivery-count field only includes prior failed delivery attempts,\n                \/\/ whereas JMSXDeliveryCount includes the first\/current delivery attempt.\n                int amqpDeliveryCount = msg.getIntProperty(key) - 1;\n                if (amqpDeliveryCount > 0) {\n                    header.setDeliveryCount(new UnsignedInteger(amqpDeliveryCount));\n                }\n            } else if (key.startsWith(\"JMSXUserID\")) {\n                String value = msg.getStringProperty(key);\n                props.setUserId(new Binary(value.getBytes(\"UTF-8\")));\n            } else if (key.startsWith(\"JMSXGroupID\")) {\n                String value = msg.getStringProperty(key);\n                props.setGroupId(value);\n                if (apMap == null) {\n                    apMap = new HashMap();\n                }\n                apMap.put(key, value);\n            } else if (key.startsWith(\"JMSXGroupSeq\")) {\n                UnsignedInteger value = new UnsignedInteger(msg.getIntProperty(key));\n                props.setGroupSequence(value);\n                if (apMap == null) {\n                    apMap = new HashMap();\n                }\n                apMap.put(key, value);\n            } else if (key.startsWith(prefixDeliveryAnnotationsKey)) {\n                if (daMap == null) {\n                    daMap = new HashMap<Symbol, Object>();\n                }\n                String name = key.substring(prefixDeliveryAnnotationsKey.length());\n                daMap.put(Symbol.valueOf(name), msg.getObjectProperty(key));\n            } else if (key.startsWith(prefixMessageAnnotationsKey)) {\n                if (maMap == null) {\n                    maMap = new HashMap<Symbol, Object>();\n                }\n                String name = key.substring(prefixMessageAnnotationsKey.length());\n                maMap.put(Symbol.valueOf(name), msg.getObjectProperty(key));\n            } else if (key.equals(contentTypeKey)) {\n                props.setContentType(Symbol.getSymbol(msg.getStringProperty(key)));\n            } else if (key.equals(contentEncodingKey)) {\n                props.setContentEncoding(Symbol.getSymbol(msg.getStringProperty(key)));\n            } else if (key.equals(replyToGroupIDKey)) {\n                props.setReplyToGroupId(msg.getStringProperty(key));\n            } else if (key.startsWith(prefixFooterKey)) {\n                if (footerMap == null) {\n                    footerMap = new HashMap();\n                }\n                String name = key.substring(prefixFooterKey.length());\n                footerMap.put(name, msg.getObjectProperty(key));\n            } else {\n                if (apMap == null) {\n                    apMap = new HashMap();\n                }\n                apMap.put(key, msg.getObjectProperty(key));\n            }\n        }\n\n        MessageAnnotations ma = null;\n        if (maMap != null) {\n            ma = new MessageAnnotations(maMap);\n        }\n        DeliveryAnnotations da = null;\n        if (daMap != null) {\n            da = new DeliveryAnnotations(daMap);\n        }\n        ApplicationProperties ap = null;\n        if (apMap != null) {\n            ap = new ApplicationProperties(apMap);\n        }\n        Footer footer = null;\n        if (footerMap != null) {\n            footer = new Footer(footerMap);\n        }\n\n        return (ProtonJMessage) org.apache.qpid.proton.message.Message.Factory.create(header, da, ma, props, ap, body, footer);\n    }\n","new_comment_raw":"@param message The message to transform into an AMQP version for dispatch.","old_comment_raw":"@param msg","label":1,"pre_label":0,"AST_level":25,"line_counts":146,"new_code_token_num":1085},{"new_code_raw":"private boolean searchForButton(String regex, int matches) { sleeper.sleep(); inst.waitForIdleSync(); Pattern p = Pattern.compile(regex); Matcher matcher; ArrayList<Button> buttonList = viewFetcher.getCurrentViews(Button.class); if(matches == 0) matches = 1; for(Button button : buttonList){ matcher = p.matcher(button.getText().toString()); if(matcher.find()){ countMatches++; } if (countMatches == matches) { countMatches = 0; return true; } } if (scroller.scroll(Scroller.Direction.DOWN)) { return searchForButton(regex, matches); } else { if (countMatches > 0) Log.d(LOG_TAG, \" There are only \" + countMatches + \" matches of \" + regex); countMatches = 0; return false; } }","old_code_raw":"\tprivate boolean searchForButton(String search, int matches) {\n\t\tsleeper.sleep();\n\t\tinst.waitForIdleSync();\n\t\tPattern p = Pattern.compile(search);\n\t\tMatcher matcher;\n\t\tArrayList<Button> buttonList = viewFetcher.getCurrentViews(Button.class);\n\t\tif(matches == 0)\n\t\t\tmatches = 1;\n\t\tfor(Button button : buttonList){\n\t\t\tmatcher = p.matcher(button.getText().toString());\n\t\t\tif(matcher.find()){\t\n\t\t\t\tcountMatches++;\n\t\t\t}\n\t\t\tif (countMatches == matches) {\n\t\t\t\tcountMatches = 0;\n\t\t\t\treturn true;\n\t\t\t} \t\n\t\t}\n\n\t\tif (scroller.scroll(Scroller.Direction.DOWN))\n\t\t{\n\t\t\treturn searchForButton(search, matches);\n\t\t} else {\n\t\t\tif (countMatches > 0)\n\t\t\t\tLog.d(LOG_TAG, \" There are only \" + countMatches + \" matches of \" + search);\n\t\t\tcountMatches = 0;\n\t\t\treturn false;\n\t\t}\n\n\t}\n","new_comment_raw":"@param regex the text to search for. The parameter will be interpreted as a regular expression.","old_comment_raw":"@param search the string to be searched. The parameter will be interpreted as a regular expression.","label":1,"pre_label":0,"AST_level":11,"line_counts":31,"new_code_token_num":154},{"new_code_raw":"public void updateUser (String username, User user) throws TimeoutException, ExecutionException, InterruptedException, ApiException { Object postBody = user; \/\/ verify the required parameter 'username' is set if (username == null) { VolleyError error = new VolleyError(\"Missing the required parameter 'username' when calling updateUser\", new ApiException(400, \"Missing the required parameter 'username' when calling updateUser\")); } \/\/ verify the required parameter 'user' is set if (user == null) { VolleyError error = new VolleyError(\"Missing the required parameter 'user' when calling updateUser\", new ApiException(400, \"Missing the required parameter 'user' when calling updateUser\")); } \/\/ create path and map variables String path = \"\/user\/{username}\".replaceAll(\"\\\\{\" + \"username\" + \"\\\\}\", apiInvoker.escapeString(username.toString())); \/\/ query params List<Pair> queryParams = new ArrayList<Pair>(); \/\/ header params Map<String, String> headerParams = new HashMap<String, String>(); \/\/ form params Map<String, String> formParams = new HashMap<String, String>(); String[] contentTypes = { \"application\/json\" }; String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\"; if (contentType.startsWith(\"multipart\/form-data\")) { \/\/ file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); HttpEntity httpEntity = localVarBuilder.build(); postBody = httpEntity; } else { \/\/ normal form params } String[] authNames = new String[] { }; try { String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"PUT\", queryParams, postBody, headerParams, formParams, contentType, authNames); if (localVarResponse != null) { return ; } else { return ; } } catch (ApiException ex) { throw ex; } catch (InterruptedException ex) { throw ex; } catch (ExecutionException ex) { if (ex.getCause() instanceof VolleyError) { VolleyError volleyError = (VolleyError)ex.getCause(); if (volleyError.networkResponse != null) { throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage()); } } throw ex; } catch (TimeoutException ex) { throw ex; } }","old_code_raw":"  public void updateUser (String username, User body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {\n    Object postBody = body;\n    \/\/ verify the required parameter 'username' is set\n    if (username == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'username' when calling updateUser\",\n        new ApiException(400, \"Missing the required parameter 'username' when calling updateUser\"));\n    }\n    \/\/ verify the required parameter 'body' is set\n    if (body == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'body' when calling updateUser\",\n        new ApiException(400, \"Missing the required parameter 'body' when calling updateUser\"));\n    }\n\n    \/\/ create path and map variables\n    String path = \"\/user\/{username}\".replaceAll(\"\\\\{\" + \"username\" + \"\\\\}\", apiInvoker.escapeString(username.toString()));\n\n    \/\/ query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    \/\/ header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    \/\/ form params\n    Map<String, String> formParams = new HashMap<String, String>();\n    String[] contentTypes = {\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\";\n\n    if (contentType.startsWith(\"multipart\/form-data\")) {\n      \/\/ file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      HttpEntity httpEntity = localVarBuilder.build();\n      postBody = httpEntity;\n    } else {\n      \/\/ normal form params\n    }\n\n    String[] authNames = new String[] {  };\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"PUT\", queryParams, postBody, headerParams, formParams, contentType, authNames);\n      if (localVarResponse != null) {\n         return ;\n      } else {\n         return ;\n      }\n    } catch (ApiException ex) {\n       throw ex;\n    } catch (InterruptedException ex) {\n       throw ex;\n    } catch (ExecutionException ex) {\n      if (ex.getCause() instanceof VolleyError) {\n        VolleyError volleyError = (VolleyError)ex.getCause();\n        if (volleyError.networkResponse != null) {\n          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());\n        }\n      }\n      throw ex;\n    } catch (TimeoutException ex) {\n      throw ex;\n    }\n  }\n","new_comment_raw":"@param username name that need to be deleted","old_comment_raw":"@param username name that need to be deleted","label":0,"pre_label":1,"AST_level":11,"line_counts":62,"new_code_token_num":441},{"new_code_raw":"public ServletBuilder addServlet(Class<? extends Servlet> klass, String urlPattern) { final ServletHolder holder = new ServletHolder(checkNotNull(klass)); final ServletBuilder builder = new ServletBuilder(holder, handler); builder.addUrlPattern(checkNotNull(urlPattern)); return builder; }","old_code_raw":"    public ServletRegistration.Dynamic addServlet(String name, Class<? extends Servlet> klass) {\n        final ServletHolder holder = new ServletHolder(checkNotNull(klass));\n        holder.setName(name);\n        handler.getServletHandler().addServlet(holder);\n        return holder.getRegistration();\n    }\n","new_comment_raw":"@param klass the servlet class","old_comment_raw":"@param name the servlet's name","label":1,"pre_label":0,"AST_level":7,"line_counts":9,"new_code_token_num":50},{"new_code_raw":"public Index parseAndUpdateIndex(Set<String> mappingFileNames, Index annotationIndex) { ClassLoaderService classLoaderService = meta.getServiceRegistry().getService( ClassLoaderService.class ); Set<InputStream> mappingStreams = new HashSet<InputStream>(); for ( String fileName : mappingFileNames ) { EntityMappings entityMappings; try { entityMappings = XmlHelper.unmarshallXml( fileName, ORM2_MAPPING_XSD, EntityMappings.class, classLoaderService ).getRoot(); } catch ( JAXBException orm2Exception ) { \/\/ if we cannot parse against orm_2_0.xsd we try orm_1_0.xsd for backwards compatibility try { entityMappings = XmlHelper.unmarshallXml( fileName, ORM1_MAPPING_XSD, EntityMappings.class, classLoaderService ).getRoot(); } catch ( JAXBException orm1Exception ) { throw new AnnotationException( \"Unable to parse xml configuration.\", orm1Exception ); } } entityMappings.toString(); } return null; }","old_code_raw":"\tpublic Index parseAndUpdateIndex(List<JaxbRoot<XMLEntityMappings>> mappings, Index annotationIndex) {\n\t\tList<XMLEntityMappings> list = new ArrayList<XMLEntityMappings>( mappings.size() );\n\t\tfor ( JaxbRoot<XMLEntityMappings> jaxbRoot : mappings ) {\n\t\t\tlist.add( jaxbRoot.getRoot() );\n\t\t}\n\t\treturn new EntityMappingsMocker(\n\t\t\t\tlist, annotationIndex, meta.getServiceRegistry()\n\t\t).mockNewIndex();\n\t}\n","new_comment_raw":"@param annotationIndex the annotation index based on scanned annotations","old_comment_raw":"@param annotationIndex the annotation index based on scanned annotations","label":0,"pre_label":1,"AST_level":12,"line_counts":29,"new_code_token_num":139},{"new_code_raw":"public void createUsersWithArrayInput (List<User> user) throws TimeoutException, ExecutionException, InterruptedException, ApiException { Object postBody = user; \/\/ verify the required parameter 'user' is set if (user == null) { VolleyError error = new VolleyError(\"Missing the required parameter 'user' when calling createUsersWithArrayInput\", new ApiException(400, \"Missing the required parameter 'user' when calling createUsersWithArrayInput\")); } \/\/ create path and map variables String path = \"\/user\/createWithArray\"; \/\/ query params List<Pair> queryParams = new ArrayList<Pair>(); \/\/ header params Map<String, String> headerParams = new HashMap<String, String>(); \/\/ form params Map<String, String> formParams = new HashMap<String, String>(); String[] contentTypes = { }; String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\"; if (contentType.startsWith(\"multipart\/form-data\")) { \/\/ file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); HttpEntity httpEntity = localVarBuilder.build(); postBody = httpEntity; } else { \/\/ normal form params } String[] authNames = new String[] { }; try { String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames); if (localVarResponse != null) { return ; } else { return ; } } catch (ApiException ex) { throw ex; } catch (InterruptedException ex) { throw ex; } catch (ExecutionException ex) { if (ex.getCause() instanceof VolleyError) { VolleyError volleyError = (VolleyError)ex.getCause(); if (volleyError.networkResponse != null) { throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage()); } } throw ex; } catch (TimeoutException ex) { throw ex; } }","old_code_raw":"  public void createUsersWithArrayInput (List<User> body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {\n    Object postBody = body;\n    \/\/ verify the required parameter 'body' is set\n    if (body == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'body' when calling createUsersWithArrayInput\",\n        new ApiException(400, \"Missing the required parameter 'body' when calling createUsersWithArrayInput\"));\n    }\n\n    \/\/ create path and map variables\n    String path = \"\/user\/createWithArray\";\n\n    \/\/ query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    \/\/ header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    \/\/ form params\n    Map<String, String> formParams = new HashMap<String, String>();\n    String[] contentTypes = {\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\";\n\n    if (contentType.startsWith(\"multipart\/form-data\")) {\n      \/\/ file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      HttpEntity httpEntity = localVarBuilder.build();\n      postBody = httpEntity;\n    } else {\n      \/\/ normal form params\n    }\n\n    String[] authNames = new String[] {  };\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames);\n      if (localVarResponse != null) {\n         return ;\n      } else {\n         return ;\n      }\n    } catch (ApiException ex) {\n       throw ex;\n    } catch (InterruptedException ex) {\n       throw ex;\n    } catch (ExecutionException ex) {\n      if (ex.getCause() instanceof VolleyError) {\n        VolleyError volleyError = (VolleyError)ex.getCause();\n        if (volleyError.networkResponse != null) {\n          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());\n        }\n      }\n      throw ex;\n    } catch (TimeoutException ex) {\n      throw ex;\n    }\n  }\n","new_comment_raw":"@param user List of user object","old_comment_raw":"@param body List of user object","label":1,"pre_label":0,"AST_level":11,"line_counts":56,"new_code_token_num":349},{"new_code_raw":"private int scanURL(String url, User user, int maxChildren) throws ApiException { log.debug(\"API Spider scanning url: \" + url); URI startURI; try { \/\/ Try to build uri startURI = new URI(url, true); } catch (URIException e) { throw new ApiException(ApiException.Type.BAD_FORMAT); } SiteNode startNode = Model.getSingleton().getSession().getSiteTree().findNode(startURI); String scheme = startURI.getScheme(); if (scheme == null || (!scheme.equalsIgnoreCase(\"http\") && !scheme.equalsIgnoreCase(\"https\"))) { throw new ApiException(ApiException.Type.BAD_FORMAT); } Target target = new Target(startNode); target.setRecurse(true); Object[] objs = null; if (maxChildren > 0) { \/\/ Add the filters to filter on maximum number of children MaxChildrenFetchFilter maxChildrenFetchFilter = new MaxChildrenFetchFilter(); maxChildrenFetchFilter.setMaxChildren(maxChildren); maxChildrenFetchFilter.setModel(extension.getModel()); MaxChildrenParseFilter maxChildrenParseFilter = new MaxChildrenParseFilter(); maxChildrenParseFilter.setMaxChildren(maxChildren); maxChildrenParseFilter.setModel(extension.getModel()); objs = new Object[] { maxChildrenFetchFilter, maxChildrenParseFilter }; } return extension.startScan(target.getDisplayName(), target, user, objs); }","old_code_raw":"\tprivate int scanURL(String url, User user) throws ApiException {\n\t\tlog.debug(\"API Spider scanning url: \" + url);\n\n\t\tURI startURI;\n\t\ttry {\n\t\t\t\/\/ Try to build uri\n\t\t\tstartURI = new URI(url, true);\n\t\t} catch (URIException e) {\n\t\t\tthrow new ApiException(ApiException.Type.BAD_FORMAT);\n\t\t}\n\n\t\tSiteNode startNode = Model.getSingleton().getSession().getSiteTree().findNode(startURI);\n\t\tString scheme = startURI.getScheme();\n\t\tif (scheme == null || (!scheme.equalsIgnoreCase(\"http\") && !scheme.equalsIgnoreCase(\"https\"))) {\n\t\t\tthrow new ApiException(ApiException.Type.BAD_FORMAT);\n\t\t}\n\t\tTarget target = new Target(startNode);\n\t\ttarget.setRecurse(true);\n\t\treturn extension.startScan(target.getDisplayName(), target, user, null);\n\t}\n","new_comment_raw":"@param url the url to start the spider scan","old_comment_raw":"@param url the url to start the spider scan","label":0,"pre_label":1,"AST_level":9,"line_counts":38,"new_code_token_num":240},{"new_code_raw":"static String formatSQLParsingError(String sql, DrillSqlParseException ex) { final String sqlErrorMessageHeader = \"SQL Query: \"; final SqlParserPos pos = ex.getPos(); if (pos != null) { int issueLineNumber = pos.getLineNum() - 1; \/\/ recalculates to base 0 int issueColumnNumber = pos.getColumnNum() - 1; \/\/ recalculates to base 0 int messageHeaderLength = sqlErrorMessageHeader.length(); \/\/ If the issue happens on the first line, header width should be calculated alongside with the sql query int shiftLength = (issueLineNumber == 0) ? issueColumnNumber + messageHeaderLength : issueColumnNumber; StringBuilder sb = new StringBuilder(); String[] lines = sql.split(DrillParserUtil.EOL); for (int i = 0; i < lines.length; i++) { sb.append(lines[i]); if (i == issueLineNumber) { sb .append(DrillParserUtil.EOL) .append(StringUtils.repeat(' ', shiftLength)) .append(\"^\"); } if (i < lines.length - 1) { sb.append(DrillParserUtil.EOL); } } sql = sb.toString(); } return sqlErrorMessageHeader + sql; }","old_code_raw":"  static String formatSQLParsingError(String sql, SqlParserPos pos) {\n    if (pos == null) {\n      return sql;\n    }\n    StringBuilder sb = new StringBuilder();\n    String[] lines = sql.split(\"\\n\");\n    for (int i = 0; i < lines.length; i++) {\n      String line = lines[i];\n      sb.append(line).append(\"\\n\");\n      if (i == (pos.getLineNum() - 1)) {\n        for (int j = 0; j < pos.getColumnNum() - 1; j++) {\n          sb.append(\" \");\n        }\n        sb.append(\"^\\n\");\n      }\n    }\n    return sb.toString();\n  }\n","new_comment_raw":"@param ex exception object","old_comment_raw":"@param pos the position of the error","label":1,"pre_label":0,"AST_level":13,"line_counts":33,"new_code_token_num":210},{"new_code_raw":"protected InstrumentedClientConnManager createConnectionManager(SchemeRegistry registry, DnsResolver resolver) { final long ttl = configuration.getTimeToLive().toMilliseconds(); final InstrumentedClientConnManager manager = new InstrumentedClientConnManager(Metrics.defaultRegistry(), registry, ttl, TimeUnit.MILLISECONDS, resolver); manager.setDefaultMaxPerRoute(configuration.getMaxConnectionsPerRoute()); manager.setMaxTotal(configuration.getMaxConnections()); return manager; }","old_code_raw":"    protected InstrumentedClientConnManager createConnectionManager(SchemeRegistry registry) {\n        final long ttl = configuration.getTimeToLive().toMilliseconds();\n        final InstrumentedClientConnManager manager =\n                new InstrumentedClientConnManager(registry, ttl, TimeUnit.MILLISECONDS);\n        manager.setDefaultMaxPerRoute(configuration.getMaxConnectionsPerRoute());\n        manager.setMaxTotal(configuration.getMaxConnections());\n        return manager;\n    }\n","new_comment_raw":"@param registry the SchemeRegistry","old_comment_raw":"@param registry the SchemeRegistry","label":0,"pre_label":1,"AST_level":6,"line_counts":9,"new_code_token_num":65},{"new_code_raw":"public IntervalConverter removeIntervalConverter(IntervalConverter converter) throws SecurityException { checkAlterIntervalConverters(); if (converter == null) { return null; } IntervalConverter[] removed = new IntervalConverter[1]; iIntervalConverters = iIntervalConverters.remove(converter, removed); return removed[0]; }","old_code_raw":"    public IntervalConverter removeIntervalConverter(int index) throws SecurityException {\n        checkAlterIntervalConverters();\n        IntervalConverter[] removed = new IntervalConverter[1];\n        iIntervalConverters = iIntervalConverters.remove(index, removed);\n        return removed[0];\n    }\n","new_comment_raw":"@param converter the converter to remove, null ignored","old_comment_raw":"@param index the index to remove","label":1,"pre_label":0,"AST_level":6,"line_counts":12,"new_code_token_num":50},{"new_code_raw":"private static int findStartIndex(Entry entry, List<CoreLabel> document, int searchStart, Set<String> myLabels, boolean ignoreCase) { List<Pattern> regex = entry.regex; for (int start = searchStart; start <= document.size() - regex.size(); start++) { boolean failed = false; for (int i = 0; i < regex.size(); i++) { Pattern pattern = regex.get(i); String exact = entry.exact.get(i); CoreLabel token = document.get(start + i); String NERType = token.get(CoreAnnotations.NamedEntityTagAnnotation.class); String currentType = token.get(CoreAnnotations.AnswerAnnotation.class); if ( currentType != null || (exact != null && ! (ignoreCase ? exact.equalsIgnoreCase(token.word()) : exact.equals(token.word()))) || ! (entry.overwritableTypes.contains(NERType) || myLabels.contains(NERType) || NERType.equals(\"O\")) || ! pattern.matcher(token.word()).matches() \/\/ last, as this is likely the expensive operation ) { failed = true; break; } } if(! failed) { \/\/System.err.print(\"MATCHED REGEX:\"); \/\/for(int i = start; i < start + regex.size(); i ++) System.err.print(\" \" + document.get(i).word()); \/\/System.err.println(); return start; } } return -1; }","old_code_raw":"  private static int findStartIndex(Entry entry, List<CoreLabel> document, int searchStart, Set<String> myLabels) {\n    List<Pattern> regex = entry.regex;\n    for (int start = searchStart; start <= document.size() - regex.size(); start++) {\n      boolean failed = false;\n      for (int i = 0; i < regex.size(); i++) {\n        Pattern pattern = regex.get(i);\n        CoreLabel token = document.get(start + i);\n        String NERType = token.get(CoreAnnotations.NamedEntityTagAnnotation.class);\n        String currentType = token.get(CoreAnnotations.AnswerAnnotation.class);\n\n        if (! pattern.matcher(token.word()).matches() ||\n            currentType != null ||\n            ! (entry.overwritableTypes.contains(NERType) ||\n               myLabels.contains(NERType) ||\n               NERType.equals(\"O\"))) {\n          failed = true;\n          break;\n        }\n      }\n      if(! failed) {\n        \/\/System.err.print(\"MATCHED REGEX:\");\n        \/\/for(int i = start; i < start + regex.size(); i ++) System.err.print(\" \" + document.get(i).word());\n        \/\/System.err.println();\n        return start;\n      }\n    }\n    return -1;\n  }\n","new_comment_raw":"@param entry","old_comment_raw":"@param entry","label":0,"pre_label":1,"AST_level":14,"line_counts":33,"new_code_token_num":290},{"new_code_raw":"public Index parseAndUpdateIndex(Set<String> mappingFileNames, Index annotationIndex) { ClassLoaderService classLoaderService = meta.getServiceRegistry().getService( ClassLoaderService.class ); Set<InputStream> mappingStreams = new HashSet<InputStream>(); for ( String fileName : mappingFileNames ) { EntityMappings entityMappings; try { entityMappings = XmlHelper.unmarshallXml( fileName, ORM2_MAPPING_XSD, EntityMappings.class, classLoaderService ).getRoot(); } catch ( JAXBException orm2Exception ) { \/\/ if we cannot parse against orm_2_0.xsd we try orm_1_0.xsd for backwards compatibility try { entityMappings = XmlHelper.unmarshallXml( fileName, ORM1_MAPPING_XSD, EntityMappings.class, classLoaderService ).getRoot(); } catch ( JAXBException orm1Exception ) { throw new AnnotationException( \"Unable to parse xml configuration.\", orm1Exception ); } } entityMappings.toString(); } return null; }","old_code_raw":"\tpublic Index parseAndUpdateIndex(List<JaxbRoot<XMLEntityMappings>> mappings, Index annotationIndex) {\n\t\tList<XMLEntityMappings> list = new ArrayList<XMLEntityMappings>( mappings.size() );\n\t\tfor ( JaxbRoot<XMLEntityMappings> jaxbRoot : mappings ) {\n\t\t\tlist.add( jaxbRoot.getRoot() );\n\t\t}\n\t\treturn new EntityMappingsMocker(\n\t\t\t\tlist, annotationIndex, meta.getServiceRegistry()\n\t\t).mockNewIndex();\n\t}\n","new_comment_raw":"@param mappingFileNames the file names of the xml files to parse","old_comment_raw":"@param mappings list of XMLEntityMappings created from the specified orm xml files","label":1,"pre_label":0,"AST_level":12,"line_counts":29,"new_code_token_num":139},{"new_code_raw":"private int getNodeInScopeCount(StructuralNode node, boolean incRelatedSiblings) { if (node == null) { return 0; } int nodeCount = 1; if (parentScanner.scanChildren()) { Set<StructuralNode> parentNodes = new HashSet<>(); parentNodes.add(node); if (incRelatedSiblings) { \/\/ Also match siblings with the same hierarchic name \/\/ If we dont do this http:\/\/localhost\/start might match the GET variant in the Sites tree and miss the hierarchic node \/\/ note that this is only done for the top level. try { Iterator<StructuralNode> iter = node.getParent().getChildIterator(); while (iter.hasNext()) { StructuralNode sibling = iter.next(); if (! node.isSameAs(sibling) && ! node.getName().equals(sibling.getName())) { parentNodes.add(sibling); nodeCount++; } } } catch (DatabaseException e) { \/\/ Ignore - if we cant connect to the db there will be plenty of other errors logged ;) } } for (StructuralNode pNode : parentNodes) { Iterator<StructuralNode> iter = pNode.getChildIterator(); while (iter.hasNext()) { nodeCount += getNodeInScopeCount(iter.next(), false); } } } return nodeCount; }","old_code_raw":"    private int getNodeInScopeCount(SiteNode node, boolean incRelatedSiblings) {\n        if (node == null) {\n            return 0;\n        }\n        \n        int nodeCount = 1;\n        if (parentScanner.scanChildren()) {\n            \n            Set<SiteNode> parentNodes = new HashSet<>();\n            parentNodes.add(node);\n                        \n            if (incRelatedSiblings) {\n                \/\/ Also match siblings with the same hierarchic name\n                \/\/ If we dont do this http:\/\/localhost\/start might match the GET variant in the Sites tree and miss the hierarchic node\n                \/\/ note that this is only done for the top level.\n                SiteNode sibling = node;\n                while ((sibling = (SiteNode) sibling.getPreviousSibling()) != null) {\n                    if (node.getHierarchicNodeName().equals(sibling.getHierarchicNodeName())) {\n                        \/\/ count also sibling\n                        parentNodes.add(sibling);\n                        nodeCount++;\n                    }\n                }\n\n                sibling = node;\n                while ((sibling = (SiteNode) sibling.getNextSibling()) != null) {\n                    if (node.getHierarchicNodeName().equals(sibling.getHierarchicNodeName())) {\n                        \/\/ count also sibling\n                        parentNodes.add(sibling);\n                        nodeCount++;\n                    }\n                }\n            }\n            \n            for (SiteNode pNode : parentNodes) {\n                \n                for (int i = 0; i < pNode.getChildCount(); i++) {\n                    nodeCount += getNodeInScopeCount((SiteNode)pNode.getChildAt(i), false);\n                }\n            }\n        }\n        \n        return nodeCount;\n    }\n","new_comment_raw":"@param node the starting node","old_comment_raw":"@param node the starting node","label":0,"pre_label":1,"AST_level":14,"line_counts":40,"new_code_token_num":239},{"new_code_raw":"protected String setEscapedParameter(HttpMessage message, String param, String value) { return variant.setEscapedParameter(message, originalPair, param, value); }","old_code_raw":"    protected String setEscapedParameter(HttpMessage msg, String param, String value) {\n        return variant.setEscapedParameter(msg, originalPair, param, value);\n    }\n","new_comment_raw":"@param message the message that will be changed","old_comment_raw":"@param msg","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":28},{"new_code_raw":"public static RuleSet getDrillUserConfigurableLogicalRules(OptimizerRulesContext optimizerRulesContext) { PlannerSettings ps = optimizerRulesContext.getPlannerSettings(); \/\/ This list is used to store rules that can be turned on an off \/\/ by user facing planning options Builder userConfigurableRules = ImmutableSet.<RelOptRule>builder(); if (ps.isConstantFoldingEnabled()) { \/\/ TODO - DRILL-2218 userConfigurableRules.add(ReduceExpressionsRule.PROJECT_INSTANCE); userConfigurableRules.add(DrillReduceExpressionsRule.FILTER_INSTANCE_DRILL); userConfigurableRules.add(DrillReduceExpressionsRule.CALC_INSTANCE_DRILL); } return new DrillRuleSet(userConfigurableRules.build()); }","old_code_raw":"  public static RuleSet getDrillUserConfigurableLogicalRules(QueryContext queryContext) {\n    PlannerSettings ps = queryContext.getPlannerSettings();\n\n    \/\/ This list is used to store rules that can be turned on an off\n    \/\/ by user facing planning options\n    Builder userConfigurableRules = ImmutableSet.<RelOptRule>builder();\n\n    if (ps.isConstantFoldingEnabled()) {\n      \/\/ TODO - DRILL-2218\n      userConfigurableRules.add(ReduceExpressionsRule.PROJECT_INSTANCE);\n\n      userConfigurableRules.add(DrillReduceExpressionsRule.FILTER_INSTANCE_DRILL);\n      userConfigurableRules.add(DrillReduceExpressionsRule.CALC_INSTANCE_DRILL);\n    }\n\n    return new DrillRuleSet(userConfigurableRules.build());\n  }\n","new_comment_raw":"@param optimizerRulesContext - used to get the list of planner settings, other rules may also in the future need to get other query state from this, such as the available list of UDFs (as is used by the DrillMergeProjectRule created in getDrillBasicRules())","old_comment_raw":"@param queryContext - used to get the list of planner settings, other rules may also in the future need to get other query state from this, such as the available list of UDFs (as is used by the DrillMergeProjectRule created in getDrillBasicRules())","label":1,"pre_label":0,"AST_level":7,"line_counts":18,"new_code_token_num":95},{"new_code_raw":"public ApiResponse<Void> testEndpointParametersWithHttpInfo(BigDecimal number, Double _double, String string, byte[] _byte, Integer integer, Integer int32, Long int64, Float _float, byte[] binary, Date date, Date dateTime, String password) throws ApiException { Call call = testEndpointParametersCall(number, _double, string, _byte, integer, int32, int64, _float, binary, date, dateTime, password, null, null); return apiClient.execute(call); }","old_code_raw":"  public ApiResponse<Void> testEndpointParametersWithHttpInfo(String number, Double _double, String string, byte[] _byte, Integer integer, Integer int32, Long int64, Float _float, byte[] binary, Date date, Date dateTime, String password) throws ApiException {\n    Call call = testEndpointParametersCall(number, _double, string, _byte, integer, int32, int64, _float, binary, date, dateTime, password, null, null);\n    return apiClient.execute(call);\n  }\n","new_comment_raw":"@param _float None (optional)","old_comment_raw":"@param _float None (optional)","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":89},{"new_code_raw":"public int performExecuteUpdate(QueryParameters queryParameters, SharedSessionContractImplementor session) throws HibernateException { if ( traceEnabled ) { LOG.tracev( \"Execute update: {0}\", getSourceQuery() ); queryParameters.traceParameters( session.getFactory() ); } if ( translators.length != 1 ) { LOG.splitQueries( getSourceQuery(), translators.length ); } int result = 0; for ( QueryTranslator translator : translators ) { result += translator.executeUpdate( queryParameters, session ); } return result; }","old_code_raw":"\tpublic int performExecuteUpdate(QueryParameters queryParameters, SessionImplementor session)\n\t\t\tthrows HibernateException {\n\t\tif ( traceEnabled ) {\n\t\t\tLOG.tracev( \"Execute update: {0}\", getSourceQuery() );\n\t\t\tqueryParameters.traceParameters( session.getFactory() );\n\t\t}\n\t\tif ( translators.length != 1 ) {\n\t\t\tLOG.splitQueries( getSourceQuery(), translators.length );\n\t\t}\n\t\tint result = 0;\n\t\tfor ( QueryTranslator translator : translators ) {\n\t\t\tresult += translator.executeUpdate( queryParameters, session );\n\t\t}\n\t\treturn result;\n\t}\n","new_comment_raw":"@param session The session","old_comment_raw":"@param session The session","label":0,"pre_label":1,"AST_level":8,"line_counts":16,"new_code_token_num":92},{"new_code_raw":"public boolean waitForText(String text, int minimumNumberOfMatches, long timeout) { return robotiumUtils.waitForText(text, minimumNumberOfMatches, timeout); }","old_code_raw":"\tpublic boolean waitForText(String text, int expectedMinimumNumberOfMatches, long timeout) {\n       return robotiumUtils.waitForText(text, expectedMinimumNumberOfMatches, timeout);\n    }\n","new_comment_raw":"@param minimumNumberOfMatches the minimum number of text matches that are expected to be shown.  0 means any number of matches","old_comment_raw":"@param expectedMinimumNumberOfMatches the minimum number of matches of text that must be shown. 0 means any number of matches","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":26},{"new_code_raw":"public ArrayList filterContent(String key) { return this.of.filter(key); }","old_code_raw":"\t\tpublic ArrayList filterContent(String prefix) {\n\t\t\t\/\/ prefix MUST be in lowercase\n\t\t\tif (\"\".equals(prefix)) {\n\t\t\t\tthis.filteredItemsBuffer = new ArrayList(getItemIds());\n\t\t\t\treturn this.filteredItemsBuffer;\n\n\t\t\t} else if (items != null) { \n\t\t\t\t\/\/ all items will be iterated and tested.\n\t\t\t\t\/\/ SLOW when there are lot of items.\n\t\t\t\t\/\/ TODO Should we add \n\t\t\t\tthis.filteredItemsBuffer = new ArrayList();\n\t\t\t\tfor (Iterator iter = items.getItemIds().iterator(); iter\n\t\t\t\t\t\t.hasNext();) {\n\t\t\t\t\tObject id = iter.next();\n\n\t\t\t\t\tItem item = getItem(id);\n\t\t\t\t\tString test = \"\";\n\t\t\t\t\tif (getItemCaptionMode() == ITEM_CAPTION_MODE_PROPERTY)\n\t\t\t\t\t\ttest = item.getItemProperty(getItemCaptionPropertyId())\n\t\t\t\t\t\t\t\t.getValue().toString().trim();\n\t\t\t\t\telse\n\t\t\t\t\t\ttest = String.valueOf(id);\n\n\t\t\t\t\tif (test.toLowerCase().startsWith(prefix)) {\n\t\t\t\t\t\tthis.filteredItemsBuffer.add(id);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this.filteredItemsBuffer;\n\t\t}\n","new_comment_raw":"@param key the key given to OptionFilter","old_comment_raw":"@param prefix the Filter prefix","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":17},{"new_code_raw":"public static DownloadQueue newDownloadQueue() { return newDownloadQueue(2); }","old_code_raw":"\tpublic static DownloadQueue newDownloadQueue(Context context) {\n\t\treturn newDownloadQueue(context, 2);\n\t}\n","new_comment_raw":"@param context ApplicationContext","old_comment_raw":"@param context ApplicationContext","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":14},{"new_code_raw":"private SQLResponse execute(String correctedSql, SQLRequest sqlRequest) throws Exception { Connection conn = null; Statement stat = null; ResultSet resultSet = null; List<List<String>> results = Lists.newArrayList(); List<SelectedColumnMeta> columnMetas = Lists.newArrayList(); try { conn = cacheService.getOLAPDataSource(sqlRequest.getProject()).getConnection(); if (sqlRequest instanceof PrepareSqlRequest) { PreparedStatement preparedState = conn.prepareStatement(correctedSql); processStatementAttr(preparedState, sqlRequest); for (int i = 0; i < ((PrepareSqlRequest) sqlRequest).getParams().length; i++) { setParam(preparedState, i + 1, ((PrepareSqlRequest) sqlRequest).getParams()[i]); } resultSet = preparedState.executeQuery(); } else { stat = conn.createStatement(); processStatementAttr(stat, sqlRequest); resultSet = stat.executeQuery(correctedSql); } ResultSetMetaData metaData = resultSet.getMetaData(); int columnCount = metaData.getColumnCount(); \/\/ Fill in selected column meta for (int i = 1; i <= columnCount; ++i) { columnMetas.add(new SelectedColumnMeta(metaData.isAutoIncrement(i), metaData.isCaseSensitive(i), metaData.isSearchable(i), metaData.isCurrency(i), metaData.isNullable(i), metaData.isSigned(i), metaData.getColumnDisplaySize(i), metaData.getColumnLabel(i), metaData.getColumnName(i), metaData.getSchemaName(i), metaData.getCatalogName(i), metaData.getTableName(i), metaData.getPrecision(i), metaData.getScale(i), metaData.getColumnType(i), metaData.getColumnTypeName(i), metaData.isReadOnly(i), metaData.isWritable(i), metaData.isDefinitelyWritable(i))); } \/\/ fill in results while (resultSet.next()) { List<String> oneRow = Lists.newArrayListWithCapacity(columnCount); for (int i = 0; i < columnCount; i++) { oneRow.add((resultSet.getString(i + 1))); } results.add(oneRow); } } finally { close(resultSet, stat, conn); } boolean isPartialResult = false; String cube = \"\"; StringBuilder sb = new StringBuilder(\"Scan count for each storageContext: \"); long totalScanCount = 0; if (OLAPContext.getThreadLocalContexts() != null) { \/\/ contexts can be null in case of 'explain plan for' for (OLAPContext ctx : OLAPContext.getThreadLocalContexts()) { if (ctx.realization != null) { isPartialResult |= ctx.storageContext.isPartialResultReturned(); cube = ctx.realization.getName(); totalScanCount += ctx.storageContext.getTotalScanCount(); sb.append(ctx.storageContext.getTotalScanCount() + \",\"); } } } logger.info(sb.toString()); SQLResponse response = new SQLResponse(columnMetas, results, cube, 0, false, null, isPartialResult); response.setTotalScanCount(totalScanCount); return response; }","old_code_raw":"    private SQLResponse execute(String sql, SQLRequest sqlRequest) throws Exception {\n        Connection conn = null;\n        Statement stat = null;\n        ResultSet resultSet = null;\n\n        List<List<String>> results = Lists.newArrayList();\n        List<SelectedColumnMeta> columnMetas = Lists.newArrayList();\n\n        try {\n            conn = cacheService.getOLAPDataSource(sqlRequest.getProject()).getConnection();\n\n            if (sqlRequest instanceof PrepareSqlRequest) {\n                PreparedStatement preparedState = conn.prepareStatement(sql);\n                processStatementAttr(preparedState, sqlRequest);\n\n                for (int i = 0; i < ((PrepareSqlRequest) sqlRequest).getParams().length; i++) {\n                    setParam(preparedState, i + 1, ((PrepareSqlRequest) sqlRequest).getParams()[i]);\n                }\n\n                resultSet = preparedState.executeQuery();\n            } else {\n                stat = conn.createStatement();\n                processStatementAttr(stat, sqlRequest);\n                resultSet = stat.executeQuery(sql);\n            }\n\n            ResultSetMetaData metaData = resultSet.getMetaData();\n            int columnCount = metaData.getColumnCount();\n\n            \/\/ Fill in selected column meta\n            for (int i = 1; i <= columnCount; ++i) {\n                columnMetas.add(new SelectedColumnMeta(metaData.isAutoIncrement(i), metaData.isCaseSensitive(i), metaData.isSearchable(i), metaData.isCurrency(i), metaData.isNullable(i), metaData.isSigned(i), metaData.getColumnDisplaySize(i), metaData.getColumnLabel(i), metaData.getColumnName(i), metaData.getSchemaName(i), metaData.getCatalogName(i), metaData.getTableName(i), metaData.getPrecision(i), metaData.getScale(i), metaData.getColumnType(i), metaData.getColumnTypeName(i), metaData.isReadOnly(i), metaData.isWritable(i), metaData.isDefinitelyWritable(i)));\n            }\n\n            \/\/ fill in results\n            while (resultSet.next()) {\n                List<String> oneRow = Lists.newArrayListWithCapacity(columnCount);\n                for (int i = 0; i < columnCount; i++) {\n                    oneRow.add((resultSet.getString(i + 1)));\n                }\n\n                results.add(oneRow);\n            }\n        } finally {\n            close(resultSet, stat, conn);\n        }\n\n        boolean isPartialResult = false;\n        String cube = \"\";\n        StringBuilder sb = new StringBuilder(\"Scan count for each storageContext: \");\n        long totalScanCount = 0;\n        if (OLAPContext.getThreadLocalContexts() != null) { \/\/ contexts can be null in case of 'explain plan for'\n            for (OLAPContext ctx : OLAPContext.getThreadLocalContexts()) {\n                if (ctx.realization != null) {\n                    isPartialResult |= ctx.storageContext.isPartialResultReturned();\n                    cube = ctx.realization.getName();\n                    totalScanCount += ctx.storageContext.getTotalScanCount();\n                    sb.append(ctx.storageContext.getTotalScanCount() + \",\");\n                }\n            }\n        }\n        logger.info(sb.toString());\n\n        SQLResponse response = new SQLResponse(columnMetas, results, cube, 0, false, null, isPartialResult);\n        response.setTotalScanCount(totalScanCount);\n\n        return response;\n    }\n","new_comment_raw":"@param sqlRequest","old_comment_raw":"@param sqlRequest","label":0,"pre_label":1,"AST_level":12,"line_counts":69,"new_code_token_num":534},{"new_code_raw":"public WebElement searchForWebElement(final By by, int minimumNumberOfMatches, int timeout, boolean scroll){ if(minimumNumberOfMatches < 1){ minimumNumberOfMatches = 1; } List<WebElement> viewsFromScreen = webUtils.getCurrentWebElements(by); addViewsToList (webElements, viewsFromScreen); return getViewFromList(webElements, minimumNumberOfMatches); }","old_code_raw":"\tpublic WebElement searchForWebElement(final By by, int match, int timeout, boolean scroll){\n\n\t\tif(match < 1){\n\t\t\tmatch = 1;\n\t\t}\n\n\t\tList<WebElement> viewsFromScreen = webUtils.getCurrentWebElements(by);\n\t\taddViewsToList (webElements, viewsFromScreen);\n\n\t\treturn getViewFromList(webElements, match);\n\t}\n","new_comment_raw":"@param minimumNumberOfMatches the minimum number of matches that are expected to be shown.  0 means any number of matches","old_comment_raw":"@param match if multiple objects match the text, this determines which one will be clicked","label":1,"pre_label":0,"AST_level":7,"line_counts":12,"new_code_token_num":53},{"new_code_raw":"public Call updatePetWithFormAsync(Long petId, String name, String status, final ApiCallback<Void> callback) throws ApiException { ProgressResponseBody.ProgressListener progressListener = null; ProgressRequestBody.ProgressRequestListener progressRequestListener = null; if (callback != null) { progressListener = new ProgressResponseBody.ProgressListener() { @Override public void update(long bytesRead, long contentLength, boolean done) { callback.onDownloadProgress(bytesRead, contentLength, done); } }; progressRequestListener = new ProgressRequestBody.ProgressRequestListener() { @Override public void onRequestProgress(long bytesWritten, long contentLength, boolean done) { callback.onUploadProgress(bytesWritten, contentLength, done); } }; } Call call = updatePetWithFormCall(petId, name, status, progressListener, progressRequestListener); apiClient.executeAsync(call, callback); return call; }","old_code_raw":"  public Call updatePetWithFormAsync(String petId, String name, String status, final ApiCallback<Void> callback) throws ApiException {\n\n    ProgressResponseBody.ProgressListener progressListener = null;\n    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n    if (callback != null) {\n      progressListener = new ProgressResponseBody.ProgressListener() {\n        @Override\n        public void update(long bytesRead, long contentLength, boolean done) {\n          callback.onDownloadProgress(bytesRead, contentLength, done);\n        }\n      };\n\n      progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {\n        @Override\n        public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {\n          callback.onUploadProgress(bytesWritten, contentLength, done);\n        }\n      };\n    }\n\n    Call call = updatePetWithFormCall(petId, name, status, progressListener, progressRequestListener);\n    apiClient.executeAsync(call, callback);\n    return call;\n  }\n","new_comment_raw":"@param status Updated status of the pet (optional)","old_comment_raw":"@param status Updated status of the pet (optional)","label":0,"pre_label":1,"AST_level":11,"line_counts":26,"new_code_token_num":138},{"new_code_raw":"File getBaseDir(File base, File file) { if (base == null) { return file.getParentFile().getAbsoluteFile(); } else { Iterator bases = getParents(base).iterator(); Iterator fileParents = getParents(file.getAbsoluteFile()).iterator(); File result = null; while (bases.hasNext() && fileParents.hasNext()) { File next = (File) bases.next(); if (next.equals(fileParents.next())) { result = next; } else { break; } } return result; } }","old_code_raw":"    File getBaseDir(final File file1, final File file2) {\n        if (file1 == null || file2 == null) {\n            return null;\n        }\n        final Iterator file1Parents = getParents(file1).iterator();\n        final Iterator file2Parents = getParents(file2.getAbsoluteFile()).iterator();\n        File result = null;\n        while (file1Parents.hasNext() && file2Parents.hasNext()) {\n            File next = (File) file1Parents.next();\n            if (next.equals(file2Parents.next())) {\n                result = next;\n            } else {\n                break;\n            }\n        }\n        return result;\n    }\n","new_comment_raw":"@param file the file for which the new base directory should be returned.","old_comment_raw":"@param file2 The other file for which the common base directory should be returned, may be null.","label":1,"pre_label":0,"AST_level":11,"line_counts":20,"new_code_token_num":106},{"new_code_raw":"protected long copyCollection(CollectionId collectionId, Instant timestamp) throws InterruptedException { AtomicLong docCount = new AtomicLong(); primaryClient.executeBlocking(\"sync '\" + collectionId + \"'\", primary -> { docCount.set(copyCollection(primary, collectionId, timestamp)); }); return docCount.get(); }","old_code_raw":"    protected long copyCollection(CollectionId collectionId, long timestamp) throws InterruptedException {\n        AtomicLong docCount = new AtomicLong();\n        primaryClient.executeBlocking(\"sync '\" + collectionId + \"'\", primary -> {\n            docCount.set(copyCollection(primary, collectionId, timestamp));\n        });\n        return docCount.get();\n    }\n","new_comment_raw":"@param collectionId the identifier of the collection to be copied; may not be null","old_comment_raw":"@param collectionId the identifier of the collection to be copied; may not be null","label":0,"pre_label":1,"AST_level":9,"line_counts":8,"new_code_token_num":60},{"new_code_raw":"public List<String> dependencyPathBetween(int start, int end, Optional<Function<Sentence, List<String>>> selector) { \/\/ Get paths from a node to the root of the sentence LinkedList<Integer> rootToStart = new LinkedList<>(); LinkedList<Integer> rootToEnd = new LinkedList<>(); int startAncestor = start; List<Optional<Integer>> governors = sentence.governors(); Set<Integer> seenVertices = new HashSet<>(); while (startAncestor >= 0 && governors.get(startAncestor).isPresent()) { if (seenVertices.contains(startAncestor)) { \/\/ Found loopiness -- revert to BFS return loopyDependencyPathBetween(start, end, selector); } seenVertices.add(startAncestor); rootToStart.addFirst(startAncestor); startAncestor = governors.get(startAncestor).get(); } if (startAncestor == -1) { rootToStart.addFirst(-1); } int endAncestor = end; seenVertices.clear(); while (endAncestor >= 0 && governors.get(endAncestor).isPresent()) { if (seenVertices.contains(endAncestor)) { \/\/ Found loopiness -- revert to BFS return loopyDependencyPathBetween(start, end, selector); } seenVertices.add(endAncestor); rootToEnd.addFirst(endAncestor); endAncestor = governors.get(endAncestor).get(); } if (endAncestor == -1) { rootToEnd.addFirst(-1); } \/\/ Get least common node int leastCommonNodeIndex = (rootToStart.size() == 0 || rootToEnd.size() == 0 || !rootToStart.get(0).equals(rootToEnd.get(0))) ? -1 : 0; for (int i = 1; i < Math.min(rootToStart.size(), rootToEnd.size()); ++i) { if (rootToStart.get(i).equals(rootToEnd.get(i))) { leastCommonNodeIndex = i; } } \/\/ Construct the path if (leastCommonNodeIndex < 0) { return Collections.emptyList(); } List<String> path = new ArrayList<>(); Optional<List<String>> words = selector.map(x -> x.apply(sentence)); for (int i = rootToStart.size() - 1; i > leastCommonNodeIndex; --i) { final int index = i; words.ifPresent(x -> path.add(x.get(rootToStart.get(index)))); path.add(\"<-\" + sentence.incomingDependencyLabel(rootToStart.get(i)).orElse(\"dep\") + \"-\"); } if (words.isPresent()) { path.add(words.get().get(rootToStart.get(leastCommonNodeIndex))); } for (int i = leastCommonNodeIndex + 1; i < rootToEnd.size(); ++i) { final int index = i; path.add(\"-\" + sentence.incomingDependencyLabel(rootToEnd.get(i)).orElse(\"dep\") + \"->\"); words.ifPresent(x -> path.add(x.get(rootToEnd.get(index)))); } return path; }","old_code_raw":"  public List<String> dependencyPathBetween(int start, int end, Function<Sentence, List<String>> selector) {\n    \/\/ Get paths from a node to the root of the sentence\n    LinkedList<Integer> rootToStart = new LinkedList<>();\n    LinkedList<Integer> rootToEnd = new LinkedList<>();\n    int startAncestor = start;\n    List<Optional<Integer>> governors = sentence.governors();\n    Set<Integer> seenVertices = new HashSet<>();\n    while (startAncestor >= 0 && governors.get(startAncestor).isPresent()) {\n      if (seenVertices.contains(startAncestor)) {\n        return Collections.EMPTY_LIST;\n      }\n      seenVertices.add(startAncestor);\n      rootToStart.addFirst(startAncestor);\n      startAncestor = governors.get(startAncestor).get();\n    }\n    if (startAncestor == -1) {\n      rootToStart.addFirst(-1);\n    }\n    int endAncestor = end;\n    seenVertices.clear();\n    while (endAncestor >= 0 && governors.get(endAncestor).isPresent()) {\n      if (seenVertices.contains(endAncestor)) {\n        return Collections.EMPTY_LIST;\n      }\n      seenVertices.add(endAncestor);\n      rootToEnd.addFirst(endAncestor);\n      endAncestor = governors.get(endAncestor).get();\n    }\n    if (endAncestor == -1) {\n      rootToEnd.addFirst(-1);\n    }\n\n    \/\/ Get least common node\n    int leastCommonNodeIndex = (rootToStart.size() == 0 || rootToEnd.size() == 0 || !rootToStart.get(0).equals(rootToEnd.get(0))) ? -1 : 0;\n    for (int i = 1; i < Math.min(rootToStart.size(), rootToEnd.size()); ++i) {\n      if (rootToStart.get(i).equals(rootToEnd.get(i))) {\n        leastCommonNodeIndex = i;\n      }\n    }\n\n    \/\/ Construct the path\n    if (leastCommonNodeIndex < 0) {\n      return Collections.EMPTY_LIST;\n    }\n    List<String> path = new ArrayList<>();\n    for (int i = rootToStart.size() - 1; i > leastCommonNodeIndex; --i) {\n      path.add(selector.apply(sentence).get(rootToStart.get(i)));\n      path.add(\"<-\" + sentence.incomingDependencyLabel(rootToStart.get(i)).orElse(\"dep\") + \"-\");\n    }\n    path.add(selector.apply(sentence).get(rootToStart.get(leastCommonNodeIndex)));\n    for (int i = leastCommonNodeIndex + 1; i < rootToEnd.size(); ++i) {\n      path.add(\"-\" + sentence.incomingDependencyLabel(rootToEnd.get(i)).orElse(\"dep\") + \"->\");\n      path.add(selector.apply(sentence).get(rootToEnd.get(i)));\n    }\n    return path;\n  }\n","new_comment_raw":"@param start The start word, 0-indexed.","old_comment_raw":"@param span The span of the sentence to find the mode element in. This must be entirely contained in the sentence.","label":1,"pre_label":0,"AST_level":11,"line_counts":64,"new_code_token_num":555},{"new_code_raw":"public static Point getCanvasImageLocation(Client client, Graphics2D graphics, LocalPoint localLocation, BufferedImage image, int zOffset) { int plane = client.getPlane(); Point p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset); if (p == null) { return null; } int xOffset = p.getX() - image.getWidth() \/ 2; int yOffset = p.getY() - image.getHeight() \/ 2; return new Point(xOffset, yOffset); }","old_code_raw":"\tpublic static Point getCanvasImageLocation(Client client, Graphics2D graphics, Point localLocation, BufferedImage image, int zOffset)\n\t{\n\t\tint plane = client.getPlane();\n\n\t\tPoint p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset);\n\n\t\tif (p == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tint xOffset = p.getX() - image.getWidth() \/ 2;\n\t\tint yOffset = p.getY() - image.getHeight() \/ 2;\n\n\t\treturn new Point(xOffset, yOffset);\n\t}\n","new_comment_raw":"@param graphics","old_comment_raw":"@param graphics","label":0,"pre_label":1,"AST_level":7,"line_counts":17,"new_code_token_num":98},{"new_code_raw":"protected String getAsText(int fieldValue, Locale locale) { return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToText(fieldValue); }","old_code_raw":"    public String getAsText(long instant, Locale locale) {\n        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToText(get(instant));\n    }\n","new_comment_raw":"@param fieldValue the field value to query","old_comment_raw":"@param instant the time instant in millis to query","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":23},{"new_code_raw":"public static RemoteProxy getNewBasicRemoteProxy(Map<String, Object> cap, String url,Registry registry) { RegistrationRequest req = new RegistrationRequest(); req.addDesiredCapabilitiy(cap); Map<String, Object> config = new HashMap<String, Object>(); config.put(\"url\", url); req.setConfiguration(config); return new RemoteProxy(req,registry); }","old_code_raw":"\tpublic static RemoteProxy getNewBasicRemoteProxy(Map<String, Object> cap, String url) {\n\n\t\tRegistrationRequest req = new RegistrationRequest();\n\n\t\treq.addDesiredCapabilitiy(cap);\n\n\t\tMap<String, Object> config = new HashMap<String, Object>();\n\t\tconfig.put(\"url\", url);\n\t\treq.setConfiguration(config);\n\t\treturn new RemoteProxy(req);\n\n\t}\n","new_comment_raw":"@param cap","old_comment_raw":"@param cap","label":0,"pre_label":1,"AST_level":8,"line_counts":13,"new_code_token_num":70},{"new_code_raw":"private MessageBatcher getBatcher(final String serviceUrl, String pBatcherName) { String batcherName = null; try { batcherName = new URL(serviceUrl).getHost(); } catch (MalformedURLException e1) { batcherName = serviceUrl; } String absoluteBatcherName = batcherName + \"-\" + pBatcherName; ConfigurationManager.getConfigInstance().setProperty( \"batcher.\" + absoluteBatcherName + \".queue.maxMessages\", config.getMaxElementsInPeerReplicationPool()); ConfigurationManager.getConfigInstance().setProperty( \"batcher.\" + absoluteBatcherName + \".batch.maxMessages\", 250); ConfigurationManager.getConfigInstance().setProperty( \"batcher.\" + absoluteBatcherName + \".keepAliveTime\", config.getMaxIdleThreadAgeInMinutesForPeerReplication() * 60); ConfigurationManager.getConfigInstance().setProperty( \"batcher.\" + absoluteBatcherName + \".maxThreads\", config.getMaxThreadsForPeerReplication()); return BatcherFactory.createBatcher(absoluteBatcherName, new MessageProcessor<ReplicationTask>() { private String BATCH_URL_PATH = \"apps\/batch\/\";; @Override public void process(List<ReplicationTask> tasks) { if (!tasks.get(0).isBatchingSupported()) { executeSingle(tasks); } else if (!executeBatch(tasks)) { executeSingle(tasks); } } private boolean executeBatch(List<ReplicationTask> tasks) { boolean success = true; boolean done = true; PeerEurekaNode.ReplicationList list = new PeerEurekaNode.ReplicationList(); for (ReplicationTask task : tasks) { Object[] args = { task.getAppName(), task.getId(), task.getAction(), new Date(System.currentTimeMillis()), new Date(task.getSubmitTime()) }; if (System.currentTimeMillis() - config.getMaxTimeForReplication() > task .getSubmitTime()) { logger.warn( \"Replication events older than the threshold. AppName : {}, Id: {}, Action : {}, Current Time : {}, Submit Time :{}\", args); continue; } PeerEurekaNode.ReplicationInstance instance = new PeerEurekaNode.ReplicationInstance(); instance.setAppName(task.getAppName()); instance.setId(task.getId()); InstanceInfo instanceInfo = task.getInstanceInfo(); if (instanceInfo != null) { String overriddenStatus = (task .getOverriddenStatus() == null ? null : task.getOverriddenStatus().name()); instance.setOverriddenStatus(overriddenStatus); instance.setLastDirtyTimestamp(instanceInfo .getLastDirtyTimestamp()); if (task.shouldReplicateInstanceInfo()) { instance.setInstanceInfo(instanceInfo); } String instanceStatus = instanceInfo .getStatus() == null ? null : instanceInfo.getStatus().name(); instance.setStatus(instanceStatus); } list.addReplicationInstance(instance); } if (list.getList().size() == 0) { return true; } list.setAction(tasks.get(0).getAction()); DynamicCounter.increment(\"Batch_\" + list.getAction().name() + \"_tries\"); do { done = true; ClientResponse response = null; try { response = jerseyApacheClient .resource(serviceUrl) .path(BATCH_URL_PATH) .accept(MediaType.APPLICATION_JSON_TYPE) .type(MediaType.APPLICATION_JSON_TYPE) .post(ClientResponse.class, list); if (isSuccess(response)) { return false; } DynamicCounter.increment(\"Batch_\" + list.getAction().name() + \"_success\"); PeerEurekaNode.ReplicationListResponse batchResponse = response .getEntity(PeerEurekaNode.ReplicationListResponse.class); int ctr = 0; for (PeerEurekaNode.ReplicationInstanceResponse singleResponse : batchResponse .getResponseList()) { int statusCode = singleResponse .getStatusCode(); if ((!isSuccess(response)) || (singleResponse .getResponseEntity() != null)) { if (singleResponse.getResponseEntity() != null) { tasks.get(ctr) .setPeerInstanceInfo( singleResponse .getResponseEntity()); } tasks.get(ctr) .handleFailure(statusCode); } ++ctr; } done = true; } catch (Throwable e) { if ((isNetworkConnectException(e))) { DynamicCounter.increment(\"Batch_\" + list.getAction().name() + \"_retries\"); done = false; } else { success = false; logger.info( \"Not re-trying this exception because it does not seem to be a network exception\", e); } } finally { if (response != null) { response.close(); } } } while (!done); return success; } private boolean isSuccess(ClientResponse response) { return response.getStatus() < 200 || response.getStatus() >= 300; } private void executeSingle(List<ReplicationTask> tasks) { for (ReplicationTask task : tasks) { boolean done = true; do { done = true; try { Object[] args = { task.getAppName(), task.getId(), task.getAction(), new Date(System.currentTimeMillis()), new Date(task.getSubmitTime()) }; if (System.currentTimeMillis() - config.getMaxTimeForReplication() > task .getSubmitTime()) { logger.warn( \"Replication events older than the threshold. AppName : {}, Id: {}, Action : {}, Current Time : {}, Submit Time :{}\", args); continue; } DynamicCounter.increment(\"Single_\" + task.getAction().name() + \"_tries\"); int statusCode = task.execute(); if (statusCode < 200 && statusCode > 299) { task.handleFailure(statusCode); } DynamicCounter.increment(\"Single_\" + task.getAction().name() + \"_success\"); } catch (Throwable e) { logger.error( name + task.getAppName() + \"\/\" + task.getId() + \":\" + task.getAction(), e); try { Thread.sleep(RETRY_SLEEP_TIME_MS); } catch (InterruptedException e1) { } if ((isNetworkConnectException(e))) { DynamicCounter.increment(task .getAction().name() + \"_retries\"); done = false; } else { logger.info( \"Not re-trying this exception because it does not seem to be a network exception\", e); } } } while (!done); } } }); }","old_code_raw":"    private MessageBatcher getBatcher(String serviceUrl, Action action) {\n        String batcherName = null;\n        try {\n            batcherName = new URL(serviceUrl).getHost();\n        } catch (MalformedURLException e1) {\n            batcherName = serviceUrl;\n        }\n        String absoluteBatcherName = batcherName + \"-\" + action.name();\n        ConfigurationManager.getConfigInstance().setProperty(\n                \"batcher.\" + absoluteBatcherName + \".queue.maxMessages\",\n                config.getMaxElementsInPeerReplicationPool());\n        ConfigurationManager.getConfigInstance().setProperty(\n                \"batcher.\" + absoluteBatcherName + \".keepAliveTime\",\n                config.getMaxIdleThreadAgeInMinutesForPeerReplication() * 60);\n        ConfigurationManager.getConfigInstance().setProperty(\n                \"batcher.\" + absoluteBatcherName + \".maxThreads\",\n                config.getMaxThreadsForPeerReplication());\n\n        return BatcherFactory.createBatcher(absoluteBatcherName,\n                new MessageProcessor<ReplicationTask>() {\n\n                    @Override\n                    public void process(List<ReplicationTask> tasks) {\n                        for (ReplicationTask task : tasks) {\n                            boolean done = true;\n                            do {\n                                done = true;\n                                try {\n                                    Object[] args = {\n                                            task.getAppName(),\n                                            task.getId(),\n                                            task.getAction(),\n                                            new Date(System.currentTimeMillis()),\n                                            new Date(task.getSubmitTime()) };\n                                    if (System.currentTimeMillis()\n                                            - config.getMaxTimeForReplication() > task\n                                            .getSubmitTime()) {\n                                        logger.warn(\n                                                \"Replication events older than the threshold. AppName : {}, Id: {}, Action : {}, Current Time : {}, Submit Time :{}\",\n                                                args);\n\n                                        continue;\n                                    }\n                                    task.execute();\n                                } catch (Throwable e) {\n                                    logger.error(\n                                            name + task.getAppName() + \"\/\"\n                                                    + task.getId() + \":\"\n                                                    + task.getAction(), e);\n                                    try {\n                                        Thread.sleep(RETRY_SLEEP_TIME_MS);\n                                    } catch (InterruptedException e1) {\n\n                                    }\n                                    if ((isNetworkConnectException(e))) {\n                                        DynamicCounter.increment(task\n                                                .getAction().name()\n                                                + \"_retries\");\n                                        done = false;\n                                    } else {\n                                        logger.info(\n                                                \"Not re-trying this exception because it does not seem to be a network exception\",\n                                                e);\n                                    }\n                                }\n                            } while (!done);\n                        }\n                    }\n                });\n    }\n","new_comment_raw":"@param action the action that indicates the type of replication event - registrations, heartbeat etc","old_comment_raw":"@param action the action that indicates the type of replication event - registrations, heartbeat etc","label":0,"pre_label":1,"AST_level":20,"line_counts":215,"new_code_token_num":1124},{"new_code_raw":"public int get(long instant) { \/\/ Get an initial estimate of the year, and the millis value that \/\/ represents the start of that year. Then verify estimate and fix if \/\/ necessary. int year; long unitMillis = getDurationUnitMillis(); if (instant >= 0) { year = 1970 + (int) (instant \/ unitMillis); } else { year = 1970 + (int) ((instant - unitMillis + 1) \/ unitMillis); } long yearStart = iChronology.getYearMillis(year); if ((yearStart ^ instant) < 0) { \/\/ Sign mismatch, operation overflowed. return getOverflow(instant); } long diff = instant - yearStart; if (diff < 0) { \/\/ Subtract one year to fix estimate. year--; } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) { \/\/ One year may need to be added to fix estimate. long oneYear; if (iChronology.isLeapYear(year)) { oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L; } else { oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L; } yearStart += oneYear; if ((yearStart ^ instant) < 0) { \/\/ Sign mismatch, operation overflowed. return getOverflow(instant); } if (yearStart <= instant) { \/\/ Didn't go too far, so actually add one year. year++; } } return year; }","old_code_raw":"    public int get(long millis) {\n        \/\/ Get an initial estimate of the year, and the millis value\n        \/\/ that represents the start of that year.\n        int year = 1970 + (int) (millis \/ iRoughMillisPerYear);\n        long yearStartMillis = iChronology.getYearMillis(year);\n\n        if (millis > yearStartMillis) {\n            for (;;) {\n                \/\/ Actual year may be greater than what we estimated. Check if\n                \/\/ year should advance.\n                if (iChronology.isLeapYear(year)) {\n                    yearStartMillis += DateTimeConstants.MILLIS_PER_DAY * 366L;\n                } else {\n                    yearStartMillis += DateTimeConstants.MILLIS_PER_DAY * 365L;\n                }\n                if (millis < yearStartMillis) {\n                    \/\/ Year was correct, no need to advance.\n                    break;\n                }\n                year++;\n                if (millis == yearStartMillis) {\n                    \/\/ Millis is at start of year; year is now correct, so no\n                    \/\/ need to check anymore.\n                    break;\n                }\n                if ((millis ^ yearStartMillis) < 0) {\n                    \/\/ Sign mismatch, operation overflowed.\n                    return getOverflow(millis);\n                }\n            }\n        } else if (millis < yearStartMillis) {\n            for (;;) {\n                \/\/ Actual year less than what we estimated. Go to previous year\n                \/\/ and check.\n                year--;\n                if (iChronology.isLeapYear(year)) {\n                    yearStartMillis -= DateTimeConstants.MILLIS_PER_DAY * 366L;\n                } else {\n                    yearStartMillis -= DateTimeConstants.MILLIS_PER_DAY * 365L;\n                }\n                if (millis >= yearStartMillis) {\n                    \/\/ Year is now correct.\n                    break;\n                }\n                if ((millis ^ yearStartMillis) < 0) {\n                    \/\/ Sign mismatch, operation overflowed.\n                    return getOverflow(millis);\n                }\n            }\n        }\n\n        return year;\n    }\n","new_comment_raw":"@param instant the time instant in millis to query.","old_comment_raw":"@param millis the time instant in millis to query.","label":1,"pre_label":0,"AST_level":12,"line_counts":49,"new_code_token_num":254},{"new_code_raw":"public int delete(Object[] row, Instant ts) throws InterruptedException { return delete(row, ts, 0, 1); }","old_code_raw":"        public int delete(Object[] row, long ts) throws InterruptedException {\n            return delete(row, ts, 0, 1);\n        }\n","new_comment_raw":"@param ts the timestamp for this row","old_comment_raw":"@param ts the timestamp for this row","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":28},{"new_code_raw":"public String getTypeDeclaration(Schema p) { if (ModelUtils.isArraySchema(p)) { ArraySchema ap = (ArraySchema) p; Schema inner = ap.getItems(); return getTypeDeclaration(inner) + \"[]\"; } else if (ModelUtils.isMapSchema(p)) { Schema inner = (Schema) p.getAdditionalProperties(); \/\/ TODO not sure if the following map\/hash declaration is correct return \"{String, \" + getTypeDeclaration(inner) + \"}\"; } else if (!languageSpecificPrimitives.contains(getSchemaType(p))) { return packageName + \".Model.\" + super.getTypeDeclaration(p); } return super.getTypeDeclaration(p); }","old_code_raw":"    public String getTypeDeclaration(Property p) {\n        if (p instanceof ArrayProperty) {\n            ArrayProperty ap = (ArrayProperty) p;\n            Property inner = ap.getItems();\n            return getTypeDeclaration(inner) + \"[]\";\n        } else if (p instanceof MapProperty) {\n            MapProperty mp = (MapProperty) p;\n            Property inner = mp.getAdditionalProperties();\n            \/\/ TODO not sure if the following map\/hash declaration is correct\n            return \"{String, \" + getTypeDeclaration(inner) + \"}\";\n        } else if (!languageSpecificPrimitives.contains(getSwaggerType(p))) {\n            return packageName + \".Model.\" + super.getTypeDeclaration(p);\n        }\n        return super.getTypeDeclaration(p);\n    }\n","new_comment_raw":"@param p OpenAPI Schema object","old_comment_raw":"@param p Swagger Property object","label":1,"pre_label":0,"AST_level":10,"line_counts":15,"new_code_token_num":130},{"new_code_raw":"public static SemgrexPattern compile(String semgrex, Env env) { try { SemgrexParser parser = new SemgrexParser(new StringReader(semgrex + \"\\n\")); SemgrexPattern newPattern = parser.Root(); newPattern.env = env; newPattern.patternString = semgrex; return newPattern; } catch (ParseException ex) { throw new SemgrexParseException(\"Error parsing semgrex pattern \" + semgrex, ex); } catch (TokenMgrError er) { throw new SemgrexParseException(\"Error parsing semgrex pattern \" + semgrex, er); } }","old_code_raw":"  public static SemgrexPattern compile(String semgrex) {\n    try {\n      SemgrexParser parser = new SemgrexParser(new StringReader(semgrex + \"\\n\"));\n      SemgrexPattern newPattern = parser.Root();\n      newPattern.patternString = semgrex;\n      return newPattern;\n    } catch (ParseException ex) {\n      throw new SemgrexParseException(\"Error parsing semgrex pattern \" + semgrex, ex);\n    } catch (TokenMgrError er) {\n      throw new SemgrexParseException(\"Error parsing semgrex pattern \" + semgrex, er);\n    }\n  }\n","new_comment_raw":"@param semgrex the pattern string","old_comment_raw":"@param semgrex the pattern string","label":0,"pre_label":1,"AST_level":9,"line_counts":14,"new_code_token_num":97},{"new_code_raw":"public long set(long instant, int era) { Utils.verifyValueBounds(this, era, DateTimeConstants.BCE, DateTimeConstants.CE); int oldEra = get(instant); if (oldEra != era) { int year = iChronology.year().get(instant); return iChronology.year().set(instant, -year); } else { return instant; } }","old_code_raw":"    public long set(long millis, int era) {\n        super.verifyValueBounds(era, DateTimeConstants.BCE, DateTimeConstants.CE);\n            \n        int oldEra = get(millis);\n        if (oldEra != era) {\n            int year = iChronology.year().get(millis);\n            return iChronology.year().set(millis, -year);\n        } else {\n            return millis;\n        }\n    }\n","new_comment_raw":"@param instant the time instant in millis to update.","old_comment_raw":"@param millis the time instant in millis to update.","label":1,"pre_label":0,"AST_level":9,"line_counts":12,"new_code_token_num":71},{"new_code_raw":"public static String ensurePrerequisiteAnnotators(String[] annotators) { \/\/ Get an unordered set of annotators Set<String> unorderedAnnotators = new LinkedHashSet<>(); \/\/ linked to preserve order Collections.addAll(unorderedAnnotators, annotators); for (String annotator : annotators) { \/\/ Add the annotator if (!getNamedAnnotators().containsKey(annotator.toLowerCase())) { throw new IllegalArgumentException(\"Unknown annotator: \" + annotator); } \/\/ Add its transitive dependencies unorderedAnnotators.add(annotator.toLowerCase()); if (!Annotator.DEFAULT_REQUIREMENTS.containsKey(annotator.toLowerCase())) { throw new IllegalArgumentException(\"Cannot infer requirements for annotator: \" + annotator); } Queue<String> fringe = new LinkedList<>(Annotator.DEFAULT_REQUIREMENTS.get(annotator.toLowerCase())); int ticks = 0; while (!fringe.isEmpty()) { ticks += 1; if (ticks == 1000000) { throw new IllegalStateException(\"[INTERNAL ERROR] Annotators have a circular dependency.\"); } String prereq = fringe.poll(); unorderedAnnotators.add(prereq); fringe.addAll(Annotator.DEFAULT_REQUIREMENTS.get(prereq.toLowerCase())); } } \/\/ Order the annotators List<String> orderedAnnotators = new ArrayList<>(); while (!unorderedAnnotators.isEmpty()) { boolean somethingAdded = false; \/\/ to make sure the dependencies are satisfiable \/\/ Loop over candidate annotators to add Iterator<String> iter = unorderedAnnotators.iterator(); while (iter.hasNext()) { String candidate = iter.next(); \/\/ Are the requirements satisfied? boolean canAdd = true; for (String prereq : Annotator.DEFAULT_REQUIREMENTS.get(candidate.toLowerCase())) { if (!orderedAnnotators.contains(prereq)) { canAdd = false; break; } } \/\/ If so, add the annotator if (canAdd) { orderedAnnotators.add(candidate); iter.remove(); somethingAdded = true; } } \/\/ Make sure we're making progress every iteration, to prevent an infinite loop if (!somethingAdded) { throw new IllegalArgumentException(\"Unsatisfiable annotator list: \" + StringUtils.join(annotators, \",\")); } } \/\/ Return return StringUtils.join(orderedAnnotators, \",\"); }","old_code_raw":"  public static String ensurePrerequisiteAnnotators(String[] annotators, Properties props) {\n    \/\/ Get an unordered set of annotators\n    Set<String> unorderedAnnotators = new LinkedHashSet<>();  \/\/ linked to preserve order\n    Collections.addAll(unorderedAnnotators, annotators);\n    for (String annotator : annotators) {\n      \/\/ Add the annotator\n      if (!getNamedAnnotators().containsKey(annotator.toLowerCase())) {\n        throw new IllegalArgumentException(\"Unknown annotator: \" + annotator);\n      }\n\n      \/\/ Add its transitive dependencies\n      unorderedAnnotators.add(annotator.toLowerCase());\n      if (!Annotator.DEFAULT_REQUIREMENTS.containsKey(annotator.toLowerCase())) {\n        throw new IllegalArgumentException(\"Cannot infer requirements for annotator: \" + annotator);\n      }\n      Queue<String> fringe = new LinkedList<>(Annotator.DEFAULT_REQUIREMENTS.get(annotator.toLowerCase()));\n      int ticks = 0;\n      while (!fringe.isEmpty()) {\n        ticks += 1;\n        if (ticks == 1000000) {\n          throw new IllegalStateException(\"[INTERNAL ERROR] Annotators have a circular dependency.\");\n        }\n        String prereq = fringe.poll();\n        unorderedAnnotators.add(prereq);\n        fringe.addAll(Annotator.DEFAULT_REQUIREMENTS.get(prereq.toLowerCase()));\n      }\n    }\n\n    \/\/ Order the annotators\n    List<String> orderedAnnotators = new ArrayList<>();\n    while (!unorderedAnnotators.isEmpty()) {\n      boolean somethingAdded = false;  \/\/ to make sure the dependencies are satisfiable\n      \/\/ Loop over candidate annotators to add\n      Iterator<String> iter = unorderedAnnotators.iterator();\n      while (iter.hasNext()) {\n        String candidate = iter.next();\n        \/\/ Are the requirements satisfied?\n        boolean canAdd = true;\n        for (String prereq : Annotator.DEFAULT_REQUIREMENTS.get(candidate.toLowerCase())) {\n          if (!orderedAnnotators.contains(prereq)) {\n            canAdd = false;\n            break;\n          }\n        }\n        \/\/ If so, add the annotator\n        if (canAdd) {\n          orderedAnnotators.add(candidate);\n          iter.remove();\n          somethingAdded = true;\n        }\n      }\n      \/\/ Make sure we're making progress every iteration, to prevent an infinite loop\n      if (!somethingAdded) {\n        throw new IllegalArgumentException(\"Unsatisfiable annotator list: \" + StringUtils.join(annotators, \",\"));\n      }\n    }\n\n    \/\/ Remove depparse + parse -- these are redundant\n    if (orderedAnnotators.contains(STANFORD_PARSE) && !ArrayUtils.contains(annotators, STANFORD_DEPENDENCIES)) {\n      orderedAnnotators.remove(STANFORD_DEPENDENCIES);\n    }\n\n    \/\/ Tweak the properties, if necessary\n    \/\/ (set the mention annotator to use dependency trees, if appropriate)\n    if (orderedAnnotators.contains(Annotator.STANFORD_MENTION) && !orderedAnnotators.contains(Annotator.STANFORD_PARSE) &&\n        !props.containsKey(\"coref.md.type\")) {\n      props.setProperty(\"coref.md.type\", \"dep\");\n    }\n    \/\/ (ensure regexner is after ner)\n    if (orderedAnnotators.contains(Annotator.STANFORD_NER) && orderedAnnotators.contains(STANFORD_REGEXNER)) {\n      orderedAnnotators.remove(STANFORD_REGEXNER);\n      int nerIndex = orderedAnnotators.indexOf(Annotator.STANFORD_NER);\n      orderedAnnotators.add(nerIndex + 1, STANFORD_REGEXNER);\n    }\n    \/\/ (ensure coref is before openie)\n    if (orderedAnnotators.contains(Annotator.STANFORD_COREF) && orderedAnnotators.contains(STANFORD_OPENIE)) {\n      int maxIndex = Math.max(\n          orderedAnnotators.indexOf(STANFORD_OPENIE),\n          orderedAnnotators.indexOf(STANFORD_COREF)\n          );\n      if (Objects.equals(orderedAnnotators.get(maxIndex), STANFORD_OPENIE)) {\n        orderedAnnotators.add(maxIndex, STANFORD_COREF);\n        orderedAnnotators.remove(STANFORD_COREF);\n      } else {\n        orderedAnnotators.add(maxIndex + 1, STANFORD_OPENIE);\n        orderedAnnotators.remove(STANFORD_OPENIE);\n      }\n    }\n\n    \/\/ Return\n    return StringUtils.join(orderedAnnotators, \",\");\n  }\n","new_comment_raw":"@param annotators The annotators the user has requested.","old_comment_raw":"@param annotators The annotators the user has requested.","label":0,"pre_label":1,"AST_level":13,"line_counts":61,"new_code_token_num":417},{"new_code_raw":"public Query createQuery(Expr<?>[] args){ queryMixin.addToProjection(args); String queryString = toString(); logQuery(queryString); return createQuery(queryString, queryMixin.getMetadata().getModifiers()); }","old_code_raw":"    public Query createQuery(Expr<?> expr1, Expr<?> expr2, Expr<?>... rest){\n        queryMixin.addToProjection(expr1, expr2);\n        queryMixin.addToProjection(rest);\n        String queryString = toString();\n        logQuery(queryString);\n        return createQuery(queryString, queryMixin.getMetadata().getModifiers());\n    }\n","new_comment_raw":"@param args","old_comment_raw":"@param expr","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":43},{"new_code_raw":"public PumpEnactResult setTempBasalAbsolute(Double absoluteRate, Integer durationInMinutes, boolean force) { Double rateAfterConstraints = applyBasalConstraints(absoluteRate); PumpEnactResult result = activePump.setTempBasalAbsolute(rateAfterConstraints, durationInMinutes, force); if (Config.logCongigBuilderActions) log.debug(\"setTempBasalAbsolute rate: \" + rateAfterConstraints + \" durationInMinutes: \" + durationInMinutes + \" success: \" + result.success + \" enacted: \" + result.enacted); return result; }","old_code_raw":"    public PumpEnactResult setTempBasalAbsolute(Double absoluteRate, Integer durationInMinutes) {\n        Double rateAfterConstraints = applyBasalConstraints(absoluteRate);\n        PumpEnactResult result = activePump.setTempBasalAbsolute(rateAfterConstraints, durationInMinutes);\n        if (Config.logCongigBuilderActions)\n            log.debug(\"setTempBasalAbsolute rate: \" + rateAfterConstraints + \" durationInMinutes: \" + durationInMinutes + \" success: \" + result.success + \" enacted: \" + result.enacted);\n        return result;\n    }\n","new_comment_raw":"@param absoluteRate","old_comment_raw":"@param absoluteRate","label":0,"pre_label":1,"AST_level":13,"line_counts":8,"new_code_token_num":77},{"new_code_raw":"long getLoad(MigratableHandler handler) { return handlerLoadCounter.get(handler); }","old_code_raw":"    long getLoad(MigratablePipeline pipeline) {\n        return pipelineLoadCounter.get(pipeline);\n    }\n","new_comment_raw":"@param handler","old_comment_raw":"@param pipeline","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":15},{"new_code_raw":"private boolean hasSingleValue(ColumnStatistics columnStatistics, long rowCount) { return columnStatistics != null && isSingleVal(columnStatistics, rowCount); }","old_code_raw":"  private boolean hasSingleValue(ColumnMetadata columnChunkMetaData, long rowCount) {\n    return (columnChunkMetaData != null) && (columnChunkMetaData.hasSingleValue(rowCount));\n  }\n","new_comment_raw":"@param rowCount rows count in column chunk","old_comment_raw":"@param rowCount rows count in column chunk","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":25},{"new_code_raw":"public double distanceTo(double x, double y, double z) { final double a = this.x - x; final double b = this.y - y; final double c = this.z - z; return Math.sqrt(a * a + b * b + c * c); }","old_code_raw":"\tpublic float distanceTo(float x, float y, float z) {\n\t\tfinal float a = this.x - x;\n\t\tfinal float b = this.y - y;\n\t\tfinal float c = this.z - z;\n\t\treturn (float) Math.sqrt(a * a + b * b + c * c);\n\t}\n","new_comment_raw":"@param double y The point y coordinate.","old_comment_raw":"@param float y The point y coordinate.","label":1,"pre_label":0,"AST_level":8,"line_counts":8,"new_code_token_num":56},{"new_code_raw":"private boolean isAncestorOf(Object object1, Object object2) { if (object2 == null) return false; Object parent = getParent(object2); if (parent == object1) return true; return isAncestorOf(object1, parent); }","old_code_raw":"\tprivate boolean isAncestorOf(Object node, Object target) {\r\n\t\tif (target == null) return false;\r\n\t\tObject parent = getParent(target);\r\n\t\tif (parent == node) return true;\r\n\t\treturn isAncestorOf(node, parent);\r\n   }\r\n","new_comment_raw":"@param object2 The second object to be tested.","old_comment_raw":"@param target The target node.","label":1,"pre_label":0,"AST_level":6,"line_counts":8,"new_code_token_num":43},{"new_code_raw":"public boolean onExpandStart(CommonCardView viewCard) { Card card = viewCard.getCard(); if (card!=null){ String itemId = card.getId(); if (!mExpandedIds.contains(itemId)) { return true; } } return false; }","old_code_raw":"    public boolean onExpandStart(CardView viewCard) {\n        Card card = viewCard.getCard();\n        if (card!=null){\n            String itemId = card.getId();\n            if (!mExpandedIds.contains(itemId)) {\n                return true;\n            }\n        }\n        return false;\n    }\n","new_comment_raw":"@param viewCard","old_comment_raw":"@param viewCard","label":0,"pre_label":1,"AST_level":8,"line_counts":11,"new_code_token_num":48},{"new_code_raw":"public Call buildCall(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException { Request request = buildRequest(path, method, queryParams, collectionQueryParams, body, headerParams, formParams, authNames, callback); return httpClient.newCall(request); }","old_code_raw":"    public Call buildCall(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {\n        Request request = buildRequest(path, method, queryParams, collectionQueryParams, body, headerParams, formParams, authNames, progressRequestListener);\n\n        return httpClient.newCall(request);\n    }\n","new_comment_raw":"@param headerParams The header parameters","old_comment_raw":"@param headerParams The header parameters","label":0,"pre_label":1,"AST_level":6,"line_counts":6,"new_code_token_num":75},{"new_code_raw":"public float get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }","old_code_raw":"    public float get(WithAttributes attributes) {\r\n        return attributes.getAttributes().get(this);\r\n    }\r\n","new_comment_raw":"@param withAttributes an object containing an AttributeMap","old_comment_raw":"@param attributes an object containing an AttributeMap","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":19},{"new_code_raw":"public boolean scrollList(int listIndex, Direction direction, ArrayList<ListView> listViews) { int[] xy = new int[2]; final ListView listView = getView(ListView.class, listViews, listIndex); listView.getLocationOnScreen(xy); while (xy[1] + 20 > activityUtils.getCurrentActivity(false) .getWindowManager().getDefaultDisplay().getHeight()) { scrollScrollView(direction, null); listView.getLocationOnScreen(xy); } if (direction == Direction.DOWN) { if (listView.getLastVisiblePosition() >= listView.getCount() - 1) return false; scrollListToLine(listView, listView.getLastVisiblePosition()+1); } else if (direction == Direction.UP) { if (listView.getFirstVisiblePosition() < 2) return false; final int lines = (listView.getLastVisiblePosition()+1)-(listView.getFirstVisiblePosition()); int lineToScrollTo = listView.getFirstVisiblePosition() - lines; if(lineToScrollTo < 0) lineToScrollTo=0; scrollListToLine(listView, lineToScrollTo); } sleeper.sleep(); return true; }","old_code_raw":"\tpublic boolean scrollList(int listIndex, Direction direction) {\n\t\tint[] xy = new int[2];\n\t\tfinal ListView listView = viewFetcher.getCurrentViews(ListView.class).get(listIndex);\n\t\tlistView.getLocationOnScreen(xy);\n\t\n\t\twhile (xy[1] + 20 > activityUtils.getCurrentActivity(false)\n\t\t\t\t.getWindowManager().getDefaultDisplay().getHeight()) {\n\t\t\tscrollScrollView(direction);\n\t\t\tlistView.getLocationOnScreen(xy);\n\t\t}\n\t\tif (direction == Direction.DOWN) {\n\t\t\t\n\t\t\tif (listView.getLastVisiblePosition() >= listView.getCount() - 1) \n\t\t\t\treturn false;\n\t\t\t\n\t\t\tscrollListToLine(listView, listView.getLastVisiblePosition()+1);\n\t\t\t\n\t\t} else if (direction == Direction.UP) {\n\t\t\t\n\t\t\tif (listView.getFirstVisiblePosition() < 2) \n\t\t\t\treturn false;\n\t\t\t\n\t\t\tfinal int lines = (listView.getLastVisiblePosition()+1)-(listView.getFirstVisiblePosition());\n\t\t\tint lineToScrollTo = listView.getFirstVisiblePosition() - lines;\n\t\t\tif(lineToScrollTo < 0)\n\t\t\t\tlineToScrollTo=0;\n\t\t\t\n\t\t\tscrollListToLine(listView, lineToScrollTo);\n\t\t}\t\n\t\tsleeper.sleep();\n\t\treturn true;\n\t}\n","new_comment_raw":"@param direction the direction to be scrolled","old_comment_raw":"@param direction the direction to be scrolled","label":0,"pre_label":1,"AST_level":10,"line_counts":34,"new_code_token_num":190},{"new_code_raw":"public boolean searchWithTimeoutFor(Class<? extends TextView> viewClass, String regex, int expectedMinimumNumberOfMatches, boolean scroll, boolean visible) { final long endTime = System.currentTimeMillis() + TIMEOUT; while (System.currentTimeMillis() < endTime) { sleeper.sleep(); final boolean foundAnyMatchingView = searchFor(viewClass, regex, expectedMinimumNumberOfMatches, scroll, visible); if (foundAnyMatchingView){ return true; } } return false; }","old_code_raw":"\tpublic boolean searchWithTimeoutFor(Class<? extends TextView> viewClass, String regex, int expectedMinimumNumberOfMatches, boolean scroll) {\n\t\tfinal long endTime = System.currentTimeMillis() + TIMEOUT;\n\n\t\twhile (System.currentTimeMillis() < endTime) {\n\t\t\tsleeper.sleep();\n\t\t\tfinal boolean foundAnyMatchingView = searchFor(viewClass, regex, expectedMinimumNumberOfMatches, scroll);\n\t\t\tif (foundAnyMatchingView){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n","new_comment_raw":"@param scroll whether scrolling should be performed","old_comment_raw":"@param scroll whether scrolling should be performed","label":0,"pre_label":1,"AST_level":8,"line_counts":14,"new_code_token_num":77},{"new_code_raw":"public int get(long instant) { \/\/ 1970-01-01 is day of week 4, Thursday. long daysSince19700101; if (instant >= 0) { daysSince19700101 = instant \/ DateTimeConstants.MILLIS_PER_DAY; } else { daysSince19700101 = (instant - (DateTimeConstants.MILLIS_PER_DAY - 1)) \/ DateTimeConstants.MILLIS_PER_DAY; if (daysSince19700101 < -3) { return 7 + (int) ((daysSince19700101 + 4) % 7); } } return 1 + (int) ((daysSince19700101 + 3) % 7); }","old_code_raw":"    public int get(long millis) {\n        \/\/ 1970-01-01 is day of week 4, Thursday.\n\n        long daysSince19700101;\n        if (millis >= 0) {\n            daysSince19700101 = millis \/ DateTimeConstants.MILLIS_PER_DAY;\n        } else {\n            daysSince19700101 = (millis - (DateTimeConstants.MILLIS_PER_DAY - 1))\n                \/ DateTimeConstants.MILLIS_PER_DAY;\n            if (daysSince19700101 < -3) {\n                return 7 + (int) ((daysSince19700101 + 4) % 7);\n            }\n        }\n\n        return 1 + (int) ((daysSince19700101 + 3) % 7);\n    }\n","new_comment_raw":"@param instant the time instant in millis to query","old_comment_raw":"@param millis the time instant in millis to query","label":1,"pre_label":0,"AST_level":12,"line_counts":17,"new_code_token_num":97},{"new_code_raw":"public AtmosphereRequest queryString(String qs) { if (qs == null) return this; if (!qs.isEmpty()) { QueryStringDecoder decoder = new QueryStringDecoder(getRequestURI() + \"?\" + qs); Map<String, List<String>> m = decoder.getParameters(); Map<String, String[]> newM = new HashMap<String, String[]>(); for (Map.Entry<String, List<String>> q : m.entrySet()) { newM.put(q.getKey(), q.getValue().toArray(new String[q.getValue().size()])); } b.queryStrings(newM); } b.queryString = qs; return this; }","old_code_raw":"    public AtmosphereRequest queryString(String queryString) {\n\n        if (queryString == null) return this;\n\n        \/\/ Don't override the builder\n        String qs = queryString;\n        if (qs.isEmpty()) {\n            qs = b.queryString;\n        }\n        if (!qs.isEmpty()) {\n            QueryStringDecoder decoder = new QueryStringDecoder(getRequestURI() + \"?\" + qs);\n            Map<String, List<String>> m = decoder.getParameters();\n            Map<String, String[]> newM = new HashMap<String, String[]>();\n            for (Map.Entry<String, List<String>> q : m.entrySet()) {\n                newM.put(q.getKey(), q.getValue().toArray(new String[q.getValue().size()]));\n            }\n            b.queryStrings(newM);\n            b.queryString = qs;\n        }\n        return this;\n    }\n","new_comment_raw":"@param qs","old_comment_raw":"@param queryString","label":1,"pre_label":0,"AST_level":13,"line_counts":17,"new_code_token_num":129},{"new_code_raw":"public static EBoolean endsWith(Expr<String> left, Expr<String> right) { return operationFactory.createBoolean(Ops.ENDSWITH, left, right); }","old_code_raw":"    public static EBoolean endsWith(Expr<String> left, Expr<String> right, boolean caseSensitive) {\n        if (caseSensitive){\n            return endsWith(left, right);            \n        }else{\n            return operationFactory.createBoolean(Ops.ENDSWITH_IC, left, right);\n        }\n    }\n","new_comment_raw":"@param right","old_comment_raw":"@param right","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":27},{"new_code_raw":"public int bind(PreparedStatement statement, QueryParameters qp, SharedSessionContractImplementor session, int position) throws SQLException { Type type = qp.getPositionalParameterTypes()[hqlPosition]; Object value = qp.getPositionalParameterValues()[hqlPosition]; type.nullSafeSet( statement, value, position, session ); return type.getColumnSpan( session.getFactory() ); }","old_code_raw":"\tpublic int bind(PreparedStatement statement, QueryParameters qp, SessionImplementor session, int position) throws SQLException {\n\t\tType type = qp.getPositionalParameterTypes()[hqlPosition];\n\t\tObject value = qp.getPositionalParameterValues()[hqlPosition];\n\n\t\ttype.nullSafeSet( statement, value, position, session );\n\t\treturn type.getColumnSpan( session.getFactory() );\n\t}\n","new_comment_raw":"@param position The position from which to start binding value(s).","old_comment_raw":"@param position The position from which to start binding value(s).","label":0,"pre_label":1,"AST_level":7,"line_counts":8,"new_code_token_num":62},{"new_code_raw":"public Object buildResultRow(Object[] data, ResultSet resultSet, boolean hasTransformer, SharedSessionContractImplementor session) throws SQLException, HibernateException { final Object[] resultRow = buildResultRow( data, resultSet, session ); if ( hasTransformer ) { return resultRow; } else { return resultRow.length == 1 ? resultRow[0] : resultRow; } }","old_code_raw":"\tpublic Object buildResultRow(Object[] data, ResultSet resultSet, boolean hasTransformer, SessionImplementor session)\n\t\t\tthrows SQLException, HibernateException {\n\t\tfinal Object[] resultRow = buildResultRow( data, resultSet, session );\n\t\tif ( hasTransformer ) {\n\t\t\treturn resultRow;\n\t\t}\n\t\telse {\n\t\t\treturn resultRow.length == 1\n\t\t\t\t\t? resultRow[0]\n\t\t\t\t\t: resultRow;\n\t\t}\n\t}\n","new_comment_raw":"@param hasTransformer Does this query have an associated  org.hibernate.transform.ResultTransformer","old_comment_raw":"@param hasTransformer Does this query have an associated org.hibernate.transform.ResultTransformer","label":0,"pre_label":1,"AST_level":9,"line_counts":13,"new_code_token_num":62},{"new_code_raw":"private String terminalToShowWhenClosing(String handle) { int terminalClosing = terminals_.indexOfTerminal(handle); if (terminalClosing > 0) return terminals_.terminalHandleAtIndex(terminalClosing - 1); else if (terminalClosing + 1 < terminals_.terminalCount()) return terminals_.terminalHandleAtIndex(terminalClosing + 1); else return null; }","old_code_raw":"   private int terminalToShowWhenClosing(int terminalClosing)\n   {\n      if (terminalClosing > 0)\n         return terminalClosing - 1;\n      else if (terminalClosing + 1 < getTerminalCount())\n         return terminalClosing + 1;\n      else\n         return -1;\n   }\n","new_comment_raw":"@param handle terminal being closed","old_comment_raw":"@param terminalClosing index of terminal being closed","label":1,"pre_label":0,"AST_level":8,"line_counts":11,"new_code_token_num":55},{"new_code_raw":"private ScanProgressActionIcon getScanProgressAction(Point point) { int column = table.columnAtPoint(point); if (column == NOT_FOUND) { return null; } int row = table.rowAtPoint(point); if (row == NOT_FOUND) { return null; } Object value = table.getValueAt(row, column); if (value instanceof ScanProgressActionIcon) { return (ScanProgressActionIcon)value; } return null; }","old_code_raw":"        private ScanProgressActionIcon getScanProgressAction(MouseEvent e) {\n            TableColumnModel columnModel = table.getColumnModel();\n            int column = columnModel.getColumnIndexAtX(e.getX());\n            int row = e.getY() \/ table.getRowHeight();\n\n            if ((row < table.getRowCount()) && (row >= 0) && \n                (column < table.getColumnCount()) && (column >= 0)) {\n\n                Object value = table.getValueAt(row, column);\n                if (value instanceof ScanProgressActionIcon) {\n                    return (ScanProgressActionIcon)value;\n                }\n            }\n            \n            return null;\n        }        \n","new_comment_raw":"@param point the point to get the scan progress action icon","old_comment_raw":"@param e","label":1,"pre_label":0,"AST_level":7,"line_counts":19,"new_code_token_num":72},{"new_code_raw":"static public IStructuredTextExpert getStatefulExpert(StructuredTextTypeHandler handler, StructuredTextEnvironment environment) { if (environment == null) environment = StructuredTextEnvironment.DEFAULT; return new StructuredTextImpl(handler, environment, true); }","old_code_raw":"\tstatic public ISTextExpert getStatefulExpert(STextTypeHandler handler, STextEnvironment environment) {\n\t\tif (environment == null)\n\t\t\tenvironment = STextEnvironment.DEFAULT;\n\t\treturn new STextImpl(handler, environment, true);\n\t}\n","new_comment_raw":"@param handler the type handler instance. It may have been obtained using  StructuredTextTypeHandlerFactory#getHandler(String) or by instantiating a type handler.","old_comment_raw":"@param handler the type handler instance. It may have been obtained using STextTypeHandlerFactory#getHandler(String) or by instantiating a type handler.","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":33},{"new_code_raw":"public JdbcConnection prepareQuery(String[] multiQuery, StatementPreparer[] preparers, BlockingMultiResultSetConsumer resultConsumer) throws SQLException, InterruptedException { final ResultSet[] resultSets = new ResultSet[multiQuery.length]; final PreparedStatement[] preparedStatements = new PreparedStatement[multiQuery.length]; try { for (int i = 0; i < multiQuery.length; i++) { final String query = multiQuery[i]; if (LOGGER.isTraceEnabled()) { LOGGER.trace(\"running '{}'\", query); } final PreparedStatement statement = createPreparedStatement(query); preparedStatements[i] = statement; preparers[i].accept(statement); resultSets[i] = statement.executeQuery(); } if (resultConsumer != null) { resultConsumer.accept(resultSets); } } finally { for (ResultSet rs: resultSets) { if (rs != null) { try { rs.close(); } catch (Exception ei) { } } } } return this; }","old_code_raw":"    public JdbcConnection prepareQuery(String[] multiQuery, StatementPreparer preparer, BlockingMultiResultSetConsumer resultConsumer) throws SQLException, InterruptedException {\n        final Connection conn = connection();\n        final ResultSet[] resultSets = new ResultSet[multiQuery.length];\n        final PreparedStatement[] preparedStatements = new PreparedStatement[multiQuery.length];\n\n        try {\n            for (int i = 0; i < multiQuery.length; i++) {\n                final String query = multiQuery[i];\n                if (LOGGER.isTraceEnabled()) {\n                    LOGGER.trace(\"running '{}'\", query);\n                }\n                final PreparedStatement statement = createPreparedStatement(query);\n                preparedStatements[i] = statement;\n                preparer.accept(statement);\n                resultSets[i] = statement.executeQuery();\n            }\n            if (resultConsumer != null) {\n                resultConsumer.accept(resultSets);\n            }\n        }\n        finally {\n            for (ResultSet rs: resultSets) {\n                if (rs != null) {\n                    try {\n                        rs.close();\n                    }\n                    catch (Exception ei) {\n                    }\n                }\n            }\n        }\n        return this;\n    }\n","new_comment_raw":"@param resultConsumer the consumer of the query results","old_comment_raw":"@param resultConsumer the consumer of the query results","label":0,"pre_label":1,"AST_level":10,"line_counts":33,"new_code_token_num":181},{"new_code_raw":"public static long toNanoOfDay(Object value, boolean acceptLargeValues) { if (value instanceof Duration) { Duration duration = (Duration) value; if (!acceptLargeValues && (duration.isNegative() || duration.compareTo(ONE_DAY) > 0)) { throw new IllegalArgumentException(\"Time values must be between 00:00:00 and 24:00:00 (inclusive): \" + duration); } return ((Duration) value).toNanos(); } \/\/ TODO only needed for SQL Server\/Oracle, where we don't produce Duration right away; \/\/ this should go eventually, as the conversion to LocalTime is superfluous LocalTime time = Conversions.toLocalTime(value); return time.toNanoOfDay(); }","old_code_raw":"    public static long toNanoOfDay(Object value, TemporalAdjuster adjuster) {\n        LocalTime time = Conversions.toLocalTime(value);\n        if (adjuster !=null) {\n            time = time.with(adjuster);\n        }\n        return time.toNanoOfDay();\n    }\n","new_comment_raw":"@param acceptLargeValues whether to accept values less than 00:00:00 and larger than 24:00:00 or not","old_comment_raw":"@param adjuster the optional component that adjusts the local date value before obtaining the epoch day; may be null if no adjustment is necessary","label":1,"pre_label":0,"AST_level":10,"line_counts":16,"new_code_token_num":141},{"new_code_raw":"public static Point getCanvasSpriteLocation(Client client, Graphics2D graphics, LocalPoint localLocation, SpritePixels sprite, int zOffset) { int plane = client.getPlane(); Point p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset); if (p == null) { return null; } int xOffset = p.getX() - sprite.getWidth() \/ 2; int yOffset = p.getY() - sprite.getHeight() \/ 2; return new Point(xOffset, yOffset); }","old_code_raw":"\tpublic static Point getCanvasSpriteLocation(Client client, Graphics2D graphics, Point localLocation, SpritePixels sprite, int zOffset)\n\t{\n\t\tint plane = client.getPlane();\n\n\t\tPoint p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset);\n\n\t\tif (p == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tint xOffset = p.getX() - sprite.getWidth() \/ 2;\n\t\tint yOffset = p.getY() - sprite.getHeight() \/ 2;\n\n\t\treturn new Point(xOffset, yOffset);\n\t}\n","new_comment_raw":"@param client","old_comment_raw":"@param client","label":0,"pre_label":1,"AST_level":7,"line_counts":17,"new_code_token_num":98},{"new_code_raw":"public Actions sendKeys(CharSequence... keys) { if (isBuildingActions()) { action.addAction(new SendKeysAction(jsonKeyboard, jsonMouse, null, keys)); return this; } for (CharSequence key : keys) { key.codePoints().forEach(codePoint -> { tick(defaultKeyboard.createKeyDown(codePoint)); tick(defaultKeyboard.createKeyUp(codePoint)); }); } return this; }","old_code_raw":"  public Actions sendKeys(CharSequence... keysToSend) {\n    return this.sendKeys(null, keysToSend);\n  }\n","new_comment_raw":"@param keys The keys.","old_comment_raw":"@param keysToSend The keys.","label":1,"pre_label":0,"AST_level":12,"line_counts":16,"new_code_token_num":78},{"new_code_raw":"public Action timedout(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException { logger.trace(\"Timing out {}\", req); if (trackActiveRequest(req) && completeLifecycle(req.resource(), false)) { config.framework().notify(Action.TYPE.TIMEOUT, req, res); } return timedoutAction; }","old_code_raw":"    public Action timedout(AtmosphereRequest request, AtmosphereResponse response)\n            throws IOException, ServletException {\n\n        AtmosphereResourceImpl r = null;\n\n        try {\n            SessionTimeoutSupport.restoreTimeout(request);\n\n            if (trackActiveRequest) {\n                long l = (Long) request.getAttribute(MAX_INACTIVE);\n                if (l == -1) {\n                    \/\/ The closedDetector closed the connection.\n                    return timedoutAction;\n                }\n                request.setAttribute(MAX_INACTIVE, (long) -1);\n            }\n\n            logger.debug(\"Timing out the connection for request {}\", request);\n\n            \/\/ Something went wrong.\n            if (request == null || response == null) {\n                logger.warn(\"Invalid Request\/Response: {}\/{}\", request, response);\n                return timedoutAction;\n            }\n\n            r = (AtmosphereResourceImpl) request.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE);\n\n            if (r != null && r.isCancelled()) {\n                return cancelledAction;\n            }\n\n            if (r == null) {\n                logger.debug(\"AtmosphereResource was null, failed to timeout AtmosphereRequest {}\", request);\n            }\n\n            if (r != null && r.getAtmosphereResourceEvent().isSuspended()) {\n                r.getAtmosphereResourceEvent().setIsResumedOnTimeout(true);\n\n                Broadcaster b = r.getBroadcaster();\n                if (b instanceof DefaultBroadcaster) {\n                    ((DefaultBroadcaster) b).broadcastOnResume(r);\n                }\n\n                if (request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT) != null) {\n                    r.getAtmosphereResourceEvent().setIsResumedOnTimeout(\n                            (Boolean) request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT));\n                }\n\n                invokeAtmosphereHandler(r);\n            }\n        } catch (Throwable t) {\n            logger.error(\"failed to timeout resource {}\", r, t);\n        } finally {\n            config.framework().notify(Action.TYPE.TIMEOUT, request, response);\n            try {\n                if (r != null) {\n                    r.notifyListeners();\n                    r.setIsInScope(false);\n                    r.cancel();\n                }\n            } catch (Throwable t) {\n                logger.trace(\"timedout\", t);\n            } finally {\n                try {\n                    response.getOutputStream().close();\n                } catch (Throwable t) {\n                    try {\n                        response.getWriter().close();\n                    } catch (Throwable t2) {\n                    }\n                }\n\n                if (r != null) {\n                    r._destroy();\n                }\n            }\n        }\n\n        return timedoutAction;\n    }\n","new_comment_raw":"@param req the  AtmosphereRequest","old_comment_raw":"@param request the AtmosphereRequest","label":1,"pre_label":0,"AST_level":8,"line_counts":10,"new_code_token_num":67},{"new_code_raw":"public static UserAuthenticator createAuthenticator(final DrillConfig config, ScanResult scan) throws DrillbitStartupException { final String authImplConfigured = config.getString(USER_AUTHENTICATOR_IMPL); if (Strings.isNullOrEmpty(authImplConfigured)) { throw new DrillbitStartupException(String.format(\"Invalid value '%s' for BOOT option '%s'\", authImplConfigured, USER_AUTHENTICATOR_IMPL)); } final Collection<Class<? extends UserAuthenticator>> authImpls = scan.getImplementations(UserAuthenticator.class); for(Class<? extends UserAuthenticator> clazz : authImpls) { final UserAuthenticatorTemplate template = clazz.getAnnotation(UserAuthenticatorTemplate.class); if (template == null) { logger.warn(\"{} doesn't have {} annotation. Skipping.\", clazz.getCanonicalName(), UserAuthenticatorTemplate.class); continue; } if (Strings.isNullOrEmpty(template.type())) { logger.warn(\"{} annotation doesn't have valid type field for UserAuthenticator implementation {}. Skipping..\", UserAuthenticatorTemplate.class, clazz.getCanonicalName()); continue; } if (template.type().equalsIgnoreCase(authImplConfigured)) { Constructor<?> validConstructor = null; for (Constructor<?> c : clazz.getConstructors()) { if (c.getParameterTypes().length == 0) { validConstructor = c; break; } } if (validConstructor == null) { logger.warn(\"Skipping UserAuthenticator implementation class '{}' since it doesn't \" + \"implement a constructor [{}()]\", clazz.getCanonicalName(), clazz.getName()); continue; } \/\/ Instantiate authenticator and initialize it try { final UserAuthenticator authenticator = clazz.newInstance(); authenticator.setup(config); return authenticator; } catch(IllegalArgumentException | IllegalAccessException | InstantiationException e) { throw new DrillbitStartupException( String.format(\"Failed to create and initialize the UserAuthenticator class '%s'\", clazz.getCanonicalName()), e); } } } String errMsg = String.format(\"Failed to find the implementation of '%s' for type '%s'\", UserAuthenticator.class.getCanonicalName(), authImplConfigured); logger.error(errMsg); throw new DrillbitStartupException(errMsg); }","old_code_raw":"  public static UserAuthenticator createAuthenticator(final DrillConfig config) throws DrillbitStartupException {\n    final String authImplConfigured = config.getString(USER_AUTHENTICATOR_IMPL);\n\n    if (Strings.isNullOrEmpty(authImplConfigured)) {\n      throw new DrillbitStartupException(String.format(\"Invalid value '%s' for BOOT option '%s'\", authImplConfigured,\n          USER_AUTHENTICATOR_IMPL));\n    }\n\n    final Collection<Class<? extends UserAuthenticator>> authImpls =\n        PathScanner.scanForImplementations(UserAuthenticator.class,\n            config.getStringList(ExecConstants.USER_AUTHENTICATOR_IMPL_PACKAGES));\n\n    for(Class<? extends UserAuthenticator> clazz : authImpls) {\n      final UserAuthenticatorTemplate template = clazz.getAnnotation(UserAuthenticatorTemplate.class);\n      if (template == null) {\n        logger.warn(\"{} doesn't have {} annotation. Skipping.\", clazz.getCanonicalName(), UserAuthenticatorTemplate.class);\n        continue;\n      }\n\n      if (Strings.isNullOrEmpty(template.type())) {\n        logger.warn(\"{} annotation doesn't have valid type field for UserAuthenticator implementation {}. Skipping..\",\n            UserAuthenticatorTemplate.class, clazz.getCanonicalName());\n        continue;\n      }\n\n      if (template.type().equalsIgnoreCase(authImplConfigured)) {\n        Constructor<?> validConstructor = null;\n        for (Constructor<?> c : clazz.getConstructors()) {\n          if (c.getParameterTypes().length == 0) {\n            validConstructor = c;\n            break;\n          }\n        }\n\n        if (validConstructor == null) {\n          logger.warn(\"Skipping UserAuthenticator implementation class '{}' since it doesn't \" +\n              \"implement a constructor [{}()]\", clazz.getCanonicalName(), clazz.getName());\n          continue;\n        }\n\n        \/\/ Instantiate authenticator and initialize it\n        try {\n          final UserAuthenticator authenticator = clazz.newInstance();\n          authenticator.setup(config);\n          return authenticator;\n        } catch(IllegalArgumentException | IllegalAccessException | InstantiationException e) {\n          throw new DrillbitStartupException(\n              String.format(\"Failed to create and initialize the UserAuthenticator class '%s'\",\n                  clazz.getCanonicalName()), e);\n        }\n      }\n    }\n\n    String errMsg = String.format(\"Failed to find the implementation of '%s' for type '%s'\",\n        UserAuthenticator.class.getCanonicalName(), authImplConfigured);\n    logger.error(errMsg);\n    throw new DrillbitStartupException(errMsg);\n  }\n","new_comment_raw":"@param config DrillConfig containing BOOT options.","old_comment_raw":"@param config DrillConfig containing BOOT options.","label":0,"pre_label":1,"AST_level":13,"line_counts":58,"new_code_token_num":393},{"new_code_raw":"public static ENumber<Byte> create(byte i){ if (i >= 0 && i < 256){ return bytes[i]; }else{ return new ENumberConst<Byte>(Byte.class, Byte.valueOf(i)); } }","old_code_raw":"    public static ENumber<Integer> create(int i){\n        if (i >= 0 && i < 256){\n            return ints[i];\n        }else{\n            return new ENumberConst<Integer>(Integer.class, Integer.valueOf(i));\n        }\n    }\n","new_comment_raw":"@param val","old_comment_raw":"@param val","label":0,"pre_label":1,"AST_level":9,"line_counts":8,"new_code_token_num":46},{"new_code_raw":"public Collection<Tree> getRelatedNodes(Tree t, Tree root, HeadFinder headFinder) { Set<Tree> nodeList = new ArraySet<Tree>(); for (TregexPattern p : targetPatterns) { \/\/ cdm: I deleted: && nodeList.isEmpty() \/\/ Initialize the TregexMatcher with the HeadFinder so that we \/\/ can use the same HeadFinder through the entire process of \/\/ building the dependencies TregexMatcher m = p.matcher(root, headFinder); while (m.findAt(t)) { nodeList.add(m.getNode(\"target\")); if (DEBUG) { System.err.println(\"found \" + this + \"(\" + t + \", \" + m.getNode(\"target\") + \") using pattern \" + p); for (String nodeName : m.getNodeNames()) { if (nodeName.equals(\"target\")) continue; System.err.println(\" node \" + nodeName + \": \" + m.getNode(nodeName)); } } } } return nodeList; }","old_code_raw":"  public Collection<Tree> getRelatedNodes(Tree t, Tree root) {\n    Set<Tree> nodeList = new ArraySet<Tree>();\n    for (TregexPattern p : targetPatterns) {    \/\/ cdm: I deleted: && nodeList.isEmpty()\n      TregexMatcher m = p.matcher(root);\n      while (m.findAt(t)) {\n        nodeList.add(m.getNode(\"target\"));\n        if (DEBUG) {\n          System.err.println(\"found \" + this + \"(\" + t + \", \" + m.getNode(\"target\") + \") using pattern \" + p);\n          for (String nodeName : m.getNodeNames()) {\n            if (nodeName.equals(\"target\"))\n              continue;\n            System.err.println(\"  node \" + nodeName + \": \" + m.getNode(nodeName));\n          }\n        }\n      }\n    }\n    return nodeList;\n  }\n","new_comment_raw":"@param root The root of the Tree","old_comment_raw":"@param root The root of the Tree","label":0,"pre_label":1,"AST_level":18,"line_counts":22,"new_code_token_num":198},{"new_code_raw":"public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws ApiException { Object localVarPostBody = null; \/\/ verify the required parameter 'petId' is set if (petId == null) { throw new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\"); } \/\/ verify the required parameter 'requiredFile' is set if (requiredFile == null) { throw new ApiException(400, \"Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile\"); } \/\/ create path and map variables String localVarPath = \"\/fake\/{petId}\/uploadImageWithRequiredFile\" .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString())); \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); if (additionalMetadata != null) localVarFormParams.put(\"additionalMetadata\", additionalMetadata); if (requiredFile != null) localVarFormParams.put(\"requiredFile\", requiredFile); final String[] localVarAccepts = { \"application\/json\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { \"multipart\/form-data\" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { \"petstore_auth\" }; GenericType<ModelApiResponse> localVarReturnType = new GenericType<ModelApiResponse>() {}; return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public ModelApiResponse uploadFileWithRequiredFile(Long petId, File file, String additionalMetadata) throws ApiException {\n    Object localVarPostBody = null;\n    \n    \/\/ verify the required parameter 'petId' is set\n    if (petId == null) {\n      throw new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\");\n    }\n    \n    \/\/ verify the required parameter 'file' is set\n    if (file == null) {\n      throw new ApiException(400, \"Missing the required parameter 'file' when calling uploadFileWithRequiredFile\");\n    }\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/fake\/{petId}\/uploadImageWithRequiredFile\"\n      .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString()));\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    if (additionalMetadata != null)\n      localVarFormParams.put(\"additionalMetadata\", additionalMetadata);\nif (file != null)\n      localVarFormParams.put(\"file\", file);\n\n    final String[] localVarAccepts = {\n      \"application\/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"multipart\/form-data\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] { \"petstore_auth\" };\n\n    GenericType<ModelApiResponse> localVarReturnType = new GenericType<ModelApiResponse>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@param petId ID of pet to update (required)","old_comment_raw":"@param petId ID of pet to update (required)","label":0,"pre_label":1,"AST_level":9,"line_counts":46,"new_code_token_num":324},{"new_code_raw":"public PendingMessageCursor getSubscriberPendingMessageCursor(String clientId, String name, Store tmpStorage, int maxBatchSize, Subscription sub) { return new FilePendingMessageCursor(name, tmpStorage); }","old_code_raw":"    public PendingMessageCursor getSubscriberPendingMessageCursor(String clientId, String name, Store tmpStorage, int maxBatchSize) {\n        return new FilePendingMessageCursor(name, tmpStorage);\n    }\n","new_comment_raw":"@param tmpStorage","old_comment_raw":"@param tmpStorage","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":30},{"new_code_raw":"private Connection createConnection(ActiveMQConnectionRequestInfo connectionRequestInfo) throws JMSException { try { if (connectionRequestInfo.isUseInboundSessionEnabled()) { return new InboundConnectionProxy(); } if (manager == null) { throw new JMSException(\"No JCA ConnectionManager configured! Either enable UseInboundSessionEnabled or get your JCA container to configure one.\"); } return (Connection)manager.allocateConnection(factory, connectionRequestInfo); } catch (ResourceException e) { \/\/ Throw the root cause if it was a JMSException.. if (e.getCause() instanceof JMSException) { throw (JMSException)e.getCause(); } LOG.debug(\"Connection could not be created:\", e); throw new JMSException(e.getMessage()); } }","old_code_raw":"    private Connection createConnection(ActiveMQConnectionRequestInfo info) throws JMSException {\n        try {\n            if (info.isUseInboundSessionEnabled()) {\n                return new InboundConnectionProxy();\n            }\n            if (manager == null) {\n                throw new JMSException(\"No JCA ConnectionManager configured! Either enable UseInboundSessionEnabled or get your JCA container to configure one.\");\n            }\n            return (Connection)manager.allocateConnection(factory, info);\n        } catch (ResourceException e) {\n            \/\/ Throw the root cause if it was a JMSException..\n            if (e.getCause() instanceof JMSException) {\n                throw (JMSException)e.getCause();\n            }\n            LOG.debug(\"Connection could not be created:\", e);\n            throw new JMSException(e.getMessage());\n        }\n    }\n","new_comment_raw":"@param connectionRequestInfo","old_comment_raw":"@param info","label":1,"pre_label":0,"AST_level":9,"line_counts":19,"new_code_token_num":135},{"new_code_raw":"public Response getApplication(@PathParam(\"version\") String version, @HeaderParam(\"Accept\") final String acceptHeader, @HeaderParam(EurekaAccept.HTTP_X_EUREKA_ACCEPT) String eurekaAccept) { if (!registry.shouldAllowAccess(false)) { return Response.status(Status.FORBIDDEN).build(); } EurekaMonitors.GET_APPLICATION.increment(); CurrentRequestVersion.set(Version.toEnum(version)); KeyType keyType = KeyType.JSON; if (acceptHeader == null || !acceptHeader.contains(\"json\")) { keyType = KeyType.XML; } Key cacheKey = new Key( Key.EntityType.Application, appName, keyType, CurrentRequestVersion.get(), EurekaAccept.fromString(eurekaAccept) ); String payLoad = responseCache.get(cacheKey); if (payLoad != null) { logger.debug(\"Found: {}\", appName); return Response.ok(payLoad).build(); } else { logger.debug(\"Not Found: {}\", appName); return Response.status(Status.NOT_FOUND).build(); } }","old_code_raw":"    public Response getApplication(@PathParam(\"version\") String version,\n                                   @HeaderParam(\"Accept\") final String acceptHeader) {\n        if (!PeerAwareInstanceRegistryImpl.getInstance().shouldAllowAccess(false)) {\n            return Response.status(Status.FORBIDDEN).build();\n        }\n\n        EurekaMonitors.GET_APPLICATION.increment();\n\n        CurrentRequestVersion.set(Version.toEnum(version));\n        KeyType keyType = KeyType.JSON;\n        if (acceptHeader == null || !acceptHeader.contains(\"json\")) {\n            keyType = KeyType.XML;\n        }\n\n        Key cacheKey = new Key(Key.EntityType.Application, appName, keyType, CurrentRequestVersion.get());\n\n        String payLoad = ResponseCache.getInstance().get(cacheKey);\n\n        if (payLoad != null) {\n            logger.debug(\"Found: {}\", appName);\n            return Response.ok(payLoad).build();\n        } else {\n            logger.debug(\"Not Found: {}\", appName);\n            return Response.status(Status.NOT_FOUND).build();\n        }\n    }\n","new_comment_raw":"@param acceptHeader the accept header of the request to indicate whether to serve JSON or XML data.","old_comment_raw":"@param acceptHeader the accept header of the request to indicate whether to serve JSON or XML data.","label":0,"pre_label":1,"AST_level":7,"line_counts":34,"new_code_token_num":192},{"new_code_raw":"public List<TypedDependency> typedDependenciesCCprocessed(boolean includeExtras) { List<TypedDependency> tdl = typedDependencies(false); \/\/ Adds stuff to the basic dependencies. \/\/ We don't want to simply call typedDependencies with \/\/ \"includeExtras\" because the collapseDependencies method may add \/\/ the extras in a way that makes more logical sense. For \/\/ example, the English dependencies, when CC processed, have more \/\/ nsubjs than they originally do. If we wait until that occurs \/\/ to add xsubj for xcomp dependencies, we get better coverage. if (includeExtras) { getTreeDeps(root(), tdl, new NoPunctTypedDependencyFilter(puncFilter)); } collapseDependencies(tdl, true, includeExtras); return tdl; }","old_code_raw":"  public List<TypedDependency> typedDependenciesCCprocessed(Extras includeExtras) {\n    List<TypedDependency> tdl = typedDependencies(includeExtras);\n    collapseDependencies(tdl, true, includeExtras);\n    return tdl;\n  }\n","new_comment_raw":"@param includeExtras If true, the list of typed dependencies returned may include \"extras\", such as controlled subject links.","old_comment_raw":"@param includeExtras If true, the list of typed dependencies returned may include \"extras\", such as controlled subject links.","label":0,"pre_label":1,"AST_level":8,"line_counts":16,"new_code_token_num":135},{"new_code_raw":"public PendingMessageCursor getSubscriberPendingMessageCursor(String clientId, String name, Store tmpStorage, int maxBatchSize, Subscription sub) { return new VMPendingMessageCursor(); }","old_code_raw":"    public PendingMessageCursor getSubscriberPendingMessageCursor(String clientId, String name, Store tmpStorage, int maxBatchSize) {\n        return new VMPendingMessageCursor();\n    }\n","new_comment_raw":"@param maxBatchSize","old_comment_raw":"@param maxBatchSize","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":27},{"new_code_raw":"public Timer getTimer(TimerDesc timerDesc) { return getTimer(timerDesc.getName(), timerDesc.getDurationUnit(), timerDesc.getTimeUnit()); }","old_code_raw":"  public Timer getTimer(String name) {\n    return getTimer(name, TimeUnit.MILLISECONDS, TimeUnit.SECONDS);\n  }\n","new_comment_raw":"@param timerDesc TimerDesc describing the timer","old_comment_raw":"@param name the name of the metric","label":1,"pre_label":0,"AST_level":5,"line_counts":6,"new_code_token_num":28},{"new_code_raw":"public WebElement searchForWebElement(final By by, int minimumNumberOfMatches, int timeout, boolean scroll){ if(minimumNumberOfMatches < 1){ minimumNumberOfMatches = 1; } List<WebElement> viewsFromScreen = webUtils.getCurrentWebElements(by); addViewsToList (webElements, viewsFromScreen); return getViewFromList(webElements, minimumNumberOfMatches); }","old_code_raw":"\tpublic WebElement searchForWebElement(final By by, int match, int timeout, boolean scroll){\n\n\t\tif(match < 1){\n\t\t\tmatch = 1;\n\t\t}\n\n\t\tList<WebElement> viewsFromScreen = webUtils.getCurrentWebElements(by);\n\t\taddViewsToList (webElements, viewsFromScreen);\n\n\t\treturn getViewFromList(webElements, match);\n\t}\n","new_comment_raw":"@param scroll true if scrolling should be performed","old_comment_raw":"@param scroll true if scrolling should be performed","label":0,"pre_label":1,"AST_level":7,"line_counts":12,"new_code_token_num":53},{"new_code_raw":"public boolean isASGEnabled(InstanceInfo instanceInfo) { CacheKey cacheKey = new CacheKey(getAccountId(instanceInfo, accountId), instanceInfo.getASGName()); asgCache.refresh(cacheKey); Boolean result = asgCache.getIfPresent(cacheKey); if (result != null) { return result; } else { logger.warn(\"Cache value for asg {} does not exist yet\", cacheKey.asgName); return true; } }","old_code_raw":"    public boolean isASGEnabled(String asgName) {\n        try {\n            return asgCache.get(asgName);\n        } catch (ExecutionException e) {\n            logger.error(\"Error getting cache value for asg : \" + asgName, e);\n        }\n        return true;\n    }\n","new_comment_raw":"@param instanceInfo the instanceInfo for the lookup","old_comment_raw":"@param asgName - The name of the ASG","label":1,"pre_label":0,"AST_level":7,"line_counts":12,"new_code_token_num":78},{"new_code_raw":"public boolean searchButton(String text, boolean onlyVisible) { boolean found = searcher.searchWithTimeoutFor(Button.class, text, 0, true, onlyVisible); return found; }","old_code_raw":"\tpublic boolean searchButton(String text, boolean visible) {\n\t\tboolean found = searcher.searchWithTimeoutFor(Button.class, text, 0, true, visible);\n\t\treturn found;\n\t}\n","new_comment_raw":"@param onlyVisible  true if only  Buttons visible on the screen should be searched","old_comment_raw":"@param visible true if only Buttons visible on the screen should be searched","label":1,"pre_label":0,"AST_level":7,"line_counts":5,"new_code_token_num":32},{"new_code_raw":"public boolean applyAPSRequest(APSResult request, Callback callback) { PumpInterface pump = getActivePump(); request.rate = applyBasalConstraints(request.rate); PumpEnactResult result; if (!pump.isInitialized()) { log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpNotInitialized)); if (callback != null) { callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpNotInitialized)).enacted(false).success(false)).run(); } return false; } if (pump.isSuspended()) { log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpsuspended)); if (callback != null) { callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpsuspended)).enacted(false).success(false)).run(); } return false; } if (Config.logCongigBuilderActions) log.debug(\"applyAPSRequest: \" + request.toString()); if ((request.rate == 0 && request.duration == 0) || Math.abs(request.rate - pump.getBaseBasalRate()) < pump.getPumpDescription().basalStep) { if (isTempBasalInProgress()) { if (Config.logCongigBuilderActions) log.debug(\"applyAPSRequest: cancelTempBasal()\"); getCommandQueue().cancelTempBasal(false, callback); return true; } else { if (Config.logCongigBuilderActions) log.debug(\"applyAPSRequest: Basal set correctly\"); if (callback != null) { callback.result(new PumpEnactResult().absolute(request.rate).duration(0).enacted(false).success(true).comment(\"Basal set correctly\")).run(); } return false; } } else if (isTempBasalInProgress() && Math.abs(request.rate - getTempBasalAbsoluteRateHistory()) < pump.getPumpDescription().basalStep) { if (Config.logCongigBuilderActions) log.debug(\"applyAPSRequest: Temp basal set correctly\"); if (callback != null) { callback.result(new PumpEnactResult().absolute(getTempBasalAbsoluteRateHistory()).duration(getTempBasalFromHistory(System.currentTimeMillis()).getPlannedRemainingMinutes()).enacted(false).success(true).comment(\"Temp basal set correctly\")).run(); } return false; } else { if (Config.logCongigBuilderActions) log.debug(\"applyAPSRequest: setTempBasalAbsolute()\"); getCommandQueue().tempBasalAbsolute(request.rate, request.duration, false, callback); return true; } }","old_code_raw":"    public PumpEnactResult applyAPSRequest(APSResult request) {\n        request.rate = applyBasalConstraints(request.rate);\n        PumpEnactResult result;\n\n        if (!isInitialized()) {\n            result = new PumpEnactResult();\n            result.comment = MainApp.sResources.getString(R.string.pumpNotInitialized);\n            result.enacted = false;\n            result.success = false;\n            log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpNotInitialized));\n            return result;\n        }\n\n        if (isSuspended()) {\n            result = new PumpEnactResult();\n            result.comment = MainApp.sResources.getString(R.string.pumpsuspended);\n            result.enacted = false;\n            result.success = false;\n            log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpsuspended));\n            return result;\n        }\n\n        if (Config.logCongigBuilderActions)\n            log.debug(\"applyAPSRequest: \" + request.toString());\n        if ((request.rate == 0 && request.duration == 0) || Math.abs(request.rate - getBaseBasalRate()) < getPumpDescription().basalStep) {\n            if (isTempBasalInProgress()) {\n                if (Config.logCongigBuilderActions)\n                    log.debug(\"applyAPSRequest: cancelTempBasal()\");\n                result = cancelTempBasal(false);\n            } else {\n                result = new PumpEnactResult();\n                result.absolute = request.rate;\n                result.duration = 0;\n                result.enacted = false;\n                result.comment = \"Basal set correctly\";\n                result.success = true;\n                if (Config.logCongigBuilderActions)\n                    log.debug(\"applyAPSRequest: Basal set correctly\");\n            }\n        } else if (isTempBasalInProgress()\n                && getTempBasalRemainingMinutesFromHistory() > 5\n                && Math.abs(request.rate - getTempBasalAbsoluteRateHistory()) < getPumpDescription().basalStep) {\n            result = new PumpEnactResult();\n            result.absolute = getTempBasalAbsoluteRateHistory();\n            result.duration = getTempBasalFromHistory(System.currentTimeMillis()).getPlannedRemainingMinutes();\n            result.enacted = false;\n            result.comment = \"Temp basal set correctly\";\n            result.success = true;\n            if (Config.logCongigBuilderActions)\n                log.debug(\"applyAPSRequest: Temp basal set correctly\");\n        } else {\n            if (Config.logCongigBuilderActions)\n                log.debug(\"applyAPSRequest: setTempBasalAbsolute()\");\n            result = setTempBasalAbsolute(request.rate, request.duration);\n        }\n        return result;\n    }\n","new_comment_raw":"@param request","old_comment_raw":"@param request","label":0,"pre_label":1,"AST_level":13,"line_counts":52,"new_code_token_num":468},{"new_code_raw":"public int compareTo(ReadablePartial partial) { if (partial == null) { throw new IllegalArgumentException(\"The instant must not be null\"); } int thisValue = get(); int otherValue = partial.get(getFieldType()); if (thisValue < otherValue) { return -1; } else if (thisValue > otherValue) { return 1; } else { return 0; } }","old_code_raw":"    public int compareTo(ReadablePartial instant) {\n        if (instant == null) {\n            throw new IllegalArgumentException(\"The instant must not be null\");\n        }\n        int thisValue = get();\n        int otherValue = instant.get(getField());\n        if (thisValue < otherValue) {\n            return -1;\n        } else if (thisValue > otherValue) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n","new_comment_raw":"@param partial the partial to compare to","old_comment_raw":"@param instant the instant to compare to","label":1,"pre_label":0,"AST_level":7,"line_counts":15,"new_code_token_num":74},{"new_code_raw":"public Call testEndpointParametersAsync(BigDecimal number, Double _double, String string, byte[] _byte, Integer integer, Integer int32, Long int64, Float _float, byte[] binary, Date date, Date dateTime, String password, final ApiCallback<Void> callback) throws ApiException { ProgressResponseBody.ProgressListener progressListener = null; ProgressRequestBody.ProgressRequestListener progressRequestListener = null; if (callback != null) { progressListener = new ProgressResponseBody.ProgressListener() { @Override public void update(long bytesRead, long contentLength, boolean done) { callback.onDownloadProgress(bytesRead, contentLength, done); } }; progressRequestListener = new ProgressRequestBody.ProgressRequestListener() { @Override public void onRequestProgress(long bytesWritten, long contentLength, boolean done) { callback.onUploadProgress(bytesWritten, contentLength, done); } }; } Call call = testEndpointParametersCall(number, _double, string, _byte, integer, int32, int64, _float, binary, date, dateTime, password, progressListener, progressRequestListener); apiClient.executeAsync(call, callback); return call; }","old_code_raw":"  public Call testEndpointParametersAsync(String number, Double _double, String string, byte[] _byte, Integer integer, Integer int32, Long int64, Float _float, byte[] binary, Date date, Date dateTime, String password, final ApiCallback<Void> callback) throws ApiException {\n\n    ProgressResponseBody.ProgressListener progressListener = null;\n    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n    if (callback != null) {\n      progressListener = new ProgressResponseBody.ProgressListener() {\n        @Override\n        public void update(long bytesRead, long contentLength, boolean done) {\n          callback.onDownloadProgress(bytesRead, contentLength, done);\n        }\n      };\n\n      progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {\n        @Override\n        public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {\n          callback.onUploadProgress(bytesWritten, contentLength, done);\n        }\n      };\n    }\n\n    Call call = testEndpointParametersCall(number, _double, string, _byte, integer, int32, int64, _float, binary, date, dateTime, password, progressListener, progressRequestListener);\n    apiClient.executeAsync(call, callback);\n    return call;\n  }\n","new_comment_raw":"@param _float None (optional)","old_comment_raw":"@param _float None (optional)","label":0,"pre_label":1,"AST_level":11,"line_counts":26,"new_code_token_num":187},{"new_code_raw":"public static GrammaticalRelation valueOf(String s, Collection<GrammaticalRelation> values) { for (GrammaticalRelation reln : values) { if (reln.toString().equals(s)) return reln; } return null; }","old_code_raw":"  public static GrammaticalRelation valueOf(String s, Map<String, GrammaticalRelation> map) {\n    if (map.containsKey(s)) {\n      return map.get(s);\n    }\n    return null;\n  }\n","new_comment_raw":"@param values The set of GrammaticalRelations to look for it among.","old_comment_raw":"@param map The map from string to GrammaticalRelation","label":1,"pre_label":0,"AST_level":8,"line_counts":8,"new_code_token_num":40},{"new_code_raw":"public Emitter emit(final String event, final Object... args) { EventThread.exec(new Runnable() { @Override public void run() { if (events.containsKey(event)) { Socket.super.emit(event, args); return; } List<Object> _args = new ArrayList<Object>(args.length + 1); _args.add(event); _args.addAll(Arrays.asList(args)); JSONArray jsonArgs = new JSONArray(_args); int parserType = Parser.EVENT; if (HasBinaryData.hasBinary(jsonArgs)) { parserType = Parser.BINARY_EVENT; } Packet packet = new Packet(parserType, jsonArgs); if (_args.get(_args.size() - 1) instanceof Ack) { logger.fine(String.format(\"emitting packet with ack id %d\", Socket.this.ids)); Socket.this.acks.put(Socket.this.ids, (Ack)_args.remove(_args.size() - 1)); packet.id = Socket.this.ids++; } Socket.this.packet(packet); } }); return this; }","old_code_raw":"    public Emitter emit(final String event, final Object... arguments) {\n        EventThread.exec(new Runnable() {\n            @Override\n            public void run() {\n                if (events.containsKey(event)) {\n                    Socket.super.emit(event, arguments);\n                    return;\n                }\n\n                List<Object> args = new ArrayList<Object>(arguments.length + 1);\n                args.add(event);\n                args.addAll(Arrays.asList(arguments));\n                JSONArray _args = new JSONArray(args);\n                int parserType = Parser.EVENT;\n                if (HasBinaryData.hasBinary(_args)) { parserType = Parser.BINARY_EVENT; }\n                Packet packet = new Packet(parserType, _args);\n\n                if (args.get(args.size() - 1) instanceof Ack) {\n                    logger.fine(String.format(\"emitting packet with ack id %d\", Socket.this.ids));\n                    Socket.this.acks.put(Socket.this.ids, (Ack)args.remove(args.size() - 1));\n                    packet.id = Socket.this.ids++;\n                }\n\n                Socket.this.packet(packet);\n            }\n        });\n        return this;\n    }\n","new_comment_raw":"@param event an event name.","old_comment_raw":"@param event an event name.","label":0,"pre_label":1,"AST_level":15,"line_counts":29,"new_code_token_num":202},{"new_code_raw":"public static boolean canEdit(Permissions perms, Permissions user2Perms) { if(isAdmin(perms)) return true; if(isAdmin(user2Perms)) return false; return getManagementLevel(perms) > getManagementLevel(user2Perms); }","old_code_raw":"\tpublic static boolean canEdit(User manager, User toEdit)\r\n\t{\r\n\t\tif(isAdmin(manager))\r\n\t\t\treturn true;\r\n\t\tif(isAdmin(toEdit))\r\n\t\t\treturn false;\r\n\r\n\t\treturn getManagementLevel(manager) > getManagementLevel(toEdit);\r\n\t}\r\n","new_comment_raw":"@param user2Perms The permissions of the user to be edited","old_comment_raw":"@param toEdit The user to be edited","label":1,"pre_label":0,"AST_level":6,"line_counts":11,"new_code_token_num":43},{"new_code_raw":"public Order getOrderById(String orderId) throws ApiException { Object localVarPostBody = null; \/\/ verify the required parameter 'orderId' is set if (orderId == null) { throw new ApiException(400, \"Missing the required parameter 'orderId' when calling getOrderById\"); } \/\/ create path and map variables String localVarPath = \"\/store\/order\/{orderId}\".replaceAll(\"\\\\{format\\\\}\",\"json\") .replaceAll(\"\\\\{\" + \"orderId\" + \"\\\\}\", apiClient.escapeString(orderId.toString())); \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { \"application\/json\", \"application\/xml\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { \"test_api_key_query\", \"test_api_key_header\" }; GenericType<Order> localVarReturnType = new GenericType<Order>() {}; return apiClient.invokeAPI(localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public Order getOrderById(Long orderId) throws ApiException {\n    Object localVarPostBody = null;\n    \n    \/\/ verify the required parameter 'orderId' is set\n    if (orderId == null) {\n      throw new ApiException(400, \"Missing the required parameter 'orderId' when calling getOrderById\");\n    }\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/store\/order\/{orderId}\".replaceAll(\"\\\\{format\\\\}\",\"json\")\n      .replaceAll(\"\\\\{\" + \"orderId\" + \"\\\\}\", apiClient.escapeString(orderId.toString()));\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application\/xml\", \"application\/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Order> localVarReturnType = new GenericType<Order>() {};\n    return apiClient.invokeAPI(localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@param orderId ID of pet that needs to be fetched (required)","old_comment_raw":"@param orderId ID of pet that needs to be fetched (required)","label":0,"pre_label":1,"AST_level":9,"line_counts":41,"new_code_token_num":256},{"new_code_raw":"public List<String> generateCreationCommands(Metadata metadata, boolean createNamespaces, Dialect dialect) { final ArrayList<String> commands = new ArrayList<String>(); doCreation( metadata, createNamespaces, dialect, new Target() { @Override public boolean acceptsImportScriptActions() { return true; } @Override public void prepare() { } @Override public void accept(String action) { commands.add( action ); } @Override public void release() { } } ); return commands; }","old_code_raw":"\tpublic List<String> generateCreationCommands(Metadata metadata, boolean createSchemas, Dialect dialect) {\n\t\tfinal ArrayList<String> commands = new ArrayList<String>();\n\t\tdoCreation(\n\t\t\t\tmetadata,\n\t\t\t\tcreateSchemas,\n\t\t\t\tdialect,\n\t\t\t\tnew Target() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean acceptsImportScriptActions() {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void prepare() {\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void accept(String action) {\n\t\t\t\t\t\tcommands.add( action );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void release() {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\treturn commands;\n\t}\n","new_comment_raw":"@param dialect Allow explicitly passing the Dialect to use.","old_comment_raw":"@param dialect Allow explicitly passing the Dialect to use.","label":0,"pre_label":1,"AST_level":9,"line_counts":30,"new_code_token_num":92},{"new_code_raw":"protected void coordinateSharedCacheCleanup(SharedSessionContractImplementor session) { final BulkOperationCleanupAction action = new BulkOperationCleanupAction( session, getCustomQuery().getQuerySpaces() ); if ( session.isEventSource() ) { ( (EventSource) session ).getActionQueue().addAction( action ); } else { action.getAfterTransactionCompletionProcess().doAfterTransactionCompletion( true, session ); } }","old_code_raw":"\tprotected void coordinateSharedCacheCleanup(SessionImplementor session) {\n\t\tfinal BulkOperationCleanupAction action = new BulkOperationCleanupAction( session, getCustomQuery().getQuerySpaces() );\n\n\t\tif ( session.isEventSource() ) {\n\t\t\t( (EventSource) session ).getActionQueue().addAction( action );\n\t\t}\n\t\telse {\n\t\t\taction.getAfterTransactionCompletionProcess().doAfterTransactionCompletion( true, session );\n\t\t}\n\t}\n","new_comment_raw":"@param ps The prepared statement to which to bind the parameter values.","old_comment_raw":"@param ps The prepared statement to which to bind the parameter values.","label":0,"pre_label":1,"AST_level":8,"line_counts":11,"new_code_token_num":62},{"new_code_raw":"public static SemanticGraph parseTree(JsonReader json, List<CoreLabel> tokens) { SemanticGraph tree = new SemanticGraph(); JsonArray array = json.readArray(); if (array == null || array.isEmpty()) { return tree; } IndexedWord[] vertices = new IndexedWord[tokens.size() + 2]; \/\/ Add edges for(int i = 0; i < array.size(); i++) { JsonObject entry = array.getJsonObject(i); \/\/ Parse row int dependentIndex = entry.getInt(\"dependent\"); if (vertices[dependentIndex] == null) { if (dependentIndex > tokens.size()) { \/\/ Bizarre mismatch in sizes; the malt parser seems to do this often return new SemanticGraph(); } vertices[dependentIndex] = new IndexedWord(tokens.get(dependentIndex - 1)); } IndexedWord dependent = vertices[dependentIndex]; int governorIndex = entry.getInt(\"governor\"); if (governorIndex > tokens.size()) { \/\/ Bizarre mismatch in sizes; the malt parser seems to do this often return new SemanticGraph(); } if (vertices[governorIndex] == null && governorIndex > 0) { vertices[governorIndex] = new IndexedWord(tokens.get(governorIndex - 1)); } IndexedWord governor = vertices[governorIndex]; String relation = entry.getString(\"dep\"); \/\/ Process row if (governorIndex == 0) { tree.addRoot(dependent); } else { tree.addVertex(dependent); if (!tree.containsVertex(governor)) { tree.addVertex(governor); } if (!\"ref\".equals(relation)) { tree.addEdge(governor, dependent, GrammaticalRelation.valueOf(Language.English, relation), Double.NEGATIVE_INFINITY, false); } } } return tree; }","old_code_raw":"  public static SemanticGraph parseTree(String conll, List<CoreLabel> tokens) {\n    SemanticGraph tree = new SemanticGraph();\n    if (conll == null || conll.isEmpty()) {\n      return tree;\n    }\n    String[] treeLines = newline.split(conll);\n    IndexedWord[] vertices = new IndexedWord[tokens.size() + 2];\n    \/\/ Add edges\n    for (String line : treeLines) {\n      \/\/ Parse row\n      String[] fields = tab.split(line);\n      int dependentIndex = Integer.parseInt(fields[0]);\n      if (vertices[dependentIndex] == null) {\n        if (dependentIndex > tokens.size()) {\n          \/\/ Bizarre mismatch in sizes; the malt parser seems to do this often\n          return new SemanticGraph();\n        }\n        vertices[dependentIndex] = new IndexedWord(tokens.get(dependentIndex - 1));\n      }\n      IndexedWord dependent = vertices[dependentIndex];\n      int governorIndex = Integer.parseInt(fields[1]);\n      if (governorIndex > tokens.size()) {\n        \/\/ Bizarre mismatch in sizes; the malt parser seems to do this often\n        return new SemanticGraph();\n      }\n      if (vertices[governorIndex] == null && governorIndex > 0) {\n        vertices[governorIndex] = new IndexedWord(tokens.get(governorIndex - 1));\n      }\n      IndexedWord governor = vertices[governorIndex];\n      String relation = fields[2];\n\n      \/\/ Process row\n      if (governorIndex == 0) {\n        tree.addRoot(dependent);\n      } else {\n        tree.addVertex(dependent);\n        if (!tree.containsVertex(governor)) {\n          tree.addVertex(governor);\n        }\n        if (!\"ref\".equals(relation)) {\n          tree.addEdge(governor, dependent, GrammaticalRelation.valueOf(Language.English, relation), Double.NEGATIVE_INFINITY, false);\n        }\n      }\n    }\n    return tree;\n  }\n","new_comment_raw":"@param tokens The tokens of the sentence, to form the backing labels of the tree.","old_comment_raw":"@param tokens The tokens of the sentence, to form the backing labels of the tree.","label":0,"pre_label":1,"AST_level":12,"line_counts":49,"new_code_token_num":336},{"new_code_raw":"public TemplateExpressionImpl(Class<? extends T> type, Template template, Object... args){ this(type, template, Arrays.<Object>asList(args)); }","old_code_raw":"    public TemplateExpressionImpl(Class<? extends T> type, Template template, Expression<?>... args){\n        this(type, template, Arrays.<Expression<?>>asList(args));\n    }    \n","new_comment_raw":"@param template","old_comment_raw":"@param template","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":31},{"new_code_raw":"public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws RestClientException { Object postBody = new Object(); \/\/ verify the required parameter 'petId' is set if (petId == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\"); } \/\/ verify the required parameter 'requiredFile' is set if (requiredFile == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile\"); } \/\/ create path and map variables final Map<String, Object> uriVariables = new HashMap<String, Object>(); uriVariables.put(\"petId\", petId); String path = UriComponentsBuilder.fromPath(\"\/fake\/{petId}\/uploadImageWithRequiredFile\").buildAndExpand(uriVariables).toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); if (additionalMetadata != null) formParams.add(\"additionalMetadata\", additionalMetadata); if (requiredFile != null) formParams.add(\"requiredFile\", new FileSystemResource(requiredFile)); final String[] accepts = { \"application\/json\" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { \"multipart\/form-data\" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { \"petstore_auth\" }; ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {}; return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }","old_code_raw":"    public ModelApiResponse uploadFileWithRequiredFile(Long petId, File file, String additionalMetadata) throws RestClientException {\n        Object postBody = new Object();\n        \n        \/\/ verify the required parameter 'petId' is set\n        if (petId == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\");\n        }\n        \n        \/\/ verify the required parameter 'file' is set\n        if (file == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'file' when calling uploadFileWithRequiredFile\");\n        }\n        \n        \/\/ create path and map variables\n        final Map<String, Object> uriVariables = new HashMap<String, Object>();\n        uriVariables.put(\"petId\", petId);\n        String path = UriComponentsBuilder.fromPath(\"\/fake\/{petId}\/uploadImageWithRequiredFile\").buildAndExpand(uriVariables).toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n        \n        if (additionalMetadata != null)\n            formParams.add(\"additionalMetadata\", additionalMetadata);\n        if (file != null)\n            formParams.add(\"file\", new FileSystemResource(file));\n\n        final String[] accepts = { \n            \"application\/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"multipart\/form-data\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] { \"petstore_auth\" };\n\n        ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n","new_comment_raw":"@param petId ID of pet to update","old_comment_raw":"@param petId ID of pet to update","label":0,"pre_label":1,"AST_level":8,"line_counts":42,"new_code_token_num":327},{"new_code_raw":"public String toExampleValue(Schema schema) { if (schema.getExample() != null) { return schema.getExample().toString(); } if (ModelUtils.isBooleanSchema(schema)) { return \"null\"; } else if (ModelUtils.isDateSchema(schema)) { return \"null\"; } else if (ModelUtils.isDateTimeSchema(schema)) { return \"null\"; } else if (ModelUtils.isNumberSchema(schema)) { return \"null\"; } else if (ModelUtils.isIntegerSchema(schema)) { return \"null\"; } else if (ModelUtils.isStringSchema(schema)) { return \"null\"; } else if (ModelUtils.isObjectSchema(schema)) { return \"null\"; } else { return \"null\"; } }","old_code_raw":"    public String toExampleValue(Property p) {\n        if(p.getExample() != null) {\n            return p.getExample().toString();\n        }\n        if (p instanceof StringProperty) {\n            return \"null\";\n        } else if (p instanceof BooleanProperty) {\n            return \"null\";\n        } else if (p instanceof DateProperty) {\n            return \"null\";\n        } else if (p instanceof DateTimeProperty) {\n            return \"null\";\n        } else if (p instanceof DoubleProperty) {\n            DoubleProperty dp = (DoubleProperty) p;\n            if (dp.getExample() != null) {\n                return dp.getExample().toString();\n            }\n            return \"null\";\n        } else if (p instanceof FloatProperty) {\n            FloatProperty dp = (FloatProperty) p;\n            if (dp.getExample() != null) {\n                return dp.getExample().toString();\n            }\n            return \"null\";\n        } else if (p instanceof IntegerProperty) {\n            IntegerProperty dp = (IntegerProperty) p;\n            if (dp.getExample() != null) {\n                return dp.getExample().toString();\n            }\n            return \"null\";\n        } else if (p instanceof LongProperty) {\n            LongProperty dp = (LongProperty) p;\n            if (dp.getExample() != null) {\n                return dp.getExample().toString();\n            }\n            return \"null\";\n        } else {\n            return \"null\";\n        }\n    }\n","new_comment_raw":"@param schema Property schema","old_comment_raw":"@param p Swagger property object","label":1,"pre_label":0,"AST_level":12,"line_counts":24,"new_code_token_num":148},{"new_code_raw":"public List<String> get(Path key) { Integer index = keyToIndexMapper.get(key); if (index == null) { return Collections.emptyList(); } return partitionValues.get(index); }","old_code_raw":"  public List<String> get(String key) {\n    Integer index = keyToIndexMapper.get(key);\n    if (index == null) {\n      return Collections.emptyList();\n    }\n    return partitionValues.get(index);\n  }\n","new_comment_raw":"@param key mapper key","old_comment_raw":"@param key mapper key","label":0,"pre_label":1,"AST_level":6,"line_counts":8,"new_code_token_num":38},{"new_code_raw":"protected FieldValueInfo completeField(ExecutionContext executionContext, ExecutionStrategyParameters parameters, FetchedValue fetchedValue) { Field field = parameters.getField().getSingleField(); GraphQLObjectType parentType = (GraphQLObjectType) parameters.getExecutionStepInfo().getUnwrappedNonNullType(); GraphQLFieldDefinition fieldDef = getFieldDef(executionContext.getGraphQLSchema(), parentType, field); ExecutionStepInfo executionStepInfo = createExecutionStepInfo(executionContext, parameters, fieldDef); Instrumentation instrumentation = executionContext.getInstrumentation(); InstrumentationFieldCompleteParameters instrumentationParams = new InstrumentationFieldCompleteParameters(executionContext, parameters, fieldDef, executionStepInfo, fetchedValue); InstrumentationContext<ExecutionResult> ctxCompleteField = instrumentation.beginFieldComplete( instrumentationParams ); GraphQLCodeRegistry codeRegistry = executionContext.getGraphQLSchema().getCodeRegistry(); Map<String, Object> argumentValues = valuesResolver.getArgumentValues(codeRegistry, fieldDef.getArguments(), field.getArguments(), executionContext.getVariables()); NonNullableFieldValidator nonNullableFieldValidator = new NonNullableFieldValidator(executionContext, executionStepInfo); ExecutionStrategyParameters newParameters = parameters.transform(builder -> builder.executionStepInfo(executionStepInfo) .arguments(argumentValues) .source(fetchedValue.getFetchedValue()) .localContext(fetchedValue.getLocalContext()) .nonNullFieldValidator(nonNullableFieldValidator) ); log.debug(\"'{}' completing field '{}'...\", executionContext.getExecutionId(), executionStepInfo.getPath()); FieldValueInfo fieldValueInfo = completeValue(executionContext, newParameters); CompletableFuture<ExecutionResult> executionResultFuture = fieldValueInfo.getFieldValue(); ctxCompleteField.onDispatched(executionResultFuture); executionResultFuture.whenComplete(ctxCompleteField::onCompleted); return fieldValueInfo; }","old_code_raw":"    protected FieldValueInfo completeField(ExecutionContext executionContext, ExecutionStrategyParameters parameters, Object fetchedValue) {\n        Field field = parameters.getField().getSingleField();\n        GraphQLObjectType parentType = (GraphQLObjectType) parameters.getExecutionStepInfo().getUnwrappedNonNullType();\n        GraphQLFieldDefinition fieldDef = getFieldDef(executionContext.getGraphQLSchema(), parentType, field);\n        ExecutionStepInfo executionStepInfo = createExecutionStepInfo(executionContext, parameters, fieldDef);\n\n        Instrumentation instrumentation = executionContext.getInstrumentation();\n        InstrumentationFieldCompleteParameters instrumentationParams = new InstrumentationFieldCompleteParameters(executionContext, parameters, fieldDef, executionStepInfo, fetchedValue);\n        InstrumentationContext<ExecutionResult> ctxCompleteField = instrumentation.beginFieldComplete(\n                instrumentationParams\n        );\n\n        GraphQLCodeRegistry codeRegistry = executionContext.getGraphQLSchema().getCodeRegistry();\n        Map<String, Object> argumentValues = valuesResolver.getArgumentValues(codeRegistry, fieldDef.getArguments(), field.getArguments(), executionContext.getVariables());\n\n        NonNullableFieldValidator nonNullableFieldValidator = new NonNullableFieldValidator(executionContext, executionStepInfo);\n\n        ExecutionStrategyParameters newParameters = parameters.transform(builder ->\n                builder.executionStepInfo(executionStepInfo)\n                        .arguments(argumentValues)\n                        .source(fetchedValue)\n                        .nonNullFieldValidator(nonNullableFieldValidator)\n        );\n\n        log.debug(\"'{}' completing field '{}'...\", executionContext.getExecutionId(), executionStepInfo.getPath());\n\n        FieldValueInfo fieldValueInfo = completeValue(executionContext, newParameters);\n\n        CompletableFuture<ExecutionResult> executionResultFuture = fieldValueInfo.getFieldValue();\n        ctxCompleteField.onDispatched(executionResultFuture);\n        executionResultFuture.whenComplete(ctxCompleteField::onCompleted);\n        return fieldValueInfo;\n    }\n","new_comment_raw":"@param parameters contains the parameters holding the fields to be executed and source object","old_comment_raw":"@param parameters contains the parameters holding the fields to be executed and source object","label":0,"pre_label":1,"AST_level":9,"line_counts":35,"new_code_token_num":239},{"new_code_raw":"public static List<Integer> getSubListIndex(Object[] tofind, Object[] tokens){ if(tofind.length > tokens.length) return null; List<Integer> allIndices = new ArrayList<Integer>(); boolean matched = false; int index = -1; int lastUnmatchedIndex = 0; for(int i = 0 ; i < tokens.length;){ for(int j = 0; j < tofind.length ;){ if(tofind[j].equals(tokens[i])){ index = i; i++; j++; if(j == tofind.length) { matched = true; break; } }else{ j = 0; i = lastUnmatchedIndex +1; lastUnmatchedIndex = i; index = -1; if(lastUnmatchedIndex == tokens.length) break; } if(i >= tokens.length){ index = -1; break; } } if(i == tokens.length || matched){ if(index >= 0) \/\/index = index - l1.length + 1; allIndices.add(index - tofind.length + 1); matched = false; lastUnmatchedIndex = index; \/\/break; } } \/\/get starting point return allIndices; }","old_code_raw":"  public static List<Integer> getSubListIndex(Object[] l1, Object[] l2){\n    if(l1.length > l2.length)\n      return null;\n    List<Integer> allIndices = new ArrayList<Integer>();\n    boolean matched = false;\n    int index = -1;\n    int lastUnmatchedIndex = 0;\n    for(int i = 0 ; i < l2.length;){\n      for(int j = 0; j < l1.length ;){\n        if(l1[j].equals(l2[i])){\n          index = i;\n          i++;\n          j++;\n          if(j == l1.length)\n          {\n            matched = true;\n            break;\n          }\n        }else{\n          j = 0;\n          i = lastUnmatchedIndex +1;\n          lastUnmatchedIndex = i;\n          index = -1;\n          if(lastUnmatchedIndex == l2.length)\n            break;\n        }\n        if(i >= l2.length){\n          index = -1;\n          break;\n        }\n      }\n      if(i == l2.length || matched){\n        if(index >= 0)\n          \/\/index = index - l1.length + 1;\n          allIndices.add(index - l1.length + 1);\n        matched = false;\n        lastUnmatchedIndex = index;\n\n        \/\/break;\n      }\n    }\n    \/\/get starting point\n\n    return allIndices;\n  }\n","new_comment_raw":"@param tokens","old_comment_raw":"@param l2","label":1,"pre_label":0,"AST_level":13,"line_counts":46,"new_code_token_num":211},{"new_code_raw":"public boolean searchForText(String regex, int matches, boolean scroll) { sleeper.sleep(); inst.waitForIdleSync(); Pattern p = Pattern.compile(regex); Matcher matcher; ArrayList<TextView> textViewList = viewFetcher.getCurrentViews(TextView.class); if(matches == 0) matches = 1; for(TextView textView : textViewList){ matcher = p.matcher(textView.getText().toString()); if(matcher.find()){ countMatches++; } if (countMatches == matches) { countMatches=0; return true; } } if (scroll && scroller.scroll(Scroller.Direction.DOWN)) { return searchForText(regex, matches, scroll); } else { if (countMatches > 0) Log.d(LOG_TAG, \" There are only \" + countMatches + \" matches of \" + regex); countMatches=0; return false; } }","old_code_raw":"\tpublic boolean searchForText(String search, int matches, boolean scroll) {\n\t\tsleeper.sleep();\n\t\tinst.waitForIdleSync();\n\t\tPattern p = Pattern.compile(search);\n\t\tMatcher matcher;\n\t\tArrayList<TextView> textViewList = viewFetcher.getCurrentViews(TextView.class);\n\t\tif(matches == 0)\n\t\t\tmatches = 1;\n\t\tfor(TextView textView : textViewList){\n\t\t\tmatcher = p.matcher(textView.getText().toString());\n\t\t\tif(matcher.find()){\t\n\t\t\t\tcountMatches++;\n\t\t\t}\n\t\t\tif (countMatches == matches) {\n\t\t\t\tcountMatches=0;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tif (scroll && scroller.scroll(Scroller.Direction.DOWN)) {\n\t\t\treturn searchForText(search, matches, scroll);\n\t\t} else {\n\t\t\tif (countMatches > 0)\n\t\t\t\tLog.d(LOG_TAG, \" There are only \" + countMatches + \" matches of \" + search);\n\t\t\tcountMatches=0;\n\t\t\treturn false;\n\t\t}\n\t\t\n\t}\n","new_comment_raw":"@param regex the text to search for. The parameter will be interpreted as a regular expression.","old_comment_raw":"@param search the string to be searched. The parameter will be interpreted as a regular expression.","label":1,"pre_label":0,"AST_level":11,"line_counts":30,"new_code_token_num":162},{"new_code_raw":"public boolean searchText(String regex, int matches) { boolean found = searcher.searchText(regex, matches, true); return found; }","old_code_raw":"\tpublic boolean searchText(String search, int matches) {\n\t\tboolean found = searcher.searchText(search, matches, true);\n\t\treturn found;\n\n\t}\n","new_comment_raw":"@param regex the text to search for. The parameter will be interpreted as a regular expression.","old_comment_raw":"@param search the string to be searched. The parameter will be interpreted as a regular expression.","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":27},{"new_code_raw":"public ScrollableResults scroll(ScrollMode mode, Expression<?> expr) { Query query = createQuery(expr); reset(); return query.scroll(mode); }","old_code_raw":"    public ScrollableResults scroll(ScrollMode mode, Expr<?> expr) {\n        Query query = createQuery(expr);\n        reset();\n        return query.scroll(mode);\n    }\n","new_comment_raw":"@param expr","old_comment_raw":"@param expr","label":0,"pre_label":1,"AST_level":6,"line_counts":6,"new_code_token_num":31},{"new_code_raw":"public static String quoteIdentifierInSqlExpr(TableDesc tableDesc, String sqlExpr, SqlDialect sqlDialect) { String table = tableDesc.getName(); boolean tableMatched = false; List<String> tabPatterns = getTableNameOrAliasPatterns(table); if (isIdentifierNeedToQuote(sqlExpr, table, tabPatterns)) { sqlExpr = quoteIdentifier(sqlExpr, table, tabPatterns, sqlDialect); tableMatched = true; } if (tableMatched) { for (ColumnDesc columnDesc : tableDesc.getColumns()) { String column = columnDesc.getName(); List<String> colPatterns = getColumnNameOrAliasPatterns(column); if (isIdentifierNeedToQuote(sqlExpr, column, colPatterns)) { sqlExpr = quoteIdentifier(sqlExpr, column, colPatterns, sqlDialect); } } } return sqlExpr; }","old_code_raw":"    public static String quoteIdentifierInSqlExpr(TableDesc tableDesc, String sqlExpr) {\n        String table = tableDesc.getName();\n        boolean tableMatched = false;\n        List<String> tabPatterns = getTableNameOrAliasPatterns(table);\n        if (isIdentifierNeedToQuote(sqlExpr, table, tabPatterns)) {\n            sqlExpr = quoteIdentifier(sqlExpr, table, tabPatterns);\n            tableMatched = true;\n        }\n\n        if (tableMatched) {\n            for (ColumnDesc columnDesc : tableDesc.getColumns()) {\n                String column = columnDesc.getName();\n                List<String> colPatterns = getColumnNameOrAliasPatterns(column);\n                if (isIdentifierNeedToQuote(sqlExpr, column, colPatterns)) {\n                    sqlExpr = quoteIdentifier(sqlExpr, column, colPatterns);\n                }\n            }\n        }\n\n        return sqlExpr;\n    }\n","new_comment_raw":"@param tableDesc","old_comment_raw":"@param tableDesc","label":0,"pre_label":1,"AST_level":12,"line_counts":22,"new_code_token_num":124},{"new_code_raw":"public RepositoryMetadata lookupComponent(Class<?> repositoryClass) { if (repositoriesMetadata.containsKey(repositoryClass)) { return repositoriesMetadata.get(repositoryClass); } throw new RuntimeException(\"Unknown Repository class \" + repositoryClass.getName()); }","old_code_raw":"    public RepositoryMetadata lookupComponent(Class<?> repoClass)\r\n    {\r\n        if (repositoriesMetadata.containsKey(repoClass))\r\n        {\r\n            return repositoriesMetadata.get(repoClass);\r\n        }\r\n        throw new RuntimeException(\"Unknown Repository class \" + repoClass.getName());\r\n    }\r\n","new_comment_raw":"@param repositoryClass The repository class to lookup the method for","old_comment_raw":"@param repoClass The Repository class to lookup the method for","label":1,"pre_label":0,"AST_level":7,"line_counts":10,"new_code_token_num":43},{"new_code_raw":"public static StringTemplate stringTemplate(String template, ImmutableList<?> args) { return new StringTemplate(createTemplate(template), args); }","old_code_raw":"    public static StringExpression stringTemplate(Template template, Object... args) {\n        return new StringTemplate(template, ImmutableList.copyOf(args));\n    }\n","new_comment_raw":"@param template","old_comment_raw":"@param template","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":26},{"new_code_raw":"public CodegenModel fromModel(String name, Schema schema, Map<String, Schema> allDefinitions) { if (typeAliases == null) { \/\/ Only do this once during first call typeAliases = getAllAliases(allDefinitions); } CodegenModel m = CodegenModelFactory.newInstance(CodegenModelType.MODEL); if (reservedWords.contains(name)) { m.name = escapeReservedWord(name); } else { m.name = name; } m.title = escapeText(schema.getTitle()); m.description = escapeText(schema.getDescription()); m.unescapedDescription = schema.getDescription(); m.classname = toModelName(name); m.classVarName = toVarName(name); m.classFilename = toModelFilename(name); m.modelJson = Json.pretty(schema); m.externalDocumentation = schema.getExternalDocs(); if (schema.getExtensions() != null && !schema.getExtensions().isEmpty()) { m.getVendorExtensions().putAll(schema.getExtensions()); } m.isAlias = typeAliases.containsKey(name); m.discriminator = schema.getDiscriminator(); if (schema.getXml() != null) { m.xmlPrefix = schema.getXml().getPrefix(); m.xmlNamespace = schema.getXml().getNamespace(); m.xmlName = schema.getXml().getName(); } if (ModelUtils.isArraySchema(schema)) { m.isArrayModel = true; m.arrayModelType = fromProperty(name, schema).complexType; addParentContainer(m, name, schema); } else if (schema instanceof ComposedSchema) { final ComposedSchema composed = (ComposedSchema) schema; Map<String, Schema> properties = new LinkedHashMap<String, Schema>(); List<String> required = new ArrayList<String>(); Map<String, Schema> allProperties; List<String> allRequired; if (supportsInheritance || supportsMixins) { allProperties = new LinkedHashMap<String, Schema>(); allRequired = new ArrayList<String>(); m.allVars = new ArrayList<CodegenProperty>(); int modelImplCnt = 0; \/\/ only one inline object allowed in a ComposedModel for (Schema innerModel : composed.getAllOf()) { if (m.discriminator == null) { m.discriminator = schema.getDiscriminator(); } if (innerModel.getXml() != null) { m.xmlPrefix = innerModel.getXml().getPrefix(); m.xmlNamespace = innerModel.getXml().getNamespace(); m.xmlName = innerModel.getXml().getName(); } if (modelImplCnt++ > 1) { LOGGER.warn(\"More than one inline schema specified in allOf:. Only the first one is recognized. All others are ignored.\"); break; \/\/ only one ModelImpl with discriminator allowed in allOf } } } else { allProperties = null; allRequired = null; } \/\/ parent model final String parentName = getParentName(composed, allDefinitions); final Schema parent = StringUtils.isBlank(parentName) ? null : allDefinitions.get(parentName); List<Schema> interfaces = getInterfaces(composed); \/\/ interfaces (intermediate models) if (interfaces != null) { if (m.interfaces == null) m.interfaces = new ArrayList<String>(); for (Schema interfaceSchema : interfaces) { if (StringUtils.isBlank(interfaceSchema.get$ref())) { continue; } Schema refSchema = null; String ref = getSimpleRef(interfaceSchema.get$ref()); if (allDefinitions != null) { refSchema = allDefinitions.get(ref); } final String modelName = toModelName(ref); m.interfaces.add(modelName); addImport(m, modelName); if (allDefinitions != null && refSchema != null) { if (!supportsMixins && !supportsInheritance) { addProperties(properties, required, refSchema, allDefinitions); } if (supportsInheritance) { addProperties(allProperties, allRequired, refSchema, allDefinitions); } } } } if (parent != null) { m.parentSchema = parentName; m.parent = toModelName(parentName); addImport(m, m.parent); if (allDefinitions != null && !allDefinitions.isEmpty()) { if (supportsInheritance) { addProperties(allProperties, allRequired, parent, allDefinitions); } else { addProperties(properties, required, parent, allDefinitions); } } } \/\/ child model (properties owned by the model itself) Schema child = null; if (composed.getAllOf() != null && !composed.getAllOf().isEmpty()) { for (Schema component : composed.getAllOf()) { if (component.get$ref() == null) { child = component; } } } if (child != null) { addProperties(properties, required, child, allDefinitions); if (supportsInheritance) { addProperties(allProperties, allRequired, child, allDefinitions); } } addVars(m, properties, required, allProperties, allRequired); \/\/ TODO \/\/} else if (schema instanceof RefModel) { } else { m.dataType = getSchemaType(schema); if (schema.getEnum() != null && !schema.getEnum().isEmpty()) { m.isEnum = true; \/\/ comment out below as allowableValues is not set in post processing model enum m.allowableValues = new HashMap<String, Object>(); m.allowableValues.put(\"values\", schema.getEnum()); } if (ModelUtils.isMapSchema(schema)) { addAdditionPropertiesToCodeGenModel(m, schema); } addVars(m, schema.getProperties(), schema.getRequired()); } if (m.vars != null) { for (CodegenProperty prop : m.vars) { postProcessModelProperty(m, prop); } } LOGGER.debug(\"debugging fromModel return: \" + m); return m; }","old_code_raw":"    public CodegenModel fromModel(String name, Model model, Map<String, Model> allDefinitions) {\n        if (typeAliases == null) {\n            \/\/ Only do this once during first call\n            typeAliases = getAllAliases(allDefinitions);\n        }\n        CodegenModel m = CodegenModelFactory.newInstance(CodegenModelType.MODEL);\n        if (reservedWords.contains(name)) {\n            m.name = escapeReservedWord(name);\n        } else {\n            m.name = name;\n        }\n        m.title = escapeText(model.getTitle());\n        m.description = escapeText(model.getDescription());\n        m.unescapedDescription = model.getDescription();\n        m.classname = toModelName(name);\n        m.classVarName = toVarName(name);\n        m.classFilename = toModelFilename(name);\n        m.modelJson = Json.pretty(model);\n        m.externalDocs = model.getExternalDocs();\n        m.vendorExtensions = model.getVendorExtensions();\n        m.isAlias = typeAliases.containsKey(name);\n\n        if (model instanceof ModelImpl) {\n            ModelImpl modelImpl = (ModelImpl) model;\n            m.discriminator = modelImpl.getDiscriminator();\n\n            if (modelImpl.getXml() != null) {\n                m.xmlPrefix = modelImpl.getXml().getPrefix();\n                m.xmlNamespace = modelImpl.getXml().getNamespace();\n                m.xmlName = modelImpl.getXml().getName();\n            }\n        }\n\n        if (model instanceof ArrayModel) {\n            ArrayModel am = (ArrayModel) model;\n            ArrayProperty arrayProperty = new ArrayProperty(am.getItems());\n            m.isArrayModel = true;\n            m.arrayModelType = fromProperty(name, arrayProperty).complexType;\n            addParentContainer(m, name, arrayProperty);\n        } else if (model instanceof RefModel) {\n            \/\/ TODO\n        } else if (model instanceof ComposedModel) {\n            final ComposedModel composed = (ComposedModel) model;\n            Map<String, Property> properties = new LinkedHashMap<String, Property>();\n            List<String> required = new ArrayList<String>();\n            Map<String, Property> allProperties;\n            List<String> allRequired;\n            if (supportsInheritance || supportsMixins) {\n                allProperties = new LinkedHashMap<String, Property>();\n                allRequired = new ArrayList<String>();\n                m.allVars = new ArrayList<CodegenProperty>();\n                int modelImplCnt = 0; \/\/ only one inline object allowed in a ComposedModel\n                for (Model innerModel: ((ComposedModel)model).getAllOf()) {\n                    if (innerModel instanceof ModelImpl) {\n                        ModelImpl modelImpl = (ModelImpl) innerModel;\n                        if (m.discriminator == null) {\n                            m.discriminator = modelImpl.getDiscriminator();\n                        }\n                        if (modelImpl.getXml() != null) {\n                            m.xmlPrefix = modelImpl.getXml().getPrefix();\n                            m.xmlNamespace = modelImpl.getXml().getNamespace();\n                            m.xmlName = modelImpl.getXml().getName();\n                        }\n                        if (modelImplCnt++ > 1) {\n                            LOGGER.warn(\"More than one inline schema specified in allOf:. Only the first one is recognized. All others are ignored.\");\n                            break; \/\/ only one ModelImpl with discriminator allowed in allOf\n                        }\n                    }\n                }\n            } else {\n                allProperties = null;\n                allRequired = null;\n            }\n            \/\/ parent model\n            RefModel parent = (RefModel) composed.getParent();\n\n            \/\/ interfaces (intermediate models)\n            if (composed.getInterfaces() != null) {\n                if (m.interfaces == null)\n                    m.interfaces = new ArrayList<String>();\n                for (RefModel _interface : composed.getInterfaces()) {\n                    Model interfaceModel = null;\n                    if (allDefinitions != null) {\n                        interfaceModel = allDefinitions.get(_interface.getSimpleRef());\n                    }\n                    \/\/ set first interface with discriminator found as parent\n                    if (parent == null\n                            && ((interfaceModel instanceof ModelImpl && ((ModelImpl) interfaceModel).getDiscriminator() != null)\n                            || (interfaceModel instanceof ComposedModel && isDiscriminatorInInterfaceTree((ComposedModel) interfaceModel, allDefinitions)))) {\n                        parent = _interface;\n                    } else {\n                        final String interfaceRef = toModelName(_interface.getSimpleRef());\n                        m.interfaces.add(interfaceRef);\n                        addImport(m, interfaceRef);\n                        if (allDefinitions != null) {\n                            if (!supportsMixins) {\n                                addProperties(properties, required, interfaceModel, allDefinitions);\n                            }\n                            if (supportsInheritance) {\n                                addProperties(allProperties, allRequired, interfaceModel, allDefinitions);\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (parent != null) {\n                final String parentRef = parent.getSimpleRef();\n                m.parentSchema = parentRef;\n                m.parent = toModelName(parent.getSimpleRef());\n                addImport(m, m.parent);\n                if (allDefinitions != null) {\n                    final Model parentModel = allDefinitions.get(m.parentSchema);\n                    if (supportsInheritance) {\n                        addProperties(allProperties, allRequired, parentModel, allDefinitions);\n                    } else {\n                        addProperties(properties, required, parentModel, allDefinitions);\n                    }\n                }\n            }\n\n            \/\/ child model (properties owned by the model itself)\n            Model child = composed.getChild();\n            if (child != null && child instanceof RefModel && allDefinitions != null) {\n                final String childRef = ((RefModel) child).getSimpleRef();\n                child = allDefinitions.get(childRef);\n            }\n            if (child != null && child instanceof ModelImpl) {\n                addProperties(properties, required, child, allDefinitions);\n                if (supportsInheritance) {\n                    addProperties(allProperties, allRequired, child, allDefinitions);\n                }\n            }\n            addVars(m, properties, required, allProperties, allRequired);\n        } else {\n            ModelImpl impl = (ModelImpl) model;\n            if (impl.getType() != null) {\n                Property p = PropertyBuilder.build(impl.getType(), impl.getFormat(), null);\n                m.dataType = getSwaggerType(p);\n            }\n            if(impl.getEnum() != null && impl.getEnum().size() > 0) {\n                m.isEnum = true;\n                \/\/ comment out below as allowableValues is not set in post processing model enum\n                m.allowableValues = new HashMap<String, Object>();\n                m.allowableValues.put(\"values\", impl.getEnum());\n            }\n            if (impl.getAdditionalProperties() != null) {\n                addAdditionPropertiesToCodeGenModel(m, impl);\n            }\n            addVars(m, impl.getProperties(), impl.getRequired());\n        }\n\n        if (m.vars != null) {\n            for(CodegenProperty prop : m.vars) {\n                postProcessModelProperty(m, prop);\n            }\n        }\n        return m;\n    }\n","new_comment_raw":"@param allDefinitions a map of all OAS models from the spec","old_comment_raw":"@param allDefinitions a map of all Swagger models from the spec","label":1,"pre_label":0,"AST_level":16,"line_counts":156,"new_code_token_num":1025},{"new_code_raw":"public static long durationNanos(int years, int months, int days, int hours, int minutes, long seconds) { return durationNanos(years, months, days, hours, minutes, seconds, 0); }","old_code_raw":"    public static double durationNanos(int years, int months, int days, int hours, int minutes, double seconds) {\n        return durationNanos(years, months, days, hours, minutes, seconds, 0);\n    }\n","new_comment_raw":"@param years a number of years","old_comment_raw":"@param years a number of years","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":43},{"new_code_raw":"protected SourceInfo update(Long lsn, Instant commitTime, Long txId, TableId tableId) { this.lsn = lsn; this.useconds = Conversions.toEpochMicros(commitTime); this.txId = txId; if (tableId != null && tableId.schema() != null) { this.schemaName = tableId.schema(); } if (tableId != null && tableId.table() != null) { this.tableName = tableId.table(); } return this; }","old_code_raw":"    protected SourceInfo update(Long lsn, Long useconds, Long txId, TableId tableId) {\n        this.lsn = lsn;\n        this.useconds = useconds;\n        this.txId = txId;\n        if (tableId != null && tableId.schema() != null) {\n            this.schemaName = tableId.schema();\n        }\n        if (tableId != null && tableId.table() != null) {\n            this.tableName = tableId.table();\n        }\n        return this;\n    }\n","new_comment_raw":"@param tableId the table that should be included in the source info; may be null","old_comment_raw":"@param tableId the table that should be included in the source info; may be null","label":0,"pre_label":1,"AST_level":8,"line_counts":13,"new_code_token_num":83},{"new_code_raw":"public Task<Boolean> contains(final CacheKey key) { if (containsSync(key)) { return Task.forResult(true); } return containsAsync(key); }","old_code_raw":"  public Task<Boolean> contains(final List<CacheKey> keys) {\n    if (keys.isEmpty()) {\n      return Task.forResult(false);\n    }\n    if (containsSync(keys)) {\n      return Task.forResult(true);\n    }\n    Task<Boolean> masterTask = containsAsync(keys.get(0));\n    if (keys.size() == 1) {\n      return masterTask;\n    }\n    for (final CacheKey key : keys.subList(1, keys.size())) {\n      masterTask = masterTask.continueWithTask(\n          new Continuation<Boolean, Task<Boolean>>() {\n            @Override\n            public Task<Boolean> then(Task<Boolean> previousTask) throws Exception {\n              if (previousTask.isCancelled() || previousTask.getResult()) {\n                return previousTask;\n              }\n              return containsAsync(key);\n            }\n          },\n          mReadExecutor);\n    }\n    return masterTask;\n  }\n","new_comment_raw":"@param key","old_comment_raw":"@param keys","label":1,"pre_label":0,"AST_level":7,"line_counts":7,"new_code_token_num":33},{"new_code_raw":"public Builder field(UnaryOperator<GraphQLFieldDefinition.Builder> builderFunction) { assertNotNull(builderFunction, \"builderFunction can't be null\"); GraphQLFieldDefinition.Builder builder = GraphQLFieldDefinition.newFieldDefinition(); builder = builderFunction.apply(builder); return field(builder); }","old_code_raw":"        public Builder field(BuilderFunction<GraphQLFieldDefinition.Builder> builderFunction) {\n            assertNotNull(builderFunction, \"builderFunction can't be null\");\n            GraphQLFieldDefinition.Builder builder = GraphQLFieldDefinition.newFieldDefinition();\n            builder = builderFunction.apply(builder);\n            return field(builder);\n        }\n","new_comment_raw":"@param builderFunction a supplier for the builder impl","old_comment_raw":"@param builderFunction a supplier for the builder impl","label":0,"pre_label":1,"AST_level":7,"line_counts":7,"new_code_token_num":46},{"new_code_raw":"public static String getConsoleIconPath(DesiredCapabilities cap,Registry registry) { String name = consoleIconName(cap,registry); InputStream in = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"images\/\"+name+\".png\"); if (in == null){ return null; }else { return \"\/grid\/resources\/images\/\" + name + \".png\"; } }","old_code_raw":"\tpublic static String getConsoleIconPath(DesiredCapabilities cap) {\n\t\tString name = consoleIconName(cap);\n\t\tInputStream in = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"images\/\"+name+\".png\");\n\t\tif (in == null){\n\t\t\treturn null;\n\t\t}else {\n\t\t\treturn \"\/grid\/resources\/images\/\" + name + \".png\";\n\t\t}\n\t\t\n\t}\n","new_comment_raw":"@param cap","old_comment_raw":"@param cap","label":0,"pre_label":1,"AST_level":9,"line_counts":11,"new_code_token_num":75},{"new_code_raw":"public void setInto(ReadWritablePeriod duration, Object object) { duration.setPeriod((ReadableDuration) object); }","old_code_raw":"    public void setInto(ReadWritableTimePeriod duration, Object object) {\n        duration.setTimePeriod((ReadableDuration) object);\n    }\n","new_comment_raw":"@param duration duration to get modified","old_comment_raw":"@param duration duration to get modified","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":21},{"new_code_raw":"public static long toNanoOfDay(Object value, boolean acceptLargeValues) { if (value instanceof Duration) { Duration duration = (Duration) value; if (!acceptLargeValues && (duration.isNegative() || duration.compareTo(ONE_DAY) > 0)) { throw new IllegalArgumentException(\"Time values must be between 00:00:00 and 24:00:00 (inclusive): \" + duration); } return ((Duration) value).toNanos(); } \/\/ TODO only needed for SQL Server\/Oracle, where we don't produce Duration right away; \/\/ this should go eventually, as the conversion to LocalTime is superfluous LocalTime time = Conversions.toLocalTime(value); return time.toNanoOfDay(); }","old_code_raw":"    public static long toNanoOfDay(Object value, TemporalAdjuster adjuster) {\n        LocalTime time = Conversions.toLocalTime(value);\n        if (adjuster !=null) {\n            time = time.with(adjuster);\n        }\n        return time.toNanoOfDay();\n    }\n","new_comment_raw":"@param value the duration value; may not be null","old_comment_raw":"@param value the local or SQL date, time, or timestamp value; may not be null","label":1,"pre_label":0,"AST_level":10,"line_counts":16,"new_code_token_num":141},{"new_code_raw":"private static String toString(Collection<TypedDependency> dependencies, boolean extraSep) { StringBuilder buf = new StringBuilder(); if (extraSep) { List<TypedDependency> extraDeps = new ArrayList<TypedDependency>(); for (TypedDependency td : dependencies) { if (td.extra()) { extraDeps.add(td); } else { buf.append(td.toString()).append('\\n'); } } \/\/ now we print the separator for extra dependencies, and print these if there are some if (!extraDeps.isEmpty()) { buf.append(\"======\\n\"); for (TypedDependency td : extraDeps) { buf.append(td.toString()).append('\\n'); } } } else { for (TypedDependency td : dependencies) { buf.append(td.toString()).append('\\n'); } } return buf.toString(); }","old_code_raw":"  private static String toString(Collection<TypedDependency> dependencies, boolean extraSep, boolean includeTags) {\n    CoreLabel.OutputFormat labelFormat = (includeTags) ? CoreLabel.OutputFormat.VALUE_TAG_INDEX : CoreLabel.OutputFormat.VALUE_INDEX;\n    StringBuilder buf = new StringBuilder();\n    if (extraSep) {\n      List<TypedDependency> extraDeps =  new ArrayList<TypedDependency>();\n      for (TypedDependency td : dependencies) {\n        if (td.extra()) {\n          extraDeps.add(td);\n        } else {\n          buf.append(td.toString(labelFormat)).append('\\n');\n        }\n      }\n      \/\/ now we print the separator for extra dependencies, and print these if there are some\n      if (!extraDeps.isEmpty()) {\n        buf.append(\"======\\n\");\n        for (TypedDependency td : extraDeps) {\n          buf.append(td.toString(labelFormat)).append('\\n');\n        }\n      }\n    } else {\n      for (TypedDependency td : dependencies) {\n        buf.append(td.toString(labelFormat)).append('\\n');\n      }\n    }\n    return buf.toString();\n  }\n","new_comment_raw":"@param dependencies The TypedDependencies to print","old_comment_raw":"@param dependencies The TypedDependencies to print","label":0,"pre_label":1,"AST_level":12,"line_counts":27,"new_code_token_num":175},{"new_code_raw":"public boolean searchText(String text, int minimumNumberOfMatches, boolean scroll, boolean onlyVisible) { return searcher.searchWithTimeoutFor(TextView.class, text, minimumNumberOfMatches, scroll, onlyVisible); }","old_code_raw":"\tpublic boolean searchText(String text, int minimumNumberOfMatches, boolean scroll, boolean visible) {\n\t\treturn searcher.searchWithTimeoutFor(TextView.class, text, minimumNumberOfMatches, scroll, visible);\n\t}\n","new_comment_raw":"@param onlyVisible  true if only texts visible on the screen should be searched","old_comment_raw":"@param visible true if only texts visible on the screen should be searched","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":34},{"new_code_raw":"public PendingMessageCursor getSubscriberPendingMessageCursor(Broker broker,String clientId, String name, int maxBatchSize, DurableTopicSubscription sub) { StoreDurableSubscriberCursor cursor = new StoreDurableSubscriberCursor(broker,clientId, name, maxBatchSize, sub); cursor.setImmediatePriorityDispatch(isImmediatePriorityDispatch()); return cursor; }","old_code_raw":"    public PendingMessageCursor getSubscriberPendingMessageCursor(Broker broker,String clientId, String name, int maxBatchSize, Subscription sub) {\n        StoreDurableSubscriberCursor cursor = new StoreDurableSubscriberCursor(broker,clientId, name, maxBatchSize, sub);\n        cursor.setImmediatePriorityDispatch(isImmediatePriorityDispatch());\n        return cursor;\n    }\n","new_comment_raw":"@param sub","old_comment_raw":"@param sub","label":0,"pre_label":1,"AST_level":6,"line_counts":6,"new_code_token_num":48},{"new_code_raw":"private StringBuilder appendIfNotNull(StringBuilder source, String addStr, String delimiter) { if (addStr != null) { if (addStr.length() == 0) { delimiter = \"\"; } return source.append(addStr).append(delimiter); } return source; }","old_code_raw":"    private String appendIfNotNull(String sourceStr, String appendStr, String delimiter) {\n        if (appendStr != null) {\n            if (appendStr.length() == 0) {\n                delimiter = \"\";\n            }\n            sourceStr += delimiter + appendStr;\n        }\n        return sourceStr;\n    }\n","new_comment_raw":"@param source Stringbuilder containing the text to append to.","old_comment_raw":"@param sourceStr The String to append to.","label":1,"pre_label":0,"AST_level":9,"line_counts":12,"new_code_token_num":51},{"new_code_raw":"public int update(Object[] before, Object[] after, Instant ts) throws InterruptedException { return update(before, after, ts, 0, 1); }","old_code_raw":"        public int update(Object[] before, Object[] after, long ts) throws InterruptedException {\n            return update(before, after, ts, 0, 1);\n        }\n","new_comment_raw":"@param ts the timestamp for this row","old_comment_raw":"@param ts the timestamp for this row","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":35},{"new_code_raw":"public static BufferedImage alphaOffset(final Image rawImg, final int offset) { BufferedImage image = toARGB(rawImg); final float offsetFloat = (float) offset; final int numComponents = image.getColorModel().getNumComponents(); final float[] scales = new float[numComponents]; final float[] offsets = new float[numComponents]; Arrays.fill(scales, 1f); Arrays.fill(offsets, 0f); offsets[numComponents - 1] = offsetFloat; return offset(image, scales, offsets); }","old_code_raw":"\tpublic static BufferedImage alphaOffset(final BufferedImage image, final int offset)\n\t{\n\t\tfinal float offsetFloat = (float) offset;\n\t\tfinal int numComponents = image.getColorModel().getNumComponents();\n\t\tfinal float[] scales = new float[numComponents];\n\t\tfinal float[] offsets = new float[numComponents];\n\n\t\tArrays.fill(scales, 1f);\n\t\tArrays.fill(offsets, 0f);\n\t\toffsets[numComponents - 1] = offsetFloat;\n\t\treturn offset(image, scales, offsets);\n\t}\n","new_comment_raw":"@param rawImg The image to be made more or less transparent.","old_comment_raw":"@param image The image to be made more or less transparent.","label":1,"pre_label":0,"AST_level":8,"line_counts":14,"new_code_token_num":97},{"new_code_raw":"public String invokeAPI(String path, String method, Set<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); b.append(\"?\"); if (queryParams != null){ for (Pair queryParam : queryParams){ if (!queryParam.getName().isEmpty()) { b.append(escapeString(queryParam.getName())); b.append(\"=\"); b.append(escapeString(queryParam.getValue())); b.append(\"&\"); } } } String querystring = b.substring(0, b.length() - 1); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(\"GET\".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (\"POST\".equals(method)) { if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (\"PUT\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (\"DELETE\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, \"unknown method type \" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return \"\"; } } else { String message = \"error\"; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { \/\/ e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }","old_code_raw":"  public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    for(String key : queryParams.keySet()) {\n      String value = queryParams.get(key);\n      if (value != null){\n        if(b.toString().length() == 0)\n          b.append(\"?\");\n        else\n          b.append(\"&\");\n        b.append(escapeString(key)).append(\"=\").append(escapeString(value));\n      }\n    }\n    String querystring = b.toString();\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          \/\/ e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n","new_comment_raw":"@param contentType The request's Content-Type header","old_comment_raw":"@param contentType The request's Content-Type header","label":0,"pre_label":1,"AST_level":16,"line_counts":113,"new_code_token_num":736},{"new_code_raw":"static public IStructuredTextExpert getExpert(String type, StructuredTextEnvironment environment) { IStructuredTextExpert expert; if (environment == null) environment = StructuredTextEnvironment.DEFAULT; synchronized (sharedExperts) { Map experts = (Map) sharedExperts.get(type); if (experts == null) { experts = new HashMap(); \/\/ environment -> expert sharedExperts.put(type, experts); } expert = (IStructuredTextExpert) experts.get(environment); if (expert == null) { StructuredTextTypeHandler handler = StructuredTextTypeHandlerFactory.getHandler(type); if (handler == null) throw new IllegalArgumentException(\"Invalid type argument\"); \/\/$NON-NLS-1$ expert = new StructuredTextImpl(handler, environment, false); experts.put(type, expert); } } return expert; }","old_code_raw":"\tstatic public ISTextExpert getExpert(String type, STextEnvironment environment) {\n\t\tISTextExpert expert;\n\t\tif (environment == null)\n\t\t\tenvironment = STextEnvironment.DEFAULT;\n\t\tsynchronized (sharedExperts) {\n\t\t\tMap experts = (Map) sharedExperts.get(type);\n\t\t\tif (experts == null) {\n\t\t\t\texperts = new HashMap(); \/\/ environment -> expert\n\t\t\t\tsharedExperts.put(type, experts);\n\t\t\t}\n\t\t\texpert = (ISTextExpert) experts.get(environment);\n\t\t\tif (expert == null) {\n\t\t\t\tSTextTypeHandler handler = STextTypeHandlerFactory.getHandler(type);\n\t\t\t\tif (handler == null)\n\t\t\t\t\tthrow new IllegalArgumentException(\"Invalid type argument\"); \/\/$NON-NLS-1$\n\t\t\t\texpert = new STextImpl(handler, environment, false);\n\t\t\t\texperts.put(type, expert);\n\t\t\t}\n\t\t}\n\t\treturn expert;\n\t}\n","new_comment_raw":"@param environment the current environment, which may affect the behavior of the expert. This parameter may be specified as null, in which case the  StructuredTextEnvironment#DEFAULT environment should be assumed.","old_comment_raw":"@param environment the current environment, which may affect the behavior of the expert. This parameter may be specified as null, in which case the STextEnvironment#DEFAULT environment should be assumed.","label":1,"pre_label":0,"AST_level":9,"line_counts":23,"new_code_token_num":140},{"new_code_raw":"public int recordEvent(Document oplogEvent, Document masterEvent, Instant timestamp, long txOrder) throws InterruptedException { source.opLogEvent(replicaSetName, oplogEvent, masterEvent, txOrder); final Struct sourceValue = source.struct(); final Map<String, ?> offset = source.lastOffset(replicaSetName); Document patchObj = oplogEvent.get(\"o\", Document.class); \/\/ Updates have an 'o2' field, since the updated object in 'o' might not have the ObjectID ... Object o2 = oplogEvent.get(\"o2\"); String objId = o2 != null ? idObjToJson(o2) : idObjToJson(patchObj); assert objId != null; Operation operation = OPERATION_LITERALS.get(oplogEvent.getString(\"op\")); return createRecords(sourceValue, offset, operation, objId, patchObj, timestamp); }","old_code_raw":"        public int recordEvent(Document oplogEvent, Document masterEvent, long timestamp, long txOrder) throws InterruptedException {\n            source.opLogEvent(replicaSetName, oplogEvent, masterEvent, txOrder);\n            final Struct sourceValue = source.struct();\n            final Map<String, ?> offset = source.lastOffset(replicaSetName);\n            Document patchObj = oplogEvent.get(\"o\", Document.class);\n            \/\/ Updates have an 'o2' field, since the updated object in 'o' might not have the ObjectID ...\n            Object o2 = oplogEvent.get(\"o2\");\n            String objId = o2 != null ? idObjToJson(o2) : idObjToJson(patchObj);\n            assert objId != null;\n            Operation operation = OPERATION_LITERALS.get(oplogEvent.getString(\"op\"));\n            return createRecords(sourceValue, offset, operation, objId, patchObj, timestamp);\n        }\n","new_comment_raw":"@param txOrder order of event in transaction; 0 for non-transactional event","old_comment_raw":"@param txOrder order of event in transaction; 0 for non-transactional event","label":0,"pre_label":1,"AST_level":7,"line_counts":13,"new_code_token_num":149},{"new_code_raw":"public JdbcConnection prepareQuery(String[] multiQuery, StatementPreparer preparer, BlockingMultiResultSetConsumer resultConsumer) throws SQLException, InterruptedException { final Connection conn = connection(); final ResultSet[] resultSets = new ResultSet[multiQuery.length]; final PreparedStatement[] preparedStatements = new PreparedStatement[multiQuery.length]; try { for (int i = 0; i < multiQuery.length; i++) { final String query = multiQuery[i]; if (LOGGER.isTraceEnabled()) { LOGGER.trace(\"running '{}'\", query); } final PreparedStatement statement = conn.prepareStatement(query); preparedStatements[i] = statement; preparer.accept(statement); resultSets[i] = statement.executeQuery(); } if (resultConsumer != null) { resultConsumer.accept(resultSets); } } finally { for (ResultSet rs: resultSets) { if (rs != null) { try { rs.close(); } catch (Exception ei) { } } } for (PreparedStatement ps: preparedStatements) { if (ps != null) { try { ps.close(); } catch (Exception ei) { } } } } return this; }","old_code_raw":"    public JdbcConnection prepareQuery(String[] multiQuery, StatementPreparer preparer, MultiResultSetConsumer resultConsumer) throws SQLException {\n        final Connection conn = connection();\n        final ResultSet[] resultSets = new ResultSet[multiQuery.length];\n        final PreparedStatement[] preparedStatements = new PreparedStatement[multiQuery.length];\n\n        try {\n            for (int i = 0; i < multiQuery.length; i++) {\n                final String query = multiQuery[i];\n                if (LOGGER.isTraceEnabled()) {\n                    LOGGER.trace(\"running '{}'\", query);\n                }\n                final PreparedStatement statement = conn.prepareStatement(query);\n                preparedStatements[i] = statement;\n                preparer.accept(statement);\n                resultSets[i] = statement.executeQuery();\n            }\n            if (resultConsumer != null) {\n                resultConsumer.accept(resultSets);\n            }\n        }\n        finally {\n            for (ResultSet rs: resultSets) {\n                if (rs != null) {\n                    try {\n                        rs.close();\n                    }\n                    catch (Exception ei) {\n                    }\n                }\n            }\n            for (PreparedStatement ps: preparedStatements) {\n                if (ps != null) {\n                    try {\n                        ps.close();\n                    }\n                    catch (Exception ei) {\n                    }\n                }\n            }\n        }\n        return this;\n    }\n","new_comment_raw":"@param multiQuery the array of prepared queries","old_comment_raw":"@param multiQuery the array of prepared queries","label":0,"pre_label":1,"AST_level":10,"line_counts":43,"new_code_token_num":216},{"new_code_raw":"public CodegenProperty fromProperty(String name, Schema p) { if (p == null) { LOGGER.error(\"Unexpected missing property for name \" + name); return null; } LOGGER.debug(\"debugging fromProperty for \" + name + \" : \" + p); CodegenProperty property = CodegenModelFactory.newInstance(CodegenModelType.PROPERTY); property.name = toVarName(name); property.baseName = name; property.nameInCamelCase = camelize(property.name, false); property.description = escapeText(p.getDescription()); property.unescapedDescription = p.getDescription(); property.title = p.getTitle(); property.getter = toGetter(name); property.setter = toSetter(name); String example = toExampleValue(p); if (!\"null\".equals(example)) { property.example = example; } property.defaultValue = toDefaultValue(p); property.defaultValueWithParam = toDefaultValueWithParam(name, p); property.jsonSchema = Json.pretty(p); if (p.getReadOnly() != null) { property.isReadOnly = p.getReadOnly(); } if (p.getXml() != null) { if (p.getXml().getAttribute() != null) { property.isXmlAttribute = p.getXml().getAttribute(); } property.xmlPrefix = p.getXml().getPrefix(); property.xmlName = p.getXml().getName(); property.xmlNamespace = p.getXml().getNamespace(); } if (p.getExtensions() != null && !p.getExtensions().isEmpty()) { property.getVendorExtensions().putAll(p.getExtensions()); } String type = getSchemaType(p); if (ModelUtils.isIntegerSchema(p)) { \/\/ integer type property.isNumeric = Boolean.TRUE; if (SchemaTypeUtil.INTEGER64_FORMAT.equals(p.getFormat())) { \/\/ int64\/long format property.isLong = Boolean.TRUE; } else { \/\/ int32 format property.isInteger = Boolean.TRUE; } if (p.getMinimum() != null) { property.minimum = String.valueOf(p.getMinimum().longValue()); } if (p.getMaximum() != null) { property.maximum = String.valueOf(p.getMaximum().longValue()); } if (p.getExclusiveMinimum() != null) { property.exclusiveMinimum = p.getExclusiveMinimum(); } if (p.getExclusiveMaximum() != null) { property.exclusiveMaximum = p.getExclusiveMaximum(); } \/\/ check if any validation rule defined \/\/ exclusive* are noop without corresponding min\/max if (property.minimum != null || property.maximum != null) property.hasValidation = true; \/\/ legacy support Map<String, Object> allowableValues = new HashMap<String, Object>(); if (p.getMinimum() != null) { allowableValues.put(\"min\", p.getMinimum()); } if (p.getMaximum() != null) { allowableValues.put(\"max\", p.getMaximum()); } if (p.getEnum() != null) { List<Object> _enum = p.getEnum(); property._enum = new ArrayList<String>(); for (Object i : _enum) { property._enum.add(String.valueOf(i)); } property.isEnum = true; allowableValues.put(\"values\", _enum); } if (allowableValues.size() > 0) { property.allowableValues = allowableValues; } } else if (ModelUtils.isBooleanSchema(p)) { \/\/ boolean type property.isBoolean = true; property.getter = toBooleanGetter(name); } else if (ModelUtils.isDateSchema(p)) { \/\/ date format property.isString = false; \/\/ for backward compatibility with 2.x property.isDate = true; if (p.getEnum() != null) { List<String> _enum = p.getEnum(); property._enum = new ArrayList<String>(); for (String i : _enum) { property._enum.add(i); } property.isEnum = true; \/\/ legacy support Map<String, Object> allowableValues = new HashMap<String, Object>(); allowableValues.put(\"values\", _enum); property.allowableValues = allowableValues; } } else if (ModelUtils.isDateTimeSchema(p)) { \/\/ date-time format property.isString = false; \/\/ for backward compatibility with 2.x property.isDateTime = true; if (p.getEnum() != null) { List<String> _enum = p.getEnum(); property._enum = new ArrayList<String>(); for (String i : _enum) { property._enum.add(i); } property.isEnum = true; \/\/ legacy support Map<String, Object> allowableValues = new HashMap<String, Object>(); allowableValues.put(\"values\", _enum); property.allowableValues = allowableValues; } } else if (ModelUtils.isStringSchema(p)) { if (ModelUtils.isByteArraySchema(p)) { property.isByteArray = true; } else if (ModelUtils.isBinarySchema(p)) { property.isBinary = true; property.isFile = true; \/\/ file = binary in OAS3 } else if (ModelUtils.isFileSchema(p)) { property.isFile = true; } else if (ModelUtils.isUUIDSchema(p)) { \/\/ keep isString to true to make it backward compatible property.isString = true; property.isUuid = true; } else { property.isString = true; } property.maxLength = p.getMaxLength(); property.minLength = p.getMinLength(); property.pattern = toRegularExpression(p.getPattern()); \/\/ check if any validation rule defined if (property.pattern != null || property.minLength != null || property.maxLength != null) property.hasValidation = true; if (p.getEnum() != null) { List<String> _enum = p.getEnum(); property._enum = _enum; property.isEnum = true; \/\/ legacy support Map<String, Object> allowableValues = new HashMap<String, Object>(); allowableValues.put(\"values\", _enum); property.allowableValues = allowableValues; } } else if (ModelUtils.isNumberSchema(p)) { property.isNumeric = Boolean.TRUE; if (ModelUtils.isFloatSchema(p)) { \/\/ float property.isFloat = Boolean.TRUE; } else if (ModelUtils.isDoubleSchema(p)) { \/\/ double property.isDouble = Boolean.TRUE; } else { \/\/ type is number and without format property.isNumber = Boolean.TRUE; } if (p.getMinimum() != null) { property.minimum = String.valueOf(p.getMinimum()); } if (p.getMaximum() != null) { property.maximum = String.valueOf(p.getMaximum()); } if (p.getExclusiveMinimum() != null) { property.exclusiveMinimum = p.getExclusiveMinimum(); } if (p.getExclusiveMaximum() != null) { property.exclusiveMaximum = p.getExclusiveMaximum(); } \/\/ check if any validation rule defined \/\/ exclusive* are noop without corresponding min\/max if (property.minimum != null || property.maximum != null) property.hasValidation = true; if (p.getEnum() != null && !p.getEnum().isEmpty()) { List<Object> _enum = p.getEnum(); property._enum = new ArrayList<String>(); for (Object i : _enum) { property._enum.add(String.valueOf(i)); } property.isEnum = true; \/\/ legacy support Map<String, Object> allowableValues = new HashMap<String, Object>(); allowableValues.put(\"values\", _enum); property.allowableValues = allowableValues; } } property.datatype = getTypeDeclaration(p); property.dataFormat = p.getFormat(); property.baseType = getSchemaType(p); \/\/ this can cause issues for clients which don't support enums if (property.isEnum) { property.datatypeWithEnum = toEnumName(property); property.enumName = toEnumName(property); } else { property.datatypeWithEnum = property.datatype; } if (ModelUtils.isArraySchema(p)) { property.isContainer = true; property.isListContainer = true; property.containerType = \"array\"; property.baseType = getSchemaType(p); if (p.getXml() != null) { property.isXmlWrapped = p.getXml().getWrapped() == null ? false : p.getXml().getWrapped(); property.xmlPrefix = p.getXml().getPrefix(); property.xmlNamespace = p.getXml().getNamespace(); property.xmlName = p.getXml().getName(); } \/\/ handle inner property property.maxItems = p.getMaxItems(); property.minItems = p.getMinItems(); String itemName = null; if (p.getExtensions() != null && p.getExtensions().get(\"x-item-name\") != null) { itemName = p.getExtensions().get(\"x-item-name\").toString(); } if (itemName == null) { itemName = property.name; } CodegenProperty cp = fromProperty(itemName, ((ArraySchema) p).getItems()); updatePropertyForArray(property, cp); } else if (ModelUtils.isMapSchema(p)) { property.isContainer = true; property.isMapContainer = true; property.containerType = \"map\"; property.baseType = getSchemaType(p); property.minItems = p.getMinProperties(); property.maxItems = p.getMaxProperties(); \/\/ handle inner property CodegenProperty cp = fromProperty(\"inner\", (Schema) p.getAdditionalProperties()); updatePropertyForMap(property, cp); } else { \/\/ model \/\/ TODO revise the logic below \/\/if (StringUtils.isNotBlank(p.get$ref())) { \/\/ property.baseType = getSimpleRef(p.get$ref()); \/\/} \/\/ --END of revision setNonArrayMapProperty(property, type); } LOGGER.debug(\"debugging from property return: \" + property); return property; }","old_code_raw":"    public CodegenProperty fromProperty(String name, Property p) {\n        if (p == null) {\n            LOGGER.error(\"unexpected missing property for name \" + name);\n            return null;\n        }\n\n        CodegenProperty property = CodegenModelFactory.newInstance(CodegenModelType.PROPERTY);\n        property.name = toVarName(name);\n        property.baseName = name;\n        property.nameInCamelCase = camelize(property.name, false);\n        property.description = escapeText(p.getDescription());\n        property.unescapedDescription = p.getDescription();\n        property.title = p.getTitle();\n        property.getter = toGetter(name);\n        property.setter = toSetter(name);\n        String example = toExampleValue(p);\n        if(!\"null\".equals(example)) {\n            property.example = example;\n        }\n        property.defaultValue = toDefaultValue(p);\n        property.defaultValueWithParam = toDefaultValueWithParam(name, p);\n        property.jsonSchema = Json.pretty(p);\n        if (p.getReadOnly() != null) {\n            property.isReadOnly = p.getReadOnly();\n        }\n        if (p.getXml() != null) {\n            if (p.getXml().getAttribute() != null) {\n                property.isXmlAttribute = p.getXml().getAttribute();\n            }\n            property.xmlPrefix = p.getXml().getPrefix();\n            property.xmlName = p.getXml().getName();\n            property.xmlNamespace = p.getXml().getNamespace();\n        }\n        property.vendorExtensions = p.getVendorExtensions();\n\n        String type = getSwaggerType(p);\n        if (p instanceof AbstractNumericProperty) {\n            AbstractNumericProperty np = (AbstractNumericProperty) p;\n            if (np.getMinimum() != null) {\n                if (p instanceof BaseIntegerProperty) { \/\/ int, long\n                    property.minimum = String.valueOf(np.getMinimum().longValue());\n                } else { \/\/ double, decimal\n                    property.minimum = String.valueOf(np.getMinimum());\n                }\n            }\n            if (np.getMaximum() != null) {\n                if (p instanceof BaseIntegerProperty) { \/\/ int, long\n                    property.maximum = String.valueOf(np.getMaximum().longValue());\n                } else { \/\/ double, decimal\n                    property.maximum = String.valueOf(np.getMaximum());\n                }\n            }\n\n            if (np.getExclusiveMinimum() != null) {\n                property.exclusiveMinimum = np.getExclusiveMinimum();\n            }\n            if (np.getExclusiveMaximum() != null) {\n                property.exclusiveMaximum = np.getExclusiveMaximum();\n            }\n\n            \/\/ check if any validation rule defined\n            \/\/ exclusive* are noop without corresponding min\/max\n            if (property.minimum != null || property.maximum != null)\n                property.hasValidation = true;\n\n            \/\/ legacy support\n            Map<String, Object> allowableValues = new HashMap<String, Object>();\n            if (np.getMinimum() != null) {\n                allowableValues.put(\"min\", np.getMinimum());\n            }\n            if (np.getMaximum() != null) {\n                allowableValues.put(\"max\", np.getMaximum());\n            }\n            if(allowableValues.size() > 0) {\n                property.allowableValues = allowableValues;\n            }\n        }\n\n        if (p instanceof StringProperty) {\n            StringProperty sp = (StringProperty) p;\n            property.maxLength = sp.getMaxLength();\n            property.minLength = sp.getMinLength();\n            property.pattern = toRegularExpression(sp.getPattern());\n\n            \/\/ check if any validation rule defined\n            if (property.pattern != null || property.minLength != null || property.maxLength != null)\n                property.hasValidation = true;\n\n            property.isString = true;\n            if (sp.getEnum() != null) {\n                List<String> _enum = sp.getEnum();\n                property._enum = _enum;\n                property.isEnum = true;\n\n                \/\/ legacy support\n                Map<String, Object> allowableValues = new HashMap<String, Object>();\n                allowableValues.put(\"values\", _enum);\n                property.allowableValues = allowableValues;\n            }\n        }\n\n        \/\/ type is integer and without format\n        if (p instanceof BaseIntegerProperty && !(p instanceof IntegerProperty) && !(p instanceof LongProperty)) {\n            BaseIntegerProperty sp = (BaseIntegerProperty) p;\n            property.isInteger = true;\n            property.isNumeric = true;\n        }\n        if (p instanceof IntegerProperty) {\n            IntegerProperty sp = (IntegerProperty) p;\n            property.isInteger = true;\n            if (sp.getEnum() != null) {\n                List<Integer> _enum = sp.getEnum();\n                property._enum = new ArrayList<String>();\n                for(Integer i : _enum) {\n                    property._enum.add(i.toString());\n                }\n                property.isEnum = true;\n\n                \/\/ legacy support\n                Map<String, Object> allowableValues = new HashMap<String, Object>();\n                allowableValues.put(\"values\", _enum);\n                property.allowableValues = allowableValues;\n            }\n        }\n        if (p instanceof LongProperty) {\n            LongProperty sp = (LongProperty) p;\n            property.isLong = true;\n            property.isNumeric = true;\n            if (sp.getEnum() != null) {\n                List<Long> _enum = sp.getEnum();\n                property._enum = new ArrayList<String>();\n                for(Long i : _enum) {\n                    property._enum.add(i.toString());\n                }\n                property.isEnum = true;\n\n                \/\/ legacy support\n                Map<String, Object> allowableValues = new HashMap<String, Object>();\n                allowableValues.put(\"values\", _enum);\n                property.allowableValues = allowableValues;\n            }\n        }\n        if (p instanceof BooleanProperty) {\n            property.isBoolean = true;\n            property.getter = toBooleanGetter(name);\n        }\n        if (p instanceof BinaryProperty) {\n            property.isBinary = true;\n        }\n        if (p instanceof FileProperty) {\n            property.isFile = true;\n        }\n        if (p instanceof UUIDProperty) {\n            property.isString =true;\n            property.isUuid = true;\n\n        }\n        if (p instanceof ByteArrayProperty) {\n            property.isByteArray = true;\n        }\n        \/\/ type is number and without format\n        if (p instanceof DecimalProperty && !(p instanceof DoubleProperty) && !(p instanceof FloatProperty)) {\n            DecimalProperty sp = (DecimalProperty) p;\n            property.isNumber = true;\n        }\n        if (p instanceof DoubleProperty) {\n            DoubleProperty sp = (DoubleProperty) p;\n            property.isDouble = true;\n            property.isNumeric = true;\n            if (sp.getEnum() != null) {\n                List<Double> _enum = sp.getEnum();\n                property._enum = new ArrayList<String>();\n                for(Double i : _enum) {\n                    property._enum.add(i.toString());\n                }\n                property.isEnum = true;\n\n                \/\/ legacy support\n                Map<String, Object> allowableValues = new HashMap<String, Object>();\n                allowableValues.put(\"values\", _enum);\n                property.allowableValues = allowableValues;\n            }\n        }\n        if (p instanceof FloatProperty) {\n            FloatProperty sp = (FloatProperty) p;\n            property.isFloat = true;\n            property.isNumeric = true;\n            if (sp.getEnum() != null) {\n                List<Float> _enum = sp.getEnum();\n                property._enum = new ArrayList<String>();\n                for(Float i : _enum) {\n                    property._enum.add(i.toString());\n                }\n                property.isEnum = true;\n\n                \/\/ legacy support\n                Map<String, Object> allowableValues = new HashMap<String, Object>();\n                allowableValues.put(\"values\", _enum);\n                property.allowableValues = allowableValues;\n            }\n        }\n\n        if (p instanceof DateProperty) {\n            DateProperty sp = (DateProperty) p;\n            property.isDate = true;\n            if (sp.getEnum() != null) {\n                List<String> _enum = sp.getEnum();\n                property._enum = new ArrayList<String>();\n                for(String i : _enum) {\n                    property._enum.add(i);\n                }\n                property.isEnum = true;\n\n                \/\/ legacy support\n                Map<String, Object> allowableValues = new HashMap<String, Object>();\n                allowableValues.put(\"values\", _enum);\n                property.allowableValues = allowableValues;\n            }\n        }\n        if (p instanceof DateTimeProperty) {\n            DateTimeProperty sp = (DateTimeProperty) p;\n            property.isDateTime = true;\n            if (sp.getEnum() != null) {\n                List<String> _enum = sp.getEnum();\n                property._enum = new ArrayList<String>();\n                for(String i : _enum) {\n                    property._enum.add(i);\n                }\n                property.isEnum = true;\n\n                \/\/ legacy support\n                Map<String, Object> allowableValues = new HashMap<String, Object>();\n                allowableValues.put(\"values\", _enum);\n                property.allowableValues = allowableValues;\n            }\n        }\n        property.datatype = getTypeDeclaration(p);\n        property.dataFormat = p.getFormat();\n\n        \/\/ this can cause issues for clients which don't support enums\n        if (property.isEnum) {\n            property.datatypeWithEnum = toEnumName(property);\n            property.enumName = toEnumName(property);\n        } else {\n            property.datatypeWithEnum = property.datatype;\n        }\n\n        property.baseType = getSwaggerType(p);\n\n        if (p instanceof ArrayProperty) {\n            property.isContainer = true;\n            property.isListContainer = true;\n            property.containerType = \"array\";\n            property.baseType = getSwaggerType(p);\n            if (p.getXml() != null) {\n                property.isXmlWrapped = p.getXml().getWrapped() == null ? false : p.getXml().getWrapped();\n                property.xmlPrefix= p.getXml().getPrefix();\n                property.xmlNamespace = p.getXml().getNamespace();\n                property.xmlName = p.getXml().getName();\n            }\n            \/\/ handle inner property\n            ArrayProperty ap = (ArrayProperty) p;\n            property.maxItems = ap.getMaxItems();\n            property.minItems = ap.getMinItems();\n            String itemName = (String) p.getVendorExtensions().get(\"x-item-name\");\n            if (itemName == null) {\n                itemName = property.name;\n            }\n            CodegenProperty cp = fromProperty(itemName, ap.getItems());\n            updatePropertyForArray(property, cp);\n        } else if (p instanceof MapProperty) {\n            MapProperty ap = (MapProperty) p;\n\n            property.isContainer = true;\n            property.isMapContainer = true;\n            property.containerType = \"map\";\n            property.baseType = getSwaggerType(p);\n            property.minItems = ap.getMinProperties();\n            property.maxItems = ap.getMaxProperties();\n\n            \/\/ handle inner property\n            CodegenProperty cp = fromProperty(\"inner\", ap.getAdditionalProperties());\n            updatePropertyForMap(property, cp);\n        } else {\n            setNonArrayMapProperty(property, type);\n        }\n        return property;\n    }\n","new_comment_raw":"@param p OAS property object","old_comment_raw":"@param p Swagger property object","label":1,"pre_label":0,"AST_level":17,"line_counts":260,"new_code_token_num":1764},{"new_code_raw":"public boolean isFlagSet(int flagsToCheck) { return isFlagSet(flags, flagsToCheck); }","old_code_raw":"    public boolean isFlagSet(int flag) {\n        return (flags & flag) != 0;\n    }\n","new_comment_raw":"@param flagsToCheck the flags to check","old_comment_raw":"@param flag the flag to check","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":17},{"new_code_raw":"protected int addToolBarElements(JToolBar toolBar, Location location, int gridX) { return gridX; }","old_code_raw":"\tprotected int addToolBarElements(JToolBar panelToolbar2, Location loc, int gridX) {\n\t\t\/\/ Override to add elements into the toolbar\n\t\treturn gridX;\n\t}\n","new_comment_raw":"@param location the current location where elements will be added","old_comment_raw":"@param loc the current location where elements can be added","label":1,"pre_label":0,"AST_level":4,"line_counts":4,"new_code_token_num":18},{"new_code_raw":"public ApiResponse<Void> testInlineAdditionalPropertiesWithHttpInfo(Map<String, String> requestBody) throws ApiException { com.squareup.okhttp.Call call = testInlineAdditionalPropertiesValidateBeforeCall(requestBody, null, null); return apiClient.execute(call); }","old_code_raw":"    public ApiResponse<Void> testInlineAdditionalPropertiesWithHttpInfo(String requestBody) throws ApiException {\n        com.squareup.okhttp.Call call = testInlineAdditionalPropertiesValidateBeforeCall(requestBody, null, null);\n        return apiClient.execute(call);\n    }\n","new_comment_raw":"@param requestBody request body (required)","old_comment_raw":"@param requestBody request body (required)","label":0,"pre_label":1,"AST_level":7,"line_counts":5,"new_code_token_num":36},{"new_code_raw":"public Order placeOrder(Order order) throws ApiException { Object localVarPostBody = order; \/\/ verify the required parameter 'order' is set if (order == null) { throw new ApiException(400, \"Missing the required parameter 'order' when calling placeOrder\"); } \/\/ create path and map variables String localVarPath = \"\/store\/order\"; \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { \"application\/xml\", \"application\/json\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Order> localVarReturnType = new GenericType<Order>() {}; return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public Order placeOrder(Order body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    \/\/ verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling placeOrder\");\n    }\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/store\/order\";\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application\/xml\", \"application\/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Order> localVarReturnType = new GenericType<Order>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@param order order placed for purchasing the pet (required)","old_comment_raw":"@param body order placed for purchasing the pet (required)","label":1,"pre_label":0,"AST_level":8,"line_counts":36,"new_code_token_num":213},{"new_code_raw":"public static Point getCanvasTextLocation(Client client, Graphics2D graphics, LocalPoint localLocation, String text, int zOffset) { int plane = client.getPlane(); Point p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset); if (p == null) { return null; } FontMetrics fm = graphics.getFontMetrics(); Rectangle2D bounds = fm.getStringBounds(text, graphics); int xOffset = p.getX() - (int) (bounds.getWidth() \/ 2); return new Point(xOffset, p.getY()); }","old_code_raw":"\tpublic static Point getCanvasTextLocation(Client client, Graphics2D graphics, Point localLocation, String text, int zOffset)\n\t{\n\t\tint plane = client.getPlane();\n\n\t\tPoint p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset);\n\n\t\tif (p == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tFontMetrics fm = graphics.getFontMetrics();\n\t\tRectangle2D bounds = fm.getStringBounds(text, graphics);\n\t\tint xOffset = p.getX() - (int) (bounds.getWidth() \/ 2);\n\n\t\treturn new Point(xOffset, p.getY());\n\t}\n","new_comment_raw":"@param client","old_comment_raw":"@param client","label":0,"pre_label":1,"AST_level":8,"line_counts":18,"new_code_token_num":109},{"new_code_raw":"public QuoteAnnotator(String name, Properties props, boolean verbose) { USE_SINGLE = Boolean.parseBoolean(props.getProperty(name + \".\" + \"singleQuotes\", \"false\")); MAX_LENGTH = Integer.parseInt(props.getProperty(name + \".\" + \"maxLength\", \"-1\")); ASCII_QUOTES = Boolean.parseBoolean(props.getProperty(name + \".\" + \"asciiQuotes\", \"false\")); ALLOW_EMBEDDED_SAME = Boolean.parseBoolean(props.getProperty(name + \".\" + \"allowEmbeddedSame\", \"false\")); SMART_QUOTES = Boolean.parseBoolean(props.getProperty(name + \".\" + \"smartQuotes\", \"false\")); EXTRACT_UNCLOSED = Boolean.parseBoolean(props.getProperty(name + \".\" + \"extractUnclosedQuotes\", \"false\")); ATTRIBUTE_QUOTES = Boolean.parseBoolean(props.getProperty(name + \".\" + \"attributeQuotes\", \"true\")); VERBOSE = verbose; Timing timer = null; if (VERBOSE) { timer = new Timing(); log.info(\"Preparing quote annotator...\"); } if (ATTRIBUTE_QUOTES) quoteAttributionAnnotator = new QuoteAttributionAnnotator(props); if (VERBOSE) { timer.stop(\"done.\"); } }","old_code_raw":"  public QuoteAnnotator(Properties props, boolean verbose) {\n    USE_SINGLE = Boolean.parseBoolean(props.getProperty(\"singleQuotes\", \"false\"));\n    MAX_LENGTH = Integer.parseInt(props.getProperty(\"maxLength\", \"-1\"));\n    ASCII_QUOTES = Boolean.parseBoolean(props.getProperty(\"asciiQuotes\", \"false\"));\n    ALLOW_EMBEDDED_SAME = Boolean.parseBoolean(props.getProperty(\"allowEmbeddedSame\", \"false\"));\n    SMART_QUOTES = Boolean.parseBoolean(props.getProperty(\"smartQuotes\", \"false\"));\n    EXTRACT_UNCLOSED = Boolean.parseBoolean(props.getProperty(\"extractUnclosedQuotes\", \"false\"));\n    ATTRIBUTE_QUOTES = Boolean.parseBoolean(props.getProperty(\"attributeQuotes\", \"true\"));\n\n    VERBOSE = verbose;\n    Timing timer = null;\n    if (VERBOSE) {\n      timer = new Timing();\n      log.info(\"Preparing quote annotator...\");\n    }\n    if (ATTRIBUTE_QUOTES)\n      quoteAttributionAnnotator = new QuoteAttributionAnnotator(props);\n\n    if (VERBOSE) {\n      timer.stop(\"done.\");\n    }\n  }\n","new_comment_raw":"@param props Properties object that contains the customizable properties attributes.","old_comment_raw":"@param props Properties object that contains the customizable properties attributes.","label":0,"pre_label":1,"AST_level":9,"line_counts":23,"new_code_token_num":223},{"new_code_raw":"public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); final String url = buildUrl(path, queryParams); final Request.Builder reqBuilder = new Request.Builder().url(url); processHeaderParams(headerParams, reqBuilder); String contentType = (String) headerParams.get(\"Content-Type\"); \/\/ ensuring a default content type if (contentType == null) contentType = \"application\/json\"; RequestBody reqBody; if (!HttpMethod.permitsRequestBody(method)) { reqBody = null; } else if (\"application\/x-www-form-urlencoded\".equals(contentType)) { reqBody = buildRequestBodyFormEncoding(formParams); } else if (\"multipart\/form-data\".equals(contentType)) { reqBody = buildRequestBodyMultipart(formParams); } else if (body == null) { if (\"DELETE\".equals(method)) { \/\/ allow calling DELETE without sending a request body reqBody = null; } else { \/\/ use an empty request body (for POST, PUT and PATCH) reqBody = RequestBody.create(MediaType.parse(contentType), \"\"); } } else { reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType)); } Request request = reqBuilder.method(method, reqBody).build(); return httpClient.newCall(request); }","old_code_raw":"  public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    final String url = buildUrl(path, queryParams);\n    final Request.Builder reqBuilder = new Request.Builder().url(url);\n    processHeaderParams(headerParams, reqBuilder);\n\n    String contentType = (String) headerParams.get(\"Content-Type\");\n    \/\/ ensuring a default content type\n    if (contentType == null) contentType = \"application\/json\";\n\n    RequestBody reqBody;\n    if (!HttpMethod.permitsRequestBody(method)) {\n      reqBody = null;\n    } else if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n      reqBody = buildRequestBodyFormEncoding(formParams);\n    } else if (\"multipart\/form-data\".equals(contentType)) {\n      reqBody = buildRequestBodyMultipart(formParams);\n    } else if (body == null) {\n      if (\"DELETE\".equals(method)) {\n        \/\/ allow calling DELETE without sending a request body\n        reqBody = null;\n      } else {\n        \/\/ use an empty request body (for POST, PUT and PATCH)\n        reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n      }\n    } else {\n      reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType));\n    }\n\n    Request request = null;\n\n    if(progressRequestListener != null && reqBody != null) {\n      ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, progressRequestListener);\n      request = reqBuilder.method(method, progressRequestBody).build();\n    } else {\n      request = reqBuilder.method(method, reqBody).build();\n    }\n\n    return httpClient.newCall(request);\n  }\n","new_comment_raw":"@param method The request method, one of \"GET\", \"HEAD\", \"OPTIONS\", \"POST\", \"PUT\", \"PATCH\" and \"DELETE\"","old_comment_raw":"@param method The request method, one of \"GET\", \"HEAD\", \"OPTIONS\", \"POST\", \"PUT\", \"PATCH\" and \"DELETE\"","label":0,"pre_label":1,"AST_level":14,"line_counts":34,"new_code_token_num":285},{"new_code_raw":"public BufferedImage getImage(int itemId, int quantity, boolean stackable) { try { return itemImages.get(new ImageKey(itemId, quantity, stackable)); } catch (ExecutionException ex) { return null; } }","old_code_raw":"\tpublic BufferedImage getImage(int itemId, int quantity)\n\t{\n\t\ttry\n\t\t{\n\t\t\treturn itemImages.get(itemId | (quantity << 16));\n\t\t}\n\t\tcatch (ExecutionException ex)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t}\n","new_comment_raw":"@param quantity","old_comment_raw":"@param quantity","label":0,"pre_label":1,"AST_level":7,"line_counts":12,"new_code_token_num":43},{"new_code_raw":"protected String determineSegmentColumnName(Properties params, JdbcEnvironment jdbcEnvironment) { final String name = ConfigurationHelper.getString( SEGMENT_COLUMN_PARAM, params, DEF_SEGMENT_COLUMN ); return jdbcEnvironment.getIdentifierHelper().toIdentifier( name ).render( jdbcEnvironment.getDialect() ); }","old_code_raw":"\tprotected String determineSegmentColumnName(Properties params, Dialect dialect) {\n\t\tfinal ObjectNameNormalizer normalizer = (ObjectNameNormalizer) params.get( IDENTIFIER_NORMALIZER );\n\t\tfinal String name = ConfigurationHelper.getString( SEGMENT_COLUMN_PARAM, params, DEF_SEGMENT_COLUMN );\n\t\treturn normalizer.toDatabaseIdentifierText( name );\n\t}\n","new_comment_raw":"@param jdbcEnvironment The JDBC environment","old_comment_raw":"@param dialect The dialect in effect","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":42},{"new_code_raw":"public void redirectOutput(){ if (System.getenv(\"REDIRECT\") == null || !System.getenv(\"REDIRECT\").equals(\"true\")) { return; } String DEFAULT_OUT_TARGET_FILE = JStormUtils.getLogFileName(); if (DEFAULT_OUT_TARGET_FILE == null) { DEFAULT_OUT_TARGET_FILE = \"\/dev\/null\"; } else { DEFAULT_OUT_TARGET_FILE += \".out\"; } String outputFile = ConfigExtension.getWorkerRedirectOutputFile(workerData.getStormConf()); if (outputFile == null) { outputFile = DEFAULT_OUT_TARGET_FILE; }else { try { File file = new File(outputFile); if (file.exists() == false) { PathUtils.touch(outputFile); }else { if (file.isDirectory() == true) { LOG.warn(\"Failed to write \" + outputFile); outputFile = DEFAULT_OUT_TARGET_FILE; }else if (file.canWrite() == false) { LOG.warn(\"Failed to write \" + outputFile); outputFile = DEFAULT_OUT_TARGET_FILE; } } }catch(Exception e) { LOG.warn(\"Failed to touch \" + outputFile, e); outputFile = DEFAULT_OUT_TARGET_FILE; } } try { JStormUtils.redirectOutput(outputFile); }catch(Exception e) { LOG.warn(\"Failed to redirect to \" + outputFile, e); } }","old_code_raw":"\tpublic static void redirectOutput(String port) throws Exception {\n\n\t\tif (System.getenv(\"REDIRECT\") == null\n\t\t\t\t|| !System.getenv(\"REDIRECT\").equals(\"true\")) {\n\t\t\treturn;\n\t\t}\n\n\t\tString OUT_TARGET_FILE = JStormUtils.getLogFileName();\n\t\tif (OUT_TARGET_FILE == null) {\n\t\t\tOUT_TARGET_FILE = \"\/dev\/null\";\n\t\t} else {\n\t\t\tOUT_TARGET_FILE += \".out\";\n\t\t}\n\n\t\tJStormUtils.redirectOutput(OUT_TARGET_FILE);\n\n\t}\n","new_comment_raw":"@param worker_id","old_comment_raw":"@param worker_id","label":0,"pre_label":1,"AST_level":14,"line_counts":46,"new_code_token_num":229},{"new_code_raw":"public String runHTMLSuite(String browser, String browserURL, String HTMLSuite, File outputFile, int timeoutInSeconds, boolean multiWindow) throws IOException { long timeoutInMs = 1000 * timeoutInSeconds; server.handleHTMLRunnerResults(this); BrowserLauncherFactory blf = new BrowserLauncherFactory(server); String sessionId = Long.toString(System.currentTimeMillis() % 1000000); BrowserLauncher launcher = blf.getBrowserLauncher(browser, sessionId, null); launcher.launchHTMLSuite(HTMLSuite, browserURL, multiWindow); long now = System.currentTimeMillis(); long end = now + timeoutInMs; while (results == null && System.currentTimeMillis() < end) { AsyncExecute.sleepTight(500); } launcher.close(); if (results == null) { throw new SeleniumCommandTimedOutException(); } if (outputFile != null) { FileWriter fw = new FileWriter(outputFile); results.write(fw); fw.close(); } return results.getResult().toUpperCase(); }","old_code_raw":"    public String runHTMLSuite(String browser, String browserURL, String HTMLSuite, File outputFile, long timeoutInMs, boolean multiWindow) throws IOException {\n        server.handleHTMLRunnerResults(this);\n        BrowserLauncherFactory blf = new BrowserLauncherFactory(server);\n        String sessionId = Long.toString(System.currentTimeMillis() % 1000000);\n        BrowserLauncher launcher = blf.getBrowserLauncher(browser, sessionId, null);\n        launcher.launchHTMLSuite(HTMLSuite, browserURL, multiWindow);\n        long now = System.currentTimeMillis();\n        long end = now + timeoutInMs;\n        while (results == null && System.currentTimeMillis() < end) {\n            AsyncExecute.sleepTight(500);\n        }\n        launcher.close();\n        if (results == null) {\n            throw new SeleniumCommandTimedOutException();\n        }\n        if (outputFile != null) {\n            FileWriter fw = new FileWriter(outputFile);\n            results.write(fw);\n            fw.close();\n        }\n        \n        return results.getResult().toUpperCase();\n    }\n","new_comment_raw":"@param outputFile - The file to which we'll output the HTML results","old_comment_raw":"@param outputFile - The file to which we'll output the HTML results","label":0,"pre_label":1,"AST_level":8,"line_counts":25,"new_code_token_num":168},{"new_code_raw":"public TimeOfDay setCopy(String text) { return setCopy(text, null); }","old_code_raw":"        public TimeOfDay setCopy(int value) {\n            int[] newValues = getField().set(iInstant, iFieldIndex, value);\n            return new TimeOfDay(iInstant, newValues);\n        }\n","new_comment_raw":"@param text the text value to set","old_comment_raw":"@param value the value to set the field in the copy to","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":17},{"new_code_raw":"public PendingMessageCursor getSubscriberPendingMessageCursor(Broker broker,String name,int maxBatchSize,Subscription subs) { return new VMPendingMessageCursor(AbstractPendingMessageCursor.isPrioritizedMessageSubscriber(broker, subs)); }","old_code_raw":"    public PendingMessageCursor getSubscriberPendingMessageCursor(Broker broker,String name,int maxBatchSize) {\n        return new VMPendingMessageCursor();\n    }\n","new_comment_raw":"@param broker","old_comment_raw":"@param broker","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":31},{"new_code_raw":"public static LdapContext createPathContext( LdapContext authorityContext, String[] pathTokens) throws NamingException { for (int i = 1; i < (pathTokens.length); i++) { String subContext = CN + \"=\" + pathTokens[i]; authorityContext = (LdapContext) createSubContext( authorityContext, subContext, null ); } return authorityContext; }","old_code_raw":"    public static LdapContext createPathContext(\n    \t\tLdapContext ldapContext, \n        String[] pathTokens) \n    throws NamingException\n    {\n        for (int i = 1; i < (pathTokens.length); i++)\n        {\n            String subContext = CN + \"=\" + pathTokens[i];\n            ldapContext = (LdapContext) createSubContext( \n            \t\tldapContext, \n            \t\tsubContext, null );\n        }\n        return ldapContext;\n    }\n","new_comment_raw":"@param authorityContext the ldap context","old_comment_raw":"@param ldapContext the dir context","label":1,"pre_label":0,"AST_level":10,"line_counts":16,"new_code_token_num":63},{"new_code_raw":"protected Connection getConnection(IBasicRequest request) { Logger.d(\"--------------Request start--------------\"); Headers responseHeaders = new HttpHeaders(); InputStream inputStream = null; Exception exception = null; HttpURLConnection urlConnection = null; String url = request.url(); try { if (!NetUtil.isNetworkAvailable()) throw new NetworkError(\"The network is not available, please check the network. The requested url is: \" + url); \/\/ MalformedURLException, IOException, ProtocolException, UnknownHostException, SocketTimeoutException urlConnection = createConnectionAndWriteData(request); Logger.d(\"-------Response start-------\"); int responseCode = urlConnection.getResponseCode(); responseHeaders = parseResponseHeaders(new URI(request.url()), responseCode, urlConnection.getResponseMessage(), urlConnection.getHeaderFields()); \/\/ handle body if (responseCode == 301 || responseCode == 302 || responseCode == 303 || responseCode == 307) { Connection redirectConnection = handleRedirect(request, responseHeaders); responseHeaders = redirectConnection.responseHeaders(); inputStream = redirectConnection.serverStream(); exception = redirectConnection.exception(); } else if (hasResponseBody(request.getRequestMethod(), responseCode)) { inputStream = getServerStream(responseCode, responseHeaders.getContentEncoding(), urlConnection); } Logger.d(\"-------Response end-------\"); } catch (MalformedURLException e) { exception = new URLError(\"The url is malformed: \" + url + \".\"); } catch (UnknownHostException e) { exception = new UnKnownHostError(\"Hostname can not be resolved: \" + url + \".\"); } catch (SocketTimeoutException e) { exception = new TimeoutError(\"Request time out: \" + url + \".\"); } catch (Exception e) { exception = e; } finally { if (exception != null) Logger.e(exception); } Logger.d(\"--------------Request finish--------------\"); return new Connection(urlConnection, responseHeaders, inputStream, exception); }","old_code_raw":"    protected Connection getConnection(BasicServerRequest request) {\n        Logger.d(\"--------------Request start--------------\");\n\n        Headers responseHeaders = new HttpHeaders();\n        InputStream inputStream = null;\n        Exception exception = null;\n\n        HttpURLConnection urlConnection = null;\n        String url = request.url();\n        try {\n            if (!NetUtil.isNetworkAvailable())\n                throw new NetworkError(\"The network is not available, please check the network. The requested url is: \" + url);\n\n            \/\/ MalformedURLException, IOException, ProtocolException, UnknownHostException, SocketTimeoutException\n            urlConnection = createHttpURLConnection(request);\n            Logger.d(\"-------Response start-------\");\n            int responseCode = urlConnection.getResponseCode();\n            responseHeaders = parseResponseHeaders(new URI(request.url()), responseCode, urlConnection.getResponseMessage(), urlConnection.getHeaderFields());\n\n            \/\/ handle body\n            if (responseCode == 301 || responseCode == 302 || responseCode == 303 || responseCode == 307) {\n                Connection redirectConnectiont = handleRedirect(request, responseHeaders);\n                responseHeaders = redirectConnectiont.responseHeaders();\n                inputStream = redirectConnectiont.serverStream();\n                exception = redirectConnectiont.exception();\n            } else if (hasResponseBody(request.getRequestMethod(), responseCode)) {\n                inputStream = getServerStream(responseCode, responseHeaders.getContentEncoding(), urlConnection);\n            }\n            Logger.d(\"-------Response end-------\");\n        } catch (MalformedURLException e) {\n            exception = new URLError(\"The url is malformed: \" + url + \".\");\n        } catch (UnknownHostException e) {\n            exception = new UnKnownHostError(\"Hostname can not be resolved: \" + url + \".\");\n        } catch (SocketTimeoutException e) {\n            exception = new TimeoutError(\"Request time out: \" + url + \".\");\n        } catch (Exception e) {\n            exception = e;\n        } finally {\n            if (exception != null)\n                Logger.e(exception);\n        }\n        Logger.d(\"--------------Request finish--------------\");\n        return new Connection(urlConnection, responseHeaders, inputStream, exception);\n    }\n","new_comment_raw":"@param request  IBasicRequest.","old_comment_raw":"@param request ImplServerRequest.","label":1,"pre_label":0,"AST_level":10,"line_counts":45,"new_code_token_num":431},{"new_code_raw":"public boolean isUpToDate(Set<Serializable> spaces, Long timestamp, SharedSessionContractImplementor session) throws CacheException { final boolean stats = factory != null && factory.getStatistics().isStatisticsEnabled(); for ( Serializable space : spaces ) { final Long lastUpdate = getLastUpdateTimestampForSpace( space, session ); if ( lastUpdate == null ) { if ( stats ) { factory.getStatistics().updateTimestampsCacheMiss(); } \/\/the last update timestamp was lost from the cache \/\/(or there were no updates since startup!) \/\/updateTimestamps.put( space, new Long( updateTimestamps.nextTimestamp() ) ); \/\/result = false; \/\/ safer } else { if ( DEBUG_ENABLED ) { LOG.debugf( \"[%s] last update timestamp: %s\", space, lastUpdate + \", result set timestamp: \" + timestamp ); } if ( stats ) { factory.getStatistics().updateTimestampsCacheHit(); } if ( lastUpdate >= timestamp ) { return false; } } } return true; }","old_code_raw":"\tpublic boolean isUpToDate(Set<Serializable> spaces, Long timestamp, SessionImplementor session) throws CacheException {\n\t\tfinal boolean stats = factory != null && factory.getStatistics().isStatisticsEnabled();\n\n\t\tfor ( Serializable space : spaces ) {\n\t\t\tfinal Long lastUpdate = getLastUpdateTimestampForSpace( space, session );\n\t\t\tif ( lastUpdate == null ) {\n\t\t\t\tif ( stats ) {\n\t\t\t\t\tfactory.getStatisticsImplementor().updateTimestampsCacheMiss();\n\t\t\t\t}\n\t\t\t\t\/\/the last update timestamp was lost from the cache\n\t\t\t\t\/\/(or there were no updates since startup!)\n\t\t\t\t\/\/updateTimestamps.put( space, new Long( updateTimestamps.nextTimestamp() ) );\n\t\t\t\t\/\/result = false; \/\/ safer\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( DEBUG_ENABLED ) {\n\t\t\t\t\tLOG.debugf(\n\t\t\t\t\t\t\t\"[%s] last update timestamp: %s\",\n\t\t\t\t\t\t\tspace,\n\t\t\t\t\t\t\tlastUpdate + \", result set timestamp: \" + timestamp\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif ( stats ) {\n\t\t\t\t\tfactory.getStatisticsImplementor().updateTimestampsCacheHit();\n\t\t\t\t}\n\t\t\t\tif ( lastUpdate >= timestamp ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n","new_comment_raw":"@param timestamp The timestamp against which to check.","old_comment_raw":"@param timestamp The timestamp against which to check.","label":0,"pre_label":1,"AST_level":13,"line_counts":33,"new_code_token_num":189},{"new_code_raw":"protected String[] convert(Path<?> leftHandSide, Object rightHandSide) { String str = rightHandSide.toString(); if (lowerCase){ str = str.toLowerCase(); } if (splitTerms) { if (str.equals(\"\")) { return new String[] { str }; } else { return StringUtils.split(str); } } else { return new String[] { str }; } }","old_code_raw":"    protected String convert(Path<?> path, Object value){\n        return value.toString();\n    }\n","new_comment_raw":"@param leftHandSide","old_comment_raw":"@param object","label":1,"pre_label":0,"AST_level":10,"line_counts":16,"new_code_token_num":82},{"new_code_raw":"private boolean searchForToggleButton(String regex, int matches) { sleeper.sleep(); inst.waitForIdleSync(); Pattern p = Pattern.compile(regex); Matcher matcher; ArrayList<ToggleButton> toggleButtonList = viewFetcher.getCurrentViews(ToggleButton.class); if(matches == 0) matches = 1; for(ToggleButton toggleButton : toggleButtonList){ matcher = p.matcher(toggleButton.getText().toString()); if(matcher.find()){ countMatches++; } if (countMatches == matches) { countMatches=0; return true; } } if (scroller.scroll(Scroller.Direction.DOWN)) { return searchForToggleButton(regex, matches); } else { if(countMatches > 0) Log.d(LOG_TAG, \" There are only \" + countMatches + \" matches of \" + regex); countMatches = 0; return false; } }","old_code_raw":"\tprivate boolean searchForToggleButton(String search, int matches) {\n\t\tsleeper.sleep();\n\t\tinst.waitForIdleSync();\n\t\tPattern p = Pattern.compile(search);\n\t\tMatcher matcher;\n\t\tArrayList<ToggleButton> toggleButtonList = viewFetcher.getCurrentViews(ToggleButton.class);\n\t\tif(matches == 0)\n\t\t\tmatches = 1;\n\t\tfor(ToggleButton toggleButton : toggleButtonList){\n\t\t\tmatcher = p.matcher(toggleButton.getText().toString());\n\t\t\tif(matcher.find()){\t\n\t\t\t\tcountMatches++;\n\t\t\t}\n\t\t\tif (countMatches == matches) {\n\t\t\t\tcountMatches=0;\n\t\t\t\treturn true;\n\t\t\t} \n\t\t}\n\n\t\tif (scroller.scroll(Scroller.Direction.DOWN))\n\t\t{\n\t\t\treturn searchForToggleButton(search, matches);\n\t\t} else {\n\t\t\tif(countMatches > 0)\n\t\t\t\tLog.d(LOG_TAG, \" There are only \" + countMatches + \" matches of \" + search);\n\t\t\tcountMatches = 0;\n\t\t\treturn false;\n\t\t}\n\t\t\n\t}\n","new_comment_raw":"@param matches the number of matches expected to be found. 0 matches means that one or more matches are expected to be found","old_comment_raw":"@param matches the number of matches expected to be found. 0 matches means that one or more matches are expected to be found","label":0,"pre_label":1,"AST_level":11,"line_counts":31,"new_code_token_num":154},{"new_code_raw":"private ClientResponse makeRemoteCall(Action action, String serviceUrl) throws Throwable { String urlPath = null; Stopwatch tracer = null; ClientResponse response = null; logger.debug(\"Discovery Client talking to the server {}\", serviceUrl); try { \/\/ If the application is unknown do not register\/renew\/cancel but \/\/ refresh if ((UNKNOWN.equals(instanceInfo.getAppName()) && (!Action.Refresh.equals(action)) && (!Action.Refresh_Delta .equals(action)))) { return null; } WebResource r = discoveryApacheClient.resource(serviceUrl); String remoteRegionsToFetchStr; switch (action) { case Renew: tracer = RENEW_TIMER.start(); urlPath = \"apps\/\" + appPathIdentifier; response = r .path(urlPath) .queryParam(\"status\", instanceInfo.getStatus().toString()) .queryParam(\"lastDirtyTimestamp\", instanceInfo.getLastDirtyTimestamp().toString()) .put(ClientResponse.class); break; case Refresh: tracer = REFRESH_TIMER.start(); final String vipAddress = clientConfig.getRegistryRefreshSingleVipAddress(); urlPath = vipAddress == null ? \"apps\/\" : \"vips\/\" + vipAddress; remoteRegionsToFetchStr = remoteRegionsToFetch.get(); if (!Strings.isNullOrEmpty(remoteRegionsToFetchStr)) { urlPath += \"?regions=\" + remoteRegionsToFetchStr; } response = getUrl(serviceUrl + urlPath); break; case Refresh_Delta: tracer = REFRESH_DELTA_TIMER.start(); urlPath = \"apps\/delta\"; remoteRegionsToFetchStr = remoteRegionsToFetch.get(); if (!Strings.isNullOrEmpty(remoteRegionsToFetchStr)) { urlPath += \"?regions=\" + remoteRegionsToFetchStr; } response = getUrl(serviceUrl + urlPath); break; case Register: tracer = REGISTER_TIMER.start(); urlPath = \"apps\/\" + instanceInfo.getAppName(); response = r.path(urlPath) .type(MediaType.APPLICATION_JSON_TYPE) .post(ClientResponse.class, instanceInfo); break; case Cancel: tracer = CANCEL_TIMER.start(); urlPath = \"apps\/\" + appPathIdentifier; response = r.path(urlPath).delete(ClientResponse.class); \/\/ Return without during de-registration if it is not registered \/\/ already and if we get a 404 if ((!isRegisteredWithDiscovery) && (response.getStatus() == Status.NOT_FOUND .getStatusCode())) { return response; } break; } if (logger.isDebugEnabled()) { logger.debug(\"Finished a call to service url {} and url path {} with status code {}.\", new String[] {serviceUrl, urlPath, String.valueOf(response.getStatus())}); } if (isOk(action, response.getStatus())) { return response; } else { logger.warn(\"Action: \" + action + \" => returned status of \" + response.getStatus() + \" from \" + serviceUrl + urlPath); throw new RuntimeException(\"Bad status: \" + response.getStatus()); } } catch (Throwable t) { closeResponse(response); logger.warn(\"Can't get a response from \" + serviceUrl + urlPath, t); throw t; } finally { if (tracer != null) { tracer.stop(); } } }","old_code_raw":"    private ClientResponse makeRemoteCall(Action action, int serviceUrlIndex)\n            throws Throwable {\n        String urlPath = null;\n        Stopwatch tracer = null;\n        String serviceUrl = eurekaServiceUrls.get().get(serviceUrlIndex);\n        ClientResponse response = null;\n        logger.debug(\"Discovery Client talking to the server {}\", serviceUrl);\n        try {\n            \/\/ If the application is unknown do not register\/renew\/cancel but\n            \/\/ refresh\n            if ((UNKNOWN.equals(instanceInfo.getAppName())\n                    && (!Action.Refresh.equals(action)) && (!Action.Refresh_Delta\n                    .equals(action)))) {\n                return null;\n            }\n            WebResource r = discoveryApacheClient.resource(serviceUrl);\n            String remoteRegionsToFetchStr;\n            switch (action) {\n            case Renew:\n                tracer = RENEW_TIMER.start();\n                urlPath = \"apps\/\" + appPathIdentifier;\n                response = r\n                        .path(urlPath)\n                        .queryParam(\"status\",\n                                instanceInfo.getStatus().toString())\n                        .queryParam(\"lastDirtyTimestamp\",\n                                instanceInfo.getLastDirtyTimestamp().toString())\n                        .put(ClientResponse.class);\n                break;\n            case Refresh:\n                tracer = REFRESH_TIMER.start();\n                final String vipAddress = clientConfig.getRegistryRefreshSingleVipAddress();\n                urlPath = vipAddress == null ? \"apps\/\" : \"vips\/\" + vipAddress;\n                remoteRegionsToFetchStr = remoteRegionsToFetch.get();\n                if (!Strings.isNullOrEmpty(remoteRegionsToFetchStr)) {\n                    urlPath += \"?regions=\" + remoteRegionsToFetchStr;\n                }\n                response = getUrl(serviceUrl + urlPath);\n                break;\n            case Refresh_Delta:\n                tracer = REFRESH_DELTA_TIMER.start();\n                urlPath = \"apps\/delta\";\n                remoteRegionsToFetchStr = remoteRegionsToFetch.get();\n                if (!Strings.isNullOrEmpty(remoteRegionsToFetchStr)) {\n                    urlPath += \"?regions=\" + remoteRegionsToFetchStr;\n                }\n                response = getUrl(serviceUrl + urlPath);\n                break;\n            case Register:\n                tracer = REGISTER_TIMER.start();\n                urlPath = \"apps\/\" + instanceInfo.getAppName();\n                response = r.path(urlPath)\n                        .type(MediaType.APPLICATION_JSON_TYPE)\n                        .post(ClientResponse.class, instanceInfo);\n                break;\n            case Cancel:\n                tracer = CANCEL_TIMER.start();\n                urlPath = \"apps\/\" + appPathIdentifier;\n                response = r.path(urlPath).delete(ClientResponse.class);\n                \/\/ Return without during de-registration if it is not registered\n                \/\/ already and if we get a 404\n                if ((!isRegisteredWithDiscovery)\n                        && (response.getStatus() == Status.NOT_FOUND\n                                .getStatusCode())) {\n                    return response;\n                }\n                break;\n            }\n\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Finished a call to service url {} and url path {} with status code {}.\",\n                            new String[] {serviceUrl, urlPath, String.valueOf(response.getStatus())});\n            }\n            if (isOk(action, response.getStatus())) {\n                return response;\n            } else {\n                logger.warn(\"Action: \" + action + \"  => returned status of \"\n                        + response.getStatus() + \" from \" + serviceUrl\n                        + urlPath);\n                throw new RuntimeException(\"Bad status: \"\n                        + response.getStatus());\n            }\n        } catch (Throwable t) {\n            closeResponse(response);\n            String msg = \"Can't get a response from \" + serviceUrl + urlPath;\n            if (eurekaServiceUrls.get().size() > (++serviceUrlIndex)) {\n                logger.warn(msg, t);\n                logger.warn(\"Trying backup: \"\n                        + eurekaServiceUrls.get().get(serviceUrlIndex));\n                SERVER_RETRY_COUNTER.increment();\n                return makeRemoteCall(action, serviceUrlIndex);\n            } else {\n                ALL_SERVER_FAILURE_COUNT.increment();\n                logger.error(\n                        msg\n                                + \"\\nCan't contact any eureka nodes - possibly a security group issue?\",\n                        t);\n                throw t;\n            }\n        } finally {\n            if (tracer != null) {\n                tracer.stop();\n            }\n        }\n    }\n","new_comment_raw":"@param action the action to be performed on eureka server.","old_comment_raw":"@param action the action to be performed on eureka server. Try the fallback servers in case of problems communicating to the primary one.","label":1,"pre_label":0,"AST_level":14,"line_counts":91,"new_code_token_num":590},{"new_code_raw":"public Actions clickAndHold(WebElement target) { if (isBuildingActions()) { action.addAction(new ClickAndHoldAction(jsonMouse, (Locatable) target)); return this; } return moveToElement(target).clickAndHold(); }","old_code_raw":"  public Actions clickAndHold(WebElement onElement) {\n    action.addAction(new ClickAndHoldAction(mouse, (Locatable) onElement));\n    return this;\n  }\n","new_comment_raw":"@param target Element to move to and click.","old_comment_raw":"@param onElement Element to move to and click.","label":1,"pre_label":0,"AST_level":9,"line_counts":8,"new_code_token_num":44},{"new_code_raw":"public boolean searchButton(String regex, int matches) { boolean found = searcher.searchButton(regex, matches); return found; }","old_code_raw":"\tpublic boolean searchButton(String search, int matches) {\n\t\tboolean found = searcher.searchButton(search, matches);\n\t\treturn found;\n\n\t}\n","new_comment_raw":"@param regex the text to search for. The parameter will be interpreted as a regular expression.","old_comment_raw":"@param search the string to be searched. The parameter will be interpreted as a regular expression.","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":25},{"new_code_raw":"public static IType createType(IASTDeclarator declarator) { IASTDeclSpecifier declSpec = null; IASTNode node = declarator.getParent(); while( node instanceof IASTDeclarator ){ declarator = (IASTDeclarator) node; node = node.getParent(); } if( node instanceof IASTParameterDeclaration ) declSpec = ((IASTParameterDeclaration) node).getDeclSpecifier(); else if( node instanceof IASTSimpleDeclaration ) declSpec = ((IASTSimpleDeclaration)node).getDeclSpecifier(); else if( node instanceof IASTFunctionDefinition ) declSpec = ((IASTFunctionDefinition)node).getDeclSpecifier(); else if( node instanceof IASTTypeId ) declSpec = ((IASTTypeId)node).getDeclSpecifier(); boolean isParameter = ( node instanceof IASTParameterDeclaration || node.getParent() instanceof ICASTKnRFunctionDeclarator ); IType type = null; \/\/C99 6.7.5.3-12 The storage class specifier for a parameter declaration is ignored unless the declared parameter is one of the \/\/members of the parameter type list for a function definition. if( isParameter && node.getParent().getParent() instanceof IASTFunctionDefinition ){ type = createBaseType( declSpec ); } else { type = createType( declSpec ); } type = createType( type, declarator ); if( isParameter ) { \/\/C99: 6.7.5.3-7 a declaration of a parameter as \"array of type\" shall be adjusted to \"qualified pointer to type\", where the \/\/type qualifiers (if any) are those specified within the [ and ] of the array type derivation if( type instanceof IArrayType ){ CArrayType at = (CArrayType) type; type = new CQualifiedPointerType( at.getType(), at.getModifier() ); } else if( type instanceof IFunctionType ) { \/\/-8 A declaration of a parameter as \"function returning type\" shall be adjusted to \"pointer to function returning type\" type = new CPointerType( type ); } } return type; }","old_code_raw":"\tpublic static IType createType(IASTName name) {\n\t\tif (!(name.getParent() instanceof IASTDeclarator)) return null;\n\t\t\n\t    IASTDeclSpecifier declSpec = null;\n\t\tIASTDeclarator declarator = (IASTDeclarator) name.getParent();\n\t\t\n\t\tIASTNode node = declarator.getParent();\n\t\twhile( node instanceof IASTDeclarator ){\n\t\t\tdeclarator = (IASTDeclarator) node;\n\t\t\tnode = node.getParent();\n\t\t}\n\t\t\n\t\tif( node instanceof IASTParameterDeclaration )\n\t\t\tdeclSpec = ((IASTParameterDeclaration) node).getDeclSpecifier();\n\t\telse if( node instanceof IASTSimpleDeclaration )\n\t\t\tdeclSpec = ((IASTSimpleDeclaration)node).getDeclSpecifier();\n\t\telse if( node instanceof IASTFunctionDefinition )\n\t\t\tdeclSpec = ((IASTFunctionDefinition)node).getDeclSpecifier();\n\t\telse if( node instanceof IASTTypeId )\n\t\t    declSpec = ((IASTTypeId)node).getDeclSpecifier();\n\t\n\t\tboolean isParameter = ( node instanceof IASTParameterDeclaration || node.getParent() instanceof ICASTKnRFunctionDeclarator ); \n\t\t\n\t\tIType type = null;\n\t\t\n\t\t\/\/C99 6.7.5.3-12 The storage class specifier for a parameter declaration is ignored unless the declared parameter is one of the \n\t\t\/\/members of the parameter type list for a function definition.\n\t\tif( isParameter && node.getParent().getParent() instanceof IASTFunctionDefinition ){\n\t\t    type = createBaseType( declSpec );\n\t\t} else {\n\t\t    type = createType( declSpec );\n\t\t}\n\t\t\n\t\ttype = createType( type, declarator );\n\t\t\n\t\t\n        if( isParameter ) {\n            \/\/C99: 6.7.5.3-7 a declaration of a parameter as \"array of type\" shall be adjusted to \"qualified pointer to type\", where the\n    \t\t\/\/type qualifiers (if any) are those specified within the [ and ] of the array type derivation\n            if( type instanceof IArrayType ){\n\t            CArrayType at = (CArrayType) type;\n\t            type = new CQualifiedPointerType( at.getType(), at.getModifier() );\n\t        } else if( type instanceof IFunctionType ) {\n\t            \/\/-8 A declaration of a parameter as \"function returning type\" shall be adjusted to \"pointer to function returning type\"\n\t            type = new CPointerType( type );\n\t        }\n        }\n        \n\t\treturn type;\n\t}\n","new_comment_raw":"@param declarator the IASTDeclarator whose IType will be created","old_comment_raw":"@param name the IASTName whose IType will be created","label":1,"pre_label":0,"AST_level":11,"line_counts":49,"new_code_token_num":347},{"new_code_raw":"@Override public int onReceiveLiquid(int type,int vol, byte side) { if(type == this.type) { int rejectedVolume = Math.max((this.getStoredLiquid(type) + vol) - this.capacity, 0); this.liquidStored = vol - rejectedVolume; return rejectedVolume; } return vol; }","old_code_raw":"\t@Override\n\tpublic int onReceiveLiquid(int type,int amt, byte side)\n\t{\n\t\tif(type == this.type)\n\t\t{\n\t\tint rejectedLiquid = Math.max((this.getStoredLiquid(type) + amt) - this.capacity, 0);\n\t\t this.liquidStored += watt - rejectedElectricity;\n\t\treturn rejectedLiquid;\n\t\t}\n\t\treturn watt;\n\t}\n","new_comment_raw":"@param vols - The amount of vol this block recieved","old_comment_raw":"@param watts - The amount of watt this block recieved","label":1,"pre_label":0,"AST_level":12,"line_counts":13,"new_code_token_num":58},{"new_code_raw":"public static StandardProperty buildStandardProperty(AttributeBinding property, boolean lazyAvailable) { final Type type = property.getHibernateTypeDescriptor().getExplicitType(); \/\/ we need to dirty check collections, since they can cause an owner \/\/ version number increment \/\/ we need to dirty check many-to-ones with not-found=\"ignore\" in order \/\/ to update the cache (not the database), since in this case a null \/\/ entity reference can lose information boolean alwaysDirtyCheck = type.isAssociationType() && ( (AssociationType) type ).isAlwaysDirtyChecked(); if ( property.isSimpleValue() ) { SimpleAttributeBinding simpleProperty = ( SimpleAttributeBinding ) property; return new StandardProperty( simpleProperty.getAttribute().getName(), simpleProperty.getNodeName(), type, lazyAvailable && simpleProperty.isLazy(), simpleProperty.isInsertable(), simpleProperty.isUpdatable(), simpleProperty.getGeneration() == PropertyGeneration.INSERT || simpleProperty.getGeneration() == PropertyGeneration.ALWAYS, simpleProperty.getGeneration() == PropertyGeneration.ALWAYS, simpleProperty.isNullable(), alwaysDirtyCheck || simpleProperty.isUpdatable(), simpleProperty.isOptimisticLockable(), \/\/ TODO: get cascadeStyle from simpleProperty when HHH-6355 is fixed; for now, assume NONE \/\/simpleProperty.getCascadeStyle(), CascadeStyle.NONE, \/\/ TODO: get fetchMode() from simpleProperty when HHH-6357 is fixed; for now, assume FetchMode.DEFAULT \/\/simpleProperty.getFetchMode() FetchMode.DEFAULT ); } else { PluralAttributeBinding pluralProperty = ( PluralAttributeBinding ) property; return new StandardProperty( pluralProperty.getAttribute().getName(), pluralProperty.getNodeName(), type, lazyAvailable && pluralProperty.isLazy(), \/\/ TODO: fix this when HHH-6356 is fixed; for now assume PluralAttributeBinding is updatable and insertable \/\/ pluralProperty.isInsertable(), \/\/pluralProperty.isUpdatable(), true, true, false, false, pluralProperty.isNullable(), \/\/ TODO: fix this when HHH-6356 is fixed; for now assume PluralAttributeBinding is updatable and insertable \/\/alwaysDirtyCheck || pluralProperty.isUpdatable(), true, pluralProperty.isOptimisticLocked(), \/\/ TODO: get cascadeStyle from property when HHH-6355 is fixed; for now, assume NONE \/\/pluralProperty.getCascadeStyle(), CascadeStyle.NONE, \/\/ TODO: get fetchMode() from simpleProperty when HHH-6357 is fixed; for now, assume FetchMode.DEFAULT \/\/pluralProperty.getFetchMode() FetchMode.DEFAULT ); } }","old_code_raw":"\tpublic static StandardProperty buildStandardProperty(Property property, boolean lazyAvailable) {\n\t\t\n\t\tfinal Type type = property.getValue().getType();\n\t\t\n\t\t\/\/ we need to dirty check collections, since they can cause an owner\n\t\t\/\/ version number increment\n\t\t\n\t\t\/\/ we need to dirty check many-to-ones with not-found=\"ignore\" in order \n\t\t\/\/ to update the cache (not the database), since in this case a null\n\t\t\/\/ entity reference can lose information\n\t\t\n\t\tboolean alwaysDirtyCheck = type.isAssociationType() && \n\t\t\t\t( (AssociationType) type ).isAlwaysDirtyChecked(); \n\n\t\treturn new StandardProperty(\n\t\t\t\tproperty.getName(),\n\t\t\t\tproperty.getNodeName(),\n\t\t\t\ttype,\n\t\t\t\tlazyAvailable && property.isLazy(),\n\t\t\t\tproperty.isInsertable(),\n\t\t\t\tproperty.isUpdateable(),\n\t\t        property.getGeneration() == PropertyGeneration.INSERT || property.getGeneration() == PropertyGeneration.ALWAYS,\n\t\t\t\tproperty.getGeneration() == PropertyGeneration.ALWAYS,\n\t\t\t\tproperty.isOptional(),\n\t\t\t\talwaysDirtyCheck || property.isUpdateable(),\n\t\t\t\tproperty.isOptimisticLocked(),\n\t\t\t\tproperty.getCascadeStyle(),\n\t\t        property.getValue().getFetchMode()\n\t\t\t);\n\t}\n","new_comment_raw":"@param lazyAvailable Is property lazy loading currently available.","old_comment_raw":"@param lazyAvailable Is property lazy loading currently available.","label":0,"pre_label":1,"AST_level":9,"line_counts":66,"new_code_token_num":450},{"new_code_raw":"public static EBoolean endsWith(Expr<String> left, Expr<String> right) { return operationFactory.createBoolean(Ops.ENDSWITH, left, right); }","old_code_raw":"    public static EBoolean endsWith(Expr<String> left, Expr<String> right, boolean caseSensitive) {\n        if (caseSensitive){\n            return endsWith(left, right);            \n        }else{\n            return operationFactory.createBoolean(Ops.ENDSWITH_IC, left, right);\n        }\n    }\n","new_comment_raw":"@param left","old_comment_raw":"@param left","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":27},{"new_code_raw":"private String validateBrowserString(String inputString, RemoteControlConfiguration configuration) throws IllegalArgumentException { String browserString = inputString; if (configuration.getForcedBrowserMode() != null) { browserString = configuration.getForcedBrowserMode(); log.info(\"overriding browser mode w\/ forced browser mode setting: \" + browserString); } if (SeleniumServer.isProxyInjectionMode() && browserString.equals(\"*iexplore\")) { log.warn(\"running in proxy injection mode, but you used a *iexplore browser string; this is \" + \"almost surely inappropriate, so I'm changing it to *piiexplore...\"); browserString = \"*piiexplore\"; } else if (SeleniumServer.isProxyInjectionMode() && browserString.equals(\"*firefox\")) { log.warn(\"running in proxy injection mode, but you used a *firefox browser string; this is \" + \"almost surely inappropriate, so I'm changing it to *pifirefox...\"); browserString = \"*pifirefox\"; } if (null == browserString) { throw new IllegalArgumentException(\"browser string may not be null\"); } return browserString; }","old_code_raw":"    private String validateBrowserString(String inputString) throws IllegalArgumentException {\n        String browserString = inputString;\n        if (SeleniumServer.getForcedBrowserMode() != null) {\n            browserString = SeleniumServer.getForcedBrowserMode();\n            log.info(\"overriding browser mode w\/ forced browser mode setting: \" + browserString);\n        }\n        if (SeleniumServer.isProxyInjectionMode() && browserString.equals(\"*iexplore\")) {\n            log.warn(\"running in proxy injection mode, but you used a *iexplore browser string; this is \" +\n                    \"almost surely inappropriate, so I'm changing it to *piiexplore...\");\n            browserString = \"*piiexplore\";\n        } else if (SeleniumServer.isProxyInjectionMode() && browserString.equals(\"*firefox\")) {\n            log.warn(\"running in proxy injection mode, but you used a *firefox browser string; this is \" +\n                    \"almost surely inappropriate, so I'm changing it to *pifirefox...\");\n            browserString = \"*pifirefox\";\n        }\n\n        if (null == browserString) {\n            throw new IllegalArgumentException(\"browser string may not be null\");\n        }\n        return browserString;\n    }\n","new_comment_raw":"@param inputString the input browser string","old_comment_raw":"@param inputString the input browser string","label":0,"pre_label":1,"AST_level":9,"line_counts":22,"new_code_token_num":209},{"new_code_raw":"public String toDefaultValue(Schema p) { if (ModelUtils.isDateSchema(p)) { \/\/ TODO } else if (ModelUtils.isDateTimeSchema(p)) { \/\/ TODO } else if (ModelUtils.isNumberSchema(p)) { if (p.getDefault() != null) { return \"@\" + p.getDefault().toString(); } } else if (ModelUtils.isIntegerSchema(p)) { if (p.getDefault() != null) { return \"@\" + p.getDefault().toString(); } } else if (ModelUtils.isStringSchema(p)) { if (p.getDefault() != null) { return \"@\\\"\" + (String) p.getDefault() + \"\\\"\"; } } else if (ModelUtils.isBooleanSchema(p)) { if (p.getDefault() != null) { if (p.getDefault().toString().equalsIgnoreCase(\"false\")) return \"@(NO)\"; else return \"@(YES)\"; } } return null; }","old_code_raw":"    public String toDefaultValue(Property p) {\n        if (p instanceof StringProperty) {\n            StringProperty dp = (StringProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\\\"\" + dp.getDefault() + \"\\\"\";\n            }\n        } else if (p instanceof BooleanProperty) {\n            BooleanProperty dp = (BooleanProperty) p;\n            if (dp.getDefault() != null) {\n                if (dp.getDefault().toString().equalsIgnoreCase(\"false\"))\n                    return \"@(NO)\";\n                else\n                    return \"@(YES)\";\n            }\n        } else if (p instanceof DateProperty) {\n            \/\/ TODO\n        } else if (p instanceof DateTimeProperty) {\n            \/\/ TODO\n        } else if (p instanceof DoubleProperty) {\n            DoubleProperty dp = (DoubleProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        } else if (p instanceof FloatProperty) {\n            FloatProperty dp = (FloatProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        } else if (p instanceof IntegerProperty) {\n            IntegerProperty dp = (IntegerProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        } else if (p instanceof LongProperty) {\n            LongProperty dp = (LongProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        }\n\n        return null;\n    }\n","new_comment_raw":"@param p Swagger schema object","old_comment_raw":"@param p Swagger property object","label":1,"pre_label":0,"AST_level":15,"line_counts":29,"new_code_token_num":206},{"new_code_raw":"private static Uri getSharedPreferenceUri(Context context , int preferenceId) { String uriString = getSharedPreferences(context).getString(context.getString(preferenceId), null); if (uriString == null) return null; return Uri.parse(uriString); }","old_code_raw":"  public static Uri getSharedPreferenceUri(final int preferenceId) {\n\tString uriString = getSharedPreferences().getString(MyApplication.getContext().getString(preferenceId),\n\tnull);\n\n\tif (uriString == null) {\n\t  return null;\n\t}\n\telse {\n\t  return Uri.parse(uriString);\n\t}\n  }\n","new_comment_raw":"@param preferenceId the id of the shared preference.","old_comment_raw":"@param preferenceId the id of the shared preference.","label":0,"pre_label":1,"AST_level":8,"line_counts":7,"new_code_token_num":45},{"new_code_raw":"public static Collection<Simon> getSimons(SimonFilter simonFilter) { return manager.getSimons(simonFilter); }","old_code_raw":"\tpublic static Collection<Simon> getSimons(SimonPattern pattern) {\n\t\treturn manager.getSimons(pattern);\n\t}\n","new_comment_raw":"@param simonFilter filter accepting the Simons to result collection","old_comment_raw":"@param pattern Simon name pattern (see SimonPattern","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":18},{"new_code_raw":"protected SourceInfo update(Long lsn, Long useconds, Long txId) { this.lsn = lsn; this.useconds = useconds; this.txId = txId; return this; }","old_code_raw":"    protected SourceInfo update(Long lsn, Long useconds, Integer txId) {\n        this.lsn = lsn;\n        this.useconds = useconds;\n        this.txId = txId;\n        return this;\n    }\n","new_comment_raw":"@param useconds the commit time (in microseconds since epoch) of the transaction that generated the event; may be null indicating that this information is not available","old_comment_raw":"@param useconds the commit time (in microseconds since epoch) of the transaction that generated the event; may be null indicating that this information is not available","label":0,"pre_label":1,"AST_level":6,"line_counts":7,"new_code_token_num":30},{"new_code_raw":"public long set(long instant, int year) { Utils.verifyValueBounds(this, Math.abs(year), iChronology.getMinYear(), iChronology.getMaxYear()); \/\/ \/\/ Do nothing if no real change is requested. \/\/ int thisWeekyear = get( instant ); if ( thisWeekyear == year ) { return instant; } \/\/ \/\/ Calculate the DayOfWeek (to be preserved). \/\/ int thisDow = iChronology.dayOfWeek().get( instant ); \/\/ \/\/ Calculate the maximum weeks in the target year. \/\/ int weeksInFromYear = iChronology.getWeeksInYear( thisWeekyear ); int weeksInToYear = iChronology.getWeeksInYear( year ); int maxOutWeeks = (weeksInToYear < weeksInFromYear) ? weeksInToYear : weeksInFromYear; \/\/ \/\/ Get the current week of the year. This will be preserved in \/\/ the output unless it is greater than the maximum possible \/\/ for the target weekyear. In that case it is adjusted \/\/ to the maximum possible. \/\/ int setToWeek = iChronology.weekOfWeekyear().get( instant ); if ( setToWeek > maxOutWeeks ) { setToWeek = maxOutWeeks; } \/\/ \/\/ Get a wroking copy of the current date-time. \/\/ This can be a convenience for debugging. \/\/ long workInstant = instant; \/\/ Get a copy \/\/ \/\/ Attempt to get close to the proper weekyear. \/\/ Note - we cannot currently call ourself, so we just call \/\/ set for the year. This at least gets us close. \/\/ workInstant = iChronology.year().set( workInstant, year ); \/\/ \/\/ Calculate the weekyear number for the get close to value \/\/ (which might not be equal to the year just set). \/\/ int workWoyYear = iChronology.weekyear().get( workInstant ); \/\/ \/\/ At most we are off by one year, which can be \"fixed\" by \/\/ adding\/subtracting a week. \/\/ if ( workWoyYear < year ) { workInstant += DateTimeConstants.MILLIS_PER_WEEK; } else if ( workWoyYear > year ) { workInstant -= DateTimeConstants.MILLIS_PER_WEEK; } \/\/ \/\/ Set the proper week in the current weekyear. \/\/ \/\/ BEGIN: possible set WeekOfWeekyear logic. int currentWoyWeek = iChronology.weekOfWeekyear().get( workInstant ); \/\/ No range check required (we already know it is OK). workInstant = workInstant + (setToWeek - currentWoyWeek) * (long)DateTimeConstants.MILLIS_PER_WEEK; \/\/ END: possible set WeekOfWeekyear logic. \/\/ \/\/ Reset DayOfWeek to previous value. \/\/ workInstant = iChronology.dayOfWeek().set( workInstant, thisDow ); \/\/ \/\/ Return result. \/\/ return workInstant; }","old_code_raw":"    public long set(long millis, int year) {\n        super.verifyValueBounds(Math.abs(year),\n                                iChronology.getMinYear(), iChronology.getMaxYear());\n        \/\/\n        \/\/ Do nothing if no real change is requested.\n        \/\/\n        int thisWeekyear = get( millis );\n        if ( thisWeekyear == year ) {\n            return millis;\n        }\n        \/\/\n        \/\/ Calculate the DayOfWeek (to be preserved).\n        \/\/\n        int thisDow = iChronology.dayOfWeek().get( millis );\n        \/\/\n        \/\/ Calculate the maximum weeks in the target year.\n        \/\/\n        int weeksInFromYear = iChronology.getWeeksInYear( thisWeekyear );\n        int weeksInToYear = iChronology.getWeeksInYear( year );\n        int maxOutWeeks = (weeksInToYear < weeksInFromYear) ?\n            weeksInToYear : weeksInFromYear;\n        \/\/\n        \/\/ Get the current week of the year. This will be preserved in\n        \/\/ the output unless it is greater than the maximum possible\n        \/\/ for the target weekyear.  In that case it is adjusted\n        \/\/ to the maximum possible.\n        \/\/\n        int setToWeek = iChronology.weekOfWeekyear().get( millis );\n        if ( setToWeek > maxOutWeeks ) {\n            setToWeek = maxOutWeeks;\n        }\n        \/\/\n        \/\/ Get a wroking copy of the current date-time.\n        \/\/ This can be a convenience for debugging.\n        \/\/\n        long workMillis = millis; \/\/ Get a copy\n        \/\/\n        \/\/ Attempt to get close to the proper weekyear.\n        \/\/ Note - we cannot currently call ourself, so we just call\n        \/\/ set for the year.  This at least gets us close.\n        \/\/\n        workMillis = iChronology.year().set( workMillis, year );\n        \/\/\n        \/\/ Calculate the weekyear number for the get close to value\n        \/\/ (which might not be equal to the year just set).\n        \/\/\n        int workWoyYear = iChronology.weekyear().get( workMillis );\n\n        \/\/ *TEMP Debugging\n        \/*\n        MutableDateTime temp = new MutableDateTime(workMillis,\n            ISOChronology.getInstance());\n        System.out.println(\"Current mdt value 01: \"\n            + temp\n            + \" \" + workWoyYear\n        );\n        System.out.println(\"->Temp: \" + temp.toString()\n            + \" WOYYr=\" + temp.getWeekyear()\n            + \" WOYWk=\" + temp.getWeekOfWeekyear()\n            + \" DoW=\" + temp.getDayOfWeek()\n        );\n        *\/\n\n        \/\/\n        \/\/ At most we are off by one year, which can be \"fixed\" by\n        \/\/ adding\/subtracting a week.\n        \/\/\n        if ( workWoyYear < year ) {\n            \/\/ System.out.println(\"Year: Adding \"+workWoyYear+\" \"+year);\n            workMillis += DateTimeConstants.MILLIS_PER_WEEK;\n        } else if ( workWoyYear > year ) {\n            \/\/ System.out.println(\"Year: Subing \"+workWoyYear+\" \"+year);\n            workMillis -= DateTimeConstants.MILLIS_PER_WEEK;\n        }\n        \/\/\n        \/\/ Set the proper week in the current weekyear.\n        \/\/\n\n        \/\/ BEGIN: possible set WeekOfWeekyear logic.\n        int currentWoyWeek = iChronology.weekOfWeekyear().get( workMillis );\n        \/\/ No range check required (we already know it is OK).\n        workMillis = workMillis + (setToWeek - currentWoyWeek)\n            * (long)DateTimeConstants.MILLIS_PER_WEEK;\n        \/\/ END: possible set WeekOfWeekyear logic.\n\n        \/\/\n        \/\/ Reset DayOfWeek to previous value.\n        \/\/\n        workMillis = iChronology.dayOfWeek().set( workMillis, thisDow );\n        \/\/\n        \/\/ Return result.\n        \/\/\n        return workMillis;\n    }\n","new_comment_raw":"@param instant the time instant in millis to update.","old_comment_raw":"@param millis the time instant in millis to update.","label":1,"pre_label":0,"AST_level":8,"line_counts":78,"new_code_token_num":485},{"new_code_raw":"private ColumnState buildSimpleList(ContainerState parent, ColumnMetadata columnSchema) { \/\/ The variant must have the one and only type. assert columnSchema.variantSchema().size() == 1; assert columnSchema.variantSchema().isSimple(); \/\/ Create the manager for the one and only column within the list. final ListState listState = new ListState(parent.loader(), parent.vectorCache().childCache(columnSchema.name())); \/\/ Create the child vector, writer and state. final ColumnMetadata memberSchema = columnSchema.variantSchema().listSubtype(); final ColumnState memberState = buildColumn(listState, memberSchema); listState.setSubColumn(memberState); \/\/ Create the list vector. Contains a single type. final ListVector listVector = new ListVector(columnSchema.schema().cloneEmpty(), parent.loader().allocator(), null); listVector.setChildVector(memberState.vector()); \/\/ Create the list writer: an array of the one type. final ListWriterImpl listWriter = new ListWriterImpl(columnSchema, listVector, memberState.writer()); final AbstractObjectWriter listObjWriter = new ArrayObjectWriter(listWriter); \/\/ Create the list vector state that tracks the list vector lifecycle. final ListVectorState vectorState = new ListVectorState(listWriter, memberState.writer().events(), listVector); \/\/ Assemble it all into a union column state. return new UnionColumnState(parent.loader(), listObjWriter, vectorState, listState); }","old_code_raw":"  private ColumnState buildSimpleList(ContainerState parent, ColumnReadProjection colProj) {\n    ColumnMetadata columnSchema = colProj.providedSchema();\n\n    \/\/ The variant must have the one and only type.\n\n    assert columnSchema.variantSchema().size() == 1;\n    assert columnSchema.variantSchema().isSimple();\n\n    \/\/ Create the manager for the one and only column within the list.\n\n    final ListState listState = new ListState(parent.loader(),\n        parent.vectorCache().childCache(columnSchema.name()));\n\n    \/\/ Create the child vector, writer and state.\n\n    final ColumnMetadata memberSchema = columnSchema.variantSchema().listSubtype();\n    final ColumnState memberState = buildColumn(listState, memberSchema);\n    listState.setSubColumn(memberState);\n\n    \/\/ Create the list vector. Contains a single type.\n\n    final ListVector listVector = new ListVector(columnSchema.schema().cloneEmpty(),\n        parent.loader().allocator(), null);\n    listVector.setChildVector(memberState.vector());\n\n    \/\/ Create the list writer: an array of the one type.\n\n    final ListWriterImpl listWriter = new ListWriterImpl(columnSchema,\n        listVector, memberState.writer());\n    final AbstractObjectWriter listObjWriter = new ArrayObjectWriter(listWriter);\n\n    \/\/ Create the list vector state that tracks the list vector lifecycle.\n\n    final ListVectorState vectorState = new ListVectorState(listWriter,\n        memberState.writer().events(), listVector);\n\n    \/\/ Assemble it all into a union column state.\n\n    return new UnionColumnState(parent.loader(),\n        listObjWriter, vectorState, listState);\n  }\n","new_comment_raw":"@param colProj metadata description of the list which must contain exactly one subtype","old_comment_raw":"@param colProj metadata description of the list which must contain exactly one subtype","label":0,"pre_label":1,"AST_level":8,"line_counts":34,"new_code_token_num":257},{"new_code_raw":"public DurationType getDurationType(Object object, boolean precise) { if (precise) { return DurationType.getPreciseAllType(); } return DurationType.getAllType(); }","old_code_raw":"    public DurationType getDurationType(Object object, boolean totalMillisMaster) {\n        if (totalMillisMaster) {\n            return DurationType.getPreciseAllType();\n        }\n        return DurationType.getAllType();\n    }\n","new_comment_raw":"@param precise true if a precise type is required","old_comment_raw":"@param totalMillisMaster true if total millis based duration","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":30},{"new_code_raw":"public static List<Integer> getSubListIndex(Object[] tofind, Object[] tokens, Predicate<Pair> matchingFunction){ if(tofind.length > tokens.length) return null; List<Integer> allIndices = new ArrayList<>(); boolean matched = false; int index = -1; int lastUnmatchedIndex = 0; for(int i = 0 ; i < tokens.length;){ for(int j = 0; j < tofind.length ;){ if(matchingFunction.test(new Pair(tofind[j], tokens[i]))){ index = i; i++; j++; if(j == tofind.length) { matched = true; break; } }else{ j = 0; i = lastUnmatchedIndex +1; lastUnmatchedIndex = i; index = -1; if(lastUnmatchedIndex == tokens.length) break; } if(i >= tokens.length){ index = -1; break; } } if(i == tokens.length || matched){ if(index >= 0) \/\/index = index - l1.length + 1; allIndices.add(index - tofind.length + 1); matched = false; lastUnmatchedIndex = index; \/\/break; } } \/\/get starting point return allIndices; }","old_code_raw":"  public static List<Integer> getSubListIndex(Object[] tofind, Object[] tokens, Function<Pair, Boolean> matchingFunction){\n    if(tofind.length > tokens.length)\n      return null;\n    List<Integer> allIndices = new ArrayList<>();\n    boolean matched = false;\n    int index = -1;\n    int lastUnmatchedIndex = 0;\n    for(int i = 0 ; i < tokens.length;){\n      for(int j = 0; j < tofind.length ;){\n        if(matchingFunction.apply(new Pair(tofind[j], tokens[i]))){\n          index = i;\n          i++;\n          j++;\n          if(j == tofind.length)\n          {\n            matched = true;\n            break;\n          }\n        }else{\n          j = 0;\n          i = lastUnmatchedIndex +1;\n          lastUnmatchedIndex = i;\n          index = -1;\n          if(lastUnmatchedIndex == tokens.length)\n            break;\n        }\n        if(i >= tokens.length){\n          index = -1;\n          break;\n        }\n      }\n      if(i == tokens.length || matched){\n        if(index >= 0)\n          \/\/index = index - l1.length + 1;\n          allIndices.add(index - tofind.length + 1);\n        matched = false;\n        lastUnmatchedIndex = index;\n\n        \/\/break;\n      }\n    }\n    \/\/get starting point\n\n    return allIndices;\n  }\n","new_comment_raw":"@param tofind array you want to find in tokens","old_comment_raw":"@param tofind array you want to find in tokens","label":0,"pre_label":1,"AST_level":13,"line_counts":46,"new_code_token_num":220},{"new_code_raw":"public QuoteAnnotator(String name, Properties props, boolean verbose) { USE_SINGLE = Boolean.parseBoolean(props.getProperty(name + \".\" + \"singleQuotes\", \"false\")); MAX_LENGTH = Integer.parseInt(props.getProperty(name + \".\" + \"maxLength\", \"-1\")); ASCII_QUOTES = Boolean.parseBoolean(props.getProperty(name + \".\" + \"asciiQuotes\", \"false\")); ALLOW_EMBEDDED_SAME = Boolean.parseBoolean(props.getProperty(name + \".\" + \"allowEmbeddedSame\", \"false\")); SMART_QUOTES = Boolean.parseBoolean(props.getProperty(name + \".\" + \"smartQuotes\", \"false\")); EXTRACT_UNCLOSED = Boolean.parseBoolean(props.getProperty(name + \".\" + \"extractUnclosedQuotes\", \"false\")); ATTRIBUTE_QUOTES = Boolean.parseBoolean(props.getProperty(name + \".\" + \"attributeQuotes\", \"true\")); VERBOSE = verbose; Timing timer = null; if (VERBOSE) { timer = new Timing(); log.info(\"Preparing quote annotator...\"); } if (ATTRIBUTE_QUOTES) quoteAttributionAnnotator = new QuoteAttributionAnnotator(props); if (VERBOSE) { timer.stop(\"done.\"); } }","old_code_raw":"  public QuoteAnnotator(Properties props, boolean verbose) {\n    USE_SINGLE = Boolean.parseBoolean(props.getProperty(\"singleQuotes\", \"false\"));\n    MAX_LENGTH = Integer.parseInt(props.getProperty(\"maxLength\", \"-1\"));\n    ASCII_QUOTES = Boolean.parseBoolean(props.getProperty(\"asciiQuotes\", \"false\"));\n    ALLOW_EMBEDDED_SAME = Boolean.parseBoolean(props.getProperty(\"allowEmbeddedSame\", \"false\"));\n    SMART_QUOTES = Boolean.parseBoolean(props.getProperty(\"smartQuotes\", \"false\"));\n    EXTRACT_UNCLOSED = Boolean.parseBoolean(props.getProperty(\"extractUnclosedQuotes\", \"false\"));\n    ATTRIBUTE_QUOTES = Boolean.parseBoolean(props.getProperty(\"attributeQuotes\", \"true\"));\n\n    VERBOSE = verbose;\n    Timing timer = null;\n    if (VERBOSE) {\n      timer = new Timing();\n      log.info(\"Preparing quote annotator...\");\n    }\n    if (ATTRIBUTE_QUOTES)\n      quoteAttributionAnnotator = new QuoteAttributionAnnotator(props);\n\n    if (VERBOSE) {\n      timer.stop(\"done.\");\n    }\n  }\n","new_comment_raw":"@param verbose whether or not to output verbose information.","old_comment_raw":"@param verbose whether or not to output verbose information.","label":0,"pre_label":1,"AST_level":9,"line_counts":23,"new_code_token_num":223},{"new_code_raw":"public RexLiteral makeNullLiteral(RelDataType type) { if (!type.isNullable()) { type = typeFactory.createTypeWithNullability(type, true); } return (RexLiteral) makeCast(type, constantNull()); }","old_code_raw":"  public RexNode makeNullLiteral(SqlTypeName typeName) {\n    RelDataType type =\n        typeFactory.createTypeWithNullability(\n            typeFactory.createSqlType(typeName),\n            true);\n    return makeCast(type, constantNull());\n  }\n","new_comment_raw":"@param type Type to cast NULL to","old_comment_raw":"@param typeName Type to cast NULL to","label":1,"pre_label":0,"AST_level":8,"line_counts":7,"new_code_token_num":41},{"new_code_raw":"private RexNode adjustCondition(LogicalProject project, SemiJoin semiJoin) { \/\/ create two RexPrograms -- the bottom one representing a \/\/ concatenation of the project and the RHS of the semijoin and the \/\/ top one representing the semijoin condition RexBuilder rexBuilder = project.getCluster().getRexBuilder(); RelDataTypeFactory typeFactory = rexBuilder.getTypeFactory(); RelNode rightChild = semiJoin.getRight(); \/\/ for the bottom RexProgram, the input is a concatenation of the \/\/ child of the project and the RHS of the semijoin RelDataType bottomInputRowType = Join.deriveJoinRowType( project.getInput().getRowType(), rightChild.getRowType(), JoinRelType.INNER, typeFactory, null, semiJoin.getSystemFieldList()); RexProgramBuilder bottomProgramBuilder = new RexProgramBuilder(bottomInputRowType, rexBuilder); \/\/ add the project expressions, then add input references for the RHS \/\/ of the semijoin for (Pair<RexNode, String> pair : project.getNamedProjects()) { bottomProgramBuilder.addProject(pair.left, pair.right); } int nLeftFields = project.getInput().getRowType().getFieldCount(); List<RelDataTypeField> rightFields = rightChild.getRowType().getFieldList(); int nRightFields = rightFields.size(); for (int i = 0; i < nRightFields; i++) { final RelDataTypeField field = rightFields.get(i); RexNode inputRef = rexBuilder.makeInputRef( field.getType(), i + nLeftFields); bottomProgramBuilder.addProject(inputRef, field.getName()); } RexProgram bottomProgram = bottomProgramBuilder.getProgram(); \/\/ input rowtype into the top program is the concatenation of the \/\/ project and the RHS of the semijoin RelDataType topInputRowType = Join.deriveJoinRowType( project.getRowType(), rightChild.getRowType(), JoinRelType.INNER, typeFactory, null, semiJoin.getSystemFieldList()); RexProgramBuilder topProgramBuilder = new RexProgramBuilder( topInputRowType, rexBuilder); topProgramBuilder.addIdentity(); topProgramBuilder.addCondition(semiJoin.getCondition()); RexProgram topProgram = topProgramBuilder.getProgram(); \/\/ merge the programs and expand out the local references to form \/\/ the new semijoin condition; it now references a concatenation of \/\/ the project's child and the RHS of the semijoin RexProgram mergedProgram = RexProgramBuilder.mergePrograms( topProgram, bottomProgram, rexBuilder); return mergedProgram.expandLocalRef( mergedProgram.getCondition()); }","old_code_raw":"  private RexNode adjustCondition(ProjectRel project, SemiJoinRel semiJoin) {\n    \/\/ create two RexPrograms -- the bottom one representing a\n    \/\/ concatenation of the project and the RHS of the semijoin and the\n    \/\/ top one representing the semijoin condition\n\n    RexBuilder rexBuilder = project.getCluster().getRexBuilder();\n    RelDataTypeFactory typeFactory = rexBuilder.getTypeFactory();\n    RelNode rightChild = semiJoin.getRight();\n\n    \/\/ for the bottom RexProgram, the input is a concatenation of the\n    \/\/ child of the project and the RHS of the semijoin\n    RelDataType bottomInputRowType =\n        JoinRelBase.deriveJoinRowType(\n            project.getChild().getRowType(),\n            rightChild.getRowType(),\n            JoinRelType.INNER,\n            typeFactory,\n            null,\n            semiJoin.getSystemFieldList());\n    RexProgramBuilder bottomProgramBuilder =\n        new RexProgramBuilder(bottomInputRowType, rexBuilder);\n\n    \/\/ add the project expressions, then add input references for the RHS\n    \/\/ of the semijoin\n    for (Pair<RexNode, String> pair : project.getNamedProjects()) {\n      bottomProgramBuilder.addProject(pair.left, pair.right);\n    }\n    int nLeftFields = project.getChild().getRowType().getFieldCount();\n    List<RelDataTypeField> rightFields =\n        rightChild.getRowType().getFieldList();\n    int nRightFields = rightFields.size();\n    for (int i = 0; i < nRightFields; i++) {\n      final RelDataTypeField field = rightFields.get(i);\n      RexNode inputRef =\n          rexBuilder.makeInputRef(\n              field.getType(), i + nLeftFields);\n      bottomProgramBuilder.addProject(inputRef, field.getName());\n    }\n    RexProgram bottomProgram = bottomProgramBuilder.getProgram();\n\n    \/\/ input rowtype into the top program is the concatenation of the\n    \/\/ project and the RHS of the semijoin\n    RelDataType topInputRowType =\n        JoinRelBase.deriveJoinRowType(\n            project.getRowType(),\n            rightChild.getRowType(),\n            JoinRelType.INNER,\n            typeFactory,\n            null,\n            semiJoin.getSystemFieldList());\n    RexProgramBuilder topProgramBuilder =\n        new RexProgramBuilder(\n            topInputRowType,\n            rexBuilder);\n    topProgramBuilder.addIdentity();\n    topProgramBuilder.addCondition(semiJoin.getCondition());\n    RexProgram topProgram = topProgramBuilder.getProgram();\n\n    \/\/ merge the programs and expand out the local references to form\n    \/\/ the new semijoin condition; it now references a concatenation of\n    \/\/ the project's child and the RHS of the semijoin\n    RexProgram mergedProgram =\n        RexProgramBuilder.mergePrograms(\n            topProgram,\n            bottomProgram,\n            rexBuilder);\n\n    return mergedProgram.expandLocalRef(\n        mergedProgram.getCondition());\n  }\n","new_comment_raw":"@param semiJoin the semijoin","old_comment_raw":"@param semiJoin the semijoin","label":0,"pre_label":1,"AST_level":9,"line_counts":71,"new_code_token_num":411},{"new_code_raw":"public static int generateId(final String url, final String path) { return CustomComponentHolder.getImpl().getIdGeneratorInstance() .generateId(url, path, false); }","old_code_raw":"    public static int generateId(final String url, final String path, final boolean pathAsDirectory) {\n        return CustomComponentHolder.getImpl().getIdGeneratorInstance().generateId(url, path, pathAsDirectory);\n    }\n","new_comment_raw":"@param path The absolute file path.","old_comment_raw":"@param path If pathAsDirectory is true, path would be the absolute directory to place the file; If pathAsDirectory is false, path would be the absolute file path.","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":32},{"new_code_raw":"public static boolean isNotTransient(String entityName, Object entity, Boolean assumed, SharedSessionContractImplementor session) { if ( entity instanceof HibernateProxy ) { return true; } if ( session.getPersistenceContext().isEntryFor( entity ) ) { return true; } \/\/ todo : shouldnt assumed be revered here? return !isTransient( entityName, entity, assumed, session ); }","old_code_raw":"\tpublic static boolean isNotTransient(String entityName, Object entity, Boolean assumed, SessionImplementor session) {\n\t\tif ( entity instanceof HibernateProxy ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( session.getPersistenceContext().isEntryFor( entity ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t\/\/ todo : shouldnt assumed be revered here?\n\n\t\treturn !isTransient( entityName, entity, assumed, session );\n\t}\n","new_comment_raw":"@param assumed The assumed return value, if avoiding database hit is desired","old_comment_raw":"@param assumed The assumed return value, if avoiding database hit is desired","label":0,"pre_label":1,"AST_level":6,"line_counts":14,"new_code_token_num":69},{"new_code_raw":"public static String addPropertiesToURI(URI uri, Map<String, String> properties) throws Exception { return addPropertiesToURI(uri.toString(), properties); }","old_code_raw":"    public static String addPropertiesToURI(URI uri, Map<String, String> props) throws Exception {\n        return addPropertiesToURI(uri.toString(), props);\n    }\n","new_comment_raw":"@param uri The URI value to append the object properties to.","old_comment_raw":"@param uri","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":29},{"new_code_raw":"public SqlTester getTester() { return new SqlTesterImpl(new AdvisorTesterFactory()); }","old_code_raw":"  public Tester getTester(SqlConformance conformance) {\n    return new AdvisorTestImpl(conformance);\n  }\n","new_comment_raw":"@param list List","old_comment_raw":"@param list List","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":17},{"new_code_raw":"public Client testClassname(Client client) throws RestClientException { Object postBody = client; \/\/ verify the required parameter 'client' is set if (client == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'client' when calling testClassname\"); } String path = UriComponentsBuilder.fromPath(\"\/fake_classname_test\").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { \"application\/json\" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { \"application\/json\" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { \"api_key_query\" }; ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {}; return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }","old_code_raw":"    public Client testClassname(Client body) throws RestClientException {\n        Object postBody = body;\n        \n        \/\/ verify the required parameter 'body' is set\n        if (body == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'body' when calling testClassname\");\n        }\n        \n        String path = UriComponentsBuilder.fromPath(\"\/fake_classname_test\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application\/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"application\/json\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] { \"api_key_query\" };\n\n        ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {};\n        return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n","new_comment_raw":"@param client client model","old_comment_raw":"@param body client model","label":1,"pre_label":0,"AST_level":8,"line_counts":29,"new_code_token_num":203},{"new_code_raw":"File getBaseDir(File base, File file) { if (base == null) { return file.getParentFile().getAbsoluteFile(); } else { Iterator bases = getParents(base).iterator(); Iterator fileParents = getParents(file.getAbsoluteFile()).iterator(); File result = null; while (bases.hasNext() && fileParents.hasNext()) { File next = (File) bases.next(); if (next.equals(fileParents.next())) { result = next; } else { break; } } return result; } }","old_code_raw":"    File getBaseDir(final File file1, final File file2) {\n        if (file1 == null || file2 == null) {\n            return null;\n        }\n        final Iterator file1Parents = getParents(file1).iterator();\n        final Iterator file2Parents = getParents(file2.getAbsoluteFile()).iterator();\n        File result = null;\n        while (file1Parents.hasNext() && file2Parents.hasNext()) {\n            File next = (File) file1Parents.next();\n            if (next.equals(file2Parents.next())) {\n                result = next;\n            } else {\n                break;\n            }\n        }\n        return result;\n    }\n","new_comment_raw":"@param base the current base directory, may be null.","old_comment_raw":"@param file1 One of the files, for which the common base directory is being sought, may be null.","label":1,"pre_label":0,"AST_level":11,"line_counts":20,"new_code_token_num":106},{"new_code_raw":"public static List<Integer> getSubListIndex(Object[] tofind, Object[] tokens){ if(tofind.length > tokens.length) return null; List<Integer> allIndices = new ArrayList<Integer>(); boolean matched = false; int index = -1; int lastUnmatchedIndex = 0; for(int i = 0 ; i < tokens.length;){ for(int j = 0; j < tofind.length ;){ if(tofind[j].equals(tokens[i])){ index = i; i++; j++; if(j == tofind.length) { matched = true; break; } }else{ j = 0; i = lastUnmatchedIndex +1; lastUnmatchedIndex = i; index = -1; if(lastUnmatchedIndex == tokens.length) break; } if(i >= tokens.length){ index = -1; break; } } if(i == tokens.length || matched){ if(index >= 0) \/\/index = index - l1.length + 1; allIndices.add(index - tofind.length + 1); matched = false; lastUnmatchedIndex = index; \/\/break; } } \/\/get starting point return allIndices; }","old_code_raw":"  public static List<Integer> getSubListIndex(Object[] l1, Object[] l2){\n    if(l1.length > l2.length)\n      return null;\n    List<Integer> allIndices = new ArrayList<Integer>();\n    boolean matched = false;\n    int index = -1;\n    int lastUnmatchedIndex = 0;\n    for(int i = 0 ; i < l2.length;){\n      for(int j = 0; j < l1.length ;){\n        if(l1[j].equals(l2[i])){\n          index = i;\n          i++;\n          j++;\n          if(j == l1.length)\n          {\n            matched = true;\n            break;\n          }\n        }else{\n          j = 0;\n          i = lastUnmatchedIndex +1;\n          lastUnmatchedIndex = i;\n          index = -1;\n          if(lastUnmatchedIndex == l2.length)\n            break;\n        }\n        if(i >= l2.length){\n          index = -1;\n          break;\n        }\n      }\n      if(i == l2.length || matched){\n        if(index >= 0)\n          \/\/index = index - l1.length + 1;\n          allIndices.add(index - l1.length + 1);\n        matched = false;\n        lastUnmatchedIndex = index;\n\n        \/\/break;\n      }\n    }\n    \/\/get starting point\n\n    return allIndices;\n  }\n","new_comment_raw":"@param tofind array you want to find in tokens","old_comment_raw":"@param l1 array you want to find in l2","label":1,"pre_label":0,"AST_level":13,"line_counts":46,"new_code_token_num":211},{"new_code_raw":"public Collection<Tree> getRelatedNodes(Tree t, Tree root) { if (root.value() == null) { root.setValue(\"ROOT\"); \/\/ todo: cdm: it doesn't seem like this line should be here } Set<Tree> nodeList = new LinkedHashSet<Tree>(); for (TregexPattern p : targetPatterns) { \/\/ cdm: I deleted: && nodeList.isEmpty() TregexMatcher m = p.matcher(root); while (m.findAt(t)) { nodeList.add(m.getNode(\"target\")); \/\/System.out.println(\"found \" + this + \"(\" + t + \", \" + m.getNode(\"target\") + \") using pattern \" + p); } } return nodeList; }","old_code_raw":"  public Collection<Tree> getRelatedNodes(Tree t, Tree root, HeadFinder headFinder) {\n    Set<Tree> nodeList = new ArraySet<Tree>();\n    for (TregexPattern p : targetPatterns) {    \/\/ cdm: I deleted: && nodeList.isEmpty()\n      \/\/ Initialize the TregexMatcher with the HeadFinder so that we\n      \/\/ can use the same HeadFinder through the entire process of\n      \/\/ building the dependencies\n      TregexMatcher m = p.matcher(root, headFinder);\n      while (m.findAt(t)) {\n        nodeList.add(m.getNode(\"target\"));\n        if (DEBUG) {\n          System.err.println(\"found \" + this + \"(\" + t + \", \" + m.getNode(\"target\") + \") using pattern \" + p);\n          for (String nodeName : m.getNodeNames()) {\n            if (nodeName.equals(\"target\"))\n              continue;\n            System.err.println(\"  node \" + nodeName + \": \" + m.getNode(nodeName));\n          }\n        }\n      }\n    }\n    return nodeList;\n  }\n","new_comment_raw":"@param t Target for finding governors of t related by this GR","old_comment_raw":"@param t Target for finding dependents of t related by this GR","label":1,"pre_label":0,"AST_level":10,"line_counts":15,"new_code_token_num":151},{"new_code_raw":"public ScrollableResults scroll(ScrollMode mode, Expression<?> expr1, Expression<?> expr2, Expression<?>... rest) { Query query = createQuery(expr1, expr2, rest); reset(); return query.scroll(mode); }","old_code_raw":"    public ScrollableResults scroll(ScrollMode mode, Expr<?> expr1, Expr<?> expr2, Expr<?>... rest) {\n        Query query = createQuery(expr1, expr2, rest);\n        reset();\n        return query.scroll(mode);\n    }\n","new_comment_raw":"@param expr1","old_comment_raw":"@param expr1","label":0,"pre_label":1,"AST_level":6,"line_counts":6,"new_code_token_num":43},{"new_code_raw":"public void createUsersWithListInput (java.util.List<User> body) throws ApiException { Object postBody = body; byte[] postBinaryBody = null; \/\/ create path and map variables String path = \"\/user\/createWithList\".replaceAll(\"\\\\{format\\\\}\",\"json\"); \/\/ query params java.util.List<Pair> queryParams = new java.util.ArrayList<Pair>(); java.util.Map<String, String> headerParams = new java.util.HashMap<String, String>(); java.util.Map<String, Object> formParams = new java.util.HashMap<String, Object>(); final String[] accepts = { \"application\/json\", \"application\/xml\" }; final String accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final String contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; apiClient.invokeAPI(path, \"POST\", queryParams, postBody, postBinaryBody, headerParams, formParams, accept, contentType, authNames, null); }","old_code_raw":"  public void createUsersWithListInput (List<User> body) throws ApiException {\n    Object postBody = body;\n    byte[] postBinaryBody = null;\n    \n    \/\/ create path and map variables\n    String path = \"\/user\/createWithList\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    \/\/ query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    Map<String, String> headerParams = new HashMap<String, String>();\n    Map<String, Object> formParams = new HashMap<String, Object>();\n\n    \n\n    \n\n    \n\n    final String[] accepts = {\n      \"application\/json\", \"application\/xml\"\n    };\n    final String accept = apiClient.selectHeaderAccept(accepts);\n\n    final String[] contentTypes = {\n      \n    };\n    final String contentType = apiClient.selectHeaderContentType(contentTypes);\n\n    String[] authNames = new String[] {  };\n\n    \n\n    \n    \n    apiClient.invokeAPI(path, \"POST\", queryParams, postBody, postBinaryBody, headerParams, formParams, accept, contentType, authNames, null);\n    \n    \n\n\n  }\n","new_comment_raw":"@param body List of user object","old_comment_raw":"@param body List of user object","label":0,"pre_label":1,"AST_level":10,"line_counts":41,"new_code_token_num":191},{"new_code_raw":"private ColumnState buildUnionList(ContainerState parent, ColumnTransform outputCol) { ColumnMetadata columnSchema = outputCol.outputSchema(); \/\/ The variant must start out empty. assert columnSchema.variantSchema().size() == 0; \/\/ Create the union writer, bound to an empty list shim. final UnionWriterImpl unionWriter = new UnionWriterImpl(columnSchema); unionWriter.bindShim(new EmptyListShim()); final VariantObjectWriter unionObjWriter = new VariantObjectWriter(unionWriter); \/\/ Create the list vector. Starts with the default (dummy) data \/\/ vector which corresponds to the empty union shim above. \/\/ Don't get the list vector from the vector cache. List vectors may \/\/ have content that varies from batch to batch. Only the leaf \/\/ vectors can be cached. final ListVector listVector = new ListVector(columnSchema.schema(), parent.loader().allocator(), null); \/\/ Create the list vector state that tracks the list vector lifecycle. final ListVectorState vectorState = new ListVectorState(unionWriter, listVector); \/\/ Create the list writer: an array of unions. final AbstractObjectWriter listWriter = new ArrayObjectWriter( new ListWriterImpl(columnSchema, listVector, unionObjWriter)); \/\/ Create the manager for the columns within the list (which may or \/\/ may not be grouped into a union.) final ListState listState = new ListState(parent.loader(), parent.vectorCache().childCache(columnSchema.name()), ImpliedTupleRequest.ALL_MEMBERS); \/\/ Bind the union state to the union writer to handle column additions. unionWriter.bindListener(listState); \/\/ Assemble it all into a union column state. return new UnionColumnState(parent.loader(), listWriter, vectorState, listState); }","old_code_raw":"  private static ColumnState buildUnionList(ContainerState parent, ColumnMetadata columnSchema) {\n\n    \/\/ The variant must start out empty.\n\n    assert columnSchema.variantSchema().size() == 0;\n\n    \/\/ Create the union writer, bound to an empty list shim.\n\n    final UnionWriterImpl unionWriter = new UnionWriterImpl(columnSchema);\n    unionWriter.bindShim(new EmptyListShim());\n    final VariantObjectWriter unionObjWriter = new VariantObjectWriter(unionWriter);\n\n    \/\/ Create the list vector. Starts with the default (dummy) data\n    \/\/ vector which corresponds to the empty union shim above.\n    \/\/ Don't get the list vector from the vector cache. List vectors may\n    \/\/ have content that varies from batch to batch. Only the leaf\n    \/\/ vectors can be cached.\n\n    final ListVector listVector = new ListVector(columnSchema.schema(),\n        parent.loader().allocator(), null);\n\n    \/\/ Create the list vector state that tracks the list vector lifecycle.\n\n    final ListVectorState vectorState = new ListVectorState(unionWriter, listVector);\n\n    \/\/ Create the list writer: an array of unions.\n\n    final AbstractObjectWriter listWriter = new ArrayObjectWriter(\n        new ListWriterImpl(columnSchema, listVector, unionObjWriter));\n\n    \/\/ Create the manager for the columns within the list (which may or\n    \/\/ may not be grouped into a union.)\n\n    final ListState listState = new ListState(parent.loader(),\n        parent.vectorCache().childCache(columnSchema.name()),\n        ImpliedTupleRequest.ALL_MEMBERS);\n\n    \/\/ Bind the union state to the union writer to handle column additions.\n\n    unionWriter.bindListener(listState);\n\n    \/\/ Assemble it all into a union column state.\n\n    return new UnionColumnState(parent.loader(),\n        listWriter, vectorState, listState);\n  }\n","new_comment_raw":"@param parent the parent (tuple, union or list) that holds this list","old_comment_raw":"@param parent the parent (tuple, union or list) that holds this list","label":0,"pre_label":1,"AST_level":8,"line_counts":48,"new_code_token_num":309},{"new_code_raw":"public boolean waitForText(String text, int expectedMinimumNumberOfMatches, long timeout, boolean scroll) { final long endTime = System.currentTimeMillis() + timeout; while (true) { final boolean timedOut = System.currentTimeMillis() > endTime; if (timedOut){ return false; } sleeper.sleep(); final boolean foundAnyTextView = searcher.searchFor(TextView.class, text, expectedMinimumNumberOfMatches, scroll); if (foundAnyTextView){ return true; } final boolean foundAnyEditText = searcher.searchFor(EditText.class, text, 1, scroll); if (foundAnyEditText){ return true; } } }","old_code_raw":"\tpublic boolean waitForText(String text, int matches, long timeout, boolean scroll) {\n        final long endTime = System.currentTimeMillis() + timeout;\n\n\t\twhile (true) {\n\t\t\tfinal boolean timedOut = System.currentTimeMillis() > endTime;\n\t\t\tif (timedOut){\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tsleeper.sleep();\n\n\t\t\tfinal boolean foundAnyTextView = searcher.searchFor(TextView.class, text, matches, scroll);\n\t\t\tif (foundAnyTextView){\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tfinal boolean foundAnyEditText = searcher.searchFor(EditText.class, text, 1, scroll);\n\t\t\tif (foundAnyEditText){\n\t\t\t\treturn true;\n\t\t\t}\n        }\n    }\n","new_comment_raw":"@param expectedMinimumNumberOfMatches the minimum number of matches of text that must be shown.  0 means any number of matches","old_comment_raw":"@param matches the number of matches of text that must be shown. 0 means any number of matches","label":1,"pre_label":0,"AST_level":9,"line_counts":23,"new_code_token_num":107},{"new_code_raw":"public TableSchema create(String schemaPrefix, String envelopSchemaName, Table table, ColumnNameFilter filter, ColumnMappers mappers, CustomKeyMapper keysMapper) { if (schemaPrefix == null) { schemaPrefix = \"\"; } \/\/ Build the schemas ... final TableId tableId = table.id(); final String tableIdStr = tableSchemaName(tableId); final String schemaNamePrefix = schemaPrefix + tableIdStr; LOGGER.debug(\"Mapping table '{}' to schemas under '{}'\", tableId, schemaNamePrefix); SchemaBuilder valSchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Value\")); SchemaBuilder keySchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Key\")); AtomicBoolean hasPrimaryKey = new AtomicBoolean(false); Key tableKey = new Key.Builder(table).customKeyMapper(keysMapper).build(); tableKey.keyColumns().forEach(column -> { addField(keySchemaBuilder, column, null); hasPrimaryKey.set(true); }); table.columns() .stream() .filter(column -> filter == null || filter.matches(tableId.catalog(), tableId.schema(), tableId.table(), column.name())) .forEach(column -> { ColumnMapper mapper = mappers == null ? null : mappers.mapperFor(tableId, column); addField(valSchemaBuilder, column, mapper); }); Schema valSchema = valSchemaBuilder.optional().build(); Schema keySchema = hasPrimaryKey.get() ? keySchemaBuilder.build() : null; if (LOGGER.isDebugEnabled()) { LOGGER.debug(\"Mapped primary key for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(keySchema)); LOGGER.debug(\"Mapped columns for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(valSchema)); } Envelope envelope = Envelope.defineSchema() .withName(schemaNameAdjuster.adjust(envelopSchemaName)) .withRecord(valSchema) .withSource(sourceInfoSchema) .build(); \/\/ Create the generators ... Function<Object[], Object> keyGenerator = createKeyGenerator(keySchema, tableId, tableKey.keyColumns()); Function<Object[], Struct> valueGenerator = createValueGenerator(valSchema, tableId, table.columns(), filter, mappers); \/\/ And the table schema ... return new TableSchema(tableId, keySchema, keyGenerator, envelope, valSchema, valueGenerator); }","old_code_raw":"    public TableSchema create(String schemaPrefix, String envelopSchemaName, Table table, ColumnNameFilter filter, ColumnMappers mappers) {\n        if (schemaPrefix == null) {\n            schemaPrefix = \"\";\n        }\n\n        \/\/ Build the schemas ...\n        final TableId tableId = table.id();\n        final String tableIdStr = tableSchemaName(tableId);\n        final String schemaNamePrefix = schemaPrefix + tableIdStr;\n        LOGGER.debug(\"Mapping table '{}' to schemas under '{}'\", tableId, schemaNamePrefix);\n        SchemaBuilder valSchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Value\"));\n        SchemaBuilder keySchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Key\"));\n        AtomicBoolean hasPrimaryKey = new AtomicBoolean(false);\n        table.columns().forEach(column -> {\n            if (table.isPrimaryKeyColumn(column.name())) {\n                \/\/ The column is part of the primary key, so ALWAYS add it to the PK schema ...\n                addField(keySchemaBuilder, column, null);\n                hasPrimaryKey.set(true);\n            }\n            if (filter == null || filter.matches(tableId.catalog(), tableId.schema(), tableId.table(), column.name())) {\n                \/\/ Add the column to the value schema only if the column has not been filtered ...\n                ColumnMapper mapper = mappers == null ? null : mappers.mapperFor(tableId, column);\n                addField(valSchemaBuilder, column, mapper);\n            }\n        });\n        Schema valSchema = valSchemaBuilder.optional().build();\n        Schema keySchema = hasPrimaryKey.get() ? keySchemaBuilder.build() : null;\n\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"Mapped primary key for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(keySchema));\n            LOGGER.debug(\"Mapped columns for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(valSchema));\n        }\n\n        Envelope envelope = Envelope.defineSchema()\n                .withName(schemaNameAdjuster.adjust(envelopSchemaName))\n                .withRecord(valSchema)\n                .withSource(sourceInfoSchema)\n                .build();\n\n\n        \/\/ Create the generators ...\n        Function<Object[], Object> keyGenerator = createKeyGenerator(keySchema, tableId, table.primaryKeyColumns());\n        Function<Object[], Struct> valueGenerator = createValueGenerator(valSchema, tableId, table.columns(), filter, mappers);\n\n        \/\/ And the table schema ...\n        return new TableSchema(tableId, keySchema, keyGenerator, envelope, valSchema, valueGenerator);\n    }\n","new_comment_raw":"@param mappers the mapping functions for columns; may be null if none of the columns are to be mapped to different values","old_comment_raw":"@param mappers the mapping functions for columns; may be null if none of the columns are to be mapped to different values","label":0,"pre_label":1,"AST_level":11,"line_counts":51,"new_code_token_num":433},{"new_code_raw":"public Call createUsersWithArrayInputAsync(java.util.List<User> body, ApiCallback<Void> callback) throws ApiException { Call call = createUsersWithArrayInputCall(body); apiClient.executeAsync(call, callback); return call; }","old_code_raw":"  public Call createUsersWithArrayInputAsync(List<User> body, ApiCallback<Void> callback) throws ApiException {\n    Call call = createUsersWithArrayInputCall(body);\n    apiClient.executeAsync(call, callback);\n    return call;\n  }\n","new_comment_raw":"@param callback The callback to be executed when the API call finishes","old_comment_raw":"@param callback The callback to be executed when the API call finishes","label":0,"pre_label":1,"AST_level":8,"line_counts":6,"new_code_token_num":36},{"new_code_raw":"private static void algC(StringBuilder sb, int m, int n, String a, String b) { int i; int j; \/\/ Step 1 if (n == 0) { \/\/ Nothing to do } else if (m == 1) { for (j = 0; j < n; j++) { if (a.charAt(0) == b.charAt(j)) { sb.append(a.charAt(0)); break; } } \/\/ Step 2 } else { i = (int)Math.floor(((double) m) \/ 2); \/\/ Step 3 int[] l1 = algB(i, n, a.substring(0, i), b); int[] l2 = algB(m - i, n, reverseString(a.substring(i)), reverseString(b)); \/\/ Step 4 int k = findK(l1, l2, n); \/\/ Step 5 algC(sb, i, k, a.substring(0, i), b.substring(0, k)); algC(sb, m - i, n - k, a.substring(i), b.substring(k)); } }","old_code_raw":"    private String algC(int m, int n, String a, String b) {\n        int i;\n        int j;\n        StringBuilder sb;\n\n        \/\/ Step 1\n        if (n == 0) {\n            sb = new StringBuilder();\n            \n        } else if (m == 1) {\n            sb = new StringBuilder();\n            for (j = 0; j < n; j++) {\n                if (a.charAt(0) == b.charAt(j)) {\n                    sb.append(a.charAt(0));\n                    break;\n                }\n            }\n\n        \/\/ Step 2\n        } else {\n            i = (int)Math.floor(((double) m) \/ 2);\n\n            \/\/ Step 3\n            int[] l1 = algB(i, n, a.substring(0, i), b);\n            int[] l2 = algB(m - i, n, reverseString(a.substring(i)), reverseString(b));\n\n            \/\/ Step 4\n            int k = findK(l1, l2, n);\n\n            \/\/ Step 5\n            sb = new StringBuilder(algC(i, k, a.substring(0, i), b.substring(0, k)));\n            sb.append(algC(m - i, n - k, a.substring(i), b.substring(k)));\n        }\n\n        \/\/ Return the LCS\n        return sb.toString();\n    }\n","new_comment_raw":"@param a","old_comment_raw":"@param a","label":0,"pre_label":1,"AST_level":13,"line_counts":32,"new_code_token_num":238},{"new_code_raw":"public static DateTimeComparator getInstance(DateTimeFieldType lowerLimit, DateTimeFieldType upperLimit) { if (lowerLimit == null && upperLimit == null) { return ALL_INSTANCE; } if (lowerLimit == DateTimeFieldType.dayOfYear() && upperLimit == null) { return DATE_INSTANCE; } if (lowerLimit == null && upperLimit == DateTimeFieldType.dayOfYear()) { return TIME_INSTANCE; } return new DateTimeComparator(lowerLimit, upperLimit); }","old_code_raw":"    public static DateTimeComparator getInstance(DateTimeField lowerLimit, DateTimeField upperLimit) {\n        if (lowerLimit == null && upperLimit == null) {\n            return INSTANCE;\n        }\n        if (lowerLimit != null && upperLimit != null) {\n            if (lowerLimit.getDurationField().getUnitMillis() > upperLimit.getDurationField().getUnitMillis()) {\n                throw new IllegalArgumentException(\"Lower limit greater than upper: \" +\n                    lowerLimit.getName() + \" > \" + upperLimit.getName());\n            }\n        }\n        return new DateTimeComparator(lowerLimit, upperLimit);\n    }\n","new_comment_raw":"@param lowerLimit inclusive lower limit for fields to be compared, null means no limit","old_comment_raw":"@param lowerLimit inclusive lower limit for fields to be compared, null means no limit","label":0,"pre_label":1,"AST_level":6,"line_counts":13,"new_code_token_num":70},{"new_code_raw":"public String runHTMLSuite(String browser, String browserURL, String suiteURL, File outputFile, long timeoutInSeconds, boolean multiWindow) throws IOException { return runHTMLSuite(browser, browserURL, suiteURL, outputFile, timeoutInSeconds, multiWindow, \"info\"); }","old_code_raw":"    public String runHTMLSuite(String browser, String browserURL, String suiteURL, File outputFile, int timeoutInSeconds, boolean multiWindow) throws IOException {\n        return runHTMLSuite(browser, browserURL, suiteURL, outputFile,\n                timeoutInSeconds, multiWindow, \"info\");\n    }\n","new_comment_raw":"@param outputFile - The file to which we'll output the HTML results","old_comment_raw":"@param outputFile - The file to which we'll output the HTML results","label":0,"pre_label":1,"AST_level":5,"line_counts":5,"new_code_token_num":46},{"new_code_raw":"public Client call123testSpecialTags(Client body) throws ApiException { return call123testSpecialTagsWithHttpInfo(body).getData(); }","old_code_raw":"  public Client call123testSpecialTags(Client client) throws ApiException {\n    return call123testSpecialTagsWithHttpInfo(client).getData();\n      }\n","new_comment_raw":"@param body client model (required)","old_comment_raw":"@param client client model (required)","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"public int[] findModified(Object[] old, Object[] current, Object entity, SharedSessionContractImplementor session) throws HibernateException { int[] props = TypeHelper.findModified( entityMetamodel.getProperties(), current, old, propertyColumnUpdateable, hasUninitializedLazyProperties( entity ), session ); if ( props == null ) { return null; } else { logDirtyProperties( props ); return props; } }","old_code_raw":"\tpublic int[] findModified(Object[] old, Object[] current, Object entity, SessionImplementor session)\n\t\t\tthrows HibernateException {\n\t\tint[] props = TypeHelper.findModified(\n\t\t\t\tentityMetamodel.getProperties(),\n\t\t\t\tcurrent,\n\t\t\t\told,\n\t\t\t\tpropertyColumnUpdateable,\n\t\t\t\thasUninitializedLazyProperties( entity ),\n\t\t\t\tsession\n\t\t);\n\t\tif ( props == null ) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tlogDirtyProperties( props );\n\t\t\treturn props;\n\t\t}\n\t}\n","new_comment_raw":"@param old The old state of the entity.","old_comment_raw":"@param old The old state of the entity.","label":0,"pre_label":1,"AST_level":7,"line_counts":19,"new_code_token_num":73},{"new_code_raw":"private boolean resolveAccount(Uri uri, ContentValues values) { String accountName = getQueryParameter(uri, RawContacts.ACCOUNT_NAME); String accountType = getQueryParameter(uri, RawContacts.ACCOUNT_TYPE); if (TextUtils.isEmpty(accountName) || TextUtils.isEmpty(accountType)) { accountName = null; accountType = null; } String valueAccountName = values.getAsString(RawContacts.ACCOUNT_NAME); String valueAccountType = values.getAsString(RawContacts.ACCOUNT_TYPE); if (TextUtils.isEmpty(valueAccountName) && TextUtils.isEmpty(valueAccountType)) { values.put(RawContacts.ACCOUNT_NAME, accountName); values.put(RawContacts.ACCOUNT_TYPE, accountType); } else { if (accountName != null && !accountName.equals(valueAccountName)) { return false; } if (accountType != null && !accountType.equals(valueAccountType)) { return false; } accountName = valueAccountName; accountType = valueAccountType; } if (TextUtils.isEmpty(accountName) || TextUtils.isEmpty(accountType)) { mAccount = null; return true; } if (mAccount == null || !mAccount.name.equals(accountName) || !mAccount.type.equals(accountType)) { mAccount = new Account(accountName, accountType); } return true; }","old_code_raw":"    private boolean resolveAccount(ContentValues values, Account account) {\n        \/\/ If either is specified then both must be specified.\n        final String accountName = values.getAsString(RawContacts.ACCOUNT_NAME);\n        final String accountType = values.getAsString(RawContacts.ACCOUNT_TYPE);\n        if (!TextUtils.isEmpty(accountName) || !TextUtils.isEmpty(accountType)) {\n            final Account valuesAccount = new Account(accountName, accountType);\n            if (account != null && !valuesAccount.equals(account)) {\n                return false;\n            }\n            account = valuesAccount;\n        }\n        if (account != null) {\n            values.put(RawContacts.ACCOUNT_NAME, account.name);\n            values.put(RawContacts.ACCOUNT_TYPE, account.type);\n        }\n        return true;\n    }\n","new_comment_raw":"@param values the explicitly provided Account","old_comment_raw":"@param account the explicitly provided Account","label":1,"pre_label":0,"AST_level":8,"line_counts":43,"new_code_token_num":215},{"new_code_raw":"protected Object suspendAndGet(Object key, FlagAdapter opt, boolean suppressTimeout) throws CacheException { Transaction tx = suspend(); try { if (suppressTimeout) return cacheAdapter.getAllowingTimeout(key); else return cacheAdapter.get(key); } finally { resume(tx); } }","old_code_raw":"   protected Object suspendAndGet(Object key, Flag opt, boolean suppressTimeout) throws CacheException {\n       Transaction tx = suspend();\n       try {\n           if (suppressTimeout)\n               return CacheHelper.getAllowingTimeout(cache, key);\n           else\n               return CacheHelper.get(cache, key);\n       } finally {\n           resume(tx);\n       }\n   }\n","new_comment_raw":"@param suppressTimeout should any TimeoutException be suppressed?","old_comment_raw":"@param suppressTimeout should any TimeoutException be suppressed?","label":0,"pre_label":1,"AST_level":7,"line_counts":12,"new_code_token_num":53},{"new_code_raw":"public Activity getCurrentActivity(int pause) { if(pause > 0){ RobotiumUtils.sleep(pause); inst.waitForIdleSync(); } Boolean found = false; if (activityMonitor != null) { if (activityMonitor.getLastActivity() != null) activity = activityMonitor.getLastActivity(); } for(Activity storedActivity : activityList){ if (storedActivity.getClass().getName().equals( activity.getClass().getName())) found = true; } if (found) return activity; else { activityList.add(activity); return activity; } }","old_code_raw":"\tpublic Activity getCurrentActivity(int paus) {\n\t\tif(paus > 0){\n\t\t\tRobotiumUtils.sleep(paus);\n\t\t\tinst.waitForIdleSync();\n\t\t}\n\t\tBoolean found = false;\n\t\tif (activityMonitor != null) {\n\t\t\tif (activityMonitor.getLastActivity() != null)\n\t\t\t\tactivity = activityMonitor.getLastActivity();\n\t\t}\n\t\tfor(Activity storedActivity : activityList){\n\t\t\tif (storedActivity.getClass().getName().equals(\n\t\t\t\t\tactivity.getClass().getName()))\n\t\t\t\tfound = true;\n\t\t}\n\t\tif (found)\n\t\t\treturn activity;\n\t\telse {\n\t\t\tactivityList.add(activity);\n\t\t\treturn activity;\n\t\t}\n\t}\n","new_comment_raw":"@param pause the time to pause in milliseconds","old_comment_raw":"@param paus the time to paus","label":1,"pre_label":0,"AST_level":9,"line_counts":23,"new_code_token_num":105},{"new_code_raw":"ScrollQuery scan(String query, BytesArray body, ScrollReader reader) throws IOException { String[] scrollInfo = client.scan(query, body); String scrollId = scrollInfo[0]; long totalSize = Long.parseLong(scrollInfo[1]); return new ScrollQuery(this, scrollId, totalSize, reader); }","old_code_raw":"    ScrollQuery scan(String query, ScrollReader reader) throws IOException {\n        String[] scrollInfo = client.scan(query);\n        String scrollId = scrollInfo[0];\n        long totalSize = Long.parseLong(scrollInfo[1]);\n        return new ScrollQuery(this, scrollId, totalSize, reader);\n    }\n","new_comment_raw":"@param reader scroll reader","old_comment_raw":"@param reader scroll reader","label":0,"pre_label":1,"AST_level":8,"line_counts":7,"new_code_token_num":59},{"new_code_raw":"public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, Map<String, Object> params) throws IOException { HttpResponse response = uploadFileWithRequiredFileForHttpResponse(petId, requiredFile, params); TypeReference typeRef = new TypeReference<ModelApiResponse>() {}; return apiClient.getObjectMapper().readValue(response.getContent(), typeRef); }","old_code_raw":"    public ModelApiResponse uploadFileWithRequiredFile(Long petId, File file, Map<String, Object> params) throws IOException {\n        HttpResponse response = uploadFileWithRequiredFileForHttpResponse(petId, file, params);\n        TypeReference typeRef = new TypeReference<ModelApiResponse>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    }\n","new_comment_raw":"@param requiredFile file to upload","old_comment_raw":"@param file file to upload","label":1,"pre_label":0,"AST_level":8,"line_counts":6,"new_code_token_num":56},{"new_code_raw":"private BufferedImage loadImage(int itemId, int quantity, boolean stackable) { SpritePixels sprite = client.createItemSprite(itemId, quantity, 1, SpritePixels.DEFAULT_SHADOW_COLOR, stackable ? 1 : 0, false); return sprite.toBufferedImage(); }","old_code_raw":"\tprivate BufferedImage loadImage(int itemId, int quantity)\n\t{\n\t\tSpritePixels sprite = client.createItemSprite(itemId, quantity, 1, SpritePixels.DEFAULT_SHADOW_COLOR, 0, false);\n\t\treturn sprite.toBufferedImage();\n\t}\n","new_comment_raw":"@param itemId","old_comment_raw":"@param itemId","label":0,"pre_label":1,"AST_level":7,"line_counts":6,"new_code_token_num":44},{"new_code_raw":"public long set(long instant, int year) { Utils.verifyValueBounds (this, year, iChronology.getMinYear(), iChronology.getMaxYear()); int dayOfYear = iChronology.dayOfYear().get(instant); int millisOfDay = iChronology.millisOfDay().get(instant); if (dayOfYear > (31 + 28)) { \/\/ after Feb 28 if (isLeap(instant)) { \/\/ Old date is Feb 29 or later. if (!iChronology.isLeapYear(year)) { \/\/ Moving to a non-leap year, Feb 29 does not exist. dayOfYear--; } } else { \/\/ Old date is Mar 01 or later. if (iChronology.isLeapYear(year)) { \/\/ Moving to a leap year, account for Feb 29. dayOfYear++; } } } instant = iChronology.getYearMonthDayMillis(year, 1, dayOfYear); instant += millisOfDay; return instant; }","old_code_raw":"    public long set(long millis, int year) {\n        super.verifyValueBounds(year, iChronology.getMinYear(), iChronology.getMaxYear());\n\n        int dayOfYear = iChronology.dayOfYear().get(millis);\n        int millisOfDay = iChronology.millisOfDay().get(millis);\n\n        if (dayOfYear > (31 + 28)) { \/\/ after Feb 28\n            if (isLeap(millis)) {\n                \/\/ Old date is Feb 29 or later.\n                if (!iChronology.isLeapYear(year)) {\n                    \/\/ Moving to a non-leap year, Feb 29 does not exist.\n                    dayOfYear--;\n                }\n            } else {\n                \/\/ Old date is Mar 01 or later.\n                if (iChronology.isLeapYear(year)) {\n                    \/\/ Moving to a leap year, account for Feb 29.\n                    dayOfYear++;\n                }\n            }\n        }\n\n        millis = iChronology.getYearMonthDayMillis(year, 1, dayOfYear);\n        millis += millisOfDay;\n\n        return millis;\n    }\n","new_comment_raw":"@param instant the time instant in millis to update.","old_comment_raw":"@param millis the time instant in millis to update.","label":1,"pre_label":0,"AST_level":10,"line_counts":29,"new_code_token_num":172},{"new_code_raw":"protected String[] convert(Path<?> leftHandSide, Object rightHandSide) { String str = rightHandSide.toString(); if (lowerCase){ str = str.toLowerCase(); } if (splitTerms) { if (str.equals(\"\")) { return new String[] { str }; } else { return StringUtils.split(str); } } else { return new String[] { str }; } }","old_code_raw":"    protected String convert(Path<?> path, Object value){\n        return value.toString();\n    }\n","new_comment_raw":"@param rightHandSide","old_comment_raw":"@param value","label":1,"pre_label":0,"AST_level":10,"line_counts":16,"new_code_token_num":82},{"new_code_raw":"public Client testClassname(Client client, Map<String, Object> params) throws IOException { HttpResponse response = testClassnameForHttpResponse(client, params); TypeReference typeRef = new TypeReference<Client>() {}; return apiClient.getObjectMapper().readValue(response.getContent(), typeRef); }","old_code_raw":"    public Client testClassname(Client body, Map<String, Object> params) throws IOException {\n        HttpResponse response = testClassnameForHttpResponse(body, params);\n        TypeReference typeRef = new TypeReference<Client>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    }\n","new_comment_raw":"@param client client model","old_comment_raw":"@param body client model","label":1,"pre_label":0,"AST_level":8,"line_counts":6,"new_code_token_num":51},{"new_code_raw":"public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); final String url = buildUrl(path, queryParams); final Request.Builder reqBuilder = new Request.Builder().url(url); processHeaderParams(headerParams, reqBuilder); String contentType = (String) headerParams.get(\"Content-Type\"); \/\/ ensuring a default content type if (contentType == null) contentType = \"application\/json\"; RequestBody reqBody; if (!HttpMethod.permitsRequestBody(method)) { reqBody = null; } else if (\"application\/x-www-form-urlencoded\".equals(contentType)) { reqBody = buildRequestBodyFormEncoding(formParams); } else if (\"multipart\/form-data\".equals(contentType)) { reqBody = buildRequestBodyMultipart(formParams); } else if (body == null) { if (\"DELETE\".equals(method)) { \/\/ allow calling DELETE without sending a request body reqBody = null; } else { \/\/ use an empty request body (for POST, PUT and PATCH) reqBody = RequestBody.create(MediaType.parse(contentType), \"\"); } } else { reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType)); } Request request = null; if(progressRequestListener != null) { ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, progressRequestListener); request = reqBuilder.method(method, progressRequestBody).build(); } else { request = reqBuilder.method(method, reqBody).build(); } return httpClient.newCall(request); }","old_code_raw":"  public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    final String url = buildUrl(path, queryParams);\n    final Request.Builder reqBuilder = new Request.Builder().url(url);\n    processHeaderParams(headerParams, reqBuilder);\n\n    String contentType = (String) headerParams.get(\"Content-Type\");\n    \/\/ ensuring a default content type\n    if (contentType == null) contentType = \"application\/json\";\n\n    RequestBody reqBody;\n    if (!HttpMethod.permitsRequestBody(method)) {\n      reqBody = null;\n    } else if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n      reqBody = buildRequestBodyFormEncoding(formParams);\n    } else if (\"multipart\/form-data\".equals(contentType)) {\n      reqBody = buildRequestBodyMultipart(formParams);\n    } else if (body == null) {\n      if (\"DELETE\".equals(method)) {\n        \/\/ allow calling DELETE without sending a request body\n        reqBody = null;\n      } else {\n        \/\/ use an empty request body (for POST, PUT and PATCH)\n        reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n      }\n    } else {\n      reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType));\n    }\n\n    Request request = reqBuilder.method(method, reqBody).build();\n    return httpClient.newCall(request);\n  }\n","new_comment_raw":"@param formParams The form parameters","old_comment_raw":"@param formParams The form parameters","label":0,"pre_label":1,"AST_level":14,"line_counts":42,"new_code_token_num":325},{"new_code_raw":"public long addWrapped(long instant, int months) { return set(instant, Utils.getWrappedValue(get(instant), months, MIN, MAX)); }","old_code_raw":"    public long addWrapped(long millis, int months) {\n        return set(millis, getWrappedValue(get(millis), months, MIN, MAX));\n    }\n","new_comment_raw":"@param instant the time instant in millis to update.","old_comment_raw":"@param millis the time instant in millis to update.","label":1,"pre_label":0,"AST_level":7,"line_counts":4,"new_code_token_num":33},{"new_code_raw":"private static boolean shouldDelayIdentityInserts(boolean requiresImmediateIdAccess, EventSource source, EntityPersister persister) { return shouldDelayIdentityInserts( requiresImmediateIdAccess, isPartOfTransaction( source ), source.getHibernateFlushMode(), persister ); }","old_code_raw":"\tprivate static boolean shouldDelayIdentityInserts(boolean requiresImmediateIdAccess, EventSource source) {\n\t\treturn shouldDelayIdentityInserts( requiresImmediateIdAccess, isPartOfTransaction( source ), source.getHibernateFlushMode() );\n\t}\n","new_comment_raw":"@param source The session which is the source of the current event.","old_comment_raw":"@param source The session which is the source of the current event.","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":34},{"new_code_raw":"public Object getCache(PGraphics renderer) { if (cacheMap == null) return null; return cacheMap.get(renderer); }","old_code_raw":"  public Object getCache(Object parent) {\n    if (cacheMap == null) return null;\n    return cacheMap.get(parent);\n  }\n","new_comment_raw":"@param renderer The PGraphics renderer associated to the image","old_comment_raw":"@param parent The PGraphics object (or any object, really) associated","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":24},{"new_code_raw":"public boolean isValid(Litmus litmus, Context context) { return super.isValid(litmus, context) && litmus.check(Util.isDistinct(getRowType().getFieldNames()), \"distinct field names: {}\", getRowType()); }","old_code_raw":"  public boolean isValid(Litmus litmus) {\n    return super.isValid(litmus)\n        && litmus.check(Util.isDistinct(getRowType().getFieldNames()),\n            \"distinct field names: {}\", getRowType());\n  }\n","new_comment_raw":"@param groupSet Bit set of grouping fields","old_comment_raw":"@param groupSet Bit set of grouping fields","label":0,"pre_label":1,"AST_level":8,"line_counts":6,"new_code_token_num":50},{"new_code_raw":"public Single<ModelApiResponse> rxUploadFileWithRequiredFile(Long petId, AsyncFile requiredFile, String additionalMetadata) { return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> { delegate.uploadFileWithRequiredFile(petId, requiredFile, additionalMetadata, fut); })); }","old_code_raw":"    public Single<ModelApiResponse> rxUploadFileWithRequiredFile(Long petId, AsyncFile file, String additionalMetadata) {\n        return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> {\n            delegate.uploadFileWithRequiredFile(petId, file, additionalMetadata, fut);\n        }));\n    }\n","new_comment_raw":"@param requiredFile file to upload (required)","old_comment_raw":"@param file file to upload (required)","label":1,"pre_label":0,"AST_level":10,"line_counts":6,"new_code_token_num":46},{"new_code_raw":"public TableSchema create(String schemaPrefix, String envelopSchemaName, Table table, ColumnNameFilter filter, ColumnMappers mappers, KeyMapper keysMapper) { if (schemaPrefix == null) { schemaPrefix = \"\"; } \/\/ Build the schemas ... final TableId tableId = table.id(); final String tableIdStr = tableSchemaName(tableId); final String schemaNamePrefix = schemaPrefix + tableIdStr; LOGGER.debug(\"Mapping table '{}' to schemas under '{}'\", tableId, schemaNamePrefix); SchemaBuilder valSchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Value\")); SchemaBuilder keySchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Key\")); AtomicBoolean hasPrimaryKey = new AtomicBoolean(false); Key tableKey = new Key.Builder(table).customKeyMapper(keysMapper).build(); tableKey.keyColumns().forEach(column -> { addField(keySchemaBuilder, column, null); hasPrimaryKey.set(true); }); table.columns() .stream() .filter(column -> filter == null || filter.matches(tableId.catalog(), tableId.schema(), tableId.table(), column.name())) .forEach(column -> { ColumnMapper mapper = mappers == null ? null : mappers.mapperFor(tableId, column); addField(valSchemaBuilder, column, mapper); }); Schema valSchema = valSchemaBuilder.optional().build(); Schema keySchema = hasPrimaryKey.get() ? keySchemaBuilder.build() : null; if (LOGGER.isDebugEnabled()) { LOGGER.debug(\"Mapped primary key for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(keySchema)); LOGGER.debug(\"Mapped columns for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(valSchema)); } Envelope envelope = Envelope.defineSchema() .withName(schemaNameAdjuster.adjust(envelopSchemaName)) .withRecord(valSchema) .withSource(sourceInfoSchema) .build(); \/\/ Create the generators ... Function<Object[], Object> keyGenerator = createKeyGenerator(keySchema, tableId, tableKey.keyColumns()); Function<Object[], Struct> valueGenerator = createValueGenerator(valSchema, tableId, table.columns(), filter, mappers); \/\/ And the table schema ... return new TableSchema(tableId, keySchema, keyGenerator, envelope, valSchema, valueGenerator); }","old_code_raw":"    public TableSchema create(String schemaPrefix, String envelopSchemaName, Table table, ColumnNameFilter filter, ColumnMappers mappers, CustomKeyMapper keysMapper) {\n        if (schemaPrefix == null) {\n            schemaPrefix = \"\";\n        }\n\n        \/\/ Build the schemas ...\n        final TableId tableId = table.id();\n        final String tableIdStr = tableSchemaName(tableId);\n        final String schemaNamePrefix = schemaPrefix + tableIdStr;\n        LOGGER.debug(\"Mapping table '{}' to schemas under '{}'\", tableId, schemaNamePrefix);\n        SchemaBuilder valSchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Value\"));\n        SchemaBuilder keySchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Key\"));\n        AtomicBoolean hasPrimaryKey = new AtomicBoolean(false);\n        \n        Key tableKey = new Key.Builder(table).customKeyMapper(keysMapper).build();\n        tableKey.keyColumns().forEach(column -> {\n            addField(keySchemaBuilder, column, null);\n            hasPrimaryKey.set(true);\n        });\n        \n        table.columns()\n            .stream()\n            .filter(column -> filter == null || filter.matches(tableId.catalog(), tableId.schema(), tableId.table(), column.name()))\n            .forEach(column -> {\n                ColumnMapper mapper = mappers == null ? null : mappers.mapperFor(tableId, column);\n                addField(valSchemaBuilder, column, mapper);\n            });\n        \n        Schema valSchema = valSchemaBuilder.optional().build();\n        Schema keySchema = hasPrimaryKey.get() ? keySchemaBuilder.build() : null;\n\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"Mapped primary key for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(keySchema));\n            LOGGER.debug(\"Mapped columns for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(valSchema));\n        }\n\n        Envelope envelope = Envelope.defineSchema()\n                .withName(schemaNameAdjuster.adjust(envelopSchemaName))\n                .withRecord(valSchema)\n                .withSource(sourceInfoSchema)\n                .build();\n\n\n        \/\/ Create the generators ...\n        Function<Object[], Object> keyGenerator = createKeyGenerator(keySchema, tableId, tableKey.keyColumns());\n        Function<Object[], Struct> valueGenerator = createValueGenerator(valSchema, tableId, table.columns(), filter, mappers);\n\n        \/\/ And the table schema ...\n        return new TableSchema(tableId, keySchema, keyGenerator, envelope, valSchema, valueGenerator);\n    }\n","new_comment_raw":"@param table the table definition; may not be null","old_comment_raw":"@param table the table definition; may not be null","label":0,"pre_label":1,"AST_level":11,"line_counts":51,"new_code_token_num":433},{"new_code_raw":"private List<File> getCandidateFiles(final Path directory) { Preconditions.checkNotNull(directory); final List<File> candidateFiles = new ArrayList<>(); try { Files.walkFileTree(directory, new SimpleFileVisitor<Path>() { @Override public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException { if (directory.equals(dir)) { \/\/ The top directory should always be listed return FileVisitResult.CONTINUE; } String directoryName = dir.getFileName().toString(); if (!recursiveDirectorySearch || directoryName.startsWith(\".\") || ignorePattern.matcher(directoryName).matches()) { return FileVisitResult.SKIP_SUBTREE; } return FileVisitResult.CONTINUE; } @Override public FileVisitResult visitFile(Path candidate, BasicFileAttributes attrs) throws IOException { String fileName = candidate.getFileName().toString(); if (!fileName.endsWith(completedSuffix) && !fileName.startsWith(\".\") && !ignorePattern.matcher(fileName).matches()) { candidateFiles.add(candidate.toFile()); } return FileVisitResult.CONTINUE; } }); } catch (IOException e) { logger.error(\"I\/O exception occurred while listing directories. \" + \"Files already matched will be returned. \" + directory, e); } return candidateFiles; }","old_code_raw":"  private List<File> getCandidateFiles(File directory) {\n    Preconditions.checkNotNull(directory);\n    List<File> candidateFiles = new ArrayList<File>();\n    if (!directory.isDirectory()) {\n      return candidateFiles;\n    }\n\n    for (File file : directory.listFiles(filter)) {\n      if (file.isDirectory()) {\n        candidateFiles.addAll(getCandidateFiles(file));\n      } else {\n        candidateFiles.add(file);\n      }\n    }\n\n    return candidateFiles;\n  }\n","new_comment_raw":"@param directory the directory to gather files from","old_comment_raw":"@param directory the directory to gather files from","label":0,"pre_label":1,"AST_level":12,"line_counts":41,"new_code_token_num":233},{"new_code_raw":"public List<String> generateCreationCommands(Metadata metadata, boolean createNamespaces, Dialect dialect) { final ArrayList<String> commands = new ArrayList<String>(); doCreation( metadata, createNamespaces, dialect, new Target() { @Override public boolean acceptsImportScriptActions() { return true; } @Override public void prepare() { } @Override public void accept(String action) { commands.add( action ); } @Override public void release() { } } ); return commands; }","old_code_raw":"\tpublic List<String> generateCreationCommands(Metadata metadata, boolean createSchemas, Dialect dialect) {\n\t\tfinal ArrayList<String> commands = new ArrayList<String>();\n\t\tdoCreation(\n\t\t\t\tmetadata,\n\t\t\t\tcreateSchemas,\n\t\t\t\tdialect,\n\t\t\t\tnew Target() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean acceptsImportScriptActions() {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void prepare() {\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void accept(String action) {\n\t\t\t\t\t\tcommands.add( action );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void release() {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\treturn commands;\n\t}\n","new_comment_raw":"@param createNamespaces Should the schema(s)\/catalog(s) actually be created as well ( CREATE SCHEMA)?","old_comment_raw":"@param createSchemas Should the schema(s) actually be created as well ( CREATE SCHEMA)?","label":1,"pre_label":0,"AST_level":9,"line_counts":30,"new_code_token_num":92},{"new_code_raw":"public List<String> generateCreationCommands(Metadata metadata, boolean createNamespaces) { final ArrayList<String> commands = new ArrayList<String>(); doCreation( metadata, createNamespaces, new Target() { @Override public boolean acceptsImportScriptActions() { return true; } @Override public void prepare() { } @Override public void accept(String action) { commands.add( action ); } @Override public void release() { } } ); return commands; }","old_code_raw":"\tpublic List<String> generateCreationCommands(Metadata metadata, boolean createSchemas) {\n\t\tfinal ArrayList<String> commands = new ArrayList<String>();\n\t\tdoCreation(\n\t\t\t\tmetadata,\n\t\t\t\tcreateSchemas,\n\t\t\t\tnew Target() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean acceptsImportScriptActions() {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void prepare() {\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void accept(String action) {\n\t\t\t\t\t\tcommands.add( action );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void release() {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\treturn commands;\n\t}\n","new_comment_raw":"@param metadata The metadata for which to generate the creation commands.","old_comment_raw":"@param metadata The metadata for which to generate the creation commands.","label":0,"pre_label":1,"AST_level":9,"line_counts":28,"new_code_token_num":87},{"new_code_raw":"public static long toMicroOfDay(Object value, boolean acceptLargeValues) { if (value instanceof Duration) { Duration duration = (Duration) value; if (!acceptLargeValues && (duration.isNegative() || duration.compareTo(ONE_DAY) > 0)) { throw new IllegalArgumentException(\"Time values must be between 00:00:00 and 24:00:00 (inclusive): \" + duration); } \/\/ conversion to nanos is fine as TIME values won't exceed long range return ((Duration) value).toNanos() \/ 1_000; } \/\/ TODO only needed for SQL Server\/Oracle, where we don't produce Duration right away; \/\/ this should go eventually, as the conversion to LocalTime is superfluous LocalTime time = Conversions.toLocalTime(value); return Math.floorDiv(time.toNanoOfDay(), Conversions.NANOSECONDS_PER_MICROSECOND); }","old_code_raw":"    public static long toMicroOfDay(Object value, TemporalAdjuster adjuster) {\n        \/\/ conversion to nanos is fine as TIME values won't exceed long range\n        if (value instanceof Duration) {\n            return ((Duration) value).toNanos() \/ 1_000;\n        }\n\n        LocalTime time = Conversions.toLocalTime(value);\n        if (adjuster != null) {\n            time = time.with(adjuster);\n        }\n        return Math.floorDiv(time.toNanoOfDay(), Conversions.NANOSECONDS_PER_MICROSECOND);\n    }\n","new_comment_raw":"@param acceptLargeValues whether to accept values less than 00:00:00 and larger than 24:00:00 or not","old_comment_raw":"@param adjuster the optional component that adjusts the local date value before obtaining the epoch day; may be null if no adjustment is necessary","label":1,"pre_label":0,"AST_level":10,"line_counts":17,"new_code_token_num":166},{"new_code_raw":"public static VersionProperty buildVersionProperty(SimpleAttributeBinding property, boolean lazyAvailable) { String mappedUnsavedValue = ( (KeyValue) property.getValue() ).getNullValue(); VersionValue unsavedValue = UnsavedValueFactory.getUnsavedVersionValue( mappedUnsavedValue, getGetter( property ), ( VersionType ) property.getHibernateTypeDescriptor().getExplicitType(), getConstructor( property.getEntityBinding() ) ); boolean lazy = lazyAvailable && property.isLazy(); return new VersionProperty( property.getAttribute().getName(), property.getNodeName(), property.getHibernateTypeDescriptor().getExplicitType(), lazy, property.isInsertable(), property.isUpdatable(), property.getGeneration() == PropertyGeneration.INSERT || property.getGeneration() == PropertyGeneration.ALWAYS, property.getGeneration() == PropertyGeneration.ALWAYS, property.isNullable(), property.isUpdatable() && !lazy, property.isOptimisticLockable(), \/\/ TODO: get cascadeStyle from property when HHH-6355 is fixed; for now, assume NONE \/\/property.getCascadeStyle(), CascadeStyle.NONE, unsavedValue ); }","old_code_raw":"\tpublic static VersionProperty buildVersionProperty(SimpleSingularAttributeBinding property, boolean lazyAvailable) {\n\t\tString mappedUnsavedValue = ( (KeyValue) property.getValue() ).getNullValue();\n\n\t\tVersionValue unsavedValue = UnsavedValueFactory.getUnsavedVersionValue(\n\t\t\t\tmappedUnsavedValue,\n\t\t\t\tgetGetter( property ),\n\t\t\t\t(VersionType) property.getHibernateTypeDescriptor().getResolvedTypeMapping(),\n\t\t\t\tgetConstructor( property.getEntityBinding() )\n\t\t);\n\n\t\tboolean lazy = lazyAvailable && property.isLazy();\n\n\t\tfinal CascadeStyle cascadeStyle = property.isAssociation()\n\t\t\t\t? ( (AssociationAttributeBinding) property ).getCascadeStyle()\n\t\t\t\t: CascadeStyle.NONE;\n\n\t\treturn new VersionProperty(\n\t\t        property.getAttribute().getName(),\n\t\t        null,\n\t\t        property.getHibernateTypeDescriptor().getResolvedTypeMapping(),\n\t\t        lazy,\n\t\t\t\ttrue, \/\/ insertable\n\t\t\t\ttrue, \/\/ updatable\n\t\t        property.getGeneration() == PropertyGeneration.INSERT\n\t\t\t\t\t\t|| property.getGeneration() == PropertyGeneration.ALWAYS,\n\t\t\t\tproperty.getGeneration() == PropertyGeneration.ALWAYS,\n\t\t\t\tproperty.isNullable(),\n\t\t\t\t!lazy,\n\t\t\t\tproperty.isIncludedInOptimisticLocking(),\n\t\t\t\tcascadeStyle,\n\t\t        unsavedValue\n\t\t\t);\n\t}\n","new_comment_raw":"@param lazyAvailable Is property lazy loading currently available.","old_comment_raw":"@param lazyAvailable Is property lazy loading currently available.","label":0,"pre_label":1,"AST_level":8,"line_counts":31,"new_code_token_num":181},{"new_code_raw":"public Action timedout(AtmosphereRequest request, AtmosphereResponse response) throws IOException, ServletException { AtmosphereResourceImpl r = null; try { if (trackActiveRequest) { long l = (Long) request.getAttribute(MAX_INACTIVE); if (l == -1) { \/\/ The closedDetector closed the connection. return timedoutAction; } request.setAttribute(MAX_INACTIVE, (long) -1); } logger.debug(\"Timing out the connection for request {}\", request); \/\/ Something went wrong. if (request == null || response == null) { logger.warn(\"Invalid Request\/Response: {}\/{}\", request, response); return timedoutAction; } r = (AtmosphereResourceImpl) request.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE); if (r != null && r.getAtmosphereResourceEvent().isSuspended()) { r.getAtmosphereResourceEvent().setIsResumedOnTimeout(true); Broadcaster b = r.getBroadcaster(); if (b instanceof DefaultBroadcaster) { ((DefaultBroadcaster) b).broadcastOnResume(r); } if (request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT) != null) { r.getAtmosphereResourceEvent().setIsResumedOnTimeout( (Boolean) request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT)); } invokeAtmosphereHandler(r); } } catch (Throwable t) { logger.error(\"failed to timeout resource {}\", r, t); } finally { try { if (r != null) { r.notifyListeners(); r.setIsInScope(false); r.cancel(); } } catch (Throwable t) { logger.trace(\"timedout\", t); } finally { try { response.getOutputStream().close(); } catch (Throwable t) { try { response.getWriter().close(); } catch (Throwable t2) { } } if (r != null) { destroyResource(r); } } } return timedoutAction; }","old_code_raw":"    public Action timedout(HttpServletRequest request, HttpServletResponse response)\n            throws IOException, ServletException {\n\n        AtmosphereResourceImpl r = null;\n        try {\n            if (trackActiveRequest) {\n                long l = (Long) request.getAttribute(MAX_INACTIVE);\n                if (l == -1) {\n                    \/\/ The closedDetector closed the connection.\n                    return timedoutAction;\n                }\n                request.setAttribute(MAX_INACTIVE, (long) -1);\n            }\n\n            logger.debug(\"Timing out the connection for request {}\", request);\n\n            \/\/ Something went wrong.\n            if (request == null || response == null) {\n                logger.warn(\"Invalid Request\/Response: {}\/{}\", request, response);\n                return timedoutAction;\n            }\n\n            r = (AtmosphereResourceImpl) request.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE);\n\n            if (r != null && r.getAtmosphereResourceEvent().isSuspended()) {\n                r.getAtmosphereResourceEvent().setIsResumedOnTimeout(true);\n\n                Broadcaster b = r.getBroadcaster();\n                if (b instanceof DefaultBroadcaster) {\n                    ((DefaultBroadcaster) b).broadcastOnResume(r);\n                }\n\n                if (request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT) != null) {\n                    r.getAtmosphereResourceEvent().setIsResumedOnTimeout(\n                            (Boolean) request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT));\n                }\n\n                invokeAtmosphereHandler(r);\n            }\n        } catch (Throwable t) {\n            logger.error(\"failed to timeout resource {}\", r, t);\n        } finally {\n            try {\n                if (r != null) {\n                    r.notifyListeners();\n                    r.setIsInScope(false);\n                    r.cancel();\n                }\n            } catch (Throwable t) {\n                logger.trace(\"timedout\", t);\n            } finally {\n\n                try {\n                    response.getOutputStream().close();\n                } catch (Throwable t) {\n                    try {\n                        response.getWriter().close();\n                    } catch (Throwable t2) {\n                    }\n                }\n\n                if (r != null) {\n                    destroyResource(r);\n                }\n            }\n        }\n\n        return timedoutAction;\n    }\n","new_comment_raw":"@param response the  AtmosphereResponse","old_comment_raw":"@param response the HttpServletResponse","label":1,"pre_label":0,"AST_level":13,"line_counts":70,"new_code_token_num":351},{"new_code_raw":"public static boolean isTransient(String entityName, Object entity, Boolean assumed, SharedSessionContractImplementor session) { if ( entity == LazyPropertyInitializer.UNFETCHED_PROPERTY ) { \/\/ an unfetched association can only point to \/\/ an entity that already exists in the db return false; } \/\/ let the interceptor inspect the instance to decide Boolean isUnsaved = session.getInterceptor().isTransient( entity ); if ( isUnsaved != null ) { return isUnsaved; } \/\/ let the persister inspect the instance to decide final EntityPersister persister = session.getEntityPersister( entityName, entity ); isUnsaved = persister.isTransient( entity, session ); if ( isUnsaved != null ) { return isUnsaved; } \/\/ we use the assumed value, if there is one, to avoid hitting \/\/ the database if ( assumed != null ) { return assumed; } \/\/ hit the database, afterQuery checking the session cache for a snapshot final Object[] snapshot = session.getPersistenceContext().getDatabaseSnapshot( persister.getIdentifier( entity, session ), persister ); return snapshot == null; }","old_code_raw":"\tpublic static boolean isTransient(String entityName, Object entity, Boolean assumed, SessionImplementor session) {\n\t\tif ( entity == LazyPropertyInitializer.UNFETCHED_PROPERTY ) {\n\t\t\t\/\/ an unfetched association can only point to\n\t\t\t\/\/ an entity that already exists in the db\n\t\t\treturn false;\n\t\t}\n\n\t\t\/\/ let the interceptor inspect the instance to decide\n\t\tBoolean isUnsaved = session.getInterceptor().isTransient( entity );\n\t\tif ( isUnsaved != null ) {\n\t\t\treturn isUnsaved;\n\t\t}\n\n\t\t\/\/ let the persister inspect the instance to decide\n\t\tfinal EntityPersister persister = session.getEntityPersister( entityName, entity );\n\t\tisUnsaved = persister.isTransient( entity, session );\n\t\tif ( isUnsaved != null ) {\n\t\t\treturn isUnsaved;\n\t\t}\n\n\t\t\/\/ we use the assumed value, if there is one, to avoid hitting\n\t\t\/\/ the database\n\t\tif ( assumed != null ) {\n\t\t\treturn assumed;\n\t\t}\n\n\t\t\/\/ hit the database, after checking the session cache for a snapshot\n\t\tfinal Object[] snapshot = session.getPersistenceContext().getDatabaseSnapshot(\n\t\t\t\tpersister.getIdentifier( entity, session ),\n\t\t\t\tpersister\n\t\t);\n\t\treturn snapshot == null;\n\n\t}\n","new_comment_raw":"@param entityName The name of the entity","old_comment_raw":"@param entityName The name of the entity","label":0,"pre_label":1,"AST_level":8,"line_counts":35,"new_code_token_num":193},{"new_code_raw":"private HttpSession getMatchingHttpSession(List<HttpCookie> cookies, final HttpSessionTokensSet siteTokens) { \/\/ Pre-checks if (sessions.isEmpty()) { return null; } List<HttpSession> matchingSessions = new LinkedList<>(sessions); for (String token : siteTokens.getTokensSet()) { \/\/ Get the corresponding cookie from the cookies list HttpCookie matchingCookie = null; for (HttpCookie cookie : cookies) { if (cookie.getName().equals(token)) { matchingCookie = cookie; break; } } \/\/ Filter the sessions that do not match the cookie value Iterator<HttpSession> it = matchingSessions.iterator(); while (it.hasNext()) { if (!it.next().matchesToken(token, matchingCookie)) { it.remove(); } } } \/\/ Return the matching session if (matchingSessions.size() >= 1) { if (matchingSessions.size() > 1) { log.warn(\"Multiple sessions matching the cookies from response for site: \" + getSite() + \". Using first one.\"); } return matchingSessions.get(0); } return null; }","old_code_raw":"\tprivate HttpSession getMatchingHttpSession(List<HttpCookie> cookies, final Set<String> tokens) {\n\n\t\t\/\/ Pre-checks\n\t\tif (sessions.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tList<HttpSession> matchingSessions = new LinkedList<>(sessions);\n\t\tfor (String token : tokens) {\n\t\t\t\/\/ Get the corresponding cookie from the cookies list\n\t\t\tHttpCookie matchingCookie = null;\n\t\t\tfor (HttpCookie cookie : cookies) {\n\t\t\t\tif (cookie.getName().equals(token)) {\n\t\t\t\t\tmatchingCookie = cookie;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/ Filter the sessions that do not match the cookie value\n\t\t\tIterator<HttpSession> it = matchingSessions.iterator();\n\t\t\twhile (it.hasNext()) {\n\t\t\t\tif (!it.next().matchesToken(token, matchingCookie)) {\n\t\t\t\t\tit.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t\/\/ Return the matching session\n\t\tif (matchingSessions.size() >= 1) {\n\t\t\tif (matchingSessions.size() > 1) {\n\t\t\t\tlog.warn(\"Multiple sessions matching the cookies from response for site: \" + getSite()\n\t\t\t\t\t\t+ \". Using first one.\");\n\t\t\t}\n\t\t\treturn matchingSessions.get(0);\n\t\t}\n\t\treturn null;\n\n\t}\n","new_comment_raw":"@param cookies the cookies present in the request header of the message","old_comment_raw":"@param cookies the cookies present in the request header of the message","label":0,"pre_label":1,"AST_level":11,"line_counts":38,"new_code_token_num":206},{"new_code_raw":"public static Area getClickbox(@Nonnull Client client, Model model, int orientation, int localX, int localY) { if (model == null) { return null; } List<Triangle> triangles = model.getTriangles().stream() .map(triangle -> triangle.rotate(orientation)) .collect(Collectors.toList()); List<Vertex> vertices = model.getVertices().stream() .map(v -> v.rotate(orientation)) .collect(Collectors.toList()); Area clickBox = get2DGeometry(client, triangles, orientation, localX, localY); Area visibleAABB = getAABB(client, vertices, orientation, localX, localY); if (visibleAABB == null || clickBox == null) { return null; } clickBox.intersect(visibleAABB); return clickBox; }","old_code_raw":"\tpublic static Area getClickbox(@Nonnull Client client, Model model, int orientation, int tileX, int tileY)\n\t{\n\t\tif (model == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tList<Triangle> triangles = model.getTriangles().stream()\n\t\t\t.map(triangle -> triangle.rotate(orientation))\n\t\t\t.collect(Collectors.toList());\n\n\t\tList<Vertex> vertices = model.getVertices().stream()\n\t\t\t\t.map(v -> v.rotate(orientation))\n\t\t\t\t.collect(Collectors.toList());\n\n\t\tArea clickBox = get2DGeometry(client, triangles, orientation, tileX, tileY);\n\t\tArea visibleAABB = getAABB(client, vertices, orientation, tileX, tileY);\n\n\t\tif (visibleAABB == null || clickBox == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tclickBox.intersect(visibleAABB);\n\t\treturn clickBox;\n\t}\n","new_comment_raw":"@param orientation the orientation of the model (0-2048, where 0 is north)","old_comment_raw":"@param orientation the orientation of the model (0-2048, where 0 is north)","label":0,"pre_label":1,"AST_level":9,"line_counts":27,"new_code_token_num":143},{"new_code_raw":"public static CloudEventsMaker create(RecordParser parser, SerializerType contentType, String dataSchemaUriBase) { switch (parser.connectorType()) { case \"mysql\": return new MysqlCloudEventsMaker(parser, contentType, dataSchemaUriBase); case \"postgresql\": return new PostgresCloudEventsMaker(parser, contentType, dataSchemaUriBase); case \"mongodb\": return new MongodbCloudEventsMaker(parser, contentType, dataSchemaUriBase); case \"sqlserver\": return new SqlserverCloudEventsMaker(parser, contentType, dataSchemaUriBase); default: throw new DataException(\"No usable CloudEvents converters for connector type \\\"\" + parser.connectorType() + \"\\\"\"); } }","old_code_raw":"    public static CloudEventsMaker create(RecordParser parser, SerializerType contentType, String schemaUri) {\n        switch (parser.connectorType()) {\n            case \"mysql\":\n                return new MysqlCloudEventsMaker(parser, contentType, schemaUri);\n            case \"postgresql\":\n                return new PostgresCloudEventsMaker(parser, contentType, schemaUri);\n            case \"mongodb\":\n                return new MongodbCloudEventsMaker(parser, contentType, schemaUri);\n            case \"sqlserver\":\n                return new SqlserverCloudEventsMaker(parser, contentType, schemaUri);\n            default:\n                throw new DataException(\"No usable CloudEvents converters for connector type \\\"\" + parser.connectorType() + \"\\\"\");\n        }\n    }\n","new_comment_raw":"@param contentType the data content type of CloudEvents","old_comment_raw":"@param contentType the data content type of CloudEvents","label":0,"pre_label":1,"AST_level":9,"line_counts":15,"new_code_token_num":118},{"new_code_raw":"protected boolean canImplement(LogicalCalc rel, String relTypeName) { for (RelType relType : relTypes) { if (relType.name.equals(relTypeName)) { return relType.canImplement(rel.getProgram()); } } throw Util.newInternal(\"unknown type \" + relTypeName); }","old_code_raw":"  protected boolean canImplement(CalcRel rel, String relTypeName) {\n    for (RelType relType : relTypes) {\n      if (relType.name.equals(relTypeName)) {\n        return relType.canImplement(rel.getProgram());\n      }\n    }\n    throw Util.newInternal(\"unknown reltype \" + relTypeName);\n  }\n","new_comment_raw":"@param rel Calculation relational expression","old_comment_raw":"@param rel Calculation relational expression","label":0,"pre_label":1,"AST_level":9,"line_counts":9,"new_code_token_num":54},{"new_code_raw":"private JSONObject httpMessageToJSON(HttpMessage msg) { JSONObject ja = new JSONObject(); ja.put(\"id\", msg.getHistoryRef().getHistoryId()); ja.put(\"cookieParams\", XMLStringUtil.escapeControlChrs(msg.getCookieParamsAsString())); ja.put(\"note\", msg.getNote()); ja.put(\"requestHeader\", XMLStringUtil.escapeControlChrs(msg.getRequestHeader().toString())); ja.put(\"requestBody\", XMLStringUtil.escapeControlChrs(msg.getRequestBody().toString())); ja.put(\"responseHeader\", XMLStringUtil.escapeControlChrs(msg.getResponseHeader().toString())); if (HttpHeader.GZIP.equals(msg.getResponseHeader().getHeader(HttpHeader.CONTENT_ENCODING))) { \/\/ Uncompress gziped content try { ByteArrayInputStream bais = new ByteArrayInputStream(msg.getResponseBody().getBytes()); GZIPInputStream gis = new GZIPInputStream(bais); InputStreamReader isr = new InputStreamReader(gis); BufferedReader br = new BufferedReader(isr); StringBuilder sb = new StringBuilder(); String line = null; while ((line = br.readLine()) != null) { sb.append(line); } br.close(); isr.close(); gis.close(); bais.close(); ja.put(\"responseBody\", XMLStringUtil.escapeControlChrs(sb.toString())); } catch (IOException e) { \/\/this.log.error(e.getMessage(), e); System.out.println(e); } } else { ja.put(\"responseBody\", XMLStringUtil.escapeControlChrs(msg.getResponseBody().toString())); } return ja; }","old_code_raw":"\tprivate JSONObject httpMessageToJSON(HttpMessage hm) {\n\t\tJSONObject ja = new JSONObject();\n\t\tja.put(\"cookieParams\", XMLStringUtil.escapeControlChrs(hm.getCookieParamsAsString()));\n\t\tja.put(\"note\", hm.getNote());\n\t\tja.put(\"requestHeader\", XMLStringUtil.escapeControlChrs(hm.getRequestHeader().toString()));\n\t\tja.put(\"requestBody\", XMLStringUtil.escapeControlChrs(hm.getRequestBody().toString()));\n\t\tja.put(\"responseHeader\", XMLStringUtil.escapeControlChrs(hm.getResponseHeader().toString()));\n\t\t\n\t\tif (HttpHeader.GZIP.equals(hm.getResponseHeader().getHeader(HttpHeader.CONTENT_ENCODING))) {\n\t\t\t\/\/ Uncompress gziped content\n\t\t\ttry {\n\t\t\t\tByteArrayInputStream bais = new ByteArrayInputStream(hm.getResponseBody().getBytes());\n\t\t\t\tGZIPInputStream gis = new GZIPInputStream(bais);\n\t\t\t\tInputStreamReader isr = new InputStreamReader(gis);\n\t\t\t\tBufferedReader br = new BufferedReader(isr);\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tString line = null;\n\t\t\t\twhile ((line = br.readLine()) != null) {\n\t\t\t\t\tsb.append(line);\n\t\t\t\t}\n\t\t\t\tbr.close();\n\t\t\t\tisr.close();\n\t\t\t\tgis.close();\n\t\t\t\tbais.close();\n\t\t\t\tja.put(\"responseBody\", XMLStringUtil.escapeControlChrs(sb.toString()));\n\t\t\t} catch (IOException e) {\n\t\t\t\t\/\/this.log.error(e.getMessage(), e);\n\t\t\t\tSystem.out.println(e);\n\t\t\t}\n\t\t} else {\n\t\t\tja.put(\"responseBody\", XMLStringUtil.escapeControlChrs(hm.getResponseBody().toString()));\n\t\t}\n\t\t\n\t\treturn ja;\n\t}\n","new_comment_raw":"@param msg","old_comment_raw":"@param hm","label":1,"pre_label":0,"AST_level":10,"line_counts":37,"new_code_token_num":309},{"new_code_raw":"public Boolean fakeOuterBooleanSerialize(Boolean booleanPostBody) throws RestClientException { Object postBody = booleanPostBody; String path = UriComponentsBuilder.fromPath(\"\/fake\/outer\/boolean\").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { \"*\/*\" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<Boolean> returnType = new ParameterizedTypeReference<Boolean>() {}; return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }","old_code_raw":"    public Boolean fakeOuterBooleanSerialize(Boolean body) throws RestClientException {\n        Object postBody = body;\n        \n        String path = UriComponentsBuilder.fromPath(\"\/fake\/outer\/boolean\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<Boolean> returnType = new ParameterizedTypeReference<Boolean>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n","new_comment_raw":"@param booleanPostBody Input boolean as post body","old_comment_raw":"@param body Input boolean as post body","label":1,"pre_label":0,"AST_level":8,"line_counts":22,"new_code_token_num":160},{"new_code_raw":"public Builder field(UnaryOperator<GraphQLInputObjectField.Builder> builderFunction) { assertNotNull(builderFunction, \"builderFunction should not be null\"); GraphQLInputObjectField.Builder builder = GraphQLInputObjectField.newInputObjectField(); builder = builderFunction.apply(builder); return field(builder); }","old_code_raw":"        public Builder field(BuilderFunction<GraphQLInputObjectField.Builder> builderFunction) {\n            assertNotNull(builderFunction, \"builderFunction should not be null\");\n            GraphQLInputObjectField.Builder builder = GraphQLInputObjectField.newInputObjectField();\n            builder = builderFunction.apply(builder);\n            return field(builder);\n        }\n","new_comment_raw":"@param builderFunction a supplier for the builder impl","old_comment_raw":"@param builderFunction a supplier for the builder impl","label":0,"pre_label":1,"AST_level":7,"line_counts":7,"new_code_token_num":45},{"new_code_raw":"public static RelationTriple fromProto(CoreNLPProtos.RelationTriple proto, Annotation doc, int sentenceIndex) { if (Thread.interrupted()) { throw new RuntimeInterruptedException(); } \/\/ Get the spans for the extraction List<CoreLabel> subject = proto.getSubjectTokensList().stream().map(loc -> doc.get(SentencesAnnotation.class).get(loc.getSentenceIndex()).get(TokensAnnotation.class).get(loc.getTokenIndex()) ).collect(Collectors.toList()); List<CoreLabel> relation; if (proto.getRelationTokensCount() == 0) { \/\/ If we don't have a real span for the relation, make a dummy word relation = Collections.singletonList(new CoreLabel(new Word(proto.getRelation()))); } else { relation = proto.getRelationTokensList().stream().map(loc -> doc.get(SentencesAnnotation.class).get(loc.getSentenceIndex()).get(TokensAnnotation.class).get(loc.getTokenIndex()) ).collect(Collectors.toList()); } List<CoreLabel> object = proto.getObjectTokensList().stream().map(loc -> doc.get(SentencesAnnotation.class).get(loc.getSentenceIndex()).get(TokensAnnotation.class).get(loc.getTokenIndex()) ).collect(Collectors.toList()); \/\/ Create the extraction RelationTriple extraction; double confidence = proto.getConfidence(); if (proto.hasTree()) { SemanticGraph tree = fromProto( proto.getTree(), doc.get(SentencesAnnotation.class).get(sentenceIndex).get(TokensAnnotation.class), doc.get(DocIDAnnotation.class), Optional.of(doc)); extraction = new RelationTriple.WithTree(subject, relation, object, tree, confidence); } else { extraction = new RelationTriple(subject, relation, object, confidence); } \/\/ Tweak the extraction if (proto.hasIstmod()) { extraction.istmod(proto.getIstmod()); } if (proto.hasPrefixBe()) { extraction.isPrefixBe(proto.getPrefixBe()); } if (proto.hasSuffixBe()) { extraction.isSuffixBe(proto.getSuffixBe()); } if (proto.hasSuffixOf()) { extraction.isSuffixOf(proto.getSuffixOf()); } \/\/ Return return extraction; }","old_code_raw":"  public static RelationTriple fromProto(CoreNLPProtos.RelationTriple proto, List<CoreLabel> sentence, String docid) {\n    if (Thread.interrupted()) {\n      throw new RuntimeInterruptedException();\n    }\n    \/\/ Get the spans for the extraction\n    List<CoreLabel> subject = proto.getSubjectTokensList().stream().map(sentence::get).collect(Collectors.toList());\n    List<CoreLabel> relation;\n    if (proto.getRelationTokensCount() == 0) {  \/\/ If we don't have a real span for the relation, make a dummy word\n      relation = Collections.singletonList(new CoreLabel(new Word(proto.getRelation())));\n    } else {\n      relation = proto.getRelationTokensList().stream().map(sentence::get).collect(Collectors.toList());\n    }\n    List<CoreLabel> object = proto.getObjectTokensList().stream().map(sentence::get).collect(Collectors.toList());\n\n    \/\/ Create the extraction\n    RelationTriple extraction;\n    double confidence = proto.getConfidence();\n    if (proto.hasTree()) {\n      SemanticGraph tree = fromProto(proto.getTree(), sentence, docid);\n      extraction =  new RelationTriple.WithTree(subject, relation, object, tree, confidence);\n    } else {\n      extraction = new RelationTriple(subject, relation, object, confidence);\n    }\n\n    \/\/ Tweak the extraction\n    if (proto.hasIstmod()) { extraction.istmod(proto.getIstmod()); }\n    if (proto.hasPrefixBe()) { extraction.isPrefixBe(proto.getPrefixBe()); }\n    if (proto.hasSuffixBe()) { extraction.isSuffixBe(proto.getSuffixBe()); }\n    if (proto.hasSuffixOf()) { extraction.isSuffixOf(proto.getSuffixOf()); }\n\n    \/\/ Return\n    return extraction;\n  }\n","new_comment_raw":"@param doc The document we are deserializing. This document should already have a docid annotation set, if there is one.","old_comment_raw":"@param sentence The sentence the triples were extracted from.","label":1,"pre_label":0,"AST_level":13,"line_counts":44,"new_code_token_num":414},{"new_code_raw":"public ArrayList<TextView> clickInList(int line, int index, boolean longClick, int time) { line--; if(line < 0) line = 0; boolean foundList = waiter.waitForView(ListView.class, index); if (!foundList) Assert.assertTrue(\"No ListView with index \" + index + \" is available!\", false); ArrayList<View> views = new ArrayList<View>(); final ListView listView = viewFetcher.getView(ListView.class, null, index); if(listView == null) Assert.assertTrue(\"ListView is null!\", false); View view = listView.getChildAt(line); if(view != null){ views = viewFetcher.getViews(view, true); views = RobotiumUtils.removeInvisibleViews(views); clickOnScreen(view, longClick, time); } return RobotiumUtils.filterViews(TextView.class, views); }","old_code_raw":"\tpublic ArrayList<TextView> clickInList(int line, int index) {\t\n\t\tline--;\n\t\tif(line < 0)\n\t\t\tline = 0;\n\n\t\tboolean foundList = waiter.waitForView(ListView.class, index);\n\t\tif (!foundList) \n\t\t\tAssert.assertTrue(\"No ListView with index \" + index + \" is available!\", false);\n\n\t\tArrayList<View> views = new ArrayList<View>();\n\t\tfinal ListView listView = viewFetcher.getView(ListView.class, null, index);\n\t\tif(listView == null)\n\t\t\tAssert.assertTrue(\"ListView is null!\", false);\n\n\t\tView view = listView.getChildAt(line);\n\t\tif(view != null){\n\t\t\tviews = viewFetcher.getViews(view, true);\n\t\t\tviews = RobotiumUtils.removeInvisibleViews(views);\n\t\t\tclickOnScreen(view);\n\t\t}\n\t\treturn RobotiumUtils.filterViews(TextView.class, views);\n\t}\n","new_comment_raw":"@param index the index of the list. E.g. Index 1 if two lists are available","old_comment_raw":"@param index the index of the list. E.g. Index 1 if two lists are available","label":0,"pre_label":1,"AST_level":8,"line_counts":23,"new_code_token_num":160},{"new_code_raw":"protected URL isProxied(HttpURI uri) throws MalformedURLException { \/\/ Is this a proxy request? if (isForbidden(uri)) return null; \/\/ OK return URI as untransformed URL. return new URL(uri.toString()); }","old_code_raw":"  protected URL isProxied(URI uri) throws MalformedURLException {\n    \/\/ Is this a proxy request?\n    if (isForbidden(uri))\n      return null;\n\n    \/\/ OK return URI as untransformed URL.\n    return new URL(uri.toString());\n  }\n","new_comment_raw":"@param uri The requested URI, which should include a scheme, host and port.","old_comment_raw":"@param uri The requested URI, which should include a scheme, host and port.","label":0,"pre_label":1,"AST_level":5,"line_counts":9,"new_code_token_num":47},{"new_code_raw":"public ArrayList<TextView> clickInList(int line, int listIndex) { return soloClick.clickInList(line, listIndex); }","old_code_raw":"\tpublic ArrayList<TextView> clickInList(int line, int index) {\n\treturn soloClick.clickInList(line, index);\n\t}\n","new_comment_raw":"@param listIndex the index of the list. E.g. Index 1 if two lists are available","old_comment_raw":"@param index the index of the list. E.g. Index 1 if two lists are available","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":22},{"new_code_raw":"public Tree apply(Object in) { List<? extends HasWord> lst; if (in instanceof String) { TokenizerFactory<? extends HasWord> tf = op.tlpParams.treebankLanguagePack().getTokenizerFactory(); Tokenizer<? extends HasWord> tokenizer = tf.getTokenizer(new BufferedReader(new StringReader((String) in))); lst = tokenizer.tokenize(); } else if (in instanceof List) { lst = ErasureUtils.uncheckedCast(in); } else { throw new IllegalArgumentException(\"Can only parse Sentence\/List\/String\"); } try { LexicalizedParserQuery pq = new LexicalizedParserQuery(this); if (pq.parse(lst)) { Tree bestparse = pq.getBestParse(); \/\/ -10000 denotes unknown words bestparse.setScore(pq.getPCFGScore() % -10000.0); return bestparse; } } catch (Exception e) { System.err.println(\"Following exception caught during parsing:\"); e.printStackTrace(); System.err.println(\"Recovering using fall through strategy: will construct an (X ...) tree.\"); } \/\/ if can't parse or exception, fall through \/\/ TODO: merge with ParserAnnotatorUtils TreeFactory lstf = new LabeledScoredTreeFactory(); List<Tree> lst2 = new ArrayList<Tree>(); for (HasWord obj : lst) { String s = obj.word(); Tree t = lstf.newLeaf(s); Tree t2 = lstf.newTreeNode(\"X\", Collections.singletonList(t)); lst2.add(t2); } return lstf.newTreeNode(\"X\", lst2); }","old_code_raw":"  public Tree apply(List<? extends HasWord> words) {\n    return parse(words);\n  }\n","new_comment_raw":"@param in The input Sentence\/List\/String","old_comment_raw":"@param words The input sentence (a List of words)","label":1,"pre_label":0,"AST_level":11,"line_counts":38,"new_code_token_num":290},{"new_code_raw":"public static String uniquify(String name, Set<String> nameList) { if (name == null) { name = \"EXPR$\"; } if (nameList.add(name)) { return name; } String aliasBase = name; for (int j = 0;; j++) { name = aliasBase + j; if (nameList.add(name)) { return name; } } }","old_code_raw":"    public static String uniquify(String name, Collection<String> nameList)\n    {\n        if (name == null) {\n            name = \"EXPR$\";\n        }\n        if (nameList.contains(name)) {\n            String aliasBase = name;\n            for (int j = 0;; j++) {\n                name = aliasBase + j;\n                if (!nameList.contains(name)) {\n                    break;\n                }\n            }\n        }\n        nameList.add(name);\n        return name;\n    }\n","new_comment_raw":"@param name Suggested name, may not be unique","old_comment_raw":"@param name Suggested name, may not be unique","label":0,"pre_label":1,"AST_level":8,"line_counts":17,"new_code_token_num":75},{"new_code_raw":"public static Predicate<ColumnId> excludeColumns(String columnNames) { return Predicates.excludes(columnNames, ColumnId::toString); }","old_code_raw":"    public static Predicate<ColumnId> excludeColumns(String fullyQualifiedTableNames) {\n        return Predicates.excludes(fullyQualifiedTableNames, ColumnId::toString);\n    }\n","new_comment_raw":"@param columnNames the comma-separated list of column names names to exclude; may be null or empty","old_comment_raw":"@param fullyQualifiedTableNames the comma-separated list of fully-qualified table names to exclude; may be null or empty","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":23},{"new_code_raw":"public boolean putFromLoad(SharedSessionContractImplementor session, Object key, Object value, long txTimestamp, Object version, boolean minimalPutOverride) throws CacheException { if ( !region.checkValid() ) { if ( TRACE_ENABLED ) { log.tracef( \"Region %s not valid\", region.getName() ); } return false; } \/\/ In theory, since putForExternalRead is already as minimal as it can \/\/ get, we shouldn't be need this check. However, without the check and \/\/ without https:\/\/issues.jboss.org\/browse\/ISPN-1986, it's impossible to \/\/ know whether the put actually occurred. Knowing this is crucial so \/\/ that Hibernate can expose accurate statistics. if ( minimalPutOverride && cache.containsKey( key ) ) { return false; } PutFromLoadValidator.Lock lock = putValidator.acquirePutFromLoadLock(session, key, txTimestamp); if ( lock == null) { if ( TRACE_ENABLED ) { log.tracef( \"Put from load lock not acquired for key %s\", key ); } return false; } try { writeCache.putForExternalRead( key, value ); } finally { putValidator.releasePutFromLoadLock( key, lock); } return true; }","old_code_raw":"\tpublic boolean putFromLoad(SessionImplementor session, Object key, Object value, long txTimestamp, Object version, boolean minimalPutOverride)\n\t\t\tthrows CacheException {\n\t\tif ( !region.checkValid() ) {\n\t\t\tif ( TRACE_ENABLED ) {\n\t\t\t\tlog.tracef( \"Region %s not valid\", region.getName() );\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t\/\/ In theory, since putForExternalRead is already as minimal as it can\n\t\t\/\/ get, we shouldn't be need this check. However, without the check and\n\t\t\/\/ without https:\/\/issues.jboss.org\/browse\/ISPN-1986, it's impossible to\n\t\t\/\/ know whether the put actually occurred. Knowing this is crucial so\n\t\t\/\/ that Hibernate can expose accurate statistics.\n\t\tif ( minimalPutOverride && cache.containsKey( key ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tPutFromLoadValidator.Lock lock = putValidator.acquirePutFromLoadLock(session, key, txTimestamp);\n\t\tif ( lock == null) {\n\t\t\tif ( TRACE_ENABLED ) {\n\t\t\t\tlog.tracef( \"Put from load lock not acquired for key %s\", key );\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\ttry {\n\t\t\twriteCache.putForExternalRead( key, value );\n\t\t}\n\t\tfinally {\n\t\t\tputValidator.releasePutFromLoadLock( key, lock);\n\t\t}\n\n\t\treturn true;\n\t}\n","new_comment_raw":"@param key The item key","old_comment_raw":"@param key The item key","label":0,"pre_label":1,"AST_level":9,"line_counts":36,"new_code_token_num":226},{"new_code_raw":"private String getChildSuffix(StructuralNode node, boolean performRecursiveCheck) { String resultSuffix = \"\"; String suffix = null; StructuralNode child = null; try { for (int i = 0; i < staticSuffixList.length; i++) { suffix = staticSuffixList[i]; Iterator<StructuralNode> iter = node.getChildIterator(); while (iter.hasNext()) { child = iter.next(); try { if (child.getURI().getPath().endsWith(suffix)) { return suffix; } } catch (Exception e) { } } } if (performRecursiveCheck) { Iterator<StructuralNode> iter = node.getChildIterator(); while (iter.hasNext()) { child = iter.next(); resultSuffix = getChildSuffix(child, performRecursiveCheck); if (!resultSuffix.equals(\"\")) { return resultSuffix; } } } } catch (Exception e) { } return resultSuffix; }","old_code_raw":"    private String getChildSuffix(SiteNode node, boolean performRecursiveCheck) {\n\n        String resultSuffix = \"\";\n        String suffix = null;\n        SiteNode child = null;\n        HistoryReference ref = null;\n        try {\n\n            for (int i = 0; i < staticSuffixList.length; i++) {\n                suffix = staticSuffixList[i];\n                for (int j = 0; j < node.getChildCount(); j++) {\n                    child = (SiteNode) node.getChildAt(j);\n                    ref = child.getHistoryReference();\n                    try {\n                        if (ref.getURI().getPath().endsWith(suffix)) {\n                            return suffix;\n                        }\n                    } catch (Exception e) {\n                    }\n                }\n            }\n\n            if (performRecursiveCheck) {\n                for (int j = 0; j < node.getChildCount(); j++) {\n                    resultSuffix = getChildSuffix((SiteNode) node.getChildAt(j), performRecursiveCheck);\n                    if (!resultSuffix.equals(\"\")) {\n                        return resultSuffix;\n                    }\n                }\n            }\n\n        } catch (Exception e) {\n        }\n\n        return resultSuffix;\n    }\n","new_comment_raw":"@param performRecursiveCheck True = get recursively the suffix from all the children.","old_comment_raw":"@param performRecursiveCheck True = get recursively the suffix from all the children.","label":0,"pre_label":1,"AST_level":12,"line_counts":38,"new_code_token_num":164},{"new_code_raw":"public Collection<Tree> getRelatedNodes(Tree t, Tree root) { if (root.value() == null) { root.setValue(\"ROOT\"); \/\/ todo: cdm: it doesn't seem like this line should be here } Set<Tree> nodeList = new LinkedHashSet<Tree>(); for (TregexPattern p : targetPatterns) { \/\/ cdm: I deleted: && nodeList.isEmpty() TregexMatcher m = p.matcher(root); while (m.findAt(t)) { nodeList.add(m.getNode(\"target\")); if (DEBUG) { System.err.println(\"found \" + this + \"(\" + t + \", \" + m.getNode(\"target\") + \") using pattern \" + p); for (String nodeName : m.getNodeNames()) { if (nodeName.equals(\"target\")) continue; System.err.println(\" node \" + nodeName + \": \" + m.getNode(nodeName)); } } } } return nodeList; }","old_code_raw":"  public Collection<TreeGraphNode> getRelatedNodes(TreeGraphNode t, TreeGraphNode root, HeadFinder headFinder) {\n    Set<TreeGraphNode> nodeList = new ArraySet<>();\n    for (TregexPattern p : targetPatterns) {    \/\/ cdm: I deleted: && nodeList.isEmpty()\n      \/\/ Initialize the TregexMatcher with the HeadFinder so that we\n      \/\/ can use the same HeadFinder through the entire process of\n      \/\/ building the dependencies\n      TregexMatcher m = p.matcher(root, headFinder);\n      while (m.findAt(t)) {\n        TreeGraphNode target = (TreeGraphNode) m.getNode(\"target\");\n        if (target == null) {\n          throw new AssertionError(\"Expression has no target: \" + p);\n        }\n        nodeList.add(target);\n        if (DEBUG) {\n          System.err.println(\"found \" + this + \"(\" + t + \"-\" + t.headWordNode() + \", \" + m.getNode(\"target\") + \"-\" + ((TreeGraphNode) m.getNode(\"target\")).headWordNode() + \") using pattern \" + p);\n          for (String nodeName : m.getNodeNames()) {\n            if (nodeName.equals(\"target\"))\n              continue;\n            System.err.println(\"  node \" + nodeName + \": \" + m.getNode(nodeName));\n          }\n        }\n      }\n    }\n    return nodeList;\n  }\n","new_comment_raw":"@param t Target for finding governors of t related by this GR","old_comment_raw":"@param t Target for finding dependents of t related by this GR","label":1,"pre_label":0,"AST_level":18,"line_counts":22,"new_code_token_num":200},{"new_code_raw":"public int[] addInField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { int current = values[fieldIndex]; int wrapped = FieldUtils.getWrappedValue (current, valueToAdd, getMinimumValue(instant), getMaximumValue(instant)); return set(instant, fieldIndex, values, wrapped); \/\/ adjusts smaller fields }","old_code_raw":"    public int[] addInField(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd) {\n        int current = values[fieldIndex];\n        int wrapped = FieldUtils.getWrappedValue\n            (current, valueToAdd, getMinimumValue(instant), getMaximumValue(instant));\n        return set(instant, fieldIndex, values, wrapped);  \/\/ adjusts smaller fields\n    }\n","new_comment_raw":"@param instant the partial instant","old_comment_raw":"@param instant the partial instant","label":0,"pre_label":1,"AST_level":7,"line_counts":7,"new_code_token_num":66},{"new_code_raw":"public Call buildCall(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException { Request request = buildRequest(path, method, queryParams, collectionQueryParams, body, headerParams, formParams, authNames, callback); return httpClient.newCall(request); }","old_code_raw":"    public Call buildCall(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {\n        Request request = buildRequest(path, method, queryParams, collectionQueryParams, body, headerParams, formParams, authNames, progressRequestListener);\n\n        return httpClient.newCall(request);\n    }\n","new_comment_raw":"@param queryParams The query parameters","old_comment_raw":"@param queryParams The query parameters","label":0,"pre_label":1,"AST_level":6,"line_counts":6,"new_code_token_num":75},{"new_code_raw":"public Client testClientModel(Client client) throws RestClientException { Object postBody = client; \/\/ verify the required parameter 'client' is set if (client == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'client' when calling testClientModel\"); } String path = UriComponentsBuilder.fromPath(\"\/fake\").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { \"application\/json\" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { \"application\/json\" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {}; return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }","old_code_raw":"    public Client testClientModel(Client body) throws RestClientException {\n        Object postBody = body;\n        \n        \/\/ verify the required parameter 'body' is set\n        if (body == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'body' when calling testClientModel\");\n        }\n        \n        String path = UriComponentsBuilder.fromPath(\"\/fake\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application\/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"application\/json\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {};\n        return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n","new_comment_raw":"@param client client model","old_comment_raw":"@param body client model","label":1,"pre_label":0,"AST_level":8,"line_counts":29,"new_code_token_num":200},{"new_code_raw":"public static String normalizeDateString(String s, Date ctxdate) { \/\/ TODO [pengqi]: need to handle basic localization (\"\u00e5\u009c\u00a8\u00e4\u00b8\u0083\u00e6\u009c\u0088\u00e4\u00ba\u008c\u00e6\u0097\u00a5\u00e5\u0088\u00b0[\u00e5 \u00ab\u00e6\u0097\u00a5]\u00e9\u0097\u00b4\") \/\/ TODO [pengqi]: need to handle literal numeral dates (usually used in events, e.g. \"\u00e4\u00b8\u0089\u00e4\u00b8\u0080\u00e4\u00ba\u0094\" for 03-15) \/\/ TODO [pengqi]: might need to add a pattern for centuries (\"\u00e4\u00b8\u008a\u00e4\u00b8\u0096\u00e7\u00ba\u00aa90\u00e5\u00b9\u00b4\u00e4\u00bb\u00a3\")? String ctxyear = new SimpleDateFormat(\"yyyy\").format(ctxdate); String ctxmonth = new SimpleDateFormat(\"MM\").format(ctxdate); String ctxday = new SimpleDateFormat(\"dd\").format(ctxdate); Pattern p = Pattern.compile(\"^\" + BASIC_YYYYMMDD_PATTERN + \"$\"); Matcher m = p.matcher(s); if (m.find() && m.groupCount() == 3) { StringBuilder res = new StringBuilder(); res.append(normalizeYear(m.group(1), ctxyear)); res.append(\"-\"); res.append(normalizeMonthOrDay(m.group(2), ctxmonth)); res.append(\"-\"); res.append(normalizeMonthOrDay(m.group(3), ctxday)); return res.toString(); } p = Pattern.compile(\"^\" + BASIC_MMDD_PATTERN + \"$\"); m = p.matcher(s); if (m.find() && m.groupCount() == 2) { StringBuilder res = new StringBuilder(); res.append(ctxyear); res.append(\"-\"); res.append(normalizeMonthOrDay(m.group(1), ctxmonth)); res.append(\"-\"); res.append(normalizeMonthOrDay(m.group(2), ctxday)); return res.toString(); } p = Pattern.compile(\"^\" + BASIC_DD_PATTERN + \"$\"); m = p.matcher(s); if (m.find() && m.groupCount() == 1) { StringBuilder res = new StringBuilder(); res.append(ctxyear); res.append(\"-\"); res.append(ctxmonth); res.append(\"-\"); res.append(normalizeMonthOrDay(m.group(1), ctxday)); return res.toString(); } p = Pattern.compile(\"^\" + ENGLISH_MMDDYYYY_PATTERN + \"$\"); m = p.matcher(s); if (m.find() && m.groupCount() == 3) { StringBuilder res = new StringBuilder(); if (m.group(3) == null) res.append(ctxyear); else res.append(normalizeYear(m.group(3), ctxyear)); res.append(\"-\"); res.append(normalizeMonthOrDay(m.group(1), ctxmonth)); res.append(\"-\"); res.append(normalizeMonthOrDay(m.group(2), ctxday)); return res.toString(); } return s; }","old_code_raw":"  public static String normalizeDateString(String s, Date docdate) {\n    \/\/ TODO [pengqi]: still need to handle relative dates (\"\u00e5\u008e\u00bb\u00e5\u00b9\u00b4\") and temporal references (\"\u00e5\u00bd\u0093\u00e6\u0097\u00b6\")\n    \/\/ TODO [pengqi]: need to handle irregular years (\"81\u00e5\u00b9\u00b4\")\n    \/\/ TODO [pengqi]: need to handle basic localization (\"\u00e5\u009c\u00a8\u00e4\u00b8\u0083\u00e6\u009c\u0088\u00e4\u00ba\u008c\u00e6\u0097\u00a5\u00e5\u0088\u00b0[\u00e5\u0085\u00ab\u00e6\u0097\u00a5]\u00e9\u0097\u00b4\")\n    Pattern p = Pattern.compile(BASIC_YYYYMMDD_PATTERN);\n    Matcher m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 3) {\n      StringBuilder res = new StringBuilder();\n      String year = m.group(1);\n      for (int i = 0; i < year.length(); i++) {\n        String t = \"\" + year.charAt(i);\n        if (CHINESE_LITERAL_DECIMAL_PATTERN.matcher(t).matches()) {\n          if (wordsToValues.containsKey(t))\n            res.append((int)wordsToValues.getCount(t));\n          else\n            \/\/ something unexpected happened\n            return null;\n        } else\n          res.append(t);\n      }\n\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(2)));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(3)));\n\n      return res.toString();\n    }\n\n    p = Pattern.compile(BASIC_MMDD_PATTERN);\n    m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 2) {\n      StringBuilder res = new StringBuilder();\n      String year = new SimpleDateFormat(\"yyyy\").format(docdate);\n\n      res.append(year);\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(1)));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(2)));\n\n      return res.toString();\n    }\n\n    p = Pattern.compile(BASIC_DD_PATTERN);\n    m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 1) {\n      StringBuilder res = new StringBuilder();\n      String year = new SimpleDateFormat(\"yyyy\").format(docdate);\n      String month = new SimpleDateFormat(\"MM\").format(docdate);\n\n      res.append(year);\n      res.append(\"-\");\n      res.append(month);\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(1)));\n\n      return res.toString();\n    }\n\n    p = Pattern.compile(ENGLISH_MMDDYYYY_PATTERN);\n    m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 3) {\n      StringBuilder res = new StringBuilder();\n\n      String year = new SimpleDateFormat(\"yyyy\").format(docdate);\n\n      if (m.group(3) == null)\n        res.append(year);\n      else\n        res.append(m.group(3));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(1)));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(2)));\n\n      return res.toString();\n    }\n\n    return s;\n  }\n","new_comment_raw":"@param ctxdate Context date (usually doc_date)","old_comment_raw":"@param docdate The document date","label":1,"pre_label":0,"AST_level":10,"line_counts":74,"new_code_token_num":579},{"new_code_raw":"public String getTypeName(int code, long length, int precision, int scale) throws HibernateException { String result = typeNames.get( code, length, precision, scale ); if ( result == null ) { throw new HibernateException( \"No type mapping for java.sql.Types code: \" + code + \", length: \" + length ); } return result; }","old_code_raw":"\tpublic String getTypeName(int code, int length, int precision, int scale) throws HibernateException {\n\t\tString result = typeNames.get( code, length, precision, scale );\n\t\tif ( result == null ) {\n\t\t\tthrow new HibernateException(\n\t\t\t\t\t\"No type mapping for java.sql.Types code: \" +\n\t\t\t\t\tcode +\n\t\t\t\t\t\", length: \" +\n\t\t\t\t\tlength\n\t\t\t);\n\t\t}\n\t\treturn result;\n\t}\n","new_comment_raw":"@param code The  java.sql.Types typecode","old_comment_raw":"@param code The java.sql.Types typecode","label":0,"pre_label":1,"AST_level":10,"line_counts":13,"new_code_token_num":71},{"new_code_raw":"public static long readVLong(DrillBuf buffer, int start, int end) { buffer.readerIndex(start); byte firstByte = buffer.readByte(); int len = decodeVIntSize(firstByte); int availableBytes = (end-start); if (len == 1) { return firstByte; } else if (availableBytes < len) { throw new NumberFormatException(\"Expected \" + len + \" bytes but the buffer '\" + DrillStringUtils.toBinaryString(buffer, start, end) + \"' has \" + availableBytes + \" bytes.\"); } long longValue = 0; for (int idx = 0; idx < len-1; idx++) { byte byteValue = buffer.readByte(); longValue = longValue << 8; longValue = longValue | (byteValue & 0xFF); } return (isNegativeVInt(firstByte) ? (longValue ^ -1L) : longValue); }","old_code_raw":"    public static long readVLong(ByteBuf buffer, int start, int end) {\n      buffer.readerIndex(start);\n      byte firstByte = buffer.readByte();\n      int len = decodeVIntSize(firstByte);\n      int availableBytes = (end-start);\n      if (len == 1) {\n        return firstByte;\n      } else if (availableBytes < len) {\n        throw new NumberFormatException(\"Expected \" + len + \" bytes but the buffer '\"\n            + DrillStringUtils.toBinaryString(buffer, start, end) + \"' has  \"\n            + availableBytes + \" bytes.\");\n      }\n\n      long longValue = 0;\n      for (int idx = 0; idx < len-1; idx++) {\n        byte byteValue = buffer.readByte();\n        longValue = longValue << 8;\n        longValue = longValue | (byteValue & 0xFF);\n      }\n      return (isNegativeVInt(firstByte) ? (longValue ^ -1L) : longValue);\n    }\n","new_comment_raw":"@param buffer DrillBuf to read from","old_comment_raw":"@param buffer ByteBuf to read from","label":1,"pre_label":0,"AST_level":14,"line_counts":22,"new_code_token_num":160},{"new_code_raw":"public Call testEndpointParametersAsync(BigDecimal number, Double _double, String string, byte[] _byte, Integer integer, Integer int32, Long int64, Float _float, byte[] binary, Date date, Date dateTime, String password, final ApiCallback<Void> callback) throws ApiException { ProgressResponseBody.ProgressListener progressListener = null; ProgressRequestBody.ProgressRequestListener progressRequestListener = null; if (callback != null) { progressListener = new ProgressResponseBody.ProgressListener() { @Override public void update(long bytesRead, long contentLength, boolean done) { callback.onDownloadProgress(bytesRead, contentLength, done); } }; progressRequestListener = new ProgressRequestBody.ProgressRequestListener() { @Override public void onRequestProgress(long bytesWritten, long contentLength, boolean done) { callback.onUploadProgress(bytesWritten, contentLength, done); } }; } Call call = testEndpointParametersCall(number, _double, string, _byte, integer, int32, int64, _float, binary, date, dateTime, password, progressListener, progressRequestListener); apiClient.executeAsync(call, callback); return call; }","old_code_raw":"  public Call testEndpointParametersAsync(String number, Double _double, String string, byte[] _byte, Integer integer, Integer int32, Long int64, Float _float, byte[] binary, Date date, Date dateTime, String password, final ApiCallback<Void> callback) throws ApiException {\n\n    ProgressResponseBody.ProgressListener progressListener = null;\n    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n    if (callback != null) {\n      progressListener = new ProgressResponseBody.ProgressListener() {\n        @Override\n        public void update(long bytesRead, long contentLength, boolean done) {\n          callback.onDownloadProgress(bytesRead, contentLength, done);\n        }\n      };\n\n      progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {\n        @Override\n        public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {\n          callback.onUploadProgress(bytesWritten, contentLength, done);\n        }\n      };\n    }\n\n    Call call = testEndpointParametersCall(number, _double, string, _byte, integer, int32, int64, _float, binary, date, dateTime, password, progressListener, progressRequestListener);\n    apiClient.executeAsync(call, callback);\n    return call;\n  }\n","new_comment_raw":"@param password None (optional)","old_comment_raw":"@param password None (optional)","label":0,"pre_label":1,"AST_level":11,"line_counts":26,"new_code_token_num":187},{"new_code_raw":"public <T> int querySimpleList(Class<T> c, String sqlCmd, Connection conn, Collection<T> result) { \/\/ Check status if (checkOpen()==false) return -1; \/\/ Start query ResultSet rs = null; try { \/\/ Log performance long start = System.currentTimeMillis(); if (log.isInfoEnabled()) log.info(\"executing: \" + sqlCmd); \/\/ Get the next Value rs = driver.executeQuery(sqlCmd, null, false, conn); if (rs == null) { \/\/ Error error(driver); return -1; } \/\/ Check Result int count=0; while (rs.next()) { T item = ObjectUtils.convert(c, rs.getObject(1)); result.add(item); count++; } \/\/ No Value if (log.isInfoEnabled()) log.info(\"querySimpleList retured \"+String.valueOf(count)+\" items. Query completed in \" + String.valueOf(System.currentTimeMillis() - start) + \" ms\"); clearError(); return count; } catch (ClassCastException e) { log.error(\"querySingleValue cast exception: \", e); error(Errors.Exception, e); return -1; } catch (SQLException e) { log.error(\"querySimpleList exception: \", e); error(DBErrors.QueryFailed, e); return -1; } finally { \/\/ Cleanup closeResultSet(rs); } }","old_code_raw":"    public <T> List<T> querySimpleList(Class<T> c, String sqlCmd, Connection conn)\n    {   \/\/ Execute the  Statement\n        if (checkOpen()==false)\n            return null;\n        \/\/ Debug\n        ResultSet rs = null;\n        try\n        {\t\/\/ Check Open\n            if (checkOpen()==false)\n                return null;\n            \/\/ Debug\n            long start = System.currentTimeMillis();\n            if (log.isInfoEnabled())\n                log.info(\"executing: \" + sqlCmd);\n            \/\/ Get the next Value\n            rs = driver.executeQuery(sqlCmd, null, false, conn);\n            if (rs == null)\n            { \/\/ Error\n                error(driver);\n                return null;\n            }\n            \/\/ Check Result\n            List<T> result = new ArrayList<T>();\n            while (rs.next())\n            {\n                T item = ObjectUtils.convert(c, rs.getObject(1));\n                result.add(item);\n            }\n            \/\/ No Value\n            if (log.isInfoEnabled())\n                log.info(\"querySimpleList retured \"+String.valueOf(result.size())+\" items. Query completed in \" + String.valueOf(System.currentTimeMillis() - start) + \" ms\");\n            clearError();\n            return result;\n        } catch (ClassCastException e) \n        {   \n            log.error(\"querySingleValue cast exception: \", e);\n            error(Errors.Exception, e);\n            return null;\n        } catch (SQLException e) \n        {\n            log.error(\"querySimpleList exception: \", e);\n            error(DBErrors.QueryFailed, e);\n            return null;\n        } finally\n        { \/\/ Cleanup\n            closeResultSet(rs);\n        }\n    }\n","new_comment_raw":"@param  the type for the list","old_comment_raw":"@param the type for th list","label":1,"pre_label":0,"AST_level":12,"line_counts":48,"new_code_token_num":284},{"new_code_raw":"public FilterRegistration.Dynamic addFilter(String name, Filter filter) { final FilterHolder holder = new FilterHolder(checkNotNull(filter)); holder.setName(name); handler.getServletHandler().addFilter(holder); return holder.getRegistration(); }","old_code_raw":"    public FilterBuilder addFilter(Filter filter,\n                                   String urlPattern) {\n        final FilterHolder holder = new FilterHolder(checkNotNull(filter));\n        final FilterBuilder builder = new FilterBuilder(holder, handler);\n        builder.addUrlPattern(checkNotNull(urlPattern));\n        return builder;\n    }\n","new_comment_raw":"@param filter the filter instance","old_comment_raw":"@param urlPattern the URL pattern for requests that should be handled by filter","label":1,"pre_label":0,"AST_level":7,"line_counts":8,"new_code_token_num":46},{"new_code_raw":"public static RequestQueue newRequestQueue(int threadPoolSize) { RequestQueue requestQueue = new RequestQueue(HttpRestConnection.getInstance(getContext()), threadPoolSize); requestQueue.start(); return requestQueue; }","old_code_raw":"\tpublic static RequestQueue newRequestQueue(Context context, int threadPoolSize) {\n\t\tRequestQueue requestQueue = new RequestQueue(HttpRestConnection.getInstance(context), threadPoolSize);\n\t\trequestQueue.start();\n\t\treturn requestQueue;\n\t}\n","new_comment_raw":"@param context ApplicationContext","old_comment_raw":"@param context ApplicationContext","label":0,"pre_label":1,"AST_level":7,"line_counts":6,"new_code_token_num":34},{"new_code_raw":"public int[] set(ReadablePartial instant, int fieldIndex, int[] values, String text, Locale locale) { int value = convertText(text, locale); return set(instant, fieldIndex, values, value); }","old_code_raw":"    public int[] set(PartialInstant instant, int fieldIndex, int[] values, String text, Locale locale) {\n        int value = convertText(text, locale);\n        return set(instant, fieldIndex, values, value);\n    }\n","new_comment_raw":"@param text the text value to set","old_comment_raw":"@param text the text value to set","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":46},{"new_code_raw":"public OuterComposite fakeOuterCompositeSerialize(OuterComposite outerComposite) throws IOException { HttpResponse response = fakeOuterCompositeSerializeForHttpResponse(outerComposite); TypeReference typeRef = new TypeReference<OuterComposite>() {}; return apiClient.getObjectMapper().readValue(response.getContent(), typeRef); }","old_code_raw":"    public OuterComposite fakeOuterCompositeSerialize(OuterComposite body) throws IOException {\n        HttpResponse response = fakeOuterCompositeSerializeForHttpResponse(body);\n        TypeReference typeRef = new TypeReference<OuterComposite>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    }\n","new_comment_raw":"@param outerComposite Input composite as post body","old_comment_raw":"@param body Input composite as post body","label":1,"pre_label":0,"AST_level":8,"line_counts":6,"new_code_token_num":43},{"new_code_raw":"public PMetadata getCache(PGraphics renderer) { return g.getCache(renderer); }","old_code_raw":"  public Object getCache(Object parent) {\n    return g.getCache(parent);\n  }\n","new_comment_raw":"@param renderer The PGraphics renderer associated to the image","old_comment_raw":"@param parent The PGraphics object (or any object, really) associated","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":16},{"new_code_raw":"protected ApiResponse findMethodResponse(ApiResponses responses) { String code = null; for (String responseCode : responses.keySet()) { if (responseCode.startsWith(\"2\") || responseCode.equals(\"default\")) { if (code == null || code.compareTo(responseCode) > 0) { code = responseCode; } } } if (code == null) { return null; } return responses.get(code); }","old_code_raw":"    protected Response findMethodResponse(Map<String, Response> responses) {\n\n        String code = null;\n        for (String responseCode : responses.keySet()) {\n            if (responseCode.startsWith(\"2\") || responseCode.equals(\"default\")) {\n                if (code == null || code.compareTo(responseCode) > 0) {\n                    code = responseCode;\n                }\n            }\n        }\n        if (code == null) {\n            return null;\n        }\n        return responses.get(code);\n    }\n","new_comment_raw":"@param responses OAS Operation's responses","old_comment_raw":"@param responses Swagger Operation's responses","label":1,"pre_label":0,"AST_level":11,"line_counts":15,"new_code_token_num":81},{"new_code_raw":"public boolean waitForText(String text, int expectedMinimumNumberOfMatches, long timeout) { return robotiumUtils.waitForText(text, expectedMinimumNumberOfMatches, timeout); }","old_code_raw":"\tpublic boolean waitForText(String text, int matches, long timeout)\n    {\n       return robotiumUtils.waitForText(text, matches, timeout);\n    }\n","new_comment_raw":"@param expectedMinimumNumberOfMatches the minimum number of matches of text that must be shown.  0 means any number of matches","old_comment_raw":"@param matches the number of matches of text that must be shown. 0 means any number of matches","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":26},{"new_code_raw":"private ImmutableBitSet factorBitmap(ImmutableBitSet fieldRefBitmap) { ImmutableBitSet.Builder factorRefBitmap = ImmutableBitSet.builder(); for (int field : fieldRefBitmap) { int factor = findRef(field); factorRefBitmap.set(factor); } return factorRefBitmap.build(); }","old_code_raw":"  private BitSet factorBitmap(BitSet fieldRefBitmap) {\n    BitSet factorRefBitmap = new BitSet(nJoinFactors);\n    for (int field : BitSets.toIter(fieldRefBitmap)) {\n      int factor = findRef(field);\n      factorRefBitmap.set(factor);\n    }\n    return factorRefBitmap;\n  }\n","new_comment_raw":"@param fieldRefBitmap bitmap representing fields referenced","old_comment_raw":"@param fieldRefBitmap bitmap representing fields referenced","label":0,"pre_label":1,"AST_level":8,"line_counts":9,"new_code_token_num":45},{"new_code_raw":"public long addWrapped(long instant, int years) { if (years == 0) { return instant; } \/\/ Return newly calculated millis value int thisYear = iChronology.year().get(instant); int wrappedYear = Utils.getWrappedValue (thisYear, years, iChronology.getMinYear(), iChronology.getMaxYear()); return set(instant, wrappedYear); }","old_code_raw":"    public long addWrapped(long millis, int years) {\n        if (years == 0) {\n            return millis;\n        }\n        \/\/ Return newly calculated millis value\n        int thisYear = iChronology.year().get(millis);\n        int wrappedYear = getWrappedValue\n            (thisYear, years, iChronology.getMinYear(), iChronology.getMaxYear());\n        return set(millis, wrappedYear);\n    }\n","new_comment_raw":"@param instant the time instant in millis to update.","old_comment_raw":"@param millis the time instant in millis to update.","label":1,"pre_label":0,"AST_level":7,"line_counts":11,"new_code_token_num":68},{"new_code_raw":"public boolean addFilter(BroadcastFilter e) { logDuplicateFilter(e); if (filters.contains(e)) return false; if (e instanceof BroadcastFilterLifecycle) { ((BroadcastFilterLifecycle) e).init(); } if (e instanceof PerRequestBroadcastFilter) { perRequestFilters.add((PerRequestBroadcastFilter) e); } return filters.offer(e); }","old_code_raw":"    protected boolean addFilter(BroadcastFilter e, boolean init) {\n        logDuplicateFilter(e);\n        if (filters.contains(e)) return false;\n\n        if (e instanceof BroadcastFilterLifecycle) {\n            ((BroadcastFilterLifecycle) e).init(config);\n        }\n\n        if (init && ClusterBroadcastFilter.class.isAssignableFrom(e.getClass())) {\n            Broadcaster b = config.getBroadcasterFactory().lookup(name, false);\n            if (b != null) {\n                synchronized (e) {\n                    ClusterBroadcastFilter.class.cast(e).setBroadcaster(b);\n                }\n            }\n        }\n\n        if (e instanceof PerRequestBroadcastFilter) {\n            perRequestFilters.add((PerRequestBroadcastFilter) e);\n        }\n\n        return filters.offer(e);\n    }\n","new_comment_raw":"@param e  BroadcastFilter","old_comment_raw":"@param e BroadcastFilter","label":0,"pre_label":1,"AST_level":8,"line_counts":15,"new_code_token_num":67},{"new_code_raw":"public Response syncSendPacket(Command command, int timeout) throws JMSException { if (isClosed()) { throw new ConnectionClosedException(); } else { if (command.isMessage() && flowControlSleepTime > 0) { try { Thread.sleep(flowControlSleepTime); } catch (InterruptedException e) { } } try { Response response = this.transport.request(command,timeout); if (response.isException()) { ExceptionResponse er = (ExceptionResponse) response; if (er.getException() instanceof JMSException) throw (JMSException) er.getException(); else throw JMSExceptionSupport.create(er.getException()); } return response; } catch (IOException e) { throw JMSExceptionSupport.create(e); } } }","old_code_raw":"    public Response syncSendPacket(Command command) throws JMSException {\n        if (isClosed()) {\n            throw new ConnectionClosedException();\n        } else {\n\n            if (command.isMessage() && flowControlSleepTime > 0) {\n                try {\n                    Thread.sleep(flowControlSleepTime);\n                } catch (InterruptedException e) {\n                }\n            }\n\n            try {\n                Response response = this.transport.request(command);\n                if (response.isException()) {\n                    ExceptionResponse er = (ExceptionResponse) response;\n                    if (er.getException() instanceof JMSException)\n                        throw (JMSException) er.getException();\n                    else\n                        throw JMSExceptionSupport.create(er.getException());\n                }\n                return response;\n            } catch (IOException e) {\n                throw JMSExceptionSupport.create(e);\n            }\n        }\n    }\n","new_comment_raw":"@param command","old_comment_raw":"@param command","label":0,"pre_label":1,"AST_level":11,"line_counts":28,"new_code_token_num":136},{"new_code_raw":"public static RelNode swap(Join join, boolean swapOuterJoins) { final JoinRelType joinType = join.getJoinType(); if (!swapOuterJoins && joinType != JoinRelType.INNER) { return null; } final RexBuilder rexBuilder = join.getCluster().getRexBuilder(); final RelDataType leftRowType = join.getLeft().getRowType(); final RelDataType rightRowType = join.getRight().getRowType(); final VariableReplacer variableReplacer = new VariableReplacer(rexBuilder, leftRowType, rightRowType); final RexNode oldCondition = join.getCondition(); RexNode condition = variableReplacer.go(oldCondition); \/\/ NOTE jvs 14-Mar-2006: We preserve attribute semiJoinDone after the \/\/ swap. This way, we will generate one semijoin for the original \/\/ join, and one for the swapped join, and no more. This \/\/ doesn't prevent us from seeing any new combinations assuming \/\/ that the planner tries the desired order (semijoins after swaps). Join newJoin = join.copy(join.getTraitSet(), condition, join.getRight(), join.getLeft(), joinType.swap(), join.isSemiJoinDone()); final List<RexNode> exps = RelOptUtil.createSwappedJoinExprs(newJoin, join, true); return RelOptUtil.createProject( newJoin, exps, join.getRowType().getFieldNames(), true); }","old_code_raw":"  public static RelNode swap(JoinRelBase join, boolean swapOuterJoins) {\n    final JoinRelType joinType = join.getJoinType();\n    if (!swapOuterJoins && joinType != JoinRelType.INNER) {\n      return null;\n    }\n    final RexBuilder rexBuilder = join.getCluster().getRexBuilder();\n    final RelDataType leftRowType = join.getLeft().getRowType();\n    final RelDataType rightRowType = join.getRight().getRowType();\n    final VariableReplacer variableReplacer =\n        new VariableReplacer(rexBuilder, leftRowType, rightRowType);\n    final RexNode oldCondition = join.getCondition();\n    RexNode condition = variableReplacer.go(oldCondition);\n\n    \/\/ NOTE jvs 14-Mar-2006: We preserve attribute semiJoinDone after the\n    \/\/ swap.  This way, we will generate one semijoin for the original\n    \/\/ join, and one for the swapped join, and no more.  This\n    \/\/ doesn't prevent us from seeing any new combinations assuming\n    \/\/ that the planner tries the desired order (semijoins after swaps).\n    JoinRelBase newJoin =\n        join.copy(join.getTraitSet(), condition, join.getRight(),\n            join.getLeft(), joinType.swap(), join.isSemiJoinDone());\n    final List<RexNode> exps =\n        RelOptUtil.createSwappedJoinExprs(newJoin, join, true);\n    return RelOptUtil.createProject(\n        newJoin,\n        exps,\n        join.getRowType().getFieldNames(),\n        true);\n  }\n","new_comment_raw":"@param join join to be swapped","old_comment_raw":"@param join join to be swapped","label":0,"pre_label":1,"AST_level":6,"line_counts":30,"new_code_token_num":237},{"new_code_raw":"public Activity getCurrentActivity(boolean shouldSleepFirst) { if(shouldSleepFirst){ RobotiumUtils.sleep(); inst.waitForIdleSync(); } Boolean found = false; if (activityMonitor != null) { if (activityMonitor.getLastActivity() != null) activity = activityMonitor.getLastActivity(); } for(Activity storedActivity : activityList){ if (storedActivity.getClass().getName().equals( activity.getClass().getName())) found = true; } if (found) return activity; else { activityList.add(activity); return activity; } }","old_code_raw":"\tpublic Activity getCurrentActivity(int pause) {\n\t\tif(pause > 0){\n\t\t\tRobotiumUtils.sleep(pause);\n\t\t\tinst.waitForIdleSync();\n\t\t}\n\t\tBoolean found = false;\n\t\tif (activityMonitor != null) {\n\t\t\tif (activityMonitor.getLastActivity() != null)\n\t\t\t\tactivity = activityMonitor.getLastActivity();\n\t\t}\n\t\tfor(Activity storedActivity : activityList){\n\t\t\tif (storedActivity.getClass().getName().equals(\n\t\t\t\t\tactivity.getClass().getName()))\n\t\t\t\tfound = true;\n\t\t}\n\t\tif (found)\n\t\t\treturn activity;\n\t\telse {\n\t\t\tactivityList.add(activity);\n\t\t\treturn activity;\n\t\t}\n\t}\n","new_comment_raw":"@param shouldSleepFirst whether to sleep a default pause first","old_comment_raw":"@param pause the time to pause in milliseconds","label":1,"pre_label":0,"AST_level":9,"line_counts":23,"new_code_token_num":103},{"new_code_raw":"public Iterator keyIterator() { return new KeyIterator( map.keySet().iterator() ); }","old_code_raw":"\tpublic static Iterator keyIterator(Map map) {\n\t\treturn ( (IdentityMap) map ).keyIterator();\n\t}\n","new_comment_raw":"@param map The map of entries","old_comment_raw":"@param map The map of entries","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"static protected float getFloatWithUnit(PNode element, String attribute) { String val = element.getString(attribute); return (val == null) ? 0 : parseUnitSize(val); }","old_code_raw":"  static protected float getFloatWithUnit(XMLElement element, String attribute) {\n    String val = element.getString(attribute);\n    return (val == null) ? 0 : parseUnitSize(val);\n  }\n","new_comment_raw":"@param element what to parse","old_comment_raw":"@param element what to parse","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":34},{"new_code_raw":"public static Configuration from(Map<String, String> properties) { Map<String, String> props = new HashMap<>(); if (properties != null) props.putAll(properties); return new Configuration() { @Override public String getString(String key) { return properties.get(key); } @Override public Set<String> keys() { return properties.keySet(); } @Override public String toString() { return props.toString(); } }; }","old_code_raw":"    public static Configuration from(Properties properties) {\n        Properties props = new Properties();\n        if (properties != null) props.putAll(properties);\n        return new Configuration() {\n            @Override\n            public String getString(String key) {\n                return properties.getProperty(key);\n            }\n\n            @Override\n            public Set<String> keys() {\n                return properties.stringPropertyNames();\n            }\n            \n            @Override\n            public String toString() {\n                return props.toString();\n            }\n        };\n    }\n","new_comment_raw":"@param properties the properties; may be null or empty","old_comment_raw":"@param properties the properties; may be null or empty","label":0,"pre_label":1,"AST_level":8,"line_counts":21,"new_code_token_num":92},{"new_code_raw":"public boolean remove(final BaseDownloadTask willRemoveDownload, final int removeByStatus) { boolean succeed; synchronized (list) { succeed = list.remove(willRemoveDownload); } if (succeed) { \/\/ \u00e6\u008a\u009b\u00e6\u00b6\u0088\u00e6\u0081\u00af switch (removeByStatus) { case FileDownloadStatus.warn: willRemoveDownload.getDriver().notifyWarn(); break; case FileDownloadStatus.error: willRemoveDownload.getDriver().notifyError(); break; case FileDownloadStatus.paused: willRemoveDownload.getDriver().notifyPaused(); break; case FileDownloadStatus.completed: Throwable ex = null; try{ willRemoveDownload.getDriver().notifyBlockComplete(); }catch (Throwable e){ ex = e; } if (ex != null) { willRemoveDownload.setStatus(FileDownloadStatus.error); willRemoveDownload.setEx(ex); willRemoveDownload.getDriver().notifyError(); } else { willRemoveDownload.getDriver().notifyCompleted(); } break; } } else { FileDownloadLog.e(this, \"remove error, not exist: %s\", willRemoveDownload); } return succeed; }","old_code_raw":"    public boolean remove(final BaseFileDownloadInternal willRemoveDownload, final int removeByStatus) {\n        boolean succeed;\n        synchronized (list) {\n            succeed = list.remove(willRemoveDownload);\n        }\n\n        if (succeed) {\n            \/\/ \u00e6\u008a\u009b\u00e6\u00b6\u0088\u00e6\u0081\u00af\n            switch (removeByStatus) {\n                case FileDownloadStatus.warn:\n                    willRemoveDownload.getDriver().notifyWarn();\n                    break;\n                case FileDownloadStatus.error:\n                    willRemoveDownload.getDriver().notifyError();\n                    break;\n                case FileDownloadStatus.paused:\n                    willRemoveDownload.getDriver().notifyPaused();\n                    break;\n                case FileDownloadStatus.completed:\n                    Throwable ex = null;\n                    try{\n                        willRemoveDownload.getDriver().notifyBlockComplete();\n                    }catch (Throwable e){\n                        ex = e;\n                    }\n\n                    if (ex != null) {\n                        willRemoveDownload.setStatus(FileDownloadStatus.error);\n                        willRemoveDownload.setEx(ex);\n                        willRemoveDownload.getDriver().notifyError();\n                    } else {\n                        willRemoveDownload.getDriver().notifyCompleted();\n                    }\n                    break;\n            }\n\n        } else {\n            FileDownloadLog.e(this, \"remove error, not exist: %s\", willRemoveDownload);\n        }\n\n        return succeed;\n    }\n","new_comment_raw":"@param removeByStatus must remove by status  com.liulishuo.filedownloader.model.FileDownloadStatus#warn  com.liulishuo.filedownloader.model.FileDownloadStatus#paused  com.liulishuo.filedownloader.model.FileDownloadStatus#completed  com.liulishuo.filedownloader.model.FileDownloadStatus#error","old_comment_raw":"@param removeByStatus must remove by status com.liulishuo.filedownloader.model.FileDownloadStatus#warn com.liulishuo.filedownloader.model.FileDownloadStatus#paused com.liulishuo.filedownloader.model.FileDownloadStatus#completed com.liulishuo.filedownloader.model.FileDownloadStatus#error","label":0,"pre_label":1,"AST_level":11,"line_counts":43,"new_code_token_num":185},{"new_code_raw":"public int compareTo(ReadableDuration other) { long thisMillis = this.getMillis(); long otherMillis = other.getMillis(); \/\/ cannot do (thisMillis - otherMillis) as it can overflow if (thisMillis < otherMillis) { return -1; } if (thisMillis > otherMillis) { return 1; } return 0; }","old_code_raw":"    public int compareTo(Object obj) {\n        \/\/ Comparable contract means we cannot handle null or other types gracefully\n        ReadableDuration thisDuration = (ReadableDuration) this;\n        ReadableDuration otherDuration = (ReadableDuration) obj;\n        \n        long thisMillis = thisDuration.getMillis();\n        long otherMillis = otherDuration.getMillis();\n        \n        \/\/ cannot do (thisMillis - otherMillis) as it can overflow\n        if (thisMillis < otherMillis) {\n            return -1;\n        }\n        if (thisMillis > otherMillis) {\n            return 1;\n        }\n        return 0;\n    }\n","new_comment_raw":"@param other a duration to check against","old_comment_raw":"@param obj a duration to check against","label":1,"pre_label":0,"AST_level":6,"line_counts":14,"new_code_token_num":60},{"new_code_raw":"String evaluate(String url, String host) throws ScriptException { try { return (String) pacImpl.invokeFunction(\"FindProxyForURL\", url, host); } catch (NoSuchMethodException | ScriptAbuseException e) { throw new ScriptException(e); } }","old_code_raw":"    public String evaluate(String destURL, String destHost) throws ScriptException {\n        try {\n            return (String) pacImpl.invokeFunction(\"FindProxyForURL\", destURL, destHost);\n        } catch (NoSuchMethodException | ScriptAbuseException e) {\n            throw new ScriptException(e);\n        }\n    }\n","new_comment_raw":"@param host the host param of FindProxyForURL(url, host)","old_comment_raw":"@param destHost the host param of FindProxyForURL(url, host)","label":1,"pre_label":0,"AST_level":7,"line_counts":8,"new_code_token_num":48},{"new_code_raw":"private SQLResponse execute(String correctedSql, SQLRequest sqlRequest) throws Exception { Connection conn = null; Statement stat = null; ResultSet resultSet = null; Boolean isPushDown = false; List<List<String>> results = Lists.newArrayList(); List<SelectedColumnMeta> columnMetas = Lists.newArrayList(); try { conn = cacheService.getOLAPDataSource(sqlRequest.getProject()).getConnection(); \/\/ special case for prepare query. if (BackdoorToggles.getPrepareOnly()) { return getPrepareOnlySqlResponse(correctedSql, conn, isPushDown, results, columnMetas); } stat = conn.createStatement(); processStatementAttr(stat, sqlRequest); resultSet = stat.executeQuery(correctedSql); ResultSetMetaData metaData = resultSet.getMetaData(); int columnCount = metaData.getColumnCount(); \/\/ Fill in selected column meta for (int i = 1; i <= columnCount; ++i) { columnMetas.add(new SelectedColumnMeta(metaData.isAutoIncrement(i), metaData.isCaseSensitive(i), metaData.isSearchable(i), metaData.isCurrency(i), metaData.isNullable(i), metaData.isSigned(i), metaData.getColumnDisplaySize(i), metaData.getColumnLabel(i), metaData.getColumnName(i), metaData.getSchemaName(i), metaData.getCatalogName(i), metaData.getTableName(i), metaData.getPrecision(i), metaData.getScale(i), metaData.getColumnType(i), metaData.getColumnTypeName(i), metaData.isReadOnly(i), metaData.isWritable(i), metaData.isDefinitelyWritable(i))); } \/\/ fill in results while (resultSet.next()) { List<String> oneRow = Lists.newArrayListWithCapacity(columnCount); for (int i = 0; i < columnCount; i++) { oneRow.add((resultSet.getString(i + 1))); } results.add(oneRow); } } catch (SQLException sqlException) { isPushDown = PushDownUtil.doPushDownQuery(sqlRequest.getProject(), correctedSql, results, columnMetas, sqlException); } finally { close(resultSet, stat, conn); } return getSqlResponse(isPushDown, results, columnMetas); }","old_code_raw":"    private SQLResponse execute(String correctedSql, SQLRequest sqlRequest, Connection conn) throws Exception {\n        Statement stat = null;\n        ResultSet resultSet = null;\n        Boolean isPushDown = false;\n\n        List<List<String>> results = Lists.newArrayList();\n        List<SelectedColumnMeta> columnMetas = Lists.newArrayList();\n\n        try {\n\n            \/\/ special case for prepare query. \n            if (BackdoorToggles.getPrepareOnly()) {\n                return getPrepareOnlySqlResponse(correctedSql, conn, isPushDown, results, columnMetas);\n            }\n\n            stat = conn.createStatement();\n            processStatementAttr(stat, sqlRequest);\n            resultSet = stat.executeQuery(correctedSql);\n\n            ResultSetMetaData metaData = resultSet.getMetaData();\n            int columnCount = metaData.getColumnCount();\n\n            \/\/ Fill in selected column meta\n            for (int i = 1; i <= columnCount; ++i) {\n                columnMetas.add(new SelectedColumnMeta(metaData.isAutoIncrement(i), metaData.isCaseSensitive(i),\n                        metaData.isSearchable(i), metaData.isCurrency(i), metaData.isNullable(i), metaData.isSigned(i),\n                        metaData.getColumnDisplaySize(i), metaData.getColumnLabel(i), metaData.getColumnName(i),\n                        metaData.getSchemaName(i), metaData.getCatalogName(i), metaData.getTableName(i),\n                        metaData.getPrecision(i), metaData.getScale(i), metaData.getColumnType(i),\n                        metaData.getColumnTypeName(i), metaData.isReadOnly(i), metaData.isWritable(i),\n                        metaData.isDefinitelyWritable(i)));\n            }\n\n            \/\/ fill in results\n            while (resultSet.next()) {\n                List<String> oneRow = Lists.newArrayListWithCapacity(columnCount);\n                for (int i = 0; i < columnCount; i++) {\n                    oneRow.add((resultSet.getString(i + 1)));\n                }\n\n                results.add(oneRow);\n            }\n        } catch (SQLException sqlException) {\n            isPushDown = PushDownUtil.doPushDownQuery(sqlRequest.getProject(), correctedSql, conn.getSchema(), results,\n                    columnMetas, sqlException);\n            if (!isPushDown) {\n                throw sqlException;\n            }\n        } finally {\n            close(resultSet, stat, null);\/\/conn is passed in, not my duty to close\n        }\n\n        return getSqlResponse(isPushDown, results, columnMetas);\n    }\n","new_comment_raw":"@param correctedSql","old_comment_raw":"@param correctedSql","label":0,"pre_label":1,"AST_level":12,"line_counts":54,"new_code_token_num":376},{"new_code_raw":"public PersistentCollection locateLoadingCollection(CollectionPersister persister, CollectionKey key) { final LoadingCollectionEntry lce = locateLoadingCollectionEntry( key ) ; if ( lce != null ) { if ( LOG.isTraceEnabled() ) { LOG.tracef( \"Returning loading collection: %s\", MessageHelper.collectionInfoString( persister, key.getKey(), getSession().getFactory() ) ); } return lce.getCollection(); } return null; }","old_code_raw":"\tpublic PersistentCollection locateLoadingCollection(CollectionPersister persister, Serializable ownerKey) {\n\t\tfinal LoadingCollectionEntry lce = locateLoadingCollectionEntry( new CollectionKey( persister, ownerKey ) );\n\t\tif ( lce != null ) {\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracef(\n\t\t\t\t\t\t\"Returning loading collection: %s\",\n\t\t\t\t\t\tMessageHelper.collectionInfoString( persister, ownerKey, getSession().getFactory() )\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn lce.getCollection();\n\t\t}\n\t\treturn null;\n\t}\n","new_comment_raw":"@param key The collection key","old_comment_raw":"@param ownerKey The owner key","label":1,"pre_label":0,"AST_level":11,"line_counts":14,"new_code_token_num":77},{"new_code_raw":"private PeriodFormatterBuilder appendPrefix(PeriodFieldAffix prefix) { if (prefix == null) { throw new IllegalArgumentException(); } if (iPrefix != null) { prefix = new CompositeAffix(iPrefix, prefix); } iPrefix = prefix; return this; }","old_code_raw":"    private PeriodFormatterBuilder appendPrefix(DurationFieldAffix prefix) {\n        if (prefix == null) {\n            throw new IllegalArgumentException();\n        }\n        if (iPrefix != null) {\n            prefix = new CompositeAffix(iPrefix, prefix);\n        }\n        iPrefix = prefix;\n        return this;\n    }\n","new_comment_raw":"@param prefix custom prefix","old_comment_raw":"@param prefix custom prefix","label":0,"pre_label":1,"AST_level":8,"line_counts":11,"new_code_token_num":45},{"new_code_raw":"public BroadcastAction filter(Object originalMessage, Object o) { if (o instanceof String){ String message = (String)o; \/\/ Avoid re-broadcasting if (!receivedMessages.remove(message)) { try { jchannel.send(new Message(null, null, message)); } catch (ChannelException e) { logger.warn(\"failed to send message\", e); } } return new BroadcastAction(message); } else { return new BroadcastAction(o); } }","old_code_raw":"    public BroadcastAction filter(Object originalMessage, Object message) {\n        \/\/ Avoid re-broadcasting\n        if (!receivedMessages.remove(message)) {\n            try {\n                jchannel.send(new Message(null, null, new JGroupsBroadcaster.BroadcastMessage(bc.getID(), message)));\n            } catch (ChannelException e) {\n                logger.warn(\"failed to send message\", e);\n            }\n        }\n        return new BroadcastAction(message);\n    }\n","new_comment_raw":"@param o the message to broadcast.","old_comment_raw":"@param message the message to broadcast.","label":1,"pre_label":0,"AST_level":11,"line_counts":17,"new_code_token_num":98},{"new_code_raw":"public String invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); b.append(\"?\"); if (queryParams != null){ for (Pair queryParam : queryParams){ if (!queryParam.getName().isEmpty()) { b.append(escapeString(queryParam.getName())); b.append(\"=\"); b.append(escapeString(queryParam.getValue())); b.append(\"&\"); } } } String querystring = b.substring(0, b.length() - 1); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(\"GET\".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (\"POST\".equals(method)) { if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (\"PUT\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (\"DELETE\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, \"unknown method type \" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return \"\"; } } else { String message = \"error\"; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { \/\/ e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }","old_code_raw":"  public String invokeAPI(String path, String method, Set<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          \/\/ e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n","new_comment_raw":"@param accept The request's Accept header","old_comment_raw":"@param accept The request's Accept header","label":0,"pre_label":1,"AST_level":16,"line_counts":113,"new_code_token_num":736},{"new_code_raw":"public CloseableIterator<Tuple> iterate(Expression<?>... args) { return iterate(queryMixin.createProjection(args)); }","old_code_raw":"    public CloseableIterator<T> iterate() {\n        try {\n            Expression<T> projection = (Expression<T>)queryMixin.getMetadata().getProjection();\n            return new IteratorAdapter<T>(queryEngine.list(getMetadata(), iterables, projection).iterator());\n        } finally {\n            reset();\n        }\n    }\n","new_comment_raw":"@param alias","old_comment_raw":"@param alias alias for the joint target","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":21},{"new_code_raw":"public static boolean isTransient(String entityName, Object entity, Boolean assumed, SharedSessionContractImplementor session) { if ( entity == LazyPropertyInitializer.UNFETCHED_PROPERTY ) { \/\/ an unfetched association can only point to \/\/ an entity that already exists in the db return false; } \/\/ let the interceptor inspect the instance to decide Boolean isUnsaved = session.getInterceptor().isTransient( entity ); if ( isUnsaved != null ) { return isUnsaved; } \/\/ let the persister inspect the instance to decide final EntityPersister persister = session.getEntityPersister( entityName, entity ); isUnsaved = persister.isTransient( entity, session ); if ( isUnsaved != null ) { return isUnsaved; } \/\/ we use the assumed value, if there is one, to avoid hitting \/\/ the database if ( assumed != null ) { return assumed; } \/\/ hit the database, afterQuery checking the session cache for a snapshot final Object[] snapshot = session.getPersistenceContext().getDatabaseSnapshot( persister.getIdentifier( entity, session ), persister ); return snapshot == null; }","old_code_raw":"\tpublic static boolean isTransient(String entityName, Object entity, Boolean assumed, SessionImplementor session) {\n\t\tif ( entity == LazyPropertyInitializer.UNFETCHED_PROPERTY ) {\n\t\t\t\/\/ an unfetched association can only point to\n\t\t\t\/\/ an entity that already exists in the db\n\t\t\treturn false;\n\t\t}\n\n\t\t\/\/ let the interceptor inspect the instance to decide\n\t\tBoolean isUnsaved = session.getInterceptor().isTransient( entity );\n\t\tif ( isUnsaved != null ) {\n\t\t\treturn isUnsaved;\n\t\t}\n\n\t\t\/\/ let the persister inspect the instance to decide\n\t\tfinal EntityPersister persister = session.getEntityPersister( entityName, entity );\n\t\tisUnsaved = persister.isTransient( entity, session );\n\t\tif ( isUnsaved != null ) {\n\t\t\treturn isUnsaved;\n\t\t}\n\n\t\t\/\/ we use the assumed value, if there is one, to avoid hitting\n\t\t\/\/ the database\n\t\tif ( assumed != null ) {\n\t\t\treturn assumed;\n\t\t}\n\n\t\t\/\/ hit the database, after checking the session cache for a snapshot\n\t\tfinal Object[] snapshot = session.getPersistenceContext().getDatabaseSnapshot(\n\t\t\t\tpersister.getIdentifier( entity, session ),\n\t\t\t\tpersister\n\t\t);\n\t\treturn snapshot == null;\n\n\t}\n","new_comment_raw":"@param entity The entity instance","old_comment_raw":"@param entity The entity instance","label":0,"pre_label":1,"AST_level":8,"line_counts":35,"new_code_token_num":193},{"new_code_raw":"public boolean isNormalized(Litmus litmus, RexBuilder rexBuilder) { final RexProgram normalizedProgram = normalize(rexBuilder, false); String normalized = normalizedProgram.toString(); String string = toString(); if (!normalized.equals(string)) { return litmus.fail(\"Program is not normalized:\\n\" + \"program: \" + string + \"\\n\" + \"normalized: \" + normalized + \"\\n\"); } return litmus.succeed(); }","old_code_raw":"  public boolean isNormalized(boolean fail, RexBuilder rexBuilder) {\n    final RexProgram normalizedProgram =\n        RexProgramBuilder.normalize(rexBuilder, this);\n    String normalized = normalizedProgram.toString();\n    String string = toString();\n    if (!normalized.equals(string)) {\n      assert !fail\n          : \"Program is not normalized:\\n\"\n          + \"program:    \" + string + \"\\n\"\n          + \"normalized: \" + normalized + \"\\n\";\n      return false;\n    }\n    return true;\n  }\n","new_comment_raw":"@param litmus What to do if an error is detected (program is not in canonical form)","old_comment_raw":"@param fail Whether to throw an assertion error if not in canonical form","label":1,"pre_label":0,"AST_level":13,"line_counts":12,"new_code_token_num":91},{"new_code_raw":"private RexNode convertUsing(SqlValidatorNamespace leftNamespace, SqlValidatorNamespace rightNamespace, List<String> nameList) { final List<RexNode> list = Lists.newArrayList(); for (String name : nameList) { List<RexNode> operands = new ArrayList<>(); int offset = 0; for (SqlValidatorNamespace n : ImmutableList.of(leftNamespace, rightNamespace)) { final RelDataType rowType = n.getRowType(); final RelDataTypeField field = catalogReader.field(rowType, name); operands.add(rexBuilder.makeInputRef(field.getType(), offset + field.getIndex())); offset += rowType.getFieldList().size(); } list.add(rexBuilder.makeCall(SqlStdOperatorTable.EQUALS, operands)); } return RexUtil.composeConjunction(rexBuilder, list, false); }","old_code_raw":"    private RexNode convertUsing(RelNode leftRel, RelNode rightRel, List<String> nameList) {\n        final List<RexNode> list = Lists.newArrayList();\n        for (String name : nameList) {\n            final RelDataType leftRowType = leftRel.getRowType();\n            RelDataTypeField leftField = catalogReader.field(leftRowType, name);\n            RexNode left = rexBuilder.makeInputRef(leftField.getType(), leftField.getIndex());\n            final RelDataType rightRowType = rightRel.getRowType();\n            RelDataTypeField rightField = catalogReader.field(rightRowType, name);\n            RexNode right = rexBuilder.makeInputRef(rightField.getType(), leftRowType.getFieldList().size() + rightField.getIndex());\n            RexNode equalsCall = rexBuilder.makeCall(SqlStdOperatorTable.EQUALS, left, right);\n            list.add(equalsCall);\n        }\n        return RexUtil.composeConjunction(rexBuilder, list, false);\n    }\n","new_comment_raw":"@param rightNamespace Namespace of right input to join","old_comment_raw":"@param rightRel Right input to the join","label":1,"pre_label":0,"AST_level":11,"line_counts":16,"new_code_token_num":134},{"new_code_raw":"private boolean scroll(Direction direction) { int yStart; int yEnd; if (direction == Direction.DOWN) { yStart = (activityUtils.getCurrentActivity().getWindowManager() .getDefaultDisplay().getHeight() - 20); yEnd = ((activityUtils.getCurrentActivity().getWindowManager() .getDefaultDisplay().getHeight() \/ 2)); } else { yStart = ((activityUtils.getCurrentActivity().getWindowManager() .getDefaultDisplay().getHeight() \/ 2)); yEnd = (activityUtils.getCurrentActivity().getWindowManager() .getDefaultDisplay().getHeight() - 20); } int x = activityUtils.getCurrentActivity().getWindowManager() .getDefaultDisplay().getWidth() \/ 2; if (viewFetcher.getCurrentListViews().size() > 0) { return scrollList(0, direction); } else if (viewFetcher.getCurrentScrollViews().size() > 0) { ScrollView scroll = viewFetcher.getCurrentScrollViews().get(0); scrollAmount = scroll.getScrollY(); drag(x, x, yStart, yEnd, 20); if (scrollAmount == scroll.getScrollY()) { scrollAmount = 0; return false; } else return true; } else return false; }","old_code_raw":"\tprivate boolean scroll(int direction) {\n\t\tint yStart;\n\t\tint yEnd;\n\t\tif (direction == DOWN) {\n\t\t\tyStart = (activityUtils.getCurrentActivity().getWindowManager()\n\t\t\t\t\t.getDefaultDisplay().getHeight() - 20);\n\t\t\tyEnd = ((activityUtils.getCurrentActivity().getWindowManager()\n\t\t\t\t\t.getDefaultDisplay().getHeight() \/ 2));\n\t\t} \n\t\telse {\n\t\t\tyStart = ((activityUtils.getCurrentActivity().getWindowManager()\n\t\t\t\t\t.getDefaultDisplay().getHeight() \/ 2));\n\t\t\tyEnd = (activityUtils.getCurrentActivity().getWindowManager()\n\t\t\t\t\t.getDefaultDisplay().getHeight() - 20);\n\t\t}\n\t\tint x = activityUtils.getCurrentActivity().getWindowManager()\n\t\t\t\t.getDefaultDisplay().getWidth() \/ 2;\n\n\t\tif (viewFetcher.getCurrentListViews().size() > 0) {\n\t\t\treturn scrollList(0, direction);\n\t\t} \n\t\telse if (viewFetcher.getCurrentScrollViews().size() > 0) {\n\t\t\tScrollView scroll = viewFetcher.getCurrentScrollViews().get(0);\n\t\t\tscrollAmount = scroll.getScrollY();\n\t\t\tdrag(x, x, yStart, yEnd, 20);\n\t\t\tif (scrollAmount == scroll.getScrollY()) {\n\t\t\t\tscrollAmount = 0;\n\t\t\t\treturn false;\n\t\t\t} \n\t\t\telse\n\t\t\t\treturn true;\n\t\t} \n\t\telse\n\t\t\treturn false;\n\n\t}\n","new_comment_raw":"@param direction the direction in which to scroll","old_comment_raw":"@param direction the direction in which to scroll","label":0,"pre_label":1,"AST_level":10,"line_counts":37,"new_code_token_num":213},{"new_code_raw":"public static RemoteProxy getNewBasicRemoteProxy(String browser, String url, Registry registry) { RegistrationRequest req = RegistrationRequest.build(\"-role\", \"webdriver\"); req.getCapabilities().clear(); DesiredCapabilities capability = new DesiredCapabilities(); capability.setBrowserName(browser); req.addDesiredCapabilitiy(capability); Map<String, Object> config = new HashMap<String, Object>(); config.put(\"url\", url); req.setConfiguration(config); return new RemoteProxy(req, registry); }","old_code_raw":"  public static RemoteProxy getNewBasicRemoteProxy(Map<String, Object> cap, String url, Registry registry) {\n    RegistrationRequest req = RegistrationRequest.build(\"-role\", \"webdriver\");\n    req.getCapabilities().clear();\n    req.addDesiredCapabilitiy(cap);\n    req.getConfiguration().put(RegistrationRequest.REMOTE_URL, url);\n    return new RemoteProxy(req, registry);\n\n  }\n","new_comment_raw":"@param appName","old_comment_raw":"@param cap","label":1,"pre_label":0,"AST_level":8,"line_counts":16,"new_code_token_num":96},{"new_code_raw":"public Client testClassname(Client client) throws ApiException { ApiResponse<Client> resp = testClassnameWithHttpInfo(client); return resp.getData(); }","old_code_raw":"    public Client testClassname(Client body) throws ApiException {\n        ApiResponse<Client> resp = testClassnameWithHttpInfo(body);\n        return resp.getData();\n    }\n","new_comment_raw":"@param client client model (required)","old_comment_raw":"@param body client model (required)","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":25},{"new_code_raw":"public String getName(long instant, Locale locale) { if (locale == null) { locale = Locale.getDefault(); } String nameKey = getNameKey(instant); if (nameKey == null) { return iID; } String name = cNameProvider.getName(locale, iID, nameKey); if (name != null) { return name; } return offsetFormatter().print(instant, this); }","old_code_raw":"    public String getName(long millis, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(millis);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return offsetFormatter().print(millis, this);\n    }\n","new_comment_raw":"@param instant milliseconds from 1970-01-01T00:00:00Z to get the name for","old_comment_raw":"@param millis milliseconds from 1970-01-01T00:00:00Z to get the name for","label":1,"pre_label":0,"AST_level":7,"line_counts":15,"new_code_token_num":76},{"new_code_raw":"private static RestClient connect(List<HttpHost> hosts, String pathPrefix) { Objects.requireNonNull(hosts, \"hosts or coordinates\"); Preconditions.checkArgument(!hosts.isEmpty(), \"no ES hosts specified\"); RestClientBuilder builder = RestClient.builder(hosts.toArray(new HttpHost[hosts.size()])); if (pathPrefix != null && !pathPrefix.isEmpty()) { builder.setPathPrefix(pathPrefix); } return builder.build(); }","old_code_raw":"  private static RestClient connect(List<HttpHost> hosts) {\n\n    Objects.requireNonNull(hosts, \"hosts or coordinates\");\n    Preconditions.checkArgument(!hosts.isEmpty(), \"no ES hosts specified\");\n\n    return RestClient.builder(hosts.toArray(new HttpHost[hosts.size()])).build();\n  }\n","new_comment_raw":"@param hosts list of ES HTTP Hosts to connect to","old_comment_raw":"@param hosts list of ES HTTP Hosts to connect to","label":0,"pre_label":1,"AST_level":8,"line_counts":12,"new_code_token_num":89},{"new_code_raw":"public void updatePet (Pet pet) throws TimeoutException, ExecutionException, InterruptedException, ApiException { Object postBody = pet; \/\/ verify the required parameter 'pet' is set if (pet == null) { VolleyError error = new VolleyError(\"Missing the required parameter 'pet' when calling updatePet\", new ApiException(400, \"Missing the required parameter 'pet' when calling updatePet\")); } \/\/ create path and map variables String path = \"\/pet\"; \/\/ query params List<Pair> queryParams = new ArrayList<Pair>(); \/\/ header params Map<String, String> headerParams = new HashMap<String, String>(); \/\/ form params Map<String, String> formParams = new HashMap<String, String>(); String[] contentTypes = { }; String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\"; if (contentType.startsWith(\"multipart\/form-data\")) { \/\/ file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); HttpEntity httpEntity = localVarBuilder.build(); postBody = httpEntity; } else { \/\/ normal form params } String[] authNames = new String[] { \"petstore_auth\" }; try { String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"PUT\", queryParams, postBody, headerParams, formParams, contentType, authNames); if (localVarResponse != null) { return ; } else { return ; } } catch (ApiException ex) { throw ex; } catch (InterruptedException ex) { throw ex; } catch (ExecutionException ex) { if (ex.getCause() instanceof VolleyError) { VolleyError volleyError = (VolleyError)ex.getCause(); if (volleyError.networkResponse != null) { throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage()); } } throw ex; } catch (TimeoutException ex) { throw ex; } }","old_code_raw":"  public void updatePet (Pet body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {\n    Object postBody = body;\n    \/\/ verify the required parameter 'body' is set\n    if (body == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'body' when calling updatePet\",\n        new ApiException(400, \"Missing the required parameter 'body' when calling updatePet\"));\n    }\n\n    \/\/ create path and map variables\n    String path = \"\/pet\";\n\n    \/\/ query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    \/\/ header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    \/\/ form params\n    Map<String, String> formParams = new HashMap<String, String>();\n    String[] contentTypes = {\n      \"application\/json\",\n      \"application\/xml\"\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\";\n\n    if (contentType.startsWith(\"multipart\/form-data\")) {\n      \/\/ file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      HttpEntity httpEntity = localVarBuilder.build();\n      postBody = httpEntity;\n    } else {\n      \/\/ normal form params\n    }\n\n    String[] authNames = new String[] { \"petstore_auth\" };\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"PUT\", queryParams, postBody, headerParams, formParams, contentType, authNames);\n      if (localVarResponse != null) {\n         return ;\n      } else {\n         return ;\n      }\n    } catch (ApiException ex) {\n       throw ex;\n    } catch (InterruptedException ex) {\n       throw ex;\n    } catch (ExecutionException ex) {\n      if (ex.getCause() instanceof VolleyError) {\n        VolleyError volleyError = (VolleyError)ex.getCause();\n        if (volleyError.networkResponse != null) {\n          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());\n        }\n      }\n      throw ex;\n    } catch (TimeoutException ex) {\n      throw ex;\n    }\n  }\n","new_comment_raw":"@param pet Pet object that needs to be added to the store","old_comment_raw":"@param body Pet object that needs to be added to the store","label":1,"pre_label":0,"AST_level":11,"line_counts":56,"new_code_token_num":349},{"new_code_raw":"public static SDOGeometry join(SDOGeometry[] sdoElements) { final SDOGeometry sdoCollection = new SDOGeometry(); if ( sdoElements == null || sdoElements.length == 0 ) { sdoCollection.setGType( new SDOGType( 2, 0, TypeGeometry.COLLECTION ) ); } else { final SDOGeometry firstElement = sdoElements[0]; final int dim = firstElement.getGType().getDimension(); final int lrsDim = firstElement.getGType().getLRSDimension(); sdoCollection.setGType( new SDOGType( dim, lrsDim, TypeGeometry.COLLECTION ) ); int ordinatesOffset = 1; for ( int i = 0; i < sdoElements.length; i++ ) { final ElemInfo element = sdoElements[i].getInfo(); final Double[] ordinates = sdoElements[i].getOrdinates().getOrdinateArray(); if ( element != null && element.getSize() > 0 ) { final int shift = ordinatesOffset - element.getOrdinatesOffset( 0 ); shiftOrdinateOffset( element, shift ); sdoCollection.addElement( element ); sdoCollection.addOrdinates( ordinates ); ordinatesOffset += ordinates.length; } } } return sdoCollection; }","old_code_raw":"\tpublic static SDOGeometry join(SDOGeometry[] SDOElements) {\n\t\tSDOGeometry SDOCollection = new SDOGeometry();\n\t\tif ( SDOElements == null || SDOElements.length == 0 ) {\n\t\t\tSDOCollection.setGType(\n\t\t\t\t\tnew SDOGType(\n\t\t\t\t\t\t\t2, 0,\n\t\t\t\t\t\t\tTypeGeometry.COLLECTION\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tSDOGeometry firstElement = SDOElements[0];\n\t\t\tint dim = firstElement.getGType().getDimension();\n\t\t\tint lrsDim = firstElement.getGType().getLRSDimension();\n\t\t\tSDOCollection.setGType(\n\t\t\t\t\tnew SDOGType(\n\t\t\t\t\t\t\tdim, lrsDim,\n\t\t\t\t\t\t\tTypeGeometry.COLLECTION\n\t\t\t\t\t)\n\t\t\t);\n\t\t\tint ordinatesOffset = 1;\n\t\t\tfor ( int i = 0; i < SDOElements.length; i++ ) {\n\t\t\t\tElemInfo element = SDOElements[i].getInfo();\n\t\t\t\tDouble[] ordinates = SDOElements[i].getOrdinates()\n\t\t\t\t\t\t.getOrdinateArray();\n\t\t\t\tif ( element != null && element.getSize() > 0 ) {\n\t\t\t\t\tint shift = ordinatesOffset\n\t\t\t\t\t\t\t- element.getOrdinatesOffset( 0 );\n\t\t\t\t\tshiftOrdinateOffset( element, shift );\n\t\t\t\t\tSDOCollection.addElement( element );\n\t\t\t\t\tSDOCollection.addOrdinates( ordinates );\n\t\t\t\t\tordinatesOffset += ordinates.length;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn SDOCollection;\n\t}\n","new_comment_raw":"@param sdoElements The SDO_geometries to join into an SDO Geometry Collection","old_comment_raw":"@param SDOElements","label":1,"pre_label":0,"AST_level":13,"line_counts":26,"new_code_token_num":195},{"new_code_raw":"protected String setEscapedParameter(HttpMessage message, String param, String value) { return variant.setEscapedParameter(message, originalPair, param, value); }","old_code_raw":"    protected String setEscapedParameter(HttpMessage msg, String param, String value) {\n        return variant.setEscapedParameter(msg, originalPair, param, value);\n    }\n","new_comment_raw":"@param param the name of the parameter","old_comment_raw":"@param param","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":28},{"new_code_raw":"private ServiceReference[] getInitialReferences(boolean trackAllServices, String className, String filterString) throws InvalidSyntaxException { if (trackAllServices) { return context.getAllServiceReferences(className, filterString); } return context.getServiceReferences(className, filterString); }","old_code_raw":"\tprivate ServiceReference[] getInitialReferences(boolean trackAllServices,\n\t\t\tString trackClass, String filterString)\n\t\t\tthrows InvalidSyntaxException {\n\t\tif (trackAllServices) {\n\t\t\treturn context.getAllServiceReferences(trackClass, filterString);\n\t\t}\n\t\telse {\n\t\t\treturn context.getServiceReferences(trackClass, filterString);\n\t\t}\n\t}\n","new_comment_raw":"@param className The class name with which the service was registered, or null for all services.","old_comment_raw":"@param trackClass the class name with which the service was registered, or null for all services.","label":1,"pre_label":0,"AST_level":7,"line_counts":10,"new_code_token_num":43},{"new_code_raw":"public int compareTo(ReadableInstant other) { if (this == other) { return 0; } long otherMillis = other.getMillis(); long thisMillis = getMillis(); \/\/ cannot do (thisMillis - otherMillis) as can overflow if (thisMillis == otherMillis) { return 0; } if (thisMillis < otherMillis) { return -1; } else { return 1; } }","old_code_raw":"    public int compareTo(Object instant) {\n        if (this == instant) {\n            return 0;\n        }\n        \n        ReadableInstant otherInstant = (ReadableInstant) instant;\n        \n        long otherMillis = otherInstant.getMillis();\n        long thisMillis = getMillis();\n        \n        \/\/ cannot do (thisMillis - otherMillis) as can overflow\n        if (thisMillis == otherMillis) {\n            return 0;\n        }\n        if (thisMillis < otherMillis) {\n            return -1;\n        } else {\n            return 1;\n        }\n    }\n","new_comment_raw":"@param other a readable instant to check against","old_comment_raw":"@param instant a readable instant to check against","label":1,"pre_label":0,"AST_level":6,"line_counts":19,"new_code_token_num":71},{"new_code_raw":"private URL determineSuiteUrl(String startURL, String suiteURL) throws IOException { if (suiteURL.startsWith(\"https:\/\/\") || suiteURL.startsWith(\"http:\/\/\")) { return verifySuiteUrl(new URL(suiteURL)); } \/\/ Is the suiteURL a file? Path path = Paths.get(suiteURL); if (Files.exists(path)) { \/\/ Not all drivers can read files from the disk, so we need to host the suite somewhere. try (SocketLock lock = new SocketLock()) { server = new Server(); HttpConfiguration httpConfig = new HttpConfiguration(); ServerConnector http = new ServerConnector(server, new HttpConnectionFactory(httpConfig)); int port = PortProber.findFreePort(); http.setPort(port); http.setIdleTimeout(500000); server.setConnectors(new Connector[]{http}); ResourceHandler handler = new ResourceHandler(); handler.setDirectoriesListed(true); handler.setWelcomeFiles(new String[]{path.getFileName().toString(), \"index.html\"}); handler.setBaseResource(new PathResource(path.toFile().getParentFile().toPath().toRealPath())); ContextHandler context = new ContextHandler(\"\/tests\"); context.setHandler(handler); server.setHandler(context); server.start(); PortProber.waitForPortUp(port, 15, SECONDS); URL serverUrl = server.getURI().toURL(); return new URL(serverUrl.getProtocol(), serverUrl.getHost(), serverUrl.getPort(), \"\/tests\/\"); } catch (Exception e) { throw new IOException(e); } } \/\/ Well then, it must be a URL relative to whatever the browserUrl. Probe and find out. URL browser = new URL(startURL); return verifySuiteUrl(new URL(browser, suiteURL)); }","old_code_raw":"  private URL determineSuiteUrl(String browserUrl, String suiteURL) throws IOException {\n    if (suiteURL.startsWith(\"https:\/\/\") || suiteURL.startsWith(\"http:\/\/\")) {\n      return verifySuiteUrl(new URL(suiteURL));\n    }\n\n    \/\/ Is the suiteURL a file?\n    Path path = Paths.get(suiteURL);\n    if (Files.exists(path)) {\n      \/\/ Not all drivers can read files from the disk, so we need to host the suite somewhere.\n      try (SocketLock lock = new SocketLock()) {\n        server = new Server();\n        HttpConfiguration httpConfig = new HttpConfiguration();\n\n        ServerConnector http = new ServerConnector(server, new HttpConnectionFactory(httpConfig));\n        int port = PortProber.findFreePort();\n        http.setPort(port);\n        http.setIdleTimeout(500000);\n        server.setConnectors(new Connector[]{http});\n\n        ResourceHandler handler = new ResourceHandler();\n        handler.setDirectoriesListed(true);\n        handler.setWelcomeFiles(new String[]{path.getFileName().toString(), \"index.html\"});\n        handler.setBaseResource(new PathResource(path.toFile().getParentFile().toPath().toRealPath()));\n\n        ContextHandler context = new ContextHandler(\"\/tests\");\n        context.setHandler(handler);\n\n        server.setHandler(context);\n        server.start();\n\n        PortProber.waitForPortUp(port, 15, SECONDS);\n\n        URL serverUrl = server.getURI().toURL();\n        return new URL(serverUrl.getProtocol(), serverUrl.getHost(), serverUrl.getPort(),\n                       \"\/tests\/\");\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n\n    \/\/ Well then, it must be a URL relative to whatever the browserUrl. Probe and find out.\n    URL browser = new URL(browserUrl);\n    return verifySuiteUrl(new URL(browser, suiteURL));\n  }\n","new_comment_raw":"@param startURL - the start URL for the browser","old_comment_raw":"@param browserURL - the start URL for the browser","label":1,"pre_label":0,"AST_level":11,"line_counts":45,"new_code_token_num":351},{"new_code_raw":"public OuterComposite fakeOuterCompositeSerialize(OuterComposite outerComposite) throws ApiException { return fakeOuterCompositeSerializeWithHttpInfo(outerComposite).getData(); }","old_code_raw":"  public OuterComposite fakeOuterCompositeSerialize(OuterComposite body) throws ApiException {\n    return fakeOuterCompositeSerializeWithHttpInfo(body).getData();\n      }\n","new_comment_raw":"@param outerComposite Input composite as post body (optional)","old_comment_raw":"@param body Input composite as post body (optional)","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"public void createUsersWithListInput (List<User> user) throws TimeoutException, ExecutionException, InterruptedException, ApiException { Object postBody = user; \/\/ verify the required parameter 'user' is set if (user == null) { VolleyError error = new VolleyError(\"Missing the required parameter 'user' when calling createUsersWithListInput\", new ApiException(400, \"Missing the required parameter 'user' when calling createUsersWithListInput\")); } \/\/ create path and map variables String path = \"\/user\/createWithList\"; \/\/ query params List<Pair> queryParams = new ArrayList<Pair>(); \/\/ header params Map<String, String> headerParams = new HashMap<String, String>(); \/\/ form params Map<String, String> formParams = new HashMap<String, String>(); String[] contentTypes = { }; String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\"; if (contentType.startsWith(\"multipart\/form-data\")) { \/\/ file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); HttpEntity httpEntity = localVarBuilder.build(); postBody = httpEntity; } else { \/\/ normal form params } String[] authNames = new String[] { }; try { String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames); if (localVarResponse != null) { return ; } else { return ; } } catch (ApiException ex) { throw ex; } catch (InterruptedException ex) { throw ex; } catch (ExecutionException ex) { if (ex.getCause() instanceof VolleyError) { VolleyError volleyError = (VolleyError)ex.getCause(); if (volleyError.networkResponse != null) { throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage()); } } throw ex; } catch (TimeoutException ex) { throw ex; } }","old_code_raw":"  public void createUsersWithListInput (List<User> body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {\n    Object postBody = body;\n    \/\/ verify the required parameter 'body' is set\n    if (body == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'body' when calling createUsersWithListInput\",\n        new ApiException(400, \"Missing the required parameter 'body' when calling createUsersWithListInput\"));\n    }\n\n    \/\/ create path and map variables\n    String path = \"\/user\/createWithList\";\n\n    \/\/ query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    \/\/ header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    \/\/ form params\n    Map<String, String> formParams = new HashMap<String, String>();\n    String[] contentTypes = {\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\";\n\n    if (contentType.startsWith(\"multipart\/form-data\")) {\n      \/\/ file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      HttpEntity httpEntity = localVarBuilder.build();\n      postBody = httpEntity;\n    } else {\n      \/\/ normal form params\n    }\n\n    String[] authNames = new String[] {  };\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames);\n      if (localVarResponse != null) {\n         return ;\n      } else {\n         return ;\n      }\n    } catch (ApiException ex) {\n       throw ex;\n    } catch (InterruptedException ex) {\n       throw ex;\n    } catch (ExecutionException ex) {\n      if (ex.getCause() instanceof VolleyError) {\n        VolleyError volleyError = (VolleyError)ex.getCause();\n        if (volleyError.networkResponse != null) {\n          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());\n        }\n      }\n      throw ex;\n    } catch (TimeoutException ex) {\n      throw ex;\n    }\n  }\n","new_comment_raw":"@param user List of user object","old_comment_raw":"@param body List of user object","label":1,"pre_label":0,"AST_level":11,"line_counts":56,"new_code_token_num":349},{"new_code_raw":"private static RestClient connect(List<HttpHost> hosts) { Objects.requireNonNull(hosts, \"hosts or coordinates\"); Preconditions.checkArgument(!hosts.isEmpty(), \"no ES hosts specified\"); return RestClient.builder(hosts.toArray(new HttpHost[hosts.size()])).build(); }","old_code_raw":"  private static RestClient connect(Map<String, Integer> coordinates) {\n    Objects.requireNonNull(coordinates, \"coordinates\");\n    Preconditions.checkArgument(!coordinates.isEmpty(), \"no ES coordinates specified\");\n    final Set<HttpHost> set = new LinkedHashSet<>();\n    for (Map.Entry<String, Integer> entry: coordinates.entrySet()) {\n      set.add(new HttpHost(entry.getKey(), entry.getValue()));\n    }\n\n    return RestClient.builder(set.toArray(new HttpHost[0])).build();\n  }\n","new_comment_raw":"@param hosts list of ES HTTP Hosts to connect to","old_comment_raw":"@param coordinates list of hostname\/port to connect to","label":1,"pre_label":0,"AST_level":7,"line_counts":8,"new_code_token_num":61},{"new_code_raw":"protected BroadcastAction filter(AtmosphereResource<?,?> r, Object message, Object originalMessage) { BroadcastAction transformed = new BroadcastAction(originalMessage); for (PerRequestBroadcastFilter mf : perRequestFilters) { synchronized (mf) { transformed = mf.filter(r, message, transformed.message()); if (transformed == null || transformed.action() == BroadcastAction.ACTION.ABORT) { return transformed; } } } return transformed; }","old_code_raw":"    protected BroadcastAction filter(HttpServletRequest request, HttpServletResponse response, Object object) {\n        BroadcastAction transformed = new BroadcastAction(object);\n        for (PerRequestBroadcastFilter mf : perRequestFilters) {\n            synchronized (mf) {\n                transformed = mf.filter(request, response, transformed.message());\n                if (transformed == null || transformed.action() == BroadcastAction.ACTION.ABORT) {\n                    return transformed;\n                }\n            }\n        }\n        return transformed;\n    }\n","new_comment_raw":"@param r  AtmosphereResource","old_comment_raw":"@param request javax.servlet.http.HttpServletRequest","label":1,"pre_label":0,"AST_level":9,"line_counts":13,"new_code_token_num":77},{"new_code_raw":"public long getMessageCount(String destinationName) { if (null == brokerService) { throw new IllegalStateException(\"BrokerService has not yet been created - was before() called?\"); } \/\/ TODO: Figure out how to do this for Topics Destination destination = getDestination(destinationName); if (destination == null) { throw new RuntimeException(\"Failed to find destination: \" + destinationName); } \/\/ return destination.getMessageStore().getMessageCount(); return destination.getDestinationStatistics().getMessages().getCount(); }","old_code_raw":"    public int getMessageCount(String fullDestinationName) throws Exception {\n        final int QUEUE_TYPE = 1;\n        final int TOPIC_TYPE = 2;\n\n        if (null == brokerService) {\n            throw new IllegalStateException(\"BrokerService has not yet been created - was before() called?\");\n        }\n\n        int destinationType = QUEUE_TYPE;\n        String destinationName = fullDestinationName;\n\n        if (fullDestinationName.startsWith(\"queue:\")) {\n            destinationName = fullDestinationName.substring(fullDestinationName.indexOf(':') + 1);\n        } else if (fullDestinationName.startsWith(\"topic:\")) {\n            destinationType = TOPIC_TYPE;\n            destinationName = fullDestinationName.substring(fullDestinationName.indexOf(':') + 1);\n        }\n\n        int messageCount = -1;\n        boolean foundDestination = false;\n        for (Destination destination : brokerService.getBroker().getDestinationMap().values()) {\n            String tmpName = destination.getName();\n            if (tmpName.equalsIgnoreCase(destinationName)) {\n                switch (destinationType) {\n                    case QUEUE_TYPE:\n                        if (destination instanceof Queue) {\n                            messageCount = destination.getMessageStore().getMessageCount();\n                            foundDestination = true;\n                        }\n                        break;\n                    case TOPIC_TYPE:\n                        if (destination instanceof Topic) {\n                            messageCount = destination.getMessageStore().getMessageCount();\n                            foundDestination = true;\n                        }\n                        break;\n                    default:\n                        \/\/ Should never see this\n                        log.error(\"Type didn't match: {}\", destination.getClass().getName());\n                }\n            }\n            if (foundDestination) {\n                break;\n            }\n        }\n\n        if (!foundDestination) {\n            log.warn(\"Didn't find destination {} in broker {}\", fullDestinationName, getBrokerName());\n        }\n\n        return messageCount;\n    }\n","new_comment_raw":"@param destinationName the full name of the JMS Destination","old_comment_raw":"@param fullDestinationName the full name of the JMS Destination","label":1,"pre_label":0,"AST_level":8,"line_counts":15,"new_code_token_num":101},{"new_code_raw":"public BroadcastAction filter(Object originalMessage, Object message) { \/\/ Avoid re-broadcasting if (!receivedMessages.remove(message)) { try { jchannel.send(new Message(null, null, (Serializable)message)); } catch (ChannelException e) { logger.warn(\"failed to send message\", e); } } return new BroadcastAction(message); }","old_code_raw":"    public BroadcastAction filter(Object originalMessage, Object o) {\n        if (o instanceof String){\n            String message = (String)o;\n            \/\/ Avoid re-broadcasting\n            if (!receivedMessages.remove(message)) {\n                try {\n                    jchannel.send(new Message(null, null, message));\n                } catch (ChannelException e) {\n                    logger.warn(\"failed to send message\", e);\n                }\n            }\n            return new BroadcastAction(message);\n        } else {\n            return new BroadcastAction(o);\n        }\n    }\n","new_comment_raw":"@param message the message to broadcast.","old_comment_raw":"@param o the message to broadcast.","label":1,"pre_label":0,"AST_level":10,"line_counts":12,"new_code_token_num":76},{"new_code_raw":"public boolean searchText(String text, int minimumNumberOfMatches) { boolean found = searcher.searchWithTimeoutFor(TextView.class, text, minimumNumberOfMatches, true); return found; }","old_code_raw":"\tpublic boolean searchText(String regex, int expectedMinimumNumberOfMatches) {\n\t\tboolean found = searcher.searchWithTimeoutFor(TextView.class, regex, expectedMinimumNumberOfMatches, true);\n\t\treturn found;\n\t}\n","new_comment_raw":"@param minimumNumberOfMatches the minimum number of matches expected to be found.  0 matches means that one or more matches are expected to be found","old_comment_raw":"@param expectedMinimumNumberOfMatches the minimum number of matches expected to be found. 0 matches means that one or more matches are expected to be found","label":1,"pre_label":0,"AST_level":7,"line_counts":5,"new_code_token_num":30},{"new_code_raw":"public List<WebElement> apply(WebDriver driver) { WebElement current = findElement(parent, driver); List<WebElement> allChildren = current.findElements(childLocator); \/\/ The original code only checked the first element. Fair enough. if (!allChildren.isEmpty() && allChildren.get(0).isDisplayed()) { return allChildren; } return null; }","old_code_raw":"      public List<WebElement> apply(WebDriver webDriver) {\n        Boolean displayed = false;\n        Boolean exists = false;\n        try {\n          exists = findElement(locator, webDriver).findElements(sub_locator).size() > 0;\n          displayed =\n            findElement(locator, webDriver).findElement(sub_locator).isDisplayed();\n        } catch (Exception e) {\n          int i = 0;\n        }\n        return (exists && displayed) ?\n               findElement(locator, webDriver).findElements(sub_locator) :\n               null;\n      }\n","new_comment_raw":"@param childLocator used to find the ultimate child element.","old_comment_raw":"@param sub_locator used to find child element. For example td By.xpath(\".\/tr\/td\")","label":1,"pre_label":0,"AST_level":6,"line_counts":12,"new_code_token_num":66},{"new_code_raw":"public Single<Void> rxUpdateUser(String username, User user) { return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> { delegate.updateUser(username, user, fut); })); }","old_code_raw":"    public Single<Void> rxUpdateUser(String username, User body) {\n        return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> {\n            delegate.updateUser(username, body, fut);\n        }));\n    }\n","new_comment_raw":"@param user Updated user object (required)","old_comment_raw":"@param body Updated user object (required)","label":1,"pre_label":0,"AST_level":10,"line_counts":6,"new_code_token_num":41},{"new_code_raw":"public boolean searchText(String regex, int matches, boolean scroll) { long now = System.currentTimeMillis(); final long endTime = now + TIMEOUT; while (!searchForText(regex, matches, scroll) && now < endTime) { now = System.currentTimeMillis(); } if(now < endTime) return true; else return false; }","old_code_raw":"\tpublic boolean searchText(String search, int matches, boolean scroll) {\n        long now = System.currentTimeMillis();\n        final long endTime = now + TIMEOUT;\n        while (!searchForText(search, matches, scroll) && now < endTime)\n        {\n        \tnow = System.currentTimeMillis();\n        }\n        if(now < endTime)\n        \treturn true;\n        else\n        \treturn false;\n\t}\n","new_comment_raw":"@param regex the text to search for. The parameter will be interpreted as a regular expression.","old_comment_raw":"@param search the string to be searched. The parameter will be interpreted as a regular expression.","label":1,"pre_label":0,"AST_level":7,"line_counts":13,"new_code_token_num":65},{"new_code_raw":"public boolean searchForEditText(String regex, boolean scroll) { inst.waitForIdleSync(); Pattern p = Pattern.compile(regex); Matcher matcher; ArrayList<EditText> editTextList = viewFetcher.getCurrentViews(EditText.class); for(EditText editText : editTextList){ matcher = p.matcher(editText.getText().toString()); if (matcher.find()) { return true; } } if (scroll && scroller.scroll(Scroller.Direction.DOWN)) return searchForEditText(regex, scroll); else return false; }","old_code_raw":"\tpublic boolean searchForEditText(String search, boolean scroll) {\n\t\tinst.waitForIdleSync();\n\t\tPattern p = Pattern.compile(search);\n\t\tMatcher matcher;\n\t\tArrayList<EditText> editTextList = viewFetcher.getCurrentViews(EditText.class);\n\t\tfor(EditText editText : editTextList){\n\t\t\tmatcher = p.matcher(editText.getText().toString());\n\t\t\tif (matcher.find()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tif (scroll && scroller.scroll(Scroller.Direction.DOWN))\n\t\t\treturn searchForEditText(search, scroll);\n\t\telse\n\t\t\treturn false;\n\t}\n","new_comment_raw":"@param regex the text to search for. The parameter will be interpreted as a regular expression.","old_comment_raw":"@param search the search string to be searched. The parameter will be interpreted as a regular expression.","label":1,"pre_label":0,"AST_level":9,"line_counts":18,"new_code_token_num":97},{"new_code_raw":"public Client testClientModel(Client client, Map<String, Object> params) throws IOException { HttpResponse response = testClientModelForHttpResponse(client, params); TypeReference typeRef = new TypeReference<Client>() {}; return apiClient.getObjectMapper().readValue(response.getContent(), typeRef); }","old_code_raw":"    public Client testClientModel(Client body, Map<String, Object> params) throws IOException {\n        HttpResponse response = testClientModelForHttpResponse(body, params);\n        TypeReference typeRef = new TypeReference<Client>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    }\n","new_comment_raw":"@param client client model","old_comment_raw":"@param body client model","label":1,"pre_label":0,"AST_level":8,"line_counts":6,"new_code_token_num":51},{"new_code_raw":"public static Granularity extractGranularity(RexNode node) { final int flagIndex; switch (node.getKind()) { case EXTRACT: flagIndex = 0; break; case FLOOR: flagIndex = 1; break; default: return null; } final RexCall call = (RexCall) node; if (call.operands.size() != 2) { return null; } final RexLiteral flag = (RexLiteral) call.operands.get(flagIndex); final TimeUnitRange timeUnit = (TimeUnitRange) flag.getValue(); if (timeUnit == null) { return null; } switch (timeUnit) { case YEAR: return Granularity.YEAR; case QUARTER: return Granularity.QUARTER; case MONTH: return Granularity.MONTH; case WEEK: return Granularity.WEEK; case DAY: return Granularity.DAY; case HOUR: return Granularity.HOUR; case MINUTE: return Granularity.MINUTE; case SECOND: return Granularity.SECOND; default: return null; } }","old_code_raw":"  public static Granularity extractGranularity(RexCall call) {\n    if ((call.getKind() != SqlKind.FLOOR && call.getKind() != SqlKind.EXTRACT)\n            || call.getOperands().size() != 2) {\n      return null;\n    }\n    int flagIndex;\n    if (call.getKind() == SqlKind.EXTRACT) {\n      \/\/ EXTRACT\n      flagIndex = 0;\n    } else {\n      \/\/ FLOOR\n      flagIndex = 1;\n    }\n    final RexLiteral flag = (RexLiteral) call.operands.get(flagIndex);\n    final TimeUnitRange timeUnit = (TimeUnitRange) flag.getValue();\n    if (timeUnit == null) {\n      return null;\n    }\n    switch (timeUnit) {\n    case YEAR:\n      return Granularity.YEAR;\n    case QUARTER:\n      return Granularity.QUARTER;\n    case MONTH:\n      return Granularity.MONTH;\n    case WEEK:\n      return Granularity.WEEK;\n    case DAY:\n      return Granularity.DAY;\n    case HOUR:\n      return Granularity.HOUR;\n    case MINUTE:\n      return Granularity.MINUTE;\n    case SECOND:\n      return Granularity.SECOND;\n    default:\n      return null;\n    }\n  }\n","new_comment_raw":"@param node the Rex node","old_comment_raw":"@param call the function call","label":1,"pre_label":0,"AST_level":7,"line_counts":43,"new_code_token_num":168},{"new_code_raw":"public final File getGeneratedOutput() throws CurnException { return hasGeneratedOutput() ? outputFile : null; }","old_code_raw":"public final InputStream getGeneratedOutput() throws CurnException {\n    InputStream result = null;\n    if (hasGeneratedOutput()) {\n        try {\n            result = new FileInputStream(outputFile);\n        } catch (FileNotFoundException ex) {\n            throw new CurnException(Curn.BUNDLE_NAME, STR, STR, new Object[] { outputFile }, ex);\n        }\n    }\n    return result;\n}","new_comment_raw":"@return the output file, or null if no suitable output was produced","old_comment_raw":"@return an open input stream, or null if no suitable output was produced","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":19},{"new_code_raw":"public HttpServletResponse getResponse() { return this.response; }","old_code_raw":"\t\tpublic HttpServletResponse getResponse() {\n\t\t\treturn response;\n\t\t}\n","new_comment_raw":"@return the response to write to. Cannot be null.","old_comment_raw":"@return the response to write to. Cannot be null.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":11},{"new_code_raw":"public static Schema unaliasSchema(Map<String, Schema> allSchemas, Schema schema) { if (allSchemas == null || allSchemas.isEmpty()) { LOGGER.warn(\"allSchemas cann't be null\/empty in unaliasSchema. Returned 'schema'\"); return schema; } if (schema != null && StringUtils.isNotEmpty(schema.get$ref())) { Schema ref = allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())); if (ref == null) { LOGGER.warn(\"{} is not defined\", schema.get$ref()); return schema; } else if (isStringSchema(ref) && (ref.getEnum() != null && !ref.getEnum().isEmpty())) { \/\/ top-level enum class return schema; } else if (isArraySchema(ref) || isComposedSchema(ref)) { \/\/ array def should be created as models return schema; } else if (isMapSchema(ref)) { if (ref.getProperties() != null && !ref.getProperties().isEmpty()) \/\/ has properties return schema; \/\/ treat it as model else { \/\/ treat it as a typical map \/* TODO unalias the map item if it's an alias if (ref.getAdditionalProperties() != null) { Schema innerSchema = (Schema) ref.getAdditionalProperties(); if (StringUtils.isNotEmpty(innerSchema.get$ref())) { \/\/ map item is a ref to something else \/\/Schema unaliasInnerSchema = unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(innerSchema.get$ref()))); \/\/ref.setAdditionalProperties(unaliasInnerSchema); } }*\/ return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()))); } } else if (isObjectSchema(ref)) { \/\/ model return schema; } else { return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()))); } } return schema; }","old_code_raw":"    public static Schema unaliasSchema(Map<String, Schema> allSchemas, Schema schema) {\n        if (schema != null && StringUtils.isNotEmpty(schema.get$ref())) {\n            Schema ref = allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()));\n            if (ref == null) {\n                LOGGER.warn(\"{} is not defined\", schema.get$ref());\n                return schema;\n            } else if (isObjectSchema(ref)) { \/\/ model\n                return schema;\n            } else if (isStringSchema(ref) && (ref.getEnum() != null && !ref.getEnum().isEmpty())) {\n                \/\/ top-level enum class\n                return schema;\n            } else if (isMapSchema(ref) || isArraySchema(ref) || isComposedSchema(ref)) { \/\/ map\/array def should be created as models\n                return schema;\n            } else {\n                return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));\n            }\n        }\n        return schema;\n    }\n","new_comment_raw":"@return actual schema","old_comment_raw":"@return actual schema","label":0,"pre_label":1,"AST_level":16,"line_counts":41,"new_code_token_num":397},{"new_code_raw":"public AsyncSupport newCometSupport(final Class<? extends AsyncSupport> targetClass) { try { return (AsyncSupport) targetClass.getDeclaredConstructor(new Class[]{AtmosphereConfig.class}) .newInstance(config); } catch (final Exception e) { logger.warn(\"Failed to create AsyncSupport class: {}, error: {}\", targetClass, e); return null; \/\/ All callers are expected to handle null return value } }","old_code_raw":"    public AsyncSupport newCometSupport(final Class<? extends AsyncSupport> targetClass) {\n        try {\n            return (AsyncSupport) targetClass.getDeclaredConstructor(new Class[]{AtmosphereConfig.class})\n                    .newInstance(config);\n        } catch (final Exception e) {\n            logger.error(\"Failed to create comet support class: {}, error: {}\", targetClass, e);\n            logger.error(\"Switching to BlockingIO\");\n\n            return new BlockingIOCometSupport(config);\n        }\n    }\n","new_comment_raw":"@return an instance of the specified class or null if the class cannot be instantiated","old_comment_raw":"@return an instance of the specified class","label":1,"pre_label":0,"AST_level":10,"line_counts":10,"new_code_token_num":83},{"new_code_raw":"public ExecutionInfo getParent() { return parentInfo; }","old_code_raw":"    public ExecutionInfo getParent() {\n        return parentType;\n    }\n","new_comment_raw":"@return the parent type information","old_comment_raw":"@return the parent type information","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"public static String getHostFromUrl(String url) { String authority = getAuthorityFromUrl(url); int idx = authority.indexOf(STR); if (idx == -NUM) return authority; return authority.substring(NUM, idx); }","old_code_raw":"public static String getHostFromUrl(String url) {\n    if (url.indexOf(STR) == -NUM)\n        return url;\n    int slashes = NUM;\n    if (url.contains(STR))\n        slashes += NUM;\n    String[] parts = url.split(STR);\n    if (parts.length < slashes)\n        return url;\n    return parts[slashes];\n}","new_comment_raw":"@return The host, as a string.","old_comment_raw":"@return Host name and port, as a string.","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":43},{"new_code_raw":"public static ModuleConfig getModuleConfig(HttpServletRequest request, ServletContext context) { ModuleConfig moduleConfig = (ModuleConfig) request.getAttribute(Globals.MODULE_KEY); if (moduleConfig == null) { moduleConfig = (ModuleConfig) context.getAttribute(Globals.MODULE_KEY); } return moduleConfig; }","old_code_raw":"public static ApplicationConfig getModuleConfig(HttpServletRequest request, ServletContext context) {\n    ApplicationConfig appConfig = (ApplicationConfig) request.getAttribute(Globals.MODULE_KEY);\n    if (appConfig == null) {\n        appConfig = (ApplicationConfig) context.getAttribute(Globals.MODULE_KEY);\n    }\n    return appConfig;\n}","new_comment_raw":"@return the ModuleConfig object","old_comment_raw":"@return the ApplicationConfig object","label":1,"pre_label":0,"AST_level":9,"line_counts":7,"new_code_token_num":46},{"new_code_raw":"public Optional<GraphQLError> add(Definition definition) { \/\/ extensions if (definition instanceof ObjectTypeExtensionDefinition) { ObjectTypeExtensionDefinition newEntry = (ObjectTypeExtensionDefinition) definition; return defineExt(objectTypeExtensions, newEntry, ObjectTypeExtensionDefinition::getName); } else if (definition instanceof InterfaceTypeExtensionDefinition) { InterfaceTypeExtensionDefinition newEntry = (InterfaceTypeExtensionDefinition) definition; return defineExt(interfaceTypeExtensions, newEntry, InterfaceTypeExtensionDefinition::getName); } else if (definition instanceof UnionTypeExtensionDefinition) { UnionTypeExtensionDefinition newEntry = (UnionTypeExtensionDefinition) definition; return defineExt(unionTypeExtensions, newEntry, UnionTypeExtensionDefinition::getName); } else if (definition instanceof EnumTypeExtensionDefinition) { EnumTypeExtensionDefinition newEntry = (EnumTypeExtensionDefinition) definition; return defineExt(enumTypeExtensions, newEntry, EnumTypeExtensionDefinition::getName); } else if (definition instanceof ScalarTypeExtensionDefinition) { ScalarTypeExtensionDefinition newEntry = (ScalarTypeExtensionDefinition) definition; return defineExt(scalarTypeExtensions, newEntry, ScalarTypeExtensionDefinition::getName); } else if (definition instanceof InputObjectTypeExtensionDefinition) { InputObjectTypeExtensionDefinition newEntry = (InputObjectTypeExtensionDefinition) definition; return defineExt(inputObjectTypeExtensions, newEntry, InputObjectTypeExtensionDefinition::getName); \/\/ \/\/ normal } else if (definition instanceof ScalarTypeDefinition) { ScalarTypeDefinition newEntry = (ScalarTypeDefinition) definition; return define(scalarTypes, scalarTypes, newEntry); } else if (definition instanceof TypeDefinition) { TypeDefinition newEntry = (TypeDefinition) definition; return define(types, types, newEntry); } else if (definition instanceof DirectiveDefinition) { DirectiveDefinition newEntry = (DirectiveDefinition) definition; return define(directiveDefinitions, directiveDefinitions, newEntry); } else if (definition instanceof SchemaDefinition) { SchemaDefinition newSchema = (SchemaDefinition) definition; if (schema != null) { return Optional.of(new SchemaRedefinitionError(this.schema, newSchema)); } else { schema = newSchema; } } return Optional.empty(); }","old_code_raw":"    public Optional<GraphQLError> add(SDLDefinition definition) {\n        \/\/ extensions\n        if (definition instanceof ObjectTypeExtensionDefinition) {\n            ObjectTypeExtensionDefinition newEntry = (ObjectTypeExtensionDefinition) definition;\n            return defineExt(typeExtensions, newEntry, ObjectTypeExtensionDefinition::getName);\n        } else if (definition instanceof InterfaceTypeExtensionDefinition) {\n            InterfaceTypeExtensionDefinition newEntry = (InterfaceTypeExtensionDefinition) definition;\n            return defineExt(interfaceTypeExtensions, newEntry, InterfaceTypeExtensionDefinition::getName);\n        } else if (definition instanceof UnionTypeExtensionDefinition) {\n            UnionTypeExtensionDefinition newEntry = (UnionTypeExtensionDefinition) definition;\n            return defineExt(unionTypeExtensions, newEntry, UnionTypeExtensionDefinition::getName);\n        } else if (definition instanceof EnumTypeExtensionDefinition) {\n            EnumTypeExtensionDefinition newEntry = (EnumTypeExtensionDefinition) definition;\n            return defineExt(enumTypeExtensions, newEntry, EnumTypeExtensionDefinition::getName);\n        } else if (definition instanceof ScalarTypeExtensionDefinition) {\n            ScalarTypeExtensionDefinition newEntry = (ScalarTypeExtensionDefinition) definition;\n            return defineExt(scalarTypeExtensions, newEntry, ScalarTypeExtensionDefinition::getName);\n        } else if (definition instanceof InputObjectTypeExtensionDefinition) {\n            InputObjectTypeExtensionDefinition newEntry = (InputObjectTypeExtensionDefinition) definition;\n            return defineExt(inputObjectTypeExtensions, newEntry, InputObjectTypeExtensionDefinition::getName);\n            \/\/\n            \/\/ normal\n        } else if (definition instanceof ScalarTypeDefinition) {\n            ScalarTypeDefinition newEntry = (ScalarTypeDefinition) definition;\n            return define(scalarTypes, scalarTypes, newEntry);\n        } else if (definition instanceof TypeDefinition) {\n            TypeDefinition newEntry = (TypeDefinition) definition;\n            return define(types, types, newEntry);\n        } else if (definition instanceof DirectiveDefinition) {\n            DirectiveDefinition newEntry = (DirectiveDefinition) definition;\n            return define(directiveDefinitions, directiveDefinitions, newEntry);\n        } else if (definition instanceof SchemaDefinition) {\n            SchemaDefinition newSchema = (SchemaDefinition) definition;\n            if (schema != null) {\n                return Optional.of(new SchemaRedefinitionError(this.schema, newSchema));\n            } else {\n                schema = newSchema;\n            }\n        } else {\n            return Assert.assertShouldNeverHappen();\n        }\n        return Optional.empty();\n    }\n","new_comment_raw":"@return an optional error","old_comment_raw":"@return an optional error","label":0,"pre_label":1,"AST_level":20,"line_counts":42,"new_code_token_num":319},{"new_code_raw":"public boolean isButtonOverflowVisible() { return mIsButtonOverflowVisible; }","old_code_raw":"public boolean isButtonOverflowVisible() {\n    if (mPopupMenu == NO_POPUP_MENU && mCustomOverflowAnimation == null) {\n        if (mIsButtonOverflowVisible)\n            Log.w(STR, STR);\n        return false;\n    }\n    return mIsButtonOverflowVisible;\n}","new_comment_raw":"@return <code>true<\/code> if the button is visible","old_comment_raw":"@return <code>true<\/code> if the button is visible and Popup Menu is assigned.","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":10},{"new_code_raw":"public DateTime withField(DateTimeFieldType fieldType, int value) { if (fieldType == null) { throw new IllegalArgumentException(\"Field must not be null\"); } long instant = fieldType.getField(getChronology()).set(getMillis(), value); return withMillis(instant); }","old_code_raw":"    public DateTime withField(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            return this;\n        }\n        long instant = fieldType.getField(getChronology()).set(getMillis(), value);\n        return withMillis(instant);\n    }\n","new_comment_raw":"@return a copy of this datetime with the field set","old_comment_raw":"@return a copy of this datetime with the field set","label":0,"pre_label":1,"AST_level":7,"line_counts":8,"new_code_token_num":56},{"new_code_raw":"public ICursor getCursor() { return cursor; }","old_code_raw":"public Cursor getCursor() {\n    return cursor;\n}","new_comment_raw":"@return the {@link ICursor} backing this SquidCursor. If you are on Android and you need to pass this object across process boundaries, and if this SquidCursor was obtained from a SquidDatabase, you can safely cast the object returned by this method to an Android cursor","old_comment_raw":"@return the {@link Cursor} backing this SquidCursor","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":10},{"new_code_raw":"public Client testClassname(Client body) throws ApiException { ApiResponse<Client> localVarResp = testClassnameWithHttpInfo(body); return localVarResp.getData(); }","old_code_raw":"    public Client testClassname(Client body) throws ApiException {\n        ApiResponse<Client> resp = testClassnameWithHttpInfo(body);\n        return resp.getData();\n    }\n","new_comment_raw":"@return Client","old_comment_raw":"@return Client","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":25},{"new_code_raw":"public static SqlParser create(String sql, Config config) { SqlAbstractParserImpl parser = config.parserFactory().getParser(new StringReader(sql)); return new SqlParser(sql, parser, config); }","old_code_raw":"  public static SqlParser create(String s) {\n    return create(SqlParserImpl.FACTORY, s, Quoting.DOUBLE_QUOTE,\n        Casing.TO_UPPER, Casing.UNCHANGED);\n  }\n","new_comment_raw":"@return A parser","old_comment_raw":"@return A SqlParser object.","label":1,"pre_label":0,"AST_level":8,"line_counts":7,"new_code_token_num":39},{"new_code_raw":"private ZapTextArea getTxtEncode() { if (txtEncode == null) { txtEncode = new ZapTextArea(); txtEncode.setLineWrap(true); txtEncode.setFont(new java.awt.Font(\"Courier New\", java.awt.Font.PLAIN, 12)); txtEncode.addMouseListener(new java.awt.event.MouseAdapter() { public void mousePressed(java.awt.event.MouseEvent e) { if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0) { \/\/ right mouse button view.getPopupMenu().show(e.getComponent(), e.getX(), e.getY()); } } }); } return txtEncode; }","old_code_raw":"\tprivate JTextArea getTxtEncode() {\n\t\tif (txtEncode == null) {\n\t\t\ttxtEncode = new JTextArea();\n\t\t\ttxtEncode.setLineWrap(true);\n\t\t\ttxtEncode.setFont(new java.awt.Font(\"Courier New\", java.awt.Font.PLAIN, 12));\n\t\t\ttxtEncode.addMouseListener(new java.awt.event.MouseAdapter() {   \n\t\t\t\tpublic void mousePressed(java.awt.event.MouseEvent e) {    \n\t          \t\tif ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0) {  \/\/ right mouse button\n\t            \t\tview.getPopupMenu().show(e.getComponent(), e.getX(), e.getY());\n\t            \t}\n\t\t\t\t} \n\n\t\t\t\n\t\t\t});\n\n\t\t}\n\t\treturn txtEncode;\n\t}\n","new_comment_raw":"@return javax.swing.ZapTextArea","old_comment_raw":"@return javax.swing.JTextField","label":1,"pre_label":0,"AST_level":14,"line_counts":19,"new_code_token_num":120},{"new_code_raw":"public Iterable<AttributeBinding> getAttributeBindingClosure() { \/\/ TODO: update size to account for joins Iterable<AttributeBinding> iterable; if ( superEntityBinding != null ) { List<Iterable<AttributeBinding>> iterables = new ArrayList<Iterable<AttributeBinding>>( 2 ); iterables.add( superEntityBinding.getAttributeBindingClosure() ); iterables.add( attributeBindings() ); iterable = new JoinedIterable<AttributeBinding>( iterables ); } else { iterable = attributeBindings(); } return iterable; }","old_code_raw":"\tpublic Iterable<AttributeBinding> getAttributeBindingClosure() {\n\t\t\/\/ TODO: fix this after HHH-6337 is fixed. for now, just return attributeBindings\n\t\t\/\/ if this is not a root, then need to include the superclass attribute bindings\n\t\treturn attributeBindings();\n\t}\n","new_comment_raw":"@return The attribute bindings.","old_comment_raw":"@return The attribute bindings.","label":0,"pre_label":1,"AST_level":12,"line_counts":15,"new_code_token_num":78},{"new_code_raw":"public ImageView getImage(int index) { return getView(ImageView.class, index); }","old_code_raw":"\tpublic ImageView getImage(int index) {\n\t\tArrayList<ImageView> imageList = getCurrentViews(ImageView.class);\n\t\tImageView imageView = null;\n\t\ttry{\n\t\t\timageView = imageList.get(index);\n\t\t}catch (IndexOutOfBoundsException e){\n\t\t\tAssert.assertTrue(\"No image view with index \" + index + \" is found\", false);\n\t\t}\n\t\treturn imageView;\n\t}\n","new_comment_raw":"@return the  ImageView with a specified index or  null if index is invalid","old_comment_raw":"@return the ImageView with a specified index or null if index is invalid","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":18},{"new_code_raw":"private Color invertBgColor() { if (currentColor_.defaultColor()) { if (!inverted_) clazzes_.add(INVERSE_BG_STYLE); return new Color(); } else if (currentColor_.isExtended()) { clazzes_.add(Color.clazzForColorIndex(currentColor_.code(), true)); return new Color(true, currentColor_.code()); } else if (currentColor_.code() >= FOREGROUND_MIN && currentColor_.code() <= FOREGROUND_MAX) { int newBg = currentColor_.code() + (BACKGROUND_MIN - FOREGROUND_MIN); clazzes_.add(BACKGROUND_STYLE + Integer.toString(newBg - BACKGROUND_MIN)); return new Color(false, newBg); } else { int newBg = currentColor_.code() + (BACKGROUND_INTENSE_MIN - FOREGROUND_INTENSE_MIN); clazzes_.add(BACKGROUND_STYLE + Integer.toString(newBg + NUM - BACKGROUND_INTENSE_MIN)); return new Color(false, newBg); } }","old_code_raw":"private int invertBgColor() {\n    if (currentColor_.defaultColor()) {\n        if (!inverted_)\n            clazzes_.add(INVERSE_BG_STYLE);\n        return Color.DEFAULT_COLOR;\n    } else if (currentColor_.code() >= FOREGROUND_MIN && currentColor_.code() <= FOREGROUND_MAX) {\n        int newBg = currentColor_.code() + (BACKGROUND_MIN - FOREGROUND_MIN);\n        clazzes_.add(BACKGROUND_STYLE + Integer.toString(newBg - BACKGROUND_MIN));\n        return newBg;\n    } else {\n        int newBg = currentColor_.code() + (BACKGROUND_INTENSE_MIN - FOREGROUND_INTENSE_MIN);\n        clazzes_.add(BACKGROUND_STYLE + Integer.toString(newBg + NUM - BACKGROUND_INTENSE_MIN));\n        return newBg;\n    }\n}","new_comment_raw":"@return new background color based on the foreground color","old_comment_raw":"@return new background color based on the supplied foreground color","label":1,"pre_label":0,"AST_level":13,"line_counts":18,"new_code_token_num":165},{"new_code_raw":"public double get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }","old_code_raw":"public double get(WithAttributes attributes) {\n    return attributes.getAttributes().get(this);\n}","new_comment_raw":"@return the value of this attribute if this attribute is present in the extracted map. Otherwise {@link #getDefaultValue()}","old_comment_raw":"@return the value of this attribute if this attribute is present in the map. Otherwise {@link #getDefaultValue()}","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":19},{"new_code_raw":"public static SchemaBuilder builder() { return SchemaBuilder.struct() .name(LOGICAL_NAME) .version(1) .doc(\"Geometry (POINT)\") .field(X_FIELD, Schema.FLOAT64_SCHEMA) .field(Y_FIELD, Schema.FLOAT64_SCHEMA) .field(WKB_FIELD, Schema.OPTIONAL_BYTES_SCHEMA) .field(SRID_FIELD, Schema.OPTIONAL_INT32_SCHEMA); }","old_code_raw":"    public static SchemaBuilder builder() {\n        return SchemaBuilder.struct()\n                .name(LOGICAL_NAME)\n                .version(1)\n                .doc(\"Geometry (POINT)\")\n                .field(X_FIELD, Schema.FLOAT64_SCHEMA)\n                .field(Y_FIELD, Schema.FLOAT64_SCHEMA)\n                .field(WKB_FIELD, Schema.BYTES_SCHEMA)\n                .field(SRID_FIELD, Schema.OPTIONAL_INT32_SCHEMA);\n    }\n","new_comment_raw":"@return the schema builder","old_comment_raw":"@return the schema builder","label":0,"pre_label":1,"AST_level":6,"line_counts":11,"new_code_token_num":59},{"new_code_raw":"private ZapTextArea getTxtDecode() { if (txtDecode == null) { txtDecode = new ZapTextArea(); txtDecode.setLineWrap(true); txtDecode.setFont(new java.awt.Font(\"Courier New\", java.awt.Font.PLAIN, 12)); } return txtDecode; }","old_code_raw":"\tprivate JTextArea getTxtDecode() {\n\t\tif (txtDecode == null) {\n\t\t\ttxtDecode = new JTextArea();\n\t\t\ttxtDecode.setLineWrap(true);\n\t\t\ttxtDecode.setFont(new java.awt.Font(\"Courier New\", java.awt.Font.PLAIN, 12));\n\t\t}\n\t\treturn txtDecode;\n\t}\n","new_comment_raw":"@return javax.swing.ZapTextArea","old_comment_raw":"@return javax.swing.JTextField","label":1,"pre_label":0,"AST_level":10,"line_counts":9,"new_code_token_num":51},{"new_code_raw":"public Button getButton(String text) { return viewFetcher.getView(Button.class, text, false); }","old_code_raw":"\tpublic Button getButton(String text)\n\t{\n\t\treturn viewFetcher.getView(Button.class, text);\n\t}\n","new_comment_raw":"@return the  Button that shows the given text","old_comment_raw":"@return the Button that shows the given text","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":21},{"new_code_raw":"public List<TestSuite> getSuite() { return this.testSuites; }","old_code_raw":"public TestSuite getSuite() {\n    return this.testSuite;\n}","new_comment_raw":"@return a linked list with parsed Test Suites. An empty list of no test suites were found.","old_comment_raw":"@return the parsed Test Suite or null if no Test Suite was found.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":12},{"new_code_raw":"@SuppressWarnings(STR) public static String append(final String url, final Map<String, ?> params) { if (params == null || params.isEmpty()) return url; final StringBuilder result = new StringBuilder(url); int firstColon = url.indexOf(STR); int lastSlash = url.lastIndexOf(STR); if (firstColon + NUM == lastSlash) result.append(STR); result.append(STR); Entry<String, ?> entry; Object value; Iterator<?> iterator = params.entrySet().iterator(); entry = (Entry<String, ?>) iterator.next(); result.append(entry.getKey()); result.append(STR); value = entry.getValue(); if (value != null) result.append(value); while (iterator.hasNext()) { result.append(STR); entry = (Entry<String, ?>) iterator.next(); result.append(entry.getKey()); result.append(STR); value = entry.getValue(); if (value != null) result.append(value); } return result.toString(); }","old_code_raw":"@SuppressWarnings(STR)\npublic static String append(String url, final Map<String, ?> params) {\n    if (params == null || params.isEmpty())\n        return url;\n    StringBuilder result = new StringBuilder();\n    if (!url.endsWith(STR))\n        url += STR;\n    Entry<String, ?> entry;\n    Object value;\n    Iterator<?> iterator = params.entrySet().iterator();\n    entry = (Entry<String, ?>) iterator.next();\n    result.append(entry.getKey());\n    result.append(STR);\n    value = entry.getValue();\n    if (value != null)\n        result.append(value);\n    while (iterator.hasNext()) {\n        result.append(STR);\n        entry = (Entry<String, ?>) iterator.next();\n        result.append(entry.getKey());\n        result.append(STR);\n        value = entry.getValue();\n        if (value != null)\n            result.append(value);\n    }\n    return url + STR + result.toString();\n}","new_comment_raw":"@return URL with appended query params","old_comment_raw":"@return URL with query params","label":1,"pre_label":0,"AST_level":10,"line_counts":30,"new_code_token_num":212},{"new_code_raw":"public static List<CmdLineOptionValidator.Result> validate(CmdLineArgs cmdLineArgs) { Validate.notNull(cmdLineArgs); List<CmdLineOptionValidator.Result> results = Lists.newArrayList(); for (CmdLineOptionInstance optionInst : cmdLineArgs.getSpecifiedOptions()) { results.addAll(CmdLineUtils.validate(optionInst)); } return results; }","old_code_raw":"public static Set<CmdLineOptionInstance> validate(CmdLineArgs cmdLineArgs) {\n    Validate.notNull(cmdLineArgs);\n    HashSet<CmdLineOptionInstance> optionsFailed = new HashSet<CmdLineOptionInstance>();\n    for (CmdLineOptionInstance optionInst : cmdLineArgs.getSpecifiedOptions()) {\n        if (!CmdLineUtils.validate(optionInst)) {\n            optionsFailed.add(optionInst);\n        }\n    }\n    return optionsFailed;\n}","new_comment_raw":"@return The {@link CmdLineOptionValidator.Result}s generated when running {@link CmdLineOptionValidator}s.","old_comment_raw":"@return The {@link CmdLineOptionInstance}s which failed validation.","label":1,"pre_label":0,"AST_level":8,"line_counts":8,"new_code_token_num":52},{"new_code_raw":"public EDecimal<Double> div(Expr<D> right) { return ODecimal.create(Double.class, Ops.DIV, this, right); }","old_code_raw":"    public ENumber<Double> div(Expr<D> right) {\n        return ONumber.create(Double.class, Ops.DIV, this, right);\n    }\n","new_comment_raw":"@return this \/ right","old_comment_raw":"@return this \/ right","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":26},{"new_code_raw":"static public boolean isCompatible(Mode mode, StringDict props) { String currentIdentifier = mode.getIdentifier(); StringList compatibleList = parseModeList(props); if (compatibleList.size() == 0) { if (mode.requireExampleCompatibility()) { \/\/ for p5js (and maybe Python), examples must specify that they work return false; } \/\/ if no Mode specified, assume compatible everywhere return true; } return compatibleList.hasValue(currentIdentifier); }","old_code_raw":"  static public boolean isCompatible(Base base, StringDict props) {\n    Mode mode = base.getActiveEditor().getMode();\n    String currentIdentifier = mode.getIdentifier();\n    StringList compatibleList = parseModeList(props);\n    if (compatibleList.size() == 0) {\n      if (mode.requireExampleCompatibility()) {\n        \/\/ for p5js (and maybe Python), examples must specify that they work\n        return false;\n      }\n      \/\/ if no Mode specified, assume compatible everywhere\n      return true;\n    }\n    for (String c : compatibleList) {\n      if (c.equals(currentIdentifier)) {\n        return true;\n      }\n    }\n    return false;\n  }\n","new_comment_raw":"@return true if compatible with the Mode of the currently active editor","old_comment_raw":"@return true if the example is compatible with the mode of the currently active editor","label":1,"pre_label":0,"AST_level":8,"line_counts":14,"new_code_token_num":85},{"new_code_raw":"public GremlinPipeline<S, Map<String, Object>> map() { return this.add(new PropertyMapPipe()); }","old_code_raw":"public T map() {\n    return this.add(new PropertyMapPipe());\n}","new_comment_raw":"@return the extended Pipeline","old_comment_raw":"@return the extended FluentPipeline","label":1,"pre_label":0,"AST_level":7,"line_counts":3,"new_code_token_num":23},{"new_code_raw":"public static String findReg() { if (reg != null) return reg; File systemRoot = findSystemRoot(); File regExe = new File(systemRoot, \"system32\/reg.exe\"); if (regExe.exists()) { reg = regExe.getAbsolutePath(); return reg; } regExe = new File(\"c:\\\\ntreskit\"); if (regExe.exists()) { reg = regExe.getAbsolutePath(); return reg; } regExe = AsyncExecute.whichExec(\"reg.exe\"); if (regExe != null && regExe.exists()) { reg = regExe.getAbsolutePath(); return reg; } System.err.println(\"OS Version: \" + System.getProperty(\"os.version\")); throw new RuntimeException(\"Couldn't find reg.exe!\\n\" + \"Please download it from Microsoft and install it in a standard location.\\n\" + \"See here for details: http:\/\/wiki.openqa.org\/display\/SRC\/Windows+Registry+Support\"); }","old_code_raw":"    public static String findReg() {\n        if (reg != null) return reg;\n        File systemRoot = findSystemRoot();\n        File regExe = new File(systemRoot, \"system32\/reg.exe\");\n        if (regExe.exists()) {\n            reg = regExe.getAbsolutePath();\n            return reg;\n        }\n        System.err.println(\"Couldn't find reg! Hope it's on the path...\");\n        reg = \"reg\";\n        return reg;\n    }\n","new_comment_raw":"@return the exact path to reg.exe, or just the string \"reg\" if it couldn't be found (in which case you can pass that to exec to try to run it from the path)","old_comment_raw":"@return the exact path to reg.exe, or just the string \"reg\" if it couldn't be found (in which case you can pass that to exec to try to run it from the path)","label":0,"pre_label":1,"AST_level":7,"line_counts":24,"new_code_token_num":199},{"new_code_raw":"private boolean areViewsIdentical(View firstView, View secondView){ if(firstView.getId() != secondView.getId() || !firstView.getClass().isAssignableFrom(secondView.getClass())){ return false; } if (firstView.getParent() != null && firstView.getParent() instanceof View && secondView.getParent() != null && secondView.getParent() instanceof View) { return areViewsIdentical((View) firstView.getParent(), (View) secondView.getParent()); } else { return true; } }","old_code_raw":"\tprivate boolean areViewsIdentical(View firstView, View secondView){\n\n\t\tif(firstView.getId() != secondView.getId() || !firstView.getClass().isAssignableFrom(secondView.getClass())){\n\t\t\treturn false;\n\t\t}\n\n\t\tif(!isSamePlacementInRespectiveTree(firstView, secondView)){\n\t\t\treturn false;\n\t\t}\n\n\t\tif (firstView.getParent() != null && firstView.getParent() instanceof View && \n\t\t\t\tsecondView.getParent() != null && secondView.getParent() instanceof View) {\n\n\t\t\treturn areViewsIdentical((View) firstView.getParent(), (View) secondView.getParent());\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n","new_comment_raw":"@return true if views are equal","old_comment_raw":"@return true if views are equal","label":0,"pre_label":1,"AST_level":8,"line_counts":14,"new_code_token_num":104},{"new_code_raw":"private List<SearchResult> searchImplementation() { \/\/ Pre-process the tree SemanticGraph parseTree = new SemanticGraph(this.parseTree); assert Util.isTree(parseTree); \/\/ (remove common determiners) List<String> determinerRemovals = new ArrayList<>(); parseTree.getLeafVertices().stream().filter(vertex -> vertex.word().equalsIgnoreCase(\"the\") || vertex.word().equalsIgnoreCase(\"a\") || vertex.word().equalsIgnoreCase(\"an\")).forEach(vertex -> { parseTree.removeVertex(vertex); assert Util.isTree(parseTree); determinerRemovals.add(\"det\"); }); \/\/ (cut conj_and nodes) Set<SemanticGraphEdge> andsToAdd = new HashSet<>(); for (IndexedWord vertex : parseTree.vertexSet()) { if( parseTree.inDegree(vertex) > 1 ) { SemanticGraphEdge conjAnd = null; for (SemanticGraphEdge edge : parseTree.incomingEdgeIterable(vertex)) { if (edge.getRelation().toString().equals(\"conj_and\")) { conjAnd = edge; } } if (conjAnd != null) { parseTree.removeEdge(conjAnd); assert Util.isTree(parseTree); andsToAdd.add(conjAnd); } } } \/\/ Clean the tree Util.cleanTree(parseTree); assert Util.isTree(parseTree); \/\/ Find the subject \/ object split \/\/ This takes max O(n^2) time, expected O(n*log(n)) time. \/\/ Optimal is O(n), but I'm too lazy to implement it. boolean isSubject[] = new boolean[65]; for (IndexedWord vertex : parseTree.vertexSet()) { \/\/ Search up the tree for a subj node; if found, mark that vertex as a subject. Iterator<SemanticGraphEdge> incomingEdges = parseTree.incomingEdgeIterator(vertex); SemanticGraphEdge edge = null; if (incomingEdges.hasNext()) { edge = incomingEdges.next(); } int numIters = 0; while (edge != null) { if (edge.getRelation().toString().endsWith(\"subj\")) { isSubject[vertex.index() - 1] = true; break; } incomingEdges = parseTree.incomingEdgeIterator(edge.getGovernor()); if (incomingEdges.hasNext()) { edge = incomingEdges.next(); } else { edge = null; } numIters += 1; if (numIters > 100) { System.err.println(\"ERROR: tree has apparent depth > 100\"); return Collections.EMPTY_LIST; } } } \/\/ Outputs List<SearchResult> results = new ArrayList<>(); if (!determinerRemovals.isEmpty()) { if (andsToAdd.isEmpty()) { double score = Math.pow(weights.deletionProbability(\"det\"), (double) determinerRemovals.size()); assert !Double.isNaN(score); assert !Double.isInfinite(score); results.add(new SearchResult(parseTree, determinerRemovals, score)); } else { SemanticGraph treeWithAnds = new SemanticGraph(parseTree); assert Util.isTree(treeWithAnds); for (SemanticGraphEdge and : andsToAdd) { treeWithAnds.addEdge(and.getGovernor(), and.getDependent(), and.getRelation(), Double.NEGATIVE_INFINITY, false); } assert Util.isTree(treeWithAnds); results.add(new SearchResult(treeWithAnds, determinerRemovals, Math.pow(weights.deletionProbability(\"det\"), (double) determinerRemovals.size()))); } } \/\/ Initialize the search assert Util.isTree(parseTree); List<IndexedWord> topologicalVertices; try { topologicalVertices = parseTree.topologicalSort(); } catch (IllegalStateException e) { System.err.println(\"Could not topologically sort the vertices! Using left-to-right traversal.\"); topologicalVertices = parseTree.vertexListSorted(); } if (topologicalVertices.isEmpty()) { return results; } Stack<SearchState> fringe = new Stack<>(); fringe.push(new SearchState(0l, 0, parseTree, null, null, 1.0)); \/\/ Start the search int numTicks = 0; while (!fringe.isEmpty()) { \/\/ Overhead with popping a node. if (numTicks >= maxTicks) { return results; } numTicks += 1; if (results.size() >= maxResults) { return results; } SearchState state = fringe.pop(); assert state.score > 0.0; IndexedWord currentWord = topologicalVertices.get(state.currentIndex); \/\/ Push the case where we don't delete int nextIndex = state.currentIndex + 1; int numIters = 0; while (nextIndex < topologicalVertices.size()) { IndexedWord nextWord = topologicalVertices.get(nextIndex); if ( ((state.deletionMask >>> (indexToMaskIndex[nextWord.index() - 1])) & 0x1l) == 0) { fringe.push(new SearchState(state.deletionMask, nextIndex, state.tree, null, state, state.score)); break; } else { nextIndex += 1; } numIters += 1; if (numIters > 10000) { System.err.println(\"ERROR: logic error (apparent infinite loop); returning\"); return results; } } \/\/ Check if we can delete this subtree boolean canDelete = !state.tree.getFirstRoot().equals(currentWord); for (SemanticGraphEdge edge : state.tree.incomingEdgeIterable(currentWord)) { if (\"CD\".equals(edge.getGovernor().tag())) { canDelete = false; } else { \/\/ Get token information CoreLabel token = edge.getDependent().backingLabel(); OperatorSpec operator; NaturalLogicRelation lexicalRelation; Polarity tokenPolarity = token.get(NaturalLogicAnnotations.PolarityAnnotation.class); if (tokenPolarity == null) { tokenPolarity = Polarity.DEFAULT; } \/\/ Get the relation for this deletion if ((operator = token.get(NaturalLogicAnnotations.OperatorAnnotation.class)) != null) { lexicalRelation = operator.instance.deleteRelation; } else { lexicalRelation = NaturalLogicRelation.forDependencyDeletion(edge.getRelation().toString(), isSubject[edge.getDependent().index() - 1]); } NaturalLogicRelation projectedRelation = tokenPolarity.projectLexicalRelation(lexicalRelation); \/\/ Make sure this is a valid entailment if (!projectedRelation.applyToTruthValue(truthOfPremise).isTrue()) { canDelete = false; } } } if (canDelete) { \/\/ Register the deletion Lazy<Pair<SemanticGraph,Long>> treeWithDeletionsAndNewMask = Lazy.of(() -> { SemanticGraph impl = new SemanticGraph(state.tree); long newMask = state.deletionMask; for (IndexedWord vertex : state.tree.descendants(currentWord)) { impl.removeVertex(vertex); newMask |= (0x1l << (indexToMaskIndex[vertex.index() - 1])); assert indexToMaskIndex[vertex.index() - 1] < 64; assert ((newMask >>> (indexToMaskIndex[vertex.index() - 1])) & 0x1l) == 1; } return Pair.makePair(impl, newMask); }); \/\/ Compute the score of the sentence double newScore = state.score; for (SemanticGraphEdge edge : state.tree.incomingEdgeIterable(currentWord)) { double multiplier = weights.deletionProbability(edge, state.tree.outgoingEdgeIterable(edge.getGovernor())); assert !Double.isNaN(multiplier); assert !Double.isInfinite(multiplier); newScore *= multiplier; } \/\/ Register the result if (newScore > 0.0) { SemanticGraph resultTree = new SemanticGraph(treeWithDeletionsAndNewMask.get().first); andsToAdd.stream().filter(edge -> resultTree.containsVertex(edge.getGovernor()) && resultTree.containsVertex(edge.getDependent())) .forEach(edge -> resultTree.addEdge(edge.getGovernor(), edge.getDependent(), edge.getRelation(), Double.NEGATIVE_INFINITY, false)); results.add(new SearchResult(resultTree, aggregateDeletedEdges(state, state.tree.incomingEdgeIterable(currentWord), determinerRemovals), newScore)); \/\/ Push the state with this subtree deleted nextIndex = state.currentIndex + 1; numIters = 0; while (nextIndex < topologicalVertices.size()) { IndexedWord nextWord = topologicalVertices.get(nextIndex); long newMask = treeWithDeletionsAndNewMask.get().second; SemanticGraph treeWithDeletions = treeWithDeletionsAndNewMask.get().first; if ( ((newMask >>> (indexToMaskIndex[nextWord.index() - 1])) & 0x1l) == 0) { assert treeWithDeletions.containsVertex(topologicalVertices.get(nextIndex)); fringe.push(new SearchState(newMask, nextIndex, treeWithDeletions, null, state, newScore)); break; } else { nextIndex += 1; } numIters += 1; if (numIters > 10000) { System.err.println(\"ERROR: logic error (apparent infinite loop); returning\"); return results; } } } } } \/\/ Return return results; }","old_code_raw":"  private List<SearchResult> searchImplementation() {\n    \/\/ Pre-process the tree\n    SemanticGraph parseTree = new SemanticGraph(this.parseTree);\n    assert Util.isTree(parseTree);\n    \/\/ (remove common determiners)\n    List<String> determinerRemovals = new ArrayList<>();\n    parseTree.getLeafVertices().stream().filter(vertex -> vertex.word().equalsIgnoreCase(\"the\") || vertex.word().equalsIgnoreCase(\"a\") ||\n        vertex.word().equalsIgnoreCase(\"an\")).forEach(vertex -> {\n      parseTree.removeVertex(vertex);\n      assert Util.isTree(parseTree);\n      determinerRemovals.add(\"det\");\n    });\n    \/\/ (cut conj_and nodes)\n    Set<SemanticGraphEdge> andsToAdd = new HashSet<>();\n    for (IndexedWord vertex : parseTree.vertexSet()) {\n      if( parseTree.inDegree(vertex) > 1 ) {\n        SemanticGraphEdge conjAnd = null;\n        for (SemanticGraphEdge edge : parseTree.incomingEdgeIterable(vertex)) {\n          if (edge.getRelation().toString().equals(\"conj_and\")) {\n            conjAnd = edge;\n          }\n        }\n        if (conjAnd != null) {\n          parseTree.removeEdge(conjAnd);\n          assert Util.isTree(parseTree);\n          andsToAdd.add(conjAnd);\n        }\n      }\n    }\n    \/\/ Clean the tree\n    Util.cleanTree(parseTree);\n    assert Util.isTree(parseTree);\n\n    \/\/ Find the subject \/ object split\n    \/\/ This takes max O(n^2) time, expected O(n*log(n)) time.\n    \/\/ Optimal is O(n), but I'm too lazy to implement it.\n    boolean isSubject[] = new boolean[65];\n    for (IndexedWord vertex : parseTree.vertexSet()) {\n      \/\/ Search up the tree for a subj node; if found, mark that vertex as a subject.\n      Iterator<SemanticGraphEdge> incomingEdges = parseTree.incomingEdgeIterator(vertex);\n      SemanticGraphEdge edge = null;\n      if (incomingEdges.hasNext()) {\n        edge = incomingEdges.next();\n      }\n      while (edge != null) {\n        if (edge.getRelation().toString().endsWith(\"subj\")) {\n          isSubject[vertex.index() - 1] = true;\n          break;\n        }\n        incomingEdges = parseTree.incomingEdgeIterator(edge.getGovernor());\n        if (incomingEdges.hasNext()) {\n          edge = incomingEdges.next();\n        } else {\n          edge = null;\n        }\n      }\n    }\n\n    \/\/ Outputs\n    List<SearchResult> results = new ArrayList<>();\n    if (!determinerRemovals.isEmpty()) {\n      if (andsToAdd.isEmpty()) {\n        double score = Math.pow(weights.deletionProbability(\"det\"), (double) determinerRemovals.size());\n        assert !Double.isNaN(score);\n        assert !Double.isInfinite(score);\n        results.add(new SearchResult(parseTree, determinerRemovals, score));\n      } else {\n        SemanticGraph treeWithAnds = new SemanticGraph(parseTree);\n        assert Util.isTree(treeWithAnds);\n        for (SemanticGraphEdge and : andsToAdd) {\n          treeWithAnds.addEdge(and.getGovernor(), and.getDependent(), and.getRelation(), Double.NEGATIVE_INFINITY, false);\n        }\n        assert Util.isTree(treeWithAnds);\n        results.add(new SearchResult(treeWithAnds, determinerRemovals,\n            Math.pow(weights.deletionProbability(\"det\"), (double) determinerRemovals.size())));\n      }\n    }\n\n    \/\/ Initialize the search\n    assert Util.isTree(parseTree);\n    List<IndexedWord> topologicalVertices;\n    try {\n      topologicalVertices = parseTree.topologicalSort();\n    } catch (IllegalStateException e) {\n      System.err.println(\"Could not topologically sort the vertices! Using left-to-right traversal.\");\n      topologicalVertices = parseTree.vertexListSorted();\n    }\n    if (topologicalVertices.isEmpty()) {\n      return results;\n    }\n    Stack<SearchState> fringe = new Stack<>();\n    fringe.push(new SearchState(0l, 0, parseTree, null, null, 1.0));\n\n    \/\/ Start the search\n    int numTicks = 0;\n    while (!fringe.isEmpty()) {\n      \/\/ Overhead with popping a node.\n      if (numTicks >= maxTicks) { return results; }\n      numTicks += 1;\n      if (results.size() >= maxResults) { return results; }\n      SearchState state = fringe.pop();\n      assert state.score > 0.0;\n      IndexedWord currentWord = topologicalVertices.get(state.currentIndex);\n\n      \/\/ Push the case where we don't delete\n      int nextIndex = state.currentIndex + 1;\n      while (nextIndex < topologicalVertices.size()) {\n        IndexedWord nextWord = topologicalVertices.get(nextIndex);\n        if (  ((state.deletionMask >>> (indexToMaskIndex[nextWord.index() - 1])) & 0x1l) == 0) {\n          fringe.push(new SearchState(state.deletionMask, nextIndex, state.tree, null, state, state.score));\n          break;\n        } else {\n          nextIndex += 1;\n        }\n      }\n\n      \/\/ Check if we can delete this subtree\n      boolean canDelete = !state.tree.getFirstRoot().equals(currentWord);\n      for (SemanticGraphEdge edge : state.tree.incomingEdgeIterable(currentWord)) {\n        if (\"CD\".equals(edge.getGovernor().tag())) {\n          canDelete = false;\n        } else {\n          \/\/ Get token information\n          CoreLabel token = edge.getDependent().backingLabel();\n          OperatorSpec operator;\n          NaturalLogicRelation lexicalRelation;\n          Polarity tokenPolarity = token.get(NaturalLogicAnnotations.PolarityAnnotation.class);\n          if (tokenPolarity == null) {\n            tokenPolarity = Polarity.DEFAULT;\n          }\n          \/\/ Get the relation for this deletion\n          if ((operator = token.get(NaturalLogicAnnotations.OperatorAnnotation.class)) != null) {\n            lexicalRelation = operator.instance.deleteRelation;\n          } else {\n            lexicalRelation = NaturalLogicRelation.forDependencyDeletion(edge.getRelation().toString(),\n                isSubject[edge.getDependent().index() - 1]);\n          }\n          NaturalLogicRelation projectedRelation = tokenPolarity.projectLexicalRelation(lexicalRelation);\n          \/\/ Make sure this is a valid entailment\n          if (!projectedRelation.applyToTruthValue(truthOfPremise).isTrue()) {\n            canDelete = false;\n          }\n        }\n      }\n\n      if (canDelete) {\n        \/\/ Register the deletion\n        Lazy<Pair<SemanticGraph,Long>> treeWithDeletionsAndNewMask = Lazy.of(() -> {\n          SemanticGraph impl = new SemanticGraph(state.tree);\n          long newMask = state.deletionMask;\n          for (IndexedWord vertex : state.tree.descendants(currentWord)) {\n            impl.removeVertex(vertex);\n            newMask |= (0x1l << (indexToMaskIndex[vertex.index() - 1]));\n            assert indexToMaskIndex[vertex.index() - 1] < 64;\n            assert ((newMask >>> (indexToMaskIndex[vertex.index() - 1])) & 0x1l) == 1;\n          }\n          return Pair.makePair(impl, newMask);\n        });\n        \/\/ Compute the score of the sentence\n        double newScore = state.score;\n        for (SemanticGraphEdge edge : state.tree.incomingEdgeIterable(currentWord)) {\n          double multiplier = weights.deletionProbability(edge, state.tree.outgoingEdgeIterable(edge.getGovernor()));\n          assert !Double.isNaN(multiplier);\n          assert !Double.isInfinite(multiplier);\n          newScore *= multiplier;\n        }\n        \/\/ Register the result\n        if (newScore > 0.0) {\n          SemanticGraph resultTree = new SemanticGraph(treeWithDeletionsAndNewMask.get().first);\n          andsToAdd.stream().filter(edge -> resultTree.containsVertex(edge.getGovernor()) && resultTree.containsVertex(edge.getDependent()))\n              .forEach(edge -> resultTree.addEdge(edge.getGovernor(), edge.getDependent(), edge.getRelation(), Double.NEGATIVE_INFINITY, false));\n          results.add(new SearchResult(resultTree,\n              aggregateDeletedEdges(state, state.tree.incomingEdgeIterable(currentWord), determinerRemovals),\n              newScore));\n\n          \/\/ Push the state with this subtree deleted\n          nextIndex = state.currentIndex + 1;\n          while (nextIndex < topologicalVertices.size()) {\n            IndexedWord nextWord = topologicalVertices.get(nextIndex);\n            long newMask = treeWithDeletionsAndNewMask.get().second;\n            SemanticGraph treeWithDeletions = treeWithDeletionsAndNewMask.get().first;\n            if (  ((newMask >>> (indexToMaskIndex[nextWord.index() - 1])) & 0x1l) == 0) {\n              assert treeWithDeletions.containsVertex(topologicalVertices.get(nextIndex));\n              fringe.push(new SearchState(newMask, nextIndex, treeWithDeletions, null, state, newScore));\n              break;\n            } else {\n              nextIndex += 1;\n            }\n          }\n        }\n      }\n    }\n\n    \/\/ Return\n    return results;\n  }\n","new_comment_raw":"@return A list of search results, corresponding to shortenings of the sentence.","old_comment_raw":"@return A list of search results, corresponding to shortenings of the sentence.","label":0,"pre_label":1,"AST_level":18,"line_counts":215,"new_code_token_num":1586},{"new_code_raw":"public ProcessingInstruction createProcessingInstruction(String target, String data) throws DOMException { if (STR.equals(target)) { return new SVGStyleSheetProcessingInstruction(data, this, (StyleSheetFactory) getImplementation()); } return new GenericProcessingInstruction(target, data, this); }","old_code_raw":"public ProcessingInstruction createProcessingInstruction(String target, String data) throws DOMException {\n    if (STR.equals(target)) {\n        return new StyleSheetProcessingInstruction(data, this, (StyleSheetFactory) getImplementation());\n    }\n    return new GenericProcessingInstruction(target, data, this);\n}","new_comment_raw":"@return a SVGStyleSheetProcessingInstruction if target is \"xml-stylesheet\" or a GenericProcessingInstruction otherwise.","old_comment_raw":"@return a StyleSheetProcessingInstruction if target is \"xml-stylesheet\" or a GenericProcessingInstruction otherwise.","label":1,"pre_label":0,"AST_level":8,"line_counts":6,"new_code_token_num":51},{"new_code_raw":"@SuppressWarnings(STR) public ObjectName getExchangeObjectName(String virtualHostName, String exchange) { AllObjects allObject = new AllObjects(_mbsc); allObject.querystring = STR + virtualHostName + STR + exchange + STR; Set<ObjectName> objectNames = allObject.returnObjects(); _test.assertNotNull(STR, objectNames); _test.assertEquals(STR + exchange + STR, NUM, objectNames.size()); ObjectName objectName = objectNames.iterator().next(); _test.getLogger().info(STR + objectName); return objectName; }","old_code_raw":"public ObjectName getExchangeObjectName(String virtualHostName, String exchange) {\n    AllObjects allObject = new AllObjects(_mbsc);\n    allObject.querystring = STR + virtualHostName + STR + exchange + STR;\n    Set<ObjectName> objectNames = allObject.returnObjects();\n    _test.assertNotNull(STR, objectNames);\n    _test.assertEquals(STR + exchange + STR, NUM, objectNames.size());\n    return objectNames.iterator().next();\n}","new_comment_raw":"@return the ObjectName for the given Exchange on the VirtualHost","old_comment_raw":"@return the ObjectName for the given exchange on the test VirtualHost.","label":1,"pre_label":0,"AST_level":9,"line_counts":11,"new_code_token_num":94},{"new_code_raw":"public static boolean checkAlreadyExist(AccountDatabase.AccountName s) { Realm realm = Realm.getDefaultInstance(); \/\/ Query in the realm database RealmQuery<AccountDatabase> query = realm.where(AccountDatabase.class); \/\/ Checking if string equals to is exist or not query.equalTo(\"name\", s.toString()); RealmResults<AccountDatabase> result1 = query.findAll(); \/\/ Here checking if count of that values is greater than zero return (result1.size() > 0); }","old_code_raw":"    public static boolean checkAlreadyExist(AccountDatabase.AccountName s) {\n        Realm realm = Realm.getDefaultInstance();\n        \/\/ Query in the realm database\n        RealmQuery<AccountDatabase> query = realm.where(AccountDatabase.class);\n\n        \/\/ Checking if string equals to is exist or not\n        query.equalTo(\"name\", s.toString());\n        RealmResults<AccountDatabase> result1 = query.findAll();\n\n        \/\/ Here checking if count of that values is greater than zero\n        return (result1.size() > 0) ? true : false;\n    }\n","new_comment_raw":"@return true is existed, false otherwise","old_comment_raw":"@return true is existed, false otherwise","label":0,"pre_label":1,"AST_level":7,"line_counts":13,"new_code_token_num":89},{"new_code_raw":"public List<ArrayList<TaggedWord>> process(List<? extends List<? extends HasWord>> sentences) { List<ArrayList<TaggedWord>> taggedSentences = new ArrayList<ArrayList<TaggedWord>>(); TestSentence testSentence = new TestSentence(this); for (List<? extends HasWord> sentence : sentences) { taggedSentences.add(testSentence.tagSentence(sentence, false)); } return taggedSentences; }","old_code_raw":"  public List<List<TaggedWord>> process(List<? extends List<? extends HasWord>> sentences) {\n    List<List<TaggedWord>> taggedSentences = Generics.newArrayList();\n\n    TestSentence testSentence = new TestSentence(this);\n    for (List<? extends HasWord> sentence : sentences) {\n      taggedSentences.add(testSentence.tagSentence(sentence, false));\n    }\n    return taggedSentences;\n  }\n","new_comment_raw":"@return A List of Sentence of TaggedWord (final generification cannot be listed due to lack of complete generification of super classes)","old_comment_raw":"@return A List of Sentence of TaggedWord","label":1,"pre_label":0,"AST_level":10,"line_counts":10,"new_code_token_num":63},{"new_code_raw":"public static CacheDataDescriptionImpl decode(Collection model) { return new CacheDataDescriptionImpl( model.isMutable(), model.getOwner().isVersioned(), model.getOwner().isVersioned() ? ( (VersionType) model.getOwner().getVersion().getType() ).getComparator() : null, model.getKey().getType()); }","old_code_raw":"\tpublic static CacheDataDescriptionImpl decode(Collection model) {\n\t\treturn new CacheDataDescriptionImpl(\n\t\t\t\tmodel.isMutable(),\n\t\t\t\tmodel.getOwner().isVersioned(),\n\t\t\t\tmodel.getOwner().isVersioned()\n\t\t\t\t\t\t? ( (VersionType) model.getOwner().getVersion().getType() ).getComparator()\n\t\t\t\t\t\t: null\n\t\t);\n\t}\n","new_comment_raw":"@return The constructed CacheDataDescriptionImpl","old_comment_raw":"@return The constructed CacheDataDescriptionImpl","label":0,"pre_label":1,"AST_level":8,"line_counts":10,"new_code_token_num":65},{"new_code_raw":"public FeatureService createFeatureService() { return createFeatureService(defaultEndpointUrl); }","old_code_raw":"public FeatureService createFeatureService() {\n    return createFeatureService(defaultServerUrl);\n}","new_comment_raw":"@return a new feature service with the default endpoint URL","old_comment_raw":"@return a new feature service with the default server URL","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":13},{"new_code_raw":"static ColTypeInfo of(MessageType schema, Type type, String[] path, int depth, List<OriginalType> parentTypes) { if (type.isPrimitive()) { return createColTypeInfo(type.asPrimitiveType(), schema, path, parentTypes); } Type t = ((GroupType) type).getType(path[depth]); if (!t.isPrimitive()) { OriginalType originalType = t.getOriginalType(); if (originalType == OriginalType.MAP && !ParquetReaderUtility.isLogicalMapType(t.asGroupType())) { originalType = null; } else if (originalType == OriginalType.LIST && !ParquetReaderUtility.isLogicalListType(t.asGroupType())) { originalType = null; } parentTypes.add(originalType); } return of(schema, t, path, depth + 1, parentTypes); }","old_code_raw":"    static ColTypeInfo of(MessageType schema, Type type, String[] path, int depth, List<OriginalType> parentTypes) {\n      if (type.isPrimitive()) {\n        PrimitiveType primitiveType = (PrimitiveType) type;\n        int precision = 0;\n        int scale = 0;\n        if (primitiveType.getDecimalMetadata() != null) {\n          precision = primitiveType.getDecimalMetadata().getPrecision();\n          scale = primitiveType.getDecimalMetadata().getScale();\n        }\n\n        int repetitionLevel = schema.getMaxRepetitionLevel(path);\n        int definitionLevel = schema.getMaxDefinitionLevel(path);\n\n        return new ColTypeInfo(type.getOriginalType(), parentTypes, precision, scale, repetitionLevel, definitionLevel);\n      }\n      Type t = ((GroupType) type).getType(path[depth]);\n      if (!t.isPrimitive()) {\n        OriginalType originalType = t.getOriginalType();\n        if (originalType == OriginalType.MAP && !ParquetReaderUtility.isLogicalMapType(t.asGroupType())) {\n          originalType = null;\n        }\n        parentTypes.add(originalType);\n      }\n      return of(schema, t, path, depth + 1, parentTypes);\n    }\n","new_comment_raw":"@return host affinity for the row group","old_comment_raw":"@return host affinity for the row group","label":0,"pre_label":1,"AST_level":10,"line_counts":18,"new_code_token_num":148},{"new_code_raw":"public static ActiveMQConnectionFactory createConnectionFactoryWithoutHA(JMSFactoryType jmsFactoryType, final TransportConfiguration... transportConfigurations) { ActiveMQConnectionFactory factory = null; if (jmsFactoryType.equals(JMSFactoryType.CF)) { factory = new ActiveMQJMSConnectionFactory(false, transportConfigurations); } else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_CF)) { factory = new ActiveMQQueueConnectionFactory(false, transportConfigurations); } else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_CF)) { factory = new ActiveMQTopicConnectionFactory(false, transportConfigurations); } else if (jmsFactoryType.equals(JMSFactoryType.XA_CF)) { factory = new ActiveMQXAConnectionFactory(false, transportConfigurations); } else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_XA_CF)) { factory = new ActiveMQXAQueueConnectionFactory(false, transportConfigurations); } else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_XA_CF)) { factory = new ActiveMQXATopicConnectionFactory(false, transportConfigurations); } return factory; }","old_code_raw":"public static HornetQConnectionFactory createConnectionFactoryWithoutHA(JMSFactoryType jmsFactoryType, final TransportConfiguration... transportConfigurations) {\n    HornetQConnectionFactory factory = null;\n    if (jmsFactoryType.equals(JMSFactoryType.CF)) {\n        factory = new HornetQJMSConnectionFactory(false, transportConfigurations);\n    } else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_CF)) {\n        factory = new HornetQQueueConnectionFactory(false, transportConfigurations);\n    } else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_CF)) {\n        factory = new HornetQTopicConnectionFactory(false, transportConfigurations);\n    } else if (jmsFactoryType.equals(JMSFactoryType.XA_CF)) {\n        factory = new HornetQXAConnectionFactory(false, transportConfigurations);\n    } else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_XA_CF)) {\n        factory = new HornetQXAQueueConnectionFactory(false, transportConfigurations);\n    } else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_XA_CF)) {\n        factory = new HornetQXATopicConnectionFactory(false, transportConfigurations);\n    }\n    return factory;\n}","new_comment_raw":"@return the ActiveMQConnectionFactory","old_comment_raw":"@return the HornetQConnectionFactory","label":1,"pre_label":0,"AST_level":13,"line_counts":17,"new_code_token_num":146},{"new_code_raw":"public ExtensionHandler getExtensionHandler() { return generatorContext.getExtensionHandler(); }","old_code_raw":"public ExtensionHandler getExtensionHandler() {\n    return extensionHandler;\n}","new_comment_raw":"@return the extension handler used by the DOMTreeManager.","old_comment_raw":"@return the extension handler used by this SVGGraphics2D instance","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":13},{"new_code_raw":"public static ExpectedCondition<Boolean> titleContains(final String title) { return new ExpectedCondition<Boolean>() { private String currentTitle = \"\"; public Boolean apply(WebDriver driver) { currentTitle = driver.getTitle(); return currentTitle != null && currentTitle.contains(title); } @Override public String toString() { return String.format(\"title to contain \\\"%s\\\". Current title: \\\"%s\\\"\", title, currentTitle); } }; }","old_code_raw":"  public static ExpectedCondition<Boolean> titleContains(final String title) {\n    return new ExpectedCondition<Boolean>() {\n      public Boolean apply(WebDriver driver) {\n        String currentTitle = driver.getTitle();\n        return currentTitle == null ? false : currentTitle.contains(title);\n      }\n\n      @Override\n      public String toString() {\n        return \"title to contain \" + title;\n      }\n    };\n  }\n","new_comment_raw":"@return true when the title matches, false otherwise","old_comment_raw":"@return true when the title matches, false otherwise","label":0,"pre_label":1,"AST_level":9,"line_counts":16,"new_code_token_num":93},{"new_code_raw":"public CacheStatisticsImpl createCacheStatIfAbsent(String name) { CacheStatisticsImpl statistics = new CacheStatisticsImpl(); CacheStatisticsImpl temp = this.statistics.putIfAbsent(name, statistics); if (temp != null) { statistics = temp; } return statistics; }","old_code_raw":"public CacheStatisticsImpl createCacheStatIfAbsent(String name) {\n    if (!statistics.containsKey(name)) {\n        statistics.putIfAbsent(name, new CacheStatisticsImpl());\n    }\n    return statistics.get(name);\n}","new_comment_raw":"@return {@link CacheStatisticsImpl} or an empty statistics if not enabled.","old_comment_raw":"@return {@link CacheStatisticsImpl}.","label":1,"pre_label":0,"AST_level":7,"line_counts":8,"new_code_token_num":41},{"new_code_raw":"public Object next() throws java.io.IOException { int zzInput; int zzAction; \/\/ cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { \/\/ store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); \/\/ get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } \/\/ store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 6: { return getEllipsis(); } case 8: break; case 4: { return getNext(false); } case 9: break; case 7: { if ( ! removeProMarker) { return getNext(false); } } case 10: break; case 2: { return getNewline(); } case 11: break; case 5: { return getNext(true); } case 12: break; case 3: { } case 13: break; case 1: { System.err.printf(\"Untokenizable: %s%n\", yytext()); return getNext(true); } case 14: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }","old_code_raw":"  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    \/\/ cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      \/\/ set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            \/\/ store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            \/\/ get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      \/\/ store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { System.err.printf(\"Untokenizable: %s%n\", yytext());\n\t      return getNext(true);\n          }\n        case 9: break;\n        case 2: \n          { if (tokenizeNLs) {\n                return getNext(NEWLINE_TOKEN, yytext());\n              }\n          }\n        case 10: break;\n        case 3: \n          { \n          }\n        case 11: break;\n        case 4: \n          { return getNext(false);\n          }\n        case 12: break;\n        case 5: \n          { return getNext(true);\n          }\n        case 13: break;\n        case 6: \n          { return getEllipsis();\n          }\n        case 14: break;\n        case 7: \n          { if (! removeProMarker) return getNext(false);\n          }\n        case 15: break;\n        case 8: \n          { if (removeProMarker) {\n                if ( ! removeSegMarker) {\n                  return getNext(\"-\", yytext());\n                }\n              } else {\n                return getNext(false);\n              }\n          }\n        case 16: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                return null;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n","new_comment_raw":"@return the next token","old_comment_raw":"@return the next token","label":0,"pre_label":1,"AST_level":17,"line_counts":115,"new_code_token_num":431},{"new_code_raw":"@Override public Optional<TYPE> first() { Iterator<TYPE> resultIterator = first(NUM).iterator(); return resultIterator.hasNext() ? Optional.of(resultIterator.next()) : Optional.empty(); }","old_code_raw":"@Override\npublic Optional<TYPE> first() {\n    Optional result = Optional.empty();\n    List<TYPE> list = first(NUM).asList();\n    if (!list.isEmpty()) {\n        result = Optional.of(list.get(NUM));\n    }\n    return result;\n}","new_comment_raw":"@return an Optional containing the first object of this Iterable","old_comment_raw":"@return an option of the first object of the iteration","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":41},{"new_code_raw":"public Object getProperty(String name) { if (name == null || !isPropertySupported(name)) throw new IllegalArgumentException(); return callProperties.get(name); }","old_code_raw":"public Object getProperty(String name) {\n    if (name != null)\n        return callProperties.get(name);\n    return null;\n}","new_comment_raw":"@return Object value of the property or null if the property is not set","old_comment_raw":"@return Object value of the property - or null","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":34},{"new_code_raw":"public int decodable(QpidByteBuffer in) { return (in.remaining() >= NUM) ? NUM : NUM - in.remaining(); }","old_code_raw":"public boolean decodable(MarkableDataInput in) throws IOException {\n    return (in.available() >= NUM);\n}","new_comment_raw":"@return number of extra octets of data required data to decode the PI frame fully","old_comment_raw":"@return true if we have enough data to decode the PI frame fully, false if more data is required","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":27},{"new_code_raw":"public AtmosphereRequest getRequest() { return atmosphereRequest; }","old_code_raw":"public HttpServletRequest getRequest() {\n    return atmosphereRequest;\n}","new_comment_raw":"@return the associated {@link AtmosphereRequest}","old_comment_raw":"@return the associated {@link HttpServletRequest}","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":10},{"new_code_raw":"public Map<String, String> getAdditionalHttpHeaders() { return additionalHttpHeaders == null ? null : Collections.unmodifiableMap(additionalHttpHeaders); }","old_code_raw":"public Map<String, String> getAdditionalHttpHeaders() {\n    return Collections.unmodifiableMap(additionalHttpHeaders);\n}","new_comment_raw":"@return A read-only view of the additionalHttpHeaders, or null if none are set.","old_comment_raw":"@return A read-only view of the additionalHttpHeaders.","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":22},{"new_code_raw":"public HBaseResponse getHTableInfo(String tableName) throws IOException { HBaseResponse hr = htableInfoCache.getIfPresent(tableName); if (null != hr) { return hr; } hr = new HBaseResponse(); if (\"hbase\".equals(getConfig().getMetadataUrl().getScheme())) { try { \/\/ use reflection to isolate NoClassDef errors when HBase is not available hr = (HBaseResponse) Class.forName(\"org.apache.kylin.rest.service.HBaseInfoUtil\")\/\/ .getMethod(\"getHBaseInfo\", new Class[] { String.class, KylinConfig.class })\/\/ .invoke(null, tableName, this.getConfig()); } catch (Throwable e) { throw new IOException(e); } } htableInfoCache.put(tableName, hr); return hr; }","old_code_raw":"    public HBaseResponse getHTableInfo(String tableName) throws IOException, ExecutionException {\n        return htableInfoCache.get(tableName);\n    }\n","new_comment_raw":"@return The HBaseResponse object contains table size, region count. null if error happens","old_comment_raw":"@return The HBaseResponse object contains table size, region count. null if error happens","label":0,"pre_label":1,"AST_level":14,"line_counts":22,"new_code_token_num":147},{"new_code_raw":"@Override public AsyncAppenderBase<IAccessEvent> build() { return new AsyncAppenderBase<IAccessEvent>() { @Override protected void preprocess(IAccessEvent event) { event.prepareForDeferredProcessing(); } }; }","old_code_raw":"@Override\npublic AsyncAppenderBase<IAccessEvent> build() {\n    return new AsyncAppenderBase<IAccessEvent>();\n}","new_comment_raw":"@return the {@link AsyncAppenderFactory}","old_comment_raw":"@return the {@link AsyncAppenderBase}","label":1,"pre_label":0,"AST_level":7,"line_counts":10,"new_code_token_num":35},{"new_code_raw":"public int getPosition() { return currentPosition; }","old_code_raw":"public int getPosition() {\n    return this.currentPosition;\n}","new_comment_raw":"@return position relative to home.","old_comment_raw":"@return Value between 1 and 16,777,215","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":10},{"new_code_raw":"public static DateTimeExpression<Date> currentDate() { return Constants.CURRENT_DATE; }","old_code_raw":"    public static DateTimeExpression<Date> currentDate() {\n        return CURRENT_DATE;\n    }\n","new_comment_raw":"@return current date","old_comment_raw":"@return current date","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":13},{"new_code_raw":"@Override public int hashCode() { int hash = NUM; hash = hash * NUM + Double.valueOf(getRank()).hashCode(); hash = hash * NUM + mUrlDevice.hashCode(); hash = hash * NUM + mPwsResult.hashCode(); return hash; }","old_code_raw":"public int hashCode() {\n    assert false : STR;\n    return NUM;\n}","new_comment_raw":"@return hash code","old_comment_raw":"@return 42.","label":1,"pre_label":0,"AST_level":7,"line_counts":8,"new_code_token_num":52},{"new_code_raw":"public DurationField days() { return UnsupportedDurationField.getInstance(\"days\"); }","old_code_raw":"    public DurationField days() {\n        return UnsupportedDurationField.INSTANCE;\n    }\n","new_comment_raw":"@return DurationField or UnsupportedDurationField if unsupported","old_comment_raw":"@return DurationField or UnsupportedDurationField if unsupported","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":16},{"new_code_raw":"public Debugger getDebugger() { return debugger; }","old_code_raw":"    public Debugger getDebugger() {\n        return dbg;\n    }\n","new_comment_raw":"@return the debugger controller object","old_comment_raw":"@return the debugger controller object","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"private ServiceReference[] getInitialReferences(boolean trackAllServices, String className, String filterString) throws InvalidSyntaxException { if (trackAllServices) { return context.getAllServiceReferences(className, filterString); } return context.getServiceReferences(className, filterString); }","old_code_raw":"private ServiceReference[] getInitialReferences(boolean trackAllServices, String trackClass, String filterString) throws InvalidSyntaxException {\n    if (trackAllServices) {\n        return context.getAllServiceReferences(trackClass, filterString);\n    } else {\n        return context.getServiceReferences(trackClass, filterString);\n    }\n}","new_comment_raw":"@return The list of initial <code>ServiceReference<\/code>s.","old_comment_raw":"@return the list of initial <code>ServiceReference<\/code> objects.","label":1,"pre_label":0,"AST_level":7,"line_counts":6,"new_code_token_num":43},{"new_code_raw":"public LockMode getAliasSpecificLockMode(String alias) { if ( aliasSpecificLockModes == null ) { return null; } return (LockMode) aliasSpecificLockModes.get( alias ); }","old_code_raw":"\tpublic LockMode getAliasSpecificLockMode(String alias) {\n\t\treturn (LockMode) aliasSpecificLockModes.get( alias );\n\t}\n","new_comment_raw":"@return The explicit lock mode for that alias.","old_comment_raw":"@return The explicit lock mode for that alias.","label":0,"pre_label":1,"AST_level":6,"line_counts":7,"new_code_token_num":29},{"new_code_raw":"public String getMatches() { StringBuilder sb = new StringBuilder(); for (int i = NUM, sz = list.getModel().getSize(); i < sz; i++) { Tree t = ((TreeFromFile) list.getModel().getElementAt(i)).getTree(); sb.append(t.pennString()); sb.append(STR); } return sb.toString(); }","old_code_raw":"public StringBuffer getMatches() {\n    StringBuffer sb = new StringBuffer();\n    for (int i = NUM; i < list.getModel().getSize(); i++) {\n        Tree t = ((TreeFromFile) list.getModel().getElementAt(i)).getTree();\n        sb.append(t.pennString());\n        sb.append(STR);\n    }\n    return sb;\n}","new_comment_raw":"@return String filled with the Penn treebank forms of all trees in the matches panel","old_comment_raw":"@return StringBuffer filled with the penn treebank forms of all trees in the matches panel","label":1,"pre_label":0,"AST_level":10,"line_counts":9,"new_code_token_num":78},{"new_code_raw":"private PartitionTemplate assembleSar(final String name, final Configuration config, final Configuration assembly) throws LoomException { final Configuration[] blockConfig = assembly.getChildren(STR); final ComponentTemplate[] blocks = buildBlocks(blockConfig, config); final PartitionTemplate blockPartition = new PartitionTemplate(ContainerConstants.BLOCK_PARTITION, new String[] { ContainerConstants.LISTENER_PARTITION }, PartitionTemplate.EMPTY_SET, blocks); final Configuration[] listenerConfig = assembly.getChildren(STR); final ComponentTemplate[] listeners = buildBlockListeners(listenerConfig, config); final PartitionTemplate listenerPartition = new PartitionTemplate(ContainerConstants.LISTENER_PARTITION, new String[NUM], PartitionTemplate.EMPTY_SET, listeners); final PartitionTemplate[] partitions = new PartitionTemplate[] { blockPartition, listenerPartition }; return new PartitionTemplate(name, new String[NUM], partitions, ComponentTemplate.EMPTY_SET); }","old_code_raw":"private PartitionMetaData assembleSar(final String name, final Configuration config, final Configuration assembly) throws LoomException {\n    final Configuration[] blockConfig = assembly.getChildren(STR);\n    final ComponentMetaData[] blocks = buildBlocks(blockConfig, config);\n    final PartitionMetaData blockPartition = new PartitionMetaData(ContainerConstants.BLOCK_PARTITION, new String[] { ContainerConstants.LISTENER_PARTITION }, PartitionMetaData.EMPTY_SET, blocks);\n    final Configuration[] listenerConfig = assembly.getChildren(STR);\n    final ComponentMetaData[] listeners = buildBlockListeners(listenerConfig, config);\n    final PartitionMetaData listenerPartition = new PartitionMetaData(ContainerConstants.LISTENER_PARTITION, new String[NUM], PartitionMetaData.EMPTY_SET, listeners);\n    final PartitionMetaData[] partitions = new PartitionMetaData[] { blockPartition, listenerPartition };\n    return new PartitionMetaData(name, new String[NUM], partitions, ComponentMetaData.EMPTY_SET);\n}","new_comment_raw":"@return the new PartitionTemplate","old_comment_raw":"@return the new PartitionMetaData","label":1,"pre_label":0,"AST_level":8,"line_counts":10,"new_code_token_num":144},{"new_code_raw":"public Short getShort(AttributeMetadata attributeMetadata) { return (short)getInteger(Short.MAX_VALUE); }","old_code_raw":"\tpublic Short getShort(AttributeMetadata attributeMetadata) {\n\n\t\tshort retValue;\n\t\tdo {\n\t\t\tretValue = (short) RANDOM.nextInt(Byte.MAX_VALUE);\n\t\t} while (retValue == 0);\n\t\treturn retValue;\n\t}\n","new_comment_raw":"@return A short\/Short value.","old_comment_raw":"@return A short\/Short value.","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":19},{"new_code_raw":"public ObjectMapper build(JsonFactory factory) { return configure(new ObjectMapper(factory)); }","old_code_raw":"    public ObjectMapper build(JsonFactory factory) {\n        final ObjectMapper mapper = new ObjectMapper(factory);\n\n        for (Module module : modules) {\n            mapper.registerModule(module);\n        }\n\n        for (Map.Entry<MapperFeature, Boolean> entry : mapperFeatures.entrySet()) {\n            mapper.configure(entry.getKey(), entry.getValue());\n        }\n\n        for (Map.Entry<DeserializationFeature, Boolean> entry : deserializationFeatures.entrySet()) {\n            mapper.configure(entry.getKey(), entry.getValue());\n        }\n\n        for (Map.Entry<SerializationFeature, Boolean> entry : serializationFeatures.entrySet()) {\n            mapper.configure(entry.getKey(), entry.getValue());\n        }\n\n        for (Map.Entry<JsonGenerator.Feature, Boolean> entry : generatorFeatures.entrySet()) {\n            mapper.getFactory().configure(entry.getKey(), entry.getValue());\n        }\n\n        for (Map.Entry<JsonParser.Feature, Boolean> entry : parserFeatures.entrySet()) {\n            mapper.getFactory().configure(entry.getKey(), entry.getValue());\n        }\n\n        for (Map.Entry<JsonFactory.Feature, Boolean> entry : factoryFeatures.entrySet()) {\n            mapper.getFactory().configure(entry.getKey(), entry.getValue());\n        }\n\n        if (annotationIntrospector != null) {\n            mapper.setAnnotationIntrospector(annotationIntrospector);\n        }\n\n        if (dateFormat != null) {\n            mapper.setDateFormat(dateFormat);\n        }\n\n        if (defaultTyping != null) {\n            mapper.setDefaultTyping(defaultTyping);\n        }\n\n        if (filters != null) {\n            mapper.setFilters(filters);\n        }\n\n        if (handlerInstantiator != null) {\n            mapper.setHandlerInstantiator(handlerInstantiator);\n        }\n\n        if (injectableValues != null) {\n            mapper.setInjectableValues(injectableValues);\n        }\n\n        if (locale != null) {\n            mapper.setLocale(locale);\n        }\n\n        if (mixinAnnotations != null) {\n            mapper.setMixInAnnotations(mixinAnnotations);\n        }\n\n        if (nodeFactory != null) {\n            mapper.setNodeFactory(nodeFactory);\n        }\n\n        if (propertyNamingStrategy != null) {\n            mapper.setPropertyNamingStrategy(propertyNamingStrategy);\n        }\n\n        if (serializationInclusion != null) {\n            mapper.setSerializationInclusion(serializationInclusion);\n        }\n\n        if (serializerFactory != null) {\n            mapper.setSerializerFactory(serializerFactory);\n        }\n\n        if (serializerProvider != null) {\n            mapper.setSerializerProvider(serializerProvider);\n        }\n\n        if (subtypeResolver != null) {\n            mapper.setSubtypeResolver(subtypeResolver);\n        }\n\n        if (timeZone != null) {\n            mapper.setTimeZone(timeZone);\n        }\n\n        if (typeFactory != null) {\n            mapper.setTypeFactory(typeFactory);\n        }\n\n        for (Map.Entry<PropertyAccessor, JsonAutoDetect.Visibility> rule : visibilityRules.entrySet()) {\n            mapper.setVisibility(rule.getKey(), rule.getValue());\n        }\n\n        if (visibilityChecker != null) {\n            mapper.setVisibilityChecker(visibilityChecker);\n        }\n\n\n        return mapper;\n    }\n","new_comment_raw":"@return a configured  ObjectMapper instance","old_comment_raw":"@return a configured ObjectMapper instance","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":19},{"new_code_raw":"public ArrayList<ListView> getCurrentListViews() { return getCurrentViews(ListView.class); }","old_code_raw":"\tpublic ArrayList<ListView> getCurrentListViews() {\n\t\tArrayList<ListView> listViews = new ArrayList<ListView>();\n\t\tArrayList<View> viewList = getViews();\n\t\tfor(View view : viewList){\n\t\t\tif (view instanceof android.widget.ListView)\n\t\t\t\tlistViews.add((ListView) view);\n\t\t}\n\t\treturn listViews;\n\t}\n","new_comment_raw":"@return a  List of the  ListViews contained in the current  Activity","old_comment_raw":"@return a List of the ListViews contained in the current Activity","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":15},{"new_code_raw":"public Object getBuilders() { synchronized (builderLock) { if (supportsConfigs()) { return builders == null ? null : new HashMap<>(builders); } return builder; } }","old_code_raw":"public Object getBuilders() {\n    synchronized (builderLock) {\n        if (supportsConfigs())\n            return builders;\n        return builder;\n    }\n}","new_comment_raw":"@return A copy of the internal map {@link IBuildConfiguration} -> {@link IncrementalProjectBuilder} if this build command supports multiple configurations. Otherwise return the {@link IncrementalProjectBuilder} associated with this build command.","old_comment_raw":"@return Map {@link IBuildConfiguration} -> {@link IncrementalProjectBuilder} if this build command supports multiple configurations. Otherwise return the {@link IncrementalProjectBuilder} associated with this build command.","label":1,"pre_label":0,"AST_level":9,"line_counts":8,"new_code_token_num":36},{"new_code_raw":"private boolean isZoomed() { return mNormalizedScale != 1; }","old_code_raw":"    private boolean isZoomed() {\n        return normalizedScale != 1;\n    }\n","new_comment_raw":"@return true if image is zoomed","old_comment_raw":"@return true if image is zoomed","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":12},{"new_code_raw":"@ManagedAttribute(description = STR) public long getAggregationCount() { return aggregationCount.longValue(); }","old_code_raw":"public LongAdder getAggregationCount() {\n    return aggregationCount;\n}","new_comment_raw":"@return the total number of aggregation executions","old_comment_raw":"@return the aggregationCount","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":19},{"new_code_raw":"public CustomFuture<RECEIVE> send(SEND messageToSend, ByteBuf... dataBodies) { final CustomMessage customMessage = CustomMessage.newBuilder() .setMessage(ByteString.copyFrom(send.serializeToSend(messageToSend))) .setType(messageTypeId) .build(); final SyncCustomMessageSender b = new SyncCustomMessageSender(customMessage, dataBodies); manager.runCommand(b); DrillRpcFuture<CustomMessage> innerFuture = b.getFuture(); return new CustomFuture<RECEIVE>(receive, innerFuture); }","old_code_raw":"    public CustomFuture<RECEIVE> send(SEND messageToSend, ByteBuf... dataBodies) {\n      final CustomMessage customMessage = CustomMessage.newBuilder()\n          .setMessage(messageToSend.toByteString())\n          .setType(messageTypeId)\n          .build();\n      final SyncCustomMessageSender b = new SyncCustomMessageSender(customMessage, dataBodies);\n      manager.runCommand(b);\n      DrillRpcFuture<CustomMessage> innerFuture = b.getFuture();\n      return new CustomFuture<RECEIVE>(parser, innerFuture);\n    }\n","new_comment_raw":"@return The CustomFuture that can be used to wait for the response.","old_comment_raw":"@return The CustomFuture that can be used to wait for the response.","label":0,"pre_label":1,"AST_level":9,"line_counts":11,"new_code_token_num":75},{"new_code_raw":"public int getId() { if (downloadId != 0) { return downloadId; } if (!TextUtils.isEmpty(path) && !TextUtils.isEmpty(url)) { return downloadId = FileDownloadUtils.generateId(url, path, pathAsDirectory); } return 0; }","old_code_raw":"    public int getId() {\n        if (downloadId != 0) {\n            return downloadId;\n        }\n\n        if (!TextUtils.isEmpty(path) && !TextUtils.isEmpty(url)) {\n            return downloadId = FileDownloadUtils.generateId(url, path);\n        }\n\n        return 0;\n    }\n","new_comment_raw":"@return The identify id for this task.","old_comment_raw":"@return The identify id for this task.","label":0,"pre_label":1,"AST_level":8,"line_counts":12,"new_code_token_num":52},{"new_code_raw":"public String getHandle() { if (consoleProcess_ == null) { return terminalHandle_; } return consoleProcess_.getProcessInfo().getHandle(); }","old_code_raw":"public String getHandle() {\n    if (consoleProcess_ == null) {\n        return terminalHandle_;\n    }\n    return consoleProcess_.getProcessInfo().getTerminalHandle();\n}","new_comment_raw":"@return Opaque string handle for this terminal instance, or null if terminal has never been attached to a server ConsoleProcess.","old_comment_raw":"@return Opaque string handle for this terminal instance, or null if terminal has never been attached to a process","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":26},{"new_code_raw":"public AggregateCall copy(List<Integer> args, int filterArg) { \/\/ ignoring collation is error-prone return copy(args, filterArg, collation); }","old_code_raw":"  public AggregateCall copy(List<Integer> args, int filterArg) {\n    return new AggregateCall(aggFunction, distinct, approximate, args,\n        filterArg, type, name);\n  }\n","new_comment_raw":"@return AggregateCall that suits new inputs and GROUP BY columns","old_comment_raw":"@return AggregateCall that suits new inputs and GROUP BY columns","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":31},{"new_code_raw":"private Object toTypeAnnotation(JmsDestination destination, boolean useByteValue) { if (destination == null) { return null; } if (useByteValue) { if (destination.isQueue()) { if (destination.isTemporary()) { return TEMP_QUEUE_TYPE; } else { return QUEUE_TYPE; } } else if (destination.isTopic()) { if (destination.isTemporary()) { return TEMP_TOPIC_TYPE; } else { return TOPIC_TYPE; } } } else { if (destination.isQueue()) { if (destination.isTemporary()) { return TEMP_QUEUE_ATTRIBUTES_STRING; } else { return QUEUE_ATTRIBUTES_STRING; } } else if (destination.isTopic()) { if (destination.isTemporary()) { return TEMP_TOPIC_ATTRIBUTES_STRING; } else { return TOPIC_ATTRIBUTES_STRING; } } } return null; }","old_code_raw":"private String toTypeAnnotation(JmsDestination destination) {\n    if (destination == null) {\n        return null;\n    }\n    if (destination.isQueue()) {\n        if (destination.isTemporary()) {\n            return TEMP_QUEUE_ATTRIBUTES_STRING;\n        } else {\n            return QUEUE_ATTRIBUTES_STRING;\n        }\n    } else if (destination.isTopic()) {\n        if (destination.isTemporary()) {\n            return TEMP_TOPIC_ATTRIBUTES_STRING;\n        } else {\n            return TOPIC_ATTRIBUTES_STRING;\n        }\n    }\n    return null;\n}","new_comment_raw":"@return the annotation type value, or null if the supplied destination is null or can't be classified","old_comment_raw":"@return the annotation type string, or null if the supplied destination is null or can't be classified","label":1,"pre_label":0,"AST_level":11,"line_counts":35,"new_code_token_num":144},{"new_code_raw":"public ReadWritableInstantFieldProperty dayOfMonth() { return new ReadWritableInstantFieldProperty(this, getChronology().dayOfMonth()); }","old_code_raw":"    public MutableDateTimeFieldProperty dayOfMonth() {\n        return new MutableDateTimeFieldProperty(this, getChronology().dayOfMonth());\n    }\n","new_comment_raw":"@return the day of month property","old_comment_raw":"@return the day of month property","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":21},{"new_code_raw":"public Map<String, Integer> parameters() { HashMap<String, Integer> values = new HashMap<>(); values.put(STR, this.x); values.put(STR, this.y); values.put(STR, this.z); return Collections.unmodifiableMap(values); }","old_code_raw":"public ImmutableMap<String, Integer> parameters() {\n    return ImmutableMap.of(STR, this.x, STR, this.y, STR, this.z);\n}","new_comment_raw":"@return returns all axis mapped to a Map","old_comment_raw":"@return returns all axis mapped to an ImmutableMap","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":54},{"new_code_raw":"public static boolean isNetworkAvailable(NetType netType) { getConnectivityManager(); return isConnected(netType, sConnectivityManager.getActiveNetworkInfo()); }","old_code_raw":"    public static boolean isNetworkAvailable(NetType netType) {\n        getConnectivityManager();\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n            Network[] networkArray = sConnectivityManager.getAllNetworks();\n            for (Network network : networkArray) {\n                NetworkInfo networkInfo = sConnectivityManager.getNetworkInfo(network);\n                if (isConnected(netType, networkInfo)) return true;\n            }\n        } else {\n            NetworkInfo[] networkInfoArray = sConnectivityManager.getAllNetworkInfo();\n            for (NetworkInfo networkInfo : networkInfoArray) {\n                if (isConnected(netType, networkInfo)) return true;\n            }\n        }\n        return false;\n    }\n","new_comment_raw":"@return Connection state return true, otherwise it returns false.","old_comment_raw":"@return Connection state return true, otherwise it returns false.","label":0,"pre_label":1,"AST_level":5,"line_counts":5,"new_code_token_num":25},{"new_code_raw":"public Definition emit(Class cls, String allowedMethods) throws Exception { this.cls = cls; this.allowedMethods = allowedMethods; String name = cls.getName(); name = name.substring(name.lastIndexOf(STR) + NUM); setServiceName(name); return emit(); }","old_code_raw":"public Document emit(Class cls, String allowedMethods) throws Exception {\n    this.cls = cls;\n    this.allowedMethods = allowedMethods;\n    String name = cls.getName();\n    name = name.substring(name.lastIndexOf(STR) + NUM);\n    setServiceName(name);\n    return emit();\n}","new_comment_raw":"@return WSDL <code>Definition<\/code>","old_comment_raw":"@return WSDL <code>Document<\/code>","label":1,"pre_label":0,"AST_level":8,"line_counts":8,"new_code_token_num":52},{"new_code_raw":"private List<Long> getRcsRawContactIdFromPhoneNumber(String phoneNumber) { List<Long> contactsIds = new ArrayList<Long>(); String[] projection = { Data.RAW_CONTACT_ID }; String selection = Data.MIMETYPE + STR + Phone.NUMBER + STR; String[] selectionArgs = { MIMETYPE_NUMBER, phoneNumber }; String sortOrder = Data.RAW_CONTACT_ID; Cursor cur = ctx.getContentResolver().query(Data.CONTENT_URI, projection, selection, selectionArgs, sortOrder); if (cur != null) { while (cur.moveToNext()) { long rcsRawContactId = cur.getLong(cur.getColumnIndex(Data.RAW_CONTACT_ID)); contactsIds.add(rcsRawContactId); } cur.close(); } return contactsIds; }","old_code_raw":"private long getRcsRawContactIdFromPhoneNumber(String phoneNumber) {\n    String[] projection = { Data.RAW_CONTACT_ID };\n    String selection = Data.MIMETYPE + STR + Phone.NUMBER + STR;\n    String[] selectionArgs = { MIMETYPE_NUMBER, phoneNumber };\n    String sortOrder = Data.RAW_CONTACT_ID;\n    Cursor cur = ctx.getContentResolver().query(Data.CONTENT_URI, projection, selection, selectionArgs, sortOrder);\n    if (cur != null) {\n        while (cur.moveToNext()) {\n            long rcsRawContactId = cur.getLong(cur.getColumnIndex(Data.RAW_CONTACT_ID));\n            cur.close();\n            return rcsRawContactId;\n        }\n        cur.close();\n    }\n    return INVALID_ID;\n}","new_comment_raw":"@return list of contactIds, empty list if none was found","old_comment_raw":"@return contactId, if not found INVALID_ID is returned","label":1,"pre_label":0,"AST_level":11,"line_counts":16,"new_code_token_num":119},{"new_code_raw":"public static Function<String, String> osVersion() { return new Function<String, String>() { @Override public String apply(final String description) { OsFamily family = osFamily().apply(description); if (Objects.equal(family, OsFamily.CENTOS)) return parseVersion(description, CENTOS); else if (Objects.equal(family, OsFamily.DEBIAN)) return parseVersion(description, DEBIAN); else if (Objects.equal(family, OsFamily.FEDORA)) return parseVersion(description, FEDORA); else if (Objects.equal(family, OsFamily.RHEL)) return parseVersion(description, RHEL); else if (Objects.equal(family, OsFamily.UBUNTU)) return parseVersion(description, UBUNTU); else if (Objects.equal(family, OsFamily.WINDOWS)) return parseVersion(description, WINDOWS); else if (Objects.equal(family, OsFamily.CLOUD_LINUX)) return parseVersion(description, CLOUD_LINUX); return null; } }; }","old_code_raw":"public static Function<ProductItem, String> osVersion() {\n    return new Function<ProductItem, String>() {\n\n        @Override\n        public String apply(ProductItem productItem) {\n            checkNotNull(productItem, STR);\n            final String description = productItem.getDescription();\n            OsFamily family = osFamily().apply(productItem);\n            if (family.equals(OsFamily.CENTOS))\n                return parseVersion(description, CENTOS);\n            else if (family.equals(OsFamily.DEBIAN))\n                return parseVersion(description, DEBIAN);\n            else if (family.equals(OsFamily.FEDORA))\n                return parseVersion(description, FEDORA);\n            else if (family.equals(OsFamily.RHEL))\n                return parseVersion(description, RHEL);\n            else if (family.equals(OsFamily.UBUNTU))\n                return parseVersion(description, UBUNTU);\n            else if (family.equals(OsFamily.WINDOWS))\n                return parseVersion(description, WINDOWS);\n            else if (family.equals(OsFamily.CLOUD_LINUX))\n                return parseVersion(description, CLOUD_LINUX);\n            else\n                throw new NoSuchElementException(STR + productItem);\n        }\n    };\n}","new_comment_raw":"@return the version or null if the version cannot be determined","old_comment_raw":"@return the version","label":1,"pre_label":0,"AST_level":15,"line_counts":24,"new_code_token_num":186},{"new_code_raw":"public Single<Bitmap> cropAsSingle(final Uri sourceUri) { return Single.fromCallable(new Callable<Bitmap>() { @Override public Bitmap call() throws Exception { if (sourceUri != null) mSourceUri = sourceUri; return cropImage(); } }).doOnSubscribe(new Consumer<Disposable>() { @Override public void accept(@NonNull Disposable disposable) throws Exception { mIsCropping.set(true); } }).doFinally(new Action() { @Override public void run() throws Exception { mIsCropping.set(false); } }); }","old_code_raw":"  public Single<Bitmap> cropAsSingle() {\n    return Single.fromCallable(new Callable<Bitmap>() {\n\n      @Override public Bitmap call() throws Exception {\n        return cropImage();\n      }\n    }).doOnSubscribe(new Consumer<Disposable>() {\n      @Override public void accept(@NonNull Disposable disposable) throws Exception {\n        mIsCropping.set(true);\n      }\n    }).doFinally(new Action() {\n      @Override public void run() throws Exception {\n        mIsCropping.set(false);\n      }\n    });\n  }\n","new_comment_raw":"@return Single of cropping image","old_comment_raw":"@return Single of cropping image","label":0,"pre_label":1,"AST_level":10,"line_counts":18,"new_code_token_num":106},{"new_code_raw":"static public ContentionManager getContentionManager() { return cm; }","old_code_raw":"static public ContentionManager getContentionManager() {\n    ThreadState threadState = BaseTask.getThreadState();\n    return threadState.manager();\n}","new_comment_raw":"@return the contention manager","old_comment_raw":"@return the invoking thread's contention manager","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":11},{"new_code_raw":"protected Object convertNumeric(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return new BigDecimal(0); } BigDecimal decimal = null; if (data instanceof BigDecimal) decimal = (BigDecimal) data; else if (data instanceof Boolean) decimal = new BigDecimal(((Boolean) data).booleanValue() ? 1 : 0); else if (data instanceof Short) decimal = new BigDecimal(((Short) data).intValue()); else if (data instanceof Integer) decimal = new BigDecimal(((Integer) data).intValue()); else if (data instanceof Long) decimal = BigDecimal.valueOf(((Long) data).longValue()); else if (data instanceof Float) decimal = BigDecimal.valueOf(((Float) data).doubleValue()); else if (data instanceof Double) decimal = BigDecimal.valueOf(((Double) data).doubleValue()); else { return handleUnknownData(column, fieldDefn, data); } return decimal; }","old_code_raw":"    protected Object convertNumeric(Column column, Field fieldDefn, Object data) {\n        if (data == null) return null;\n        BigDecimal decimal = null;\n        if (data instanceof BigDecimal)\n            decimal = (BigDecimal) data;\n        else if (data instanceof Boolean)\n            decimal = new BigDecimal(((Boolean) data).booleanValue() ? 1 : 0);\n        else if (data instanceof Short)\n            decimal = new BigDecimal(((Short) data).intValue());\n        else if (data instanceof Integer)\n            decimal = new BigDecimal(((Integer) data).intValue());\n        else if (data instanceof Long)\n            decimal = BigDecimal.valueOf(((Long) data).longValue());\n        else if (data instanceof Float)\n            decimal = BigDecimal.valueOf(((Float) data).doubleValue());\n        else if (data instanceof Double)\n            decimal = BigDecimal.valueOf(((Double) data).doubleValue());\n        else {\n            return handleUnknownData(column, fieldDefn, data);\n        }\n        return decimal;\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made","label":1,"pre_label":0,"AST_level":14,"line_counts":29,"new_code_token_num":223},{"new_code_raw":"public DateTime setCopy(int value) { return iInstant.withMillis(iField.set(iInstant.getMillis(), value)); }","old_code_raw":"        public DateTime setCopy(int value) {\n            DateTime instant = iInstant;\n            return instant.withMillis(iField.set(instant.getMillis(), value));\n        }\n","new_comment_raw":"@return a copy of the DateTime with the field value changed","old_comment_raw":"@return a copy of the DateTime with the field value changed","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":25},{"new_code_raw":"public static HashMap getXmlRpcWorkflow(Workflow w) { HashMap workflow = new HashMap(); workflow.put(STR, w.getId()); workflow.put(STR, w.getName() != null ? w.getName() : STR); workflow.put(STR, getXmlRpcWorkflowTasks(w.getTasks())); workflow.put(STR, getXmlRpcWorkflowConditions(w.getConditions())); return workflow; }","old_code_raw":"public static Hashtable getXmlRpcWorkflow(Workflow w) {\n    Hashtable workflow = new Hashtable();\n    workflow.put(STR, w.getId());\n    workflow.put(STR, w.getName() != null ? w.getName() : STR);\n    workflow.put(STR, getXmlRpcWorkflowTasks(w.getTasks()));\n    workflow.put(STR, getXmlRpcWorkflowConditions(w.getConditions()));\n    return workflow;\n}","new_comment_raw":"@return A {@link HashMap} representation of a {@link Workflow}.","old_comment_raw":"@return A {@link Hashtable} representation of a {@link Workflow}.","label":1,"pre_label":0,"AST_level":7,"line_counts":8,"new_code_token_num":79},{"new_code_raw":"public int getClientY() { if (null != details) { return details.getClientY(); } else { return -NUM; } }","old_code_raw":"public int getClientY() {\n    return details.getClientY();\n}","new_comment_raw":"@return The mouse cursor y position or -1 if unknown","old_comment_raw":"@return The mouse cursor y position","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":28},{"new_code_raw":"public static double min(double... vector) { double min = Double.POSITIVE_INFINITY; for (double x : vector) { if (x < min) { min = x; } } return min; }","old_code_raw":"  public static double min(double[] a) {\n    return a[argmin(a)];\n  }\n","new_comment_raw":"@return The minimum value in an array.","old_comment_raw":"@return The minimum value in an array.","label":0,"pre_label":1,"AST_level":9,"line_counts":10,"new_code_token_num":37},{"new_code_raw":"public String[] checkAllWords(String words) { List<String> misspelledWords = new ArrayList<String>(); StringWordTokenizer tokenizer = new StringWordTokenizer(words); while (tokenizer.hasMoreWords()) { String word = tokenizer.nextWord(); if (!isWordCorrect(word, tokenizer.isNewSentence())) { misspelledWords.add(word); } } return misspelledWords.toArray(new String[NUM]); }","old_code_raw":"public String[] checkAllWords(String words) {\n    List<String> misspeltWords = new ArrayList<String>();\n    StringWordTokenizer tokenizer = new StringWordTokenizer(words);\n    while (tokenizer.hasMoreWords()) {\n        String word = tokenizer.nextWord();\n        if (!isWordCorrect(word, tokenizer.isNewSentence())) {\n            misspeltWords.add(word);\n        }\n    }\n    return misspeltWords.toArray(new String[NUM]);\n}","new_comment_raw":"@return string array of misspelled words","old_comment_raw":"@return string array of misspelt words","label":1,"pre_label":0,"AST_level":9,"line_counts":11,"new_code_token_num":76},{"new_code_raw":"public Receiver getReceiver() { return UnmodifiableProxy.receiverProxy(getEndpoint()); }","old_code_raw":"    public Receiver getReceiver() {\n        return new UnmodifiableReceiver(getEndpoint());\n    }\n","new_comment_raw":"@return an unmodifiable view of the underlying Receiver instance.","old_comment_raw":"@return an unmodifiable view of the underlying Receiver instance.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":16},{"new_code_raw":"public static UserAdapter createUserSpinnerAdapter(UserManager userManager, Context context) { List<UserHandle> userProfiles = userManager.getUserProfiles(); if (userProfiles.size() < NUM) { return null; } UserHandle myUserHandle = new UserHandle(UserHandle.myUserId()); userProfiles.remove(myUserHandle); userProfiles.add(NUM, myUserHandle); return createUserAdapter(userManager, context, userProfiles); }","old_code_raw":"public static UserSpinnerAdapter createUserSpinnerAdapter(UserManager userManager, Context context) {\n    List<UserHandle> userProfiles = userManager.getUserProfiles();\n    if (userProfiles.size() < NUM) {\n        return null;\n    }\n    UserHandle myUserHandle = new UserHandle(UserHandle.myUserId());\n    userProfiles.remove(myUserHandle);\n    userProfiles.add(NUM, myUserHandle);\n    ArrayList<UserDetails> userDetails = new ArrayList<UserDetails>(userProfiles.size());\n    final int count = userProfiles.size();\n    for (int i = NUM; i < count; i++) {\n        userDetails.add(new UserDetails(userProfiles.get(i), userManager, context));\n    }\n    return new UserSpinnerAdapter(context, userDetails);\n}","new_comment_raw":"@return a {@link UserAdapter} or null if there is only one profile.","old_comment_raw":"@return a {@link UserSpinnerAdapter} or null if there is only one profile.","label":1,"pre_label":0,"AST_level":6,"line_counts":10,"new_code_token_num":69},{"new_code_raw":"public ReadWritableInstantFieldProperty millisOfDay() { return new ReadWritableInstantFieldProperty(this, getChronology().millisOfDay()); }","old_code_raw":"    public MutableDateTimeFieldProperty millisOfDay() {\n        return new MutableDateTimeFieldProperty(this, getChronology().millisOfDay());\n    }\n","new_comment_raw":"@return the millis of day property","old_comment_raw":"@return the millis of day property","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":21},{"new_code_raw":"public String getInitParameter(String name) { try { String value = framework.getServletConfig().getInitParameter(name); if (value == null) { value = framework.getServletContext().getInitParameter(name); } return value; } catch (Throwable ex) { return null; } }","old_code_raw":"public String getInitParameter(String name) {\n    try {\n        return framework.getServletConfig().getInitParameter(name);\n    } catch (Throwable ex) {\n        return null;\n    }\n}","new_comment_raw":"@return the value for the init parameter if defined","old_comment_raw":"@return the list of init params defined in web.xml or application.xml","label":1,"pre_label":0,"AST_level":10,"line_counts":11,"new_code_token_num":53},{"new_code_raw":"public DateTimeFormatterBuilder appendClockhourOfHalfday(int minDigits) { return appendDecimal(DateTimeFieldType.clockhourOfHalfday(), minDigits, 2); }","old_code_raw":"    public DateTimeFormatterBuilder appendClockhourOfHalfday(final int minDigits) {\n        return appendDecimal(iChronoUTC.clockhourOfHalfday(), minDigits, 2);\n    }\n","new_comment_raw":"@return this DateTimeFormatterBuilder","old_comment_raw":"@return this DateTimeFormatterBuilder","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":22},{"new_code_raw":"private boolean processResults(boolean returnKeys, boolean update) throws SQLException { if (!resultQueue.isEmpty()) { throw new IllegalStateException(STR); } while (!tds.isEndOfResponse()) { if (!tds.getMoreResults()) { if (tds.isUpdateCount()) { if (update && connection.isLastUpdateCount()) { resultQueue.clear(); } resultQueue.addLast(new Integer(tds.getUpdateCount())); } } else { if (returnKeys) { if (tds.getNextRow()) { genKeyResultSet = new CachedResultSet(this, tds.getColumns(), tds.getRowData()); } } else { if (update && resultQueue.isEmpty()) { throw new SQLException(Messages.get(STR), STR); } resultQueue.add(new JtdsResultSet(this, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY, tds.getColumns())); break; } } } return !resultQueue.isEmpty(); }","old_code_raw":"private boolean processResults(boolean returnKeys, boolean update) throws SQLException {\n    while (!tds.isEndOfResponse()) {\n        if (!tds.getMoreResults()) {\n            if (tds.isUpdateCount()) {\n                if (update && connection.isLastUpdateCount()) {\n                    resultQueue.clear();\n                }\n                resultQueue.addLast(new Integer(tds.getUpdateCount()));\n            }\n        } else {\n            if (returnKeys) {\n                if (tds.getNextRow()) {\n                    genKeyResultSet = new CachedResultSet(this, tds.getColumns(), tds.getRowData());\n                }\n            } else {\n                if (update && resultQueue.isEmpty()) {\n                    throw new SQLException(Messages.get(STR), STR);\n                }\n                JtdsResultSet rs = new JtdsResultSet(this, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY, tds.getColumns(), false);\n                if (resultQueue.isEmpty()) {\n                    currentResult = rs;\n                    return true;\n                } else {\n                    resultQueue.add(rs);\n                    return false;\n                }\n            }\n        }\n    }\n    return false;\n}","new_comment_raw":"@return <code>true<\/code> if there are any results, <code>false<\/code> otherwise","old_comment_raw":"@return <false> if the first result is an update count, <true> if it's a <code>ResultSet<\/code>","label":1,"pre_label":0,"AST_level":14,"line_counts":28,"new_code_token_num":183},{"new_code_raw":"public List<FxType> getDerivedTypes() { return Collections.unmodifiableList(derivedTypes); }","old_code_raw":"public List<FxType> getDerivedTypes() {\n    return derivedTypes;\n}","new_comment_raw":"@return Iterator of all directly derived types","old_comment_raw":"@return Iterator of all derived types","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":15},{"new_code_raw":"protected Object convertBit(Column column, Field fieldDefn, Object data) { return convertValue(column, fieldDefn, data, false, (r) -> { if (data instanceof Boolean) { r.deliver(data); } else if (data instanceof Short) { r.deliver(((Short) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE); } else if (data instanceof Integer) { r.deliver(((Integer) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE); } else if (data instanceof Long) { r.deliver(((Long) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE); } else if (data instanceof BitSet) { BitSet value = (BitSet) data; r.deliver(value.get(0)); } }); }","old_code_raw":"    protected Object convertBit(Column column, Field fieldDefn, Object data) {\n        if (data == null && !fieldDefn.schema().isOptional()) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return false;\n        }\n        if (data instanceof Boolean) return data;\n        if (data instanceof Short) return ((Short) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;\n        if (data instanceof Integer) return ((Integer) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;\n        if (data instanceof Long) return ((Long) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;\n        if (data instanceof BitSet) {\n            BitSet value = (BitSet) data;\n            return value.get(0);\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","label":0,"pre_label":1,"AST_level":16,"line_counts":21,"new_code_token_num":164},{"new_code_raw":"public List<BreakpointMessageInterface> getBreakpointsEnabledList() { if (mode.equals(Mode.safe)) { return new ArrayList<>(); } return getBreakpointsModel().getBreakpointsEnabledList(); }","old_code_raw":"\tpublic List<BreakpointMessageInterface> getBreakpointsEnabledList() {\n\t\tif (mode.equals(Mode.safe)) {\n\t\t\treturn new ArrayList<BreakpointMessageInterface>();\n\t\t}\n\t\treturn getBreakpointsModel().getBreakpointsEnabledList();\n\t}\n","new_comment_raw":"@return list of enabled breakpoints","old_comment_raw":"@return list of enabled breakpoints","label":0,"pre_label":1,"AST_level":7,"line_counts":7,"new_code_token_num":33},{"new_code_raw":"public int getEstimatedRotation() { if (!isRotating()) { return getRotation(); } double timeSpent = (System.currentTimeMillis() - estimatedRotationStartTime) \/ NUM; int rotation = estimatedRotationStart + (int) (currentVelocity * timeSpent); if ((estimatedRotationStart < estimatedRotationEnd) != (estimatedRotationStart < rotation)) { rotation = estimatedRotationEnd; } double angle = (double) (rotation) \/ Settings.getHandlerRotation() * NUM; return (int) (Math.round(angle)) % NUM; }","old_code_raw":"public int getEstimatedRotation() {\n    if (!isRotating()) {\n        return getRotation();\n    } else {\n        double timeSpent = (System.currentTimeMillis() - startingTime) \/ NUM;\n        int pos = currentStartingPoint + (int) (currentVelocity * timeSpent);\n        double angle = (double) (pos) \/ Settings.getHandlerRotation() * NUM;\n        return (int) (Math.round(angle)) % NUM;\n    }\n}","new_comment_raw":"@return estimated rotation of where we are at in angles.","old_comment_raw":"@return current Estimated rotation we are at","label":1,"pre_label":0,"AST_level":8,"line_counts":12,"new_code_token_num":94},{"new_code_raw":"public boolean preloadBundle(Bundle bundle) { return true; }","old_code_raw":"public boolean preloadBundle(Bundle bundle) {\n    return false;\n}","new_comment_raw":"@return true: can load the bundle, false: cannot","old_comment_raw":"@return true: can launch bundle, false: otherwise","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":12},{"new_code_raw":"public BooleanExpression endsWith(String str) { return endsWith(ConstantImpl.create(str)); }","old_code_raw":"    public BooleanExpression endsWith(String str) {\n        return endsWith(StringConstant.create(str));\n    }\n","new_comment_raw":"@return this.endsWith(str)","old_comment_raw":"@return this.endsWith(str)","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":19},{"new_code_raw":"public VisualItem findItem(Point p) { Point2D p2 = (m_itransform == null ? p : m_itransform.transform(p, m_tmpPoint)); synchronized (m_registry) { Iterator items = m_registry.getItemsReversed(); while (items.hasNext()) { VisualItem vi = (VisualItem) items.next(); Renderer r = vi.getRenderer(); if (r != null && r.locatePoint(p2, vi)) { return vi; } } } return null; }","old_code_raw":"public GraphItem findItem(Point p) {\n    Point2D p2 = (m_itransform == null ? p : m_itransform.transform(p, m_tmpPoint));\n    synchronized (m_registry) {\n        Iterator items = m_registry.getItemsReversed();\n        while (items.hasNext()) {\n            GraphItem gi = (GraphItem) items.next();\n            Renderer r = gi.getRenderer();\n            if (r != null && r.locatePoint(p2, gi)) {\n                return gi;\n            }\n        }\n    }\n    return null;\n}","new_comment_raw":"@return the VisualItem located at the given point, if any","old_comment_raw":"@return the GraphItem located at the given point, if any","label":1,"pre_label":0,"AST_level":9,"line_counts":14,"new_code_token_num":88},{"new_code_raw":"public VariationService createVariationService() { return createVariationService(defaultEndpointUrl); }","old_code_raw":"public VariationService createVariationService() {\n    return createVariationService(defaultServerUrl);\n}","new_comment_raw":"@return a new variation service with the default endpoint URL","old_comment_raw":"@return a new variation service with the default server URL","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":13},{"new_code_raw":"public ParameterMetadata getSQLParameterMetadata(final String query) { ParameterMetadata value = parameterMetadataCache.get( query ); if ( value == null ) { value = buildParameterMetadata( query ); parameterMetadataCache.putIfAbsent( query, value ); } return value; }","old_code_raw":"\tpublic ParameterMetadata getSQLParameterMetadata(String query) {\n\t\tParameterMetadata metadata = ( ParameterMetadata ) sqlParamMetadataCache.get( query );\n\t\tif ( metadata == null ) {\n\t\t\tmetadata = buildNativeSQLParameterMetadata( query );\n\t\t\tsqlParamMetadataCache.put( query, metadata );\n\t\t}\n\t\treturn metadata;\n\t}\n","new_comment_raw":"@return The parameter metadata","old_comment_raw":"@return The parameter metadata","label":0,"pre_label":1,"AST_level":8,"line_counts":9,"new_code_token_num":42},{"new_code_raw":"public boolean searchText(String text, int minimumNumberOfMatches, boolean scroll) { return searcher.searchWithTimeoutFor(TextView.class, text, minimumNumberOfMatches, scroll); }","old_code_raw":"\tpublic boolean searchText(String regex, int expectedMinimumNumberOfMatches, boolean scroll) {\n\t\treturn searcher.searchWithTimeoutFor(TextView.class, regex, expectedMinimumNumberOfMatches, scroll);\n\t}\n","new_comment_raw":"@return  true if text string is found a given number of times and  false if the text string is not found","old_comment_raw":"@return true if regex string is found a given number of times and false if the regex string is not found","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":29},{"new_code_raw":"protected int getCustomColumnIndex(int columnIndex) { Integer customColumnIndex = cacheColumnIdxToIdxCustomColumnsOnly.get(columnIndex); if (customColumnIndex != null) { return customColumnIndex; } return -1; }","old_code_raw":"    protected int getCustomColumnIndex(int columnIndex) {\n        Integer customColumnIndex = cacheColumnIdxToIdxCustomColumnsOnly.get(Integer.valueOf(columnIndex));\n        if (customColumnIndex != null) {\n            return customColumnIndex.intValue();\n        }\n        return -1;\n    }\n","new_comment_raw":"@return the custom column index as if no default columns existed or -1 if not a custom column.","old_comment_raw":"@return the custom column index as if no default columns existed or -1 if not a custom column.","label":0,"pre_label":1,"AST_level":6,"line_counts":8,"new_code_token_num":32},{"new_code_raw":"public String getLCS(String strA, String strB) { return algC(strA.length(), strB.length(), strA, strB); }","old_code_raw":"    public String getLCS(String strA, String strB) {\n        if (\"\".equals(strA)) {\n            return \"\";\n        }\n\n        StringBuilder sb = new StringBuilder();\n        algC(sb, strA.length(), strB.length(), strA, strB);\n        return sb.toString();\n    }\n","new_comment_raw":"@return the Longest Common Subsequence of strA and strB","old_comment_raw":"@return the Longest Common Subsequence of strA and strB","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":30},{"new_code_raw":"private List<AbstractProject> getProjects() { List<AbstractProject> result = new ArrayList<AbstractProject>(); List<TopLevelItem> topLevelItems = Hudson.getInstance().getItems(); for (TopLevelItem topLevelItem : topLevelItems) { if (topLevelItem instanceof AbstractProject) { AbstractProject abstractProject = (AbstractProject) topLevelItem; if (abstractProject.getPublishersList().get(MonitorPublisher.DESCRIPTOR) != null) { result.add(abstractProject); } } } return result; }","old_code_raw":"private List<Project> getProjects() {\n    List<Project> result = new ArrayList<Project>();\n    List<Project> projects = Hudson.getInstance().getProjects();\n    for (Project project : projects) {\n        Publisher publisher = project.getPublisher(MonitorPublisher.DESCRIPTOR);\n        if (publisher != null) {\n            result.add(project);\n        }\n    }\n    return result;\n}","new_comment_raw":"@return list projects that will be displayed","old_comment_raw":"@return list containing Projects.","label":1,"pre_label":0,"AST_level":11,"line_counts":13,"new_code_token_num":77},{"new_code_raw":"public static Color fromObject(@Nonnull final Object object) { int i = object.hashCode(); float h = (i % 360) \/ 360f; return Color.getHSBColor(h, 1, 1); }","old_code_raw":"\tpublic static Color fromObject(@Nonnull final Object object, boolean skipAlpha)\n\t{\n\t\tint i = object.hashCode();\n\t\tint r = (i >> 24) & 0xFF;\n\t\tint g = (i >> 16) & 0xFF;\n\t\tint b = (i >> 8) & 0xFF;\n\t\tint a = i & 0xFF;\n\t\treturn new Color(r, g, b, skipAlpha ? 255 : a);\n\t}\n","new_comment_raw":"@return color","old_comment_raw":"@return color","label":0,"pre_label":1,"AST_level":7,"line_counts":7,"new_code_token_num":41},{"new_code_raw":"public DateTimeField[] getFields() { DateTimeField[] result = new DateTimeField[getFieldSize()]; for (int i = 0; i < result.length; i++) { result[i] = getField(i); } return result; }","old_code_raw":"    public DateTimeField[] getFields() {\n        return (DateTimeField[]) iFields.clone();\n    }\n","new_comment_raw":"@return the fields supported in an array that may be altered, largest to smallest","old_comment_raw":"@return the fields supported (cloned), largest to smallest","label":1,"pre_label":0,"AST_level":9,"line_counts":8,"new_code_token_num":49},{"new_code_raw":"public boolean hasUnresolvedEntityInsertActions() { return unresolvedInsertions != null && !unresolvedInsertions.isEmpty(); }","old_code_raw":"\tpublic boolean hasUnresolvedEntityInsertActions() {\n\t\treturn !unresolvedInsertions.isEmpty();\n\t}\n","new_comment_raw":"@return true, if there are unresolved entity insert actions that depend on non-nullable associations with a transient entity; false, otherwise","old_comment_raw":"@return true, if there are unresolved entity insert actions that depend on non-nullable associations with a transient entity; false, otherwise","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":19},{"new_code_raw":"@Override public long doRemoteFunction(int value) { long waitTime = (long) Math.floor(randomProvider.random() * NUM); try { sleep(waitTime); } catch (InterruptedException e) { LOGGER.error(STR, e); } return waitTime <= THRESHOLD ? value * NUM : FAILURE; }","old_code_raw":"@Override\npublic long doRemoteFunction(int value) {\n    long waitTime = (long) Math.floor(Math.random() * NUM);\n    try {\n        sleep(waitTime);\n    } catch (InterruptedException e) {\n        LOGGER.error(STR, e);\n    }\n    return waitTime >= NUM ? value * NUM : -NUM;\n}","new_comment_raw":"@return if waitTime is less than {@link RemoteService#THRESHOLD}, it returns value * 10, otherwise {@link RemoteServiceInterface#FAILURE}.","old_comment_raw":"@return if waitTime is more than 200ms, it returns value * 10, otherwise -1.","label":1,"pre_label":0,"AST_level":8,"line_counts":10,"new_code_token_num":60},{"new_code_raw":"public String getEnumString() { if (enumString == null) { return null; } return enumString.value(); }","old_code_raw":"  public EnumStringEnum getEnumString() {\n    return enumString;\n  }\n","new_comment_raw":"@return enumString","old_comment_raw":"@return enumString","label":0,"pre_label":1,"AST_level":6,"line_counts":7,"new_code_token_num":23},{"new_code_raw":"public List<String> getParameterNames() { return parameterNames; }","old_code_raw":"    public List<String> getParameterNames()\n    {\n        return Collections.unmodifiableList(parameterNames);\n    }\n","new_comment_raw":"@return List of parameter names","old_comment_raw":"@return List of parameter names","label":0,"pre_label":1,"AST_level":5,"line_counts":5,"new_code_token_num":11},{"new_code_raw":"public static Schema getValueReaderSchema(Configuration conf) { String json = conf.get(CONF_VALUE_READER_SCHEMA); return null == json ? null : new Schema.Parser().parse(json); }","old_code_raw":"  public static Schema getValueReaderSchema(Configuration conf) {\n    String json = conf.get(CONF_VALUE_READER_SCHEMA);\n    return null == json ? null : Schema.parse(json);\n  }\n","new_comment_raw":"@return The Avro value reader schema, or null if none was set.","old_comment_raw":"@return The Avro value reader schema, or null if none was set.","label":0,"pre_label":1,"AST_level":7,"line_counts":5,"new_code_token_num":34},{"new_code_raw":"public List<Expr> getArgs() { return new CopyOnWriteArrayList<Expr>(args); }","old_code_raw":"public List<Expr> getArgs() {\n    return args;\n}","new_comment_raw":"@return A copy of the current argument list.","old_comment_raw":"@return The operator's arguments.","label":1,"pre_label":0,"AST_level":7,"line_counts":3,"new_code_token_num":16},{"new_code_raw":"public Object next() throws java.io.IOException { int zzInput; int zzAction; \/\/ cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; \/\/ set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { \/\/ store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); \/\/ get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } \/\/ store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { System.err.printf(\"Untokenizable: %s%n\", yytext()); return getNext(true); } case 9: break; case 2: { return getNewline(); } case 10: break; case 3: { } case 11: break; case 4: { return getNext(false); } case 12: break; case 5: { return getNext(true); } case 13: break; case 6: { return getEllipsis(); } case 14: break; case 7: { if (! removeProMarker) return getNext(false); } case 15: break; case 8: { if (removeProMarker) { if ( ! removeSegMarker) { return getNext(\"-\", yytext()); } } else { return getNext(false); } } case 16: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }","old_code_raw":"  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    \/\/ cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      \/\/ set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            \/\/ store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            \/\/ get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      \/\/ store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { System.err.printf(\"Untokenizable: %s%n\", yytext());\n\t      return getNext(true);\n          }\n        case 8: break;\n        case 2: \n          { return getNewline();\n          }\n        case 9: break;\n        case 3: \n          { \n          }\n        case 10: break;\n        case 4: \n          { return getNext(false);\n          }\n        case 11: break;\n        case 5: \n          { return getNext(true);\n          }\n        case 12: break;\n        case 6: \n          { return getEllipsis();\n          }\n        case 13: break;\n        case 7: \n          { if (removeProMarker) {\n                if ( ! removeSegMarker) {\n                  return getNext(\"-\", yytext());\n                }\n              } else {\n                return getNext(false);\n              }\n          }\n        case 14: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                return null;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n","new_comment_raw":"@return the next token","old_comment_raw":"@return the next token","label":0,"pre_label":1,"AST_level":17,"line_counts":129,"new_code_token_num":503},{"new_code_raw":"public SqlSelect getSourceSelect() { return sourceSelect; }","old_code_raw":"  public SqlSelect getSourceSelect() {\n    return (SqlSelect) operands[SOURCE_SELECT_OPERAND];\n  }\n","new_comment_raw":"@return the source SELECT for the data to be updated","old_comment_raw":"@return the source SELECT for the data to be updated","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"public static String getColumnName(String elementType) { if (elementType.equals(ELEMENTTYPE_Organization)) return STR; else if (elementType.equals(ELEMENTTYPE_Account)) return I_C_ValidCombination.COLUMNNAME_Account_ID; else if (elementType.equals(ELEMENTTYPE_BPartner)) return I_C_ValidCombination.COLUMNNAME_C_BPartner_ID; else if (elementType.equals(ELEMENTTYPE_Product)) return I_C_ValidCombination.COLUMNNAME_M_Product_ID; else if (elementType.equals(ELEMENTTYPE_Activity)) return I_C_ValidCombination.COLUMNNAME_C_Activity_ID; else if (elementType.equals(ELEMENTTYPE_LocationFrom)) return I_C_ValidCombination.COLUMNNAME_C_LocFrom_ID; else if (elementType.equals(ELEMENTTYPE_LocationTo)) return I_C_ValidCombination.COLUMNNAME_C_LocTo_ID; else if (elementType.equals(ELEMENTTYPE_Campaign)) return I_C_ValidCombination.COLUMNNAME_C_Campaign_ID; else if (elementType.equals(ELEMENTTYPE_OrgTrx)) return I_C_ValidCombination.COLUMNNAME_AD_OrgTrx_ID; else if (elementType.equals(ELEMENTTYPE_Project)) return I_C_ValidCombination.COLUMNNAME_C_Project_ID; else if (elementType.equals(ELEMENTTYPE_SalesRegion)) return I_C_ValidCombination.COLUMNNAME_C_SalesRegion_ID; else if (elementType.equals(ELEMENTTYPE_UserList1)) return I_C_ValidCombination.COLUMNNAME_User1_ID; else if (elementType.equals(ELEMENTTYPE_UserList2)) return I_C_ValidCombination.COLUMNNAME_User2_ID; else if (elementType.equals(ELEMENTTYPE_UserElement1)) return I_C_ValidCombination.COLUMNNAME_UserElement1_ID; else if (elementType.equals(ELEMENTTYPE_UserElement2)) return I_C_ValidCombination.COLUMNNAME_UserElement2_ID; return STR; }","old_code_raw":"public static String getColumnName(String elementType) {\n    if (elementType.equals(ELEMENTTYPE_Organization))\n        return STR;\n    else if (elementType.equals(ELEMENTTYPE_Account))\n        return STR;\n    else if (elementType.equals(ELEMENTTYPE_BPartner))\n        return STR;\n    else if (elementType.equals(ELEMENTTYPE_Product))\n        return STR;\n    else if (elementType.equals(ELEMENTTYPE_Activity))\n        return STR;\n    else if (elementType.equals(ELEMENTTYPE_LocationFrom))\n        return STR;\n    else if (elementType.equals(ELEMENTTYPE_LocationTo))\n        return STR;\n    else if (elementType.equals(ELEMENTTYPE_Campaign))\n        return STR;\n    else if (elementType.equals(ELEMENTTYPE_OrgTrx))\n        return STR;\n    else if (elementType.equals(ELEMENTTYPE_Project))\n        return STR;\n    else if (elementType.equals(ELEMENTTYPE_SalesRegion))\n        return STR;\n    else if (elementType.equals(ELEMENTTYPE_UserList1))\n        return STR;\n    else if (elementType.equals(ELEMENTTYPE_UserList2))\n        return STR;\n    else if (elementType.equals(ELEMENTTYPE_UserElement1))\n        return STR;\n    else if (elementType.equals(ELEMENTTYPE_UserElement2))\n        return STR;\n    return STR;\n}","new_comment_raw":"@return column name or \"\" if not found","old_comment_raw":"@return column name","label":1,"pre_label":0,"AST_level":19,"line_counts":33,"new_code_token_num":206},{"new_code_raw":"public static By id(final String id) { if (id == null) throw new IllegalArgumentException(\"Cannot find elements with a null id attribute.\"); return new ById(id); }","old_code_raw":"    public static By id(final String id) {\n      if (id == null)\n        throw new IllegalArgumentException(\"Cannot find elements with a null id attribute.\");\n\n      return new By() {\n        @Override\n        public List<WebElement> findElements(SearchContext context) {\n          if (context instanceof FindsById)\n              return ((FindsById) context).findElementsById(id);\n          return ((FindsByXPath) context).findElementsByXPath(\"*[@id = '\" + id + \"']\");\n        }\n\n        @Override\n        public WebElement findElement(SearchContext context) {\n          if (context instanceof FindsById)\n            return ((FindsById) context).findElementById(id);\n          return ((FindsByXPath) context).findElementByXPath(\"*[@id = '\" + id + \"']\");\n        }\n       \n        @Override\n        public String toString() {\n          return \"By.id: \" + id;\n        }\n      };\n    }\n","new_comment_raw":"@return a By which locates elements by the value of the \"id\" attribute.","old_comment_raw":"@return a By which locates elements by the value of the \"id\" attribute.","label":0,"pre_label":1,"AST_level":6,"line_counts":7,"new_code_token_num":39},{"new_code_raw":"public int[] getPartialValues(ReadablePartial fieldSource, Object object, Chronology chrono, DateTimeFormatter parser) { long millis = parser.withChronology(chrono).parseMillis((String) object); return chrono.get(fieldSource, millis); }","old_code_raw":"    public int[] getPartialValues(ReadablePartial fieldSource, Object object, Chronology chrono, DateTimeFormatter parser) {\n        long millis = parser.withChronology(chrono).parseMillis((String) object);\n        int size = fieldSource.size();\n        int[] values = new int[size];\n        for (int i = 0; i < size; i++) {\n            values[i] = fieldSource.getFieldType(i).getField(chrono).get(millis);\n        }\n        chrono.validate(fieldSource, values);\n        return values;\n    }\n","new_comment_raw":"@return the array of field values that match the fieldSource, must be non-null valid","old_comment_raw":"@return the array of field values that match the fieldSource, must be non-null valid","label":0,"pre_label":1,"AST_level":8,"line_counts":5,"new_code_token_num":44},{"new_code_raw":"private static String[] decodeArray(String encoded){ char[] chars = encoded.trim().toCharArray(); \/\/--Parse the String \/\/(state) char quoteCloseChar = (char) 0; List<StringBuilder> terms = new LinkedList<StringBuilder>(); StringBuilder current = new StringBuilder(); \/\/(start\/stop overhead) int start = 0; int end = chars.length; if(chars[0] == '('){ start += 1; end -= 1; if(chars[end] != ')') throw new IllegalArgumentException(\"Unclosed paren in encoded array: \" + encoded); } if(chars[0] == '['){ start += 1; end -= 1; if(chars[end] != ']') throw new IllegalArgumentException(\"Unclosed bracket in encoded array: \" + encoded); } \/\/(finite state automata) for(int i=start; i<end; i++){ if(chars[i] == '\\\\'){ \/\/(case: escaped character) if(i == chars.length - 1) throw new IllegalArgumentException(\"Last character of encoded pair is escape character: \" + encoded); current.append(chars[i+1]); i += 1; } else if(quoteCloseChar != 0){ \/\/(case: in quotes) if(chars[i] == quoteCloseChar){ quoteCloseChar = (char) 0; }else{ current.append(chars[i]); } }else{ \/\/(case: normal) if(chars[i] == '\"'){ quoteCloseChar = '\"'; } else if(chars[i] == '\\''){ quoteCloseChar = '\\''; } else if(chars[i] == ',' || chars[i] == ' ' || chars[i] == '\\t' || chars[i] == '\\n'){ \/\/break if (current.length() > 0) { terms.add(current); } current = new StringBuilder(); }else{ current.append(chars[i]); } } } \/\/--Return if(current.length() > 0) terms.add(current); String[] rtn = new String[terms.size()]; int i=0; for(StringBuilder b : terms){ rtn[i] = b.toString().trim(); i += 1; } return rtn; }","old_code_raw":"\tprivate static String[] decodeArray(String encoded){\n    if (encoded.length() == 0) return new String[]{};\n\t\tchar[] chars = encoded.trim().toCharArray();\n\n\t\t\/\/--Parse the String\n\t\t\/\/(state)\n\t\tchar quoteCloseChar = (char) 0;\n\t\tList<StringBuilder> terms = new LinkedList<StringBuilder>();\n\t\tStringBuilder current = new StringBuilder();\n\t\t\/\/(start\/stop overhead)\n\t\tint start = 0; int end = chars.length;\n\t\tif(chars[0] == '('){ start += 1; end -= 1; if(chars[end] != ')') throw new IllegalArgumentException(\"Unclosed paren in encoded array: \" + encoded); }\n\t\tif(chars[0] == '['){ start += 1; end -= 1; if(chars[end] != ']') throw new IllegalArgumentException(\"Unclosed bracket in encoded array: \" + encoded); }\n    if(chars[0] == '{'){ start += 1; end -= 1; if(chars[end] != '}') throw new IllegalArgumentException(\"Unclosed bracket in encoded array: \" + encoded); }\n\t\t\/\/(finite state automata)\n\t\tfor(int i=start; i<end; i++){\n\t\t\tif(chars[i] == '\\\\'){\n\t\t\t\t\/\/(case: escaped character)\n\t\t\t\tif(i == chars.length - 1) throw new IllegalArgumentException(\"Last character of encoded pair is escape character: \" + encoded);\n\t\t\t\tcurrent.append(chars[i+1]);\n\t\t\t\ti += 1;\n\t\t\t} else if(quoteCloseChar != 0){\n\t\t\t\t\/\/(case: in quotes)\n\t\t\t\tif(chars[i] == quoteCloseChar){\n\t\t\t\t\tquoteCloseChar = (char) 0;\n\t\t\t\t}else{\n\t\t\t\t\tcurrent.append(chars[i]);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t\/\/(case: normal)\n\t\t\t\tif(chars[i] == '\"'){\n          quoteCloseChar = '\"';\n\t\t\t\t} else if(chars[i] == '\\''){\n          quoteCloseChar = '\\'';\n\t\t\t\t} else if(chars[i] == ',' || chars[i] == ';' || chars[i] == ' ' || chars[i] == '\\t' || chars[i] == '\\n'){\n\t\t\t\t\t\/\/break\n          if (current.length() > 0) {\n\t\t\t\t\t  terms.add(current);\n          }\n\t\t\t\t\tcurrent = new StringBuilder();\n\t\t\t\t}else{\n\t\t\t\t\tcurrent.append(chars[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t\/\/--Return\n\t\tif(current.length() > 0) terms.add(current);\n\t\tString[] rtn = new String[terms.size()];\n\t\tint i=0;\n\t\tfor(StringBuilder b : terms){\n\t\t\trtn[i] = b.toString().trim();\n\t\t\ti += 1;\n\t\t}\n    return rtn;\n  }\n","new_comment_raw":"@return A String array corresponding to the encoded array","old_comment_raw":"@return A String array corresponding to the encoded array","label":0,"pre_label":1,"AST_level":17,"line_counts":55,"new_code_token_num":489},{"new_code_raw":"public static Properties extractJndiProperties(Map configurationValues) { return JndiServiceImpl.extractJndiProperties( configurationValues ); }","old_code_raw":"\tpublic static Properties extractJndiProperties(Map configurationValues) {\n\t\tfinal Properties jndiProperties = new Properties();\n\n\t\tfor ( Map.Entry entry : (Set<Map.Entry>) configurationValues.entrySet() ) {\n\t\t\tif ( !String.class.isInstance( entry.getKey() ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfinal String propertyName = (String) entry.getKey();\n\t\t\tfinal Object propertyValue = entry.getValue();\n\t\t\tif ( propertyName.startsWith( Environment.JNDI_PREFIX ) ) {\n\t\t\t\t\/\/ write the IntialContextFactory class and provider url to the result only if they are\n\t\t\t\t\/\/ non-null; this allows the environmental defaults (if any) to remain in effect\n\t\t\t\tif ( Environment.JNDI_CLASS.equals( propertyName ) ) {\n\t\t\t\t\tif ( propertyValue != null ) {\n\t\t\t\t\t\tjndiProperties.put( Context.INITIAL_CONTEXT_FACTORY, propertyValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ( Environment.JNDI_URL.equals( propertyName ) ) {\n\t\t\t\t\tif ( propertyValue != null ) {\n\t\t\t\t\t\tjndiProperties.put( Context.PROVIDER_URL, propertyValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfinal String passThruPropertyname = propertyName.substring( Environment.JNDI_PREFIX.length() + 1 );\n\t\t\t\t\tjndiProperties.put( passThruPropertyname, propertyValue );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jndiProperties;\n\t}\n","new_comment_raw":"@return The extracted JNDI specific properties.","old_comment_raw":"@return The extracted JNDI specific properties.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":17},{"new_code_raw":"public double getRotZ() { return Math.toDegrees(mOrientation.getRotationZ()); }","old_code_raw":"public double getRotZ() {\n    return mOrientation.getRotationZ();\n}","new_comment_raw":"@return double The pitch Euler angle in degrees.","old_comment_raw":"@return double The pitch Euler angle.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":17},{"new_code_raw":"private AvaticaServerConfiguration buildSpnegoConfiguration(Builder b) { final String principal = b.kerberosPrincipal; final String realm = b.kerberosRealm; final DoAsRemoteUserCallback callback = b.remoteUserCallback; return new AvaticaServerConfiguration() { @Override public AuthenticationType getAuthenticationType() { return AuthenticationType.SPNEGO; } @Override public String getKerberosRealm() { return realm; } @Override public String getKerberosPrincipal() { return principal; } @Override public boolean supportsImpersonation() { return null != callback; } @Override public <T> T doAsRemoteUser(String remoteUserName, String remoteAddress, Callable<T> action) throws Exception { return callback.doAsRemoteUser(remoteUserName, remoteAddress, action); } @Override public String[] getAllowedRoles() { return null; } @Override public String getHashLoginServiceRealm() { return null; } @Override public String getHashLoginServiceProperties() { return null; } }; }","old_code_raw":"    private AvaticaServerConfiguration buildSpnegoConfiguration(Builder b) {\n      final String principal = b.kerberosPrincipal;\n      final String realm = b.kerberosRealm;\n      final DoAsRemoteUserCallback callback = b.remoteUserCallback;\n      return new AvaticaServerConfiguration() {\n\n        @Override public AuthenticationType getAuthenticationType() {\n          return AuthenticationType.SPNEGO;\n        }\n\n        @Override public String getKerberosRealm() {\n          return realm;\n        }\n\n        @Override public String getKerberosPrincipal() {\n          return principal;\n        }\n\n        @Override public boolean supportsImpersonation() {\n          return null != callback;\n        }\n\n        @Override public <T> T doAsRemoteUser(String remoteUserName, String remoteAddress,\n            Callable<T> action) throws Exception {\n          return callback.doAsRemoteUser(remoteUserName, remoteAddress, action);\n        }\n      };\n    }\n","new_comment_raw":"@return A configuration instance.","old_comment_raw":"@return A configuration instance.","label":0,"pre_label":1,"AST_level":9,"line_counts":41,"new_code_token_num":156},{"new_code_raw":"private ZapTextArea getTxtSkipURL() { if (txtSkipURL == null) { txtSkipURL = new ZapTextArea(); txtSkipURL.setFont(new java.awt.Font(\"Default\", java.awt.Font.PLAIN, 11)); if (Model.getSingleton().getOptionsParam().getViewParam().getWmUiHandlingOption() == 0) { txtSkipURL.setSize(new java.awt.Dimension(290,52)); } } return txtSkipURL; }","old_code_raw":"    private JTextArea getTxtSkipURL() {\n        if (txtSkipURL == null) {\n            txtSkipURL = new JTextArea();\n            txtSkipURL.setFont(new java.awt.Font(\"Default\", java.awt.Font.PLAIN, 11));\n    \t    if (Model.getSingleton().getOptionsParam().getViewParam().getWmUiHandlingOption() == 0) {\n    \t    \ttxtSkipURL.setSize(new java.awt.Dimension(290,52));\n    \t    }\n        }\n        return txtSkipURL;\n    }\n","new_comment_raw":"@return javax.swing.ZapTextArea","old_comment_raw":"@return javax.swing.JTextArea","label":1,"pre_label":0,"AST_level":12,"line_counts":11,"new_code_token_num":77},{"new_code_raw":"public static Tree UCPtransform(Tree t) { if (t == null) { return null; } Tree firstChild = t.firstChild(); if (firstChild != null) { List<Pair<TregexPattern,TsurgeonPattern>> ops = Generics.newArrayList(); for (int i = 0; i < operations.length; i++) { for (TregexPattern pattern : matchPatterns[i]) { ops.add(Generics.newPair(pattern, operations[i])); } } return Tsurgeon.processPatternsOnTree(ops, t); } else { return t; } }","old_code_raw":"  public static Tree UCPtransform(Tree t) {\n    if (t == null) {\n      return null;\n    }\n    return Tsurgeon.processPattern(ucpRenameTregex, ucpRenameTsurgeon, t);\n  }\n","new_comment_raw":"@return t transformed","old_comment_raw":"@return t transformed","label":0,"pre_label":1,"AST_level":14,"line_counts":20,"new_code_token_num":104},{"new_code_raw":"public String getResourceManagerId() throws JMSException { waitForBrokerInfo(); if( brokerInfo==null ) throw new JMSException(\"Connection failed before Broker info was received.\"); return brokerInfo.getBrokerId().getBrokerId(); }","old_code_raw":"    public String getResourceManagerId() throws JMSException {\n        waitForBrokerInfo();\n        if( resourceManagerId==null )\n            throw new JMSException(\"Resource manager id could not be determined.\");            \n        return resourceManagerId;\n    }\n","new_comment_raw":"@return Returns the resourceManagerId.","old_comment_raw":"@return Returns the resourceManagerId.","label":0,"pre_label":1,"AST_level":6,"line_counts":7,"new_code_token_num":42},{"new_code_raw":"private SailBranch branch(boolean includeinferred) throws SailException { boolean active = isActive(); IsolationLevel level = getIsolationLevel(); boolean isolated = !IsolationLevels.NONE.isCompatibleWith(level); if (includeinferred && active && isolated) { return new DelegatingSailBranch(includeInferredBranch, false); } else if (active && isolated) { return new DelegatingSailBranch(explicitOnlyBranch, false); } else if (includeinferred && active) { return new UnionSailBranch(new SailNotBranchedSource(store.getInferredSailSource(level)), new SailNotBranchedSource(store.getExplicitSailSource(level))); } else if (active) { return new SailNotBranchedSource(store.getExplicitSailSource(level)); } else if (includeinferred) { return new UnionSailBranch(store.getInferredSailSource(level).fork(), store.getExplicitSailSource(level).fork()); } else { return store.getExplicitSailSource(level).fork(); } }","old_code_raw":"private RdfBranch branch(boolean includeinferred) throws SailException {\n    boolean active = isActive();\n    IsolationLevel level = getIsolationLevel();\n    boolean isolated = !IsolationLevels.NONE.isCompatibleWith(level);\n    if (includeinferred && active && isolated) {\n        return new DelegatingRdfBranch(includeInferredBranch, false);\n    } else if (active && isolated) {\n        return new DelegatingRdfBranch(explicitOnlyBranch, false);\n    } else if (includeinferred && active) {\n        return new UnionRdfBranch(new RdfNotBranchedSource(store.getInferredRdfSource(level)), new RdfNotBranchedSource(store.getExplicitRdfSource(level)));\n    } else if (active) {\n        return new RdfNotBranchedSource(store.getExplicitRdfSource(level));\n    } else if (includeinferred) {\n        return new UnionRdfBranch(store.getInferredRdfSource(level).fork(), store.getExplicitRdfSource(level).fork());\n    } else {\n        return store.getExplicitRdfSource(level).fork();\n    }\n}","new_comment_raw":"@return read operation {@link SailBranch}","old_comment_raw":"@return read operation {@link RdfBranch}","label":1,"pre_label":0,"AST_level":12,"line_counts":18,"new_code_token_num":169},{"new_code_raw":"public DateTime withMinimumValue() { try { return setCopy(getMinimumValue()); } catch (RuntimeException ex) { if (IllegalInstantException.isIllegalInstant(ex)) { \/\/ subtracting MILLIS_PER_DAY is not perfect, but will work in almost all situations long afterGap = getChronology().getZone().nextTransition(getMillis() - DateTimeConstants.MILLIS_PER_DAY); return new DateTime(afterGap, getChronology()); } throw ex; } }","old_code_raw":"        public DateTime withMinimumValue() {\n            return setCopy(getMinimumValue());\n        }\n","new_comment_raw":"@return a copy of the DateTime with this field set to its minimum","old_comment_raw":"@return a copy of the DateTime with this field set to its minimum","label":0,"pre_label":1,"AST_level":12,"line_counts":13,"new_code_token_num":82},{"new_code_raw":"public Float getTopValue() { return topValue; }","old_code_raw":"public float getTopValue() {\n    return topValue == null ? NUM : topValue.floatValue();\n}","new_comment_raw":"@return The value of the 'top' attribute, null if not set","old_comment_raw":"@return The value of the 'top' CSS-attribute","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":10},{"new_code_raw":"private List<BatchResponse> handleBatchRequests(final List<BatchRequest> requestList, final UriInfo uriInfo) { final List<BatchResponse> responseList = new ArrayList<>(requestList.size()); final List<BatchRequestNode> batchRequestNodes = this.resolutionHelper.getDependingRequests(requestList); checkList.clear(); if(batchRequestNodes.isEmpty()) { final BatchResponse response = new BatchResponse(); ErrorInfo ex = ErrorHandler.handler(new ClientDetailsNotFoundException()); response.setStatusCode(500); response.setBody(ex.getMessage()); responseList.add(response) ; return responseList ; } for (BatchRequestNode rootNode : batchRequestNodes) { final BatchRequest rootRequest = rootNode.getRequest(); final CommandStrategy commandStrategy = this.strategyProvider.getCommandStrategy(CommandContext .resource(rootRequest.getRelativeUrl()).method(rootRequest.getMethod()).build()); final BatchResponse rootResponse = commandStrategy.execute(rootRequest, uriInfo); responseList.add(rootResponse); responseList.addAll(this.processChildRequests(rootNode, rootResponse, uriInfo)); } Collections.sort(responseList, new Comparator<BatchResponse>() { @Override public int compare(BatchResponse source, BatchResponse testee) { return source.getRequestId().compareTo(testee.getRequestId()); } }); checkList = responseList; return responseList; }","old_code_raw":"    private List<BatchResponse> handleBatchRequests(final List<BatchRequest> requestList, final UriInfo uriInfo) {\n\n        final List<BatchResponse> responseList = new ArrayList<>(requestList.size());\n\n        final List<BatchRequestNode> batchRequestNodes = this.resolutionHelper.getDependingRequests(requestList);\n        checkList.clear();\n\n        for (BatchRequestNode rootNode : batchRequestNodes) {\n            final BatchRequest rootRequest = rootNode.getRequest();\n            final CommandStrategy commandStrategy = this.strategyProvider.getCommandStrategy(CommandContext\n                    .resource(rootRequest.getRelativeUrl()).method(rootRequest.getMethod()).build());\n            final BatchResponse rootResponse = commandStrategy.execute(rootRequest, uriInfo);\n\n            responseList.add(rootResponse);\n            responseList.addAll(this.processChildRequests(rootNode, rootResponse, uriInfo));\n        }\n\n        Collections.sort(responseList, new Comparator<BatchResponse>() {\n\n            @Override\n            public int compare(BatchResponse source, BatchResponse testee) {\n                return source.getRequestId().compareTo(testee.getRequestId());\n            }\n        });\n\n        checkList = responseList;\n        return responseList;\n\n    }\n","new_comment_raw":"@return List","old_comment_raw":"@return List","label":0,"pre_label":1,"AST_level":11,"line_counts":37,"new_code_token_num":219},{"new_code_raw":"public SendFileTransfer dccSendFile(File file, User reciever, int timeout) throws IOException { return dccHandler.sendFile(file, reciever, timeout); }","old_code_raw":"public DccFileTransfer dccSendFile(File file, User reciever, int timeout) throws IOException {\n    if (file == null)\n        throw new IllegalArgumentException(STR);\n    if (reciever == null)\n        throw new IllegalArgumentException(STR);\n    DccFileTransfer transfer = new DccFileTransfer(this, file, reciever, timeout);\n    transfer.doSend(true);\n    return transfer;\n}","new_comment_raw":"@return When the transfer is finished returns the {@link SendFileTransfer} used","old_comment_raw":"@return The DccFileTransfer that can be used to monitor this transfer.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":28},{"new_code_raw":"public boolean isClosing(){ return closing.get(); }","old_code_raw":"    public boolean isClosing(){\n        return closing;\n    }\n","new_comment_raw":"@return Returns the closing.","old_comment_raw":"@return Returns the closing.","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":13},{"new_code_raw":"public String getMatchedSentences() { StringBuilder sb = new StringBuilder(); for (int i = 0, sz = list.getModel().getSize(); i < sz; i++) { String t = list.getModel().getElementAt(i).getLabel().getText(); sb.append(t); sb.append(\"\\n\"); } return sb.toString(); }","old_code_raw":"  public StringBuffer getMatchedSentences() {\n    StringBuffer sb = new StringBuffer();\n    for(int i = 0; i < list.getModel().getSize(); i++) {\n      String t = ((TreeFromFile) list.getModel().getElementAt(i)).getLabel().getText();\n      sb.append(t);\n      sb.append(\"\\n\");\n    }\n    return sb;\n  }\n","new_comment_raw":"@return String filled with the plain text form of all sentences in the matches panel","old_comment_raw":"@return StringBuffer filled with the plain text form of all sentences in the matches panel","label":1,"pre_label":0,"AST_level":9,"line_counts":10,"new_code_token_num":76},{"new_code_raw":"protected AsyncSupport resolveMultipleNativeSupportConflict(final List<Class<? extends AsyncSupport>> available) { final StringBuilder b = new StringBuilder(STR); for (Class<? extends AsyncSupport> cs : available) { b.append((cs != null) ? cs.getCanonicalName() : STR).append(STR); } b.append(STR + available.get(NUM)); logger.warn(STR, b.toString()); return newCometSupport(available.get(NUM)); }","old_code_raw":"protected CometSupport resolveMultipleNativeSupportConflict(final List<Class<? extends CometSupport>> available) {\n    final StringBuilder b = new StringBuilder(STR);\n    for (Class<? extends CometSupport> cs : available) {\n        b.append((cs != null) ? cs.getCanonicalName() : STR).append(STR);\n    }\n    b.append(STR + available.get(NUM));\n    logger.warn(STR, b.toString());\n    return newCometSupport(available.get(NUM));\n}","new_comment_raw":"@return a AsyncSupport instance","old_comment_raw":"@return a CometSupport instance","label":1,"pre_label":0,"AST_level":9,"line_counts":9,"new_code_token_num":89},{"new_code_raw":"public static long getLocalExpires(Headers responseHeaders) { final long now = System.currentTimeMillis(); final long date = responseHeaders.getDate(); final long expires = responseHeaders.getExpiration(); long maxAge = 0; long staleWhileRevalidate = 0; String cacheControl = responseHeaders.getCacheControl(); if (!TextUtils.isEmpty(cacheControl)) { StringTokenizer tokens = new StringTokenizer(cacheControl, \",\"); while (tokens.hasMoreTokens()) { String token = tokens.nextToken().trim().toLowerCase(Locale.getDefault()); if ((token.equals(\"no-cache\") || token.equals(\"no-store\"))) { return 0; } else if (token.startsWith(\"max-age=\")) { maxAge = Long.parseLong(token.substring(8)); } else if (token.startsWith(\"must-revalidate\")) { return 0; } else if (token.startsWith(\"stale-while-revalidate=\")) { staleWhileRevalidate = Long.parseLong(token.substring(23)); } } } long localExpire = now;\/\/ Local expires time of cache. \/\/ If must-revalidate, It must be from the server to validate expired. \/\/ Have CacheControl. if (!TextUtils.isEmpty(cacheControl)) { localExpire = now + maxAge * 1000; if (staleWhileRevalidate > 0) localExpire += staleWhileRevalidate * 1000; } \/\/ If the server through control the cache Expires. if (localExpire <= now && expires > date) { localExpire = now + (expires - date); } return localExpire; }","old_code_raw":"    public static long getLocalExpires(Headers responseHeaders) {\n        long now = System.currentTimeMillis();\n        long date = responseHeaders.getDate();\n        long expires = responseHeaders.getExpiration();\n\n        long maxAge = 0;\n        long staleWhileRevalidate = 0;\n\n        String cacheControl = responseHeaders.getCacheControl();\n        if (!TextUtils.isEmpty(cacheControl)) {\n            StringTokenizer tokens = new StringTokenizer(cacheControl, \",\");\n            while (tokens.hasMoreTokens()) {\n                String token = tokens.nextToken().trim().toLowerCase(Locale.getDefault());\n                if ((token.equals(\"no-cache\") || token.equals(\"no-store\"))) {\n                    return 0;\n                } else if (token.startsWith(\"max-age=\")) {\n                    try {\n                        maxAge = Long.parseLong(token.substring(8));\n                    } catch (Exception e) {\n                    }\n                } else if (token.startsWith(\"stale-while-revalidate=\")) {\n                    try {\n                        staleWhileRevalidate = Long.parseLong(token.substring(23));\n                    } catch (Exception e) {\n                    }\n                }\n            }\n        }\n\n        long localExpire = 0;\/\/ Local expires time of cache.\n\n        \/\/ If must-revalidate, It must be from the server to validate expired.\n        \/\/ Have CacheControl.\n        if (!TextUtils.isEmpty(cacheControl)) {\n            localExpire = now + maxAge * 1000;\n            if (staleWhileRevalidate > 0)\n                localExpire += staleWhileRevalidate * 1000;\n        }\n\n        \/\/ If the server through control the cache Expires.\n        if ((localExpire == 0 || localExpire == now) && date > 0 && expires >= date) {\n            localExpire = now + (expires - date);\n        }\n\n        return localExpire;\n    }\n","new_comment_raw":"@return Time corresponding milliseconds.","old_comment_raw":"@return Time corresponding milliseconds.","label":0,"pre_label":1,"AST_level":16,"line_counts":42,"new_code_token_num":293},{"new_code_raw":"public final TwitterTokenStream deserialize(final byte[] data, final CharSequence charSequence) throws IOException { return deserialize(data, NUM, data.length, charSequence); }","old_code_raw":"public final TokenStream deserialize(final byte[] data, final CharSequence charSequence) throws IOException {\n    return deserialize(data, NUM, data.length, charSequence);\n}","new_comment_raw":"@return a TwitterTokenStream object. Notice that, in order to support lucene-like TwitterTokenStream behavior, this object's reset method must only be used as reset(null) and will reset the TwitterTokenStream to its starting point.","old_comment_raw":"@return a TokenStream object. Notice that, in order to support lucene-like TokenStream behavior, this object's reset method must only be used as reset(null) and will reset the TokenStream to its starting point.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":32},{"new_code_raw":"public int getWaitingTaskCount() { return mTasks.size() + pausedList.size(); }","old_code_raw":"    public int getWaitingTaskCount() {\n        return mTasks.size();\n    }\n","new_comment_raw":"@return the count of waiting tasks on this queue.","old_comment_raw":"@return the count of waiting tasks on this queue.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":18},{"new_code_raw":"static protected String valueToString(Object value) { if (value == null || value.equals(null)) { return \"null\"; } \/\/ if (value instanceof JSONString) { \/\/ Object object; \/\/ try { \/\/ object = ((JSONString)value).toJSONString(); \/\/ } catch (Exception e) { \/\/ throw new RuntimeException(e); \/\/ } \/\/ if (object instanceof String) { \/\/ return (String)object; \/\/ } \/\/ throw new RuntimeException(\"Bad value from toJSONString: \" + object); \/\/ } if (value instanceof Number) { return numberToString((Number) value); } if (value instanceof Boolean || value instanceof JSONObject || value instanceof JSONArray) { return value.toString(); } if (value instanceof Map) { return new JSONObject(value).toString(); } if (value instanceof Collection) { return new JSONArray(value).toString(); } if (value.getClass().isArray()) { return new JSONArray(value).toString(); } return quote(value.toString()); }","old_code_raw":"  static protected String valueToString(Object value) {\n    if (value == null || value.equals(null)) {\n      return \"null\";\n    }\n\/\/    if (value instanceof JSONString) {\n\/\/      Object object;\n\/\/      try {\n\/\/        object = ((JSONString)value).toJSONString();\n\/\/      } catch (Exception e) {\n\/\/        throw new RuntimeException(e);\n\/\/      }\n\/\/      if (object instanceof String) {\n\/\/        return (String)object;\n\/\/      }\n\/\/      throw new RuntimeException(\"Bad value from toJSONString: \" + object);\n\/\/    }\n    if (value instanceof Number) {\n      return numberToString((Number) value);\n    }\n    if (value instanceof Boolean || value instanceof JSONObject ||\n      value instanceof JSONArray) {\n      return value.toString();\n    }\n    if (value instanceof Map) {\n      return new JSONObject((Map)value).toString();\n    }\n    if (value instanceof Collection) {\n      return new JSONArray((Collection)value).toString();\n    }\n    if (value.getClass().isArray()) {\n      return new JSONArray(value).toString();\n    }\n    return quote(value.toString());\n  }\n","new_comment_raw":"@return a printable, displayable, transmittable representation of the object, beginning with &nbsp;(left brace) and ending with &nbsp;(right brace).","old_comment_raw":"@return a printable, displayable, transmittable representation of the object, beginning with &nbsp;(left brace) and ending with &nbsp;(right brace).","label":0,"pre_label":1,"AST_level":8,"line_counts":35,"new_code_token_num":229},{"new_code_raw":"public static boolean containsLimit0(RelNode rel) { FindLimit0Visitor visitor = new FindLimit0Visitor(); rel.accept(visitor); if (!visitor.isContains()) { return false; } final FindHardDistributionScans hdVisitor = new FindHardDistributionScans(); rel.accept(hdVisitor); \/\/ Can't optimize limit 0 if the query contains a table which has hard distribution requirement. return !hdVisitor.contains(); }","old_code_raw":"  public static boolean containsLimit0(RelNode rel) {\n    FindLimit0Visitor visitor = new FindLimit0Visitor();\n    rel.accept(visitor);\n    return visitor.isContains();\n  }\n","new_comment_raw":"@return true if the root portion of the tree contains LIMIT(0)","old_comment_raw":"@return true if the root portion of the tree contains LIMIT(0)","label":0,"pre_label":1,"AST_level":6,"line_counts":14,"new_code_token_num":76},{"new_code_raw":"public Throwable getException() { return getCause(); }","old_code_raw":"public Throwable getException() {\n    return cause;\n}","new_comment_raw":"@return The result of calling <code>getCause()<\/code>.","old_comment_raw":"@return the nested exception or <code>null<\/code> if there is no nested exception.","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":12},{"new_code_raw":"public short getBlue() { return data[getFirst1DIndex() + NUM]; }","old_code_raw":"public short getBlue(final int i) {\n    return data[get1DIndex(i) + NUM];\n}","new_comment_raw":"@return blue value in the first position","old_comment_raw":"@return blue value in given position","label":1,"pre_label":0,"AST_level":7,"line_counts":3,"new_code_token_num":17},{"new_code_raw":"private AutoInstallsLayout createWorkspaceLoaderFromAppRestriction(AppWidgetHost widgetHost) { \/\/ UserManager.getApplicationRestrictions() requires minSdkVersion >= 18 if (!Utilities.ATLEAST_JB_MR2) { return null; } Context ctx = getContext(); UserManager um = (UserManager) ctx.getSystemService(Context.USER_SERVICE); Bundle bundle = um.getApplicationRestrictions(ctx.getPackageName()); if (bundle == null) { return null; } String packageName = bundle.getString(RESTRICTION_PACKAGE_NAME); if (packageName != null) { try { Resources targetResources = ctx.getPackageManager() .getResourcesForApplication(packageName); return AutoInstallsLayout.get(ctx, packageName, targetResources, widgetHost, mOpenHelper); } catch (NameNotFoundException e) { Log.e(TAG, \"Target package for restricted profile not found\", e); return null; } } return null; }","old_code_raw":"    private AutoInstallsLayout createWorkspaceLoaderFromAppRestriction() {\n        \/\/ UserManager.getApplicationRestrictions() requires minSdkVersion >= 18\n        if (!Utilities.ATLEAST_JB_MR2) {\n            return null;\n        }\n\n        Context ctx = getContext();\n        UserManager um = (UserManager) ctx.getSystemService(Context.USER_SERVICE);\n        Bundle bundle = um.getApplicationRestrictions(ctx.getPackageName());\n        if (bundle == null) {\n            return null;\n        }\n\n        String packageName = bundle.getString(RESTRICTION_PACKAGE_NAME);\n        if (packageName != null) {\n            try {\n                Resources targetResources = ctx.getPackageManager()\n                        .getResourcesForApplication(packageName);\n                return AutoInstallsLayout.get(ctx, packageName, targetResources,\n                        mOpenHelper.mAppWidgetHost, mOpenHelper);\n            } catch (NameNotFoundException e) {\n                Log.e(TAG, \"Target package for restricted profile not found\", e);\n                return null;\n            }\n        }\n        return null;\n    }\n","new_comment_raw":"@return the loader if the restrictions are set and the resource exists; null otherwise.","old_comment_raw":"@return the loader if the restrictions are set and the resource exists; null otherwise.","label":0,"pre_label":1,"AST_level":10,"line_counts":28,"new_code_token_num":144},{"new_code_raw":"public boolean isConnected() { return !disposed.get(); }","old_code_raw":"    public boolean isConnected() {\n        return !disposed;\n    }\n","new_comment_raw":"@return true if the Connection is connected","old_comment_raw":"@return true if the Connection is connected","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":14},{"new_code_raw":"public int getTerminalCount() { return activeTerminalToolbarButton_.terminalCount(); }","old_code_raw":"public int getTerminalCount() {\n    return terminalSessionsPanel_.getWidgetCount();\n}","new_comment_raw":"@return number of terminals in the dropdown","old_comment_raw":"@return number of terminals hosted by the pane","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":13},{"new_code_raw":"@SuppressWarnings(STR) public double getReal() { return (double) getFirstValue(); }","old_code_raw":"@SuppressWarnings(STR)\npublic double getReal(final int i) {\n    return (double) getFirstValue(i);\n}","new_comment_raw":"@return item in first position","old_comment_raw":"@return item in given position","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"private Timestamp[] getTimeframe() { Timestamp oldest = Timestamp.ZERO.plus(1000000); Timestamp newest = Timestamp.ZERO; for (Habit h : selectedHabits) { if(h.getRepetitions().getOldest() == null || h.getRepetitions().getNewest() == null) continue; Timestamp currOld = h.getRepetitions().getOldest().getTimestamp(); Timestamp currNew = h.getRepetitions().getNewest().getTimestamp(); oldest = currOld.isOlderThan(oldest) ? oldest : currOld; newest = currNew.isNewerThan(newest) ? newest : currNew; } return new Timestamp[]{oldest, newest}; }","old_code_raw":"    private long[] getTimeframe()\n    {\n        long oldest = Long.MAX_VALUE;\n        long newest = -1;\n        for (Habit h : selectedHabits)\n        {\n            if(h.getRepetitions().getOldest() == null || h.getRepetitions().getNewest() == null)\n                continue;\n            long currOld = h.getRepetitions().getOldest().getTimestamp();\n            long currNew = h.getRepetitions().getNewest().getTimestamp();\n            oldest = currOld > oldest ? oldest : currOld;\n            newest = currNew < newest ? newest : currNew;\n        }\n        return new long[]{oldest, newest};\n    }\n","new_comment_raw":"@return the timeframe containing the oldest timestamp and the newest timestamp","old_comment_raw":"@return the timeframe containing the oldest timestamp and the newest timestamp","label":0,"pre_label":1,"AST_level":9,"line_counts":16,"new_code_token_num":114},{"new_code_raw":"boolean shouldShowSelector() { return ((hasFocus() && !isInTouchMode()) || touchModeDrawsInPressedState()) && ( mBeginClick ) ; }","old_code_raw":"    boolean shouldShowSelector() {\n        return (hasFocus() && !isInTouchMode()) || touchModeDrawsInPressedState();\n    }\n","new_comment_raw":"@return True if the selector should be shown","old_comment_raw":"@return True if the selector should be shown","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":31},{"new_code_raw":"SQLException getBatchCounts(ArrayList counts, SQLException sqlEx) { Integer lastCount = JtdsStatement.SUCCESS_NO_INFO; try { checkOpen(); while (!endOfResponse) { nextToken(); if (currentToken.isResultSet()) { throw new SQLException(Messages.get(STR), STR); } switch(currentToken.token) { case TDS_DONE_TOKEN: if ((currentToken.status & DONE_ERROR) != NUM || lastCount == JtdsStatement.EXECUTE_FAILED) { if (connection.getServerType() == Driver.SYBASE) { counts.add(JtdsStatement.EXECUTE_FAILED); } } else { if (currentToken.isUpdateCount()) { counts.add(new Integer(currentToken.updateCount)); } else { counts.add(lastCount); } } lastCount = JtdsStatement.SUCCESS_NO_INFO; break; case TDS_DONEINPROC_TOKEN: if ((currentToken.status & DONE_ERROR) != NUM) { lastCount = JtdsStatement.EXECUTE_FAILED; } else if (currentToken.isUpdateCount()) { lastCount = new Integer(currentToken.updateCount); } break; case TDS_DONEPROC_TOKEN: if ((currentToken.status & DONE_ERROR) != NUM || lastCount == JtdsStatement.EXECUTE_FAILED) { if (connection.getServerType() == Driver.SYBASE) { counts.add(JtdsStatement.EXECUTE_FAILED); } } else { counts.add(lastCount); } lastCount = JtdsStatement.SUCCESS_NO_INFO; break; } } messages.checkErrors(); } catch (SQLException e) { if (sqlEx != null) { sqlEx.setNextException(e); } else { sqlEx = e; } } finally { while (!endOfResponse) { try { nextToken(); } catch (SQLException ex) { if (sqlEx != null) { sqlEx.setNextException(ex); } else { sqlEx = ex; } } } } return sqlEx; }","old_code_raw":"int[] getBatchCounts() throws BatchUpdateException {\n    ArrayList counts = new ArrayList();\n    Integer lastCount = JtdsStatement.SUCCESS_NO_INFO;\n    BatchUpdateException batchEx = null;\n    try {\n        checkOpen();\n        while (!endOfResponse) {\n            nextToken();\n            if (currentToken.isResultSet()) {\n                throw new SQLException(Messages.get(STR), STR);\n            }\n            switch(currentToken.token) {\n                case TDS_DONE_TOKEN:\n                    if ((currentToken.status & DONE_ERROR) != NUM) {\n                        counts.add(JtdsStatement.EXECUTE_FAILED);\n                    } else {\n                        if (currentToken.isUpdateCount()) {\n                            counts.add(new Integer(currentToken.updateCount));\n                        } else {\n                            counts.add(lastCount);\n                        }\n                    }\n                    lastCount = JtdsStatement.SUCCESS_NO_INFO;\n                    break;\n                case TDS_DONEINPROC_TOKEN:\n                    if ((currentToken.status & DONE_ERROR) != NUM) {\n                        lastCount = JtdsStatement.EXECUTE_FAILED;\n                    } else if (currentToken.isUpdateCount()) {\n                        lastCount = new Integer(currentToken.updateCount);\n                    }\n                    break;\n                case TDS_DONEPROC_TOKEN:\n                    if ((currentToken.status & DONE_ERROR) != NUM) {\n                        counts.add(JtdsStatement.EXECUTE_FAILED);\n                    } else {\n                        counts.add(lastCount);\n                    }\n                    lastCount = JtdsStatement.SUCCESS_NO_INFO;\n                    break;\n            }\n        }\n        messages.checkErrors();\n    } catch (SQLException e) {\n        int[] results = new int[counts.size()];\n        for (int i = NUM; i < results.length; i++) {\n            results[i] = ((Integer) counts.get(i)).intValue();\n        }\n        batchEx = new BatchUpdateException(e.getMessage(), e.getSQLState(), e.getErrorCode(), results);\n        throw batchEx;\n    } finally {\n        while (!endOfResponse) {\n            try {\n                nextToken();\n            } catch (SQLException ex) {\n                if (batchEx != null) {\n                    batchEx.setNextException(ex);\n                }\n            }\n        }\n    }\n    int[] results = new int[counts.size()];\n    for (int i = NUM; i < results.length; i++) {\n        results[i] = ((Integer) counts.get(i)).intValue();\n    }\n    return results;\n}","new_comment_raw":"@return updated <code>SQLException<\/code> or <code>null<\/code> if no error has yet occured","old_comment_raw":"@return the update counts as an <code>int[]<\/code>","label":1,"pre_label":0,"AST_level":15,"line_counts":65,"new_code_token_num":313},{"new_code_raw":"public MethodInfo createMethod(MemberID memberID, String[] argNames) { return createMethod(memberID, argNames, null); }","old_code_raw":"public MethodInfo createMethod(Signature signature, String[] argNames) {\n    return createMethod(signature, argNames, null);\n}","new_comment_raw":"@return the new method or an existing method with that memberID.","old_comment_raw":"@return the new method or an existing method with that signature.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":24},{"new_code_raw":"public static List<Point> convexHull(List<Point> points) { int[] xs = new int[points.size()]; int[] ys = new int[xs.length]; for (int i = 0; i < xs.length; i++) { Point p = points.get(i); xs[i] = p.getX(); ys[i] = p.getY(); } SimplePolygon poly = convexHull(xs, ys); if (poly == null) { return null; } return poly.toRuneLitePointList(); }","old_code_raw":"\tpublic static List<Point> convexHull(List<Point> points)\n\t{\n\t\tif (points.size() < 3)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tList<Point> ch = new ArrayList<>();\n\n\t\t\/\/ find the left most point\n\t\tPoint left = findLeftMost(points);\n\n\t\t\/\/ current point we are on\n\t\tPoint current = left;\n\n\t\tdo\n\t\t{\n\t\t\tch.add(current);\n\t\t\tassert ch.size() <= points.size() : \"hull has more points than graph\";\n\t\t\tif (ch.size() > points.size())\n\t\t\t{\n\t\t\t\t\/\/ Just to make sure we never somehow get stuck in this loop\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t\/\/ the next point - all points are to the right of the\n\t\t\t\/\/ line between current and next\n\t\t\tPoint next = null;\n\n\t\t\tfor (Point p : points)\n\t\t\t{\n\t\t\t\tif (next == null)\n\t\t\t\t{\n\t\t\t\t\tnext = p;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlong cp = crossProduct(current, p, next);\n\t\t\t\tif (cp > 0 || (cp == 0 && current.distanceTo(p) > current.distanceTo(next)))\n\t\t\t\t{\n\t\t\t\t\tnext = p;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\/\/ Points can be null if they are behind or very close to the camera.\n\t\t\tif (next == null)\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tcurrent = next;\n\t\t}\n\t\twhile (current != left);\n\n\t\treturn ch;\n\t}\n","new_comment_raw":"@return list containing the points part of the convex hull","old_comment_raw":"@return list containing the points part of the convex hull","label":0,"pre_label":1,"AST_level":9,"line_counts":20,"new_code_token_num":103},{"new_code_raw":"public LookupService createLookupService() { return createLookupService(defaultEndpointUrl); }","old_code_raw":"public LookupService createLookupService() {\n    return createLookupService(defaultServerUrl);\n}","new_comment_raw":"@return a new lookup service with the default endpoint URL","old_comment_raw":"@return a new lookup service with the default server URL","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":13},{"new_code_raw":"public Object getValue(String columnName, String columnType, Value rawValue, final PgConnectionSupplier connection) { if (rawValue.isNull()) { \/\/ nulls are null return null; } \/\/ we support wal2json both before & after commit 0255f2ac, which means we may get old-style type names \/\/ (eg. int2, timetz, varchar, numeric, _int4) \/\/ or new-style\/verbose ones \/\/ (eg. smallint; time with time zone; character varying (255); decimal (10,3), integer[]) Matcher m = TYPE_PATTERN.matcher(columnType); if (!m.matches()) { LOGGER.error(\"Failed to parse columnType for {} '{}'\", columnName, columnType); throw new ConnectException(String.format(\"Failed to parse columnType '%s' for column %s\", columnType, columnName)); } String fullType = m.group(\"full\"); String baseType = m.group(\"base\").trim(); if (!Objects.toString(m.group(\"suffix\"), \"\").isEmpty()) { baseType = String.join(\" \", baseType, m.group(\"suffix\").trim()); } String[] typeModifiers = NO_TYPE_MODIFIERS; if (m.group(\"mod\") != null) { typeModifiers = TYPEMOD_PATTERN.split(m.group(\"mod\")); \/\/ TODO: use for decimal\/etc precision } boolean isArray = (m.group(\"array\") != null); if (baseType.startsWith(\"_\")) { \/\/ old-style type specifiers use an _ prefix for arrays \/\/ e.g. int4[] would be \"_int4\" baseType = baseType.substring(1); fullType = fullType.substring(1); isArray = true; } if (isArray) { try { final String dataString = rawValue.asString(); PgArray arrayData = new PgArray(connection.get(), connection.get().getTypeInfo().getPGArrayType(fullType), dataString); Object deserializedArray = arrayData.getArray(); \/\/ TODO: what types are these? Shouldn't they pass through this function again? return Arrays.asList((Object[])deserializedArray); } catch (SQLException e) { LOGGER.warn(\"Unexpected exception trying to process PgArray ({}) column '{}', {}\", columnType, columnName, e); } return null; } switch (baseType) { \/\/ include all types from https:\/\/www.postgresql.org\/docs\/current\/static\/datatype.html#DATATYPE-TABLE \/\/ plus aliases from the shorter names produced by older wal2json case \"boolean\": case \"bool\": return rawValue.asBoolean(); case \"integer\": case \"int\": case \"int4\": case \"smallint\": case \"int2\": case \"smallserial\": case \"serial\": case \"serial2\": case \"serial4\": case \"oid\": return rawValue.asInteger(); case \"bigint\": case \"bigserial\": case \"int8\": return rawValue.asLong(); case \"real\": case \"float4\": return rawValue.asFloat(); case \"double precision\": case \"float8\": return rawValue.asDouble(); case \"numeric\": case \"decimal\": \/\/ TODO: Support for Decimal\/Numeric types with correct scale+precision return rawValue.asDouble(); case \"character\": case \"char\": case \"character varying\": case \"varchar\": case \"bpchar\": case \"text\": return rawValue.asString(); case \"date\": return DateTimeFormat.get().date(rawValue.asString()); case \"timestamp with time zone\": case \"timestamptz\": return DateTimeFormat.get().timestampWithTimeZone(rawValue.asString()); case \"timestamp\": case \"timestamp without time zone\": return DateTimeFormat.get().timestamp(rawValue.asString()); case \"time\": case \"time without time zone\": return DateTimeFormat.get().time(rawValue.asString()); case \"time with time zone\": case \"timetz\": return DateTimeFormat.get().timeWithTimeZone(rawValue.asString()); case \"bytea\": return Strings.hexStringToByteArray(rawValue.asString()); \/\/ these are all PG-specific types and we use the JDBC representations case \"box\": try { return new PGbox(rawValue.asString()); } catch (final SQLException e) { LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e); throw new ConnectException(e); } case \"circle\": try { return new PGcircle(rawValue.asString()); } catch (final SQLException e) { LOGGER.error(\"Failed to parse circle {}, {}\", rawValue.asString(), e); throw new ConnectException(e); } case \"interval\": try { return new PGInterval(rawValue.asString()); } catch (final SQLException e) { LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e); throw new ConnectException(e); } case \"line\": try { return new PGline(rawValue.asString()); } catch (final SQLException e) { LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e); throw new ConnectException(e); } case \"lseg\": try { return new PGlseg(rawValue.asString()); } catch (final SQLException e) { LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e); throw new ConnectException(e); } case \"money\": try { return new PGmoney(rawValue.asString()).val; } catch (final SQLException e) { LOGGER.error(\"Failed to parse money {}, {}\", rawValue.asString(), e); throw new ConnectException(e); } case \"path\": try { return new PGpath(rawValue.asString()); } catch (final SQLException e) { LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e); throw new ConnectException(e); } case \"point\": try { return new PGpoint(rawValue.asString()); } catch (final SQLException e) { LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e); throw new ConnectException(e); } case \"polygon\": try { return new PGpolygon(rawValue.asString()); } catch (final SQLException e) { LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e); throw new ConnectException(e); } case \"bit\": case \"bit varying\": case \"varbit\": case \"json\": case \"jsonb\": case \"xml\": case \"uuid\": case \"tstzrange\": return rawValue.asString(); \/\/ catch-all for other known\/builtin PG types \/\/ TODO: improve with more specific\/useful classes here? case \"cidr\": case \"inet\": case \"macaddr\": case \"macaddr8\": case \"pg_lsn\": case \"tsquery\": case \"tsvector\": case \"txid_snapshot\": \/\/ catch-all for unknown (extension module\/custom) types default: break; } return null; }","old_code_raw":"    public Object getValue(String columnName, String columnType, Value rawValue, final PgConnectionSupplier connection) {\n        if (rawValue.isNull()) {\n            \/\/ nulls are null\n            return null;\n        }\n\n        \/\/ we support wal2json both before & after commit 0255f2ac, which means we may get old-style type names\n        \/\/ (eg. int2, timetz, varchar, numeric, _int4)\n        \/\/ or new-style\/verbose ones\n        \/\/ (eg. smallint; time with time zone; character varying (255); decimal (10,3), integer[])\n\n        Matcher m = TYPE_PATTERN.matcher(columnType);\n        if (!m.matches()) {\n            LOGGER.error(\"Failed to parse columnType for {} '{}'\", columnName, columnType);\n            throw new ConnectException(String.format(\"Failed to parse columnType '%s' for column %s\", columnType, columnName));\n        }\n        String fullType = m.group(\"full\");\n        String baseType = m.group(\"base\").trim();\n        if (!Objects.toString(m.group(\"suffix\"), \"\").isEmpty()) {\n            baseType = String.join(\" \", baseType, m.group(\"suffix\").trim());\n        }\n\n        String[] typeModifiers = NO_TYPE_MODIFIERS;\n        if (m.group(\"mod\") != null) {\n            typeModifiers = TYPEMOD_PATTERN.split(m.group(\"mod\"));  \/\/ TODO: use for decimal\/etc precision\n        }\n        boolean isArray = (m.group(\"array\") != null);\n\n        if (baseType.startsWith(\"_\")) {\n            \/\/ old-style type specifiers use an _ prefix for arrays\n            \/\/ e.g. int4[] would be \"_int4\"\n            baseType = baseType.substring(1);\n            fullType = fullType.substring(1);\n            isArray = true;\n        }\n\n        if (isArray) {\n            try {\n                final String dataString = rawValue.asString();\n                PgArray arrayData = new PgArray(connection.get(), connection.get().getTypeInfo().getPGArrayType(fullType), dataString);\n                Object deserializedArray = arrayData.getArray();\n                \/\/ TODO: what types are these? Shouldn't they pass through this function again?\n                return Arrays.asList((Object[])deserializedArray);\n            }\n            catch (SQLException e) {\n                LOGGER.warn(\"Unexpected exception trying to process PgArray ({}) column '{}', {}\", columnType, columnName, e);\n            }\n            return null;\n        }\n\n        switch (baseType) {\n            \/\/ include all types from https:\/\/www.postgresql.org\/docs\/current\/static\/datatype.html#DATATYPE-TABLE\n            \/\/ plus aliases from the shorter names produced by older wal2json\n            case \"boolean\":\n            case \"bool\":\n                return rawValue.asBoolean();\n\n            case \"integer\":\n            case \"int\":\n            case \"int4\":\n            case \"smallint\":\n            case \"int2\":\n            case \"smallserial\":\n            case \"serial\":\n            case \"serial2\":\n            case \"serial4\":\n            case \"oid\":\n                return rawValue.asInteger();\n\n            case \"bigint\":\n            case \"bigserial\":\n            case \"int8\":\n                return rawValue.asLong();\n\n            case \"real\":\n            case \"float4\":\n                return rawValue.asFloat();\n\n            case \"double precision\":\n            case \"float8\":\n                return rawValue.asDouble();\n\n            case \"numeric\":\n            case \"decimal\":\n                \/\/ TODO: Support for Decimal\/Numeric types with correct scale+precision\n                return rawValue.asDouble();\n\n            case \"character\":\n            case \"char\":\n            case \"character varying\":\n            case \"varchar\":\n            case \"bpchar\":\n            case \"text\":\n                return rawValue.asString();\n\n            case \"date\":\n                return DateTimeFormat.get().date(rawValue.asString());\n\n            case \"timestamp with time zone\":\n            case \"timestamptz\":\n                return DateTimeFormat.get().timestampWithTimeZone(rawValue.asString());\n\n            case \"timestamp\":\n            case \"timestamp without time zone\":\n                return DateTimeFormat.get().timestamp(rawValue.asString());\n\n            case \"time\":\n            case \"time without time zone\":\n                return DateTimeFormat.get().time(rawValue.asString());\n\n            case \"time with time zone\":\n            case \"timetz\":\n                return DateTimeFormat.get().timeWithTimeZone(rawValue.asString());\n\n            case \"bytea\":\n                return Strings.hexStringToByteArray(rawValue.asString());\n\n            \/\/ these are all PG-specific types and we use the JDBC representations\n            case \"box\":\n                try {\n                    return new PGbox(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"circle\":\n                try {\n                    return new PGcircle(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse circle {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"interval\":\n                try {\n                    return new PGInterval(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"line\":\n                try {\n                    return new PGline(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"lseg\":\n                try {\n                    return new PGlseg(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"money\":\n                try {\n                    return new PGmoney(rawValue.asString()).val;\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse money {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"path\":\n                try {\n                    return new PGpath(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"point\":\n                try {\n                    return new PGpoint(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n            case \"polygon\":\n                try {\n                    return new PGpolygon(rawValue.asString());\n                } catch (final SQLException e) {\n                    LOGGER.error(\"Failed to parse point {}, {}\", rawValue.asString(), e);\n                    throw new ConnectException(e);\n                }\n\n            \/\/ catch-all for other known\/builtin PG types\n            \/\/ TODO: improve with more specific\/useful classes here?\n            case \"bit\":\n            case \"bit varying\":\n            case \"varbit\":\n            case \"cidr\":\n            case \"inet\":\n            case \"json\":\n            case \"jsonb\":\n            case \"macaddr\":\n            case \"macaddr8\":\n            case \"pg_lsn\":\n            case \"tsquery\":\n            case \"tstzrange\":\n            case \"tsvector\":\n            case \"txid_snapshot\":\n            case \"uuid\":\n            case \"xml\":\n            \/\/ catch-all for unknown (extension module\/custom) types\n            default:\n                break;\n        }\n        \/\/ this includes things like PostGIS geometries or other custom types.\n        \/\/ leave up to the downstream message recipient to deal with.\n        LOGGER.warn(\"processing column '{}' with unknown data type '{}' as byte array\", columnName,\n                columnType);\n        return rawValue.asString();\n    }\n","new_comment_raw":"@return the value; may be null","old_comment_raw":"@return the value; may be null","label":0,"pre_label":1,"AST_level":11,"line_counts":209,"new_code_token_num":1504},{"new_code_raw":"public boolean searchText(String regex, int matches, boolean scroll) { return searcher.searchText(regex, matches, scroll); }","old_code_raw":"\tpublic boolean searchText(String search, int matches, boolean scroll) {\n\t\treturn searcher.searchText(search, matches, scroll);\n\t}\n","new_comment_raw":"@return  true if regex string is found a given number of times and  false if the regex string is not found","old_comment_raw":"@return true if search string is found a given number of times and false if the search string is not found","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":26},{"new_code_raw":"public boolean scrollUpList(int listIndex) { return scrollList(listIndex, Direction.UP); }","old_code_raw":"\tpublic boolean scrollUpList(int listIndex)\n\t{\n\t\treturn scrollList(listIndex, UP);\n\t}\n","new_comment_raw":"@return  true if more scrolling can be done","old_comment_raw":"@return true if more scrolling can be done","label":0,"pre_label":1,"AST_level":5,"line_counts":5,"new_code_token_num":18},{"new_code_raw":"private ConnectionContainer upsertObjects(Environment context) { if (context.ids.isPresent()) { throw new BadRequestException(STR); } if (!context.data.isPresent()) { throw new BadRequestException(STR); } Class<?> entityClass; EntityDictionary dictionary = context.requestScope.getDictionary(); if (context.isRoot()) { entityClass = dictionary.getEntityClass(context.field.getName()); } else { entityClass = dictionary.getParameterizedType(context.parentResource.getResourceClass(), context.field.getName()); } Optional<Entity> parentEntity; if (!context.isRoot()) { parentEntity = Optional.of(new Entity(Optional.empty(), null, context.parentResource.getResourceClass(), context.requestScope)); } else { parentEntity = Optional.empty(); } LinkedHashSet<Entity> entitySet = new LinkedHashSet<>(); for (Map<String, Object> input : context.data.get()) { entitySet.add(new Entity(parentEntity, input, entityClass, context.requestScope)); } for (Entity entity : entitySet) { graphWalker(entity, (e) -> upsertObject(context, e)); } for (Entity entity : entitySet) { graphWalker(entity, this::updateRelationship); if (!context.isRoot()) { context.parentResource.addRelation(context.field.getName(), entity.toPersistentResource()); } } String entityName = dictionary.getJsonAliasFor(entityClass); Set<PersistentResource> resources = entitySet.stream().map(Entity::toPersistentResource).collect(Collectors.toCollection(LinkedHashSet::new)); return new ConnectionContainer(resources, Optional.empty(), entityName); }","old_code_raw":"private Set<PersistentResource> upsertObjects(Environment context) {\n    if (context.ids.isPresent()) {\n        throw new BadRequestException(STR);\n    }\n    if (!context.data.isPresent()) {\n        throw new BadRequestException(STR);\n    }\n    Class<?> entityClass;\n    EntityDictionary dictionary = context.requestScope.getDictionary();\n    if (context.isRoot()) {\n        entityClass = dictionary.getEntityClass(context.field.getName());\n    } else {\n        entityClass = dictionary.getParameterizedType(context.parentResource.getResourceClass(), context.field.getName());\n    }\n    Optional<Entity> parentEntity;\n    if (!context.isRoot()) {\n        parentEntity = Optional.of(new Entity(Optional.empty(), null, context.parentResource.getResourceClass(), context.requestScope));\n    } else {\n        parentEntity = Optional.empty();\n    }\n    LinkedHashSet<Entity> entitySet = new LinkedHashSet<>();\n    for (Map<String, Object> input : context.data.get()) {\n        entitySet.add(new Entity(parentEntity, input, entityClass, context.requestScope));\n    }\n    for (Entity entity : entitySet) {\n        graphWalker(entity, this::upsertObject);\n    }\n    for (Entity entity : entitySet) {\n        graphWalker(entity, this::updateRelationship);\n        if (!context.isRoot()) {\n            context.parentResource.addRelation(context.field.getName(), entity.toPersistentResource());\n        }\n    }\n    return entitySet.stream().map(Entity::toPersistentResource).collect(Collectors.toCollection(LinkedHashSet::new));\n}","new_comment_raw":"@return Connection object.","old_comment_raw":"@return list of {@link PersistentResource} objects","label":1,"pre_label":0,"AST_level":9,"line_counts":37,"new_code_token_num":303},{"new_code_raw":"public Field withDefault(BooleanSupplier defaultValueGenerator) { return new Field(name(), displayName(), type(), width, description(), importance(), dependents, defaultValueGenerator::getAsBoolean, validator, recommender); }","old_code_raw":"    public Field withDefault(BooleanSupplier defaultValueGenerator) {\n        return Field.create(name(), description(), defaultValueGenerator);\n    }\n","new_comment_raw":"@return the new field; never null","old_comment_raw":"@return the new field; never null","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":47},{"new_code_raw":"public Lock readLock() { return getGraph().getLock().readLock(); }","old_code_raw":"public Lock readLock() {\n    if (getGraph() instanceof LockableMGraph) {\n        return ((LockableMGraph) getGraph()).getLock().readLock();\n    }\n    return new FakeLock();\n}","new_comment_raw":"@return a ReadLock if the underlying ImmutableGraph is a LockableGraph it returns its lock, otherwise null","old_comment_raw":"@return a ReadLock if the underlying Graph is a LockableMGraph it returns its lock, otherwise null","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":18},{"new_code_raw":"public List<ScoredObject<Tree>> getKBestParses(int k) { if (parseSkipped) { return null; } if (bparser != null && parseSucceeded) { \/\/The getKGoodParses seems to be broken, so just return the best parse Tree binaryTree = bparser.getBestParse(); Tree tree = debinarizer.transformTree(binaryTree); if (op.nodePrune) { NodePruner np = new NodePruner(pparser, debinarizer); tree = np.prune(tree); } tree = subcategoryStripper.transformTree(tree); restoreOriginalWords(tree); double score = dparser.getBestScore(); ScoredObject<Tree> so = new ScoredObject<>(tree, score); List<ScoredObject<Tree>> trees = new ArrayList<>(1); trees.add(so); return trees; } else if (pparser != null && pparser.hasParse() && fallbackToPCFG) { return this.getKBestPCFGParses(k); } else if (dparser != null && dparser.hasParse()) { \/\/ && fallbackToDG \/\/ The dependency parser doesn't support k-best parse extraction, so just \/\/ return the best parse Tree tree = this.getBestDependencyParse(true); double score = dparser.getBestScore(); ScoredObject<Tree> so = new ScoredObject<>(tree, score); List<ScoredObject<Tree>> trees = new ArrayList<>(1); trees.add(so); return trees; } else { throw new NoSuchParseException(); } }","old_code_raw":"  public List<ScoredObject<Tree>> getKBestParses(int k) {\n    if (parseSkipped) {\n      return null;\n    }\n    if (bparser != null && parseSucceeded) {\n     return this.getKGoodFactoredParses(k);\n    } else if (pparser != null && pparser.hasParse() && fallbackToPCFG) {\n      return this.getKBestPCFGParses(k);\n    } else if (dparser != null && dparser.hasParse()) { \/\/ && fallbackToDG\n      \/\/ The dependency parser doesn't support k-best parse extraction, so just\n      \/\/ return the best parse\n      Tree tree = this.getBestDependencyParse(true);\n      double score = dparser.getBestScore();\n      ScoredObject<Tree> so = new ScoredObject<>(tree, score);\n      List<ScoredObject<Tree>> trees = new ArrayList<>(1);\n      trees.add(so);\n      return trees;\n    } else {\n      throw new NoSuchParseException();\n    }\n  }\n","new_comment_raw":"@return A list of scored trees","old_comment_raw":"@return A list of scored trees","label":0,"pre_label":1,"AST_level":12,"line_counts":37,"new_code_token_num":256},{"new_code_raw":"public LSN restart() throws BabuDBException { if (!this.stopped) throw new BabuDBException(ErrorCode.IO_ERROR, STR); databaseManager.reset(); dbCheckptr = new CheckpointerImpl(this); LSN dbLsn = null; LSN zero = new LSN(NUM, NUM); for (Database dbRaw : databaseManager.getDatabaseList()) { DatabaseImpl db = (DatabaseImpl) dbRaw; LSN onDisk = db.getLSMDB().getOndiskLSN(); if (dbLsn == null && !onDisk.equals(zero)) dbLsn = onDisk; else if (dbLsn != null) { if (!onDisk.equals(zero) && !dbLsn.equals(onDisk)) throw new RuntimeException(STR + dbLsn.toString() + STR + db.getLSMDB().getOndiskLSN().toString()); } } if (dbLsn == null) { dbLsn = new LSN(NUM, NUM); } else { dbLsn = new LSN(dbLsn.getViewId(), dbLsn.getSequenceNo() + NUM); } Logging.logMessage(Logging.LEVEL_INFO, this, STR); LSN nextLSN = replayLogs(dbLsn); if (dbLsn.compareTo(nextLSN) > NUM) { nextLSN = dbLsn; } Logging.logMessage(Logging.LEVEL_INFO, this, STR + nextLSN); try { logger = new DiskLogger(configuration.getDbLogDir(), nextLSN.getViewId(), nextLSN.getSequenceNo() + NUM, configuration.getSyncMode(), configuration.getPseudoSyncWait(), configuration.getMaxQueueLength() * configuration.getNumThreads()); logger.start(); } catch (IOException ex) { throw new BabuDBException(ErrorCode.IO_ERROR, STR, ex); } worker = new LSMDBWorker[configuration.getNumThreads()]; for (int i = NUM; i < configuration.getNumThreads(); i++) { worker[i] = new LSMDBWorker(logger, i, (configuration.getPseudoSyncWait() > NUM), configuration.getMaxQueueLength(), replicationManager); worker[i].start(); } dbCheckptr.init(logger, configuration.getCheckInterval(), configuration.getMaxLogfileSize()); dbCheckptr.start(); Logging.logMessage(Logging.LEVEL_INFO, this, STR + STR + BABUDB_VERSION + STR); this.stopped = false; return new LSN(nextLSN.getViewId(), nextLSN.getSequenceNo()); }","old_code_raw":"public LSN restart() throws BabuDBException {\n    databaseManager.reset();\n    dbCheckptr = new CheckpointerImpl(this);\n    LSN dbLsn = null;\n    LSN zero = new LSN(NUM, NUM);\n    for (Database dbRaw : databaseManager.getDatabaseList()) {\n        DatabaseImpl db = (DatabaseImpl) dbRaw;\n        LSN onDisk = db.getLSMDB().getOndiskLSN();\n        if (dbLsn == null && !onDisk.equals(zero))\n            dbLsn = onDisk;\n        else if (dbLsn != null) {\n            if (!onDisk.equals(zero) && !dbLsn.equals(onDisk))\n                throw new RuntimeException(STR + dbLsn.toString() + STR + db.getLSMDB().getOndiskLSN().toString());\n        }\n    }\n    if (dbLsn == null) {\n        dbLsn = new LSN(NUM, NUM);\n    } else {\n        dbLsn = new LSN(dbLsn.getViewId(), dbLsn.getSequenceNo() + NUM);\n    }\n    Logging.logMessage(Logging.LEVEL_INFO, this, STR);\n    LSN nextLSN = replayLogs(dbLsn);\n    if (dbLsn.compareTo(nextLSN) > NUM) {\n        nextLSN = dbLsn;\n    }\n    Logging.logMessage(Logging.LEVEL_INFO, this, STR + nextLSN);\n    try {\n        logger = new DiskLogger(configuration.getDbLogDir(), nextLSN.getViewId(), nextLSN.getSequenceNo() + NUM, configuration.getSyncMode(), configuration.getPseudoSyncWait(), configuration.getMaxQueueLength() * configuration.getNumThreads());\n        logger.start();\n    } catch (IOException ex) {\n        throw new BabuDBException(ErrorCode.IO_ERROR, STR, ex);\n    }\n    worker = new LSMDBWorker[configuration.getNumThreads()];\n    for (int i = NUM; i < configuration.getNumThreads(); i++) {\n        worker[i] = new LSMDBWorker(logger, i, (configuration.getPseudoSyncWait() > NUM), configuration.getMaxQueueLength(), replicationManager);\n        worker[i].start();\n    }\n    dbCheckptr.init(logger, configuration.getCheckInterval(), configuration.getMaxLogfileSize());\n    dbCheckptr.start();\n    Logging.logMessage(Logging.LEVEL_INFO, this, STR + BABUDB_VERSION + STR);\n    return new LSN(nextLSN.getViewId(), nextLSN.getSequenceNo() - NUM);\n}","new_comment_raw":"@return the next LSN.","old_comment_raw":"@return the latest loaded LSN.","label":1,"pre_label":0,"AST_level":14,"line_counts":45,"new_code_token_num":417},{"new_code_raw":"public static MatchFinder anyOf(final MatchFinder... finders) { return new MatchFinder() { @Override public boolean matches(UiElement element) { for (MatchFinder finder : finders) { if (finder.matches(element)) { return true; } } return false; } @Override public String toString() { return STR + Joiner.on(STR).join(finders) + STR; } }; }","old_code_raw":"public static ElementMatcher anyOf(final ElementMatcher... matchers) {\n    return new ElementMatcher() {\n\n        @Override\n        public boolean matches(UiElement element) {\n            for (ElementMatcher matcher : matchers) {\n                if (matcher.matches(element)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        @Override\n        public String toString() {\n            return STR + Joiner.on(STR).join(matchers) + STR;\n        }\n    };\n}","new_comment_raw":"@return a finder that is the logical disjunction of given finders","old_comment_raw":"@return a matcher that is the logical disjunction of given matchers","label":1,"pre_label":0,"AST_level":11,"line_counts":19,"new_code_token_num":79},{"new_code_raw":"public List<Expression> translateList(List<? extends RexNode> operandList) { return translateList(operandList, EnumUtils.internalTypes(operandList)); }","old_code_raw":"  public List<Expression> translateList(List<? extends RexNode> operandList) {\n    return translateList(operandList, null);\n  }\n","new_comment_raw":"@return translated expressions","old_comment_raw":"@return translated expressions","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":25},{"new_code_raw":"public Collection<Tree> getRelatedNodes(Tree t, Tree root) { if (root.value() == null) { root.setValue(\"ROOT\"); \/\/ todo: cdm: it doesn't seem like this line should be here } Set<Tree> nodeList = new LinkedHashSet<Tree>(); for (TregexPattern p : targetPatterns) { \/\/ cdm: I deleted: && nodeList.isEmpty() TregexMatcher m = p.matcher(root); while (m.findAt(t)) { nodeList.add(m.getNode(\"target\")); if (DEBUG) { System.err.println(\"found \" + this + \"(\" + t + \", \" + m.getNode(\"target\") + \") using pattern \" + p); for (String nodeName : m.getNodeNames()) { if (nodeName.equals(\"target\")) continue; System.err.println(\" node \" + nodeName + \": \" + m.getNode(nodeName)); } } } } return nodeList; }","old_code_raw":"  public Collection<TreeGraphNode> getRelatedNodes(TreeGraphNode t, TreeGraphNode root, HeadFinder headFinder) {\n    Set<TreeGraphNode> nodeList = new ArraySet<>();\n    for (TregexPattern p : targetPatterns) {    \/\/ cdm: I deleted: && nodeList.isEmpty()\n      \/\/ Initialize the TregexMatcher with the HeadFinder so that we\n      \/\/ can use the same HeadFinder through the entire process of\n      \/\/ building the dependencies\n      TregexMatcher m = p.matcher(root, headFinder);\n      while (m.findAt(t)) {\n        TreeGraphNode target = (TreeGraphNode) m.getNode(\"target\");\n        if (target == null) {\n          throw new AssertionError(\"Expression has no target: \" + p);\n        }\n        nodeList.add(target);\n        if (DEBUG) {\n          System.err.println(\"found \" + this + \"(\" + t + \"-\" + t.headWordNode() + \", \" + m.getNode(\"target\") + \"-\" + ((TreeGraphNode) m.getNode(\"target\")).headWordNode() + \") using pattern \" + p);\n          for (String nodeName : m.getNodeNames()) {\n            if (nodeName.equals(\"target\"))\n              continue;\n            System.err.println(\"  node \" + nodeName + \": \" + m.getNode(nodeName));\n          }\n        }\n      }\n    }\n    return nodeList;\n  }\n","new_comment_raw":"@return Governor nodes to which t bears this GR","old_comment_raw":"@return A Collection of dependent nodes to which t bears this GR","label":1,"pre_label":0,"AST_level":18,"line_counts":22,"new_code_token_num":200},{"new_code_raw":"public int _offsetToX(int line, int offset) { return super._offsetToX(line, offset) + LEFT_GUTTER; }","old_code_raw":"  public int _offsetToX(int line, int offset) {\n    return super._offsetToX(line, offset) + getGutterWidth();\n  }\n","new_comment_raw":"@return the horizontal position","old_comment_raw":"@return the horizontal position","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":23},{"new_code_raw":"public int compareTo(IndexedWord w) { if (this.equals(IndexedWord.NO_WORD)) { if (w.equals(IndexedWord.NO_WORD)) { return 0; } else { return -1; } } if (w.equals(IndexedWord.NO_WORD)) { return 1; } String docID = this.getString(CoreAnnotations.DocIDAnnotation.class); int docComp = docID.compareTo(w.getString(CoreAnnotations.DocIDAnnotation.class)); if (docComp != 0) return docComp; int sentComp = sentIndex() - w.sentIndex(); if (sentComp != 0) return sentComp; int indexComp = index() - w.index(); if (indexComp != 0) return indexComp; return copyCount() - w.copyCount(); }","old_code_raw":"  public int compareTo(IndexedWord w) {\n    if (this.equals(IndexedWord.NO_WORD)) {\n      if (w.equals(IndexedWord.NO_WORD)) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n    if (w.equals(IndexedWord.NO_WORD)) {\n      return 1;\n    }\n\n    String docID = this.getString(CoreAnnotations.DocIDAnnotation.class);\n    int docComp = docID.compareTo(w.getString(CoreAnnotations.DocIDAnnotation.class));\n    if (docComp != 0) return docComp;\n\n    int sentComp = sentIndex() - w.sentIndex();\n    if (sentComp != 0) return sentComp;\n\n    return index() - w.index();\n  }\n","new_comment_raw":"@return Whether this is less than w or not in the ordering","old_comment_raw":"@return Whether this is less than w or not in the ordering","label":0,"pre_label":1,"AST_level":8,"line_counts":25,"new_code_token_num":138},{"new_code_raw":"private boolean validate(RexNode first, RexNode second) { return first instanceof RexCall && second instanceof RexCall; }","old_code_raw":"  private boolean validate(RexNode first, RexNode second) {\n    if (first == null || second == null) {\n      return false;\n    }\n    if (!(first instanceof RexCall)\n        || !(second instanceof RexCall)) {\n      return false;\n    }\n    return true;\n  }\n","new_comment_raw":"@return whether input usage pattern is supported","old_comment_raw":"@return true, if input usage pattern is supported. Otherwise, false.","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":22},{"new_code_raw":"public JoinInfo analyzeCondition() { return joinInfo; }","old_code_raw":"  public JoinInfo analyzeCondition() {\n    return JoinInfo.of(left, right, condition);\n  }\n","new_comment_raw":"@return Analyzed join condition","old_comment_raw":"@return Analyzed join condition","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"public ProjectItem getChild(String text) { String[] childPath = new String[path.length + NUM]; System.arraycopy(path, NUM, childPath, NUM, path.length); childPath[childPath.length - NUM] = text; return project.getProjectItem(childPath); }","old_code_raw":"public ProjectItem getChild(String text) {\n    String[] childPath = new String[path.length + NUM];\n    System.arraycopy(path, NUM, childPath, NUM, path.length);\n    childPath[childPath.length - NUM] = text;\n    return new ProjectItem(treeViewerHandler.getTreeItem(treeItem, text), project, childPath);\n}","new_comment_raw":"@return project item with the specified <var>text<\/var>","old_comment_raw":"@return project item with specified text without decorators","label":1,"pre_label":0,"AST_level":8,"line_counts":6,"new_code_token_num":53},{"new_code_raw":"public String[] getDropSchemaCommand(String schemaName) { return new String[] {\"drop schema \" + schemaName}; }","old_code_raw":"\tpublic String getDropSchemaCommand(String schemaName) {\n\t\treturn \"drop schema \" + schemaName;\n\t}\n","new_comment_raw":"@return The drop commands","old_comment_raw":"@return The drop command","label":1,"pre_label":0,"AST_level":7,"line_counts":4,"new_code_token_num":25},{"new_code_raw":"public static Hours parseHours(String periodStr) { throw ExceptionUtils.unsupportedInGwt(); \/\/ if (periodStr == null) { \/\/ return Hours.ZERO; \/\/ } \/\/ Period p = PARSER.parsePeriod(periodStr); \/\/ return Hours.hours(p.getHours()); }","old_code_raw":"    public static Hours parseHours(String periodStr) {\n        if (periodStr == null) {\n            return Hours.ZERO;\n        }\n        Period p = PARSER.parsePeriod(periodStr);\n        return Hours.hours(p.getHours());\n    }\n","new_comment_raw":"@return the period in hours","old_comment_raw":"@return the period in hours","label":0,"pre_label":1,"AST_level":4,"line_counts":9,"new_code_token_num":55},{"new_code_raw":"public boolean wasFailed(Artifact configurationId) { for (Iterator it = failed.keySet().iterator(); it.hasNext(); ) { Artifact failID = (Artifact) it.next(); if (configurationId.matches(failID)) { return true; } } return false; }","old_code_raw":"public boolean wasFailed(Artifact configurationId) {\n    return failed.containsKey(configurationId);\n}","new_comment_raw":"@return true if the specified (or any matching) configuration failed the operation and threw an exception during the lifecycle operation","old_comment_raw":"@return true if the specified configuration failed the operation and threw an exception during the lifecycle operation","label":1,"pre_label":0,"AST_level":8,"line_counts":9,"new_code_token_num":55},{"new_code_raw":"public Table removeTable(TableId tableId) { return lock.write(() -> { changes.add(tableId); return tablesByTableId.remove(tableId); }); }","old_code_raw":"    public Table removeTable(TableId tableId) {\n        return lock.write(() -> tablesByTableId.remove(tableId));\n    }\n","new_comment_raw":"@return the existing table definition that was removed, or null if there was no prior table definition","old_comment_raw":"@return the existing table definition that was removed, or null if there was no prior table definition","label":0,"pre_label":1,"AST_level":8,"line_counts":7,"new_code_token_num":33},{"new_code_raw":"@Override public ActivityOptions getActivityLaunchOptions(Launcher launcher, View v) { if (hasControlRemoteAppTransitionPermission()) { try { RemoteAnimationRunnerCompat runner = new LauncherAnimationRunner(mLauncher) { @Override public void onAnimationStart(RemoteAnimationTargetCompat[] targets, Runnable finishedCallback) { postAtFrontOfQueueAsynchronously(v.getHandler(), () -> { final boolean removeTrackingView; LauncherTransitionAnimator animator = composeRecentsLaunchAnimator(v, targets); if (animator != null) { removeTrackingView = false; } else { animator = composeAppLaunchAnimator(v, targets); removeTrackingView = true; } setCurrentAnimator(animator); mAnimator = animator.getAnimatorSet(); mAnimator.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { v.setVisibility(View.VISIBLE); if (removeTrackingView) { ((ViewGroup) mDragLayer.getParent()).removeView(mFloatingView); } mDragLayer.setAlpha(NUM); mDragLayer.setTranslationY(NUM); View appsView = mLauncher.getAppsView(); appsView.setAlpha(NUM); appsView.setTranslationY(NUM); finishedCallback.run(); } }); mAnimator.start(); mAnimator.setCurrentPlayTime(REFRESH_RATE_MS); }); } }; return ActivityOptionsCompat.makeRemoteAnimation(new RemoteAnimationAdapterCompat(runner, NUM, NUM)); } catch (NoClassDefFoundError e) { } } return getDefaultActivityLaunchOptions(launcher, v); }","old_code_raw":"@Override\npublic Bundle getActivityLaunchOptions(Launcher launcher, View v) {\n    if (hasControlRemoteAppTransitionPermission()) {\n        try {\n            RemoteAnimationRunnerCompat runner = new LauncherAnimationRunner(mLauncher) {\n\n                @Override\n                public void onAnimationStart(RemoteAnimationTargetCompat[] targets, Runnable finishedCallback) {\n                    postAtFrontOfQueueAsynchronously(v.getHandler(), () -> {\n                        final boolean removeTrackingView;\n                        LauncherTransitionAnimator animator = composeRecentsLaunchAnimator(v, targets);\n                        if (animator != null) {\n                            removeTrackingView = false;\n                        } else {\n                            animator = composeAppLaunchAnimator(v, targets);\n                            removeTrackingView = true;\n                        }\n                        setCurrentAnimator(animator);\n                        mAnimator = animator.getAnimatorSet();\n                        mAnimator.addListener(new AnimatorListenerAdapter() {\n\n                            @Override\n                            public void onAnimationEnd(Animator animation) {\n                                v.setVisibility(View.VISIBLE);\n                                if (removeTrackingView) {\n                                    ((ViewGroup) mDragLayer.getParent()).removeView(mFloatingView);\n                                }\n                                mDragLayer.setAlpha(NUM);\n                                mDragLayer.setTranslationY(NUM);\n                                View appsView = mLauncher.getAppsView();\n                                appsView.setAlpha(NUM);\n                                appsView.setTranslationY(NUM);\n                                finishedCallback.run();\n                            }\n                        });\n                        mAnimator.start();\n                        mAnimator.setCurrentPlayTime(REFRESH_RATE_MS);\n                    });\n                }\n            };\n            return ActivityOptionsCompat.makeRemoteAnimation(new RemoteAnimationAdapterCompat(runner, NUM, NUM)).toBundle();\n        } catch (NoClassDefFoundError e) {\n        }\n    }\n    return getDefaultActivityLaunchOptions(launcher, v);\n}","new_comment_raw":"@return ActivityOptions with remote animations that controls how the window of the opening targets are displayed.","old_comment_raw":"@return A Bundle with remote animations that controls how the window of the opening targets are displayed.","label":1,"pre_label":0,"AST_level":21,"line_counts":46,"new_code_token_num":240},{"new_code_raw":"public static ExternalSessionKey fromJsonResponseBody(String responseBody) { try { JsonObject json = new JsonParser().parse(responseBody).getAsJsonObject(); if (json.has(\"sessionId\") && !json.get(\"sessionId\").isJsonNull()) { return new ExternalSessionKey(json.get(\"sessionId\").getAsString()); } \/\/ W3C response if (json.has(\"value\") && json.get(\"value\").isJsonObject()) { JsonObject value = json.getAsJsonObject(\"value\"); if (value.has(\"sessionId\") && !value.get(\"sessionId\").isJsonNull()) { return new ExternalSessionKey(value.get(\"sessionId\").getAsString()); } } } catch (JsonSyntaxException e) { return null; } return null; }","old_code_raw":"  public static ExternalSessionKey fromJsonResponseBody(String responseBody) {\n    try {\n      JsonObject json = new JsonParser().parse(responseBody).getAsJsonObject();\n      if (json.has(\"sessionId\") && !json.get(\"sessionId\").isJsonNull()) {\n        return new ExternalSessionKey(json.get(\"sessionId\").getAsString());\n      }\n\n      \/\/ W3C response\n      if (json.has(\"value\") && json.get(\"value\").isJsonObject()) {\n        JsonObject value = json.getAsJsonObject(\"value\");\n        if (value.has(\"sessionId\") && !value.get(\"sessionId\").isJsonNull()) {\n          return new ExternalSessionKey(json.get(\"sessionId\").getAsString());\n        }\n      }\n    } catch (JsonSyntaxException e) {\n      return null;\n    }\n\n    return null;\n  }\n","new_comment_raw":"@return the extracted ExternalKey, or null if one was not found.","old_comment_raw":"@return the extracted ExternalKey, or null if one was not found.","label":0,"pre_label":1,"AST_level":11,"line_counts":21,"new_code_token_num":160},{"new_code_raw":"private NaturalLogicRelation project(NaturalLogicRelation input, Monotonicity mono, MonotonicityType type) { switch (input) { case EQUIVALENCE: return NaturalLogicRelation.EQUIVALENCE; case FORWARD_ENTAILMENT: switch (mono) { case MONOTONE: return NaturalLogicRelation.FORWARD_ENTAILMENT; case ANTITONE: return NaturalLogicRelation.REVERSE_ENTAILMENT; case NONMONOTONE: case INVALID: return NaturalLogicRelation.INDEPENDENCE; } case REVERSE_ENTAILMENT: switch (mono) { case MONOTONE: return NaturalLogicRelation.REVERSE_ENTAILMENT; case ANTITONE: return NaturalLogicRelation.FORWARD_ENTAILMENT; case NONMONOTONE: case INVALID: return NaturalLogicRelation.INDEPENDENCE; } case NEGATION: switch (type) { case NONE: return NaturalLogicRelation.INDEPENDENCE; case ADDITIVE: switch (mono) { case MONOTONE: return NaturalLogicRelation.COVER; case ANTITONE: return NaturalLogicRelation.ALTERNATION; case NONMONOTONE: case INVALID: return NaturalLogicRelation.INDEPENDENCE; } case MULTIPLICATIVE: switch (mono) { case MONOTONE: return NaturalLogicRelation.ALTERNATION; case ANTITONE: return NaturalLogicRelation.COVER; case NONMONOTONE: case INVALID: return NaturalLogicRelation.INDEPENDENCE; } break; case BOTH: return NaturalLogicRelation.NEGATION; } break; case ALTERNATION: switch (mono) { case MONOTONE: switch (type) { case NONE: case ADDITIVE: return NaturalLogicRelation.INDEPENDENCE; case MULTIPLICATIVE: case BOTH: return NaturalLogicRelation.ALTERNATION; } case ANTITONE: switch (type) { case NONE: case ADDITIVE: return NaturalLogicRelation.INDEPENDENCE; case MULTIPLICATIVE: case BOTH: return NaturalLogicRelation.COVER; } case NONMONOTONE: case INVALID: return NaturalLogicRelation.INDEPENDENCE; } case COVER: switch (mono) { case MONOTONE: switch (type) { case NONE: case MULTIPLICATIVE: return NaturalLogicRelation.INDEPENDENCE; case ADDITIVE: case BOTH: return NaturalLogicRelation.COVER; } case ANTITONE: switch (type) { case NONE: case MULTIPLICATIVE: return NaturalLogicRelation.INDEPENDENCE; case ADDITIVE: case BOTH: return NaturalLogicRelation.ALTERNATION; } case NONMONOTONE: case INVALID: return NaturalLogicRelation.INDEPENDENCE; } case INDEPENDENCE: return NaturalLogicRelation.INDEPENDENCE; } throw new IllegalStateException(\"[should not happen!] Projection table is incomplete for \" + mono + \" : \" + type + \" on relation \" + input); }","old_code_raw":"  private NaturalLogicRelation project(NaturalLogicRelation input, Monotonicity mono, MonotonicityType type) {\n    switch (input) {\n      case EQUIVALENT:\n        return NaturalLogicRelation.EQUIVALENT;\n      case FORWARD_ENTAILMENT:\n        switch (mono) {\n          case MONOTONE:\n            return NaturalLogicRelation.FORWARD_ENTAILMENT;\n          case ANTITONE:\n            return NaturalLogicRelation.REVERSE_ENTAILMENT;\n          case NONMONOTONE:\n          case INVALID:\n            return NaturalLogicRelation.INDEPENDENCE;\n        }\n      case REVERSE_ENTAILMENT:\n        switch (mono) {\n          case MONOTONE:\n            return NaturalLogicRelation.REVERSE_ENTAILMENT;\n          case ANTITONE:\n            return NaturalLogicRelation.FORWARD_ENTAILMENT;\n          case NONMONOTONE:\n          case INVALID:\n            return NaturalLogicRelation.INDEPENDENCE;\n        }\n      case NEGATION:\n        switch (type) {\n          case NONE:\n            return NaturalLogicRelation.INDEPENDENCE;\n          case ADDITIVE:\n            switch (mono) {\n              case MONOTONE:\n                return NaturalLogicRelation.COVER;\n              case ANTITONE:\n                return NaturalLogicRelation.ALTERNATION;\n              case NONMONOTONE:\n              case INVALID:\n                return NaturalLogicRelation.INDEPENDENCE;\n            }\n          case MULTIPLICATIVE:\n            switch (mono) {\n              case MONOTONE:\n                return NaturalLogicRelation.ALTERNATION;\n              case ANTITONE:\n                return NaturalLogicRelation.COVER;\n              case NONMONOTONE:\n              case INVALID:\n                return NaturalLogicRelation.INDEPENDENCE;\n            }\n            break;\n          case BOTH:\n            return NaturalLogicRelation.NEGATION;\n        }\n        break;\n      case ALTERNATION:\n        switch (mono) {\n          case MONOTONE:\n            switch (type) {\n              case NONE:\n              case ADDITIVE:\n                return NaturalLogicRelation.INDEPENDENCE;\n              case MULTIPLICATIVE:\n              case BOTH:\n                return NaturalLogicRelation.ALTERNATION;\n            }\n          case ANTITONE:\n            switch (type) {\n              case NONE:\n              case ADDITIVE:\n                return NaturalLogicRelation.INDEPENDENCE;\n              case MULTIPLICATIVE:\n              case BOTH:\n                return NaturalLogicRelation.COVER;\n            }\n          case NONMONOTONE:\n          case INVALID:\n            return NaturalLogicRelation.INDEPENDENCE;\n        }\n      case COVER:\n        switch (mono) {\n          case MONOTONE:\n            switch (type) {\n              case NONE:\n              case MULTIPLICATIVE:\n                return NaturalLogicRelation.INDEPENDENCE;\n              case ADDITIVE:\n              case BOTH:\n                return NaturalLogicRelation.COVER;\n            }\n          case ANTITONE:\n            switch (type) {\n              case NONE:\n              case MULTIPLICATIVE:\n                return NaturalLogicRelation.INDEPENDENCE;\n              case ADDITIVE:\n              case BOTH:\n                return NaturalLogicRelation.ALTERNATION;\n            }\n          case NONMONOTONE:\n          case INVALID:\n            return NaturalLogicRelation.INDEPENDENCE;\n        }\n      case INDEPENDENCE:\n        return NaturalLogicRelation.INDEPENDENCE;\n    }\n    throw new IllegalStateException(\"[should not happen!] Projection table is incomplete for \" + mono + \" : \" + type + \" on relation \" + input);\n  }\n","new_comment_raw":"@return The projected relation, once passed through an operator with the given specifications.","old_comment_raw":"@return The projected relation, once passed through an operator with the given specifications.","label":0,"pre_label":1,"AST_level":10,"line_counts":107,"new_code_token_num":382},{"new_code_raw":"private List<File> getCandidateFiles(final Path directory) { Preconditions.checkNotNull(directory); final List<File> candidateFiles = new ArrayList<>(); try { Files.walkFileTree(directory, new SimpleFileVisitor<Path>() { @Override public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException { if (directory.equals(dir)) { \/\/ The top directory should always be listed return FileVisitResult.CONTINUE; } String directoryName = dir.getFileName().toString(); if (!recursiveDirectorySearch || directoryName.startsWith(\".\") || ignorePattern.matcher(directoryName).matches()) { return FileVisitResult.SKIP_SUBTREE; } return FileVisitResult.CONTINUE; } @Override public FileVisitResult visitFile(Path candidate, BasicFileAttributes attrs) throws IOException { String fileName = candidate.getFileName().toString(); if (!fileName.endsWith(completedSuffix) && !fileName.startsWith(\".\") && !ignorePattern.matcher(fileName).matches()) { candidateFiles.add(candidate.toFile()); } return FileVisitResult.CONTINUE; } }); } catch (IOException e) { logger.error(\"I\/O exception occurred while listing directories. \" + \"Files already matched will be returned. \" + directory, e); } return candidateFiles; }","old_code_raw":"  private List<File> getCandidateFiles(File directory) {\n    Preconditions.checkNotNull(directory);\n    List<File> candidateFiles = new ArrayList<File>();\n    if (!directory.isDirectory()) {\n      return candidateFiles;\n    }\n\n    for (File file : directory.listFiles(filter)) {\n      if (file.isDirectory()) {\n        candidateFiles.addAll(getCandidateFiles(file));\n      } else {\n        candidateFiles.add(file);\n      }\n    }\n\n    return candidateFiles;\n  }\n","new_comment_raw":"@return list of files within the passed in directory","old_comment_raw":"@return list of files within the passed in directory","label":0,"pre_label":1,"AST_level":12,"line_counts":41,"new_code_token_num":233},{"new_code_raw":"public int getStack(int k) { int nStack = getStackSize(); return (k >= 0 && k < nStack) ? stack.get(nStack - 1 - k) : Config.NONEXIST; }","old_code_raw":"  public int getStack(int k) {\n    int nStack = getStackSize();\n    return (k >= 0 && k < nStack) ? stack.get(nStack - 1 - k) : CONST.NONEXIST;\n  }\n","new_comment_raw":"@return Sentence index or  Config#NONEXIST if stack doesn't have an element at this index","old_comment_raw":"@return Sentence index or CONST#NONEXIST if stack doesn't have an element at this index","label":1,"pre_label":0,"AST_level":8,"line_counts":5,"new_code_token_num":38},{"new_code_raw":"public ServerAddress address() { return execute(\"get replica set primary\", primary -> { ReplicaSetStatus rsStatus = primary.getReplicaSetStatus(); if (rsStatus != null) { return rsStatus.getMaster(); } else { return null; } }); }","old_code_raw":"        public ServerAddress address() {\n            AtomicReference<ServerAddress> address = new AtomicReference<>();\n            execute(\"get replica set primary\", primary -> {\n                ReplicaSetStatus rsStatus = primary.getReplicaSetStatus();\n                if (rsStatus != null) {\n                    address.set(rsStatus.getMaster());\n                }\n            });\n            return address.get();\n        }\n","new_comment_raw":"@return the address of the replica set's primary node, or  null if there is currently no primary","old_comment_raw":"@return the address of the replica set's primary node, or null if there is currently no primary","label":0,"pre_label":1,"AST_level":9,"line_counts":12,"new_code_token_num":50},{"new_code_raw":"public Observable<Connectivity> observeNetworkConnectivity(final Context context) { final IntentFilter filter = new IntentFilter(); filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION); return Observable.create(new Observable.OnSubscribe<Connectivity>() { @Override public void call(final Subscriber<? super Connectivity> subscriber) { final BroadcastReceiver receiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { subscriber.onNext(Connectivity.create(context)); } }; context.registerReceiver(receiver, filter); subscriber.add(unsubscribeInUiThread(new Action0() { @Override public void call() { context.unregisterReceiver(receiver); } })); } }).defaultIfEmpty(Connectivity.create()); }","old_code_raw":"public Observable<ConnectivityStatus> observeNetworkConnectivity(final Context context) {\n    final IntentFilter filter = new IntentFilter();\n    filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);\n    return Observable.create(new Observable.OnSubscribe<ConnectivityStatus>() {\n\n        @Override\n        public void call(final Subscriber<? super ConnectivityStatus> subscriber) {\n            final BroadcastReceiver receiver = new BroadcastReceiver() {\n\n                @Override\n                public void onReceive(Context context, Intent intent) {\n                    final ConnectivityStatus newStatus = getConnectivityStatus(context);\n                    if (newStatus != status) {\n                        status = newStatus;\n                        subscriber.onNext(newStatus);\n                    }\n                }\n            };\n            context.registerReceiver(receiver, filter);\n            subscriber.add(unsubscribeInUiThread(new Action0() {\n\n                @Override\n                public void call() {\n                    context.unregisterReceiver(receiver);\n                }\n            }));\n        }\n    }).defaultIfEmpty(ConnectivityStatus.OFFLINE);\n}","new_comment_raw":"@return RxJava Observable with Connectivity class containing information about network state, type and name","old_comment_raw":"@return RxJava Observable with ConnectivityStatus","label":1,"pre_label":0,"AST_level":14,"line_counts":25,"new_code_token_num":133},{"new_code_raw":"public String toString() { if (connString == null) { String wrappedString; try { wrappedString = getRealConnection().toString(); } catch (SQLException e) { wrappedString = STR; } connString = this.getClass().getName() + STR + this.hashCode() + STR + wrappedString; } return connString; }","old_code_raw":"public String toString() {\n    try {\n        return getRealConnection().toString();\n    } catch (SQLException e) {\n        return STR;\n    }\n}","new_comment_raw":"@return unique string representation for this connection","old_comment_raw":"@return unique string representation of the underlying physical connection","label":1,"pre_label":0,"AST_level":12,"line_counts":12,"new_code_token_num":61},{"new_code_raw":"private static boolean isXMLSpaceDefault(DomNode node) { for (; node instanceof DomElement; node = node.getParentNode()) { final String value = ((DomElement) node).getAttribute(STR); if (!value.isEmpty()) { if (STR.equals(value)) { return true; } return false; } } return false; }","old_code_raw":"private static Boolean isXMLSpaceDefault(DomNode node) {\n    for (; node instanceof DomElement; node = node.getParentNode()) {\n        final String value = ((DomElement) node).getAttribute(STR);\n        if (!value.isEmpty()) {\n            if (STR.equals(value)) {\n                return Boolean.TRUE;\n            }\n            return Boolean.FALSE;\n        }\n    }\n    return null;\n}","new_comment_raw":"@return whether \"xml:space\" attribute is set to \"default\"","old_comment_raw":"@return {@link Boolean#TRUE} if \"default\" is set, {@link Boolean#FALSE} for other value, or null if nothing is set.","label":1,"pre_label":0,"AST_level":10,"line_counts":12,"new_code_token_num":68},{"new_code_raw":"public TextView waitForText(String text, int expectedMinimumNumberOfMatches, long timeout, boolean scroll) { return waitForText(TextView.class, text, expectedMinimumNumberOfMatches, timeout, scroll, false, true); }","old_code_raw":"\tpublic TextView waitForText(String text, int expectedMinimumNumberOfMatches, long timeout)\n\t{\n\t\treturn waitForText(text, expectedMinimumNumberOfMatches, timeout, true);\n\t}\n","new_comment_raw":"@return  true if text is found and  false if it is not found before the timeout","old_comment_raw":"@return true if text is found and false if it is not found before the timeout","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":37},{"new_code_raw":"@NonNull public static Calendar getInstance() { return Calendar.getInstance(Locale.getDefault()); }","old_code_raw":"@NonNull\npublic static Calendar getInstance() {\n    Calendar calendar = Calendar.getInstance();\n    copyDateTo(calendar, calendar);\n    return calendar;\n}","new_comment_raw":"@return a new Calendar instance with the date set to today.","old_comment_raw":"@return a new Calendar instance with the date set to today. Time set to zero.","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"protected Object convertInteger(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0; } if (data instanceof Integer) return data; if (data instanceof Number) { Number value = (Number) data; return new Integer(value.intValue()); } if (data instanceof Boolean) { return ((Boolean) data).booleanValue() ? INTEGER_TRUE : INTEGER_FALSE; } return handleUnknownData(column, fieldDefn, data); }","old_code_raw":"    protected Object convertInteger(Column column, Field fieldDefn, Object data) {\n        if (data == null) return null;\n        if (data instanceof Integer) return data;\n        if (data instanceof Number) {\n            Number value = (Number) data;\n            return new Integer(value.intValue());\n        }\n        if (data instanceof Boolean) {\n            return ((Boolean) data).booleanValue() ? INTEGER_TRUE : INTEGER_FALSE;\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made","label":1,"pre_label":0,"AST_level":8,"line_counts":19,"new_code_token_num":118},{"new_code_raw":"public static boolean exceedsMaxCount() { final long maxTestCount = HostConfig.getMaxTestCount(); return (maxTestCount > NUM) && (mTestCount >= maxTestCount); }","old_code_raw":"public static boolean exceedsMaxCount() {\n    return mTestCount >= MAX_TEST_COUNT;\n}","new_comment_raw":"@return true, if the max count is enabled and exceeded.","old_comment_raw":"@return If reached, return true; else, return false.","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":28},{"new_code_raw":"public final int getPeekHeight() { return mPeekHeightAuto ? PEEK_HEIGHT_AUTO : mPeekHeight; }","old_code_raw":"public final int getPeekHeight() {\n    return mPeekHeight;\n}","new_comment_raw":"@return The height of the collapsed bottom sheet in pixels, or {@link #PEEK_HEIGHT_AUTO} if the sheet is configured to peek automatically at 16:9 ratio keyline","old_comment_raw":"@return The height of the collapsed bottom sheet.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":15},{"new_code_raw":"public DateTime roundFloorCopy() { DateTime instant = iInstant; return (DateTime)instant.withMillis(iField.roundFloor(instant.getMillis())); }","old_code_raw":"    public DateTime roundFloorCopy() {\n        DateTime instant = iInstant;\n        return (DateTime)instant.toCopy(iField.roundFloor(instant.getMillis()));\n    }\n","new_comment_raw":"@return a copy of the DateTime with the field value changed","old_comment_raw":"@return a copy of the DateTime with the field value changed","label":0,"pre_label":1,"AST_level":7,"line_counts":5,"new_code_token_num":28},{"new_code_raw":"public long getMaxFileLength() { return maxFileLength; }","old_code_raw":"    public int getMaxFileLength() {\n        return maxFileLength;\n    }\n","new_comment_raw":"@return the maxFileLength","old_comment_raw":"@return the maxFileLength","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"public byte get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }","old_code_raw":"public byte get(WithAttributes attributes) {\n    return attributes.getAttributes().get(this);\n}","new_comment_raw":"@return the value of this attribute if this attribute is present in the extracted map. Otherwise {@link #getDefaultValue()}","old_comment_raw":"@return the value of this attribute if this attribute is present in the map. Otherwise {@link #getDefaultValue()}","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":19},{"new_code_raw":"public static ImportMode getModeValue(String mode) { if (mode == null) return null; mode = mode.trim().toLowerCase(); if (mode.indexOf(STR) == -NUM) { if (STR.equals(mode)) { return ImportMode.insert; } else if (STR.equals(mode)) { return ImportMode.update; } else { return null; } } else { List l = StringUtil.stringToList(mode, STR); String first = (String) l.get(NUM); String second = (String) l.get(NUM); if (STR.equals(first) && STR.equals(second)) { return ImportMode.insertUpdate; } else if (STR.equals(first) && STR.equals(second)) { return ImportMode.updateInsert; } else { return null; } } }","old_code_raw":"public static int getModeValue(String mode) {\n    if (mode == null)\n        return -NUM;\n    mode = mode.trim().toLowerCase();\n    if (mode.indexOf(STR) == -NUM) {\n        if (STR.equals(mode)) {\n            return MODE_INSERT;\n        } else if (STR.equals(mode)) {\n            return MODE_UPDATE;\n        } else {\n            return -NUM;\n        }\n    } else {\n        List l = StringUtil.stringToList(mode, STR);\n        String first = (String) l.get(NUM);\n        String second = (String) l.get(NUM);\n        if (STR.equals(first) && STR.equals(second)) {\n            return MODE_INSERT_UPDATE;\n        } else if (STR.equals(first) && STR.equals(second)) {\n            return MODE_UPDATE_INSERT;\n        } else {\n            return -NUM;\n        }\n    }\n}","new_comment_raw":"@return null if the value is not valid","old_comment_raw":"@return -1 if the value is not valid","label":1,"pre_label":0,"AST_level":9,"line_counts":25,"new_code_token_num":158},{"new_code_raw":"public String toLoggableString(Object value, SessionFactoryImplementor factory) { if ( value == null ) { return \"null\"; } final EntityPersister persister = getAssociatedEntityPersister( factory ); if ( !persister.getEntityTuplizer().isInstance( value ) ) { \/\/ it should be the id type... if ( persister.getIdentifierType().getReturnedClass().isInstance( value ) ) { return associatedEntityName + \"#\" + value; } } final StringBuilder result = new StringBuilder().append( associatedEntityName ); if ( persister.hasIdentifierProperty() ) { final Serializable id; if ( value instanceof HibernateProxy ) { HibernateProxy proxy = (HibernateProxy) value; id = proxy.getHibernateLazyInitializer().getIdentifier(); } else { id = persister.getIdentifier( value ); } result.append( '#' ) .append( persister.getIdentifierType().toLoggableString( id, factory ) ); } return result.toString(); }","old_code_raw":"\tpublic String toLoggableString(Object value, SessionFactoryImplementor factory) {\n\t\tif ( value == null ) {\n\t\t\treturn \"null\";\n\t\t}\n\n\t\tEntityPersister persister = getAssociatedEntityPersister( factory );\n\t\tStringBuilder result = new StringBuilder().append( associatedEntityName );\n\n\t\tif ( persister.hasIdentifierProperty() ) {\n\t\t\tfinal Serializable id;\n\t\t\tif ( value instanceof HibernateProxy ) {\n\t\t\t\tHibernateProxy proxy = (HibernateProxy) value;\n\t\t\t\tid = proxy.getHibernateLazyInitializer().getIdentifier();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tid = persister.getIdentifier( value );\n\t\t\t}\n\n\t\t\tresult.append( '#' )\n\t\t\t\t\t.append( persister.getIdentifierType().toLoggableString( id, factory ) );\n\t\t}\n\n\t\treturn result.toString();\n\t}\n","new_comment_raw":"@return The loggable string.","old_comment_raw":"@return The loggable string.","label":0,"pre_label":1,"AST_level":10,"line_counts":32,"new_code_token_num":165},{"new_code_raw":"public OutEdges<I, E> unwrap() { if (currentEdge != null) { newEdges.add(currentEdge); currentEdge = null; } while (oldEdgesIterator.hasNext()) { newEdges.add(oldEdgesIterator.next()); } return newEdges; }","old_code_raw":"public VertexEdges<I, E> unwrap() {\n    if (currentEdge != null) {\n        newEdges.add(currentEdge);\n        currentEdge = null;\n    }\n    while (oldEdgesIterator.hasNext()) {\n        newEdges.add(oldEdgesIterator.next());\n    }\n    return newEdges;\n}","new_comment_raw":"@return The new {@link OutEdges} data structure.","old_comment_raw":"@return The new {@link VertexEdges} data structure.","label":1,"pre_label":0,"AST_level":7,"line_counts":10,"new_code_token_num":48},{"new_code_raw":"@Override public Object put(Object value) { return put(null, value); }","old_code_raw":"@Override\npublic Object put(Object value) {\n    return put(value, false);\n}","new_comment_raw":"@return {@link #put(String, Object)}","old_comment_raw":"@return {@link #put(String, boolean)}","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":19},{"new_code_raw":"private boolean zzRefill() throws java.io.IOException { \/* first: make room (if you can) *\/ if (zzStartRead > 0) { zzEndRead += zzFinalHighSurrogate; zzFinalHighSurrogate = 0; System.arraycopy(zzBuffer, zzStartRead, zzBuffer, 0, zzEndRead-zzStartRead); \/* translate stored positions *\/ zzEndRead-= zzStartRead; zzCurrentPos-= zzStartRead; zzMarkedPos-= zzStartRead; zzStartRead = 0; } \/* is the buffer big enough? *\/ if (zzCurrentPos >= zzBuffer.length - zzFinalHighSurrogate) { \/* if not: blow it up *\/ char newBuffer[] = new char[zzBuffer.length*2]; System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length); zzBuffer = newBuffer; zzEndRead += zzFinalHighSurrogate; zzFinalHighSurrogate = 0; } \/* fill the buffer with new input *\/ int requested = zzBuffer.length - zzEndRead; int numRead = zzReader.read(zzBuffer, zzEndRead, requested); \/* not supposed to occur according to specification of java.io.Reader *\/ if (numRead == 0) { throw new java.io.IOException(\"Reader returned 0 characters. See JFlex examples for workaround.\"); } if (numRead > 0) { zzEndRead += numRead; \/* If numRead == requested, we might have requested to few chars to encode a full Unicode character. We assume that a Reader would otherwise never return half characters. *\/ if (numRead == requested) { if (Character.isHighSurrogate(zzBuffer[zzEndRead - 1])) { --zzEndRead; zzFinalHighSurrogate = 1; } } \/* potentially more input available *\/ return false; } \/* numRead < 0 ==> end of stream *\/ return true; }","old_code_raw":"  private boolean zzRefill() throws java.io.IOException {\n\n    \/* first: make room (if you can) *\/\n    if (zzStartRead > 0) {\n      System.arraycopy(zzBuffer, zzStartRead,\n                       zzBuffer, 0,\n                       zzEndRead-zzStartRead);\n\n      \/* translate stored positions *\/\n      zzEndRead-= zzStartRead;\n      zzCurrentPos-= zzStartRead;\n      zzMarkedPos-= zzStartRead;\n      zzStartRead = 0;\n    }\n\n    \/* is the buffer big enough? *\/\n    if (zzCurrentPos >= zzBuffer.length) {\n      \/* if not: blow it up *\/\n      char newBuffer[] = new char[zzCurrentPos*2];\n      System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);\n      zzBuffer = newBuffer;\n    }\n\n    \/* finally: fill the buffer with new input *\/\n    int numRead = zzReader.read(zzBuffer, zzEndRead,\n                                            zzBuffer.length-zzEndRead);\n\n    if (numRead > 0) {\n      zzEndRead+= numRead;\n      return false;\n    }\n    \/\/ unlikely but not impossible: read 0 characters, but not at end of stream    \n    if (numRead == 0) {\n      int c = zzReader.read();\n      if (c == -1) {\n        return true;\n      } else {\n        zzBuffer[zzEndRead++] = (char) c;\n        return false;\n      }     \n    }\n\n    \/\/ numRead < 0\n    return true;\n  }\n","new_comment_raw":"@return false, iff there was new input.","old_comment_raw":"@return false, iff there was new input.","label":0,"pre_label":1,"AST_level":12,"line_counts":54,"new_code_token_num":309},{"new_code_raw":"public StringExpression substring(Expression<Integer> beginIndex, Expression<Integer> endIndex) { return StringOperation.create(Ops.SUBSTR_2ARGS, mixin, beginIndex, endIndex); }","old_code_raw":"    public StringExpression substring(Expression<Integer> beginIndex, Expression<Integer> endIndex) {\n        return StringOperation.create(Ops.SUBSTR_2ARGS, this, beginIndex, endIndex);\n    }\n","new_comment_raw":"@return this.substring(beginIndex, endIndex)","old_comment_raw":"@return this.substring(beginIndex, endIndex)","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":28},{"new_code_raw":"public static TimestampedEntry parseTimestampedEntry(InputStream in) { TimestampedEntry timestampedEntry = new TimestampedEntry(); timestampedEntry.timestamp = readNumber(in, CTConstants.TIMESTAMP_LENGTH); int entryType = (int) readNumber(in, CTConstants.LOG_ENTRY_TYPE_LENGTH); timestampedEntry.entryType = Ct.LogEntryType.valueOf(entryType); Ct.SignedEntry.Builder signedEntryBuilder = Ct.SignedEntry.newBuilder(); if (entryType == Ct.LogEntryType.X509_ENTRY_VALUE) { int length = (int) readNumber(in, NUM); ByteString x509 = ByteString.copyFrom(readFixedLength(in, length)); signedEntryBuilder.setX509(x509); } else if (entryType == Ct.LogEntryType.PRECERT_ENTRY_VALUE) { Ct.PreCert.Builder preCertBuilder = Ct.PreCert.newBuilder(); byte[] arr = readFixedLength(in, NUM); preCertBuilder.setIssuerKeyHash(ByteString.copyFrom(arr)); arr = readFixedLength(in, NUM); int length = (int) readNumber(in, NUM); preCertBuilder.setTbsCertificate(ByteString.copyFrom(readFixedLength(in, length))); preCertBuilder.build(); signedEntryBuilder.setPrecert(preCertBuilder); } else { throw new SerializationException(String.format(STR, entryType)); } timestampedEntry.signedEntry = signedEntryBuilder.build(); return timestampedEntry; }","old_code_raw":"public static Ct.TimestampedEntry parseTimestampedEntry(InputStream in) {\n    Ct.TimestampedEntry.Builder timestampedEntry = Ct.TimestampedEntry.newBuilder();\n    long timestamp = readNumber(in, CTConstants.TIMESTAMP_LENGTH);\n    timestampedEntry.setTimestamp(timestamp);\n    int entryType = (int) readNumber(in, CTConstants.LOG_ENTRY_TYPE_LENGTH);\n    timestampedEntry.setEntryType(Ct.LogEntryType.valueOf(entryType));\n    Ct.SignedEntry.Builder signedEntryBuilder = Ct.SignedEntry.newBuilder();\n    if (entryType == Ct.LogEntryType.X509_ENTRY_VALUE) {\n        int length = (int) readNumber(in, NUM);\n        ByteString x509 = ByteString.copyFrom(readFixedLength(in, length));\n        signedEntryBuilder.setX509(x509);\n    } else if (entryType == Ct.LogEntryType.PRECERT_ENTRY_VALUE) {\n        Ct.PreCert.Builder preCertBuilder = Ct.PreCert.newBuilder();\n        byte[] arr = readFixedLength(in, NUM);\n        preCertBuilder.setIssuerKeyHash(ByteString.copyFrom(arr));\n        arr = readFixedLength(in, NUM);\n        int length = (int) readNumber(in, NUM);\n        preCertBuilder.setTbsCertificate(ByteString.copyFrom(readFixedLength(in, length)));\n        preCertBuilder.build();\n        signedEntryBuilder.setPrecert(preCertBuilder);\n    } else {\n        throw new SerializationException(String.format(STR, entryType));\n    }\n    signedEntryBuilder.build();\n    timestampedEntry.setSignedEntry(signedEntryBuilder);\n    return timestampedEntry.build();\n}","new_comment_raw":"@return Built {@link TimestampedEntry}.","old_comment_raw":"@return Built {@link Ct.TimestampedEntry}.","label":1,"pre_label":0,"AST_level":10,"line_counts":25,"new_code_token_num":212},{"new_code_raw":"private static String convertBufferToString(byte[] buf) throws UnsupportedEncodingException { return new String(buf, 0, buf.length - 2, \"UTF-16LE\"); }","old_code_raw":"  private static String convertBufferToString(byte[] buf) throws UnsupportedEncodingException {\n    return(new String(buf, 0, buf.length - 2, \"UTF-16LE\"));\n  }\n","new_comment_raw":"@return String","old_comment_raw":"@return String","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":34},{"new_code_raw":"protected HttpSessionsSite getHttpSessionsSite(String site, boolean createIfNeeded) { if (sessions == null) { if (!createIfNeeded) return null; sessions = new HashMap<>(); } HttpSessionsSite hss = sessions.get(site); if (hss == null) { if (!createIfNeeded) return null; hss = new HttpSessionsSite(this, site); sessions.put(site, hss); } return hss; }","old_code_raw":"\tprotected HttpSessionsSite getHttpSessionsSite(String site) {\n\t\tif (sessions == null) {\n\t\t\tsessions = new HashMap<>();\n\t\t}\n\t\tHttpSessionsSite hss = sessions.get(site);\n\t\tif (hss == null) {\n\t\t\thss = new HttpSessionsSite(this, site);\n\t\t\tsessions.put(site, hss);\n\t\t}\n\t\treturn hss;\n\t}\n","new_comment_raw":"@return the http sessions site container, or null one does not exist and createIfNeeded is false","old_comment_raw":"@return the http sessions site container","label":1,"pre_label":0,"AST_level":8,"line_counts":16,"new_code_token_num":76},{"new_code_raw":"public AggIterOutcome outputCurrentBatch() { \/\/ Handle the case of an EMIT with an empty batch if ( handleEmit && ( batchHolders == null || batchHolders[0].size() == 0 ) ) { lastBatchOutputCount = 0; \/\/ empty allocateOutgoing(0); for (VectorWrapper<?> v : outgoing) { v.getValueVector().getMutator().setValueCount(0); } outgoing.getContainer().setRecordCount(0); \/\/ When returning the last outgoing batch (following an incoming EMIT), then replace OK with EMIT this.outcome = IterOutcome.EMIT; handleEmit = false; \/\/ finish handling EMIT if ( outBatchIndex != null ) { outBatchIndex[0] = 0; \/\/ reset, for the next EMIT } return AggIterOutcome.AGG_EMIT; } \/\/ when incoming was an empty batch, just finish up if ( schema == null ) { logger.trace(\"Incoming was empty; output is an empty batch.\"); this.outcome = IterOutcome.NONE; \/\/ no records were read allFlushed = true; return AggIterOutcome.AGG_NONE; } \/\/ Initialization (covers the case of early output) ArrayList<BatchHolder> currPartition = batchHolders[earlyPartition]; int currOutBatchIndex = outBatchIndex[earlyPartition]; int partitionToReturn = earlyPartition; if ( ! earlyOutput ) { \/\/ Update the next partition to return (if needed) \/\/ skip fully returned (or spilled) partitions while (nextPartitionToReturn < numPartitions) { \/\/ \/\/ If this partition was spilled - spill the rest of it and skip it \/\/ if ( isSpilled(nextPartitionToReturn) ) { spillAPartition(nextPartitionToReturn); \/\/ spill the rest SpilledPartition sp = new SpilledPartition(); sp.spillFile = spillFiles[nextPartitionToReturn]; sp.spilledBatches = spilledBatchesCount[nextPartitionToReturn]; sp.cycleNum = cycleNum; \/\/ remember the current cycle sp.origPartn = nextPartitionToReturn; \/\/ for debugging \/ filename sp.prevOrigPartn = originalPartition; \/\/ for debugging \/ filename spilledPartitionsList.add(sp); reinitPartition(nextPartitionToReturn); \/\/ free the memory try { spillSet.close(writers[nextPartitionToReturn]); } catch (IOException ioe) { throw UserException.resourceError(ioe) .message(\"IO Error while closing output stream\") .build(logger); } writers[nextPartitionToReturn] = null; } else { currPartition = batchHolders[nextPartitionToReturn]; currOutBatchIndex = outBatchIndex[nextPartitionToReturn]; \/\/ If curr batch (partition X index) is not empty - proceed to return it if (currOutBatchIndex < currPartition.size() && 0 != currPartition.get(currOutBatchIndex).getNumPendingOutput()) { break; } } nextPartitionToReturn++; \/\/ else check next partition } \/\/ if passed the last partition - either done or need to restart and read spilled partitions if (nextPartitionToReturn >= numPartitions) { \/\/ The following \"if\" is probably never used; due to a similar check at the end of this method if ( spilledPartitionsList.isEmpty() ) { \/\/ and no spilled partitions allFlushed = true; this.outcome = IterOutcome.NONE; if ( is2ndPhase && spillSet.getWriteBytes() > 0 ) { stats.setLongStat(Metric.SPILL_MB, \/\/ update stats - total MB spilled (int) Math.round(spillSet.getWriteBytes() \/ 1024.0D \/ 1024.0)); } return AggIterOutcome.AGG_NONE; \/\/ then return NONE } \/\/ Else - there are still spilled partitions to process - pick one and handle just like a new incoming buildComplete = false; \/\/ go back and call doWork() again handlingSpills = true; \/\/ beginning to work on the spill files \/\/ pick a spilled partition; set a new incoming ... SpilledPartition sp = spilledPartitionsList.remove(0); \/\/ Create a new \"incoming\" out of the spilled partition spill file newIncoming = new SpilledRecordbatch(sp.spillFile, sp.spilledBatches, context, schema, oContext, spillSet); originalPartition = sp.origPartn; \/\/ used for the filename logger.trace(\"Reading back spilled original partition {} as an incoming\",originalPartition); \/\/ Initialize .... new incoming, new set of partitions try { initializeSetup(newIncoming); } catch (Exception e) { throw new RuntimeException(e); } \/\/ update the cycle num if needed \/\/ The current cycle num should always be one larger than in the spilled partition if ( cycleNum == sp.cycleNum ) { cycleNum = 1 + sp.cycleNum; stats.setLongStat(Metric.SPILL_CYCLE, cycleNum); \/\/ update stats \/\/ report first spill or memory stressful situations if ( cycleNum == 1 ) { logger.info(\"Started reading spilled records \"); } if ( cycleNum == 2 ) { logger.info(\"SECONDARY SPILLING \"); } if ( cycleNum == 3 ) { logger.warn(\"TERTIARY SPILLING \"); } if ( cycleNum == 4 ) { logger.warn(\"QUATERNARY SPILLING \"); } if ( cycleNum == 5 ) { logger.warn(\"QUINARY SPILLING \"); } } if ( EXTRA_DEBUG_SPILL ) { logger.debug(\"Start reading spilled partition {} (prev {}) from cycle {} (with {} batches). More {} spilled partitions left.\", sp.origPartn, sp.prevOrigPartn, sp.cycleNum, sp.spilledBatches, spilledPartitionsList.size()); } return AggIterOutcome.AGG_RESTART; } partitionToReturn = nextPartitionToReturn ; } \/\/ get the number of records in the batch holder that are pending output int numPendingOutput = currPartition.get(currOutBatchIndex).getNumPendingOutput(); \/\/ The following accounting is for logging, metrics, etc. rowsInPartition += numPendingOutput ; if ( ! handlingSpills ) { rowsNotSpilled += numPendingOutput; } else { rowsSpilledReturned += numPendingOutput; } if ( earlyOutput ) { rowsReturnedEarly += numPendingOutput; } allocateOutgoing(numPendingOutput); currPartition.get(currOutBatchIndex).outputValues(outStartIdxHolder, outNumRecordsHolder); int numOutputRecords = outNumRecordsHolder.value; if (EXTRA_DEBUG_1) { logger.debug(\"After output values: outStartIdx = {}, outNumRecords = {}\", outStartIdxHolder.value, outNumRecordsHolder.value); } this.htables[partitionToReturn].outputKeys(currOutBatchIndex, this.outContainer, outStartIdxHolder.value, outNumRecordsHolder.value, numPendingOutput); \/\/ set the value count for outgoing batch value vectors for (VectorWrapper<?> v : outgoing) { v.getValueVector().getMutator().setValueCount(numOutputRecords); } this.outcome = IterOutcome.OK; if ( EXTRA_DEBUG_SPILL && is2ndPhase ) { logger.debug(\"So far returned {} + SpilledReturned {} total {} (spilled {})\",rowsNotSpilled,rowsSpilledReturned, rowsNotSpilled+rowsSpilledReturned, rowsSpilled); } lastBatchOutputCount = numOutputRecords; outBatchIndex[partitionToReturn]++; \/\/ if just flushed the last batch in the partition if (outBatchIndex[partitionToReturn] == currPartition.size()) { if ( EXTRA_DEBUG_SPILL ) { logger.debug(\"HashAggregate: {} Flushed partition {} with {} batches total {} rows\", earlyOutput ? \"(Early)\" : \"\", partitionToReturn, outBatchIndex[partitionToReturn], rowsInPartition); } rowsInPartition = 0; \/\/ reset to count for the next partition \/\/ deallocate memory used by this partition, and re-initialize reinitPartition(partitionToReturn); if ( earlyOutput ) { if ( EXTRA_DEBUG_SPILL ) { logger.debug(\"HASH AGG: Finished (early) re-init partition {}, mem allocated: {}\", earlyPartition, allocator.getAllocatedMemory()); } outBatchIndex[earlyPartition] = 0; \/\/ reset, for next time earlyOutput = false ; \/\/ done with early output } else if ( handleEmit ) { \/\/ When returning the last outgoing batch (following an incoming EMIT), then replace OK with EMIT this.outcome = IterOutcome.EMIT; handleEmit = false; \/\/ finished handling EMIT outBatchIndex[partitionToReturn] = 0; \/\/ reset, for the next EMIT return AggIterOutcome.AGG_EMIT; } else if ( (partitionToReturn + 1 == numPartitions) && spilledPartitionsList.isEmpty() ) { \/\/ last partition ? allFlushed = true; \/\/ next next() call will return NONE logger.trace(\"HashAggregate: All batches flushed.\"); \/\/ cleanup my internal state since there is nothing more to return this.cleanup(); } } return AggIterOutcome.AGG_OK; }","old_code_raw":"  public AggIterOutcome outputCurrentBatch() {\n\n    \/\/ when incoming was an empty batch, just finish up\n    if ( schema == null ) {\n      logger.trace(\"Incoming was empty; output is an empty batch.\");\n      this.outcome = IterOutcome.NONE; \/\/ no records were read\n      allFlushed = true;\n      return AggIterOutcome.AGG_NONE;\n    }\n\n    \/\/ Initialization (covers the case of early output)\n    ArrayList<BatchHolder> currPartition = batchHolders[earlyPartition];\n    int currOutBatchIndex = outBatchIndex[earlyPartition];\n    int partitionToReturn = earlyPartition;\n\n    if ( ! earlyOutput ) {\n      \/\/ Update the next partition to return (if needed)\n      \/\/ skip fully returned (or spilled) partitions\n      while (nextPartitionToReturn < numPartitions) {\n        \/\/\n        \/\/ If this partition was spilled - spill the rest of it and skip it\n        \/\/\n        if ( isSpilled(nextPartitionToReturn) ) {\n          spillAPartition(nextPartitionToReturn); \/\/ spill the rest\n          SpilledPartition sp = new SpilledPartition();\n          sp.spillFile = spillFiles[nextPartitionToReturn];\n          sp.spilledBatches = spilledBatchesCount[nextPartitionToReturn];\n          sp.cycleNum = cycleNum; \/\/ remember the current cycle\n          sp.origPartn = nextPartitionToReturn; \/\/ for debugging \/ filename\n          sp.prevOrigPartn = originalPartition; \/\/ for debugging \/ filename\n          spilledPartitionsList.add(sp);\n\n          reinitPartition(nextPartitionToReturn); \/\/ free the memory\n          try {\n            spillSet.close(writers[nextPartitionToReturn]);\n          } catch (IOException ioe) {\n            throw UserException.resourceError(ioe)\n                .message(\"IO Error while closing output stream\")\n                .build(logger);\n          }\n          writers[nextPartitionToReturn] = null;\n        }\n        else {\n          currPartition = batchHolders[nextPartitionToReturn];\n          currOutBatchIndex = outBatchIndex[nextPartitionToReturn];\n          \/\/ If curr batch (partition X index) is not empty - proceed to return it\n          if (currOutBatchIndex < currPartition.size() && 0 != currPartition.get(currOutBatchIndex).getNumPendingOutput()) {\n            break;\n          }\n        }\n        nextPartitionToReturn++; \/\/ else check next partition\n      }\n\n      \/\/ if passed the last partition - either done or need to restart and read spilled partitions\n      if (nextPartitionToReturn >= numPartitions) {\n        \/\/ The following \"if\" is probably never used; due to a similar check at the end of this method\n        if ( spilledPartitionsList.isEmpty() ) { \/\/ and no spilled partitions\n          allFlushed = true;\n          this.outcome = IterOutcome.NONE;\n          if ( is2ndPhase && spillSet.getWriteBytes() > 0 ) {\n            stats.setLongStat(Metric.SPILL_MB, \/\/ update stats - total MB spilled\n                (int) Math.round(spillSet.getWriteBytes() \/ 1024.0D \/ 1024.0));\n          }\n          return AggIterOutcome.AGG_NONE;  \/\/ then return NONE\n        }\n        \/\/ Else - there are still spilled partitions to process - pick one and handle just like a new incoming\n        buildComplete = false; \/\/ go back and call doWork() again\n        handlingSpills = true; \/\/ beginning to work on the spill files\n        \/\/ pick a spilled partition; set a new incoming ...\n        SpilledPartition sp = spilledPartitionsList.remove(0);\n        \/\/ Create a new \"incoming\" out of the spilled partition spill file\n        newIncoming = new SpilledRecordbatch(sp.spillFile, sp.spilledBatches, context, schema, oContext, spillSet);\n        originalPartition = sp.origPartn; \/\/ used for the filename\n        logger.trace(\"Reading back spilled original partition {} as an incoming\",originalPartition);\n        \/\/ Initialize .... new incoming, new set of partitions\n        try { initializeSetup(newIncoming); } catch (Exception e) { throw new RuntimeException(e); }\n        \/\/ update the cycle num if needed\n        \/\/ The current cycle num should always be one larger than in the spilled partition\n        if ( cycleNum == sp.cycleNum ) {\n          cycleNum = 1 + sp.cycleNum;\n          stats.setLongStat(Metric.SPILL_CYCLE, cycleNum); \/\/ update stats\n          \/\/ report first spill or memory stressful situations\n          if ( cycleNum == 1 ) { logger.info(\"Started reading spilled records \"); }\n          if ( cycleNum == 2 ) { logger.info(\"SECONDARY SPILLING \"); }\n          if ( cycleNum == 3 ) { logger.warn(\"TERTIARY SPILLING \"); }\n          if ( cycleNum == 4 ) { logger.warn(\"QUATERNARY SPILLING \"); }\n          if ( cycleNum == 5 ) { logger.warn(\"QUINARY SPILLING \"); }\n        }\n        if ( EXTRA_DEBUG_SPILL ) {\n          logger.debug(\"Start reading spilled partition {} (prev {}) from cycle {} (with {} batches). More {} spilled partitions left.\",\n              sp.origPartn, sp.prevOrigPartn, sp.cycleNum, sp.spilledBatches, spilledPartitionsList.size());\n        }\n        return AggIterOutcome.AGG_RESTART;\n      }\n\n      partitionToReturn = nextPartitionToReturn ;\n\n    }\n\n    \/\/ get the number of records in the batch holder that are pending output\n    int numPendingOutput = currPartition.get(currOutBatchIndex).getNumPendingOutput();\n\n    \/\/ The following accounting is for logging, metrics, etc.\n    rowsInPartition += numPendingOutput ;\n    if ( ! handlingSpills ) { rowsNotSpilled += numPendingOutput; }\n    else { rowsSpilledReturned += numPendingOutput; }\n    if ( earlyOutput ) { rowsReturnedEarly += numPendingOutput; }\n\n    allocateOutgoing(numPendingOutput);\n\n    currPartition.get(currOutBatchIndex).outputValues(outStartIdxHolder, outNumRecordsHolder);\n    int numOutputRecords = outNumRecordsHolder.value;\n\n    if (EXTRA_DEBUG_1) {\n      logger.debug(\"After output values: outStartIdx = {}, outNumRecords = {}\", outStartIdxHolder.value, outNumRecordsHolder.value);\n    }\n\n    this.htables[partitionToReturn].outputKeys(currOutBatchIndex, this.outContainer, outStartIdxHolder.value, outNumRecordsHolder.value, numPendingOutput);\n\n    \/\/ set the value count for outgoing batch value vectors\n    for (VectorWrapper<?> v : outgoing) {\n      v.getValueVector().getMutator().setValueCount(numOutputRecords);\n    }\n\n    this.outcome = IterOutcome.OK;\n\n    if ( EXTRA_DEBUG_SPILL && is2ndPhase ) {\n      logger.debug(\"So far returned {} + SpilledReturned {}  total {} (spilled {})\",rowsNotSpilled,rowsSpilledReturned,\n        rowsNotSpilled+rowsSpilledReturned,\n        rowsSpilled);\n    }\n\n    lastBatchOutputCount = numOutputRecords;\n    outBatchIndex[partitionToReturn]++;\n    \/\/ if just flushed the last batch in the partition\n    if (outBatchIndex[partitionToReturn] == currPartition.size()) {\n\n      if ( EXTRA_DEBUG_SPILL ) {\n        logger.debug(\"HashAggregate: {} Flushed partition {} with {} batches total {} rows\",\n            earlyOutput ? \"(Early)\" : \"\",\n            partitionToReturn, outBatchIndex[partitionToReturn], rowsInPartition);\n      }\n      rowsInPartition = 0; \/\/ reset to count for the next partition\n\n      \/\/ deallocate memory used by this partition, and re-initialize\n      reinitPartition(partitionToReturn);\n\n      if ( earlyOutput ) {\n\n        if ( EXTRA_DEBUG_SPILL ) {\n          logger.debug(\"HASH AGG: Finished (early) re-init partition {}, mem allocated: {}\", earlyPartition, allocator.getAllocatedMemory());\n        }\n        outBatchIndex[earlyPartition] = 0; \/\/ reset, for next time\n        earlyOutput = false ; \/\/ done with early output\n      }\n      else if ( (partitionToReturn + 1 == numPartitions) && spilledPartitionsList.isEmpty() ) { \/\/ last partition ?\n\n        allFlushed = true; \/\/ next next() call will return NONE\n\n        logger.trace(\"HashAggregate: All batches flushed.\");\n\n        \/\/ cleanup my internal state since there is nothing more to return\n        this.cleanup();\n      }\n    }\n\n    return AggIterOutcome.AGG_OK;\n  }\n","new_comment_raw":"@return iteration outcome (e.g., OK, NONE ...)","old_comment_raw":"@return iteration outcome (e.g., OK, NONE ...)","label":0,"pre_label":1,"AST_level":17,"line_counts":193,"new_code_token_num":1505},{"new_code_raw":"public ApiResponse uploadFile (Long petId, String additionalMetadata, File file) throws ApiException { Object postBody = null; \/\/ verify the required parameter 'petId' is set if (petId == null) { throw new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFile\"); } \/\/ create path and map variables String path = \"\/pet\/{petId}\/uploadImage\".replaceAll(\"\\\\{format\\\\}\",\"json\").replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiInvoker.escapeString(petId.toString())); \/\/ query params List<Pair> queryParams = new ArrayList<Pair>(); \/\/ header params Map<String, String> headerParams = new HashMap<String, String>(); \/\/ form params Map<String, String> formParams = new HashMap<String, String>(); String[] contentTypes = { \"multipart\/form-data\" }; String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\"; if (contentType.startsWith(\"multipart\/form-data\")) { \/\/ file uploading MultipartEntityBuilder builder = MultipartEntityBuilder.create(); if (additionalMetadata != null) { builder.addTextBody(\"additionalMetadata\", ApiInvoker.parameterToString(additionalMetadata), ApiInvoker.TEXT_PLAIN_UTF8); } if (file != null) { builder.addBinaryBody(\"file\", file); } HttpEntity httpEntity = builder.build(); postBody = httpEntity; } else { \/\/ normal form params formParams.put(\"additionalMetadata\", ApiInvoker.parameterToString(additionalMetadata)); } try { String response = apiInvoker.invokeAPI(basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType); if(response != null){ return (ApiResponse) ApiInvoker.deserialize(response, \"\", ApiResponse.class); } else { return null; } } catch (ApiException ex) { throw ex; } }","old_code_raw":"  public void  uploadFile (Long petId, String additionalMetadata, File file) throws ApiException {\n    Object postBody = null;\n    \n    \/\/ verify the required parameter 'petId' is set\n    if (petId == null) {\n       throw new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFile\");\n    }\n    \n\n    \/\/ create path and map variables\n    String path = \"\/pet\/{petId}\/uploadImage\".replaceAll(\"\\\\{format\\\\}\",\"json\").replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiInvoker.escapeString(petId.toString()));\n\n    \/\/ query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    \/\/ header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    \/\/ form params\n    Map<String, String> formParams = new HashMap<String, String>();\n\n    \n\n    \n\n    String[] contentTypes = {\n      \"multipart\/form-data\"\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\";\n\n    if (contentType.startsWith(\"multipart\/form-data\")) {\n      \/\/ file uploading\n      MultipartEntityBuilder builder = MultipartEntityBuilder.create();\n      \n      if (additionalMetadata != null) {\n        builder.addTextBody(\"additionalMetadata\", ApiInvoker.parameterToString(additionalMetadata), ApiInvoker.TEXT_PLAIN_UTF8);\n      }\n      \n      if (file != null) {\n        builder.addBinaryBody(\"file\", file);\n      }\n      \n\n      HttpEntity httpEntity = builder.build();\n      postBody = httpEntity;\n    } else {\n      \/\/ normal form params\n      formParams.put(\"additionalMetadata\", ApiInvoker.parameterToString(additionalMetadata));\n      \n      \n    }\n\n    try {\n      String response = apiInvoker.invokeAPI(basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType);\n      if(response != null){\n        return ;\n      }\n      else {\n        return ;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n","new_comment_raw":"@return ApiResponse","old_comment_raw":"@return void","label":1,"pre_label":0,"AST_level":10,"line_counts":63,"new_code_token_num":369},{"new_code_raw":"public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) { return appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2); }","old_code_raw":"    public DateTimeFormatterBuilder appendDayOfMonth(final int minDigits) {\n        return appendDecimal(iChronoUTC.dayOfMonth(), minDigits, 2);\n    }\n","new_comment_raw":"@return this DateTimeFormatterBuilder","old_comment_raw":"@return this DateTimeFormatterBuilder","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":22},{"new_code_raw":"public Map<String, TopicMetadata> topicMetaData(final String... topicNames) { if (!running.get()) throw new IllegalStateException(STR); final ZkUtils z = getZkUtils(); final Set<String> set = (topicNames == null || topicNames.length == NUM) ? topicNames() : new LinkedHashSet<String>(Arrays.asList(topicNames)); final Set<TopicMetadata> meta = JavaConversions.setAsJavaSet(AdminUtils.fetchTopicMetadataFromZk(JavaConverters.asScalaSetConverter(set).asScala(), z)); final Map<String, TopicMetadata> map = new HashMap<String, TopicMetadata>(meta.size()); for (TopicMetadata tm : meta) { map.put(tm.topic(), tm); } return map; }","old_code_raw":"public Set<TopicMetadata> topicMetaData(final String... topicNames) {\n    if (!running.get())\n        throw new IllegalStateException(STR);\n    if (topicNames == null || topicNames.length == NUM)\n        return Collections.emptySet();\n    final ZkUtils z = getZkUtils();\n    final Set<String> set = new LinkedHashSet<String>(Arrays.asList(topicNames));\n    return JavaConversions.setAsJavaSet(AdminUtils.fetchTopicMetadataFromZk(JavaConverters.asScalaSetConverter(set).asScala(), z));\n}","new_comment_raw":"@return a map of TopicMetadatas keyed by topic name","old_comment_raw":"@return a set of TopicMetadatas","label":1,"pre_label":0,"AST_level":9,"line_counts":12,"new_code_token_num":128},{"new_code_raw":"public final int querySingleInt(String sqlCmd, int defVal, Connection conn) { return querySingleInt(sqlCmd, null, defVal, conn); }","old_code_raw":"public final int querySingleInt(String sqlCmd, int defVal, Connection conn) {\n    Object value = querySingleValue(sqlCmd, conn);\n    return ObjectUtils.getInteger(value, defVal);\n}","new_comment_raw":"@return the result as a int value","old_comment_raw":"@return the result as a int value, if no result the int value 0","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":28},{"new_code_raw":"private AutoInstallsLayout createWorkspaceLoaderFromAppRestriction(AppWidgetHost widgetHost) { Context ctx = getContext(); UserManager um = (UserManager) ctx.getSystemService(Context.USER_SERVICE); Bundle bundle = um.getApplicationRestrictions(ctx.getPackageName()); if (bundle == null) { return null; } String packageName = bundle.getString(RESTRICTION_PACKAGE_NAME); if (packageName != null) { try { Resources targetResources = ctx.getPackageManager() .getResourcesForApplication(packageName); return AutoInstallsLayout.get(ctx, packageName, targetResources, widgetHost, mOpenHelper); } catch (NameNotFoundException e) { Log.e(TAG, \"Target package for restricted profile not found\", e); return null; } } return null; }","old_code_raw":"    private AutoInstallsLayout createWorkspaceLoaderFromAppRestriction(AppWidgetHost widgetHost) {\n        \/\/ UserManager.getApplicationRestrictions() requires minSdkVersion >= 18\n        if (!Utilities.ATLEAST_JB_MR2) {\n            return null;\n        }\n\n        Context ctx = getContext();\n        UserManager um = (UserManager) ctx.getSystemService(Context.USER_SERVICE);\n        Bundle bundle = um.getApplicationRestrictions(ctx.getPackageName());\n        if (bundle == null) {\n            return null;\n        }\n\n        String packageName = bundle.getString(RESTRICTION_PACKAGE_NAME);\n        if (packageName != null) {\n            try {\n                Resources targetResources = ctx.getPackageManager()\n                        .getResourcesForApplication(packageName);\n                return AutoInstallsLayout.get(ctx, packageName, targetResources,\n                        widgetHost, mOpenHelper);\n            } catch (NameNotFoundException e) {\n                Log.e(TAG, \"Target package for restricted profile not found\", e);\n                return null;\n            }\n        }\n        return null;\n    }\n","new_comment_raw":"@return the loader if the restrictions are set and the resource exists; null otherwise.","old_comment_raw":"@return the loader if the restrictions are set and the resource exists; null otherwise.","label":0,"pre_label":1,"AST_level":10,"line_counts":23,"new_code_token_num":124},{"new_code_raw":"protected Control initControl(boolean ignoreProxyError) { if (!Control.initSingletonWithoutView(getControlOverrides()) && ! ignoreProxyError) { return null; } return Control.getSingleton(); }","old_code_raw":"    protected Control initControl() {\n        Control.initSingletonWithoutView(getControlOverrides());\n        return Control.getSingleton();\n    }\n","new_comment_raw":"@return the initialised  Control singleton, unless theres a problem setting up the proxy and ignoreProxyError is false","old_comment_raw":"@return the initialised Control singleton","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":35},{"new_code_raw":"public static ModuleConfig getModuleConfig(PageContext pageContext) { ModuleConfig moduleConfig = (ModuleConfig) pageContext.getRequest().getAttribute(Globals.MODULE_KEY); if (moduleConfig == null) { moduleConfig = (ModuleConfig) pageContext.getServletContext().getAttribute(Globals.MODULE_KEY); } return moduleConfig; }","old_code_raw":"public static ApplicationConfig getModuleConfig(PageContext pageContext) {\n    ApplicationConfig appConfig = (ApplicationConfig) pageContext.getRequest().getAttribute(Globals.MODULE_KEY);\n    if (appConfig == null) {\n        appConfig = (ApplicationConfig) pageContext.getServletContext().getAttribute(Globals.MODULE_KEY);\n    }\n    return appConfig;\n}","new_comment_raw":"@return the ModuleConfig object","old_comment_raw":"@return the ApplicationConfig object","label":1,"pre_label":0,"AST_level":10,"line_counts":7,"new_code_token_num":49},{"new_code_raw":"public boolean searchToggleButton(String search, int matches) { long now = System.currentTimeMillis(); final long endTime = now + TIMEOUT; while (!searchForToggleButton(search, matches) && now < endTime) { now = System.currentTimeMillis(); countMatches = 0; } countMatches = 0; if(now < endTime) return true; else return false; }","old_code_raw":"\tpublic boolean searchToggleButton(String search, int matches) {\n        long now = System.currentTimeMillis();\n        final long endTime = now + TIMEOUT;\n        while (!searchForToggleButton(search, matches) && now < endTime)\n        {\n        \tnow = System.currentTimeMillis();\n        }\n        return searchForToggleButton(search, matches);\n\t}\n","new_comment_raw":"@return true if a toggle button with the given text is found a given number of times and false if it is not found","old_comment_raw":"@return true if a toggle button with the given text is found a given number of times and false if it is not found","label":0,"pre_label":1,"AST_level":7,"line_counts":15,"new_code_token_num":66},{"new_code_raw":"private static String getPackageIdForApk(FilePath apkPath) throws IOException, InterruptedException { return apkPath.act(new FilePath.FileCallable<String>() { public String invoke(File f, VirtualChannel channel) throws IOException, InterruptedException { return getApkMetadata(f).getPackageName(); } }); }","old_code_raw":"private static String getPackageIdForApk(AbstractBuild<?, ?> build, Launcher launcher, PrintStream logger, AndroidSdk androidSdk, FilePath apkPath) throws IOException, InterruptedException {\n    ByteArrayOutputStream aaptOutput = new ByteArrayOutputStream();\n    String args = String.format(STR, apkPath.getName());\n    Utils.runAndroidTool(launcher, aaptOutput, logger, androidSdk, Tool.AAPT, args, apkPath.getParent());\n    String packageId = null;\n    String aaptResult = aaptOutput.toString();\n    if (aaptResult.length() > NUM) {\n        Matcher matcher = Pattern.compile(STR).matcher(aaptResult);\n        if (matcher.find()) {\n            packageId = matcher.group(NUM);\n        }\n    }\n    return packageId;\n}","new_comment_raw":"@return The package ID for the given APK.","old_comment_raw":"@return The package ID for the given APK, or {@code null} if it could not be determined.","label":1,"pre_label":0,"AST_level":9,"line_counts":8,"new_code_token_num":53},{"new_code_raw":"Folder getOpenFolder() { CellLayout currentScreen = (CellLayout) getChildAt(mCurrentScreen); int count = currentScreen.getChildCount(); for (int i = 0; i < count; i++) { View child = currentScreen.getChildAt(i); CellLayout.LayoutParams lp = (CellLayout.LayoutParams) child.getLayoutParams(); if (lp.cellHSpan == 4 && lp.cellVSpan == 4 && child instanceof Folder) { return (Folder) child; } } return null; }","old_code_raw":"    Folder getOpenFolder() {\n        CellLayout currentPage = (CellLayout) getChildAt(mCurrentPage);\n        int count = currentPage.getChildCount();\n        for (int i = 0; i < count; i++) {\n            View child = currentPage.getChildAt(i);\n            if (child instanceof Folder) {\n                Folder folder = (Folder) child;\n                if (folder.getInfo().opened)\n                    return folder;\n            }\n        }\n        return null;\n    }\n","new_comment_raw":"@return The open folder on the current screen, or null if there is none","old_comment_raw":"@return The open folder on the current screen, or null if there is none","label":0,"pre_label":1,"AST_level":9,"line_counts":13,"new_code_token_num":85},{"new_code_raw":"public String toString() { return ISOPeriodFormat.standard().print(this); }","old_code_raw":"    public String toString() {\n        return ISOPeriodFormat.getInstance().standard().print(this);\n    }\n","new_comment_raw":"@return the value as an ISO8601 string","old_comment_raw":"@return the value as an ISO8601 string","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":17},{"new_code_raw":"public Builder hasArgs() { numberOfArgs = Option.UNLIMITED_VALUES; return this; }","old_code_raw":"public boolean hasArgs() {\n    return numberOfArgs > NUM || numberOfArgs == UNLIMITED_VALUES;\n}","new_comment_raw":"@return this builder, to allow method chaining","old_comment_raw":"@return boolean flag indicating if multiple values are allowed","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":14},{"new_code_raw":"public GraphQLOutputType getType() { return type; }","old_code_raw":"    public GraphQLType getType() {\n        return type;\n    }\n","new_comment_raw":"@return the graphql type in question","old_comment_raw":"@return the graphql type in question","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"public double getExtraDouble(String key) throws JSONException { return mExtraData.getDouble(key); }","old_code_raw":"public double getExtraDouble(String key) {\n    return mExtraData.optDouble(key);\n}","new_comment_raw":"@return The stored value.","old_comment_raw":"@return The stored value or null if it doesn't exist in specified form.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":18},{"new_code_raw":"public static DateTimeFormatter hourMinute() { return Constants.hm; }","old_code_raw":"    public static DateTimeFormatter hourMinute() {\n        if (hm == null) {\n            hm = new DateTimeFormatterBuilder()\n                .append(hourElement())\n                .append(minuteElement())\n                .toFormatter();\n        }\n        return hm;\n    }\n","new_comment_raw":"@return a formatter for HH:mm","old_comment_raw":"@return a formatter for HH:mm","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":12},{"new_code_raw":"@SuppressWarnings(STR) public static <T, N extends TreeNode<T>> String toString(final N root) { final Function<N, String> toString; if (root instanceof Node<?>) { final Node<?> node = (Node<?>) root; toString = (Function<N, String>) node.toStringFunction(); } else { toString = new Function<N, String>() { @Override public String apply(final N input) { return Objects.firstNonNull(input.getData(), STR).toString(); } }; } return toString(root, toString); }","old_code_raw":"public static <T, N extends TreeNode<T>> String toString(final N node, final Function<N, String> toString) {\n    final String newLine = String.format(STR);\n    return toStringRecursive(node, toString, newLine);\n}","new_comment_raw":"@return the tree as a string","old_comment_raw":"@return the node as a string","label":1,"pre_label":0,"AST_level":11,"line_counts":17,"new_code_token_num":109},{"new_code_raw":"public static List<String> uniquify(List<String> nameList) { return uniquify(nameList, EXPR_SUGGESTER); }","old_code_raw":"    public static List<String> uniquify(List<String> nameList)\n    {\n        Set<String> used = new LinkedHashSet<String>();\n        int changeCount = 0;\n        for (int i = 0; i < nameList.size(); i++) {\n            String name = nameList.get(i);\n            String uniqueName = uniquify(name, used);\n            if (!uniqueName.equals(name)) {\n                ++changeCount;\n            }\n        }\n        return changeCount == 0\n           ? nameList\n           : new ArrayList<String>(used);\n    }\n","new_comment_raw":"@return List of unique strings","old_comment_raw":"@return List of unique strings","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"public static File locateInProject(String path) { File dir = new File(\".\").getAbsoluteFile(); while (dir != null) { File needle = new File(dir, path); if (needle.exists()) { return needle; } dir = dir.getParentFile(); } throw new WebDriverException(new FileNotFoundException( \"Could not find \" + path + \" in the project\")); }","old_code_raw":"  public static File locateInProject(String path) {\n    \/\/ It'll be one of these. Probably\n    String[] locations = {\n      \"..\/\",  \/\/ IDEA\n      \".\",     \/\/ Eclipse\n    };\n\n    for (String location : locations) {\n      File file = new File(location, path);\n      if (file.exists()) {\n        return file;\n      }\n    }\n\n    throw new WebDriverException(new FileNotFoundException(\n        \"Could not find \" + path + \" in the project\"));\n  }\n","new_comment_raw":"@return file being sought, if it exists","old_comment_raw":"@return file being saught, if it exists","label":1,"pre_label":0,"AST_level":8,"line_counts":14,"new_code_token_num":81},{"new_code_raw":"private int invoke_calculateBufferSize(int tdsVersion, int packetSize) { Class[] classes = new Class[] { int.class, int.class }; Object[] objects = new Object[] { new Integer(tdsVersion), new Integer(packetSize) }; return ((Integer) invokeStaticMethod(Support.class, STR, classes, objects)).intValue(); }","old_code_raw":"private int invoke_calculateBufferSize(int tdsVersion, int packetSize) {\n    Class[] classes = new Class[] { int.class, int.class };\n    Object[] objects = new Object[] { new Integer(tdsVersion), new Integer(packetSize) };\n    return ((Integer) invokeStaticMethod(SharedNamedPipe.class, STR, classes, objects)).intValue();\n}","new_comment_raw":"@return Result of calling {@link Support#calculateNamedPipeBufferSize(int, int)}.","old_comment_raw":"@return Result of calling {@link SharedNamedPipe#calculateBufferSize(int, int)}.","label":1,"pre_label":0,"AST_level":8,"line_counts":5,"new_code_token_num":71},{"new_code_raw":"private BigDecimal getCurrentCostPriceLL(MPPProductBOM bom, MCostElement element) { log.info(STR + element.getCostElementType()); BigDecimal costPriceLL = Env.ZERO; if (bom == null) return costPriceLL; for (MPPProductBOMLine bomline : bom.getLines()) { MProduct component = MProduct.get(getCtx(), bomline.getM_Product_ID()); for (MCost cost : getCosts(component, element.getCostElementType())) { BigDecimal qtyPercentage = bomline.getQtyBatch().divide(Env.ONEHUNDRED, NUM, BigDecimal.ROUND_UP); BigDecimal qtyBOM = bomline.getQtyBOM(); BigDecimal scrapDec = bomline.getScrap().divide(Env.ONEHUNDRED, NUM, BigDecimal.ROUND_UP); BigDecimal qtyTotal = Env.ZERO; if (bomline.isQtyPercentage()) { qtyTotal = qtyPercentage.divide(Env.ONE.subtract(scrapDec), NUM, BigDecimal.ROUND_HALF_UP); } else { qtyTotal = qtyBOM.divide(Env.ONE.subtract(scrapDec), NUM, BigDecimal.ROUND_HALF_UP); } BigDecimal costPrice = cost.getCurrentCostPrice().add(cost.getCurrentCostPriceLL()); costPriceLL = costPriceLL.add(costPrice.multiply(qtyTotal)); log.info(STR + element.getName() + STR + costPriceLL + STR + qtyPercentage + STR + qtyBOM); } } return costPriceLL; }","old_code_raw":"private BigDecimal getCurrentCostPriceLL(MPPProductBOM bom, MCostElement element, int Yield) {\n    log.info(STR + element.getCostElementType());\n    BigDecimal costPriceLL = Env.ZERO;\n    for (MPPProductBOMLine bomline : bom.getLines()) {\n        MProduct component = MProduct.get(getCtx(), bomline.getM_Product_ID());\n        for (MCost cost : getCosts(component, element.getCostElementType())) {\n            if (element.getCostElementType().equals(element.getCostElementType())) {\n                BigDecimal qtyPercentage = bomline.getQtyBatch().divide(Env.ONEHUNDRED, NUM, BigDecimal.ROUND_UP);\n                BigDecimal qtyBOM = bomline.getQtyBOM();\n                BigDecimal scrapDec = bomline.getScrap().divide(Env.ONEHUNDRED, NUM, BigDecimal.ROUND_UP);\n                BigDecimal qtyTotal = Env.ZERO;\n                if (bomline.isQtyPercentage()) {\n                    qtyTotal = qtyPercentage.divide(Env.ONE.subtract(scrapDec), NUM, BigDecimal.ROUND_HALF_UP);\n                } else {\n                    qtyTotal = qtyBOM.divide(Env.ONE.subtract(scrapDec), NUM, BigDecimal.ROUND_HALF_UP);\n                }\n                BigDecimal costPrice = cost.getCurrentCostPrice().add(cost.getCurrentCostPriceLL());\n                costPriceLL = costPriceLL.add(costPrice.multiply(qtyTotal));\n                log.info(STR + element.getName() + STR + costPriceLL + STR + qtyPercentage + STR + qtyBOM);\n            }\n        }\n    }\n    if (Yield != NUM) {\n        BigDecimal decimalYield = new BigDecimal(Yield \/ NUM);\n        costPriceLL = costPriceLL.divide(decimalYield, NUM, BigDecimal.ROUND_HALF_UP);\n    }\n    return costPriceLL;\n}","new_comment_raw":"@return Cost Price Lower Level","old_comment_raw":"@return CurrentCostPriceLL Sum Current Cost Price Level Low for this Cost Element Type","label":1,"pre_label":0,"AST_level":16,"line_counts":24,"new_code_token_num":223},{"new_code_raw":"public Material asMaterialFromName() { return Material.getMaterial(raw.toUpperCase()); }","old_code_raw":"public Material asMaterialFromName() {\n    return Material.getMaterial(arg.toUpperCase());\n}","new_comment_raw":"@return The material whose name is the same as the raw value, or null if no material has that name","old_comment_raw":"@return The material whose name is the same as the raw arg, or null if no material has that name","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":17},{"new_code_raw":"public String getTypeDeclaration(Schema p) { String schemaType = getSchemaType(p); if (schemaType != null) { schemaType = schemaType.replace(\"-\", \"_\"); } if (ModelUtils.isArraySchema(p)) { ArraySchema ap = (ArraySchema) p; Schema inner = ap.getItems(); return getTypeDeclaration(inner) + \"_Vectors.Vector\"; } if (ModelUtils.isMapSchema(p)) { Schema inner = (Schema) p.getAdditionalProperties(); String name = getTypeDeclaration(inner) + \"_Map\"; if (name.startsWith(\"Swagger.\")) { return name; } else { return \"Swagger.\" + name; } } if (typeMapping.containsKey(schemaType)) { return typeMapping.get(schemaType); } \/\/ LOGGER.info(\"Swagger type \" + schemaType); if (languageSpecificPrimitives.contains(schemaType)) { return schemaType; } String modelType = toModelName(schemaType).replace(\"-\", \"_\"); if (ModelUtils.isStringSchema(p) || ModelUtils.isFileSchema(p) || languageSpecificPrimitives.contains(modelType)) { return modelType; } return modelPackage + \".Models.\" + modelType; }","old_code_raw":"    public String getTypeDeclaration(Schema p) {\n        String schemaType = getSchemaType(p);\n\n        if (schemaType != null) {\n            schemaType = schemaType.replace(\"-\", \"_\");\n        }\n\n        if (ModelUtils.isArraySchema(p)) {\n            ArraySchema ap = (ArraySchema) p;\n            Schema inner = ap.getItems();\n            return getTypeDeclaration(inner) + \"_Vectors.Vector\";\n        }\n        if (ModelUtils.isMapSchema(p)) {\n            Schema inner = (Schema) p.getAdditionalProperties();\n            String name = getTypeDeclaration(inner) + \"_Map\";\n            if (name.startsWith(\"Swagger.\")) {\n                return name;\n            } else {\n                return \"Swagger.\" + name;\n            }\n        }\n        \/\/ TODO need to revise\/test the logic below to check \"required\"\n        if (typeMapping.containsKey(schemaType)) {\n            if (p.getRequired() != null && p.getRequired().contains(p.getName())) {\n                return typeMapping.get(schemaType);\n            } else {\n                return nullableTypeMapping.get(schemaType);\n            }\n        }\n        \/\/  LOGGER.info(\"Swagger type \" + schemaType);\n        if (languageSpecificPrimitives.contains(schemaType)) {\n            return schemaType;\n        }\n        String modelType = toModelName(schemaType).replace(\"-\", \"_\");\n        if (ModelUtils.isStringSchema(p) || ModelUtils.isFileSchema(p)\n                || languageSpecificPrimitives.contains(modelType)) {\n            return modelType;\n        }\n\n        return modelPackage + \".Models.\" + modelType;\n    }\n","new_comment_raw":"@return a string value used as the `dataType` field for model templates, `returnType` for api templates","old_comment_raw":"@return a string value used as the `dataType` field for model templates, `returnType` for api templates","label":0,"pre_label":1,"AST_level":9,"line_counts":37,"new_code_token_num":224},{"new_code_raw":"static boolean isNewStyleColumn(Common.ColumnValue column) { return column.hasField(HAS_ARRAY_VALUE_DESCRIPTOR) || column.hasField(SCALAR_VALUE_DESCRIPTOR); }","old_code_raw":"    static boolean isNewStyleColumn(Common.ColumnValue column) {\n      final Descriptor desc = column.getDescriptorForType();\n      return ProtobufService.hasField(column, desc, Common.ColumnValue.HAS_ARRAY_VALUE_FIELD_NUMBER)\n          || ProtobufService.hasField(column, desc, Common.ColumnValue.SCALAR_VALUE_FIELD_NUMBER);\n    }\n","new_comment_raw":"@return True if the message is the new style, false otherwise.","old_comment_raw":"@return True if the message is the new style, false otherwise.","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":24},{"new_code_raw":"public DateTimeFormatterBuilder appendDayOfYear(int minDigits) { return appendDecimal(DateTimeFieldType.dayOfYear(), minDigits, 3); }","old_code_raw":"    public DateTimeFormatterBuilder appendDayOfYear(final int minDigits) {\n        return appendDecimal(iChronoUTC.dayOfYear(), minDigits, 3);\n    }\n","new_comment_raw":"@return this DateTimeFormatterBuilder","old_comment_raw":"@return this DateTimeFormatterBuilder","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":22},{"new_code_raw":"@Override public Object clone() { try { DBTable clone = (DBTable) super.clone(); Class<?> colClass = columns.get(NUM).getClass(); Class<?> colBase = colClass.getSuperclass(); clone.columns = new ArrayList<DBColumn>(); Field[] fields = getClass().getFields(); for (int i = NUM; i < columns.size(); i++) { DBTableColumn srcCol = (DBTableColumn) columns.get(i); DBTableColumn newCol = new DBTableColumn(clone, srcCol); for (int j = NUM; j < fields.length; j++) { Class<?> type = fields[j].getType(); if (type == colClass || type == colBase) { try { if (fields[j].get(clone) == srcCol) fields[j].set(clone, newCol); } catch (Exception e) { String fieldName = fields[j].getName(); log.error(STR + fieldName + STR + e.getMessage()); CloneNotSupportedException cnse = new CloneNotSupportedException(STR + fieldName); cnse.initCause(e); throw cnse; } } } } clone.alias = STR + String.valueOf(tableCount.incrementAndGet()); log.info(STR + name + STR + alias + STR + clone.alias); return clone; } catch (CloneNotSupportedException e) { log.error(STR + getName()); throw new RuntimeException(e); } }","old_code_raw":"@Override\npublic Object clone() {\n    try {\n        DBTable clone = (DBTable) super.clone();\n        Class<?> colClass = columns.get(NUM).getClass();\n        Class<?> colBase = colClass.getSuperclass();\n        clone.columns = new ArrayList<DBColumn>();\n        Field[] fields = getClass().getDeclaredFields();\n        for (int i = NUM; i < columns.size(); i++) {\n            DBTableColumn srcCol = (DBTableColumn) columns.get(i);\n            DBTableColumn newCol = new DBTableColumn(clone, srcCol);\n            for (int j = NUM; j < fields.length; j++) {\n                Class<?> type = fields[j].getType();\n                if (type == colClass || type == colBase) {\n                    try {\n                        if (fields[j].get(clone) == srcCol)\n                            fields[j].set(clone, newCol);\n                    } catch (Exception e) {\n                        log.error(STR + fields[j].getName() + STR + e.getMessage());\n                    }\n                }\n            }\n        }\n        clone.alias = STR + String.valueOf(tableCount.incrementAndGet());\n        log.info(STR + name + STR + alias + STR + clone.alias);\n        return clone;\n    } catch (CloneNotSupportedException e) {\n        return null;\n    }\n}","new_comment_raw":"@return a table clone with new table alias","old_comment_raw":"@return this cloned Object","label":1,"pre_label":0,"AST_level":17,"line_counts":35,"new_code_token_num":272},{"new_code_raw":"public boolean isDelicious() { return this.isBaked() || this.isBoiled(); }","old_code_raw":"    public boolean isDelicious() {\n        try {\n            return this.isBaked() || this.isBoiled();\n        } catch (NotDeliciousException e) {\n            return false;\n        }\n    }\n","new_comment_raw":"@return true if this potato is delicious, false if otherwise","old_comment_raw":"@return true if this potato is delicious, false if otherwise","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":19},{"new_code_raw":"public boolean start() { if (isReleased()) throw new IllegalStateException(STR); return nativeStart(); }","old_code_raw":"public boolean start() {\n    if (!isReleased())\n        return nativeStart();\n    else\n        return false;\n}","new_comment_raw":"@return true the service is started","old_comment_raw":"@return true the serive is started","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":25},{"new_code_raw":"public static <T extends CharSequence> T notEmpty(final T chars) { return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE); }","old_code_raw":"public static <T extends Collection<?>> T notEmpty(final T collection) {\n    return notEmpty(collection, DEFAULT_NOT_EMPTY_COLLECTION_EX_MESSAGE);\n}","new_comment_raw":"@return the validated character sequence (never {@code null} method for chaining)","old_comment_raw":"@return the validated collection (never {@code null} method for chaining)","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":22},{"new_code_raw":"static public GenericServiceConnection<AcronymCall> newAcronymCallConnection() { return new GenericServiceConnection(AcronymCall.class); }","old_code_raw":"    static public GenericServiceConnection<AcronymCall> newAcronymCallConnection() {\n        return new GenericServiceConnection<AcronymCall>\n            (new GenericServiceConnection.InterfaceFactory<AcronymCall>() {\n                public AcronymCall asInterface(IBinder service) {\n                    return AcronymCall.Stub.asInterface(service);\n                }\n            });\n    }\n","new_comment_raw":"@return the GenericServiceConnection to use.","old_comment_raw":"@return the GenericServiceConnection to use.","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":17},{"new_code_raw":"@SuppressWarnings(STR) public ObjectName getQueueObjectName(String virtualHostName, String queue) { AllObjects allObject = new AllObjects(_mbsc); allObject.querystring = STR + virtualHostName + STR + queue + STR; Set<ObjectName> objectNames = allObject.returnObjects(); _test.assertNotNull(STR, objectNames); _test.assertEquals(STR + allObject.querystring + STR, NUM, objectNames.size()); ObjectName objectName = objectNames.iterator().next(); _test.getLogger().info(STR + objectName); return objectName; }","old_code_raw":"public ObjectName getQueueObjectName(String virtualHostName, String queue) {\n    AllObjects allObject = new AllObjects(_mbsc);\n    allObject.querystring = STR + virtualHostName + STR + queue + STR;\n    Set<ObjectName> objectNames = allObject.returnObjects();\n    _test.assertNotNull(STR, objectNames);\n    _test.assertEquals(STR + allObject.querystring + STR, NUM, objectNames.size());\n    return objectNames.iterator().next();\n}","new_comment_raw":"@return the ObjectName for the given queue on the VirtualHost","old_comment_raw":"@return the ObjectName for the given exchange on the test VirtualHost.","label":1,"pre_label":0,"AST_level":9,"line_counts":11,"new_code_token_num":95},{"new_code_raw":"public ApiResponse<ModelApiResponse> uploadFileWithHttpInfo(Long petId, String additionalMetadata, File file) throws ApiException { Call call = uploadFileCall(petId, additionalMetadata, file, null, null); Type localVarReturnType = new TypeToken<ModelApiResponse>(){}.getType(); return apiClient.execute(call, localVarReturnType); }","old_code_raw":"  public ApiResponse<ApiResponse> uploadFileWithHttpInfo(Long petId, String additionalMetadata, File file) throws ApiException {\n    Call call = uploadFileCall(petId, additionalMetadata, file, null, null);\n    Type localVarReturnType = new TypeToken<ApiResponse>(){}.getType();\n    return apiClient.execute(call, localVarReturnType);\n  }\n","new_comment_raw":"@return ApiResponse","old_comment_raw":"@return ApiResponse","label":0,"pre_label":1,"AST_level":8,"line_counts":6,"new_code_token_num":55},{"new_code_raw":"protected int getInSubqueryThreshold() { return config.getInSubqueryThreshold(); }","old_code_raw":"  protected int getInSubqueryThreshold() {\n    return IN_SUBQUERY_THRESHOLD;\n  }\n","new_comment_raw":"@return threshold, default  #DEFAULT_IN_SUBQUERY_THRESHOLD","old_comment_raw":"@return threshold, default #IN_SUBQUERY_THRESHOLD","label":1,"pre_label":0,"AST_level":4,"line_counts":4,"new_code_token_num":13},{"new_code_raw":"public static int[] getBodyToViewPosition(JTextArea view, String header, int start, int end) { validateView(view); validateHeader(header); validateStartEnd(start, end); if (!isValidStartEndForLength(start, end, view.getDocument().getLength())) { return INVALID_POSITION; } int excessChars = 0; int pos = 0; while ((pos = header.indexOf(HttpHeader.CRLF, pos)) != -1) { pos += 2; ++excessChars; } int len = view.getDocument().getLength(); int bodyLen = len - header.length() + excessChars; if (bodyLen < 0 || start > bodyLen || end > bodyLen) { return INVALID_POSITION; } int finalStartPos = start + header.length() - excessChars; int finalEndPos = end + header.length() - excessChars; return new int[] { finalStartPos, finalEndPos }; }","old_code_raw":"    public static int[] getBodyToViewPosition(JTextArea view, String header, int start, int end) {\n        validateView(view);\n        validateHeader(header);\n        validateStartEnd(start, end, view.getDocument().getLength());\n\n        int excessChars = 0;\n\n        int pos = 0;\n        while ((pos = header.indexOf(HttpHeader.CRLF, pos)) != -1) {\n            pos += 2;\n            ++excessChars;\n        }\n\n        int len = view.getDocument().getLength();\n        int bodyLen = len - header.length() + excessChars;\n        if (bodyLen < 0 || start > bodyLen || end > bodyLen) {\n            return INVALID_POSITION;\n        }\n\n        int finalStartPos = start + header.length() - excessChars;\n        int finalEndPos = end + header.length() - excessChars;\n        return new int[] { finalStartPos, finalEndPos };\n    }\n","new_comment_raw":"@return the positions offset for the  view, or  #INVALID_POSITION if the  start and  end positions are greater than the length of the body or the  view.","old_comment_raw":"@return the positions offset for the view, or #INVALID_POSITION if the start and end positions are greater than body's length.","label":1,"pre_label":0,"AST_level":7,"line_counts":28,"new_code_token_num":168},{"new_code_raw":"public IndexLinkedList getList() { return indexList; }","old_code_raw":"public IndexLinkedList getList() {\n    return list;\n}","new_comment_raw":"@return the indexList","old_comment_raw":"@return the list","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":10},{"new_code_raw":"public String getTypeDeclaration(Schema p) { String openAPIType = getSchemaType(p); if (ModelUtils.isArraySchema(p)) { ArraySchema ap = (ArraySchema) p; Schema inner = ap.getItems(); return getSchemaType(p) + \"<\" + getTypeDeclaration(inner) + \">\"; } if (ModelUtils.isMapSchema(p)) { Schema inner = (Schema) p.getAdditionalProperties(); return getSchemaType(p) + \"<std::string, \" + getTypeDeclaration(inner) + \">\"; } else if (ModelUtils.isByteArraySchema(p)) { return \"std::string\"; } if (ModelUtils.isStringSchema(p) || ModelUtils.isDateSchema(p) || ModelUtils.isDateTimeSchema(p) || ModelUtils.isFileSchema(p) || languageSpecificPrimitives.contains(openAPIType)) { return toModelName(openAPIType); } return openAPIType; }","old_code_raw":"    public String getTypeDeclaration(Schema p) {\n        String openAPIType = getSchemaType(p);\n\n        if (ModelUtils.isArraySchema(p)) {\n            ArraySchema ap = (ArraySchema) p;\n            Schema inner = ap.getItems();\n            return getSchemaType(p) + \"<\" + getTypeDeclaration(inner) + \">\";\n        }\n        if (ModelUtils.isMapSchema(p)) {\n            Schema inner = (Schema) p.getAdditionalProperties();\n            return getSchemaType(p) + \"<std::string, \" + getTypeDeclaration(inner) + \">\";\n        }\n        if (ModelUtils.isStringSchema(p)\n                || ModelUtils.isDateSchema(p)\n                || ModelUtils.isDateTimeSchema(p) || ModelUtils.isFileSchema(p)\n                || languageSpecificPrimitives.contains(openAPIType)) {\n            return toModelName(openAPIType);\n        }\n\n        return openAPIType;\n    }\n","new_comment_raw":"@return a string value used as the `dataType` field for model templates, `returnType` for api templates","old_comment_raw":"@return a string value used as the `dataType` field for model templates, `returnType` for api templates","label":0,"pre_label":1,"AST_level":10,"line_counts":25,"new_code_token_num":165},{"new_code_raw":"public String getAuthorizationUrl(String state, Map<String, String> additionalParams, PKCE pkce) { return createAuthorizationUrlBuilder() .state(state) .additionalParams(additionalParams) .pkce(pkce) .build(); }","old_code_raw":"    public String getAuthorizationUrl(Map<String, String> additionalParams) {\n        return getAuthorizationUrl(null, additionalParams);\n    }\n","new_comment_raw":"@return url","old_comment_raw":"@return the URL where you should redirect your users","label":1,"pre_label":0,"AST_level":6,"line_counts":8,"new_code_token_num":38},{"new_code_raw":"public static long toNanoOfDay(Object value, TemporalAdjuster adjuster) { LocalTime time = Conversions.toLocalTime(value); if (adjuster !=null) { time = time.with(adjuster); } return time.toNanoOfDay(); }","old_code_raw":"    public static long toNanoOfDay(Object value) {\n        return Conversions.toLocalTime(value).toNanoOfDay();\n    }\n","new_comment_raw":"@return the nanoseconds past midnight","old_comment_raw":"@return the nanoseconds past midnight","label":0,"pre_label":1,"AST_level":8,"line_counts":8,"new_code_token_num":42},{"new_code_raw":"@ManagedAttribute(description = STR) public long getNewPeriodCount() { return newPeriodCount.longValue(); }","old_code_raw":"public LongAdder getNewPeriodCount() {\n    return newPeriodCount;\n}","new_comment_raw":"@return the total number of created periods","old_comment_raw":"@return the newPeriodCount","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":19},{"new_code_raw":"public String toDefaultValue(Schema schema) { if (schema.getDefault() != null) { return schema.getDefault().toString(); } return getPropertyDefaultValue(schema); }","old_code_raw":"    public String toDefaultValue(Schema schema) {\n        if (schema.getDefault() != null) {\n            return schema.getDefault().toString();\n        }\n\n        if (ModelUtils.isBooleanSchema(schema)) {\n            return \"null\";\n        } else if (ModelUtils.isDateSchema(schema)) {\n            return \"null\";\n        } else if (ModelUtils.isDateTimeSchema(schema)) {\n            return \"null\";\n        } else if (ModelUtils.isNumberSchema(schema)) {\n            return \"null\";\n        } else if (ModelUtils.isIntegerSchema(schema)) {\n            return \"null\";\n        } else if (ModelUtils.isStringSchema(schema)) {\n            return \"null\";\n        } else if (ModelUtils.isObjectSchema(schema)) {\n            return \"null\";\n        } else {\n            return \"null\";\n        }\n    }\n","new_comment_raw":"@return string presentation of the default value of the property","old_comment_raw":"@return string presentation of the default value of the property","label":0,"pre_label":1,"AST_level":7,"line_counts":8,"new_code_token_num":35},{"new_code_raw":"public static String versionName() { return \"1.0.2\"; }","old_code_raw":"    public static String versionName() {\n        return \"1.0.1\";\n    }\n","new_comment_raw":"@return  String.","old_comment_raw":"@return String.","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":15},{"new_code_raw":"public static ChainFinder chain(Finder first, Finder second) { return new ChainFinder(first, second); }","old_code_raw":"public static ChainMatcher chain(Matcher first, Matcher second) {\n    return new ChainMatcher(first, second);\n}","new_comment_raw":"@return a finder that uses the UiElement returned by first Finder as context for the second Finder","old_comment_raw":"@return a matcher that uses the UiElement returned by first Matcher as context for the second Matcher","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":22},{"new_code_raw":"protected Tree determineNonTrivialHead(Tree t, Tree parent) { String motherCat = tlp.basicCategory(t.label().value()); if (DEBUG) { System.err.println(\"At \" + motherCat + \", my parent is \" + parent); } \/\/ do VPs with auxiliary as special case if ((motherCat.equals(\"VP\") || motherCat.equals(\"SQ\") || motherCat.equals(\"SINV\"))) { Tree[] kids = t.children(); \/\/ try to find if there is an auxiliary verb if (DEBUG) { System.err.println(\"Semantic head finder: at VP\"); System.err.println(\"Class is \" + t.getClass().getName()); t.pennPrint(System.err); \/\/System.err.println(\"hasVerbalAuxiliary = \" + hasVerbalAuxiliary(kids, verbalAuxiliaries)); } \/\/ looks for auxiliaries if (hasVerbalAuxiliary(kids, verbalAuxiliaries) || hasPassiveProgressiveAuxiliary(kids, passiveAuxiliaries)) { \/\/ String[] how = new String[] {\"left\", \"VP\", \"ADJP\", \"NP\"}; \/\/ Including NP etc seems okay for copular sentences but is \/\/ problematic for other auxiliaries, like 'he has an answer' \/\/ But maybe doing ADJP is fine! String[] how = { \"left\", \"VP\", \"ADJP\" }; Tree pti = traverseLocate(kids, how, false); if (DEBUG) { System.err.println(\"Determined head (case 1) for \" + t.value() + \" is: \" + pti); } if (pti != null) { return pti; } else { \/\/ System.err.println(\"------\"); \/\/ System.err.println(\"SemanticHeadFinder failed to reassign head for\"); \/\/ t.pennPrint(System.err); \/\/ System.err.println(\"------\"); } } \/\/ looks for copular verbs if (hasVerbalAuxiliary(kids, copulars) && ! isExistential(t, parent) && ! isWHQ(t, parent)) { String[] how; if (motherCat.equals(\"SQ\")) { how = new String[]{\"right\", \"VP\", \"ADJP\", \"NP\", \"WHADJP\", \"WHNP\"}; } else { how = new String[]{\"left\", \"VP\", \"ADJP\", \"NP\", \"WHADJP\", \"WHNP\"}; } Tree pti = traverseLocate(kids, how, false); \/\/ don't allow a temporal to become head if (pti != null && pti.label() != null && pti.label().value().contains(\"-TMP\")) { pti = null; } \/\/ In SQ, only allow an NP to become head if there is another one to the left (then it's probably predicative) if (motherCat.equals(\"SQ\") && pti != null && pti.label() != null && pti.label().value().startsWith(\"NP\")) { boolean foundAnotherNp = false; for (Tree kid : kids) { if (kid == pti) { break; } else if (kid.label() != null && kid.label().value().startsWith(\"NP\")) { foundAnotherNp = true; break; } } if ( ! foundAnotherNp) { pti = null; } } if (DEBUG) { System.err.println(\"Determined head (case 2) for \" + t.value() + \" is: \" + pti); } if (pti != null) { return pti; } else { if (DEBUG) { System.err.println(\"------\"); System.err.println(\"SemanticHeadFinder failed to reassign head for\"); t.pennPrint(System.err); System.err.println(\"------\"); } } } } Tree hd = super.determineNonTrivialHead(t, parent); \/\/ Heuristically repair punctuation heads Tree[] hdChildren = hd.children(); if (hdChildren != null && hdChildren.length > 0 && hdChildren[0].isLeaf()) { if (tlp.isPunctuationWord(hdChildren[0].label().value())) { Tree[] tChildren = t.children(); if (DEBUG) { System.err.printf(\"head is punct: %s\\n\", hdChildren[0].label()); } for (int i = tChildren.length - 1; i >= 0; i--) { if (!tlp.isPunctuationWord(tChildren[i].children()[0].label().value())) { hd = tChildren[i]; if (DEBUG) { System.err.printf(\"New head: %s %s\", hd.label(), hd.children()[0].label()); } break; } } } } if (DEBUG) { System.err.println(\"Determined head (case 3) for \" + t.value() + \" is: \" + hd); } return hd; }","old_code_raw":"  protected Tree determineNonTrivialHead(Tree t, Tree parent) {\n    String motherCat = tlp.basicCategory(t.label().value());\n\n    if (DEBUG) {\n      System.err.println(\"At \" + motherCat + \", my parent is \" + parent);\n    }\n\n    \/\/ Some conj expressions seem to make more sense with the \"not\" or\n    \/\/ other key words as the head.  For example, \"and not\" means\n    \/\/ something completely different than \"and\".  Furthermore,\n    \/\/ downstream code was written assuming \"not\" would be the head...\n    if (motherCat.equals(\"CONJP\")) {\n      for (TregexPattern pattern : headOfConjpTregex) {\n        TregexMatcher matcher = pattern.matcher(t);\n        if (matcher.matchesAt(t)) {\n          return matcher.getNode(\"head\");\n        }\n      }\n      \/\/ if none of the above patterns match, use the standard method\n    }\n\n    if (motherCat.equals(\"SBARQ\") || motherCat.equals(\"SINV\")) {\n      if (!makeCopulaHead) {\n        for (TregexPattern pattern : headOfCopulaTregex) {\n          TregexMatcher matcher = pattern.matcher(t);\n          if (matcher.matchesAt(t)) {\n            return matcher.getNode(\"head\");\n          }\n        }\n      }\n      \/\/ if none of the above patterns match, use the standard method\n    }\n\n    \/\/ do VPs with auxiliary as special case\n    if ((motherCat.equals(\"VP\") || motherCat.equals(\"SQ\") || motherCat.equals(\"SINV\"))) {\n      Tree[] kids = t.children();\n      \/\/ try to find if there is an auxiliary verb\n\n      if (DEBUG) {\n        System.err.println(\"Semantic head finder: at VP\");\n        System.err.println(\"Class is \" + t.getClass().getName());\n        t.pennPrint(System.err);\n        \/\/System.err.println(\"hasVerbalAuxiliary = \" + hasVerbalAuxiliary(kids, verbalAuxiliaries));\n      }\n\n      \/\/ looks for auxiliaries\n      Tree[] tmpFilteredChildren = null;\n      if (hasVerbalAuxiliary(kids, verbalAuxiliaries, true) || hasPassiveProgressiveAuxiliary(kids)) {\n        \/\/ String[] how = new String[] {\"left\", \"VP\", \"ADJP\", \"NP\"};\n        \/\/ Including NP etc seems okay for copular sentences but is\n        \/\/ problematic for other auxiliaries, like 'he has an answer'\n        String[] how ;\n        if (hasVerbalAuxiliary(kids, copulars, true)) {\n          \/\/ Only allow ADJP in copular constructions\n          \/\/ In constructions like \"It gets cold\", \"get\" should be the head\n          how = new String[]{ \"left\", \"VP\", \"ADJP\" };\n        } else {\n          how = new String[]{ \"left\", \"VP\" };\n        }\n\n        if (tmpFilteredChildren == null) {\n          tmpFilteredChildren = ArrayUtils.filter(kids, REMOVE_TMP_AND_ADV);\n        }\n        Tree pti = traverseLocate(tmpFilteredChildren, how, false);\n        if (DEBUG) {\n          System.err.println(\"Determined head (case 1) for \" + t.value() + \" is: \" + pti);\n        }\n        if (pti != null) {\n          return pti;\n        \/\/ } else {\n          \/\/ System.err.println(\"------\");\n          \/\/ System.err.println(\"SemanticHeadFinder failed to reassign head for\");\n          \/\/ t.pennPrint(System.err);\n          \/\/ System.err.println(\"------\");\n        }\n      }\n\n      \/\/ looks for copular verbs\n      if (hasVerbalAuxiliary(kids, copulars, false) && ! isExistential(t, parent) && ! isWHQ(t, parent)) {\n        String[] how;\n        if (motherCat.equals(\"SQ\")) {\n          how = new String[]{\"right\", \"VP\", \"ADJP\", \"NP\", \"WHADJP\", \"WHNP\"};\n        } else {\n          how = new String[]{\"left\", \"VP\", \"ADJP\", \"NP\", \"WHADJP\", \"WHNP\"};\n        }\n        \/\/ Avoid undesirable heads by filtering them from the list of potential children\n        if (tmpFilteredChildren == null) {\n          tmpFilteredChildren = ArrayUtils.filter(kids, REMOVE_TMP_AND_ADV);\n        }\n        Tree pti = traverseLocate(tmpFilteredChildren, how, false);\n        \/\/ In SQ, only allow an NP to become head if there is another one to the left (then it's probably predicative)\n        if (motherCat.equals(\"SQ\") && pti != null && pti.label() != null && pti.label().value().startsWith(\"NP\")) {\n            boolean foundAnotherNp = false;\n            for (Tree kid : kids) {\n              if (kid == pti) {\n                break;\n              } else if (kid.label() != null && kid.label().value().startsWith(\"NP\")) {\n                foundAnotherNp = true;\n                break;\n              }\n            }\n          if ( ! foundAnotherNp) {\n            pti = null;\n          }\n        }\n\n        if (DEBUG) {\n          System.err.println(\"Determined head (case 2) for \" + t.value() + \" is: \" + pti);\n        }\n        if (pti != null) {\n          return pti;\n        } else {\n          if (DEBUG) {\n            System.err.println(\"------\");\n            System.err.println(\"SemanticHeadFinder failed to reassign head for\");\n            t.pennPrint(System.err);\n            System.err.println(\"------\");\n          }\n        }\n      }\n    }\n\n    Tree hd = super.determineNonTrivialHead(t, parent);\n\n    \/* ----\n    \/\/ This should now be handled at the AbstractCollinsHeadFinder level, so see if we can comment this out\n    \/\/ Heuristically repair punctuation heads\n    Tree[] hdChildren = hd.children();\n    if (hdChildren != null && hdChildren.length > 0 &&\n        hdChildren[0].isLeaf()) {\n      if (tlp.isPunctuationWord(hdChildren[0].label().value())) {\n         Tree[] tChildren = t.children();\n         if (DEBUG) {\n           System.err.printf(\"head is punct: %s\\n\", hdChildren[0].label());\n         }\n         for (int i = tChildren.length - 1; i >= 0; i--) {\n           if (!tlp.isPunctuationWord(tChildren[i].children()[0].label().value())) {\n             hd = tChildren[i];\n             if (DEBUG) {\n               System.err.printf(\"New head of %s is %s%n\", hd.label(), hd.children()[0].label());\n             }\n             break;\n           }\n         }\n      }\n    }\n    *\/\n\n    if (DEBUG) {\n      System.err.println(\"Determined head (case 3) for \" + t.value() + \" is: \" + hd);\n    }\n    return hd;\n  }\n","new_comment_raw":"@return The parse tree that is the head","old_comment_raw":"@return The parse tree that is the head","label":0,"pre_label":1,"AST_level":17,"line_counts":114,"new_code_token_num":1034},{"new_code_raw":"public JsonWriter value(String value) throws IOException { if (value == null) { return nullValue(); } if (promoteNameToValue) { return name(value); } writeDeferredName(); beforeValue(false); string(value); pathIndices[stackSize - 1]++; return this; }","old_code_raw":"  public JsonWriter value(String value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue(false);\n    string(value);\n    pathIndices[stackSize - 1]++;\n    return this;\n  }\n","new_comment_raw":"@return this writer.","old_comment_raw":"@return this writer.","label":0,"pre_label":1,"AST_level":7,"line_counts":14,"new_code_token_num":61},{"new_code_raw":"public static int[] getViewToHeaderPosition(JTextArea view, int start, int end) { validateView(view); validateStartEnd(start, end); if (!isValidStartEndForLength(start, end, view.getDocument().getLength())) { return INVALID_POSITION; } return getViewToHeaderPositionImpl(view, start, end); }","old_code_raw":"    public static int[] getViewToHeaderPosition(JTextArea view, int start, int end) {\n        validateView(view);\n        validateStartEnd(start, end, view.getDocument().getLength());\n        return getViewToHeaderPositionImpl(view, start, end);\n    }\n","new_comment_raw":"@return the positions offset for the header, or  #INVALID_POSITION if the  start or  end is greater than the length of the  view","old_comment_raw":"@return the positions offset for the header","label":1,"pre_label":0,"AST_level":6,"line_counts":11,"new_code_token_num":63},{"new_code_raw":"public Pet getPetById(Long petId) throws ApiException { Object localVarPostBody = null; \/\/ verify the required parameter 'petId' is set if (petId == null) { throw new ApiException(400, \"Missing the required parameter 'petId' when calling getPetById\"); } \/\/ create path and map variables String localVarPath = \"\/pet\/{petId}\" .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString())); \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, String> localVarCookieParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { \"application\/xml\", \"application\/json\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { \"api_key\" }; GenericType<Pet> localVarReturnType = new GenericType<Pet>() {}; return apiClient.invokeAPI(localVarPath, \"GET\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public Pet getPetById(Long petId) throws ApiException {\n    Object localVarPostBody = null;\n    \n    \/\/ verify the required parameter 'petId' is set\n    if (petId == null) {\n      throw new ApiException(400, \"Missing the required parameter 'petId' when calling getPetById\");\n    }\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/pet\/{petId}\"\n      .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString()));\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application\/xml\", \"application\/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] { \"api_key\" };\n\n    GenericType<Pet> localVarReturnType = new GenericType<Pet>() {};\n    return apiClient.invokeAPI(localVarPath, \"GET\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@return Pet","old_comment_raw":"@return Pet","label":0,"pre_label":1,"AST_level":9,"line_counts":39,"new_code_token_num":260},{"new_code_raw":"protected RelNode trimUnusedFields(RelNode rootRel) { final SqlToRelConverter converter = getSqlToRelConverter( getSqlValidator(), catalogReader); converter.setTrimUnusedFields(shouldTrim(rootRel)); return converter.trimUnusedFields(ordered, rootRel); }","old_code_raw":"  protected RelNode trimUnusedFields(RelNode rootRel) {\n    final SqlToRelConverter converter =\n        getSqlToRelConverter(\n            getSqlValidator(), catalogReader);\n    converter.setTrimUnusedFields(shouldTrim(rootRel));\n    return converter.trimUnusedFields(rootRel);\n  }\n","new_comment_raw":"@return Trimmed relational expression","old_comment_raw":"@return Trimmed relational expression","label":0,"pre_label":1,"AST_level":6,"line_counts":8,"new_code_token_num":39},{"new_code_raw":"public int getSeconds() { return getPeriodType().getIndexedField(this, PeriodType.SECOND_INDEX); }","old_code_raw":"    public int getSeconds() {\n        return getPeriodType().getSeconds(this);\n    }\n","new_comment_raw":"@return the number of seconds in the period, zero if unsupported","old_comment_raw":"@return the number of seconds in the period, zero if unsupported","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":19},{"new_code_raw":"public android.telecom.Connection.VideoProvider getVideoProvider() { return mVideoProvider; }","old_code_raw":"public android.telecomm.Connection.VideoProvider getVideoProvider() {\n    return mVideoProvider;\n}","new_comment_raw":"@return The {@link android.telecom.Connection.VideoProvider}.","old_comment_raw":"@return The {@link android.telecomm.Connection.VideoProvider}.","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":13},{"new_code_raw":"public NumberExpression<Integer> locate(Expression<String> str, NumberExpression<Integer> start) { return NumberOperation.create(Integer.class, Ops.StringOps.LOCATE2, str, mixin, start); }","old_code_raw":"    public NumberExpression<Integer> locate(Expression<String> str, NumberExpression<Integer> start) {\n        return NumberOperation.create(Integer.class, Ops.StringOps.LOCATE2, str, this, start);\n    }\n","new_comment_raw":"@return locate(str, this, start)","old_comment_raw":"@return locate(str, this, start)","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":33},{"new_code_raw":"public Future<List<Broadcaster>> broadcastTo(String broadcasterID, Object message) { return map(broadcasterID, message, -1, null, false); }","old_code_raw":"    public Future<List<Broadcaster>> broadcastTo(String broadcasterID, Object message) {\n        return map(broadcasterID, message, -1, null);\n    }\n","new_comment_raw":"@return a Future.","old_comment_raw":"@return a Future.","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":29},{"new_code_raw":"private Producer<EncodedImage> newDiskCacheSequence(Producer<EncodedImage> inputProducer) { Producer<EncodedImage> cacheWriteProducer; if (mPartialImageCachingEnabled) { Producer<EncodedImage> partialDiskCacheProducer = mProducerFactory.newPartialDiskCacheProducer(inputProducer); cacheWriteProducer = mProducerFactory.newDiskCacheWriteProducer(partialDiskCacheProducer); } else { cacheWriteProducer = mProducerFactory.newDiskCacheWriteProducer(inputProducer); } return mProducerFactory.newDiskCacheReadProducer(cacheWriteProducer); }","old_code_raw":"  private Producer<EncodedImage> newDiskCacheSequence(Producer<EncodedImage> inputProducer) {\n    Producer<EncodedImage> cacheWriteProducer;\n    if (mPartialImageCachingEnabled) {\n      Producer<EncodedImage> partialDiskCacheProducer =\n          mProducerFactory.newPartialDiskCacheProducer(inputProducer);\n      cacheWriteProducer = mProducerFactory.newDiskCacheWriteProducer(partialDiskCacheProducer);\n    } else {\n      cacheWriteProducer = mProducerFactory.newDiskCacheWriteProducer(inputProducer);\n    }\n    Producer<EncodedImage> mediaVariationsProducer =\n        mProducerFactory.newMediaVariationsProducer(cacheWriteProducer);\n    return mProducerFactory.newDiskCacheReadProducer(mediaVariationsProducer);\n  }\n","new_comment_raw":"@return encoded cache multiplex to webp transcode sequence","old_comment_raw":"@return encoded cache multiplex to webp transcode sequence","label":0,"pre_label":1,"AST_level":8,"line_counts":12,"new_code_token_num":54},{"new_code_raw":"public ErrorLevel getLevel() { return level; }","old_code_raw":"public VirErrorLevel getLevel() {\n    return level;\n}","new_comment_raw":"@return a ErrorLevel","old_comment_raw":"@return a VirErrorLevel","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":10},{"new_code_raw":"private Annotation getDocument(Properties props, HttpExchange httpExchange) throws IOException, ClassNotFoundException { String inputFormat = props.getProperty(\"inputFormat\", \"text\"); String date = props.getProperty(\"date\"); switch (inputFormat) { case \"text\": \/\/ The default encoding by the HTTP standard is ISO-8859-1, but most \/\/ real users of CoreNLP would likely assume UTF-8 by default. String defaultEncoding = this.strict ? \"ISO-8859-1\" : \"UTF-8\"; \/\/ Get the encoding Headers h = httpExchange.getRequestHeaders(); String encoding; if (h.containsKey(\"Content-type\")) { String[] charsetPair = Arrays.asList(h.getFirst(\"Content-type\").split(\";\")).stream() .map(x -> x.split(\"=\")) .filter(x -> x.length > 0 && \"charset\".equals(x[0])) .findFirst().orElse(new String[]{\"charset\", defaultEncoding}); if (charsetPair.length == 2) { encoding = charsetPair[1]; } else { encoding = defaultEncoding; } } else { encoding = defaultEncoding; } String text = IOUtils.slurpReader(IOUtils.encodedInputStreamReader(httpExchange.getRequestBody(), encoding)); text = URLDecoder.decode(text, encoding).trim(); \/\/ TODO(chaganty): URLdecode string. \/\/ Read the annotation Annotation annotation = new Annotation(text); \/\/ Set the date (if provided) if (date != null) { annotation.set(CoreAnnotations.DocDateAnnotation.class, date); } return annotation; case \"serialized\": String inputSerializerName = props.getProperty(\"inputSerializer\", ProtobufAnnotationSerializer.class.getName()); AnnotationSerializer serializer = MetaClass.create(inputSerializerName).createInstance(); Pair<Annotation, InputStream> pair = serializer.read(httpExchange.getRequestBody()); return pair.first; default: throw new IOException(\"Could not parse input format: \" + inputFormat); } }","old_code_raw":"  private Annotation getDocument(Properties props, HttpExchange httpExchange) throws IOException, ClassNotFoundException {\n    String inputFormat = props.getProperty(\"inputFormat\", \"text\");\n    switch (inputFormat) {\n      case \"text\":\n        \/\/ The default encoding by the HTTP standard is ISO-8859-1, but most\n        \/\/ real users of CoreNLP would likely assume UTF-8 by default.\n        String defaultEncoding = this.strict ? \"ISO-8859-1\" : \"UTF-8\";\n        \/\/ Get the encoding\n        Headers h = httpExchange.getRequestHeaders();\n        String encoding;\n        if (h.containsKey(\"Content-type\")) {\n          String[] charsetPair = Arrays.asList(h.getFirst(\"Content-type\").split(\";\")).stream()\n              .map(x -> x.split(\"=\"))\n              .filter(x -> x.length > 0 && \"charset\".equals(x[0]))\n              .findFirst().orElse(new String[]{\"charset\", defaultEncoding});\n          if (charsetPair.length == 2) {\n            encoding = charsetPair[1];\n          } else {\n            encoding = defaultEncoding;\n          }\n        } else {\n          encoding = defaultEncoding;\n        }\n\n        String text = IOUtils.slurpReader(IOUtils.encodedInputStreamReader(httpExchange.getRequestBody(), encoding));\n        text = URLDecoder.decode(text, encoding).trim();\n        \/\/ TODO(chaganty): URLdecode string.\n        \/\/ Read the annotation\n        return new Annotation(text);\n      case \"serialized\":\n        String inputSerializerName = props.getProperty(\"inputSerializer\", ProtobufAnnotationSerializer.class.getName());\n        AnnotationSerializer serializer = MetaClass.create(inputSerializerName).createInstance();\n        Pair<Annotation, InputStream> pair = serializer.read(httpExchange.getRequestBody());\n        return pair.first;\n      default:\n        throw new IOException(\"Could not parse input format: \" + inputFormat);\n    }\n  }\n","new_comment_raw":"@return An Annotation representing the read document.","old_comment_raw":"@return An Annotation representing the read document.","label":0,"pre_label":1,"AST_level":17,"line_counts":45,"new_code_token_num":381},{"new_code_raw":"public DictionaryInfo trySaveNewDict(Dictionary<?> newDict, DictionaryInfo newDictInfo) throws IOException { initDictInfo(newDict, newDictInfo); if (KylinConfig.getInstanceFromEnv().isGrowingDictEnabled()) { DictionaryInfo largestDictInfo = findLargestDictInfo(newDictInfo); if (largestDictInfo != null) { largestDictInfo = getDictionaryInfo(largestDictInfo.getResourcePath()); Dictionary<?> largestDictObject = largestDictInfo.getDictionaryObject(); if (largestDictObject.contains(newDict)) { logger.info(\"dictionary content \" + newDict + \", is contained by dictionary at \" + largestDictInfo.getResourcePath()); return largestDictInfo; } else if (newDict.contains(largestDictObject)) { logger.info(\"dictionary content \" + newDict + \" is by far the largest, save it\"); return saveNewDict(newDictInfo); } else { logger.info(\"merge dict and save...\"); return mergeDictionary(Lists.newArrayList(newDictInfo, largestDictInfo)); } } else { logger.info(\"first dict of this column, save it directly\"); return saveNewDict(newDictInfo); } } else { logger.info(\"Growing dict is not enabled\"); String dupDict = checkDupByContent(newDictInfo, newDict); if (dupDict != null) { logger.info(\"Identical dictionary content, reuse existing dictionary at \" + dupDict); return getDictionaryInfo(dupDict); } return saveNewDict(newDictInfo); } }","old_code_raw":"    public DictionaryInfo trySaveNewDict(Dictionary<?> newDict, DictionaryInfo newDictInfo) throws IOException {\n\n        initDictInfo(newDict, newDictInfo);\n\n        DictionaryInfo largestDictInfo = findLargestDictInfo(newDictInfo);\n        if (largestDictInfo != null) {\n            largestDictInfo = getDictionaryInfo(largestDictInfo.getResourcePath());\n            Dictionary<?> largestDictObject = largestDictInfo.getDictionaryObject();\n            if (largestDictObject.contains(newDict)) {\n                logger.info(\"dictionary content \" + newDict + \", is contained by  dictionary at \" + largestDictInfo.getResourcePath());\n                return largestDictInfo;\n            } else if (newDict.contains(largestDictObject)) {\n                logger.info(\"dictionary content \" + newDict + \" is by far the largest, save it\");\n                return saveNewDict(newDictInfo);\n            } else {\n                logger.info(\"merge dict and save...\");\n                return mergeDictionary(Lists.newArrayList(newDictInfo, largestDictInfo));\n            }\n        } else {\n            logger.info(\"first dict of this column, save it directly\");\n            return saveNewDict(newDictInfo);\n        }\n    }\n","new_comment_raw":"@return may return another dict that is a super set of the input","old_comment_raw":"@return may return another dict that is a super set of the input","label":0,"pre_label":1,"AST_level":14,"line_counts":35,"new_code_token_num":255},{"new_code_raw":"public static DateTimeZone getInstance(String id) throws IllegalArgumentException { if (id == null) { return getDefault(); } if (id.equals(\"UTC\")) { return DateTimeZone.UTC; } DateTimeZone zone = cProvider.getZone(id); if (zone != null) { return zone; } if (id.startsWith(\"+\") || id.startsWith(\"-\")) { int offset = -(int) offsetFormatter().parseMillis(id); if (offset == 0L) { return DateTimeZone.UTC; } else { id = offsetFormatter().print(0, UTC, offset); return fixedOffsetZone(id, offset); } } throw new IllegalArgumentException(\"The datetime zone id is not recognised: \" + id); }","old_code_raw":"    public static DateTimeZone getInstance(String id) throws IllegalArgumentException {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int offset = -(int) offsetFormatter().parseMillis(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                id = offsetFormatter().print(0, UTC, offset);\n                return new FixedDateTimeZone(id, null, offset, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id is not recognised: \" + id);\n    }\n","new_comment_raw":"@return the DateTimeZone object for the ID","old_comment_raw":"@return the DateTimeZone object for the ID","label":0,"pre_label":1,"AST_level":11,"line_counts":23,"new_code_token_num":147},{"new_code_raw":"public static List<Accept> parse(final HttpServletRequest r) throws IllegalArgumentException { return parse(r.getHeader(STR)); }","old_code_raw":"public static ImmutableList<Accept> parse(final HttpServletRequest r) throws IllegalArgumentException {\n    return parse(Strings.nullToEmpty(r.getHeader(STR)));\n}","new_comment_raw":"@return An immutable list of {@link Accept} entities sorted by RFC priority.","old_comment_raw":"@return A group of {@link Accept} entities.","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":24},{"new_code_raw":"public int transformToActualPosition(int position) { if(getAdapter() == null || getAdapter().getItemCount() < 0) { return 0; } return position % getActualItemCountFromAdapter(); }","old_code_raw":"    public int transformToActualPosition(int position) {\n        return position % getActualItemCountFromAdapter();\n    }\n","new_comment_raw":"@return actual position","old_comment_raw":"@return actual position","label":0,"pre_label":1,"AST_level":7,"line_counts":7,"new_code_token_num":37},{"new_code_raw":"private static ObjectName asObjectName(Object componentKey) throws MalformedObjectNameException { if (componentKey == null) { throw new NullPointerException(STR); } if (componentKey instanceof ObjectName) { return (ObjectName) componentKey; } if (componentKey instanceof Class) { Class clazz = (Class) componentKey; return new ObjectName(STR + clazz.getName()); } else { String text = componentKey.toString(); if (text.indexOf(STR) == -NUM) { text = STR + text; } return new ObjectName(text); } }","old_code_raw":"public static ObjectName asObjectName(Object key) throws MalformedObjectNameException {\n    if (key == null) {\n        throw new NullPointerException(STR);\n    }\n    if (key instanceof ObjectName) {\n        return (ObjectName) key;\n    }\n    if (key instanceof Class) {\n        Class clazz = (Class) key;\n        return new ObjectName(STR + clazz.getName());\n    } else {\n        String text = key.toString();\n        if (text.indexOf(STR) == -NUM) {\n            text = STR + text;\n        }\n        return new ObjectName(text);\n    }\n}","new_comment_raw":"@return an ObjectName based on the given componentKey","old_comment_raw":"@return an ObjectName based on the given key","label":1,"pre_label":0,"AST_level":10,"line_counts":18,"new_code_token_num":101},{"new_code_raw":"public double valueSum() { \/\/ We want the exp(log-sum-exp), for stability \/\/ This rearranges to exp(a)*(sum-exp) double max = 0.0; for (int[] assignment : this) { double v = getAssignmentLogValue(assignment); if (v > max) { max = v; } } double sumExp = 0.0; for (int[] assignment : this) { sumExp += Math.exp(getAssignmentLogValue(assignment) - max); } return sumExp * Math.exp(max); }","old_code_raw":"    public double valueSum() {\n\n        \/\/ We want the exp(log-sum-exp), for stability\n        \/\/ This rearranges to exp(a)*(sum-exp)\n\n        double max = 0.0;\n        for (int[] assignment : this) {\n            double v = getAssignmentLogValue(assignment);\n            if (v > max) {\n                max = v;\n            }\n        }\n\n        double sumExp = 0.0;\n        for (int[] assignment : this) {\n            sumExp += FastMath.exp(getAssignmentLogValue(assignment) - max);\n        }\n\n        return sumExp * FastMath.exp(max);\n    }\n","new_comment_raw":"@return the sum of all values for all assignments to the TableFactor","old_comment_raw":"@return the sum of all values for all assignments to the TableFactor","label":0,"pre_label":1,"AST_level":10,"line_counts":21,"new_code_token_num":109},{"new_code_raw":"public static <T, N extends TreeNode<T>> String toString(final N inputNode, final Function<N, String> toString) { final StringBuilder builder = new StringBuilder(); depthFirst(inputNode, new TreeVisitor<N>() { final Set<Integer> depths = Sets.newHashSet(); @SuppressWarnings(STR) @Override public void onNode(final int depth, final N node) { if (!isRoot(node) && !isLeaf(node) && !isLastChild(node)) { this.depths.add(depth); } else { this.depths.remove(depth); } builder.append(indent(depth)); final String nodeString = toString.apply(node); builder.append(STR).append(nodeString).append(Strings2.NEW_LINE); } private String indent(final int depth) { final StringBuilder b = new StringBuilder(); for (int i = NUM; i < depth; i++) { if (this.depths.contains(Integer.valueOf(i))) { b.append(STR); } else { b.append(STR); } } return b.toString(); } }); return builder.toString(); }","old_code_raw":"public static <T, N extends TreeNode<T>> String toString(final N node) {\n    final Function<N, String> function = new Function<N, String>() {\n\n        @Override\n        public String apply(final N arg0) {\n            return arg0.toString();\n        }\n    };\n    return toString(node, function);\n}","new_comment_raw":"@return a string representation of the tree","old_comment_raw":"@return the node as a string","label":1,"pre_label":0,"AST_level":13,"line_counts":33,"new_code_token_num":224},{"new_code_raw":"public List<GraphQLObjectType> getImplementations(GraphQLInterfaceType type) { List<GraphQLObjectType> implementations = byInterface.get(type.getName()); return (implementations == null) ? Collections.emptyList() : Collections.unmodifiableList(sortGraphQLTypes(implementations)); }","old_code_raw":"    public List<GraphQLObjectType> getImplementations(GraphQLInterfaceType type) {\n        List<GraphQLObjectType> implementations = byInterface.get(type.getName());\n        return (implementations == null)\n                ? Collections.emptyList()\n                : Collections.unmodifiableList(implementations);\n    }\n","new_comment_raw":"@return list of types implementing provided interface","old_comment_raw":"@return list of types implementing provided interface","label":0,"pre_label":1,"AST_level":7,"line_counts":7,"new_code_token_num":42},{"new_code_raw":"public static DateTimeFormatter dateHourMinuteSecondFraction() { return Constants.dhmsf; }","old_code_raw":"    public static DateTimeFormatter dateHourMinuteSecondFraction() {\n        if (dhmsf == null) {\n            dhmsf = new DateTimeFormatterBuilder()\n                .append(date())\n                .append(literalTElement())\n                .append(hourMinuteSecondFraction())\n                .toFormatter();\n        }\n        return dhmsf;\n    }\n","new_comment_raw":"@return a formatter for yyyy-MM-dd'T'HH:mm:ss.SSS","old_comment_raw":"@return a formatter for yyyy-MM-dd'T'HH:mm:ss.SSS","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":12},{"new_code_raw":"protected Problem findProblem(int line) { List<Problem> problems = findProblems(line); for (Problem p : problems) { if (p.isError()) return p; } return problems.isEmpty() ? null : problems.get(0); }","old_code_raw":"  protected Problem findProblem(int line) {\n    int currentTab = getSketch().getCurrentCodeIndex();\n    return problems.stream()\n        .filter(p -> p.getTabIndex() == currentTab)\n        .filter(p -> {\n          int pStartLine = p.getLineNumber();\n          int pEndOffset = p.getStopOffset();\n          int pEndLine = textarea.getLineOfOffset(pEndOffset);\n          return line >= pStartLine && line <= pEndLine;\n        })\n        .findFirst()\n        .orElse(null);\n  }\n","new_comment_raw":"@return the Problem for the most relevant error or warning on 'line', defaults to the first error, if there are no errors first warning.","old_comment_raw":"@return the Problem for the most relevant error or warning on 'line', defaulting to the first.","label":1,"pre_label":0,"AST_level":7,"line_counts":8,"new_code_token_num":50},{"new_code_raw":"public static Treepath getNextSibling(Treepath treepath) { if (treepath.getHeight() < NUM) { throw new IllegalArgumentException(STR); } final Tree treeToMove = treepath.getBottom(); final Tree parent = treepath.getTreeAtHeight(NUM); for (int i = NUM; i < parent.getChildCount() - NUM; i++) { final Tree child = parent.getChildAt(i); if (child == treeToMove) { return Treepath.create(treepath.getParent(), parent.getChildAt(i + NUM)); } } throw new IllegalArgumentException(STR); }","old_code_raw":"public static Treepath getNextSibling(Treepath treepath) {\n    throw new UnsupportedOperationException(STR);\n}","new_comment_raw":"@return non-null object.","old_comment_raw":"@return non-null if sibling was found, null otherwise.","label":1,"pre_label":0,"AST_level":11,"line_counts":14,"new_code_token_num":105},{"new_code_raw":"public String escapeReservedWord(String name) { if(this.reservedWords().contains(name)) { name = \"_\" + name; } return name; }","old_code_raw":"    public String escapeReservedWord(String name) {           \n        if(this.reservedWordsMappings().containsKey(name)) {\n            return this.reservedWordsMappings().get(name);\n        }\n        return \"_\" + name;\n    }\n","new_comment_raw":"@return the escaped term","old_comment_raw":"@return the escaped term","label":0,"pre_label":1,"AST_level":8,"line_counts":7,"new_code_token_num":32},{"new_code_raw":"public static EDecimal<Double> random(){ if (random == null){ random = ODecimal.create(Double.class, MathOps.RANDOM); } return random; }","old_code_raw":"    public static ENumber<Double> random(){\n        if (random == null){\n            random = ONumber.create(Double.class, MathOps.RANDOM);\n        }\n        return random;\n    }\n","new_comment_raw":"@return random()","old_comment_raw":"@return random()","label":0,"pre_label":1,"AST_level":9,"line_counts":7,"new_code_token_num":30},{"new_code_raw":"public int toStatusCode(Throwable thrown) { if (thrown == null) { return SUCCESS; } else if (thrown instanceof InvalidCookieDomainException) { return INVALID_COOKIE_DOMAIN; } else if (thrown instanceof UnableToSetCookieException) { return UNABLE_TO_SET_COOKIE; } else if (thrown instanceof NoSuchWindowException) { return NO_SUCH_WINDOW; } else if (thrown instanceof InvalidSelectorException) { return INVALID_SELECTOR_ERROR; } else if (thrown instanceof NoSuchElementException) { return NO_SUCH_ELEMENT; } else if (thrown instanceof NoSuchFrameException) { return NO_SUCH_FRAME; } else if (thrown instanceof StaleElementReferenceException) { return STALE_ELEMENT_REFERENCE; } else if (thrown instanceof ElementNotVisibleException) { return ELEMENT_NOT_VISIBLE; } else if (thrown instanceof InvalidElementStateException) { return INVALID_ELEMENT_STATE; } else if (thrown instanceof XPathLookupException) { return XPATH_LOOKUP_ERROR; } else if (thrown instanceof TimeoutException) { return ASYNC_SCRIPT_TIMEOUT; } else if (thrown instanceof InvalidCoordinatesException) { return INVALID_ELEMENT_COORDINATES; } else if (thrown instanceof ImeNotAvailableException) { return IME_NOT_AVAILABLE; } else if (thrown instanceof ImeActivationFailedException) { return IME_ENGINE_ACTIVATION_FAILED; } else if (thrown instanceof NoAlertPresentException) { return NO_ALERT_PRESENT; } else { return UNHANDLED_ERROR; } }","old_code_raw":"  public int toStatusCode(Throwable thrown) {\n    if (thrown == null) {\n      return SUCCESS; \n    } else if (thrown instanceof InvalidCookieDomainException) {\n      return INVALID_COOKIE_DOMAIN;\n    } else if (thrown instanceof UnableToSetCookieException) {\n      return UNABLE_TO_SET_COOKIE;\n    } else if (thrown instanceof NoSuchWindowException) {\n      return NO_SUCH_WINDOW;\n    } else if (thrown instanceof InvalidSelectorException) {\n      return INVALID_SELECTOR_ERROR;\n    } else if (thrown instanceof NoSuchElementException) {\n      return NO_SUCH_ELEMENT;\n    } else if (thrown instanceof NoSuchFrameException) {\n      return NO_SUCH_FRAME;\n    } else if (thrown instanceof StaleElementReferenceException) {\n      return STALE_ELEMENT_REFERENCE;\n    } else if (thrown instanceof ElementNotVisibleException) {\n      return ELEMENT_NOT_VISIBLE;\n    } else if (thrown instanceof InvalidElementStateException) {\n      return INVALID_ELEMENT_STATE;\n    } else if (thrown instanceof XPathLookupException) {\n      return XPATH_LOOKUP_ERROR;\n    } else if (thrown instanceof TimeoutException) {\n      return ASYNC_SCRIPT_TIMEOUT;\n    } else if (thrown instanceof InvalidCoordinatesException) {\n      return INVALID_ELEMENT_COORDINATES;\n    } else if (thrown instanceof ImeNotAvailableException) {\n      return IME_NOT_AVAILABLE;\n    } else if (thrown instanceof ImeActivationFailedException) {\n      return IME_ENGINE_ACTIVATION_FAILED;\n    } else {\n      return UNHANDLED_ERROR;\n    }\n  }\n","new_comment_raw":"@return The corresponding status code for the given thrown error.","old_comment_raw":"@return The corresponding status code for the given thrown error.","label":0,"pre_label":1,"AST_level":21,"line_counts":38,"new_code_token_num":205},{"new_code_raw":"public T sum() { return sum; }","old_code_raw":"public long sum() {\n    return sum;\n}","new_comment_raw":"@return total of values seen","old_comment_raw":"@return long total of values seen","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":10},{"new_code_raw":"public Pathway createNewDrawing() { return new Pathway(sc, SWT.NO_BACKGROUND); }","old_code_raw":"public GmmlDrawing createNewDrawing() {\n    return new GmmlDrawing(sc, SWT.NO_BACKGROUND);\n}","new_comment_raw":"@return the empty {@link Pathway}","old_comment_raw":"@return the empty {@link GmmlDrawing}","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":17},{"new_code_raw":"public ApiResponse<ApiResponse> uploadFileWithHttpInfo(Long petId, String additionalMetadata, File file) throws ApiException { Call call = uploadFileCall(petId, additionalMetadata, file, null, null); Type localVarReturnType = new TypeToken<ApiResponse>(){}.getType(); return apiClient.execute(call, localVarReturnType); }","old_code_raw":"  public ApiResponse<Void> uploadFileWithHttpInfo(Long petId, String additionalMetadata, File file) throws ApiException {\n    Call call = uploadFileCall(petId, additionalMetadata, file, null, null);\n    return apiClient.execute(call);\n  }\n","new_comment_raw":"@return ApiResponse","old_comment_raw":"@return ApiResponse","label":0,"pre_label":1,"AST_level":8,"line_counts":6,"new_code_token_num":55},{"new_code_raw":"protected Object convertTimeToMicrosPastMidnight(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0L; \/\/ return epoch } try { return MicroTime.toMicroOfDay(data, adjuster); } catch (IllegalArgumentException e) { return handleUnknownData(column, fieldDefn, data); } }","old_code_raw":"    protected Object convertTimeToMicrosPastMidnight(Column column, Field fieldDefn, Object data) {\n        if (data == null) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return 0L; \/\/ return epoch\n        }\n        try {\n            return MicroTime.toMicroOfDay(data);\n        } catch (IllegalArgumentException e) {\n            return handleUnknownData(column, fieldDefn, data);\n        }\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","label":0,"pre_label":1,"AST_level":8,"line_counts":15,"new_code_token_num":84},{"new_code_raw":"public Node getFirstNode() { return m_node1; }","old_code_raw":"public NodeItem getFirstNode() {\n    return m_node1;\n}","new_comment_raw":"@return the first (source) VisualItem","old_comment_raw":"@return the first (source) GraphItem","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":10},{"new_code_raw":"public static YourKitContext startProfile(boolean enableStackTelemetry, boolean enableCPUProfilling, boolean enableAllocationRecording) { Controller controller; try { controller = new Controller(); } catch (Exception e) { LOG.info(STR, e); return null; } try { if (enableStackTelemetry) { controller.enableStackTelemetry(); LOG.info(STR); } } catch (Exception e) { LOG.info(STR, e); } try { if (enableCPUProfilling) { controller.startCPUProfiling(ProfilingModes.CPU_SAMPLING, Controller.DEFAULT_FILTERS, Controller.DEFAULT_WALLTIME_SPEC); LOG.info(STR); } } catch (Exception e) { LOG.info(STR, e); } try { if (enableAllocationRecording) { controller.startAllocationRecording(true, ALLOCATION_RECORDING_INTERVAL, false, -NUM, true, false); LOG.info(STR); } } catch (Exception e) { LOG.info(STR, e); } return new YourKitContext(controller); }","old_code_raw":"public static YourKitContext startProfile(GiraphConfiguration conf) {\n    Controller controller = null;\n    try {\n        controller = new Controller();\n        controller.enableStackTelemetry();\n        controller.startCPUProfiling(ProfilingModes.CPU_SAMPLING, Controller.DEFAULT_FILTERS);\n        LOG.debug(STR);\n    } catch (Exception e) {\n        LOG.debug(STR, e);\n    }\n    return new YourKitContext(controller);\n}","new_comment_raw":"@return profiler context, or null if controller cannot be created","old_comment_raw":"@return profiler context","label":1,"pre_label":0,"AST_level":8,"line_counts":34,"new_code_token_num":178},{"new_code_raw":"public ConcurrentSecondLevelCacheStatisticsImpl getSecondLevelCacheStatistics(String regionName) { ConcurrentSecondLevelCacheStatisticsImpl stat = secondLevelCacheStatistics.get( regionName ); if ( stat == null ) { if ( sessionFactory == null ) { return null; } final EntityRegionAccessStrategy entityRegionAccess = sessionFactory.getCache().getEntityRegionAccess( regionName ); final CollectionRegionAccessStrategy collectionRegionAccess = sessionFactory.getCache().getCollectionRegionAccess( regionName ); if ( entityRegionAccess == null && collectionRegionAccess == null ) { final QueryCache queryCache = sessionFactory.getCache().getQueryCache( regionName ); if ( queryCache == null ) { return null; } final Region region = queryCache.getRegion(); if ( region == null ) { throw new IllegalArgumentException( \"Could not resolve region name [\" + regionName + \"]\" ); } stat = new ConcurrentSecondLevelCacheStatisticsImpl( region, null, null ); } else { final Region region = entityRegionAccess != null ? entityRegionAccess.getRegion() : collectionRegionAccess.getRegion(); stat = new ConcurrentSecondLevelCacheStatisticsImpl( region, entityRegionAccess, collectionRegionAccess ); } ConcurrentSecondLevelCacheStatisticsImpl previous; if ( ( previous = secondLevelCacheStatistics.putIfAbsent( regionName, stat ) ) != null ) { stat = previous; } } return stat; }","old_code_raw":"\tpublic ConcurrentSecondLevelCacheStatisticsImpl getSecondLevelCacheStatistics(String regionName) {\n\t\tConcurrentSecondLevelCacheStatisticsImpl stat = secondLevelCacheStatistics.get( regionName );\n\t\tif ( stat == null ) {\n\t\t\tif ( sessionFactory == null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tfinal EntityRegionAccessStrategy entityRegionAccess = sessionFactory.getCache().getEntityRegionAccess( regionName );\n\t\t\tfinal CollectionRegionAccessStrategy collectionRegionAccess = sessionFactory.getCache().getCollectionRegionAccess( regionName );\n\n\t\t\tif ( entityRegionAccess == null && collectionRegionAccess == null ) {\n\t\t\t\tfinal Region region = sessionFactory.getCache().getQueryCache( regionName ).getRegion();\n\t\t\t\tif ( region == null ) {\n\t\t\t\t\tthrow new IllegalArgumentException( \"Could not resolve region name [\" + regionName + \"]\" );\n\t\t\t\t}\n\t\t\t\tstat = new ConcurrentSecondLevelCacheStatisticsImpl( region, null, null );\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\tfinal Region region = entityRegionAccess != null\n\t\t\t\t\t\t? entityRegionAccess.getRegion()\n\t\t\t\t\t\t: collectionRegionAccess.getRegion();\n\n\t\t\t\tstat = new ConcurrentSecondLevelCacheStatisticsImpl(\n\t\t\t\t\t\tregion,\n\t\t\t\t\t\tentityRegionAccess,\n\t\t\t\t\t\tcollectionRegionAccess\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tConcurrentSecondLevelCacheStatisticsImpl previous;\n\t\t\tif ( ( previous = secondLevelCacheStatistics.putIfAbsent( regionName, stat ) ) != null ) {\n\t\t\t\tstat = previous;\n\t\t\t}\n\t\t}\n\n\t\treturn stat;\n\t}\n","new_comment_raw":"@return SecondLevelCacheStatistics or null if the second level cache is not enabled","old_comment_raw":"@return SecondLevelCacheStatistics","label":1,"pre_label":0,"AST_level":13,"line_counts":43,"new_code_token_num":194},{"new_code_raw":"public long getLastAccessedTime() { return (lastAccessedTime == NUM) ? getCreationTime() : lastAccessedTime; }","old_code_raw":"public long getLastAccessedTime() {\n    if (lastAccessedTime == NUM)\n        return nativegetcreationtime();\n    else\n        return lastAccessedTime;\n}","new_comment_raw":"@return the session's last access time in milliseconds since the epoch","old_comment_raw":"@return the session's accessing time in milli seconds since 12.00 PM, January 1st, 1970","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":19},{"new_code_raw":"public Pet getPetById(Long petId) throws ApiException { Object localVarPostBody = null; \/\/ verify the required parameter 'petId' is set if (petId == null) { throw new ApiException(400, \"Missing the required parameter 'petId' when calling getPetById\"); } \/\/ create path and map variables String localVarPath = \"\/pet\/{petId}\".replaceAll(\"\\\\{format\\\\}\",\"json\") .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString())); \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, String> localVarCookieParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { \"application\/xml\", \"application\/json\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { \"api_key\" }; GenericType<Pet> localVarReturnType = new GenericType<Pet>() {}; return apiClient.invokeAPI(localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public Pet getPetById(Long petId) throws ApiException {\n    Object localVarPostBody = null;\n    \n    \/\/ verify the required parameter 'petId' is set\n    if (petId == null) {\n      throw new ApiException(400, \"Missing the required parameter 'petId' when calling getPetById\");\n    }\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/pet\/{petId}\".replaceAll(\"\\\\{format\\\\}\",\"json\")\n      .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString()));\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application\/xml\", \"application\/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] { \"api_key\" };\n\n    GenericType<Pet> localVarReturnType = new GenericType<Pet>() {};\n    return apiClient.invokeAPI(localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@return a  Pet","old_comment_raw":"@return a Pet","label":0,"pre_label":1,"AST_level":9,"line_counts":38,"new_code_token_num":265},{"new_code_raw":"public static Schema unaliasSchema(OpenAPI openAPI, Schema schema) { Map<String, Schema> allSchemas = getSchemas(openAPI); if (allSchemas == null || allSchemas.isEmpty()) { \/\/ skip the warning as the spec can have no model defined \/\/LOGGER.warn(\"allSchemas cannot be null\/empty in unaliasSchema. Returned 'schema'\"); return schema; } if (schema != null && StringUtils.isNotEmpty(schema.get$ref())) { Schema ref = allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())); if (ref == null) { LOGGER.warn(\"{} is not defined\", schema.get$ref()); return schema; } else if (ref.getEnum() != null && !ref.getEnum().isEmpty()) { \/\/ top-level enum class return schema; } else if (isArraySchema(ref)) { if (generateAliasAsModel) { return schema; \/\/ generate a model extending array } else { return unaliasSchema(openAPI, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()))); } } else if (isComposedSchema(ref)) { return schema; } else if (isMapSchema(ref)) { if (ref.getProperties() != null && !ref.getProperties().isEmpty()) \/\/ has at least one property return schema; \/\/ treat it as model else { if (generateAliasAsModel) { return schema; \/\/ generate a model extending map } else { \/\/ treat it as a typical map return unaliasSchema(openAPI, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()))); } } } else if (isObjectSchema(ref)) { \/\/ model if (ref.getProperties() != null && !ref.getProperties().isEmpty()) { \/\/ has at least one property return schema; } else { \/\/ free form object (type: object) return unaliasSchema(openAPI, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()))); } } else { return unaliasSchema(openAPI, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()))); } } return schema; }","old_code_raw":"    public static Schema unaliasSchema(Map<String, Schema> allSchemas, Schema schema) {\n        if (allSchemas == null || allSchemas.isEmpty()) {\n            \/\/ skip the warning as the spec can have no model defined\n            \/\/LOGGER.warn(\"allSchemas cannot be null\/empty in unaliasSchema. Returned 'schema'\");\n            return schema;\n        }\n\n        if (schema != null && StringUtils.isNotEmpty(schema.get$ref())) {\n            Schema ref = allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()));\n            if (ref == null) {\n                LOGGER.warn(\"{} is not defined\", schema.get$ref());\n                return schema;\n            } else if (ref.getEnum() != null && !ref.getEnum().isEmpty()) {\n                \/\/ top-level enum class\n                return schema;\n            } else if (isArraySchema(ref)) {\n                if (generateAliasAsModel) {\n                    return schema; \/\/ generate a model extending array\n                } else {\n                    return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));\n                }\n            } else if (isComposedSchema(ref)) {\n                return schema;\n            } else if (isMapSchema(ref)) {\n                if (ref.getProperties() != null && !ref.getProperties().isEmpty()) \/\/ has at least one property\n                    return schema; \/\/ treat it as model\n                else {\n                    if (generateAliasAsModel) {\n                        return schema; \/\/ generate a model extending map\n                    } else {\n                        \/\/ treat it as a typical map\n                        return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));\n                    }\n                }\n            } else if (isObjectSchema(ref)) { \/\/ model\n                if (ref.getProperties() != null && !ref.getProperties().isEmpty()) { \/\/ has at least one property\n                    return schema;\n                } else { \/\/ free form object (type: object)\n                    return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));\n                }\n            } else {\n                return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));\n            }\n        }\n        return schema;\n    }\n","new_comment_raw":"@return actual schema","old_comment_raw":"@return actual schema","label":0,"pre_label":1,"AST_level":19,"line_counts":48,"new_code_token_num":435},{"new_code_raw":"public Object h2TCPServer() throws SQLException { String port = \"1\" + env.getProperty(\"server.port\"); log.debug(\"H2 database is available on port {}\", port); return H2ConfigurationHelper.createServer(port); }","old_code_raw":"    public Object h2TCPServer() throws SQLException {\n        log.debug(\"Starting H2 database\");\n        return H2ConfigurationHelper.createServer();\n    }\n","new_comment_raw":"@return the H2 database TCP server","old_comment_raw":"@return the H2 database TCP server","label":0,"pre_label":1,"AST_level":7,"line_counts":6,"new_code_token_num":48},{"new_code_raw":"private ZapMenuItem getMenuFind() { if (menuFind == null) { menuFind = new ZapMenuItem(\"menu.edit.find\", KeyStroke.getKeyStroke(KeyEvent.VK_F, KeyEvent.CTRL_MASK, false)); menuFind.addActionListener(new java.awt.event.ActionListener() { @Override public void actionPerformed(java.awt.event.ActionEvent e) { showFindDialog(getView().getMainFrame(), null); } }); } return menuFind; }","old_code_raw":"    private JMenuItem getMenuFind() {\n        if (menuFind == null) {\n            menuFind = new JMenuItem();\n            menuFind.setText(Constant.messages.getString(\"menu.edit.find\"));\t\/\/ ZAP: i18n\n            menuFind.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_F, java.awt.Event.CTRL_MASK, false));\n\n            menuFind.addActionListener(new java.awt.event.ActionListener() {\n                @Override\n                public void actionPerformed(java.awt.event.ActionEvent e) {\n                    showFindDialog(getView().getMainFrame(), null);\n                }\n            });\n        }\n        return menuFind;\n    }\n","new_comment_raw":"@return javax.swing.JMenuItem","old_comment_raw":"@return javax.swing.JMenuItem","label":0,"pre_label":1,"AST_level":13,"line_counts":15,"new_code_token_num":80},{"new_code_raw":"public Role[] getRoles() { Item[] items = super.getItems(); Role[] roles = new Role[items.length]; for (int i = NUM; i < roles.length; i++) { roles[i] = (Role) items[i]; } return roles; }","old_code_raw":"public Iterator getRoles() {\n    return super.getItems();\n}","new_comment_raw":"@return an array of roles.","old_comment_raw":"@return an <code>Iterator<\/code>","label":1,"pre_label":0,"AST_level":10,"line_counts":8,"new_code_token_num":60},{"new_code_raw":"private boolean testContentType(final IFile file, String contentTypeId, boolean isKindOfUsed) { final String expectedValue = contentTypeId.trim(); IContentType actualContentType = null; try { IContentDescription contentDescription = file.getContentDescription(); if (contentDescription != null) { actualContentType = contentDescription.getContentType(); } } catch (CoreException e) { Policy.log(IStatus.ERROR, STR, e); } if (actualContentType != null) { if (isKindOfUsed) { return actualContentType.isKindOf(Platform.getContentTypeManager().getContentType(expectedValue)); } return expectedValue.equals(actualContentType.getId()); } return false; }","old_code_raw":"private boolean testContentType(final IFile file, String contentTypeId) {\n    final String expectedValue = contentTypeId.trim();\n    String actualValue = null;\n    try {\n        IContentDescription contentDescription = file.getContentDescription();\n        if (contentDescription != null) {\n            IContentType contentType = contentDescription.getContentType();\n            actualValue = contentType.getId();\n        }\n    } catch (CoreException e) {\n        Policy.log(IStatus.ERROR, STR, e);\n    }\n    return expectedValue.equals(actualValue);\n}","new_comment_raw":"@return <code>true<\/code>, if the best matching content type for <code>file<\/code> <ul> <li>has an identifier that matches <code>contentTypeId<\/code> and <code>isKindOfUsed<\/code> is <code>false<\/code>, or<\/li> <li>is a kind of <code>contentTypeId<\/code> and <code>isKindOfUsed<\/code> is <code>true<\/code>.<\/li> <\/ul> Otherwise it returns <code>false<\/code>.","old_comment_raw":"@return <code>true<\/code> iff the best matching content type has an identifier that matches <code>contentTypeId<\/code>; <code>false<\/code> otherwise.","label":1,"pre_label":0,"AST_level":11,"line_counts":19,"new_code_token_num":111},{"new_code_raw":"private EntityMetamodel getDeclarerEntityMetamodel(AbstractIdentifiableType<?> ownerType) { final Type.PersistenceType persistenceType = ownerType.getPersistenceType(); if ( persistenceType == Type.PersistenceType.ENTITY ) { return context.getSessionFactory() .getMetamodel() .entityPersister( ownerType.getTypeName() ) .getEntityMetamodel(); } else if ( persistenceType == Type.PersistenceType.MAPPED_SUPERCLASS ) { PersistentClass persistentClass = context.getPersistentClassHostingProperties( (MappedSuperclassTypeImpl<?>) ownerType ); return context.getSessionFactory() .getMetamodel() .entityPersister( persistentClass.getClassName() ) .getEntityMetamodel(); } else { throw new AssertionFailure( \"Cannot get the metamodel for PersistenceType: \" + persistenceType ); } }","old_code_raw":"\tprivate EntityMetamodel getDeclarerEntityMetamodel(AbstractIdentifiableType<?> ownerType) {\n\t\tfinal Type.PersistenceType persistenceType = ownerType.getPersistenceType();\n\t\tif ( persistenceType == Type.PersistenceType.ENTITY ) {\n\t\t\treturn context.getSessionFactory()\n\t\t\t\t\t.getEntityPersister( ownerType.getTypeName() )\n\t\t\t\t\t.getEntityMetamodel();\n\t\t}\n\t\telse if ( persistenceType == Type.PersistenceType.MAPPED_SUPERCLASS ) {\n\t\t\tPersistentClass persistentClass =\n\t\t\t\t\tcontext.getPersistentClassHostingProperties( (MappedSuperclassTypeImpl<?>) ownerType );\n\t\t\treturn context.getSessionFactory()\n\t\t\t\t\t.getEntityPersister( persistentClass.getClassName() )\n\t\t\t\t\t.getEntityMetamodel();\n\t\t}\n\t\telse {\n\t\t\tthrow new AssertionFailure( \"Cannot get the metamodel for PersistenceType: \" + persistenceType );\n\t\t}\n\t}\n","new_comment_raw":"@return The built attribute descriptor","old_comment_raw":"@return The built attribute descriptor","label":0,"pre_label":1,"AST_level":11,"line_counts":21,"new_code_token_num":108},{"new_code_raw":"public BooleanExpression startsWith(Expression<String> str) { return BooleanOperation.create(Ops.STARTS_WITH, mixin, str); }","old_code_raw":"    public BooleanExpression startsWith(Expression<String> str) {\n        return BooleanOperation.create(Ops.STARTS_WITH, this, str);\n    }\n","new_comment_raw":"@return this.startsWith(str)","old_comment_raw":"@return this.startsWith(str)","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":22},{"new_code_raw":"public PeriodFormatterBuilder appendSeparator(String text, String finalText) { return appendSeparator(text, finalText, null, true, true); }","old_code_raw":"    public PeriodFormatterBuilder appendSeparator(String text, String finalText) {\n        return appendSeparator(text, finalText, true, true);\n    }\n","new_comment_raw":"@return this PeriodFormatterBuilder","old_comment_raw":"@return this PeriodFormatterBuilder","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":26},{"new_code_raw":"private File[] getProjectFiles(File directory) { return directory.listFiles(new FileFilter() { public boolean accept(File file) { return (file.isFile() && file.getName().endsWith(STR)); } }); }","old_code_raw":"private File[] getProjectFiles(File directory) {\n    File[] files = directory.listFiles(new FileFilter() {\n\n        public boolean accept(File file) {\n            return (file.isFile() && file.getName().endsWith(STR));\n        }\n    });\n    switch(explorerTableSortColumn) {\n        case NUM:\n        case NUM:\n        case NUM:\n        default:\n    }\n    selectedFile = -NUM;\n    if (getProject() != null)\n        for (int n = NUM; n < files.length; n++) if (getProject().getFile().equals(files[n]))\n            selectedFile = n;\n    return files;\n}","new_comment_raw":"@return project files in that directory.","old_comment_raw":"@return project files in that directory, sorted alphabetically.","label":1,"pre_label":0,"AST_level":11,"line_counts":8,"new_code_token_num":50},{"new_code_raw":"public boolean isValid(Litmus litmus) { return super.isValid(litmus) && litmus.check(Util.isDistinct(getRowType().getFieldNames()), \"distinct field names: {}\", getRowType()); }","old_code_raw":"  public boolean isValid(Litmus litmus) {\n    return super.isValid(litmus)\n        && litmus.check(Util.isDistinct(getRowType().getFieldNames()), getRowType());\n  }\n","new_comment_raw":"@return Row type of the aggregate","old_comment_raw":"@return Row type of the aggregate","label":0,"pre_label":1,"AST_level":8,"line_counts":6,"new_code_token_num":45},{"new_code_raw":"public String getHelp() { return \"Generates a Go server library using OpenAPI-Generator. By default, \" + \"it will also generate service classes -- which you can disable with the `-Dnoservice` environment variable.\"; }","old_code_raw":"    public String getHelp() {\n        return \"Generates a Go server library using the swagger-tools project.  By default, \" +\n                \"it will also generate service classes--which you can disable with the `-Dnoservice` environment variable.\";\n    }\n","new_comment_raw":"@return A string value for the help message","old_comment_raw":"@return A string value for the help message","label":0,"pre_label":1,"AST_level":5,"line_counts":5,"new_code_token_num":44},{"new_code_raw":"public PortletContainer createContainer(String containerName, RequiredContainerServices requiredServices) throws PortletContainerException { return createContainer(containerName, requiredServices, new DefaultOptionalContainerServices()); }","old_code_raw":"public PortletContainer createContainer(String containerName, PortletContainerServices services) throws PortletContainerException {\n    return createContainer(containerName, services, new DefaultOptionalServices());\n}","new_comment_raw":"@return newly created PortletContainer instance.","old_comment_raw":"@return newly created PortletContainer","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":27},{"new_code_raw":"public ByteBuf getContent() { return this.facade.getContent(); }","old_code_raw":"public Buffer getContent() {\n    return this.facade.getContent();\n}","new_comment_raw":"@return a ByteBuf holding the bytes contained in this message.","old_comment_raw":"@return a Buffer holding the bytes contained in this message.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":14},{"new_code_raw":"public Field getSingleField() { return singleField; }","old_code_raw":"    public Field getSingleField() {\n        return fields.get(0);\n    }\n","new_comment_raw":"@return the fist of the merged Fields","old_comment_raw":"@return the fist of the merged Fields","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"public ScheduledReporter build() { ScheduledReporter reporter; switch(influxdbVersion) { case V08: Influxdb influxdb = buildInfluxdb(); reporter = (executor == null) ? new ReporterV08(registry, influxdb, clock, prefix, rateUnit, durationUnit, filter, skipIdleMetrics) : new ReporterV08(registry, influxdb, clock, prefix, rateUnit, durationUnit, filter, skipIdleMetrics, executor); break; default: Sender s = buildSender(); reporter = executor == null ? new MeasurementReporter(s, registry, filter, rateUnit, durationUnit, clock, tags, transformer) : new MeasurementReporter(s, registry, filter, rateUnit, durationUnit, clock, tags, transformer, executor); } return reporter; }","old_code_raw":"public ScheduledReporter build(Influxdb influxdb) {\n    return executor == null ? new ReporterV08(registry, influxdb, clock, prefix, rateUnit, durationUnit, filter, skipIdleMetrics) : new ReporterV08(registry, influxdb, clock, prefix, rateUnit, durationUnit, filter, skipIdleMetrics, executor);\n}","new_comment_raw":"@return a {@link ScheduledReporter}","old_comment_raw":"@return a {@link InfluxdbReporter}","label":1,"pre_label":0,"AST_level":9,"line_counts":13,"new_code_token_num":132},{"new_code_raw":"static List<String> parseCategories(String categoryStr) { List<String> outgoing = new ArrayList<String>(); if (categoryStr != null) { String[] listing = PApplet.trim(PApplet.split(categoryStr, ',')); for (String category : listing) { if (validCategories.contains(category)) { category = translateCategory(category); outgoing.add(category); } } } if (outgoing.size() == 0) { return defaultCategory(); } return outgoing; }","old_code_raw":"  static StringList parseCategories(StringDict properties) {\n    StringList outgoing = new StringList();\n\n    String categoryStr = properties.get(CATEGORIES_PROPERTY);\n    if (categoryStr == null) {\n      categoryStr = properties.get(\"category\");  \/\/ try the old way\n    }\n    if (categoryStr != null) {\n      String[] listing = PApplet.trim(PApplet.split(categoryStr, ','));\n      for (String category : listing) {\n        if (validCategories.contains(category)) {\n          category = translateCategory(category);\n          outgoing.append(category);\n        }\n      }\n    }\n    if (outgoing.size() == 0) {\n      return unknownCategory();\n    }\n    return outgoing;\n  }\n","new_comment_raw":"@return the list of categories that this contribution is part of (e.g. \"Typography \/ Geometry\"). \"Unknown\" if the category null.","old_comment_raw":"@return the list of categories that this contribution is part of (e.g. \"Typography \/ Geometry\"). \"Unknown\" if the category null.","label":0,"pre_label":1,"AST_level":12,"line_counts":18,"new_code_token_num":94},{"new_code_raw":"public static final Test suite() { return null; }","old_code_raw":"public static Test suite(String name) {\n    return new TestSuite(JtdsDataSourceUnitTest.Test_JtdsDataSource_getConnection.class, name);\n}","new_comment_raw":"@return The test suite (always <code>null<\/code>).","old_comment_raw":"@return The test suite.","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":12},{"new_code_raw":"public Charset getEncoding() { return _charset; }","old_code_raw":"public String getEncoding() {\n    return _charset;\n}","new_comment_raw":"@return The encoding used to send outgoing messages. Never null","old_comment_raw":"@return The encoding used to send outgoing messages, or null if not set.","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":10},{"new_code_raw":"public int getRowStatus(int aRow) throws IndexOutOfBoundsException { RowData row = this.getRow(aRow); if (row.isNew()) { return RowData.NEW; } else if (row.isModified()) { return RowData.MODIFIED; } else { return RowData.NOT_MODIFIED; } }","old_code_raw":"public Integer getRowStatus(int aRow) throws IndexOutOfBoundsException {\n    RowData row = this.getRow(aRow);\n    if (row.isOriginal()) {\n        return ROW_ORIGINAL;\n    } else if (row.isNew()) {\n        return ROW_NEW;\n    } else if (row.isModified()) {\n        return ROW_MODIFIED;\n    } else {\n        return ROW_ORIGINAL;\n    }\n}","new_comment_raw":"@return an int identifying the status","old_comment_raw":"@return an Integer identifying the status","label":1,"pre_label":0,"AST_level":7,"line_counts":10,"new_code_token_num":53},{"new_code_raw":"public BirthDate getDob() { return dob; }","old_code_raw":"public String getDob() {\n    return dob;\n}","new_comment_raw":"@return the date of birth different providers may use different formats","old_comment_raw":"@return String the date of birth different providers may use different formats","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":10},{"new_code_raw":"@Processor @OAuthProtected @OAuthInvalidateAccessTokenOn(exception = OAuthTokenExpiredException.class) @Paged public PagingDelegate<File> listFiles(@Optional @Default(STR) final int maxResults, @Optional final String query, final PagingConfiguration pagingConfiguration) throws IOException { return new TokenBasedPagingDelegate<File>() { @Override public List<File> doGetPage() throws IOException { FileList response = client.files().list().setMaxResults(maxResults).setPageToken(this.getPageToken()).setQ(query).execute(); this.setPageToken(response.getNextPageToken()); return File.valueOf(response.getItems(), File.class); } }; }","old_code_raw":"@Processor\n@OAuthProtected\n@OAuthInvalidateAccessTokenOn(exception = OAuthTokenExpiredException.class)\n@Inject\npublic List<File> listFiles(MuleMessage message, @Optional @Default(STR) int maxResults, @Optional String query, @Optional @Default(STR) String pageToken) throws IOException {\n    FileList response = this.client.files().list().setMaxResults(maxResults).setPageToken(pageToken).setQ(query).execute();\n    PaginationUtils.savePageToken(NEXT_PAGE_TOKEN, response.getNextPageToken(), message);\n    return File.valueOf(response.getItems(), File.class);\n}","new_comment_raw":"@return a paginated iterator with instances of {@link org.mule.module.google.drive.model.File}","old_comment_raw":"@return a list with instances of {@link org.mule.module.google.drive.model.File}","label":1,"pre_label":0,"AST_level":11,"line_counts":15,"new_code_token_num":114},{"new_code_raw":"public Boolean fakeOuterBooleanSerialize(Boolean body) throws ApiException { Object localVarPostBody = body; \/\/ create path and map variables String localVarPath = \"\/fake\/outer\/boolean\"; \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {}; return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public Boolean fakeOuterBooleanSerialize(Boolean body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/fake\/outer\/boolean\";\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@return Boolean","old_comment_raw":"@return Boolean","label":0,"pre_label":1,"AST_level":8,"line_counts":31,"new_code_token_num":166},{"new_code_raw":"public static double logSum(double[] logInputs, int fromIndex, int afterIndex, int stride) { if (logInputs.length == 0) throw new IllegalArgumentException(); if (fromIndex >= 0 && afterIndex < logInputs.length && fromIndex >= afterIndex) return Double.NEGATIVE_INFINITY; int maxIdx = fromIndex; double max = logInputs[fromIndex]; for (int i = fromIndex + stride; i < afterIndex; i += stride) { double d = logInputs[i]; if (d > max) { maxIdx = i; max = d; } } double intermediate = 0.0; double cutoff = max - SloppyMath.LOGTOLERANCE; \/\/ we avoid rearranging the array and so test indices each time! for (int i = fromIndex; i < afterIndex; i += stride) { double d = logInputs[i]; if (i != maxIdx && d > cutoff) { intermediate += Math.exp(d - max); } } return intermediate != 0 ? max + Math.log(1.0 + intermediate) : max; }","old_code_raw":"  public static double logSum(double[] logInputs, int fromIndex, int afterIndex, int stride) {\n    if (logInputs.length == 0)\n      throw new IllegalArgumentException();\n    if (fromIndex >= 0 && afterIndex < logInputs.length && fromIndex >= afterIndex)\n      return Double.NEGATIVE_INFINITY;\n    int maxIdx = fromIndex;\n    double max = logInputs[fromIndex];\n    for (int i = fromIndex + stride; i < afterIndex; i += stride) {\n      if (logInputs[i] > max) {\n        maxIdx = i;\n        max = logInputs[i];\n      }\n    }\n    boolean haveTerms = false;\n    double intermediate = 0.0;\n    double cutoff = max - SloppyMath.LOGTOLERANCE;\n    \/\/ we avoid rearranging the array and so test indices each time!\n    for (int i = fromIndex; i < afterIndex; i += stride) {\n      if (i != maxIdx && logInputs[i] > cutoff) {\n        haveTerms = true;\n        intermediate += Math.exp(logInputs[i] - max);\n      }\n    }\n    if (haveTerms) {\n      return max + Math.log(1.0 + intermediate);  \/\/ using Math.log1p(intermediate) may be more accurate, but is slower\n    } else {\n      return max;\n    }\n  }\n","new_comment_raw":"@return @literal log(x1 + ... + xn)","old_comment_raw":"@return @literal log(x1 + ... + xn)","label":0,"pre_label":1,"AST_level":11,"line_counts":26,"new_code_token_num":187},{"new_code_raw":"private long computePartitionSize(final int start) { logger.trace(\"compute partition size starting from {} on {} batches\", start, batches.size()); \/\/ current partition always starts from first batch final VectorAccessible first = getCurrent(); long length = 0; \/\/ count all rows that are in the same partition of start \/\/ keep increasing length until we find first row of next partition or we reach the very \/\/ last batch for (WindowDataBatch batch : batches) { final int recordCount = batch.getRecordCount(); \/\/ check first container from start row, and subsequent containers from first row for (int row = (batch == first) ? start : 0; row < recordCount; row++, length++) { if (!isSamePartition(start, first, row, batch)) { return length; } } } return length; }","old_code_raw":"  private int computePartitionSize(final int start) {\n    logger.trace(\"compute partition size starting from {} on {} batches\", start, batches.size());\n\n    \/\/ current partition always starts from first batch\n    final VectorAccessible first = getCurrent();\n\n    int length = 0;\n\n    \/\/ count all rows that are in the same partition of start\n    \/\/ keep increasing length until we find first row of next partition or we reach the very\n    \/\/ last batch\n    for (WindowDataBatch batch : batches) {\n      final int recordCount = batch.getRecordCount();\n\n      \/\/ check first container from start row, and subsequent containers from first row\n      for (int row = (batch == first) ? start : 0; row < recordCount; row++, length++) {\n        if (!isSamePartition(start, first, row, batch)) {\n          return length;\n        }\n      }\n    }\n\n    return length;\n  }\n","new_comment_raw":"@return number of rows that are part of the partition starting at row start of first batch","old_comment_raw":"@return number of rows that are part of the partition starting at row start of first batch","label":0,"pre_label":1,"AST_level":11,"line_counts":25,"new_code_token_num":170},{"new_code_raw":"public long getExtraLong(String key) throws JSONException { return mExtraData.getLong(key); }","old_code_raw":"public double getExtraLong(String key) {\n    return mExtraData.optLong(key);\n}","new_comment_raw":"@return The stored value.","old_comment_raw":"@return The stored value or null if it doesn't exist in specified form.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":18},{"new_code_raw":"public JSONRequest toArray(int count, int page, String name) { return new JSONRequest(StringUtil.getString(name) + KEY_ARRAY, this.setCount(count).setPage(page)); }","old_code_raw":"public JSONRequest toArray(int count, int page, String name) {\n    return toArray(count, page, name, true);\n}","new_comment_raw":"@return {name+KEY_ARRAY : this}. if needs to be put, use {@link #add(com.alibaba.fastjson.JSONObject)} instead","old_comment_raw":"@return {@link #toArray(int, int, String, boolean)}","label":1,"pre_label":0,"AST_level":7,"line_counts":3,"new_code_token_num":38},{"new_code_raw":"public static QName getXSIType(Parameter param) { if (param.getMIMEType() != null) { return getMIMETypeQName(param.getMIMEType()); } QName xmlType = null; TypeEntry te = param.getType(); if (te != null && te instanceof Element && te.getRefType() != null) { te = te.getRefType(); } if (te != null && te instanceof CollectionType && te.getRefType() != null) { te = te.getRefType(); } if (te != null) { xmlType = te.getQName(); } return xmlType; }","old_code_raw":"public static QName getXSIType(TypeEntry te) {\n    QName xmlType = null;\n    if (te != null && te instanceof Element && te.getRefType() != null) {\n        te = te.getRefType();\n    }\n    if (te != null && te instanceof CollectionType && te.getRefType() != null) {\n        te = te.getRefType();\n    }\n    if (te != null) {\n        xmlType = te.getQName();\n    }\n    return xmlType;\n}","new_comment_raw":"@return the QName of the parameter's type","old_comment_raw":"@return the QName of the type","label":1,"pre_label":0,"AST_level":7,"line_counts":17,"new_code_token_num":112},{"new_code_raw":"private int measureWidth(int widthMeasureSpec) { int widthSize = MeasureSpec.getSize(widthMeasureSpec); int widthMode = MeasureSpec.getMode(widthMeasureSpec); int measuredWidth = widthSize; if (mThumbWidth == 0 && mIsThumbUseDrawable) { mThumbWidth = mThumbDrawable.getIntrinsicWidth(); } int moveRange; int textWidth = ceil(mTextWidth); \/\/ how much the background should extend to fit text. int textExtraSpace; int contentSize; if (mThumbRangeRatio == 0) { mThumbRangeRatio = DEFAULT_THUMB_RANGE_RATIO; } if (widthMode == MeasureSpec.EXACTLY) { contentSize = widthSize - getPaddingLeft() - getPaddingRight(); if (mThumbWidth != 0) { moveRange = ceil(mThumbWidth * mThumbRangeRatio); textExtraSpace = textWidth + mTextExtra - (moveRange - mThumbWidth + ceil(Math.max(mThumbMargin.left, mThumbMargin.right))); mBackWidth = ceil(moveRange + mThumbMargin.left + mThumbMargin.right + Math.max(textExtraSpace, 0)); if (mBackWidth < 0) { mThumbWidth = 0; } if (moveRange + Math.max(mThumbMargin.left, 0) + Math.max(mThumbMargin.right, 0) + Math.max(textExtraSpace, 0) > contentSize) { mThumbWidth = 0; } } if (mThumbWidth == 0) { contentSize = widthSize - getPaddingLeft() - getPaddingRight(); moveRange = ceil(contentSize - Math.max(mThumbMargin.left, 0) - Math.max(mThumbMargin.right, 0)); if (moveRange < 0) { mThumbWidth = 0; mBackWidth = 0; return measuredWidth; } mThumbWidth = ceil(moveRange \/ mThumbRangeRatio); mBackWidth = ceil(moveRange + mThumbMargin.left + mThumbMargin.right); if (mBackWidth < 0) { mThumbWidth = 0; mBackWidth = 0; return measuredWidth; } textExtraSpace = textWidth + mTextExtra - (moveRange - mThumbWidth + ceil(Math.max(mThumbMargin.left, mThumbMargin.right))); if (textExtraSpace > 0) { \/\/ since backWidth is determined by view width, so we can only reduce thumbSize. mThumbWidth = mThumbWidth - textExtraSpace; } if (mThumbWidth < 0) { mThumbWidth = 0; mBackWidth = 0; return measuredWidth; } } } else { \/* If parent view want SwitchButton to determine it's size itself, we calculate the minimal size of it's content. Further more, we ignore the limitation of widthSize since we want to display SwitchButton in its actual size rather than compress the shape. *\/ if (mThumbWidth == 0) { \/* If thumbWidth is not set, use the default one. *\/ mThumbWidth = ceil(getResources().getDisplayMetrics().density * DEFAULT_THUMB_SIZE_DP); } if (mThumbRangeRatio == 0) { mThumbRangeRatio = DEFAULT_THUMB_RANGE_RATIO; } moveRange = ceil(mThumbWidth * mThumbRangeRatio); textExtraSpace = ceil(textWidth + mTextExtra - (moveRange - mThumbWidth + Math.max(mThumbMargin.left, mThumbMargin.right) + mTextThumbInset)); mBackWidth = ceil(moveRange + mThumbMargin.left + mThumbMargin.right + Math.max(0, textExtraSpace)); if (mBackWidth < 0) { mThumbWidth = 0; mBackWidth = 0; return measuredWidth; } contentSize = ceil(moveRange + Math.max(0, mThumbMargin.left) + Math.max(0, mThumbMargin.right) + Math.max(0, textExtraSpace)); measuredWidth = Math.max(contentSize, contentSize + getPaddingLeft() + getPaddingRight()); } return measuredWidth; }","old_code_raw":"    private int measureWidth(int widthMeasureSpec) {\n        int widthSize = MeasureSpec.getSize(widthMeasureSpec);\n        int widthMode = MeasureSpec.getMode(widthMeasureSpec);\n        int measuredWidth = widthSize;\n\n        if (mThumbWidth == 0 && mIsThumbUseDrawable) {\n            mThumbWidth = mThumbDrawable.getIntrinsicWidth();\n        }\n\n        int moveRange;\n        int textWidth = ceil(mTextWidth);\n        \/\/ how much the background should extend to fit text.\n        int textExtraSpace;\n        int contentSize;\n\n        if (mThumbRangeRatio == 0) {\n            mThumbRangeRatio = DEFAULT_THUMB_RANGE_RATIO;\n        }\n\n        if (widthMode == MeasureSpec.EXACTLY) {\n            contentSize = widthSize - getPaddingLeft() - getPaddingRight();\n\n            if (mThumbWidth != 0) {\n                moveRange = ceil(mThumbWidth * mThumbRangeRatio);\n                textExtraSpace = textWidth + mTextExtra - (moveRange - mThumbWidth - ceil(Math.max(mThumbMargin.left, mThumbMargin.right)));\n                mBackWidth = ceil(moveRange + mThumbMargin.left + mThumbMargin.right + Math.max(textExtraSpace, 0));\n                if (mBackWidth < 0) {\n                    mThumbWidth = 0;\n                }\n                if (moveRange + Math.max(mThumbMargin.left, 0) + Math.max(mThumbMargin.right, 0) + Math.max(textExtraSpace, 0) > contentSize) {\n                    mThumbWidth = 0;\n                }\n            }\n\n            if (mThumbWidth == 0) {\n                contentSize = widthSize - getPaddingLeft() - getPaddingRight();\n                moveRange = ceil(contentSize - Math.max(mThumbMargin.left, 0) - Math.max(mThumbMargin.right, 0));\n                if (moveRange < 0) {\n                    mThumbWidth = 0;\n                    mBackWidth = 0;\n                    return measuredWidth;\n                }\n                mThumbWidth = ceil(moveRange \/ mThumbRangeRatio);\n                mBackWidth = ceil(moveRange + mThumbMargin.left + mThumbMargin.right);\n                if (mBackWidth < 0) {\n                    mThumbWidth = 0;\n                    mBackWidth = 0;\n                    return measuredWidth;\n                }\n                textExtraSpace = textWidth + mTextExtra - (moveRange - mThumbWidth - ceil(Math.max(mThumbMargin.left, mThumbMargin.right)));\n                if (textExtraSpace > 0) {\n                    \/\/ since backWidth is determined by view width, so we can only reduce thumbSize.\n                    mThumbWidth = mThumbWidth - textExtraSpace;\n                }\n                if (mThumbWidth < 0) {\n                    mThumbWidth = 0;\n                    mBackWidth = 0;\n                    return measuredWidth;\n                }\n            }\n        } else {\n            \/*\n            If parent view want SwitchButton to determine it's size itself, we calculate the minimal\n            size of it's content. Further more, we ignore the limitation of widthSize since we want\n            to display SwitchButton in its actual size rather than compress the shape.\n             *\/\n            if (mThumbWidth == 0) {\n                \/*\n                If thumbWidth is not set, use the default one.\n                 *\/\n                mThumbWidth = ceil(getResources().getDisplayMetrics().density * DEFAULT_THUMB_SIZE_DP);\n            }\n            if (mThumbRangeRatio == 0) {\n                mThumbRangeRatio = DEFAULT_THUMB_RANGE_RATIO;\n            }\n\n            moveRange = ceil(mThumbWidth * mThumbRangeRatio);\n            textExtraSpace = ceil(textWidth + mTextExtra - (moveRange - mThumbWidth + Math.max(mThumbMargin.left, mThumbMargin.right) + mTextThumbInset));\n            mBackWidth = ceil(moveRange + mThumbMargin.left + mThumbMargin.right + Math.max(0, textExtraSpace));\n            contentSize = ceil(moveRange + Math.max(0, mThumbMargin.left) + Math.max(0, mThumbMargin.right) + Math.max(0, textExtraSpace));\n\n            measuredWidth = Math.max(contentSize, contentSize + getPaddingLeft() + getPaddingRight());\n        }\n        return measuredWidth;\n    }\n","new_comment_raw":"@return measuredWidth","old_comment_raw":"@return measuredWidth","label":0,"pre_label":1,"AST_level":13,"line_counts":91,"new_code_token_num":590},{"new_code_raw":"public static EventProcessingFailureHandlingMode parse(String value) { if (value == null) { return null; } value = value.trim(); for (EventProcessingFailureHandlingMode option : EventProcessingFailureHandlingMode.values()) { if (option.getValue().equalsIgnoreCase(value)) { return option; } } return null; }","old_code_raw":"        public static DdlParsingMode parse(String value, String defaultValue) {\n            DdlParsingMode mode = parse(value);\n            if (mode == null && defaultValue != null) {\n                mode = parse(defaultValue);\n            }\n            return mode;\n        }\n","new_comment_raw":"@return the matching option, or null if no match is found","old_comment_raw":"@return the matching option, or null if no match is found and the non-null default is invalid","label":1,"pre_label":0,"AST_level":8,"line_counts":16,"new_code_token_num":57},{"new_code_raw":"public Date getCreateDate() { return this.createDate; }","old_code_raw":"public java.util.Date getCreateDate() {\n    return this.createDate;\n}","new_comment_raw":"@return {@link Date} ","old_comment_raw":"@return java.util.Date","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":11},{"new_code_raw":"public DateOnly roundFloorCopy() { DateOnly instant = iInstant; return (DateOnly)instant.withMillis(iField.roundFloor(instant.getMillis())); }","old_code_raw":"    public DateOnly roundFloorCopy() {\n        DateOnly instant = iInstant;\n        return (DateOnly)instant.toCopy(iField.roundFloor(instant.getMillis()));\n    }\n","new_comment_raw":"@return a copy of the DateOnly with the field value changed","old_comment_raw":"@return a copy of the DateOnly with the field value changed","label":0,"pre_label":1,"AST_level":7,"line_counts":5,"new_code_token_num":28},{"new_code_raw":"public NVP<Long, Double> reset(final long newStartMs, final long newCount) { final long[] priorWindow = TIME_WINDOW_UPDATER.getAndSet(this, windowRangeFromMs(newStartMs, windowWidth)); final long priorCount = count; count = newCount; return new NVP<Long, Double>(priorWindow[NUM], calcRate(priorCount, windowWidth)); }","old_code_raw":"public long reset() {\n    final long priorCount = count;\n    count = NUM;\n    return priorCount;\n}","new_comment_raw":"@return An NVP of the the prior window end time and the effective count per second","old_comment_raw":"@return the prior count","label":1,"pre_label":0,"AST_level":7,"line_counts":6,"new_code_token_num":63},{"new_code_raw":"public IterOutcome innerNext() { if (hasRemainderForLeftJoin) { \/\/ if set that means there is spill over from previous left batch and no \/\/ corresponding right rows and it is left join scenario allocateVectors(); boolean hasMoreRows = !handleRemainingLeftRows(); if (leftUpstream == EMIT || hasMoreRows) { logger.debug(\"Sending current output batch with EMIT outcome since left is received with EMIT and is fully \" + \"consumed now in output batch\"); hasRemainderForLeftJoin = hasMoreRows; finalizeOutputContainer(); return (leftUpstream == EMIT) ? EMIT : OK; } else { \/\/ release memory for previous left batch leftJoinIndex = -1; VectorAccessibleUtilities.clear(left); } } \/\/ We don't do anything special on FIRST state. Process left batch first and then right batch if need be IterOutcome childOutcome = processLeftBatch(); logger.debug(\"Received left batch with outcome {}\", childOutcome); if (processLeftBatchInFuture && hasRemainderForLeftJoin) { finalizeOutputContainer(); hasRemainderForLeftJoin = false; return OK; } \/\/ reset this state after calling processLeftBatch above. processLeftBatchInFuture = false; hasRemainderForLeftJoin = false; \/\/ If the left batch doesn't have any record in the incoming batch (with OK_NEW_SCHEMA\/EMIT) or the state returned \/\/ from left side is terminal state then just return the IterOutcome and don't call next() on right branch if (isTerminalOutcome(childOutcome) || left.getRecordCount() == 0) { container.setRecordCount(0); return childOutcome; } \/\/ Left side has some records in the batch so let's process right batch childOutcome = processRightBatch(); logger.debug(\"Received right batch with outcome {}\", childOutcome); \/\/ reset the left & right outcomes to OK here and send the empty batch downstream. Non-Empty right batch with \/\/ OK_NEW_SCHEMA will be handled in subsequent next call if (childOutcome == OK_NEW_SCHEMA) { leftUpstream = (leftUpstream != EMIT) ? OK : leftUpstream; rightUpstream = OK; return childOutcome; } if (isTerminalOutcome(childOutcome)) { return childOutcome; } \/\/ If OK_NEW_SCHEMA is seen only on non empty left batch but not on right batch, then we should setup schema in \/\/ output container based on new left schema and old right schema. If schema change failed then return STOP \/\/ downstream if (leftUpstream == OK_NEW_SCHEMA && !handleSchemaChange()) { return STOP; } \/\/ Setup the references of left, right and outgoing container in generated operator state = BatchState.NOT_FIRST; \/\/ Update the memory manager only if its a brand new incoming i.e. leftJoinIndex and rightJoinIndex is 0 \/\/ Otherwise there will be a case where while filling last output batch, some records from previous left or \/\/ right batch are still left to be sent in output for which we will count this batch twice. The actual checks \/\/ are done in updateMemoryManager updateMemoryManager(LEFT_INDEX); \/\/ We have to call update on memory manager for empty batches (rightJoinIndex = -1) as well since other wise while \/\/ allocating memory for vectors below it can fail. Since in that case colSize will not have any info on right side \/\/ vectors and throws NPE. The actual checks are done in updateMemoryManager updateMemoryManager(RIGHT_INDEX); \/\/ allocate space for the outgoing batch allocateVectors(); return produceOutputBatch(); }","old_code_raw":"  public IterOutcome innerNext() {\n\n    \/\/ We don't do anything special on FIRST state. Process left batch first and then right batch if need be\n    IterOutcome childOutcome = processLeftBatch();\n\n    \/\/ reset this state after calling processLeftBatch above.\n    processLeftBatchInFuture = false;\n\n    \/\/ If the left batch doesn't have any record in the incoming batch (with OK_NEW_SCHEMA\/EMIT) or the state returned\n    \/\/ from left side is terminal state then just return the IterOutcome and don't call next() on right branch\n    if (isTerminalOutcome(childOutcome) || left.getRecordCount() == 0) {\n      container.setRecordCount(0);\n      return childOutcome;\n    }\n\n    \/\/ Left side has some records in the batch so let's process right batch\n    childOutcome = processRightBatch();\n\n    \/\/ reset the left & right outcomes to OK here and send the empty batch downstream. Non-Empty right batch with\n    \/\/ OK_NEW_SCHEMA will be handled in subsequent next call\n    if (childOutcome == OK_NEW_SCHEMA) {\n      leftUpstream = (leftUpstream != EMIT) ? OK : leftUpstream;\n      rightUpstream = OK;\n      return childOutcome;\n    }\n\n    if (isTerminalOutcome(childOutcome)) {\n      return childOutcome;\n    }\n\n    \/\/ If OK_NEW_SCHEMA is seen only on non empty left batch but not on right batch, then we should setup schema in\n    \/\/ output container based on new left schema and old right schema. If schema change failed then return STOP\n    \/\/ downstream\n    if (leftUpstream == OK_NEW_SCHEMA && !handleSchemaChange()) {\n      return STOP;\n    }\n\n    \/\/ Setup the references of left, right and outgoing container in generated operator\n    state = BatchState.NOT_FIRST;\n\n    \/\/ Update the memory manager only if its a brand new incoming i.e. leftJoinIndex and rightJoinIndex is 0\n    \/\/ Otherwise there will be a case where while filling last output batch, some records from previous left or\n    \/\/ right batch are still left to be sent in output for which we will count this batch twice. The actual checks\n    \/\/ are done in updateMemoryManager\n    updateMemoryManager(LEFT_INDEX);\n\n    \/\/ We have to call update on memory manager for empty batches (rightJoinIndex = -1) as well since other wise while\n    \/\/ allocating memory for vectors below it can fail. Since in that case colSize will not have any info on right side\n    \/\/ vectors and throws NPE. The actual checks are done in updateMemoryManager\n    updateMemoryManager(RIGHT_INDEX);\n\n    \/\/ allocate space for the outgoing batch\n    allocateVectors();\n\n    return produceOutputBatch();\n  }\n","new_comment_raw":"@return IterOutcome state of the lateral join batch","old_comment_raw":"@return IterOutcome state of the lateral join batch","label":0,"pre_label":1,"AST_level":10,"line_counts":84,"new_code_token_num":630},{"new_code_raw":"public boolean get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }","old_code_raw":"public boolean get(WithAttributes attributes) {\n    return attributes.getAttributes().get(this);\n}","new_comment_raw":"@return the value of this attribute if this attribute is present in the extracted map. Otherwise {@link #getDefaultValue()}","old_comment_raw":"@return the value of this attribute if this attribute is present in the map. Otherwise {@link #getDefaultValue()}","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":19},{"new_code_raw":"public Label newLabelFromString(String labelStr) { int first = labelStr.indexOf(divider); int second = labelStr.lastIndexOf(divider); if (first == second) { return new WordLemmaTag(labelStr.substring(0, first), Morphology.lemmaStatic(labelStr.substring(0, first), labelStr.substring(first + 1)), labelStr.substring(first + 1)); } else if (first >= 0) { return new WordLemmaTag(labelStr.substring(0, first), labelStr.substring(first + 1, second), labelStr.substring(second + 1)); } else { return new WordLemmaTag(labelStr); } }","old_code_raw":"  public Label newLabelFromString(String labelStr) {\n    int first = labelStr.indexOf(divider);\n    int second = labelStr.lastIndexOf(divider);\n    if (first == second) {\n      return new WordLemmaTag(labelStr.substring(0, first), Morphology.stemStatic(labelStr.substring(0, first), labelStr.substring(first + 1)).word(), labelStr.substring(first + 1));\n    } else if (first >= 0) {\n      return new WordLemmaTag(labelStr.substring(0, first), labelStr.substring(first + 1, second), labelStr.substring(second + 1));\n    } else {\n      return new WordLemmaTag(labelStr);\n    }\n  }\n","new_comment_raw":"@return The new WordLemmaTag","old_comment_raw":"@return The new WordLemmaTag","label":0,"pre_label":1,"AST_level":10,"line_counts":12,"new_code_token_num":122},{"new_code_raw":"protected Object convertTimeToMillisPastMidnightAsDate(Column column, Field fieldDefn, Object data) { if ( data == null ) return null; try { return new java.util.Date(Time.toMilliOfDay(data)); } catch (IllegalArgumentException e) { return handleUnknownData(column, fieldDefn, data); } }","old_code_raw":"    protected Object convertTimeToMillisPastMidnightAsDate(Column column, Field fieldDefn, Object data) {\n        try {\n            Integer millisOfDay = Time.toMilliOfDay(data);\n            if ( millisOfDay == null ) return null;\n            return new java.util.Date(millisOfDay.longValue());\n        } catch (IllegalArgumentException e) {\n            return handleUnknownData(column, fieldDefn, data);\n        }\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made","old_comment_raw":"@return the converted value, or null if the conversion could not be made","label":0,"pre_label":1,"AST_level":8,"line_counts":9,"new_code_token_num":56},{"new_code_raw":"@ManagedAttribute(description = STR) public boolean getRunning() { return running.get(); }","old_code_raw":"public AtomicBoolean getRunning() {\n    return running;\n}","new_comment_raw":"@return true if running, false if stopped","old_comment_raw":"@return the running","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":19},{"new_code_raw":"public boolean isSessionToken(String site, String token) { HashSet<String> siteTokens = sessionTokens.get(site); if (siteTokens == null) return false; return siteTokens.contains(token); }","old_code_raw":"\tpublic boolean isSessionToken(String site, String token) {\n\t\tHashSet<String> siteTokens = sessionTokens.get(site);\n\t\tif (siteTokens == null)\n\t\t\treturn false;\n\t\treturn siteTokens.contains(token.toLowerCase(Locale.ENGLISH));\n\t}\n","new_comment_raw":"@return true, if it is session token","old_comment_raw":"@return true, if it is session token","label":0,"pre_label":1,"AST_level":6,"line_counts":7,"new_code_token_num":36},{"new_code_raw":"public synchronized VisualItem getItem(String itemClass, Entity entity, boolean create) { ItemEntry entry = (ItemEntry) m_entryMap.get(itemClass); if (entry != null) { VisualItem item = (VisualItem) entry.itemMap.get(entity); if (!create) { return item; } else if (item == null) { item = m_ifactory.getItem(itemClass); item.init(this, itemClass, entity); addItem(entry, entity, item); } if (item instanceof NodeItem) ((NodeItem) item).removeAllNeighbors(); item.setDirty(NUM); item.setVisible(true); return item; } else { throw new IllegalArgumentException(STR + STR); } }","old_code_raw":"public synchronized GraphItem getItem(String itemClass, Entity entity, boolean create) {\n    ItemEntry entry = (ItemEntry) m_entryMap.get(itemClass);\n    if (entry != null) {\n        GraphItem item = (GraphItem) entry.itemMap.get(entity);\n        if (!create) {\n            return item;\n        } else if (item == null) {\n            item = m_ifactory.getItem(itemClass);\n            item.init(this, itemClass, entity);\n            addItem(entry, entity, item);\n        }\n        if (item instanceof NodeItem)\n            ((NodeItem) item).removeAllNeighbors();\n        item.setDirty(NUM);\n        item.setVisible(true);\n        return item;\n    } else {\n        throw new IllegalArgumentException(STR + STR);\n    }\n}","new_comment_raw":"@return the requested VisualItem, or null if the VisualItem wasn't found and the create parameter is false.","old_comment_raw":"@return the requested GraphItem, or null if the GraphItem wasn't found and the create parameter is false.","label":1,"pre_label":0,"AST_level":11,"line_counts":20,"new_code_token_num":134},{"new_code_raw":"public static String normalizeDateString(String s, String ctxdate) { \/\/ TODO [pengqi]: need to handle basic localization (\"\u00e5\u009c\u00a8\u00e4\u00b8\u0083\u00e6\u009c\u0088\u00e4\u00ba\u008c\u00e6\u0097\u00a5\u00e5\u0088\u00b0[\u00e5 \u00ab\u00e6\u0097\u00a5]\u00e9\u0097\u00b4\") \/\/ TODO [pengqi]: need to handle literal numeral dates (usually used in events, e.g. \"\u00e4\u00b8\u0089\u00e4\u00b8\u0080\u00e4\u00ba\u0094\" for 03-15) \/\/ TODO [pengqi]: might need to add a pattern for centuries (\"\u00e4\u00b8\u008a\u00e4\u00b8\u0096\u00e7\u00ba\u00aa90\u00e5\u00b9\u00b4\u00e4\u00bb\u00a3\")? Pattern p; Matcher m; String ctxyear = \"XXXX\", ctxmonth = \"XX\", ctxday = \"XX\"; \/\/ set up context date if (ctxdate != null) { p = Pattern.compile(\"^\" + BASIC_YYYYMMDD_PATTERN + \"$\"); m = p.matcher(ctxdate); if (m.find() && m.groupCount() == 3) { ctxyear = m.group(1); ctxmonth = m.group(2); ctxday = m.group(3); } } p = Pattern.compile(\"^\" + BIRTH_DECADE_PATTERN + \"$\"); m = p.matcher(s); if (m.find() && m.groupCount() == 1) { StringBuilder res = new StringBuilder(); res.append(normalizeYear(m.group(1), ctxyear, true).substring(0, 3) + \"X\"); res.append(\"-XX-XX\"); return res.toString(); } p = Pattern.compile(\"^\" + RELATIVE_TIME_PATTERN + \"$\"); m = p.matcher(s); if (m.find() && m.groupCount() == 1) { StringBuilder res = new StringBuilder(); res.append(ctxyear); res.append(\"-\"); res.append(ctxmonth); res.append(\"-\"); res.append(normalizeMonthOrDay(m.group(1), ctxday)); return res.toString(); } p = Pattern.compile(\"^\" + BASIC_YYYYMMDD_PATTERN + \"$\"); m = p.matcher(s); if (m.find() && m.groupCount() == 3) { StringBuilder res = new StringBuilder(); res.append(normalizeYear(m.group(1), ctxyear)); res.append(\"-\"); res.append(normalizeMonthOrDay(m.group(2), ctxmonth)); res.append(\"-\"); res.append(normalizeMonthOrDay(m.group(3), ctxday)); return res.toString(); } p = Pattern.compile(\"^\" + BASIC_MMDD_PATTERN + \"$\"); m = p.matcher(s); if (m.find() && m.groupCount() == 2) { StringBuilder res = new StringBuilder(); res.append(ctxyear); res.append(\"-\"); res.append(normalizeMonthOrDay(m.group(1), ctxmonth)); res.append(\"-\"); res.append(normalizeMonthOrDay(m.group(2), ctxday)); return res.toString(); } p = Pattern.compile(\"^\" + BASIC_DD_PATTERN + \"$\"); m = p.matcher(s); if (m.find() && m.groupCount() == 1) { StringBuilder res = new StringBuilder(); res.append(ctxyear); res.append(\"-\"); res.append(ctxmonth); res.append(\"-\"); res.append(normalizeMonthOrDay(m.group(1), ctxday)); return res.toString(); } p = Pattern.compile(\"^\" + ENGLISH_MMDDYYYY_PATTERN + \"$\"); m = p.matcher(s); if (m.find() && m.groupCount() == 3) { StringBuilder res = new StringBuilder(); if (m.group(3) == null) res.append(ctxyear); else res.append(normalizeYear(m.group(3), ctxyear)); res.append(\"-\"); res.append(normalizeMonthOrDay(m.group(1), ctxmonth)); res.append(\"-\"); res.append(normalizeMonthOrDay(m.group(2), ctxday)); return res.toString(); } return s; }","old_code_raw":"  public static String normalizeDateString(String s, Date ctxdate) {\n    \/\/ TODO [pengqi]: need to handle basic localization (\"\u00e5\u009c\u00a8\u00e4\u00b8\u0083\u00e6\u009c\u0088\u00e4\u00ba\u008c\u00e6\u0097\u00a5\u00e5\u0088\u00b0[\u00e5\u0085\u00ab\u00e6\u0097\u00a5]\u00e9\u0097\u00b4\")\n    \/\/ TODO [pengqi]: need to handle literal numeral dates (usually used in events, e.g. \"\u00e4\u00b8\u0089\u00e4\u00b8\u0080\u00e4\u00ba\u0094\" for 03-15)\n    \/\/ TODO [pengqi]: might need to add a pattern for centuries (\"\u00e4\u00b8\u008a\u00e4\u00b8\u0096\u00e7\u00ba\u00aa90\u00e5\u00b9\u00b4\u00e4\u00bb\u00a3\")?\n    String ctxyear = new SimpleDateFormat(\"yyyy\").format(ctxdate);\n    String ctxmonth = new SimpleDateFormat(\"MM\").format(ctxdate);\n    String ctxday = new SimpleDateFormat(\"dd\").format(ctxdate);\n\n    Pattern p = Pattern.compile(\"^\" + BASIC_YYYYMMDD_PATTERN + \"$\");\n    Matcher m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 3) {\n      StringBuilder res = new StringBuilder();\n\n      res.append(normalizeYear(m.group(1), ctxyear));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(2), ctxmonth));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(3), ctxday));\n\n      return res.toString();\n    }\n\n    p = Pattern.compile(\"^\" + BASIC_MMDD_PATTERN + \"$\");\n    m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 2) {\n      StringBuilder res = new StringBuilder();\n\n      res.append(ctxyear);\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(1), ctxmonth));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(2), ctxday));\n\n      return res.toString();\n    }\n\n    p = Pattern.compile(\"^\" + BASIC_DD_PATTERN + \"$\");\n    m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 1) {\n      StringBuilder res = new StringBuilder();\n\n      res.append(ctxyear);\n      res.append(\"-\");\n      res.append(ctxmonth);\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(1), ctxday));\n\n      return res.toString();\n    }\n\n    p = Pattern.compile(\"^\" + ENGLISH_MMDDYYYY_PATTERN + \"$\");\n    m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 3) {\n      StringBuilder res = new StringBuilder();\n\n      if (m.group(3) == null)\n        res.append(ctxyear);\n      else\n        res.append(normalizeYear(m.group(3), ctxyear));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(1), ctxmonth));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(2), ctxday));\n\n      return res.toString();\n    }\n\n    return s;\n  }\n","new_comment_raw":"@return Normalized Timex expression of the input date string","old_comment_raw":"@return Normalized Timex expression of the input date string","label":0,"pre_label":1,"AST_level":10,"line_counts":114,"new_code_token_num":813},{"new_code_raw":"private File[] getDirectoryHistory() { File[] dirhist = Settings.instance().getDirectoryHistory(); if (dirhist == null || dirhist.length == NUM) return new File[] { new File(STR).getAbsoluteFile() }; else return dirhist; }","old_code_raw":"private String[] getDirectoryHistory() {\n    return new String[] { directory.getAbsolutePath(), STR, STR, STR, STR };\n}","new_comment_raw":"@return current directory history, or if empty, only current directory (as File[0]).","old_comment_raw":"@return current directory history.","label":1,"pre_label":0,"AST_level":8,"line_counts":7,"new_code_token_num":51},{"new_code_raw":"public boolean waitForText(String text, int minimumNumberOfMatches, long timeout, boolean scroll) { return robotiumUtils.waitForText(text, minimumNumberOfMatches, timeout, scroll); }","old_code_raw":"public boolean waitForText(String text, int expectedMinimumNumberOfMatches, long timeout, boolean scroll) {\n    return robotiumUtils.waitForText(text, expectedMinimumNumberOfMatches, timeout, scroll);\n}","new_comment_raw":"@return {@code true} if text is shown and {@code false} if it is not shown before the timeout","old_comment_raw":"@return {@code true} if text is found and {@code false} if it is not found before the timeout","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":31},{"new_code_raw":"public Period withField(DurationFieldType field, int value) { if (field == null) { throw new IllegalArgumentException(\"Field must not be null\"); } int[] newValues = getValues(); \/\/ cloned super.setFieldInto(newValues, field, value); return new Period(newValues, getPeriodType()); }","old_code_raw":"    public Period withField(DurationFieldType field, int value) {\n        if (field == null) {\n            return this;\n        }\n        int[] newValues = getValues();  \/\/ cloned\n        super.setFieldInto(newValues, field, value);\n        return new Period(newValues, getPeriodType());\n    }\n","new_comment_raw":"@return the new period instance","old_comment_raw":"@return the new period instance","label":0,"pre_label":1,"AST_level":7,"line_counts":9,"new_code_token_num":64},{"new_code_raw":"public int removeActiveMessage() { return removeMessage(currentPage); }","old_code_raw":"public boolean removeActiveMessage() {\n    return removeMessage(currentPage);\n}","new_comment_raw":"@return One of STATUS_MESSAGES_REMAINING, STATUS_NO_MESSAGES_REMAINING or STATUS_REMOVING_MESSAGE","old_comment_raw":"@return true if a message was removed, false otherwise.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":13},{"new_code_raw":"protected PingResult parse(int exitValue, List<String> outLines, List<String> errLines) { PingResult info = new PingResult(); Pattern roundTripTimePat = Pattern.compile(RTT_REG_EX); Pattern transmitReceivePat = Pattern.compile(TRANSMITTED_RECEIVED_REG_EX); Pattern noRouteToHostPat = Pattern.compile(NO_ROUTE_TO_HOST_REG_EX); Pattern unknownHostPat = Pattern.compile(UNKNOWN_HOST_REG_EX); info.setHost(getHost()); switch(exitValue) { case NUM: for (String line : outLines) { Matcher matcher = roundTripTimePat.matcher(line); if (matcher.find()) { info.setRTTMin(Double.parseDouble(matcher.group(NUM))); info.setRTTAvg(Double.parseDouble(matcher.group(NUM))); info.setRTTMax(Double.parseDouble(matcher.group(NUM))); info.setRTTMDev(Double.parseDouble(matcher.group(NUM))); } } for (String line : outLines) { Matcher matcher = transmitReceivePat.matcher(line); if (matcher.find()) { info.setTransmitted(Integer.parseInt(matcher.group(NUM))); info.setReceived(Integer.parseInt(matcher.group(NUM))); } } if (info.getReceived() == NUM) { info.setStatus(ServiceStatus.FAIL); } else { info.setStatus(ServiceStatus.SUCCESS); } break; case NUM: case NUM: case NUM: for (String line : outLines) { Matcher matcher = transmitReceivePat.matcher(line); if (matcher.find()) { info.setTransmitted(Integer.parseInt(matcher.group(NUM))); info.setReceived(Integer.parseInt(matcher.group(NUM))); } } for (String line : errLines) { Matcher matcher = unknownHostPat.matcher(line); if (matcher.find()) { info.setMessage(matcher.group(NUM)); } } info.setStatus(ServiceStatus.FAIL); break; default: assert false : STR; } return info; }","old_code_raw":"protected PingInfo parse(int exitValue, List<String> outLines, List<String> errLines) {\n    PingInfo info = new PingInfo();\n    Pattern roundTripTimePat = Pattern.compile(RTT_REG_EX);\n    Pattern transmitReceivePat = Pattern.compile(TRANSMITTED_RECEIVED_REG_EX);\n    Pattern noRouteToHostPat = Pattern.compile(NO_ROUTE_TO_HOST_REG_EX);\n    Pattern unknownHostPat = Pattern.compile(UNKNOWN_HOST_REG_EX);\n    info.setHost(getHost());\n    switch(exitValue) {\n        case NUM:\n            for (String line : outLines) {\n                Matcher matcher = roundTripTimePat.matcher(line);\n                if (matcher.find()) {\n                    info.setRTTMin(Double.parseDouble(matcher.group(NUM)));\n                    info.setRTTAvg(Double.parseDouble(matcher.group(NUM)));\n                    info.setRTTMax(Double.parseDouble(matcher.group(NUM)));\n                    info.setRTTMDev(Double.parseDouble(matcher.group(NUM)));\n                }\n            }\n            for (String line : outLines) {\n                Matcher matcher = transmitReceivePat.matcher(line);\n                if (matcher.find()) {\n                    info.setTransmitted(Integer.parseInt(matcher.group(NUM)));\n                    info.setReceived(Integer.parseInt(matcher.group(NUM)));\n                }\n            }\n            if (info.getReceived() == NUM) {\n                info.setStatus(ServiceStatus.FAIL);\n            } else {\n                info.setStatus(ServiceStatus.SUCCESS);\n            }\n            break;\n        case NUM:\n        case NUM:\n        case NUM:\n            for (String line : outLines) {\n                Matcher matcher = transmitReceivePat.matcher(line);\n                if (matcher.find()) {\n                    info.setTransmitted(Integer.parseInt(matcher.group(NUM)));\n                    info.setReceived(Integer.parseInt(matcher.group(NUM)));\n                }\n            }\n            for (String line : errLines) {\n                Matcher matcher = unknownHostPat.matcher(line);\n                if (matcher.find()) {\n                    info.setMessage(matcher.group(NUM));\n                }\n            }\n            info.setStatus(ServiceStatus.FAIL);\n            break;\n        default:\n            assert false : STR;\n    }\n    return info;\n}","new_comment_raw":"@return {@link PingResult}","old_comment_raw":"@return {@link PingInfo}","label":1,"pre_label":0,"AST_level":13,"line_counts":54,"new_code_token_num":356},{"new_code_raw":"public Response syncSendPacket(Command command) throws JMSException { return syncSendPacket(command, 0); }","old_code_raw":"    public Response syncSendPacket(Command command, int timeout) throws JMSException {\n        if (isClosed() || closing.get()) {\n            throw new ConnectionClosedException();\n        } else {\n            return doSyncSendPacket(command, timeout);\n        }\n    }\n","new_comment_raw":"@return the broker Response for the given Command.","old_comment_raw":"@return the broker Response for the given Command.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":19},{"new_code_raw":"public Tree transformTree(Tree t) { if (VERBOSE) { System.err.println(\"Input to CoordinationTransformer: \" + t); } Tree tx = tn.transformTree(t); if (VERBOSE) { System.err.println(\"After DependencyTreeTransformer: \" + tx); } if (tx == null) { return tx; } Tree tt = UCPtransform(tx); if (VERBOSE) { System.err.println(\"After UCPTransformer: \" + tt); } Tree ttt = CCtransform(tt); if (VERBOSE) { System.err.println(\"After CCTransformer: \" + ttt); } Tree tttt = qp.transformTree(ttt); if (VERBOSE) { System.err.println(\"After QPTreeTransformer: \" + tttt); } Tree flatSQ = SQflatten(tttt); if (VERBOSE) { System.err.println(\"After SQ flattening: \" + flatSQ); } Tree ret = dates.transformTree(flatSQ); if (VERBOSE) { System.err.println(\"After DateTreeTransformer: \" + ret); } return ret; }","old_code_raw":"  public Tree transformTree(Tree t) {\n    if (VERBOSE) {\n      System.err.println(\"Input to CoordinationTransformer: \" + t);\n    }\n    t = tn.transformTree(t);\n    if (VERBOSE) {\n      System.err.println(\"After DependencyTreeTransformer:  \" + t);\n    }\n    if (t == null) {\n      return t;\n    }\n    t = UCPtransform(t);\n    if (VERBOSE) {\n      System.err.println(\"After UCPTransformer:             \" + t);\n    }\n    t = CCtransform(t);\n    if (VERBOSE) {\n      System.err.println(\"After CCTransformer:              \" + t);\n    }\n    t = qp.transformTree(t);\n    if (VERBOSE) {\n      System.err.println(\"After QPTreeTransformer:          \" + t);\n    }\n    t = SQflatten(t);\n    if (VERBOSE) {\n      System.err.println(\"After SQ flattening:              \" + t);\n    }\n    t = dates.transformTree(t);\n    if (VERBOSE) {\n      System.err.println(\"After DateTreeTransformer:        \" + t);\n    }\n    t = removeXOverX(t);\n    if (VERBOSE) {\n      System.err.println(\"After removeXoverX:               \" + t);\n    }\n    t = combineConjp(t);\n    if (VERBOSE) {\n      System.err.println(\"After combineConjp:               \" + t);\n    }\n    t = moveRB(t);\n    if (VERBOSE) {\n      System.err.println(\"After moveRB:                     \" + t);\n    }\n    t = changeSbarToPP(t);\n    if (VERBOSE) {\n      System.err.println(\"After changeSbarToPP:             \" + t);\n    }\n    t = rearrangeNowThat(t);\n    if (VERBOSE) {\n      System.err.println(\"After rearrangeNowThat:           \" + t);\n    }\n    return t;\n  }\n","new_comment_raw":"@return t transformed","old_comment_raw":"@return t transformed","label":0,"pre_label":1,"AST_level":8,"line_counts":34,"new_code_token_num":202},{"new_code_raw":"public MainWindowBase getSleakWindow() { DeviceData data = new DeviceData(); data.tracking = true; Display display = new Display(data); Sleak sleak = new Sleak(); sleak.open(); Shell shell = new Shell(display); window = new MainWindowBase(shell); return window; }","old_code_raw":"public MainWindow getSleakWindow() {\n    DeviceData data = new DeviceData();\n    data.tracking = true;\n    Display display = new Display(data);\n    Sleak sleak = new Sleak();\n    sleak.open();\n    Shell shell = new Shell(display);\n    window = new MainWindow(shell);\n    return window;\n}","new_comment_raw":"@return The {@link MainWindowBase} monitored by Sleak.java","old_comment_raw":"@return The {@link MainWindow} monitored by Sleak.java","label":1,"pre_label":0,"AST_level":6,"line_counts":10,"new_code_token_num":56},{"new_code_raw":"public long getConnectAttemptTimeout() { return wireFormat.getConnectAttemptTimeout(); }","old_code_raw":"    public long getConnectAttemptTimeout() {\n        return connectAttemptTimeout;\n    }\n","new_comment_raw":"@return the timeout value used to fail a connection if no CONNECT frame read.","old_comment_raw":"@return the timeout value used to fail a connection if no CONNECT frame read.","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":13},{"new_code_raw":"public String getSelectionHost() { ISelection selection = getSelection(); if (selection instanceof IStructuredSelection && !selection.isEmpty()) { Object element = ((IStructuredSelection) selection).getFirstElement(); IPropertiesAccessService service = ServiceManager.getInstance().getService(element, IPropertiesAccessService.class); if (service != null) { Map<String, String> props = service.getTargetAddress(element); if (props != null && props.containsKey(IPropertiesAccessServiceConstants.PROP_ADDRESS)) { return props.get(IPropertiesAccessServiceConstants.PROP_ADDRESS); } } } return null; }","old_code_raw":"public String getSelectionHost() {\n    ISelection selection = getSelection();\n    final AtomicReference<String> result = new AtomicReference<String>();\n    if (selection instanceof IStructuredSelection && !selection.isEmpty()) {\n        Object element = ((IStructuredSelection) selection).getFirstElement();\n        if (element instanceof IPeerModel) {\n            final IPeerModel peerModel = (IPeerModel) element;\n            if (Protocol.isDispatchThread()) {\n                result.set(peerModel.getPeer().getAttributes().get(IPeer.ATTR_IP_HOST));\n            } else {\n                Protocol.invokeAndWait(new Runnable() {\n\n                    @Override\n                    public void run() {\n                        result.set(peerModel.getPeer().getAttributes().get(IPeer.ATTR_IP_HOST));\n                    }\n                });\n            }\n        }\n    }\n    return result.get();\n}","new_comment_raw":"@return The host name or IP, or <code>null<\/code>.","old_comment_raw":"@return The host name or IP.","label":1,"pre_label":0,"AST_level":11,"line_counts":14,"new_code_token_num":100},{"new_code_raw":"public static boolean startsWithPattern(final byte[] byteArray, final byte[] pattern) { return hasPatternAt(byteArray, pattern, 0); }","old_code_raw":"  public static boolean startsWithPattern(final byte[] byteArray, final byte[] pattern) {\n    Preconditions.checkNotNull(byteArray);\n    Preconditions.checkNotNull(pattern);\n    if (pattern.length > byteArray.length) {\n      return false;\n    }\n\n    for (int i = 0; i < pattern.length; ++i) {\n      if (byteArray[i] != pattern[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n","new_comment_raw":"@return true if byteArray starts with pattern","old_comment_raw":"@return true if byteArray starts with pattern","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":29},{"new_code_raw":"public int getDrawQueue() { return drawQueueType; }","old_code_raw":"public DrawQueue getDrawQueue() {\n    return drawQueue;\n}","new_comment_raw":"@return the current draw queue type for this Layer","old_comment_raw":"@return the current DrawQueue object for this Scene","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":10},{"new_code_raw":"public SortedMap<String, String> getOriginTabContentsAsStrings(final Origin selectedColumn) { openTab(Tab.ORIGIN); return mapTableCellsKeyValue(String.class, getVisibleTableRows(true, false), selectedColumn.column); }","old_code_raw":"public SortedMap<String, String> getOriginTabContentsAsStrings() {\n    openTab(Tab.ORIGIN);\n    return mapTableCellsKeyValue(String.class, getVisibleTableRows(true, true), NUM);\n}","new_comment_raw":"@return a map of the specified two columns. (first column => selectedColumn)","old_comment_raw":"@return a map of the first two columns. (first column => second column)","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":36},{"new_code_raw":"public ArrayList<TextView> clickInList(int line, int index) { line--; if(line < 0) line = 0; boolean foundList = waiter.waitForView(ListView.class, index); if (!foundList) Assert.assertTrue(\"No ListView with index \" + index + \" is available!\", false); ArrayList<View> views = new ArrayList<View>(); final ListView listView = viewFetcher.getView(ListView.class, null, index); if(listView == null) Assert.assertTrue(\"ListView is null!\", false); View view = listView.getChildAt(line); if(view != null){ views = viewFetcher.getViews(view, true); views = RobotiumUtils.removeInvisibleViews(views); clickOnScreen(getClickableView(views)); } return RobotiumUtils.filterViews(TextView.class, views); }","old_code_raw":"\tpublic ArrayList<TextView> clickInList(int line, int index) {\t\n\t\tif(line < 1)\n\t\t\tline = 1;\n\n\t\tboolean foundList = waiter.waitForView(ListView.class, index);\n\n\t\tif (!foundList) {\n\t\t\tAssert.assertTrue(\"No ListView with index \" + index + \" is available!\", false);\n\t\t}\n\n\t\tArrayList<TextView> textViews = null;\n\t\tfinal ListView listView = viewFetcher.getView(ListView.class, null, index);\n\t\tif(listView == null)\n\t\t\tAssert.assertTrue(\"ListView is null!\", false);\n\n\t\ttextViews = viewFetcher.getCurrentViews(TextView.class, listView);\n\t\ttextViews = RobotiumUtils.removeInvisibleViews(textViews);\n\n\t\tArrayList<TextView> textViewGroup = new ArrayList<TextView>();\n\t\tint myLine = 0;\n\t\tif(textViews !=null ){\n\t\t\tfor (int i = 0; i < textViews.size(); i++) {\n\t\t\t\tView view = viewFetcher.getListItemParent(textViews.get(i));\n\t\t\t\ttry {\n\t\t\t\t\tif (view.equals(viewFetcher.getListItemParent(textViews.get(i + 1)))) {\n\t\t\t\t\t\ttextViewGroup.add(textViews.get(i));\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttextViewGroup.add(textViews.get(i));\n\t\t\t\t\t\tmyLine++;\n\t\t\t\t\t\tif (myLine == line)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ttextViewGroup.clear();\n\t\t\t\t\t}\n\t\t\t\t} catch (IndexOutOfBoundsException e) {textViewGroup.add(textViews.get(i));}\n\t\t\t}\n\t\t}\n\t\tif (textViewGroup.size() != 0){\n\t\t\tclickOnScreen(textViewGroup.get(textViewGroup.size()-1));\n\t\t}\n\t\treturn textViewGroup;\n\t}\n","new_comment_raw":"@return an  ArrayList of the  TextViews located in the list line","old_comment_raw":"@return an ArrayList of the TextViews located in the list line","label":0,"pre_label":1,"AST_level":8,"line_counts":23,"new_code_token_num":153},{"new_code_raw":"public JSONArray names() { JSONArray ja = new JSONArray(); Iterator keys = this.keys(); while (keys.hasNext()) { ja.append(keys.next()); } return ja.size() == 0 ? null : ja; }","old_code_raw":"  public JSONArray names() {\n    JSONArray ja = new JSONArray();\n    Iterator  keys = this.keys();\n    while (keys.hasNext()) {\n      ja.append(keys.next());\n    }\n    return ja.length() == 0 ? null : ja;\n  }\n","new_comment_raw":"@return A JSONArray containing the key strings, or null if the JSONObject is empty.","old_comment_raw":"@return A JSONArray containing the key strings, or null if the JSONObject is empty.","label":0,"pre_label":1,"AST_level":7,"line_counts":9,"new_code_token_num":50},{"new_code_raw":"public YearMonthDay setCopy(int value) { int[] newValues = iYearMonthDay.getValues(); newValues = getField().set(iYearMonthDay, iFieldIndex, newValues, value); return new YearMonthDay(iYearMonthDay, newValues); }","old_code_raw":"        public YearMonthDay setCopy(int value) {\n            int[] newValues = iInstant.getValues();\n            getField().set(iInstant, iFieldIndex, newValues, value);\n            return new YearMonthDay(iInstant, newValues);\n        }\n","new_comment_raw":"@return a copy of the YearMonthDay with the field value changed","old_comment_raw":"@return a copy of the YearMonthDay with the field value changed","label":0,"pre_label":1,"AST_level":7,"line_counts":6,"new_code_token_num":42},{"new_code_raw":"static public IStructuredTextExpert getStatefulExpert(String type) { return getStatefulExpert(type, StructuredTextEnvironment.DEFAULT); }","old_code_raw":"static public ISTextExpert getStatefulExpert(String type) {\n    return getStatefulExpert(type, STextEnvironment.DEFAULT);\n}","new_comment_raw":"@return the IStructuredTextExpert instance.","old_comment_raw":"@return the ISTextExpert instance.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":19},{"new_code_raw":"public User getOwner() { return owner; }","old_code_raw":"public Person getOwner() {\n    return owner;\n}","new_comment_raw":"@return Valid {@link User}","old_comment_raw":"@return Valid {@link Person}","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":10},{"new_code_raw":"public Collection<T> call() throws Exception { sleeper.sleep(); ArrayList<T> viewsToReturn = null; if(onlyVisible){ viewsToReturn = RobotiumUtils.removeInvisibleViews(viewFetcher.getCurrentViews(viewClass)); } else{ viewsToReturn = viewFetcher.getCurrentViews(viewClass); } if(viewClass.isAssignableFrom(TextView.class)) { viewsToReturn.addAll((Collection<? extends T>) webUtils.getTextViewsFromWebView()); } return viewsToReturn; }","old_code_raw":"\t\t\tpublic Collection<T> call() throws Exception {\n\t\t\t\tsleeper.sleep();\n\n\t\t\t\tif(onlyVisible){\n\t\t\t\t\tArrayList<T> allVisibleViews = RobotiumUtils.removeInvisibleViews(viewFetcher.getCurrentViews(viewClass));\n\t\t\t\t\tallVisibleViews.addAll((Collection<? extends T>) webUtils.getTextViewsFromWebView());\n\t\t\t\t\treturn allVisibleViews;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tArrayList<T> allViews = viewFetcher.getCurrentViews(viewClass);\n\t\t\t\t\tallViews.addAll((Collection<? extends T>) webUtils.getTextViewsFromWebView());\n\t\t\t\t\treturn allViews;\n\t\t\t\t}\n\t\t\t}\n","new_comment_raw":"@return  true if a view of the specified class with the given text is found a given number of times.  false if it is not found.","old_comment_raw":"@return true if a view of the specified class with the given text is found a given number of times. false if it is not found.","label":0,"pre_label":1,"AST_level":10,"line_counts":17,"new_code_token_num":76},{"new_code_raw":"static Object wrapArgumentForScriptExecution(Object argument) { JSONObject wrappedArgument = new JSONObject(); try { if (argument instanceof String) { wrappedArgument.put(\"type\", \"STRING\"); wrappedArgument.put(\"value\", argument); } else if (argument instanceof Boolean) { wrappedArgument.put(\"type\", \"BOOLEAN\"); wrappedArgument.put(\"value\", argument); } else if (argument instanceof Number) { wrappedArgument.put(\"type\", \"NUMBER\"); wrappedArgument.put(\"value\", argument); } else if (argument instanceof ChromeWebElement) { wrappedArgument.put(\"type\", \"ELEMENT\"); wrappedArgument.put(\"value\", ((ChromeWebElement)argument).getElementId()); } else if (argument instanceof Collection<?>) { JSONArray array = new JSONArray(); for (Object o : (Collection<?>)argument) { array.put(wrapArgumentForScriptExecution(o)); } return array; } else { throw new IllegalArgumentException(\"Could not wrap up \" + \"javascript parameter \" + argument + \"(class: \" + argument.getClass() + \")\"); } } catch (JSONException e) { throw new WebDriverException(e); } return wrappedArgument; }","old_code_raw":"    static JSONObject wrapArgumentForScriptExecution(Object argument) {\n      JSONObject wrappedArgument = new JSONObject();\n      try {\n        if (argument instanceof String) {\n          wrappedArgument.put(\"type\", \"STRING\");\n          wrappedArgument.put(\"value\", argument);\n        } else if (argument instanceof Boolean) {\n          wrappedArgument.put(\"type\", \"BOOLEAN\");\n          wrappedArgument.put(\"value\", argument);\n        } else if (argument instanceof Number) {\n          wrappedArgument.put(\"type\", \"NUMBER\");\n          wrappedArgument.put(\"value\", argument);\n        } else if (argument instanceof ChromeWebElement) {\n          wrappedArgument.put(\"type\", \"ELEMENT\");\n          wrappedArgument.put(\"value\", ((ChromeWebElement)argument).getElementId());\n        } else {\n          throw new IllegalArgumentException(\"Could not wrap up \" +\n                \"javascript parameter \" + argument +\n                \"(class: \" + argument.getClass() + \")\");\n        }\n      } catch (JSONException e) {\n        throw new WebDriverException(e);\n      }\n      return wrappedArgument;\n    }\n","new_comment_raw":"@return wrapped up value TODO(danielwh): See if JSONObject and JSONArray have a useful common superclass","old_comment_raw":"@return wrapped up value","label":1,"pre_label":0,"AST_level":17,"line_counts":32,"new_code_token_num":246},{"new_code_raw":"private IterOutcome produceOutputBatch() { boolean isLeftProcessed = false; \/\/ Try to fully pack the outgoing container while (!isOutgoingBatchFull()) { final int previousOutputCount = outputIndex; \/\/ invoke the runtime generated method to emit records in the output batch for each leftJoinIndex crossJoinAndOutputRecords(); \/\/ We have produced some records in outgoing container, hence there must be a match found for left record if (outputIndex > previousOutputCount) { \/\/ Need this extra flag since there can be left join case where for current leftJoinIndex it receives a right \/\/ batch with data, then an empty batch and again another empty batch with EMIT outcome. If we just use \/\/ outputIndex then we will loose the information that few rows for leftJoinIndex is already produced using \/\/ first right batch matchedRecordFound = true; } \/\/ One right batch might span across multiple output batch. So rightIndex will be moving sum of all the \/\/ output records for this record batch until it's fully consumed. \/\/ \/\/ Also it can be so that one output batch can contain records from 2 different right batch hence the \/\/ rightJoinIndex should move by number of records in output batch for current right batch only. rightJoinIndex += outputIndex - previousOutputCount; final boolean isRightProcessed = rightJoinIndex == -1 || rightJoinIndex >= right.getRecordCount(); \/\/ Check if above join to produce output was based on empty right batch or \/\/ it resulted in right side batch to be fully consumed. In this scenario only if rightUpstream \/\/ is EMIT then increase the leftJoinIndex. \/\/ Otherwise it means for the given right batch there is still some record left to be processed. if (isRightProcessed) { if (rightUpstream == EMIT) { if (!matchedRecordFound && JoinRelType.LEFT == popConfig.getJoinType()) { \/\/ copy left side in case of LEFT join emitLeft(leftJoinIndex, outputIndex, 1); ++outputIndex; } ++leftJoinIndex; \/\/ Reset matchedRecord for next left index record matchedRecordFound = false; } \/\/ Release vectors of right batch. This will happen for both rightUpstream = EMIT\/OK VectorAccessibleUtilities.clear(right); rightJoinIndex = -1; } \/\/ Check if previous left record was last one, then set leftJoinIndex to -1 isLeftProcessed = leftJoinIndex >= left.getRecordCount(); if (isLeftProcessed) { leftJoinIndex = -1; VectorAccessibleUtilities.clear(left); } \/\/ Check if output batch still has some space if (!isOutgoingBatchFull()) { \/\/ Check if left side still has records or not if (isLeftProcessed) { \/\/ The current left batch was with EMIT\/OK_NEW_SCHEMA outcome, then return output to downstream layer before \/\/ getting next batch if (leftUpstream == EMIT || leftUpstream == OK_NEW_SCHEMA) { break; } else { logger.debug(\"Output batch still has some space left, getting new batches from left and right\"); \/\/ Get both left batch and the right batch and make sure indexes are properly set leftUpstream = processLeftBatch(); \/\/ output batch is not empty and we have new left batch with OK_NEW_SCHEMA or terminal outcome if (processLeftBatchInFuture) { logger.debug(\"Received left batch with outcome {} such that we have to return the current outgoing \" + \"batch and process the new batch in subsequent next call\", leftUpstream); \/\/ We should return the current output batch with OK outcome and don't reset the leftUpstream finalizeOutputContainer(); return OK; } \/\/ If left batch received a terminal outcome then don't call right batch if (isTerminalOutcome(leftUpstream)) { finalizeOutputContainer(); return leftUpstream; } \/\/ If we have received the left batch with EMIT outcome and is empty then we should return previous output \/\/ batch with EMIT outcome if ((leftUpstream == EMIT || leftUpstream == OK_NEW_SCHEMA) && left.getRecordCount() == 0) { isLeftProcessed = true; break; } \/\/ Update the batch memory manager to use new left incoming batch updateMemoryManager(LEFT_INDEX); } } \/\/ If we are here it means one of the below: \/\/ 1) Either previous left batch was not fully processed and it came with OK outcome. There is still some space \/\/ left in outgoing batch so let's get next right batch. \/\/ 2) OR previous left & right batch was fully processed and it came with OK outcome. There is space in outgoing \/\/ batch. Now we have got new left batch with OK outcome. Let's get next right batch \/\/ 3) OR previous left & right batch was fully processed and left came with OK outcome. Outgoing batch is \/\/ empty since all right batches were empty for all left rows. Now we got another non-empty left batch with \/\/ OK_NEW_SCHEMA. rightUpstream = processRightBatch(); if (rightUpstream == OK_NEW_SCHEMA) { leftUpstream = (leftUpstream != EMIT) ? OK : leftUpstream; rightUpstream = OK; finalizeOutputContainer(); return OK_NEW_SCHEMA; } if (isTerminalOutcome(rightUpstream)) { finalizeOutputContainer(); return rightUpstream; } \/\/ Update the batch memory manager to use new right incoming batch updateMemoryManager(RIGHT_INDEX); \/\/ If OK_NEW_SCHEMA is seen only on non empty left batch but not on right batch, then we should setup schema in \/\/ output container based on new left schema and old right schema. If schema change failed then return STOP \/\/ downstream if (leftUpstream == OK_NEW_SCHEMA && isLeftProcessed) { if (!handleSchemaChange()) { return STOP; } \/\/ Since schema has change so we have new empty vectors in output container hence allocateMemory for them allocateVectors(); } } } \/\/ output batch is full to its max capacity finalizeOutputContainer(); \/\/ Check if output batch was full and left was fully consumed or not. Since if left is not consumed entirely \/\/ but output batch is full, then if the left batch came with EMIT outcome we should send this output batch along \/\/ with OK outcome not with EMIT. Whereas if output is full and left is also fully consumed then we should send \/\/ EMIT outcome. if (leftUpstream == EMIT && isLeftProcessed) { logger.debug(\"Sending current output batch with EMIT outcome since left is received with EMIT and is fully \" + \"consumed in output batch\"); return EMIT; } if (leftUpstream == OK_NEW_SCHEMA) { \/\/ return output batch with OK_NEW_SCHEMA and reset the state to OK logger.debug(\"Sending current output batch with OK_NEW_SCHEMA and resetting the left outcome to OK for next set\" + \" of batches\"); leftUpstream = OK; return OK_NEW_SCHEMA; } return OK; }","old_code_raw":"  private IterOutcome produceOutputBatch() {\n\n    boolean isLeftProcessed = false;\n\n    \/\/ Try to fully pack the outgoing container\n    while (!isOutgoingBatchFull()) {\n      final int previousOutputCount = outputIndex;\n      \/\/ invoke the runtime generated method to emit records in the output batch for each leftJoinIndex\n      crossJoinAndOutputRecords();\n\n      \/\/ We have produced some records in outgoing container, hence there must be a match found for left record\n      if (outputIndex > previousOutputCount) {\n        \/\/ Need this extra flag since there can be left join case where for current leftJoinIndex it receives a right\n        \/\/ batch with data, then an empty batch and again another empty batch with EMIT outcome. If we just use\n        \/\/ outputIndex then we will loose the information that few rows for leftJoinIndex is already produced using\n        \/\/ first right batch\n        matchedRecordFound = true;\n      }\n\n      \/\/ One right batch might span across multiple output batch. So rightIndex will be moving sum of all the\n      \/\/ output records for this record batch until it's fully consumed.\n      \/\/\n      \/\/ Also it can be so that one output batch can contain records from 2 different right batch hence the\n      \/\/ rightJoinIndex should move by number of records in output batch for current right batch only.\n      rightJoinIndex += outputIndex - previousOutputCount;\n      final boolean isRightProcessed = rightJoinIndex == -1 || rightJoinIndex >= right.getRecordCount();\n\n      \/\/ Check if above join to produce output was based on empty right batch or\n      \/\/ it resulted in right side batch to be fully consumed. In this scenario only if rightUpstream\n      \/\/ is EMIT then increase the leftJoinIndex.\n      \/\/ Otherwise it means for the given right batch there is still some record left to be processed.\n      if (isRightProcessed) {\n        if (rightUpstream == EMIT) {\n          if (!matchedRecordFound && JoinRelType.LEFT == popConfig.getJoinType()) {\n            \/\/ copy left side in case of LEFT join\n            emitLeft(leftJoinIndex, outputIndex, 1);\n            ++outputIndex;\n          }\n          ++leftJoinIndex;\n          \/\/ Reset matchedRecord for next left index record\n          matchedRecordFound = false;\n        }\n\n        \/\/ Release vectors of right batch. This will happen for both rightUpstream = EMIT\/OK\n        VectorAccessibleUtilities.clear(right);\n        rightJoinIndex = -1;\n      }\n\n      \/\/ Check if previous left record was last one, then set leftJoinIndex to -1\n      isLeftProcessed = leftJoinIndex >= left.getRecordCount();\n      if (isLeftProcessed) {\n        leftJoinIndex = -1;\n        VectorAccessibleUtilities.clear(left);\n      }\n\n      \/\/ Check if output batch still has some space\n      if (!isOutgoingBatchFull()) {\n        \/\/ Check if left side still has records or not\n        if (isLeftProcessed) {\n          \/\/ The current left batch was with EMIT\/OK_NEW_SCHEMA outcome, then return output to downstream layer before\n          \/\/ getting next batch\n          if (leftUpstream == EMIT || leftUpstream == OK_NEW_SCHEMA) {\n            break;\n          } else {\n            logger.debug(\"Output batch still has some space left, getting new batches from left and right\");\n            \/\/ Get both left batch and the right batch and make sure indexes are properly set\n            leftUpstream = processLeftBatch();\n\n            if (processLeftBatchInFuture) {\n              logger.debug(\"Received left batch with outcome {} such that we have to return the current outgoing \" +\n                \"batch and process the new batch in subsequent next call\", leftUpstream);\n              \/\/ We should return the current output batch with OK outcome and don't reset the leftUpstream\n              finalizeOutputContainer();\n              return OK;\n            }\n\n            \/\/ If left batch received a terminal outcome then don't call right batch\n            if (isTerminalOutcome(leftUpstream)) {\n              finalizeOutputContainer();\n              return leftUpstream;\n            }\n\n            \/\/ If we have received the left batch with EMIT outcome and is empty then we should return previous output\n            \/\/ batch with EMIT outcome\n            if (leftUpstream == EMIT && left.getRecordCount() == 0) {\n              isLeftProcessed = true;\n              break;\n            }\n\n            \/\/ Update the batch memory manager to use new left incoming batch\n            updateMemoryManager(LEFT_INDEX);\n          }\n        }\n\n        \/\/ If we are here it means one of the below:\n        \/\/ 1) Either previous left batch was not fully processed and it came with OK outcome. There is still some space\n        \/\/ left in outgoing batch so let's get next right batch.\n        \/\/ 2) OR previous left & right batch was fully processed and it came with OK outcome. There is space in outgoing\n        \/\/ batch. Now we have got new left batch with OK outcome. Let's get next right batch\n        \/\/\n        \/\/ It will not hit OK_NEW_SCHEMA since left side have not seen that outcome\n        rightUpstream = processRightBatch();\n        Preconditions.checkState(rightUpstream != OK_NEW_SCHEMA, \"Unexpected schema change in right branch\");\n\n        if (isTerminalOutcome(rightUpstream)) {\n          finalizeOutputContainer();\n          return rightUpstream;\n        }\n\n        \/\/ Update the batch memory manager to use new right incoming batch\n        updateMemoryManager(RIGHT_INDEX);\n      }\n    } \/\/ output batch is full to its max capacity\n\n    finalizeOutputContainer();\n\n    \/\/ Check if output batch was full and left was fully consumed or not. Since if left is not consumed entirely\n    \/\/ but output batch is full, then if the left batch came with EMIT outcome we should send this output batch along\n    \/\/ with OK outcome not with EMIT. Whereas if output is full and left is also fully consumed then we should send\n    \/\/ EMIT outcome.\n    if (leftUpstream == EMIT && isLeftProcessed) {\n      logger.debug(\"Sending current output batch with EMIT outcome since left is received with EMIT and is fully \" +\n        \"consumed in output batch\");\n      return EMIT;\n    }\n\n    if (leftUpstream == OK_NEW_SCHEMA) {\n      \/\/ return output batch with OK_NEW_SCHEMA and reset the state to OK\n      logger.debug(\"Sending current output batch with OK_NEW_SCHEMA and resetting the left outcome to OK for next set\" +\n        \" of batches\");\n      leftUpstream = OK;\n      return OK_NEW_SCHEMA;\n    }\n    return OK;\n  }\n","new_comment_raw":"@return - IterOutcome to be send along with output batch to downstream operator","old_comment_raw":"@return - IterOutcome to be send along with output batch to downstream operator","label":0,"pre_label":1,"AST_level":16,"line_counts":154,"new_code_token_num":1239},{"new_code_raw":"public static AbstractSchema getTemporaryWorkspace(SchemaPlus defaultSchema, DrillConfig config) { String temporarySchema = config.getString(ExecConstants.DEFAULT_TEMPORARY_WORKSPACE); List<String> temporarySchemaPath = Lists.newArrayList(temporarySchema); SchemaPlus schema = findSchema(defaultSchema, temporarySchemaPath); return schema == null ? null : unwrapAsDrillSchemaInstance(schema); }","old_code_raw":"public static AbstractSchema getTemporaryWorkspace(SchemaPlus defaultSchema, DrillConfig config) {\n    List<String> temporarySchemaPath = Lists.newArrayList(config.getString(ExecConstants.DEFAULT_TEMPORARY_WORKSPACE));\n    AbstractSchema temporarySchema = resolveToMutableDrillSchema(defaultSchema, temporarySchemaPath);\n    if (!(temporarySchema instanceof WorkspaceSchemaFactory.WorkspaceSchema)) {\n        DrillRuntimeException.format(STR + STR, temporarySchemaPath);\n    }\n    return temporarySchema;\n}","new_comment_raw":"@return default temporary workspace, null if workspace was not found","old_comment_raw":"@return default temporary workspace","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":51},{"new_code_raw":"public void uploadFile (Long petId, String additionalMetadata, File file) throws TimeoutException, ExecutionException, InterruptedException, ApiException { Object postBody = null; \/\/ verify the required parameter 'petId' is set if (petId == null) { VolleyError error = new VolleyError(\"Missing the required parameter 'petId' when calling uploadFile\", new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFile\")); } \/\/ create path and map variables String path = \"\/pet\/{petId}\/uploadImage\".replaceAll(\"\\\\{format\\\\}\",\"json\").replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiInvoker.escapeString(petId.toString())); \/\/ query params List<Pair> queryParams = new ArrayList<Pair>(); \/\/ header params Map<String, String> headerParams = new HashMap<String, String>(); \/\/ form params Map<String, String> formParams = new HashMap<String, String>(); String[] contentTypes = { \"multipart\/form-data\" }; String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\"; if (contentType.startsWith(\"multipart\/form-data\")) { \/\/ file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); if (additionalMetadata != null) { localVarBuilder.addTextBody(\"additionalMetadata\", ApiInvoker.parameterToString(additionalMetadata), ApiInvoker.TEXT_PLAIN_UTF8); } if (file != null) { localVarBuilder.addBinaryBody(\"file\", file); } HttpEntity httpEntity = localVarBuilder.build(); postBody = httpEntity; } else { \/\/ normal form params formParams.put(\"additionalMetadata\", ApiInvoker.parameterToString(additionalMetadata)); } String[] authNames = new String[] { \"petstore_auth\" }; try { String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames); if (localVarResponse != null) { return ; } else { return ; } } catch (ApiException ex) { throw ex; } catch (InterruptedException ex) { throw ex; } catch (ExecutionException ex) { if (ex.getCause() instanceof VolleyError) { VolleyError volleyError = (VolleyError)ex.getCause(); if (volleyError.networkResponse != null) { throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage()); } } throw ex; } catch (TimeoutException ex) { throw ex; } }","old_code_raw":"  public ApiResponse uploadFile (Long petId, String additionalMetadata, File file) throws TimeoutException, ExecutionException, InterruptedException, ApiException {\n    Object postBody = null;\n    \/\/ verify the required parameter 'petId' is set\n    if (petId == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'petId' when calling uploadFile\",\n        new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFile\"));\n    }\n\n    \/\/ create path and map variables\n    String path = \"\/pet\/{petId}\/uploadImage\".replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiInvoker.escapeString(petId.toString()));\n\n    \/\/ query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    \/\/ header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    \/\/ form params\n    Map<String, String> formParams = new HashMap<String, String>();\n    String[] contentTypes = {\n      \"multipart\/form-data\"\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\";\n\n    if (contentType.startsWith(\"multipart\/form-data\")) {\n      \/\/ file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      if (additionalMetadata != null) {\n        localVarBuilder.addTextBody(\"additionalMetadata\", ApiInvoker.parameterToString(additionalMetadata), ApiInvoker.TEXT_PLAIN_UTF8);\n      }\n      if (file != null) {\n        localVarBuilder.addBinaryBody(\"file\", file);\n      }\n      HttpEntity httpEntity = localVarBuilder.build();\n      postBody = httpEntity;\n    } else {\n      \/\/ normal form params\n      formParams.put(\"additionalMetadata\", ApiInvoker.parameterToString(additionalMetadata));\n    }\n\n    String[] authNames = new String[] { \"petstore_auth\" };\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames);\n      if (localVarResponse != null) {\n         return (ApiResponse) ApiInvoker.deserialize(localVarResponse, \"\", ApiResponse.class);\n      } else {\n         return null;\n      }\n    } catch (ApiException ex) {\n       throw ex;\n    } catch (InterruptedException ex) {\n       throw ex;\n    } catch (ExecutionException ex) {\n      if (ex.getCause() instanceof VolleyError) {\n        VolleyError volleyError = (VolleyError)ex.getCause();\n        if (volleyError.networkResponse != null) {\n          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());\n        }\n      }\n      throw ex;\n    } catch (TimeoutException ex) {\n      throw ex;\n    }\n  }\n","new_comment_raw":"@return void","old_comment_raw":"@return ApiResponse","label":1,"pre_label":0,"AST_level":11,"line_counts":64,"new_code_token_num":468},{"new_code_raw":"public boolean isSelected(final ToolItem toolItem) { boolean selectionState = Display.syncExec(new ResultRunnable<Boolean>() { @Override public Boolean run() { return toolItem.getSelection(); } }); return selectionState; }","old_code_raw":"public boolean isSelected(final ToolItem w) {\n    boolean selectionState = Display.syncExec(new ResultRunnable<Boolean>() {\n\n        @Override\n        public Boolean run() {\n            return w.getSelection();\n        }\n    });\n    return selectionState;\n}","new_comment_raw":"@return true if specified tool item is selected, false otherwise","old_comment_raw":"@return returns widget label text","label":1,"pre_label":0,"AST_level":9,"line_counts":10,"new_code_token_num":42},{"new_code_raw":"public BufferedImage getImage() { if (!isReady()) { return null; } long t1 = 0; long t2 = 0; if (asynchronous) { return updater.getImage(); } else { \/\/ get image t1 = System.currentTimeMillis(); BufferedImage image = new WebcamReadImageTask(driver, device).getImage(); t2 = System.currentTimeMillis(); if (image == null) { return null; } \/\/ calculate FPS \/\/ +1 to avoid division by zero fps = (4 * fps + 1000 \/ (t2 - t1 + 1)) \/ 5; \/\/ notify webcam listeners about new image available updater.notifyWebcamImageObtained(this, image); return image; } }","old_code_raw":"\tpublic BufferedImage getImage() {\n\n\t\tif (!isReady()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (asynchronous) {\n\t\t\treturn updater.getImage();\n\t\t} else {\n\n\t\t\t\/\/ get image\n\n\t\t\tlong time = System.currentTimeMillis();\n\t\t\tBufferedImage image = new WebcamReadImageTask(driver, device).getImage();\n\n\t\t\t\/\/ calculate FPS\n\n\t\t\tfps = (4 * fps + 1000 \/ (double) (System.currentTimeMillis() - time)) \/ 5;\n\n\t\t\t\/\/ notify webcam listeners about new image available\n\n\t\t\tupdater.notifyWebcamImageObtained(this, image);\n\n\t\t\treturn image;\n\t\t}\n\t}\n","new_comment_raw":"@return Captured image or null if webcam is closed or disposed by JVM","old_comment_raw":"@return Captured image or null if webcam is closed or disposed by JVM","label":0,"pre_label":1,"AST_level":12,"line_counts":36,"new_code_token_num":133},{"new_code_raw":"private ZapTextField getTxtProxyChainRealm() { if (txtProxyChainRealm == null) { txtProxyChainRealm = new ZapTextField(); } return txtProxyChainRealm; }","old_code_raw":"\tprivate JTextField getTxtProxyChainRealm() {\n\t\tif (txtProxyChainRealm == null) {\n\t\t\ttxtProxyChainRealm = new JTextField();\n\t\t}\n\t\treturn txtProxyChainRealm;\n\t}\n","new_comment_raw":"@return javax.swing.ZapTextField","old_comment_raw":"@return javax.swing.JTextField","label":1,"pre_label":0,"AST_level":8,"line_counts":7,"new_code_token_num":23},{"new_code_raw":"long getFieldValue(ReadablePeriod period) { PeriodType type; if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) { type = null; \/\/ Don't need to check if supported. } else { type = period.getPeriodType(); } int value; switch (iFieldType) { default: return Long.MAX_VALUE; case 1: if (type != null && type.years().isSupported() == false) { return Long.MAX_VALUE; } value = period.getYears(); break; case 2: if (type != null && type.months().isSupported() == false) { return Long.MAX_VALUE; } value = period.getMonths(); break; case 3: if (type != null && type.weeks().isSupported() == false) { return Long.MAX_VALUE; } value = period.getWeeks(); break; case 4: if (type != null && type.days().isSupported() == false) { return Long.MAX_VALUE; } value = period.getDays(); break; case 5: if (type != null && type.hours().isSupported() == false) { return Long.MAX_VALUE; } value = period.getHours(); break; case 6: if (type != null && type.minutes().isSupported() == false) { return Long.MAX_VALUE; } value = period.getMinutes(); break; case 7: if (type != null && type.seconds().isSupported() == false) { return Long.MAX_VALUE; } value = period.getSeconds(); break; case 8: if (type != null && type.millis().isSupported() == false) { return Long.MAX_VALUE; } value = period.getMillis(); break; case 9: \/\/ drop through case 10: if (type != null && type.seconds().isSupported() == false && type.millis().isSupported() == false) { return Long.MAX_VALUE; } value = period.getSeconds() * DateTimeConstants.MILLIS_PER_SECOND + period.getMillis(); break; } if (value == 0 && iPrintZeroSetting == PRINT_ZERO_RARELY) { return Long.MAX_VALUE; } return value; }","old_code_raw":"        long getFieldValue(ReadablePeriod period) {\n            PeriodType type;\n            if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) {\n                type = null; \/\/ Don't need to check if supported.\n            } else {\n                type = period.getPeriodType();\n            }\n\n            int value;\n\n            switch (iFieldType) {\n            default:\n                return -1;\n            case 1:\n                if (type != null && type.years().isSupported() == false) {\n                    return -1;\n                }\n                value = period.getYears();\n                break;\n            case 2:\n                if (type != null && type.months().isSupported() == false) {\n                    return -1;\n                }\n                value = period.getMonths();\n                break;\n            case 3:\n                if (type != null && type.weeks().isSupported() == false) {\n                    return -1;\n                }\n                value = period.getWeeks();\n                break;\n            case 4:\n                if (type != null && type.days().isSupported() == false) {\n                    return -1;\n                }\n                value = period.getDays();\n                break;\n            case 5:\n                if (type != null && type.hours().isSupported() == false) {\n                    return -1;\n                }\n                value = period.getHours();\n                break;\n            case 6:\n                if (type != null && type.minutes().isSupported() == false) {\n                    return -1;\n                }\n                value = period.getMinutes();\n                break;\n            case 7:\n                if (type != null && type.seconds().isSupported() == false) {\n                    return -1;\n                }\n                value = period.getSeconds();\n                break;\n            case 8:\n                if (type != null && type.millis().isSupported() == false) {\n                    return -1;\n                }\n                value = period.getMillis();\n                break;\n            }\n\n            if (value == 0 && iPrintZeroSetting == PRINT_ZERO_RARELY) {\n                return -1;\n            }\n\n            return value & 0xffffffffL;\n        }\n","new_comment_raw":"@return Long.MAX_VALUE if nothing to print, otherwise value","old_comment_raw":"@return negative value if nothing to print, otherwise lower 32 bits is signed int value.","label":1,"pre_label":0,"AST_level":10,"line_counts":77,"new_code_token_num":395},{"new_code_raw":"public boolean isNull(RexNode expr) { switch (expr.getKind()) { case LITERAL: return ((RexLiteral) expr).getValue2() == null; case LOCAL_REF: RexLocalRef inputRef = (RexLocalRef) expr; return isNull(exprs.get(inputRef.index)); case CAST: return isNull(((RexCall) expr).operands.get(0)); default: return false; } }","old_code_raw":"    public boolean isNull(RexNode expr)\n    {\n        if (RexLiteral.isNullLiteral(expr)) {\n            return true;\n        }\n        if (expr instanceof RexLocalRef) {\n            RexLocalRef inputRef = (RexLocalRef) expr;\n            return isNull(exprs.get(inputRef.index));\n        }\n        if (expr.getKind() == SqlKind.CAST) {\n            return isNull(((RexCall) expr).operands.get(0));\n        }\n        return false;\n    }\n","new_comment_raw":"@return Whether expression always evaluates to null","old_comment_raw":"@return Whether expression always evaluates to null","label":0,"pre_label":1,"AST_level":8,"line_counts":15,"new_code_token_num":78},{"new_code_raw":"public final Image[] getPendingImages() { return pendingImages != null ? Arrays.copyOf(pendingImages, pendingImages.length) : new Image[NUM]; }","old_code_raw":"public final Image[] getPendingImages() {\n    return pendingImages != null ? Arrays.copyOf(pendingImages, pendingImages.length) : null;\n}","new_comment_raw":"@return A image list.","old_comment_raw":"@return A image list or <code>null<\/code>.","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":30},{"new_code_raw":"synchronized public Value put(Transaction tx, Key key, Value value) throws IOException { Value oldValue = null; if (lastGetNodeCache != null) { if(lastGetEntryCache.getKey().equals(key)) { oldValue = lastGetEntryCache.setValue(value); lastGetEntryCache.setValue(value); lastGetNodeCache.storeUpdate(tx); return oldValue; } \/\/ This searches from the last location of a call to get for the element to replace \/\/ all the way to the end of the ListIndex. Iterator<Map.Entry<Key, Value>> iterator = lastGetNodeCache.iterator(tx); while (iterator.hasNext()) { Map.Entry<Key, Value> entry = iterator.next(); if (entry.getKey().equals(key)) { oldValue = entry.setValue(value); ((ListIterator) iterator).getCurrent().storeUpdate(tx); return oldValue; } } } \/\/ Not found because the cache wasn't set or its not at the end of the list so we \/\/ start from the beginning and go to the cached location or the end, then we do \/\/ an add if its not found. Iterator<Map.Entry<Key, Value>> iterator = iterator(tx); while (iterator.hasNext() && ((ListIterator) iterator).getCurrent() != lastGetNodeCache) { Map.Entry<Key, Value> entry = iterator.next(); if (entry.getKey().equals(key)) { oldValue = entry.setValue(value); ((ListIterator) iterator).getCurrent().storeUpdate(tx); return oldValue; } } \/\/ Not found so add it last. return add(tx, key, value); }","old_code_raw":"    synchronized public Value put(Transaction tx, Key key, Value value) throws IOException {\n        return add(tx, key, value);\n    }\n","new_comment_raw":"@return the old value contained in the list if one exists or null.","old_comment_raw":"@return null","label":1,"pre_label":0,"AST_level":12,"line_counts":43,"new_code_token_num":313},{"new_code_raw":"public static RelNode createFilter(RelNode child, RexNode condition) { final RelFactories.FilterFactory factory = RelFactories.DEFAULT_FILTER_FACTORY; return factory.createFilter(child, condition, ImmutableSet.of()); }","old_code_raw":"  public static RelNode createFilter(RelNode child, RexNode condition) {\n    final RelFactories.FilterFactory factory =\n        RelFactories.DEFAULT_FILTER_FACTORY;\n    return factory.createFilter(child, condition);\n  }\n","new_comment_raw":"@return A pair of a relational expression which outer joins a boolean condition column, and a numeric offset. The offset is 2 if column 0 is the number of rows and column 1 is the number of rows with not-null keys; 0 otherwise.","old_comment_raw":"@return A pair of a relational expression which outer joins a boolean condition column, and a numeric offset. The offset is 2 if column 0 is the number of rows and column 1 is the number of rows with not-null keys; 0 otherwise.","label":0,"pre_label":1,"AST_level":5,"line_counts":6,"new_code_token_num":34},{"new_code_raw":"protected CoreLabel fromProto(CoreNLPProtos.Token proto) { CoreLabel word = new CoreLabel(); \/\/ Required fields word.setWord(proto.getWord()); \/\/ Optional fields if (proto.hasPos()) { word.setTag(proto.getPos()); } if (proto.hasValue()) { word.setValue(proto.getValue()); } if (proto.hasCategory()) { word.setCategory(proto.getCategory()); } if (proto.hasBefore()) { word.setBefore(proto.getBefore()); } if (proto.hasAfter()) { word.setAfter(proto.getAfter()); } if (proto.hasOriginalText()) { word.setOriginalText(proto.getOriginalText()); } if (proto.hasNer()) { word.setNER(proto.getNer()); } if (proto.hasLemma()) { word.setLemma(proto.getLemma()); } if (proto.hasBeginChar()) { word.setBeginPosition(proto.getBeginChar()); } if (proto.hasEndChar()) { word.setEndPosition(proto.getEndChar()); } if (proto.hasSpeaker()) { word.set(SpeakerAnnotation.class, proto.getSpeaker()); } if (proto.hasUtterance()) { word.set(UtteranceAnnotation.class, proto.getUtterance()); } if (proto.hasBeginIndex()) { word.set(BeginIndexAnnotation.class, proto.getBeginIndex()); } if (proto.hasEndIndex()) { word.set(EndIndexAnnotation.class, proto.getEndIndex()); } if (proto.hasTokenBeginIndex()) { word.set(TokenBeginAnnotation.class, proto.getTokenBeginIndex()); } if (proto.hasTokenEndIndex()) { word.set(TokenEndAnnotation.class, proto.getTokenEndIndex()); } if (proto.hasNormalizedNER()) { word.set(NormalizedNamedEntityTagAnnotation.class, proto.getNormalizedNER()); } if (proto.hasTimexValue()) { word.set(TimexAnnotation.class, fromProto(proto.getTimexValue())); } if (proto.hasHasXmlContext() && proto.getHasXmlContext()) { word.set(XmlContextAnnotation.class, proto.getXmlContextList()); } if (proto.hasCorefClusterID()) { word.set(CorefClusterIdAnnotation.class, proto.getCorefClusterID()); } if (proto.hasAnswer()) { word.set(AnswerAnnotation.class, proto.getAnswer()); } \/\/ Non-default annotators if (proto.hasGender()) { word.set(GenderAnnotation.class, proto.getGender()); } if (proto.hasTrueCase()) { word.set(TrueCaseAnnotation.class, proto.getTrueCase()); } if (proto.hasTrueCaseText()) { word.set(TrueCaseTextAnnotation.class, proto.getTrueCaseText()); } \/\/ Return return word; }","old_code_raw":"  protected CoreMap fromProto(CoreNLPProtos.Sentence proto) {\n    CoreMap sentence = new ArrayCoreMap();\n    \/\/ Required fields\n    sentence.set(TokenBeginAnnotation.class, proto.getTokenOffsetBegin());\n    sentence.set(TokenEndAnnotation.class, proto.getTokenOffsetEnd());\n    \/\/ Optional fields\n    if (proto.hasSentenceIndex()) { sentence.set(SentenceIndexAnnotation.class, proto.getSentenceIndex()); }\n    if (proto.hasCharacterOffsetBegin()) { sentence.set(CharacterOffsetBeginAnnotation.class, proto.getCharacterOffsetBegin()); }\n    if (proto.hasCharacterOffsetEnd()) { sentence.set(CharacterOffsetEndAnnotation.class, proto.getCharacterOffsetEnd()); }\n    if (proto.hasParseTree()) { sentence.set(TreeAnnotation.class, fromProto(proto.getParseTree())); }\n    \/\/ Non-default fields\n    if (proto.hasHasRelationAnnotations() && proto.getHasRelationAnnotations()) {\n      \/\/ set entities\n      List<EntityMention> entities = new ArrayList<EntityMention>();\n      for (CoreNLPProtos.Entity entity : proto.getEntityList()) { entities.add(fromProto(entity, sentence)); }\n      sentence.set(EntityMentionsAnnotation.class, entities);\n      \/\/ set relations\n      List<RelationMention> relations = new ArrayList<RelationMention>();\n      for (CoreNLPProtos.Relation relation : proto.getRelationList()) { relations.add(fromProto(relation, sentence)); }\n      sentence.set(RelationMentionsAnnotation.class, relations);\n    }\n    \/\/ Return\n    return sentence;\n  }\n","new_comment_raw":"@return A CoreLabel, missing the fields that are not stored in the CoreLabel protobuf.","old_comment_raw":"@return A CoreMap, representing a sentence as stored in the protocol buffer (and therefore missing some fields)","label":1,"pre_label":0,"AST_level":8,"line_counts":34,"new_code_token_num":529},{"new_code_raw":"public GraphQLInputType buildDirectiveInputType(Value value) { if (value instanceof NullValue) { return Scalars.GraphQLString; } if (value instanceof FloatValue) { return Scalars.GraphQLFloat; } if (value instanceof StringValue) { return Scalars.GraphQLString; } if (value instanceof IntValue) { return Scalars.GraphQLInt; } if (value instanceof BooleanValue) { return Scalars.GraphQLBoolean; } return assertShouldNeverHappen(\"Directive values of type '%s' are not supported yet\", value.getClass().getName()); }","old_code_raw":"    public GraphQLInputType buildDirectiveInputType(Value value) {\n        if (value instanceof NullValue) {\n            return Scalars.GraphQLString;\n        }\n        if (value instanceof FloatValue) {\n            return Scalars.GraphQLFloat;\n        }\n        if (value instanceof StringValue) {\n            return Scalars.GraphQLString;\n        }\n        if (value instanceof IntValue) {\n            return Scalars.GraphQLInt;\n        }\n        if (value instanceof BooleanValue) {\n            return Scalars.GraphQLBoolean;\n        }\n        return Assert.assertShouldNeverHappen(\"Directive values of type '%s' are not supported yet\", value.getClass().getName());\n    }\n","new_comment_raw":"@return a graphql input type","old_comment_raw":"@return a graphql input type","label":0,"pre_label":1,"AST_level":6,"line_counts":19,"new_code_token_num":96},{"new_code_raw":"protected Point getPositionInScreen(View view) { if (getParent() == null) { return new Point(); } ViewGroup parent; try { parent = (ViewGroup) view.getParent(); } catch (Exception e) { return new Point(); } if (parent == null) { return new Point(); } Point point = getPositionInScreen(parent); point.offset((int) view.getX(), (int) view.getY()); return point; }","old_code_raw":"protected PointF getPositionInScreen(View view) {\n    if (getParent() == null) {\n        return new PointF();\n    }\n    ViewGroup parent;\n    try {\n        parent = (ViewGroup) view.getParent();\n    } catch (Exception e) {\n        return new PointF();\n    }\n    if (parent == null) {\n        return new PointF();\n    }\n    PointF point = getPositionInScreen(parent);\n    point.offset(view.getX(), view.getY());\n    return point;\n}","new_comment_raw":"@return Point determining position of the passed in view inside all of its ViewParents.","old_comment_raw":"@return PointF determining position of the passed in view inside all of its ViewParents.","label":1,"pre_label":0,"AST_level":7,"line_counts":17,"new_code_token_num":95},{"new_code_raw":"public static <T extends CharSequence> T notEmpty(final T chars, final String message, final Object... values) { if (chars == null) { throw new NullPointerException(String.format(message, values)); } if (chars.length() == NUM) { throw new IllegalArgumentException(String.format(message, values)); } return chars; }","old_code_raw":"public static <T extends Collection<?>> T notEmpty(final T collection, final String message, final Object... values) {\n    if (collection == null) {\n        throw new NullPointerException(String.format(message, values));\n    }\n    if (collection.isEmpty()) {\n        throw new IllegalArgumentException(String.format(message, values));\n    }\n    return collection;\n}","new_comment_raw":"@return the validated character sequence (never {@code null} method for chaining)","old_comment_raw":"@return the validated collection (never {@code null} method for chaining)","label":1,"pre_label":0,"AST_level":8,"line_counts":9,"new_code_token_num":68},{"new_code_raw":"public static String getFullUrl(HttpServletRequest request) { if (request.getQueryString() == null) { return request.getRequestURI(); } return request.getRequestURI() + \"?\" + request.getQueryString(); }","old_code_raw":"    public static String getFullUrl(HttpServletRequest request) {\n        final StringBuilder url = new StringBuilder(100).append(request.getRequestURI());\n        if (request.getQueryString() != null) {\n            url.append('?').append(request.getQueryString());\n        }\n        return url.toString();\n    }\n","new_comment_raw":"@return the full URL, including the query string","old_comment_raw":"@return the full URL, including the query string","label":0,"pre_label":1,"AST_level":6,"line_counts":9,"new_code_token_num":41},{"new_code_raw":"private CollectionPersister getPersister(SharedSessionContractImplementor session) { return getPersister( session.getFactory() ); }","old_code_raw":"\tprivate CollectionPersister getPersister(SharedSessionContractImplementor session) {\n\t\treturn session.getFactory().getMetamodel().collectionPersister( role );\n\t}\n","new_comment_raw":"@return The underlying collection persister","old_comment_raw":"@return The underlying collection persister","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":18},{"new_code_raw":"@JsonIgnore @SuppressWarnings(STR) @Nullable public <T extends Credentials> Credentials getLoginDetails(Class<T> loginDetailsClass) { return Maps.uniqueIndex(this.credentials, new Function<Credentials, Class<Credentials>>() { @Override public Class<Credentials> apply(@Nullable Credentials credentials) { if (credentials != null) { return (Class<Credentials>) credentials.getClass(); } return null; } }).get(loginDetailsClass); }","old_code_raw":"@JsonIgnore\n@SuppressWarnings(STR)\n@Nullable\npublic <T extends LoginDetails> LoginDetails getLoginDetails(Class<T> loginDetailsClass) {\n    return Maps.uniqueIndex(this.loginDetails, new Function<LoginDetails, Class<LoginDetails>>() {\n\n        @Override\n        public Class<LoginDetails> apply(@Nullable LoginDetails loginDetails) {\n            if (loginDetails != null) {\n                return (Class<LoginDetails>) loginDetails.getClass();\n            }\n            return null;\n        }\n    }).get(loginDetailsClass);\n}","new_comment_raw":"@return Credentials instance corresponding to the given Credentials class. Null if no such id found.","old_comment_raw":"@return LoginDetails instance corresponding to the given LoginDetails class. Null if no such id found.","label":1,"pre_label":0,"AST_level":13,"line_counts":15,"new_code_token_num":80},{"new_code_raw":"protected Writer openTestLog() throws Exception { File testClassDir = new File( getTestlogRoot(), ReflectUtil.getUnqualifiedClassName(getClass())); testClassDir.mkdirs(); File testLogFile = new File( testClassDir, testCaseName); return new OutputStreamWriter( openTestLogOutputStream(testLogFile), StandardCharsets.UTF_8); }","old_code_raw":"  protected Writer openTestLog() throws Exception {\n    File testClassDir =\n        new File(\n            getTestlogRoot(),\n            ReflectUtil.getUnqualifiedClassName(getClass()));\n    testClassDir.mkdirs();\n    File testLogFile =\n        new File(\n            testClassDir,\n            testCaseName);\n    return new OutputStreamWriter(openTestLogOutputStream(testLogFile));\n  }\n","new_comment_raw":"@return Writer for log file, which caller should use as a destination for test output to be diffed","old_comment_raw":"@return Writer for log file, which caller should use as a destination for test output to be diffed","label":0,"pre_label":1,"AST_level":7,"line_counts":14,"new_code_token_num":55},{"new_code_raw":"static HintStrategyTable createHintStrategies(HintStrategyTable.Builder builder) { return builder .hintStrategy(\"no_hash_join\", HintPredicates.JOIN) .hintStrategy(\"time_zone\", HintPredicates.SET_VAR) .hintStrategy(\"REPARTITION\", HintPredicates.SET_VAR) .hintStrategy(\"index\", HintPredicates.TABLE_SCAN) .hintStrategy(\"properties\", HintPredicates.TABLE_SCAN) .hintStrategy( \"resource\", HintPredicates.or( HintPredicates.PROJECT, HintPredicates.AGGREGATE, HintPredicates.CALC)) .hintStrategy(\"AGG_STRATEGY\", HintStrategyTable.strategyBuilder(HintPredicates.AGGREGATE) .optionChecker( (hint, errorHandler) -> errorHandler.check( hint.listOptions.size() == 1 && (hint.listOptions.get(0).equalsIgnoreCase(\"ONE_PHASE\") || hint.listOptions.get(0).equalsIgnoreCase(\"TWO_PHASE\")), \"Hint {} only allows single option, \" + \"allowed options: [ONE_PHASE, TWO_PHASE]\", hint.hintName)).build()) .hintStrategy(\"use_hash_join\", HintPredicates.and(HintPredicates.JOIN, joinWithFixedTableName())) .hintStrategy(\"use_merge_join\", HintStrategyTable.strategyBuilder( HintPredicates.and(HintPredicates.JOIN, joinWithFixedTableName())) .excludedRules(EnumerableRules.ENUMERABLE_JOIN_RULE).build()) .build(); }","old_code_raw":"    static HintStrategyTable createHintStrategies(HintStrategyTable.Builder builder) {\n      return builder\n        .hintStrategy(\"no_hash_join\", HintStrategies.JOIN)\n        .hintStrategy(\"time_zone\", HintStrategies.SET_VAR)\n        .hintStrategy(\"REPARTITION\", HintStrategies.SET_VAR)\n        .hintStrategy(\"index\", HintStrategies.TABLE_SCAN)\n        .hintStrategy(\"properties\", HintStrategies.TABLE_SCAN)\n        .hintStrategy(\n            \"resource\", HintStrategies.or(\n            HintStrategies.PROJECT, HintStrategies.AGGREGATE, HintStrategies.CALC))\n        .hintStrategy(\"AGG_STRATEGY\",\n            HintStrategyTable.entryBuilder(HintStrategies.AGGREGATE)\n                .optionChecker(\n                    (hint, errorHandler) -> errorHandler.check(\n                    hint.listOptions.size() == 1\n                        && (hint.listOptions.get(0).equalsIgnoreCase(\"ONE_PHASE\")\n                        || hint.listOptions.get(0).equalsIgnoreCase(\"TWO_PHASE\")),\n                    \"Hint {} only allows single option, \"\n                        + \"allowed options: [ONE_PHASE, TWO_PHASE]\",\n                    hint.hintName)).build())\n        .hintStrategy(\"use_hash_join\",\n          HintStrategies.and(HintStrategies.JOIN, joinWithFixedTableName()))\n        .hintStrategy(\"use_merge_join\",\n            HintStrategyTable.entryBuilder(\n                HintStrategies.and(HintStrategies.JOIN, joinWithFixedTableName()))\n                .excludedRules(EnumerableRules.ENUMERABLE_JOIN_RULE).build())\n        .build();\n    }\n","new_comment_raw":"@return HintStrategyTable instance","old_comment_raw":"@return HintStrategyTable instance","label":0,"pre_label":1,"AST_level":14,"line_counts":29,"new_code_token_num":216},{"new_code_raw":"public List<Pet> findPetsByStatus (List<String> status) throws ApiException { Object localVarPostBody = null; \/\/ create path and map variables String localVarPath = \"\/pet\/findByStatus\".replaceAll(\"\\\\{format\\\\}\",\"json\"); \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); \/\/ header params Map<String, String> localVarHeaderParams = new HashMap<String, String>(); \/\/ form params Map<String, String> localVarFormParams = new HashMap<String, String>(); localVarQueryParams.addAll(ApiInvoker.parameterToPairs(\"multi\", \"status\", status)); String[] localVarContentTypes = { }; String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : \"application\/json\"; if (localVarContentType.startsWith(\"multipart\/form-data\")) { \/\/ file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); localVarPostBody = localVarBuilder.build(); } else { \/\/ normal form params } try { String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType); if(localVarResponse != null){ return (List<Pet>) ApiInvoker.deserialize(localVarResponse, \"array\", Pet.class); } else { return null; } } catch (ApiException ex) { throw ex; } }","old_code_raw":"  public List<Pet>  findPetsByStatus (List<String> status) throws ApiException {\n    Object postBody = null;\n    \n\n    \/\/ create path and map variables\n    String path = \"\/pet\/findByStatus\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    \/\/ query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    \/\/ header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    \/\/ form params\n    Map<String, String> formParams = new HashMap<String, String>();\n\n    \n    queryParams.addAll(ApiInvoker.parameterToPairs(\"multi\", \"status\", status));\n    \n\n    \n\n    String[] contentTypes = {\n      \n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\";\n\n    if (contentType.startsWith(\"multipart\/form-data\")) {\n      \/\/ file uploading\n      MultipartEntityBuilder builder = MultipartEntityBuilder.create();\n      \n\n      HttpEntity httpEntity = builder.build();\n      postBody = httpEntity;\n    } else {\n      \/\/ normal form params\n      \n    }\n\n    try {\n      String response = apiInvoker.invokeAPI(basePath, path, \"GET\", queryParams, postBody, headerParams, formParams, contentType);\n      if(response != null){\n        return (List<Pet>) ApiInvoker.deserialize(response, \"array\", Pet.class);\n      }\n      else {\n        return null;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n","new_comment_raw":"@return List","old_comment_raw":"@return List","label":0,"pre_label":1,"AST_level":10,"line_counts":49,"new_code_token_num":248},{"new_code_raw":"public Vector<QueueItem> getQueue() { return queue; }","old_code_raw":"    public Vector getQueue() {\n        return queue;\n    }\n","new_comment_raw":"@return Returns the queue.","old_comment_raw":"@return Returns the queue.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":11},{"new_code_raw":"public static KeyNamePair[] getKeyNamePairs(String sql, boolean optional) { return getKeyNamePairs(sql, optional, (Object[]) null); }","old_code_raw":"public static KeyNamePair[] getKeyNamePairs(String sql, boolean optional) {\n    PreparedStatement pstmt = null;\n    ResultSet rs = null;\n    ArrayList<KeyNamePair> list = new ArrayList<KeyNamePair>();\n    if (optional)\n        list.add(new KeyNamePair(-NUM, STR));\n    try {\n        pstmt = DB.prepareStatement(sql, null);\n        rs = pstmt.executeQuery();\n        while (rs.next()) list.add(new KeyNamePair(rs.getInt(NUM), rs.getString(NUM)));\n    } catch (Exception e) {\n        log.log(Level.SEVERE, sql, e);\n    } finally {\n        close(rs);\n        close(pstmt);\n        rs = null;\n        pstmt = null;\n    }\n    KeyNamePair[] retValue = new KeyNamePair[list.size()];\n    list.toArray(retValue);\n    return retValue;\n}","new_comment_raw":"@return array of {@link KeyNamePair}","old_comment_raw":"@return array of key name pairs","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":30},{"new_code_raw":"public static By partialLinkText(final String partialLinkText) { return new ByPartialLinkText(partialLinkText); }","old_code_raw":"public static By partialLinkText(final String linkText) {\n    if (linkText == null)\n        throw new IllegalArgumentException(STR);\n    return new ByPartialLinkText(linkText);\n}","new_comment_raw":"@return a By which locates A elements that contain the given link text","old_comment_raw":"@return A By which locates A elements that contain the given text.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":18},{"new_code_raw":"public Order getOrderById(Long orderId) throws ApiException { Object localVarPostBody = null; \/\/ verify the required parameter 'orderId' is set if (orderId == null) { throw new ApiException(400, \"Missing the required parameter 'orderId' when calling getOrderById\"); } \/\/ create path and map variables String localVarPath = \"\/store\/order\/{order_id}\".replaceAll(\"\\\\{format\\\\}\",\"json\") .replaceAll(\"\\\\{\" + \"order_id\" + \"\\\\}\", apiClient.escapeString(orderId.toString())); \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, String> localVarCookieParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { \"application\/xml\", \"application\/json\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Order> localVarReturnType = new GenericType<Order>() {}; return apiClient.invokeAPI(localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public Order getOrderById(Long orderId) throws ApiException {\n    Object localVarPostBody = null;\n    \n    \/\/ verify the required parameter 'orderId' is set\n    if (orderId == null) {\n      throw new ApiException(400, \"Missing the required parameter 'orderId' when calling getOrderById\");\n    }\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/store\/order\/{order_id}\".replaceAll(\"\\\\{format\\\\}\",\"json\")\n      .replaceAll(\"\\\\{\" + \"order_id\" + \"\\\\}\", apiClient.escapeString(orderId.toString()));\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application\/xml\", \"application\/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Order> localVarReturnType = new GenericType<Order>() {};\n    return apiClient.invokeAPI(localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@return a  Order","old_comment_raw":"@return a Order","label":0,"pre_label":1,"AST_level":9,"line_counts":38,"new_code_token_num":264},{"new_code_raw":"public ArrayList<TextView> clickInList(int line, int index) { if(config.commandLogging){ Log.d(config.commandLoggingTag, \"clickInList(\"+line+\", \"+index+\")\"); } return clicker.clickInList(line, index, 0, false, 0); }","old_code_raw":"\tpublic ArrayList<TextView> clickInList(int line, int index) {\n\t\tif(config.commandLogging){\n\t\t\tLog.d(config.commandLoggingTag, \"clickInList(\"+line+\", \"+index+\")\");\n\t\t}\n\t\t\n\t\treturn clicker.clickInList(line, index, false, 0);\n\t}\n","new_comment_raw":"@return an  ArrayList of the  TextView objects located in the list line","old_comment_raw":"@return an ArrayList of the TextView objects located in the list line","label":0,"pre_label":1,"AST_level":11,"line_counts":8,"new_code_token_num":59},{"new_code_raw":"static StringList parseImports(StringDict properties) { StringList outgoing = new StringList(); String importStr = properties.get(IMPORTS_PROPERTY); if (importStr != null) { String[] importList = PApplet.trim(PApplet.split(importStr, ',')); for (String importName : importList) { if (!importName.isEmpty()) { outgoing.append(importName); } } } return (outgoing.size() > 0) ? outgoing : null; }","old_code_raw":"  static List<String> parseImports(String importStr) {\n    List<String> outgoing = new ArrayList<String>();\n\n    if (importStr != null) {\n      String[] importList = PApplet.trim(PApplet.split(importStr, ','));\n      for (String importName : importList) {\n        outgoing.add(importName);\n      }\n    }\n    return (outgoing.size() > 0) ? outgoing : null;\n  }\n","new_comment_raw":"@return null if no entries found","old_comment_raw":"@return the list of imports that this contribution (library) contains.","label":1,"pre_label":0,"AST_level":11,"line_counts":15,"new_code_token_num":88},{"new_code_raw":"protected boolean scanTo(char c) { for (; cursor < length; cursor++) { switch(expr[cursor]) { case STR: case STR: cursor = captureStringLiteral(expr[cursor], expr, cursor, expr.length); default: if (expr[cursor] == c) { return false; } } } return true; }","old_code_raw":"protected boolean scanTo(char c) {\n    for (; cursor < length; cursor++) {\n        if (expr[cursor] == c) {\n            return false;\n        }\n    }\n    return true;\n}","new_comment_raw":"@return - returns true is end of statement is hit, false if the scan scar is countered.","old_comment_raw":"@return true if end of char[] is reached, false is the character is encountered.","label":1,"pre_label":0,"AST_level":12,"line_counts":14,"new_code_token_num":70},{"new_code_raw":"public GraphQLInputType buildDirectiveInputType(Value value) { if (value instanceof NullValue) { return Scalars.GraphQLString; } if (value instanceof FloatValue) { return Scalars.GraphQLFloat; } if (value instanceof StringValue) { return Scalars.GraphQLString; } if (value instanceof IntValue) { return Scalars.GraphQLInt; } if (value instanceof BooleanValue) { return Scalars.GraphQLBoolean; } if (value instanceof ArrayValue) { ArrayValue arrayValue = (ArrayValue) value; return list(buildDirectiveInputType(getArrayValueWrappedType(arrayValue))); } return assertShouldNeverHappen(\"Directive values of type '%s' are not supported yet\", value.getClass().getSimpleName()); }","old_code_raw":"    public GraphQLInputType buildDirectiveInputType(Value value) {\n        if (value instanceof NullValue) {\n            return Scalars.GraphQLString;\n        }\n        if (value instanceof FloatValue) {\n            return Scalars.GraphQLFloat;\n        }\n        if (value instanceof StringValue) {\n            return Scalars.GraphQLString;\n        }\n        if (value instanceof IntValue) {\n            return Scalars.GraphQLInt;\n        }\n        if (value instanceof BooleanValue) {\n            return Scalars.GraphQLBoolean;\n        }\n        if (value instanceof ArrayValue) {\n            ArrayValue arrayValue = (ArrayValue) value;\n            return new GraphQLList(buildDirectiveInputType(getArrayValueWrappedType(arrayValue)));\n        }\n        return assertShouldNeverHappen(\"Directive values of type '%s' are not supported yet\", value.getClass().getSimpleName());\n    }\n","new_comment_raw":"@return a graphql input type","old_comment_raw":"@return a graphql input type","label":0,"pre_label":1,"AST_level":9,"line_counts":23,"new_code_token_num":123},{"new_code_raw":"public int getPort() { return serverPort; }","old_code_raw":"public int getPort() {\n    return port;\n}","new_comment_raw":"@return the server port","old_comment_raw":"@return the port","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":10},{"new_code_raw":"public boolean isHighWaterMark() { return (getDispatchedQueueSize() - prefetchExtension.get()) >= (info.getPrefetchSize() * .9); }","old_code_raw":"    public boolean isHighWaterMark() {\n        return getDispatchedQueueSize() >= (info.getPrefetchSize() * .9);\n    }\n","new_comment_raw":"@return true when 10% or less room is left for dispatching messages","old_comment_raw":"@return true when 10% or less room is left for dispatching messages","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":27},{"new_code_raw":"public static EntityManagerFactory createEntityManagerFactory(String persistenceUnitName, Map properties) { EntityManagerFactory factory = null; Map props = properties; if (props == null) { props = Collections.EMPTY_MAP; } PersistenceProviderResolver resolver = PersistenceProviderResolverHolder.getPersistenceProviderResolver(); List<PersistenceProvider> providers = resolver.getPersistenceProviders(); Object providerName = props.get(PERSISTENCE_PROVIDER_PROPERTY); if ((providerName != null) && (providerName instanceof String)) { boolean isLoaded = false; for (PersistenceProvider provider : providers) { if (provider.getClass().getName().compareTo(providerName.toString()) == NUM) { isLoaded = true; break; } } if (!isLoaded) { factory = createFactory(providerName.toString(), persistenceUnitName, props); if (factory != null) { return factory; } } } if (providers.size() == NUM) { return providers.get(NUM).createEntityManagerFactory(persistenceUnitName, props); } else { for (PersistenceProvider provider : providers) { try { factory = provider.createEntityManagerFactory(persistenceUnitName, props); } catch (Exception e) { } if (factory != null) { return factory; } } } throw new PersistenceException(STR + persistenceUnitName); }","old_code_raw":"public static EntityManagerFactory createEntityManagerFactory(String persistenceUnitName, Map properties) {\n    EntityManagerFactory factory = null;\n    if (properties == null) {\n        properties = Collections.EMPTY_MAP;\n    }\n    Object providerName = properties.get(PERSISTENCE_PROVIDER_PROPERTY);\n    if (providerName instanceof String) {\n        factory = createFactory(providerName.toString(), persistenceUnitName, properties);\n    }\n    if (factory == null) {\n        PersistenceProviderResolver resolver = PersistenceProviderResolverHolder.getPersistenceProviderResolver();\n        List<PersistenceProvider> providers = resolver.getPersistenceProviders();\n        for (PersistenceProvider provider : providers) {\n            try {\n                factory = provider.createEntityManagerFactory(persistenceUnitName, properties);\n            } catch (Exception e) {\n                throw new PersistenceException(STR + providerName, e);\n            }\n            if (factory != null) {\n                break;\n            }\n        }\n    }\n    return factory;\n}","new_comment_raw":"@return The factory for the specified persistence unit or null if none are applicable.","old_comment_raw":"@return The factory that creates EntityManagers configured according to the specified persistence unit.","label":1,"pre_label":0,"AST_level":11,"line_counts":39,"new_code_token_num":215},{"new_code_raw":"public Iterable<String> getNonNullableTransientPropertyPaths(final Object entity) { if ( propertyPathsByTransientEntity == null ) { return Collections.emptyList(); } else { return propertyPathsByTransientEntity.get( entity ); } }","old_code_raw":"\tpublic Iterable<String> getNonNullableTransientPropertyPaths(Object entity) {\n\t\treturn propertyPathsByTransientEntity.get( entity );\n\t}\n","new_comment_raw":"@return The property paths","old_comment_raw":"@return The property paths","label":0,"pre_label":1,"AST_level":7,"line_counts":9,"new_code_token_num":34},{"new_code_raw":"public boolean isTa() { return curEdit_STR_Value.length() > TA_LENGTH || curEdit_STR_Value.indexOf(STR) > NUM; }","old_code_raw":"public boolean isTa() {\n    return curEdit_STR_Value.length() > TA_LENGTH;\n}","new_comment_raw":"@return <code>true<\/code> if the edit-value is longer then <code>TA_LENGTH<\/code> chars or has a line break","old_comment_raw":"@return <code>true<\/code> if the edit-value is longer then <code>TA_LENGTH<\/code> chars","label":1,"pre_label":0,"AST_level":7,"line_counts":3,"new_code_token_num":22},{"new_code_raw":"protected Chronology getChronology() { return iInstant.getChronology(); }","old_code_raw":"public Chronology getChronology() {\n    return iChronology;\n}","new_comment_raw":"@return the chronology","old_comment_raw":"@return the Chronology that the date is using","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":13},{"new_code_raw":"public double getRotY() { return Math.toDegrees(mOrientation.getRotationY()); }","old_code_raw":"public double getRotY() {\n    return mOrientation.getRotationY();\n}","new_comment_raw":"@return double The yaw Euler angle in degrees.","old_comment_raw":"@return double The yaw Euler angle.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":17},{"new_code_raw":"public Double getPercentageOriginalRows(RelNode rel) { for (;;) { try { Double result = percentageOriginalRowsHandler.getPercentageOriginalRows(rel, this); return RelMdUtil.validatePercentage(result); } catch (JaninoRelMetadataProvider.NoHandler e) { percentageOriginalRowsHandler = revise(e.relClass, BuiltInMetadata.PercentageOriginalRows.DEF); } } }","old_code_raw":"  public Double getPercentageOriginalRows(RelNode rel) {\n    for (;;) {\n      try {\n        Double result =\n            percentageOriginalRowsHandler.getPercentageOriginalRows(rel, this);\n        return validatePercentage(result);\n      } catch (JaninoRelMetadataProvider.NoHandler e) {\n        percentageOriginalRowsHandler =\n            revise(e.relClass, BuiltInMetadata.PercentageOriginalRows.DEF);\n      }\n    }\n  }\n","new_comment_raw":"@return estimated percentage (between 0.0 and 1.0), or null if no reliable estimate can be determined","old_comment_raw":"@return estimated percentage (between 0.0 and 1.0), or null if no reliable estimate can be determined","label":0,"pre_label":1,"AST_level":10,"line_counts":13,"new_code_token_num":55},{"new_code_raw":"public boolean isEmpty(){ return size <= 0; }","old_code_raw":"    public boolean isEmpty(){\n        return batchList.isEmpty();\n    }\n","new_comment_raw":"@return true if there are no pending messages","old_comment_raw":"@return true if there are no pending messages","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":11},{"new_code_raw":"@Deprecated public static String getUserAgent() { return instance(); }","old_code_raw":"public static String getUserAgent() {\n    String webUserAgent = null;\n    try {\n        Class<?> sysResCls = Class.forName(STR);\n        Field webUserAgentField = sysResCls.getDeclaredField(STR);\n        Integer resId = (Integer) webUserAgentField.get(null);\n        webUserAgent = NoHttp.getContext().getString(resId);\n    } catch (Exception e) {\n    }\n    if (TextUtils.isEmpty(webUserAgent)) {\n        webUserAgent = STR;\n    }\n    Locale locale = Locale.getDefault();\n    StringBuffer buffer = new StringBuffer();\n    final String version = Build.VERSION.RELEASE;\n    if (version.length() > NUM) {\n        buffer.append(version);\n    } else {\n        buffer.append(STR);\n    }\n    buffer.append(STR);\n    final String language = locale.getLanguage();\n    if (language != null) {\n        buffer.append(language.toLowerCase(locale));\n        final String country = locale.getCountry();\n        if (!TextUtils.isEmpty(country)) {\n            buffer.append(STR);\n            buffer.append(country.toLowerCase(locale));\n        }\n    } else {\n        buffer.append(STR);\n    }\n    if (STR.equals(Build.VERSION.CODENAME)) {\n        final String model = Build.MODEL;\n        if (model.length() > NUM) {\n            buffer.append(STR);\n            buffer.append(model);\n        }\n    }\n    final String id = Build.ID;\n    if (id.length() > NUM) {\n        buffer.append(STR);\n        buffer.append(id);\n    }\n    return String.format(webUserAgent, buffer, STR);\n}","new_comment_raw":"@return String.","old_comment_raw":"@return UA.","label":1,"pre_label":0,"AST_level":4,"line_counts":4,"new_code_token_num":15},{"new_code_raw":"public File getDefaultSketchbookFolder() throws Exception { return new File(System.getProperty(\"user.home\"), \"sketchbook\"); }","old_code_raw":"  public File getDefaultSketchbookFolder() throws Exception {\n    return new File(System.getProperty(\"user.dir\"), \"sketchbook\");\n  }\n","new_comment_raw":"@return if not overridden, a folder named \"sketchbook\" in user.home.","old_comment_raw":"@return if not overridden, a folder named \"sketchbook\" in user.dir.","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":27},{"new_code_raw":"public Object next() throws java.io.IOException { int zzInput; int zzAction; \/\/ cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; \/\/ set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { \/\/ store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); \/\/ get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } \/\/ store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { String str = yytext(); int first = str.charAt(0); String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } LOGGER.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: LOGGER.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 35: break; case 2: { if (normalizeOtherBrackets) { return getNext(openparen, yytext()); } else { return getNext(); } } case 36: break; case 3: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 37: break; case 4: { return getNext(); } case 38: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 39: break; case 6: { if (normalizeOtherBrackets) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 40: break; case 7: { final String origTxt = yytext(); return getNext (asciiQuotes(origTxt), origTxt); } case 41: break; case 8: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 42: break; case 9: { if (invertible) { prevWordAfter.append(yytext()); } } case 43: break; case 10: { return handleEllipsis(yytext()); } case 44: break; case 11: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { String origTxt = yytext(); return getNext(asciiDash(origTxt), origTxt); } } case 45: break; case 12: { return normalizeFractions(yytext()); } case 46: break; case 13: { final String origTxt = yytext(); return getNext(asciiQuotes(origTxt), origTxt); } case 47: break; case 14: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 48: break; case 15: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 49: break; case 16: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 50: break; case 17: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 51: break; case 18: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 52: break; case 19: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return getNext(); } case 53: break; case 20: { final String origTxt = yytext(); return getNext(origTxt, origTxt, CONTR_ANNOTATION); } case 54: break; case 21: { final String origTxt = yytext(); return getNext(origTxt, origTxt, VB_PRON_ANNOTATION); } case 55: break; case 22: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 1; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 2; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 56: break; case 23: { if (!noSGML) { return getNext(); } } case 57: break; case 24: { final String origTxt = yytext(); return getNext(asciiQuotes(asciiDash(origTxt)), origTxt, COMPOUND_ANNOTATION); } case 58: break; case 25: { \/\/ this one should only match if we're basically at the end of file \/\/ since the last one matches two things, even newlines String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 59: break; case 26: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 60: break; case 27: { final String origTxt = yytext(); return getNext(asciiQuotes(asciiDash(origTxt)), origTxt); } case 61: break; case 28: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 62: break; case 29: { return getNormalizedAmpNext(); } case 63: break; case 30: \/\/ lookahead expression with fixed lookahead length yypushback(2); { return getNext(); } case 64: break; case 31: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 65: break; case 32: { yypushback(3) ; return getNext(); } case 66: break; case 33: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } return getNext(txt, yytext()); } case 67: break; case 34: { String txt = yytext(); if (normalizeParentheses) { txt = txt.replaceAll(\"\\\\(\", openparen); txt = txt.replaceAll(\"\\\\)\", closeparen); } return getNext(txt, yytext()); } case 68: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }","old_code_raw":"  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    \/\/ cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      \/\/ set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            \/\/ store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            \/\/ get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      \/\/ store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { String str = yytext();\n          int first = str.charAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n          }\n        case 33: break;\n        case 2: \n          { if (normalizeOtherBrackets) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 34: break;\n        case 3: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '\/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 35: break;\n        case 4: \n          { return getNext();\n          }\n        case 36: break;\n        case 5: \n          { if (tokenizeNLs) {\n                      return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns\n                  } else if (invertible) {\n                      prevWordAfter.append(yytext());\n                  }\n          }\n        case 37: break;\n        case 6: \n          { if (normalizeOtherBrackets) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 38: break;\n        case 7: \n          { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 39: break;\n        case 8: \n          { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n          }\n        case 40: break;\n        case 9: \n          { return handleEllipsis(yytext());\n          }\n        case 41: break;\n        case 10: \n          { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n\t            return getNext(ptbmdash, yytext());\n                  } else {\n\t\t    String origTxt = yytext();\n                    return getNext(asciiDash(origTxt), origTxt);\n\t\t  }\n          }\n        case 42: break;\n        case 11: \n          { return normalizeFractions(yytext());\n          }\n        case 43: break;\n        case 12: \n          { final String origTxt = yytext();\n                          return getNext(asciiQuotes(origTxt), origTxt);\n          }\n        case 44: break;\n        case 13: \n          { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 45: break;\n        case 14: \n          { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 46: break;\n        case 15: \n          { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 47: break;\n        case 16: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 48: break;\n        case 17: \n          { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 49: break;\n        case 18: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext();\n          }\n        case 50: break;\n        case 19: \n          { final String origTxt = yytext();\n\t\t\t  return getNext(origTxt, origTxt, CONTR_ANNOTATION);\n          }\n        case 51: break;\n        case 20: \n          { final String origTxt = yytext();\n                          return getNext(origTxt, origTxt, VB_PRON_ANNOTATION);\n          }\n        case 52: break;\n        case 21: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 1;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 2;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 53: break;\n        case 22: \n          { if (!noSGML) {\n                            return getNext();\n\t\t\t  }\n          }\n        case 54: break;\n        case 23: \n          { final String origTxt = yytext();\n                          return getNext(asciiDash(origTxt), origTxt, COMPOUND_ANNOTATION);\n          }\n        case 55: break;\n        case 24: \n          { \/\/ this one should only match if we're basically at the end of file\n\t\t\t  \/\/ since the last one matches two things, even newlines\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n\t                  return getNext(s, yytext());\n          }\n        case 56: break;\n        case 25: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 5;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 6;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 57: break;\n        case 26: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 58: break;\n        case 27: \n          { return getNormalizedAmpNext();\n          }\n        case 59: break;\n        case 28: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(2);\n          { return getNext();\n          }\n        case 60: break;\n        case 29: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 3;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 4;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n\t                  return getNext(s, yytext());\n          }\n        case 61: break;\n        case 30: \n          { yypushback(3) ; return getNext();\n          }\n        case 62: break;\n        case 31: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 63: break;\n        case 32: \n          { String txt = yytext();\n\t\t\t  if (normalizeParentheses) {\n\t\t\t    txt = txt.replaceAll(\"\\\\(\", openparen);\n\t\t\t    txt = txt.replaceAll(\"\\\\)\", closeparen);\n\t\t\t  }\n\t\t\t  return getNext(txt, yytext());\n          }\n        case 64: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                if (invertible) {\n            prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            prevWordAfter.setLength(0);\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n          }\n          return null;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n","new_comment_raw":"@return the next token","old_comment_raw":"@return the next token","label":0,"pre_label":1,"AST_level":17,"line_counts":431,"new_code_token_num":2315},{"new_code_raw":"public int get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }","old_code_raw":"public int get(WithAttributes attributes) {\n    return attributes.getAttributes().get(this);\n}","new_comment_raw":"@return the value of this attribute if this attribute is present in the extracted map. Otherwise {@link #getDefaultValue()}","old_comment_raw":"@return the value of this attribute if this attribute is present in the map. Otherwise {@link #getDefaultValue()}","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":19},{"new_code_raw":"public final int getLimit() { return remainingCharacters; }","old_code_raw":"public final int getLimit() {\n    return remainingBytes;\n}","new_comment_raw":"@return the remaining characters left to be read from the stream","old_comment_raw":"@return the remaining bytes left to be read from the stream","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":11},{"new_code_raw":"public static boolean canEdit(Permissions perms, Permissions user2Perms) { if (isAdmin(perms)) return true; if (isAdmin(user2Perms)) return false; return getManagementLevel(perms) > getManagementLevel(user2Perms); }","old_code_raw":"public static boolean canEdit(User manager, User toEdit) {\n    if (isAdmin(manager))\n        return true;\n    if (isAdmin(toEdit))\n        return false;\n    return getManagementLevel(manager) > getManagementLevel(toEdit);\n}","new_comment_raw":"@return Whether the user with the first given permissions can modify the user with the second","old_comment_raw":"@return Whether the first user can modify the second","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":43},{"new_code_raw":"private ZapTextArea getTxtPattern() { if (txtPattern == null) { txtPattern = new ZapTextArea(); txtPattern.setLineWrap(true); txtPattern.setFont(new java.awt.Font(\"Courier New\", java.awt.Font.PLAIN, 12)); txtPattern.addMouseListener(new java.awt.event.MouseAdapter() { public void mousePressed(java.awt.event.MouseEvent e) { if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0) { \/\/ right \/\/ mouse \/\/ button view.getPopupMenu().show(e.getComponent(), e.getX(), e.getY()); } } }); } return txtPattern; }","old_code_raw":"    private JTextArea getTxtPattern() {\n        if (txtPattern == null) {\n            txtPattern = new JTextArea();\n            txtPattern.setLineWrap(true);\n            txtPattern.setFont(new java.awt.Font(\"Courier New\",\n                    java.awt.Font.PLAIN, 12));\n            txtPattern.addMouseListener(new java.awt.event.MouseAdapter() {\n                public void mousePressed(java.awt.event.MouseEvent e) {\n                    if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0) { \/\/ right\n                                                                             \/\/ mouse\n                                                                             \/\/ button\n                        view.getPopupMenu().show(e.getComponent(), e.getX(),\n                                e.getY());\n                    }\n                }\n\n            });\n\n        }\n        return txtPattern;\n    }\n","new_comment_raw":"@return javax.swing.ZapTextArea","old_comment_raw":"@return javax.swing.JTextField","label":1,"pre_label":0,"AST_level":14,"line_counts":22,"new_code_token_num":124},{"new_code_raw":"public RepositoryMetadata lookupComponent(Class<?> repositoryClass) { if (repositoriesMetadata.containsKey(repositoryClass)) { return repositoriesMetadata.get(repositoryClass); } throw new RuntimeException(STR + repositoryClass.getName()); }","old_code_raw":"public RepositoryMetadata lookupComponent(Class<?> repoClass) {\n    if (repositoriesMetadata.containsKey(repoClass)) {\n        return repositoriesMetadata.get(repoClass);\n    }\n    throw new RuntimeException(STR + repoClass.getName());\n}","new_comment_raw":"@return A {@link RepositoryMetadata}.","old_comment_raw":"@return A {@link RepositoryMetadataInitializer} corresponding to the repoClass parameter.","label":1,"pre_label":0,"AST_level":7,"line_counts":6,"new_code_token_num":39},{"new_code_raw":"public HttpPanelResponse getResponsePanel() { if (responsePanel == null) { responsePanel = new HttpPanelResponse(false, extension); } return responsePanel; }","old_code_raw":"\tpublic HttpPanel getResponsePanel() {\n\t\tif (responsePanel == null) {\n\t\t\tresponsePanel = new HttpPanel(false);\n\t\t}\n\t\treturn responsePanel;\n\t}\n","new_comment_raw":"@return org.parosproxy.paros.view.HttpPanel","old_comment_raw":"@return org.parosproxy.paros.view.HttpPanel","label":0,"pre_label":1,"AST_level":8,"line_counts":7,"new_code_token_num":26},{"new_code_raw":"public long getDifferenceAsLong(ReadableInstant instant) { if (instant == null) { return getField().getDifferenceAsLong(getReadableInstant().getMillis(), DateTimeUtils.currentTimeMillis()); } return getField().getDifferenceAsLong(getReadableInstant().getMillis(), instant.getMillis()); }","old_code_raw":"    public long getDifferenceAsLong(ReadableInstant instant) {\n        if (instant == null) {\n            throw new IllegalArgumentException(\"The instant must not be null\");\n        }\n        return getField().getDifferenceAsLong(getReadableInstant().getMillis(), instant.getMillis());\n    }\n","new_comment_raw":"@return the difference in the units of this field","old_comment_raw":"@return the difference in the units of this field","label":0,"pre_label":1,"AST_level":9,"line_counts":7,"new_code_token_num":54},{"new_code_raw":"public List<LogRecord> getLogRecords(SessionId sessionId) throws IOException { LogFile logFile = sessionToLogFileMap.get(sessionId); if (logFile == null) { return new ArrayList<>(); } List<LogRecord> logRecords = new ArrayList<>(); try { logFile.openLogReader(); ObjectInputStream logObjInStream = logFile.getLogReader(); LogRecord tmpLogRecord; while (null != (tmpLogRecord = (LogRecord) logObjInStream .readObject())) { logRecords.add(tmpLogRecord); } } catch (IOException | ClassNotFoundException ex) { logFile.closeLogReader(); return logRecords; } logFile.closeLogReader(); return logRecords; }","old_code_raw":"  public List<LogRecord> getLogRecords(SessionId sessionId) throws IOException {\n    LogFile logFile = sessionToLogFileMap.get(sessionId);\n    if (logFile == null) {\n      return new ArrayList<>();\n    }\n\n    List<LogRecord> logRecords = new ArrayList<>();\n    try {\n      logFile.openLogReader();\n      ObjectInputStream logObjInStream = logFile.getLogReader();\n      LogRecord tmpLogRecord;\n      while (null != (tmpLogRecord = (LogRecord) logObjInStream\n          .readObject())) {\n        logRecords.add(tmpLogRecord);\n      }\n    } catch (IOException ex) {\n      logFile.closeLogReader();\n      return logRecords;\n    } catch (ClassNotFoundException e) {\n      logFile.closeLogReader();\n      return logRecords;\n    }\n    logFile.closeLogReader();\n    return logRecords;\n  }\n","new_comment_raw":"@return A List of LogRecord objects, which can be null.","old_comment_raw":"@return A List of LogRecord objects, which can be null.","label":0,"pre_label":1,"AST_level":8,"line_counts":23,"new_code_token_num":107},{"new_code_raw":"public static LdapContext createPathContext(LdapContext authorityContext, String[] pathTokens) throws NamingException { for (int i = NUM; i < (pathTokens.length); i++) { String subContext = CN + STR + pathTokens[i]; authorityContext = (LdapContext) createSubContext(authorityContext, subContext, null); } return authorityContext; }","old_code_raw":"public static LdapContext createPathContext(LdapContext ldapContext, String[] pathTokens) throws NamingException {\n    for (int i = NUM; i < (pathTokens.length); i++) {\n        String subContext = CN + STR + pathTokens[i];\n        ldapContext = (LdapContext) createSubContext(ldapContext, subContext, null);\n    }\n    return ldapContext;\n}","new_comment_raw":"@return the ldap context","old_comment_raw":"@return the dir context","label":1,"pre_label":0,"AST_level":10,"line_counts":7,"new_code_token_num":62},{"new_code_raw":"private boolean isSpillNeeded(int incomingSize) { \/\/ Can't spill if less than two batches else the merge \/\/ can't make progress. if (bufferedBatches.size() < 2) { return false; } \/\/ Must spill if we are below the spill point (the amount of memory \/\/ needed to do the minimal spill.) return allocator.getAllocatedMemory() + incomingSize >= bufferMemoryPool; }","old_code_raw":"  private boolean isSpillNeeded(int incomingSize) {\n\n    \/\/ Can't spill if less than two batches else the merge\n    \/\/ can't make progress.\n\n    if (bufferedBatches.size() < 2) {\n      return false; }\n\n    \/\/ Must spill if we are below the spill point (the amount of memory\n    \/\/ needed to do the minimal spill.)\n\n    if (allocator.getAllocatedMemory() + incomingSize >= bufferMemoryPool) {\n      return true; }\n\n    \/\/ For test purposes, configuration may have set a limit on the number of\n    \/\/ batches in memory. Spill if we exceed this limit. (By default the number\n    \/\/ of in-memory batches is unlimited.)\n\n    return bufferedBatches.size() > bufferedBatchLimit;\n  }\n","new_comment_raw":"@return true if spilling is needed, false otherwise","old_comment_raw":"@return true if spilling is needed, false otherwise","label":0,"pre_label":1,"AST_level":6,"line_counts":14,"new_code_token_num":77},{"new_code_raw":"public static LocalDateTime fromDateFields(Date date) { if (date == null) { throw new IllegalArgumentException(\"The date must not be null\"); } if (date.getTime() < 0) { \/\/ handle years in era BC GregorianCalendar cal = new GregorianCalendar(); cal.setTime(date); return fromCalendarFields(cal); } return new LocalDateTime( date.getYear() + 1900, date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), (((int) (date.getTime() % 1000)) + 1000) % 1000 ); }","old_code_raw":"    public static LocalDateTime fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return new LocalDateTime(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            (((int) (date.getTime() % 1000)) + 1000) % 1000\n        );\n    }\n","new_comment_raw":"@return the created local date-time, not null","old_comment_raw":"@return the created LocalDateTime","label":1,"pre_label":0,"AST_level":9,"line_counts":21,"new_code_token_num":126},{"new_code_raw":"public boolean ownUpdatesAreVisible(int type) { if (type == JDBC20Translation.TYPE_SCROLL_INSENSITIVE) { return true; } else { return false; } }","old_code_raw":"public boolean ownUpdatesAreVisible(int type) {\n    return false;\n}","new_comment_raw":"@return true if updates are visible for the result set type","old_comment_raw":"@return true if changes are visible for the result set type","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":26},{"new_code_raw":"public HBaseResponse getHTableInfo(String tableName) throws IOException { if (htableInfoCache.containsKey(tableName)) { return htableInfoCache.get(tableName); } Configuration hconf = HBaseConnection.getCurrentHBaseConfiguration(); HTable table = null; HBaseResponse hr = null; long tableSize = 0; int regionCount = 0; try { table = new HTable(hconf, tableName); HBaseRegionSizeCalculator cal = new HBaseRegionSizeCalculator(table); Map<byte[], Long> sizeMap = cal.getRegionSizeMap(); for (long s : sizeMap.values()) { tableSize += s; } regionCount = sizeMap.size(); \/\/ Set response. hr = new HBaseResponse(); hr.setTableSize(tableSize); hr.setRegionCount(regionCount); } finally { if (null != table) { table.close(); } } htableInfoCache.put(tableName, hr); return hr; }","old_code_raw":"    public HBaseResponse getHTableInfo(String tableName) throws IOException {\n        Configuration hconf = HadoopUtil.getCurrentHBaseConfiguration();\n        HTable table = null;\n        HBaseResponse hr = null;\n        long tableSize = 0;\n        int regionCount = 0;\n\n        try {\n            table = new HTable(hconf, tableName);\n\n            HBaseRegionSizeCalculator cal = new HBaseRegionSizeCalculator(table);\n            Map<byte[], Long> sizeMap = cal.getRegionSizeMap();\n\n            for (long s : sizeMap.values()) {\n                tableSize += s;\n            }\n\n            regionCount = sizeMap.size();\n\n            \/\/ Set response.\n            hr = new HBaseResponse();\n            hr.setTableSize(tableSize);\n            hr.setRegionCount(regionCount);\n        } finally {\n            if (null != table) {\n                table.close();\n            }\n        }\n\n        return hr;\n    }\n","new_comment_raw":"@return The HBaseResponse object contains table size, region count. null if error happens.","old_comment_raw":"@return The HBaseResponse object contains table size, region count. null if error happens.","label":0,"pre_label":1,"AST_level":8,"line_counts":38,"new_code_token_num":154},{"new_code_raw":"public Client testClientModel(Client body) throws ApiException { Object localVarPostBody = body; \/\/ verify the required parameter 'body' is set if (body == null) { throw new ApiException(400, \"Missing the required parameter 'body' when calling testClientModel\"); } \/\/ create path and map variables String localVarPath = \"\/fake\"; \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { \"application\/json\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { \"application\/json\" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Client> localVarReturnType = new GenericType<Client>() {}; return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public Client testClientModel(Client body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    \/\/ verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling testClientModel\");\n    }\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/fake\";\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application\/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application\/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@return Client","old_comment_raw":"@return Client","label":0,"pre_label":1,"AST_level":8,"line_counts":36,"new_code_token_num":210},{"new_code_raw":"static String getType1Message(final String host, final String domain) { \/\/ For compatibility reason do not include domain and host in type 1 message \/\/return new Type1Message(domain, host).getResponse(); return TYPE_1_MESSAGE; }","old_code_raw":"    String getType1Message(final String host, final String domain) throws AuthenticationException {\n        return new Type1Message(domain, host).getResponse();\n    }\n","new_comment_raw":"@return String the message to add to the HTTP request header.","old_comment_raw":"@return String the message to add to the HTTP request header.","label":0,"pre_label":1,"AST_level":4,"line_counts":6,"new_code_token_num":46},{"new_code_raw":"public int getIndicatorCount() { return 0; }","old_code_raw":"  public int getIndicatorCount() {\n    return indicator ? getGroupCount() : 0;\n  }\n","new_comment_raw":"@return number of indicator fields, always zero","old_comment_raw":"@return number of indicator fields","label":1,"pre_label":0,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"Collection<EBoolean> stringMatchingFilters(EString expr, EString other, String knownValue){ return Arrays.<EBoolean>asList( expr.eq(other), expr.eq(knownValue), expr.ne(other), expr.ne(knownValue), expr.equalsIgnoreCase(other), expr.equalsIgnoreCase(knownValue), expr.lower().eq(other.lower()), expr.upper().eq(other.upper()), expr.lower().eq(knownValue.toLowerCase()), expr.upper().eq(knownValue.toUpperCase()), expr.charAt(0).eq(other.charAt(0)), expr.endsWith(other), expr.endsWith(knownValue), expr.endsWith(knownValue.substring(1)), expr.endsWith(other,false), expr.endsWith(knownValue,false), expr.endsWith(knownValue.substring(1),false), expr.startsWith(other), expr.startsWith(knownValue), expr.startsWith(knownValue.substring(0,1)), expr.startsWith(other,false), expr.startsWith(knownValue,false), expr.startsWith(knownValue.substring(0,1),false), expr.indexOf(knownValue).eq(0), \/\/ expr.lastIndexOf(knownValue).eq(0), expr.contains(other), expr.contains(knownValue), expr.contains(knownValue.substring(0,1)), expr.contains(knownValue.substring(1,2)), other.startsWith(expr), other.endsWith(expr), other.contains(expr), expr.substring(0,1).eq(other.substring(0,1)), expr.substring(1).eq(other.substring(1)), expr.substring(0,1).eq(knownValue.substring(0,1)), expr.substring(1).eq(knownValue.substring(1)), expr.like(knownValue), other.like(knownValue), expr.like(knownValue.substring(0,1)+\"%\"), expr.like(\"%\"+knownValue.substring(1)), expr.like(\"%\"+knownValue.substring(1,2)+\"%\"), expr.matches(knownValue.substring(0,1)+\".*\"), expr.matches(\".*\"+knownValue.substring(1)), expr.matches(\".*\"+knownValue.substring(1,2)+\".*\") ); }","old_code_raw":"    Collection<EBoolean> stringMatchingFilters(EString expr, EString other, String knownValue){\n        return Arrays.<EBoolean>asList(\n            expr.eq(other),\n            expr.eq(knownValue),\n            expr.ne(other),\n            expr.ne(knownValue),\n            expr.equalsIgnoreCase(other),\n            expr.equalsIgnoreCase(knownValue),\n            expr.lower().eq(other.lower()),\n            expr.upper().eq(other.upper()),\n            expr.lower().eq(knownValue.toLowerCase()),\n            expr.charAt(0).eq(other.charAt(0)),\n            expr.endsWith(other),\n            expr.endsWith(knownValue),\n            expr.endsWith(other,false),\n            expr.endsWith(knownValue,false),\n            expr.startsWith(other),\n            expr.startsWith(knownValue),\n            expr.startsWith(other,false),\n            expr.startsWith(knownValue,false),\n            expr.indexOf(knownValue).eq(0),\n\/\/            expr.lastIndexOf(knownValue).eq(0),\n            expr.contains(other),\n            expr.contains(knownValue),\n            expr.contains(knownValue.substring(0,1)),\n            expr.contains(knownValue.substring(1,2)),\n            other.startsWith(expr),\n            other.endsWith(expr),\n            other.contains(expr),\n            expr.substring(0,1).eq(other.substring(0,1)),\n            expr.substring(1).eq(other.substring(1)),\n            expr.substring(0,1).eq(knownValue.substring(0,1)),\n            expr.substring(1).eq(knownValue.substring(1)),\n\/\/            expr.like(knownValue),\n\/\/            other.like(knownValue),\n\/\/            expr.like(knownValue.substring(0,1)+\"%\"),\n\/\/            expr.like(\"%\"+knownValue.substring(1)),\n\/\/            expr.like(\"%\"+knownValue.substring(1,2)+\"%\"),\n            expr.matches(knownValue.substring(0,1)+\".*\"),\n            expr.matches(\".*\"+knownValue.substring(1)),\n            expr.matches(\".*\"+knownValue.substring(1,2)+\".*\")\n        );\n    }\n","new_comment_raw":"@return the collection","old_comment_raw":"@return the collection","label":0,"pre_label":1,"AST_level":9,"line_counts":58,"new_code_token_num":475},{"new_code_raw":"public List<RelDataType> collectOperandTypes() { return new AbstractList<RelDataType>() { public RelDataType get(int index) { return getOperandType(index); } public int size() { return getOperandCount(); } }; }","old_code_raw":"public RelDataType[] collectOperandTypes() {\n    RelDataType[] ret = new RelDataType[getOperandCount()];\n    for (int i = NUM; i < ret.length; i++) {\n        ret[i] = getOperandType(i);\n    }\n    return ret;\n}","new_comment_raw":"@return collected list","old_comment_raw":"@return collected array","label":1,"pre_label":0,"AST_level":8,"line_counts":12,"new_code_token_num":44},{"new_code_raw":"protected long getTimeout(Session session) { return session.getTimeout(); }","old_code_raw":"protected int getTimeout(Session session) {\n    return getGlobalSessionTimeout();\n}","new_comment_raw":"@return the time in milliseconds the specified session may remain idle before expiring.","old_comment_raw":"@return the time in seconds the specified session may remain idle before expiring.","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":15},{"new_code_raw":"public boolean equals(Object obj) { if (this == obj) { return true; } if (obj instanceof GJChronology) { GJChronology chrono = (GJChronology) obj; return iCutoverMillis == chrono.iCutoverMillis && getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() && getZone().equals(chrono.getZone()); } return false; }","old_code_raw":"    public boolean equals(Object obj) {\n        return super.equals(obj);\n    }\n","new_comment_raw":"@return true if equal","old_comment_raw":"@return true if equal","label":0,"pre_label":1,"AST_level":9,"line_counts":13,"new_code_token_num":63},{"new_code_raw":"protected IsolationLevel getTransactionIsolation() { return this.transactionIsolationLevel; }","old_code_raw":"protected TransactionIsolation getTransactionIsolation() {\n    return this.transactionIsolationLevel;\n}","new_comment_raw":"@return the current {@link IsolationLevel} level. If no transaction is active, this may be <code>null<\/code>.","old_comment_raw":"@return the current {@link TransactionIsolation} level. If no transaction is active, this may be <code>null<\/code>.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":11},{"new_code_raw":"public Collection<TypedDependency> typedDependencies() { return typedDependencies(Extras.NONE); }","old_code_raw":"  public Collection<TypedDependency> typedDependencies() {\n    return typedDependencies(false);\n  }\n","new_comment_raw":"@return The typed dependencies of this grammatical structure","old_comment_raw":"@return The typed dependencies of this grammatical structure","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":15},{"new_code_raw":"public WebDriver frame(final String nameOrIdOrIndex) { try { \/\/ 1.) try to find frame in current window ... currentWindow = findFrame(currentWindow, nameOrIdOrIndex); } catch (NoSuchFrameException ignored) { \/\/ 2.) try to find frame in top window ... final WebWindow topWindow = currentWindow.getTopWindow(); currentWindow = findFrame(topWindow, nameOrIdOrIndex); } return HtmlUnitDriver.this; }","old_code_raw":"    public WebDriver frame(final String name) {\n      WebWindow window = currentWindow.getTopWindow();\n\n      \/\/ Walk over all parts of the frame identifier, each time looking for a frame\n      \/\/ with a name or ID matching this part of the identifier (separated by '.').\n      String[] frames = name.split(\"\\\\.\");\n      for (int i = 0; i < frames.length; ++i) {\n        final String currentFrameId = frames[i];\n        final HtmlPage page = (HtmlPage) window.getEnclosedPage();\n        \n        if (isNumericFrameIdValid(currentFrameId, page)) {\n          window = getWindowByNumericFrameId(currentFrameId, page);\n        } else {\n          \/\/ Numeric frame ID is not valid - could be either because the identifier\n          \/\/ was numeric and not valid OR the number that was given is actually a frame\n          \/\/ name, not an index.\n          \n          boolean nextFrameFound = false;\n          for (final FrameWindow frameWindow : page.getFrames()) {\n            final String frameName = frameWindow.getName();\n            final String frameId = frameWindow.getFrameElement().getId();\n            final String remainingFrameId = joinFrom(frames, i, '.');\n            if (frameName.equals(remainingFrameId) || frameId.equals(remainingFrameId)) {\n              currentWindow = frameWindow;\n              return HtmlUnitDriver.this;\n            }\n            if (frameName.equals(currentFrameId) || frameId.equals(currentFrameId)) {\n              window = frameWindow;\n              nextFrameFound = true;\n            }\n          } \/\/ End for.\n          \n          if (!nextFrameFound) {\n            throw new NoSuchFrameException(\"Cannot find frame: \" + name);\n          }\n        } \/\/ End else\n\n      } \/\/ End for\n      \n      currentWindow = window;\n      return HtmlUnitDriver.this;\n    }\n","new_comment_raw":"@return This instance.","old_comment_raw":"@returns This instance.","label":1,"pre_label":0,"AST_level":8,"line_counts":12,"new_code_token_num":70},{"new_code_raw":"public Map getFields() { return m_fields; }","old_code_raw":"public HashMap getFields() {\n    return m_fields;\n}","new_comment_raw":"@return the field map [field_name, type].","old_comment_raw":"@return the field hashmap [field_name, type].","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":10},{"new_code_raw":"public static String formatArrayKey(String key) { if (isArrayKey(key)) { key = StringUtil.addSuffix(key.substring(NUM, key.length() - NUM), STR); } int index = key == null ? -NUM : key.indexOf(STR); if (index >= NUM) { return key.substring(index + NUM); } return formatKey(key, false, true, true, true); }","old_code_raw":"public static String formatArrayKey(String key) {\n    if (isArrayKey(key)) {\n        key = StringUtil.addSuffix(key.substring(NUM, key.length() - NUM), STR);\n    }\n    int index = key == null ? -NUM : key.indexOf(STR);\n    if (index >= NUM) {\n        return key.substring(index + NUM);\n    }\n    return formatKey(key, false, false, true, true);\n}","new_comment_raw":"@return {@link #formatKey(String, boolean, boolean, boolean)} formatColon = false, formatAt = true, formatHyphen = true, firstCase = true","old_comment_raw":"@return {@link #formatKey(String, boolean, boolean, boolean)} formatColon = false, formatAt = false, formatHyphen = true, firstCase = true","label":1,"pre_label":0,"AST_level":10,"line_counts":10,"new_code_token_num":83},{"new_code_raw":"public boolean parseRepositoryXml() throws MojoExecutionException { File fout = new File(m_repositoryXml); if (!fout.exists()) { Document doc = m_documentBuilder.newDocument(); Date d = new Date(); d.setTime(System.currentTimeMillis()); Element root = doc.createElement(STR); root.setAttribute(STR, m_format.format(d)); root.setAttribute(STR, STR); try { writeToFile(m_repositoryXml, root); } catch (MojoExecutionException e) { e.printStackTrace(); throw new MojoExecutionException(STR); } } m_repositoryDoc = parseFile(m_repositoryXml, m_documentBuilder); return (null != m_repositoryDoc); }","old_code_raw":"private int parseRepositoryXml() throws MojoExecutionException {\n    File fout = new File(m_repositoryXml);\n    if (!fout.exists()) {\n        Document doc = m_documentBuilder.newDocument();\n        Date d = new Date();\n        d.setTime(System.currentTimeMillis());\n        Element root = doc.createElement(STR);\n        root.setAttribute(STR, m_format.format(d));\n        root.setAttribute(STR, STR);\n        try {\n            writeToFile(m_repositoryXml, root);\n        } catch (MojoExecutionException e) {\n            e.printStackTrace();\n            throw new MojoExecutionException(STR);\n        }\n    }\n    m_repositoryDoc = parseFile(m_repositoryXml, m_documentBuilder);\n    if (m_repositoryDoc == null) {\n        return -NUM;\n    }\n    return NUM;\n}","new_comment_raw":"@return true if the repository file was parsed, otherwise false","old_comment_raw":"@return 0 if the bundle is already in the descriptor, else -1","label":1,"pre_label":0,"AST_level":9,"line_counts":19,"new_code_token_num":122},{"new_code_raw":"private Point computePopupLocation(int snapPosition) { if (fPopup == null || fPopup.isDisposed()) return null; switch(snapPosition) { case SNAP_POSITION_LOWER_RIGHT: { StyledText eWidget = fEditor.getViewer().getTextWidget(); Rectangle eBounds = eWidget.getClientArea(); Point eLowerRight = eWidget.toDisplay(eBounds.x + eBounds.width, eBounds.y + eBounds.height); Point pSize = getExtent(); return new Point(eLowerRight.x - pSize.x - NUM, eLowerRight.y - pSize.y - NUM); } case SNAP_POSITION_UNDER_RIGHT_FIELD: case SNAP_POSITION_OVER_RIGHT_FIELD: { LinkedPosition position = fRenameLinkedMode.getCurrentLinkedPosition(); if (position == null) return null; ISourceViewer viewer = fEditor.getViewer(); ITextViewerExtension5 viewer5 = (ITextViewerExtension5) viewer; int widgetOffset = viewer5.modelOffset2WidgetOffset(position.offset + position.length); StyledText textWidget = viewer.getTextWidget(); Point pos = textWidget.getLocationAtOffset(widgetOffset); Point pSize = getExtent(); if (snapPosition == SNAP_POSITION_OVER_RIGHT_FIELD) { pos.y -= pSize.y + GAP; } else { pos.y += textWidget.getLineHeight(widgetOffset) + GAP; } pos.x += GAP; Point dPos = textWidget.toDisplay(pos); Rectangle displayBounds = textWidget.getDisplay().getClientArea(); Rectangle dPopupRect = Geometry.createRectangle(dPos, pSize); Geometry.moveInside(dPopupRect, displayBounds); return new Point(dPopupRect.x, dPopupRect.y); } case SNAP_POSITION_UNDER_LEFT_FIELD: case SNAP_POSITION_OVER_LEFT_FIELD: default: { LinkedPosition position = fRenameLinkedMode.getCurrentLinkedPosition(); if (position == null) return null; ISourceViewer viewer = fEditor.getViewer(); ITextViewerExtension5 viewer5 = (ITextViewerExtension5) viewer; int widgetOffset = viewer5.modelOffset2WidgetOffset(position.offset); StyledText textWidget = viewer.getTextWidget(); Point pos = textWidget.getLocationAtOffset(widgetOffset); Point pSize = getExtent(); pSize.y += HAH + NUM; pos.x -= HAO; if (snapPosition == SNAP_POSITION_OVER_LEFT_FIELD) { pos.y -= pSize.y; } else { pos.y += textWidget.getLineHeight(widgetOffset); } Point dPos = textWidget.toDisplay(pos); Rectangle displayBounds = textWidget.getDisplay().getClientArea(); Rectangle dPopupRect = Geometry.createRectangle(dPos, pSize); Geometry.moveInside(dPopupRect, displayBounds); return new Point(dPopupRect.x, dPopupRect.y); } } }","old_code_raw":"private Point computePopupLocation(int snapPosition, boolean editorBoundsChanged) {\n    if (fPopup == null || fPopup.isDisposed())\n        return null;\n    switch(snapPosition) {\n        case SNAP_POSITION_LOWER_RIGHT:\n            if (!editorBoundsChanged) {\n                return null;\n            } else {\n                StyledText eWidget = fEditor.getViewer().getTextWidget();\n                Rectangle eBounds = eWidget.getClientArea();\n                Point eLowerRight = eWidget.toDisplay(eBounds.x + eBounds.width, eBounds.y + eBounds.height);\n                Point pSize = fPopup.getSize();\n                return new Point(eLowerRight.x - pSize.x - NUM, eLowerRight.y - pSize.y - NUM);\n            }\n        case SNAP_POSITION_UNDER_RIGHT_FIELD:\n        case SNAP_POSITION_OVER_RIGHT_FIELD:\n            {\n                LinkedPosition position = fRenameLinkedMode.getCurrentLinkedPosition();\n                if (position == null)\n                    return null;\n                ISourceViewer viewer = fEditor.getViewer();\n                ITextViewerExtension5 viewer5 = (ITextViewerExtension5) viewer;\n                int widgetOffset = viewer5.modelOffset2WidgetOffset(position.offset + position.length);\n                StyledText textWidget = viewer.getTextWidget();\n                Point pos = textWidget.getLocationAtOffset(widgetOffset);\n                Point pSize = fPopup.getSize();\n                if (snapPosition == SNAP_POSITION_OVER_RIGHT_FIELD) {\n                    pos.y -= pSize.y;\n                } else {\n                    pos.y += textWidget.getLineHeight(widgetOffset);\n                }\n                pos.x += NUM;\n                Point dPos = textWidget.toDisplay(pos);\n                Rectangle displayBounds = textWidget.getDisplay().getClientArea();\n                Rectangle dPopupRect = Geometry.createRectangle(dPos, pSize);\n                Geometry.moveInside(dPopupRect, displayBounds);\n                return new Point(dPopupRect.x, dPopupRect.y);\n            }\n        case SNAP_POSITION_UNDER_LEFT_FIELD:\n        case SNAP_POSITION_OVER_LEFT_FIELD:\n        default:\n            {\n                LinkedPosition position = fRenameLinkedMode.getCurrentLinkedPosition();\n                if (position == null)\n                    return null;\n                ISourceViewer viewer = fEditor.getViewer();\n                ITextViewerExtension5 viewer5 = (ITextViewerExtension5) viewer;\n                int widgetOffset = viewer5.modelOffset2WidgetOffset(position.offset);\n                StyledText textWidget = viewer.getTextWidget();\n                Point pos = textWidget.getLocationAtOffset(widgetOffset);\n                Point pSize = fPopup.getSize();\n                if (snapPosition == SNAP_POSITION_OVER_LEFT_FIELD) {\n                    pos.y -= pSize.y;\n                } else {\n                    pos.y += textWidget.getLineHeight(widgetOffset);\n                }\n                Point dPos = textWidget.toDisplay(pos);\n                Rectangle displayBounds = textWidget.getDisplay().getClientArea();\n                Rectangle dPopupRect = Geometry.createRectangle(dPos, pSize);\n                Geometry.moveInside(dPopupRect, displayBounds);\n                return new Point(dPopupRect.x, dPopupRect.y);\n            }\n    }\n}","new_comment_raw":"@return the location in display coordinates or <code>null<\/code> iff not visible","old_comment_raw":"@returns the location in display coordinates or <code>null<\/code> iff unchanged","label":1,"pre_label":0,"AST_level":12,"line_counts":64,"new_code_token_num":400},{"new_code_raw":"public Client testClassname(Client client) throws ApiException { return testClassnameWithHttpInfo(client).getData(); }","old_code_raw":"  public Client testClassname(Client body) throws ApiException {\n    return testClassnameWithHttpInfo(body).getData();\n      }\n","new_comment_raw":"@return Client","old_comment_raw":"@return Client","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"public Client testSpecialTags(Client body) throws ApiException { return testSpecialTagsWithHttpInfo(body).getData(); }","old_code_raw":"  public Client testSpecialTags(Client body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    \/\/ verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling testSpecialTags\");\n    }\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/another-fake\/dummy\";\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application\/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application\/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@return Client","old_comment_raw":"@return Client","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"private ComponentAdapter prepDEF_lifecycleManagerSupport(MutablePicoContainer picoContainer) { picoContainer.addComponent(RecordingLifecycle.One.class); PoolingComponentAdapter poolingComponentAdapter = new PoolingComponentAdapter(new ConstructorInjectionComponentAdapter(RecordingLifecycle.Recorder.class, RecordingLifecycle.Two.class)); return picoContainer.addAdapter(poolingComponentAdapter).lastCA(); }","old_code_raw":"private ComponentAdapter prepDEF_lifecycleManagerSupport(MutablePicoContainer picoContainer) {\n    picoContainer.component(RecordingLifecycle.One.class);\n    PoolingComponentAdapter poolingComponentAdapter = new PoolingComponentAdapter(new ConstructorInjectionComponentAdapter(RecordingLifecycle.Recorder.class, RecordingLifecycle.Two.class));\n    return picoContainer.adapter(poolingComponentAdapter).lastCA();\n}","new_comment_raw":"@return the addAdapter to test","old_comment_raw":"@return the adapter to test","label":1,"pre_label":0,"AST_level":8,"line_counts":5,"new_code_token_num":45},{"new_code_raw":"public Object next() throws java.io.IOException { int zzInput; int zzAction; \/\/ cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; \/\/ set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { \/\/ store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); \/\/ get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } \/\/ store back cached position zzMarkedPos = zzMarkedPosL; if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { \/\/ prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); \/\/ System.err.println(\"At end of text making after: |\" + str + \"|\"); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); \/\/ System.err.println(\"prevWord is |\" + prevWord.get(CoreAnnotations.TextAnnotation.class) + \"|, its after is |\" + \/\/ prevWord.get(CoreAnnotations.AfterAnnotation.class) + \"|\"); prevWordAfter.setLength(0); } return null; } } else { switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { String str = yytext(); int first = str.codePointAt(0); String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } logger.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: logger.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 67: break; case 2: { return getNext(\"<\", yytext()); } case 68: break; case 3: { return getNext(); } case 69: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 70: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns } else if (invertible) { \/\/ System.err.println(\"Appending newline: |\" + yytext() + \"|\"); prevWordAfter.append(yytext()); } } case 71: break; case 6: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 72: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 73: break; case 8: { return handleQuotes(yytext(), false); } case 74: break; case 9: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 75: break; case 10: { return getNext(\">\", yytext()); } case 76: break; case 11: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 77: break; case 12: { handleHyphenatedNumber(yytext()); return getNext(removeFromNumber(yytext()), yytext()); } case 78: break; case 13: { return handleEllipsis(yytext()); } case 79: break; case 14: { return normalizeFractions(yytext()); } case 80: break; case 15: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(minimallyNormalizeCurrency(yytext()), yytext()); } } case 81: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 82: break; case 17: { if (normalizeOtherBrackets) { return getNext(\"-RSB-\", yytext()); } else { return getNext(); } } case 83: break; case 18: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 84: break; case 19: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 85: break; case 20: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 86: break; case 21: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 87: break; case 22: { if (normalizeOtherBrackets) { return getNext(\"-LSB-\", yytext()); } else { return getNext(); } } case 88: break; case 23: { if (invertible) { prevWordAfter.append(yytext()); } } case 89: break; case 24: { return getNext(\"\\u2022\", yytext()); } case 90: break; case 25: { return getNext(\"\\u2122\", yytext()); } case 91: break; case 26: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 92: break; case 27: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(); } case 93: break; case 28: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return handleQuotes(yytext(), true); } case 94: break; case 29: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 95: break; case 30: { breakByHyphens(yytext()); return getNext(removeSoftHyphens(yytext()), yytext()); } case 96: break; case 31: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 97: break; case 32: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 98: break; case 33: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 99: break; case 34: { \/\/ this one should only match if we're basically at the end of file \/\/ since the last one matches two things, even newlines (if not tokenize per line) String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 100: break; case 35: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 101: break; case 36: \/\/ lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 1); { \/* invert quote - often but not always right *\/ return handleQuotes(yytext(), true); } case 102: break; case 37: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return handleQuotes(yytext(), false); } case 103: break; case 38: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 104: break; case 39: { String txt = yytext(); \/\/ if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space... if (strictTreebank3) { int spaceIndex = indexOfSpace(txt); if (spaceIndex >= 0) { yypushback(txt.length() - spaceIndex); return getNext(); } } if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, yytext()); } case 105: break; case 40: { return getNormalizedAmpNext(); } case 106: break; case 41: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, origTxt); } case 107: break; case 42: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space } return getNext(txt, origTxt); } case 108: break; case 43: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 109: break; case 44: { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 110: break; case 45: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 17; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 111: break; case 46: \/\/ lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 112: break; case 47: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 113: break; case 48: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 22; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 114: break; case 49: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 18; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 19; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 115: break; case 50: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 116: break; case 51: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 21; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 117: break; case 52: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 118: break; case 53: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { breakByHyphens(yytext()); return getNext(removeSoftHyphens(yytext()), yytext()); } case 119: break; case 54: { if (splitAssimilations) { yypushback(3) ; return getNext(); } else { return getNext(); } } case 120: break; case 55: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNormalizedAmpNext(); } case 121: break; case 56: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 9; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 122: break; case 57: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { return getNext(); } case 123: break; case 58: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 124: break; case 59: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 125: break; case 60: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 13; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 126: break; case 61: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } return getNext(txt, yytext()); } case 127: break; case 62: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4); { return getNext(); } case 128: break; case 63: \/\/ lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { return getNext(); } case 129: break; case 64: { String txt = yytext(); if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 130: break; case 65: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 25; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 131: break; case 66: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 24; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 132: break; default: zzScanError(ZZ_NO_MATCH); } } } }","old_code_raw":"  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    \/\/ cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      \/\/ set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            \/\/ store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            \/\/ get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      \/\/ store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n        zzAtEOF = true;\n              {\n                if (invertible) {\n            \/\/ prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            \/\/ System.err.println(\"At end of text making after: |\" + str + \"|\");\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n            \/\/ System.err.println(\"prevWord is |\" + prevWord.get(CoreAnnotations.TextAnnotation.class) + \"|, its after is |\" +\n            \/\/         prevWord.get(CoreAnnotations.AfterAnnotation.class) + \"|\");\n            prevWordAfter.setLength(0);\n          }\n          return null;\n              }\n      }\n      else {\n        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n          case 1: \n            { String str = yytext();\n          int first = str.codePointAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\",\n                          yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n            }\n          case 74: break;\n          case 2: \n            { return getNext(\"<\", yytext());\n            }\n          case 75: break;\n          case 3: \n            { return getNext();\n            }\n          case 76: break;\n          case 4: \n            { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n            }\n          case 77: break;\n          case 5: \n            { if (tokenizeNLs) {\n                      return getNext(AbstractTokenizer.NEWLINE_TOKEN, yytext()); \/\/ for tokenizing newliens\n                  } else if (invertible) {\n                    \/\/ System.err.println(\"Appending newline: |\" + yytext() + \"|\");\n                    prevWordAfter.append(yytext());\n                  }\n            }\n          case 78: break;\n          case 6: \n            { final String origTxt = yytext();\n                          String tok = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tok = Americanize.americanize(tok);\n                          }\n                          if (DEBUG) { logger.info(\"Used {WORD} (2) to recognize \" + origTxt + \" as \" + tok +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(tok, origTxt);\n            }\n          case 79: break;\n          case 7: \n            { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n            }\n          case 80: break;\n          case 8: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} (3) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 81: break;\n          case 9: \n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 82: break;\n          case 10: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '\/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 83: break;\n          case 11: \n            { return getNext(\">\", yytext());\n            }\n          case 84: break;\n          case 12: \n            { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n            }\n          case 85: break;\n          case 13: \n            { handleHyphenatedNumber(yytext());\n                          if (DEBUG) { logger.info(\"Used {NUMBER} to recognize \" + yytext() + \" as \" + removeFromNumber(yytext())); }\n                          return getNext(removeFromNumber(yytext()), yytext());\n            }\n          case 86: break;\n          case 14: \n            { return handleEllipsis(yytext());\n            }\n          case 87: break;\n          case 15: \n            { \/\/ breakByHyphens(yytext()); \/\/ this is causing fail of attempted to pushback too much!\n                  String tok = yytext();\n                  \/* A THING can contain quote like O'Malley *\/\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {THING} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 88: break;\n          case 16: \n            { String txt = yytext();\n                  String norm = normalizeFractions(yytext());\n                  if (DEBUG) { logger.info(\"Used {FRAC2} to recognize \" + txt + \" as \" + norm +\n                                       \"; normalizeFractions=\" + normalizeFractions +\n                                       \", escapeForwardSlashAsterisk=\" + escapeForwardSlashAsterisk); }\n                  return getNext(norm, txt);\n            }\n          case 89: break;\n          case 17: \n            { if (normalizeCurrency) {\n                            return getNext(normalizeCurrency(yytext()), yytext());\n                        } else {\n                            return getNext(minimallyNormalizeCurrency(yytext()), yytext());\n                          }\n            }\n          case 90: break;\n          case 18: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-RSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 91: break;\n          case 19: \n            { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 92: break;\n          case 20: \n            { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 93: break;\n          case 21: \n            { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 94: break;\n          case 22: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 95: break;\n          case 23: \n            { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 96: break;\n          case 24: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-LSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 97: break;\n          case 25: \n            { String tok = yytext();\n                        String norm = processCp1252misc(tok);\n                        if (DEBUG) { logger.info(\"Used {CP1252_MISC_SYMBOL} to recognize \" + tok + \" as \" + norm); }\n                        return getNext(norm, tok);\n            }\n          case 98: break;\n          case 26: \n            { if (invertible) {\n                            prevWordAfter.append(yytext());\n                        }\n            }\n          case 99: break;\n          case 27: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 15;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 100: break;\n          case 28: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext();\n            }\n          case 101: break;\n          case 29: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {REDAUX} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 102: break;\n          case 30: \n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {APOWORD} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 103: break;\n          case 31: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                                   String norm = handleQuotes(tok, true);\n                                   if (DEBUG) { logger.info(\"Used {DBLQUOT} to recognize \" + tok + \" as \" + norm +\n                                                            \"; probablyLeft=\" + true); }\n                                   return getNext(norm, tok);\n            }\n          case 104: break;\n          case 32: \n            { String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {PROG_LANGS} to recognize \" + tok + \" as \" + tok); }\n                    return getNext(tok, tok);\n            }\n          case 105: break;\n          case 33: \n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 106: break;\n          case 34: \n            { breakByHyphens(yytext());\n                  if (DEBUG) { logger.info(\"Used {HTHING} to recognize \" + yytext() + \" as \" + removeSoftHyphens(yytext())); }\n                  return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 107: break;\n          case 35: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 3;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 4;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String origTxt = yytext();\n                          String tok = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tok = Americanize.americanize(tok);\n                          }\n                          if (DEBUG) { logger.info(\"Used {WORD} to recognize \" + origTxt + \" as \" + tok +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(tok, origTxt);\n            }\n          case 108: break;\n          case 36: \n            { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '\/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 109: break;\n          case 37: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 110: break;\n          case 38: \n            { \/\/ this one should only match if we're basically at the end of file\n                          \/\/ since the last one matches two things, even newlines (if not tokenize per line)\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n                          return getNext(s, yytext());\n            }\n          case 111: break;\n          case 39: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 112: break;\n          case 40: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { \/\/ Extra context is to not match on ones like 'd but you do want words like \"a\"\n                  \/\/ can't have digit here because of cases like '90s\n                  String tok = yytext();\n                  \/* invert single quote - often but not always right *\/\n                  String norm = handleQuotes(tok, true);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + true); }\n                  return getNext(norm, tok);\n            }\n          case 113: break;\n          case 41: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {REDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 114: break;\n          case 42: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { \/\/ Extra context is to not match on ones like 'd but you do want words like \"a\"\n                  \/\/ can't have digit here because of cases like '90s\n                  String tok = yytext();\n                  \/* invert single quote - often but not always right *\/\n                  String norm = handleQuotes(tok, true);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + true); }\n                  return getNext(norm, tok);\n            }\n          case 115: break;\n          case 43: \n            { return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 116: break;\n          case 44: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {SREDAUX} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 117: break;\n          case 45: \n            { if (splitAssimilations) {\n                      yypushback(2);\n                    }\n                    String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {ASSIMILATIONS3} to recognize \" + tok + \" as \" + tok +\n                            \"; splitAssimilations=\" + splitAssimilations); }\n                    return getNext(tok, tok);\n            }\n          case 118: break;\n          case 46: \n            { String txt = yytext();\n                  \/\/ if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space...\n                  if (strictTreebank3) {\n                    int spaceIndex = indexOfSpace(txt);\n                    if (spaceIndex >= 0) {\n                      yypushback(txt.length() - spaceIndex);\n                      return getNext();\n                    }\n                  }\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '\/');\n                  }\n                  if (normalizeSpace) {\n                    txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                  }\n                  return getNext(txt, yytext());\n            }\n          case 119: break;\n          case 47: \n            { return getNormalizedAmpNext();\n            }\n          case 120: break;\n          case 48: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 121: break;\n          case 49: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 122: break;\n          case 50: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 5;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 6;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String txt = yytext();\n                          return getNext(removeSoftHyphens(txt),\n                                         txt);\n            }\n          case 123: break;\n          case 51: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 17;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 124: break;\n          case 52: \n            { String txt = yytext();\n                  String normTok = txt;\n                  if (escapeForwardSlashAsterisk) {\n                    normTok = delimit(normTok, '*');\n                  }\n                  if (DEBUG) { logger.info(\"Used {SWEARING} to recognize \" + txt + \" as \" + normTok); }\n                  return getNext(normTok, txt);\n            }\n          case 125: break;\n          case 53: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 126: break;\n          case 54: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 10;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 127: break;\n          case 55: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 22;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 128: break;\n          case 56: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 18;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 19;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 129: break;\n          case 57: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 10;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 130: break;\n          case 58: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 21;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 131: break;\n          case 59: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 132: break;\n          case 60: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                  breakByHyphens(tok);\n                  tok = yytext();\n                  String norm = removeSoftHyphens(tok);\n                  if (DEBUG) { logger.info(\"Used {HTHING} (2) to recognize \" + tok + \" as \" + norm); }\n                  return getNext(norm, tok);\n            }\n          case 133: break;\n          case 61: \n            { if (splitAssimilations) {\n                      yypushback(3);\n                    }\n                    String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {ASSIMILATIONS3} to recognize \" + tok + \" as \" + tok +\n                            \"; splitAssimilations=\" + splitAssimilations); }\n                    return getNext(tok, tok);\n            }\n          case 134: break;\n          case 62: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNormalizedAmpNext();\n            }\n          case 135: break;\n          case 63: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 9;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 136: break;\n          case 64: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { return getNext();\n            }\n          case 137: break;\n          case 65: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 14;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 138: break;\n          case 66: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 8;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 139: break;\n          case 67: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 13;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 140: break;\n          case 68: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 141: break;\n          case 69: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4);\n            { return getNext();\n            }\n          case 142: break;\n          case 70: \n            \/\/ lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);\n            { return getNext();\n            }\n          case 143: break;\n          case 71: \n            { String txt = yytext();\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          if (DEBUG) { logger.info(\"Used {PHONE} to recognize \" + yytext() + \" as \" + txt); }\n                          return getNext(txt, yytext());\n            }\n          case 144: break;\n          case 72: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 23;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 25;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 145: break;\n          case 73: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 23;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 24;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 146: break;\n          default:\n            zzScanError(ZZ_NO_MATCH);\n        }\n      }\n    }\n  }\n","new_comment_raw":"@return the next token","old_comment_raw":"@return the next token","label":0,"pre_label":1,"AST_level":19,"line_counts":969,"new_code_token_num":6359},{"new_code_raw":"public static ErrorInfo handler(final RuntimeException exception) { if (exception instanceof AbstractPlatformResourceNotFoundException) { final PlatformResourceNotFoundExceptionMapper mapper = new PlatformResourceNotFoundExceptionMapper(); final String errorBody = jsonHelper .toJson(mapper.toResponse((AbstractPlatformResourceNotFoundException) exception).getEntity()); return new ErrorInfo(404, 1001, errorBody); } else if (exception instanceof UnsupportedParameterException) { final UnsupportedParameterExceptionMapper mapper = new UnsupportedParameterExceptionMapper(); final String errorBody = jsonHelper.toJson(mapper.toResponse((UnsupportedParameterException) exception).getEntity()); return new ErrorInfo(400, 2001, errorBody); } else if (exception instanceof PlatformApiDataValidationException) { final PlatformApiDataValidationExceptionMapper mapper = new PlatformApiDataValidationExceptionMapper(); final String errorBody = jsonHelper.toJson(mapper.toResponse((PlatformApiDataValidationException) exception).getEntity()); return new ErrorInfo(400, 2002, errorBody); } else if (exception instanceof PlatformDataIntegrityException) { final PlatformDataIntegrityExceptionMapper mapper = new PlatformDataIntegrityExceptionMapper(); final String errorBody = jsonHelper.toJson(mapper.toResponse((PlatformDataIntegrityException) exception).getEntity()); return new ErrorInfo(403, 3001, errorBody); } else if (exception instanceof LinkedAccountRequiredException) { final PlatformDomainRuleExceptionMapper mapper = new PlatformDomainRuleExceptionMapper(); final String errorBody = jsonHelper.toJson(mapper.toResponse((LinkedAccountRequiredException) exception).getEntity()); return new ErrorInfo(403, 3002, errorBody); } else if (exception instanceof MultiDisbursementDataRequiredException) { final PlatformDomainRuleExceptionMapper mapper = new PlatformDomainRuleExceptionMapper(); final String errorBody = jsonHelper.toJson(mapper.toResponse((MultiDisbursementDataRequiredException) exception).getEntity()); return new ErrorInfo(403, 3003, errorBody); } else if (exception instanceof TransactionException) { return new ErrorInfo(400, 4001, \"{\\\"Exception\\\": \" + exception.getMessage()+\"}\"); } else if (exception instanceof PlatformInternalServerException) { final PlatformInternalServerExceptionMapper mapper = new PlatformInternalServerExceptionMapper(); final String errorBody = jsonHelper.toJson(mapper.toResponse((PlatformInternalServerException) exception).getEntity()); return new ErrorInfo(500, 5001, errorBody); }else if(exception instanceof NonTransientDataAccessException) { return new ErrorInfo(400, 4001, \"{\\\"Exception\\\": \" + exception.getMessage()+\"}\"); } return new ErrorInfo(500, 9999, \"{\\\"Exception\\\": \" + exception.toString() + \"}\"); }","old_code_raw":"    public static ErrorInfo handler(final RuntimeException exception) {\n\n        if (exception instanceof AbstractPlatformResourceNotFoundException) {\n\n            final PlatformResourceNotFoundExceptionMapper mapper = new PlatformResourceNotFoundExceptionMapper();\n            final String errorBody = jsonHelper\n                    .toJson(mapper.toResponse((AbstractPlatformResourceNotFoundException) exception).getEntity());\n\n            return new ErrorInfo(404, 1001, errorBody);\n\n        } else if (exception instanceof UnsupportedParameterException) {\n\n            final UnsupportedParameterExceptionMapper mapper = new UnsupportedParameterExceptionMapper();\n            final String errorBody = jsonHelper.toJson(mapper.toResponse((UnsupportedParameterException) exception).getEntity());\n\n            return new ErrorInfo(400, 2001, errorBody);\n\n        } else if (exception instanceof PlatformApiDataValidationException) {\n\n            final PlatformApiDataValidationExceptionMapper mapper = new PlatformApiDataValidationExceptionMapper();\n            final String errorBody = jsonHelper.toJson(mapper.toResponse((PlatformApiDataValidationException) exception).getEntity());\n\n            return new ErrorInfo(400, 2002, errorBody);\n\n        } else if (exception instanceof PlatformDataIntegrityException) {\n\n            final PlatformDataIntegrityExceptionMapper mapper = new PlatformDataIntegrityExceptionMapper();\n            final String errorBody = jsonHelper.toJson(mapper.toResponse((PlatformDataIntegrityException) exception).getEntity());\n\n            return new ErrorInfo(403, 3001, errorBody);\n\n        } else if (exception instanceof LinkedAccountRequiredException) {\n\n            final PlatformDomainRuleExceptionMapper mapper = new PlatformDomainRuleExceptionMapper();\n            final String errorBody = jsonHelper.toJson(mapper.toResponse((LinkedAccountRequiredException) exception).getEntity());\n\n            return new ErrorInfo(403, 3002, errorBody);\n            \n        } else if (exception instanceof MultiDisbursementDataRequiredException) {\n\n            final PlatformDomainRuleExceptionMapper mapper = new PlatformDomainRuleExceptionMapper();\n            final String errorBody = jsonHelper.toJson(mapper.toResponse((MultiDisbursementDataRequiredException) exception).getEntity());\n\n            return new ErrorInfo(403, 3003, errorBody);\n            \n        } else if (exception instanceof TransactionException) {\n            return new ErrorInfo(400, 4001, \"{\\\"Exception\\\": \" + exception.getMessage()+\"}\");\n\n        } else if (exception instanceof PlatformInternalServerException) {\n\n            final PlatformInternalServerExceptionMapper mapper = new PlatformInternalServerExceptionMapper();\n            final String errorBody = jsonHelper.toJson(mapper.toResponse((PlatformInternalServerException) exception).getEntity());\n\n            return new ErrorInfo(500, 5001, errorBody);\n        }\n\n        return new ErrorInfo(500, 9999, \"{\\\"Exception\\\": \" + exception.toString() + \"}\");\n    }\n","new_comment_raw":"@return ErrorInfo","old_comment_raw":"@return ErrorInfo","label":0,"pre_label":1,"AST_level":17,"line_counts":61,"new_code_token_num":441},{"new_code_raw":"public Object getCache(PGraphics renderer) { if (cacheMap == null) return null; return cacheMap.get(renderer); }","old_code_raw":"  public Object getCache(Object parent) {\n    if (cacheMap == null) return null;\n    return cacheMap.get(parent);\n  }\n","new_comment_raw":"@return metadata stored for the specified renderer","old_comment_raw":"@return data stored for the specified parent","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":24},{"new_code_raw":"public <RX extends RxInvokerProvider> Client buildRx(String name, Class<RX> invokerType) { return build(name).register(invokerType); }","old_code_raw":"public <RX extends RxInvoker> RxClient<RX> buildRx(String name, Class<RX> invokerType) {\n    return Rx.from(build(name), invokerType, executorService);\n}","new_comment_raw":"@return a fully-configured {@link Client}","old_comment_raw":"@return a fully-configured {@link RxClient}","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":26},{"new_code_raw":"public boolean isToExclude(HttpMessage msg, NameValuePair param) { \/\/ Verify if check for the paramType should be maintained because \/\/ It's currently optimized using a Map in the container return ((paramType < 0) || (param.getType() == paramType)) && ((urlPattern == null) || urlPattern.matcher(msg.getRequestHeader().getURI().toString().toUpperCase(Locale.ROOT)).matches()) && (paramNamePattern.matcher(param.getName()).matches()); }","old_code_raw":"    public boolean isToExclude(HttpMessage msg, NameValuePair param) {\n        \/\/ Verify if check for the paramType should be maintained because\n        \/\/ It's currently optimized using a Map in the container\n        return ((paramType < 0) || (param.getType() == paramType)) &&\n                ((urlPattern == null) || urlPattern.matcher(msg.getRequestHeader().getURI().toString()).matches()) && \n                (paramNamePattern.matcher(param.getName()).matches());\n    }\n","new_comment_raw":"@return true if the parameter should be excluded","old_comment_raw":"@return true if the parameter should be excluded","label":0,"pre_label":1,"AST_level":10,"line_counts":8,"new_code_token_num":101},{"new_code_raw":"public AST handleIdentifierError(Token token, RecognitionException ex) throws RecognitionException, TokenStreamException { \/\/ If the token can tell us if it could be an identifier... if ( token instanceof HqlToken ) { HqlToken hqlToken = ( HqlToken ) token; \/\/ ... and the token could be an identifer and the error is \/\/ a mismatched token error ... if ( hqlToken.isPossibleID() && ( ex instanceof MismatchedTokenException ) ) { MismatchedTokenException mte = ( MismatchedTokenException ) ex; \/\/ ... and the expected token type was an identifier, then: if ( mte.expecting == HqlTokenTypes.IDENT ) { \/\/ Use the token as an identifier. reportWarning( \"Keyword '\" + token.getText() + \"' is being interpreted as an identifier due to: \" + mte.getMessage() ); \/\/ Add the token to the AST. ASTPair currentAST = new ASTPair(); token.setType( HqlTokenTypes.WEIRD_IDENT ); astFactory.addASTChild( currentAST, astFactory.create( token ) ); consume(); return currentAST.root; } } \/\/ if } \/\/ if \/\/ Otherwise, handle the error normally. return super.handleIdentifierError( token, ex ); }","old_code_raw":"    public AST handleIdentifierError(Token token, RecognitionException ex) throws RecognitionException, TokenStreamException {\n\t\t\/\/ If the token can tell us if it could be an identifier...\n\t\tif ( token instanceof HqlToken ) {\n\t\t\tHqlToken hqlToken = ( HqlToken ) token;\n\t\t\t\/\/ ... and the token could be an identifer and the error is\n\t\t\t\/\/ a mismatched token error ...\n\t\t\tif ( hqlToken.isPossibleID() && ( ex instanceof MismatchedTokenException ) ) {\n\t\t\t\tMismatchedTokenException mte = ( MismatchedTokenException ) ex;\n\t\t\t\t\/\/ ... and the expected token type was an identifier, then:\n\t\t\t\tif ( mte.expecting == HqlTokenTypes.IDENT ) {\n\t\t\t\t\t\/\/ Use the token as an identifier.\n\t\t\t\t\treportWarning( \"Keyword  '\"\n\t\t\t\t\t\t\t+ token.getText()\n\t\t\t\t\t\t\t+ \"' is being interpreted as an identifier due to: \" + mte.getMessage() );\n\t\t\t\t\t\/\/ Add the token to the AST.\n\t\t\t\t\tASTPair currentAST = new ASTPair();\n\t\t\t\t\ttoken.setType( HqlTokenTypes.WEIRD_IDENT );\n\t\t\t\t\tastFactory.addASTChild( currentAST, astFactory.create( token ) );\n\t\t\t\t\tconsume();\n\t\t\t\t\tAST identifierAST = currentAST.root;\n\t\t\t\t\treturn identifierAST;\n\t\t\t\t}\n\t\t\t} \/\/ if\n\t\t} \/\/ if\n\t\t\/\/ Otherwise, handle the error normally.\n\t\treturn super.handleIdentifierError( token, ex );\n\t}\n","new_comment_raw":"@return AST - The new AST.","old_comment_raw":"@return AST - The new AST.","label":0,"pre_label":1,"AST_level":14,"line_counts":27,"new_code_token_num":213},{"new_code_raw":"public Type getPhysical() { return physical; }","old_code_raw":"public Class<P> getPhysical() {\n    return physical;\n}","new_comment_raw":"@return the physical type used by the runtime","old_comment_raw":"@return the physical class used by the runtime","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":10},{"new_code_raw":"public LoggingConfiguration getLoggingConfiguration() { return loggingConfiguration; }","old_code_raw":"    public LoggingConfiguration getLoggingConfiguration() {\n        return logging;\n    }\n","new_comment_raw":"@return logging-specific configuration parameters","old_comment_raw":"@return logging-specific configuration parameters","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"private String terminalToShowWhenClosing(String handle) { int terminalClosing = terminals_.indexOfTerminal(handle); if (terminalClosing > 0) return terminals_.terminalHandleAtIndex(terminalClosing - 1); else if (terminalClosing + 1 < terminals_.terminalCount()) return terminals_.terminalHandleAtIndex(terminalClosing + 1); else return null; }","old_code_raw":"   private int terminalToShowWhenClosing(int terminalClosing)\n   {\n      if (terminalClosing > 0)\n         return terminalClosing - 1;\n      else if (terminalClosing + 1 < getTerminalCount())\n         return terminalClosing + 1;\n      else\n         return -1;\n   }\n","new_comment_raw":"@return handle of terminal to show next, or null if none to show","old_comment_raw":"@return index of terminal to show next, or -1 if none available","label":1,"pre_label":0,"AST_level":8,"line_counts":11,"new_code_token_num":55},{"new_code_raw":"public static Consumer<List> elasticsearchChecker(final String... strings) { return actual -> { Object[] actualArray = actual == null || actual.isEmpty() ? null : ((List) actual.get(NUM)).toArray(); CalciteAssert.assertArrayEqual(STR, strings, actualArray); }; }","old_code_raw":"public static Function<List, Void> elasticsearchChecker(final String... strings) {\n    return new Function<List, Void>() {\n\n        @Nullable\n        @Override\n        public Void apply(@Nullable List actual) {\n            Object[] actualArray = actual == null || actual.isEmpty() ? null : ((List) actual.get(NUM)).toArray();\n            CalciteAssert.assertArrayEqual(STR, strings, actualArray);\n            return null;\n        }\n    };\n}","new_comment_raw":"@return function to perform the check","old_comment_raw":"@return validation function","label":1,"pre_label":0,"AST_level":10,"line_counts":6,"new_code_token_num":57},{"new_code_raw":"protected Object convertDateToEpochDaysAsDate(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return new java.util.Date(0L); \/\/ return epoch } try { int epochDay = Date.toEpochDay(data); long epochMillis = TimeUnit.DAYS.toMillis(epochDay); return new java.util.Date(epochMillis); } catch (IllegalArgumentException e) { logger.warn(\"Unexpected JDBC DATE value for field {} with schema {}: class={}, value={}\", fieldDefn.name(), fieldDefn.schema(), data.getClass(), data); return null; } }","old_code_raw":"    protected Object convertDateToEpochDaysAsDate(Column column, Field fieldDefn, Object data) {\n        if (data == null) return null;\n        try {\n            int epochDay = Date.toEpochDay(data);\n            long epochMillis = TimeUnit.DAYS.toMillis(epochDay);\n            return new java.util.Date(epochMillis);\n        } catch (IllegalArgumentException e) {\n            logger.warn(\"Unexpected JDBC DATE value for field {} with schema {}: class={}, value={}\", fieldDefn.name(),\n                        fieldDefn.schema(), data.getClass(), data);\n            return null;\n        }\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made","label":1,"pre_label":0,"AST_level":9,"line_counts":19,"new_code_token_num":144},{"new_code_raw":"public String getLocation() { return getFirstValue(HEAD_KEY_LOCATION); }","old_code_raw":"    public String getLocation() {\n        return getValue(HEAD_KEY_LOCATION, 0);\n    }\n","new_comment_raw":"@return Location.","old_comment_raw":"@return Location.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":13},{"new_code_raw":"public InstrumentationFieldCompleteParameters withNewState(InstrumentationState instrumentationState) { return new InstrumentationFieldCompleteParameters( this.executionContext, executionStrategyParameters, this.fieldDef, this.typeInfo, this.fetchedValue, instrumentationState); }","old_code_raw":"    public InstrumentationFieldCompleteParameters withNewState(InstrumentationState instrumentationState) {\n        return new InstrumentationFieldCompleteParameters(\n                this.executionContext, executionStrategyParameters, this.fieldDef, this.typeInfo, instrumentationState);\n    }\n","new_comment_raw":"@return a new parameters object with the new state","old_comment_raw":"@return a new parameters object with the new state","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":30},{"new_code_raw":"public TraceabilityIndex getOrCreateTraceabilityIndex() { if (traceabilityIndex == null) { final Resource traceabilityResource = repositoryAdapter.getResource(IntentLocations.TRACEABILITY_INFOS_INDEX_PATH); if (traceabilityResource.getContents().isEmpty()) { traceabilityResource.getContents().add(CompilerFactory.eINSTANCE.createTraceabilityIndex()); } traceabilityIndex = (TraceabilityIndex) traceabilityResource.getContents().get(NUM); } return traceabilityIndex; }","old_code_raw":"public TraceabilityIndex getOrCreateTraceabilityIndex() {\n    final Resource traceabilityResource = repositoryAdapter.getResource(IntentLocations.TRACEABILITY_INFOS_INDEX_PATH);\n    if (traceabilityResource.getContents().isEmpty()) {\n        traceabilityResource.getContents().add(CompilerFactory.eINSTANCE.createTraceabilityIndex());\n    }\n    return (TraceabilityIndex) traceabilityResource.getContents().get(NUM);\n}","new_comment_raw":"@return the {@link TraceabilityIndex} index of the current repository. If none find, creates it","old_comment_raw":"@return the traceability index of the current repository. If none find, creates it","label":1,"pre_label":0,"AST_level":10,"line_counts":10,"new_code_token_num":65},{"new_code_raw":"private AttributeDetails maxDequeIterator(AttributeDetails valObject) { if (valueRemoved != null) { for (Iterator<AttributeDetails> iterator = maxDeque.descendingIterator(); iterator.hasNext(); ) { AttributeDetails possibleMaxValue = iterator.next(); if (possibleMaxValue.getValue() < valObject.getValue() || possibleMaxValue.getValue() <= valueRemoved.getValue()) { if (possibleMaxValue.getValue() < valObject.getValue()) { iterator.remove(); } else if (valueRemoved.equals(possibleMaxValue)) { iterator.remove(); } } else { break; } } } else { for (Iterator<AttributeDetails> iterator = maxDeque.descendingIterator(); iterator.hasNext(); ) { if (iterator.next().getValue() < valObject.getValue()) { iterator.remove(); } else { break; } } } valObject.setMaxThreshold(); maxDeque.addLast(valObject); return maxDeque.peek(); }","old_code_raw":"private attributeDetails maxDequeIterator(attributeDetails valObject) {\n    if (valueRemoved != null) {\n        for (Iterator<attributeDetails> iterator = maxDeque.descendingIterator(); iterator.hasNext(); ) {\n            double possibleMaxValue = iterator.next().getValue();\n            if (possibleMaxValue < valObject.getValue() || possibleMaxValue <= valueRemoved.getValue()) {\n                if (possibleMaxValue < valObject.getValue()) {\n                    iterator.remove();\n                } else if (valueRemoved.getValue() == possibleMaxValue) {\n                    iterator.remove();\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n    } else {\n        for (Iterator<attributeDetails> iterator = maxDeque.descendingIterator(); iterator.hasNext(); ) {\n            if (iterator.next().getValue() < valObject.getValue()) {\n                iterator.remove();\n            } else {\n                break;\n            }\n        }\n    }\n    valObject.setMaxThreshold();\n    maxDeque.addLast(valObject);\n    return maxDeque.peek();\n}","new_comment_raw":"@return maximum value (without checking preBoundChange, postBoundChange conditions)","old_comment_raw":"@return maximum value (without checking d, D conditions)","label":1,"pre_label":0,"AST_level":13,"line_counts":27,"new_code_token_num":168},{"new_code_raw":"public double conditionalLogProbGivenNext(int[] given, int of) { if (given.length != windowSize - 1) { throw new IllegalArgumentException(\"conditionalLogProbGivenNext requires given one less than clique size (\" + windowSize + \") but was \" + Arrays.toString(given)); } int[] label = indicesEnd(given); double[] masses = new double[label.length]; for (int i = 0; i < masses.length; i++) { masses[i] = table[label[i]]; } return table[indexOf(of, given)] - ArrayMath.logSum(masses); }","old_code_raw":"  public double conditionalLogProbGivenNext(int[] given, int of) {\n    if (given.length != windowSize - 1) {\n      throw new IllegalArgumentException(\"conditionalLogProbGivenNext requires given one less than clique size (\" +\n          windowSize + \") but was \" + Arrays.toString(given));\n    }\n    int[] label = indicesEnd(given);\n    double[] masses = new double[label.length];\n    for (int i = 0; i < masses.length; i++) {\n      masses[i] = table[label[i]];\n    }\n    double z = ArrayMath.logSum(masses);\n\n    return table[indexOf(of, given)] - z;\n  }\n","new_comment_raw":"@return the probability of the tag of being at the beginning of the table","old_comment_raw":"@return the probability of the tag of being at the beginning of the table","label":0,"pre_label":1,"AST_level":11,"line_counts":13,"new_code_token_num":121},{"new_code_raw":"private static YearClass categorizeByYear(Context c) { ArrayList<YearClass> componentYears = new ArrayList<YearClass>(); conditionallyAdd(componentYears, YearClass.fromNumberOfCores()); conditionallyAdd(componentYears, YearClass.fromClockSpeed()); conditionallyAdd(componentYears, YearClass.fromRamTotal(c)); if (componentYears.isEmpty()) return YearClass.CLASS_UNKNOWN; Collections.sort(componentYears); if ((componentYears.size() & NUM) == NUM) { return componentYears.get(componentYears.size() \/ NUM); } else { int baseIndex = componentYears.size() \/ NUM - NUM; int averageRoundedDown = componentYears.get(baseIndex).mIntValue + (componentYears.get(baseIndex + NUM).mIntValue - componentYears.get(baseIndex).mIntValue) \/ NUM; return YearClass.fromIntValue(averageRoundedDown); } }","old_code_raw":"private static int categorizeByYear(Context c) {\n    ArrayList<Integer> componentYears = new ArrayList<Integer>();\n    conditionallyAdd(componentYears, getNumCoresYear());\n    conditionallyAdd(componentYears, getClockSpeedYear());\n    conditionallyAdd(componentYears, getRamYear(c));\n    if (componentYears.isEmpty())\n        return CLASS_UNKNOWN;\n    Collections.sort(componentYears);\n    if ((componentYears.size() & NUM) == NUM) {\n        return componentYears.get(componentYears.size() \/ NUM);\n    } else {\n        int baseIndex = componentYears.size() \/ NUM - NUM;\n        return componentYears.get(baseIndex) + (componentYears.get(baseIndex + NUM) - componentYears.get(baseIndex)) \/ NUM;\n    }\n}","new_comment_raw":"@return The YearClass when this device would have been considered top-of-the-line.","old_comment_raw":"@return The year when this device would have been considered top-of-the-line.","label":1,"pre_label":0,"AST_level":12,"line_counts":16,"new_code_token_num":143},{"new_code_raw":"public String findInContent(String content) { \/\/ First check for a simple exact occurrence for (BoyerMooreMatcher matcher : strings) { if (matcher.findInContent(content) >= 0) return matcher.getPattern(); } \/\/ Then check for a regex occurrence Matcher matcher; for (Pattern pattern : patterns) { matcher = pattern.matcher(content); if (matcher.find()) { return matcher.group(); } } \/\/ No match found return null return null; }","old_code_raw":"    public String findInContent(String content) {\n        \n        \/\/ First check for a simple exact occurrence\n        for (String str : strings) {\n            if (content.contains(str))\n                return str;\n        }\n        \n        \/\/ Then check for a regex occurrence\n        Matcher matcher;\n        for (Pattern pattern : patterns) {\n            matcher = pattern.matcher(content);\n            if (matcher.find()) {\n                return matcher.group();\n            }\n        }\n        \n        \/\/ No match found return null\n        return null;\n    }\n","new_comment_raw":"@return the found occurrence or null if no match has been done","old_comment_raw":"@return the found occurrence or null if no match has been done","label":0,"pre_label":1,"AST_level":8,"line_counts":21,"new_code_token_num":94},{"new_code_raw":"public PMetadata getCache(PGraphics renderer) { return g.getCache(renderer); }","old_code_raw":"  public Object getCache(Object parent) {\n    return g.getCache(parent);\n  }\n","new_comment_raw":"@return metadata stored for the specified renderer","old_comment_raw":"@return data stored for the specified parent","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":16},{"new_code_raw":"public Throwable getCause() { return super.getCause(); }","old_code_raw":"public Throwable getCause() {\n    return cause;\n}","new_comment_raw":"@return The cause of this exception or <code>null<\/code> if no cause was set.","old_comment_raw":"@return The cause of this exception or <code>null<\/code> if no cause was specified.","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":13},{"new_code_raw":"public int hashCode() { return (iLowerLimit == null ? 0 : iLowerLimit.hashCode()) + (123 * (iUpperLimit == null ? 0 : iUpperLimit.hashCode())); }","old_code_raw":"    public int hashCode() {\n        return (iLowerLimit == null ? 0 : iLowerLimit.hashCode()) +\n               (iUpperLimit == null ? 0 : iUpperLimit.hashCode());\n    }\n","new_comment_raw":"@return the hashcode","old_comment_raw":"@return the hashcode","label":0,"pre_label":1,"AST_level":8,"line_counts":5,"new_code_token_num":36},{"new_code_raw":"public BlankNodeOrIri convertNonLiteral(Node node) { if (node == null) { throw new IllegalArgumentException(STR); } if (node.isBlank()) { return convertJenaNode2TriaBlankNode(node); } if (node.isURI()) { return convertJenaUri2UriRef(node); } throw new RuntimeException(STR + node + STR); }","old_code_raw":"public NonLiteral convertNonLiteral(Node node) {\n    if (node == null) {\n        throw new IllegalArgumentException(STR);\n    }\n    if (node.isBlank()) {\n        return convertJenaNode2TriaBlankNode(node);\n    }\n    if (node.isURI()) {\n        return convertJenaUri2UriRef(node);\n    }\n    throw new RuntimeException(STR + node + STR);\n}","new_comment_raw":"@return BlankNode if it is a Blank Node otherwise a Iri","old_comment_raw":"@return BNode if it is a Blank Node otherwise a UriRef","label":1,"pre_label":0,"AST_level":7,"line_counts":12,"new_code_token_num":64},{"new_code_raw":"public static DateTimeFormatter weekDate() { return Constants.wwd; }","old_code_raw":"    public static DateTimeFormatter weekDate() {\n        return weekyearWeekDay();\n    }\n","new_comment_raw":"@return a formatter for xxxx-'W'ww-e","old_comment_raw":"@return a formatter for xxxx-'W'ww-e","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":12},{"new_code_raw":"protected ComponentTemplate getMetaData(final Object entry) { return (ComponentTemplate) entry; }","old_code_raw":"protected ComponentMetaData getMetaData(final Object entry) {\n    return (ComponentMetaData) entry;\n}","new_comment_raw":"@return the ComponentTemplate","old_comment_raw":"@return the ComponentMetaData","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":16},{"new_code_raw":"public static final TwitterTokenStream of(TwitterTokenStream... streams) { return new TokenStreamAggregator(streams); }","old_code_raw":"public static final TokenStream of(TokenStream... streams) {\n    return new TokenStreamAggregator(streams);\n}","new_comment_raw":"@return an aggregated TwitterTokenStream","old_comment_raw":"@return an aggregated TokenStream","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":18},{"new_code_raw":"protected CompletableFuture<Object> fetchField(ExecutionContext executionContext, ExecutionStrategyParameters parameters) { Field field = parameters.field().get(0); GraphQLObjectType parentType = parameters.typeInfo().castType(GraphQLObjectType.class); GraphQLFieldDefinition fieldDef = getFieldDef(executionContext.getGraphQLSchema(), parentType, field); GraphqlFieldVisibility fieldVisibility = executionContext.getGraphQLSchema().getFieldVisibility(); Map<String, Object> argumentValues = valuesResolver.getArgumentValues(fieldVisibility, fieldDef.getArguments(), field.getArguments(), executionContext.getVariables()); GraphQLOutputType fieldType = fieldDef.getType(); DataFetchingFieldSelectionSet fieldCollector = DataFetchingFieldSelectionSetImpl.newCollector(executionContext, fieldType, parameters.field()); ExecutionTypeInfo fieldTypeInfo = fieldTypeInfo(parameters, fieldDef); DataFetchingEnvironment environment = newDataFetchingEnvironment(executionContext) .source(parameters.source()) .arguments(argumentValues) .fieldDefinition(fieldDef) .fields(parameters.field()) .fieldType(fieldType) .fieldTypeInfo(fieldTypeInfo) .parentType(parentType) .selectionSet(fieldCollector) .build(); Instrumentation instrumentation = executionContext.getInstrumentation(); InstrumentationFieldFetchParameters instrumentationFieldFetchParams = new InstrumentationFieldFetchParameters(executionContext, fieldDef, environment); InstrumentationContext<Object> fetchCtx = instrumentation.beginFieldFetch(instrumentationFieldFetchParams); CompletableFuture<Object> fetchedValue; DataFetcher dataFetcher = fieldDef.getDataFetcher(); dataFetcher = instrumentation.instrumentDataFetcher(dataFetcher, instrumentationFieldFetchParams); ExecutionId executionId = executionContext.getExecutionId(); try { log.debug(\"'{}' fetching field '{}' using data fetcher '{}'...\", executionId, fieldTypeInfo.getPath(), dataFetcher.getClass().getName()); Object fetchedValueRaw = dataFetcher.get(environment); log.debug(\"'{}' field '{}' fetch returned '{}'\", executionId, fieldTypeInfo.getPath(), fetchedValueRaw == null ? \"null\" : fetchedValueRaw.getClass().getName()); fetchedValue = Async.toCompletableFuture(fetchedValueRaw); } catch (Exception e) { log.debug(String.format(\"'%s', field '%s' fetch threw exception\", executionId, fieldTypeInfo.getPath()), e); fetchedValue = new CompletableFuture<>(); fetchedValue.completeExceptionally(e); } fetchCtx.onDispatched(fetchedValue); return fetchedValue .handle((result, exception) -> { fetchCtx.onCompleted(result, exception); if (exception != null) { handleFetchingException(executionContext, parameters, field, fieldDef, argumentValues, environment, exception); return null; } else { return result; } }) .thenApply(result -> unboxPossibleDataFetcherResult(executionContext, parameters, result)) .thenApply(this::unboxPossibleOptional); }","old_code_raw":"    protected CompletableFuture<Object> fetchField(ExecutionContext executionContext, ExecutionStrategyParameters parameters) {\n        Field field = parameters.field().get(0);\n        GraphQLObjectType parentType = parameters.typeInfo().castType(GraphQLObjectType.class);\n        GraphQLFieldDefinition fieldDef = getFieldDef(executionContext.getGraphQLSchema(), parentType, field);\n\n        GraphqlFieldVisibility fieldVisibility = executionContext.getGraphQLSchema().getFieldVisibility();\n        Map<String, Object> argumentValues = valuesResolver.getArgumentValues(fieldVisibility, fieldDef.getArguments(), field.getArguments(), executionContext.getVariables());\n\n        GraphQLOutputType fieldType = fieldDef.getType();\n        DataFetchingFieldSelectionSet fieldCollector = DataFetchingFieldSelectionSetImpl.newCollector(executionContext, fieldType, parameters.field());\n        ExecutionTypeInfo fieldTypeInfo = fieldTypeInfo(parameters, fieldDef);\n\n        DataFetchingEnvironment environment = newDataFetchingEnvironment(executionContext)\n                .source(parameters.source())\n                .arguments(argumentValues)\n                .fieldDefinition(fieldDef)\n                .fields(parameters.field())\n                .fieldType(fieldType)\n                .fieldTypeInfo(fieldTypeInfo)\n                .parentType(parentType)\n                .selectionSet(fieldCollector)\n                .build();\n\n        Instrumentation instrumentation = executionContext.getInstrumentation();\n\n        InstrumentationFieldFetchParameters instrumentationFieldFetchParams = new InstrumentationFieldFetchParameters(executionContext, fieldDef, environment);\n        InstrumentationContext<Object> fetchCtx = instrumentation.beginFieldFetch(instrumentationFieldFetchParams);\n        CompletableFuture<?> fetchedValue;\n        DataFetcher dataFetcher = fieldDef.getDataFetcher();\n        dataFetcher = instrumentation.instrumentDataFetcher(dataFetcher, instrumentationFieldFetchParams);\n        ExecutionId executionId = executionContext.getExecutionId();\n        try {\n            log.debug(\"'{}' fetching field '{}' using data fetcher '{}'...\", executionId, fieldTypeInfo.getPath(), dataFetcher.getClass().getName());\n            Object fetchedValueRaw = dataFetcher.get(environment);\n            log.debug(\"'{}' field '{}' fetch returned '{}'\", executionId, fieldTypeInfo.getPath(), fetchedValueRaw == null ? \"null\" : fetchedValueRaw.getClass().getName());\n\n            fetchedValue = Async.toCompletableFuture(fetchedValueRaw);\n        } catch (Exception e) {\n            log.debug(String.format(\"'%s', field '%s' fetch threw exception\", executionId, fieldTypeInfo.getPath()), e);\n\n            fetchedValue = new CompletableFuture<>();\n            fetchedValue.completeExceptionally(e);\n        }\n        return fetchedValue\n                .handle((result, exception) -> {\n                    fetchCtx.onEnd(result, exception);\n                    if (exception != null) {\n                        handleFetchingException(executionContext, parameters, field, fieldDef, argumentValues, environment, exception);\n                        return null;\n                    } else {\n                        return result;\n                    }\n                })\n                .thenApply(result -> unboxPossibleDataFetcherResult(executionContext, parameters, result))\n                .thenApply(this::unboxPossibleOptional);\n    }\n","new_comment_raw":"@return a fetched object","old_comment_raw":"@return a fetched object","label":0,"pre_label":1,"AST_level":10,"line_counts":59,"new_code_token_num":455},{"new_code_raw":"public File getGeneratedOutput() throws CurnException { return null; }","old_code_raw":"public InputStream getGeneratedOutput() throws CurnException {\n    return null;\n}","new_comment_raw":"@return null, unconditionally","old_comment_raw":"@return an open input stream, or null if no suitable output was produced","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":12},{"new_code_raw":"public ArrayList<View> getViews() { try { return viewFetcher.getViews(null, false); } catch (Exception e) { e.printStackTrace(); return null; } }","old_code_raw":"public ArrayList<View> getViews() {\n    try {\n        return viewFetcher.getViews(null);\n    } catch (Exception e) {\n        e.printStackTrace();\n        return null;\n    }\n}","new_comment_raw":"@return an {@code ArrayList} of the {@code View} objects located in the focused window","old_comment_raw":"@return an {@code ArrayList} of the {@code View} objects located in the current {@code Activity}","label":1,"pre_label":0,"AST_level":6,"line_counts":8,"new_code_token_num":35},{"new_code_raw":"private void collectFields(FieldCollectorParameters parameters, SelectionSet selectionSet, List<String> visitedFragments, Map<String, List<Field>> fields) { for (Selection selection : selectionSet.getSelections()) { if (selection instanceof Field) { collectField(parameters, fields, (Field) selection); } else if (selection instanceof InlineFragment) { collectInlineFragment(parameters, visitedFragments, fields, (InlineFragment) selection); } else if (selection instanceof FragmentSpread) { collectFragmentSpread(parameters, visitedFragments, fields, (FragmentSpread) selection); } } }","old_code_raw":"    public MergedSelectionSet collectFields(FieldCollectorParameters parameters, SelectionSet selectionSet) {\n        Map<String, MergedFields> subFields = new LinkedHashMap<>();\n        List<String> visitedFragments = new ArrayList<>();\n        this.collectFields(parameters, selectionSet, visitedFragments, subFields);\n        return newMergedSelectionSet().subFields(subFields).build();\n    }\n","new_comment_raw":"@return a map of the sub field selections","old_comment_raw":"@return a map of the sub field selections","label":0,"pre_label":1,"AST_level":12,"line_counts":13,"new_code_token_num":101},{"new_code_raw":"public Builder hasArg() { return hasArg(true); }","old_code_raw":"public boolean hasArg() {\n    return numberOfArgs > NUM || numberOfArgs == UNLIMITED_VALUES;\n}","new_comment_raw":"@return this builder, to allow method chaining","old_comment_raw":"@return boolean flag indicating if an argument is required","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":13},{"new_code_raw":"protected void checkFont() { Font awtFont = textFont.getFont(); if (awtFont == null) { \/\/ always need a native font or reference to it throw new RuntimeException(\"Use createFont() instead of loadFont() \" + \"when drawing text using the PDF library.\"); } else if (textMode != SHAPE) { if (textFont.isStream()) { throw new RuntimeException(\"Use textMode(SHAPE) with when loading \" + \".ttf and .otf files with createFont().\"); } else if (mapper.getAliases().get(textFont.getName()) == null) { \/\/System.out.println(\"alias for \" + name + \" = \" + mapper.getAliases().get(name)); System.err.println(\"Use PGraphicsPDF.listFonts() to get a list of \" + \"fonts that can be used with PDF.\"); throw new RuntimeException(\"The font \u00e2\u0080\u009c\" + textFont.getName() + \"\u00e2\u0080\u009d \" + \"cannot be used with PDF Export.\"); } } }","old_code_raw":"  protected boolean checkFont(String name) {\n    \/\/System.out.println(\"alias for \" + name + \" = \" + mapper.getAliases().get(name));\n    return mapper.getAliases().get(name) != null;\n  }\n","new_comment_raw":"@return true if it's ok","old_comment_raw":"@return true if it's ok","label":0,"pre_label":1,"AST_level":14,"line_counts":19,"new_code_token_num":205},{"new_code_raw":"public ClassFieldAccessor getFieldAccessor() { return this.accessor; }","old_code_raw":"FieldAccessor getFieldAccessor() {\n    return this.accessor;\n}","new_comment_raw":"@return Returns the field extractor","old_comment_raw":"@return Returns the field accessor","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":11},{"new_code_raw":"public static SchemaBuilder builder(DecimalMode mode, int precision, int scale) { switch (mode) { case DOUBLE: return SchemaBuilder.float64(); case PRECISE: return Decimal.builder(scale) .parameter(PRECISION_PARAMETER_KEY, String.valueOf(precision)); case STRING: return SchemaBuilder.string(); } throw new IllegalArgumentException(\"Unknown decimalMode\"); }","old_code_raw":"    public static SchemaBuilder builder(DecimalMode mode, int scale) {\n        switch (mode) {\n        case DOUBLE:\n            return SchemaBuilder.float64();\n        case PRECISE:\n            return Decimal.builder(scale);\n        case STRING:\n            return SchemaBuilder.string();\n        }\n        throw new IllegalArgumentException(\"Unknown decimalMode\");\n    }\n","new_comment_raw":"@return the schema builder","old_comment_raw":"@return the schema builder","label":0,"pre_label":1,"AST_level":9,"line_counts":13,"new_code_token_num":70},{"new_code_raw":"private static boolean isConnected(NetType netType, NetworkInfo networkInfo) { switch(netType) { case Any: return networkInfo != null && isConnected(networkInfo); case Wifi: return networkInfo != null && networkInfo.getType() == ConnectivityManager.TYPE_WIFI && isConnected(networkInfo); case Mobile: return networkInfo != null && networkInfo.getType() == ConnectivityManager.TYPE_MOBILE && isConnected(networkInfo); } return false; }","old_code_raw":"public static boolean isConnected(NetType netType, NetworkInfo networkInfo) {\n    if (netType == NetType.Any && networkInfo != null && isConnected(networkInfo))\n        return true;\n    else if (netType == NetType.Wifi && networkInfo != null && networkInfo.getType() == ConnectivityManager.TYPE_WIFI && isConnected(networkInfo))\n        return true;\n    else if (netType == NetType.Mobile && networkInfo != null && networkInfo.getType() == ConnectivityManager.TYPE_MOBILE && isConnected(networkInfo))\n        return true;\n    return false;\n}","new_comment_raw":"@return Connection state return true, otherwise it returns false.","old_comment_raw":"@return ConnectionResult state return true, otherwise it returns false.","label":1,"pre_label":0,"AST_level":9,"line_counts":11,"new_code_token_num":80},{"new_code_raw":"private TableExportButton<JXTable> getExportButton() { if (exportButton == null) { exportButton = new TableExportButton<>(getHttpSessionsTable()); } return exportButton; }","old_code_raw":"\tprivate TableExportButton getExportButton() {\n\t\tif (exportButton == null) {\n\t\t\texportButton = new TableExportButton(getHttpSessionsTable());\n\t\t}\n\t\treturn exportButton;\n\t}\n","new_comment_raw":"@return javax.swing.JPanel","old_comment_raw":"@return javax.swing.JPanel","label":0,"pre_label":1,"AST_level":8,"line_counts":7,"new_code_token_num":27},{"new_code_raw":"@RequestMapping(value = STR, method = { RequestMethod.POST }) @ResponseBody public CubeRequest saveCubeDesc(@RequestBody CubeRequest cubeRequest) { MetadataManager metaManager = MetadataManager.getInstance(cubeService.getConfig()); DataModelDesc modelDesc = deserializeDataModelDesc(cubeRequest); if (modelDesc == null) { return errorRequest(cubeRequest, STR); } if (StringUtils.isEmpty(modelDesc.getName())) { return errorRequest(cubeRequest, STR); } try { DataModelDesc existingModel = metaManager.getDataModelDesc(modelDesc.getName()); if (existingModel == null) { metaManager.createDataModelDesc(modelDesc); } else { modelDesc.setLastModified(existingModel.getLastModified()); metaManager.updateDataModelDesc(modelDesc); } } catch (IOException e) { logger.error(STR + e.getLocalizedMessage(), e); throw new InternalErrorException(STR + e.getLocalizedMessage()); } CubeDesc desc = deserializeCubeDesc(cubeRequest); if (desc == null) { return cubeRequest; } if (StringUtils.isEmpty(desc.getName())) { logger.info(STR); return errorRequest(cubeRequest, STR); } try { desc.setUuid(UUID.randomUUID().toString()); String projectName = (null == cubeRequest.getProject()) ? ProjectInstance.DEFAULT_PROJECT_NAME : cubeRequest.getProject(); CubeInstance createdCube = cubeService.createCubeAndDesc(desc.getName(), projectName, desc); accessService.init(createdCube, AclPermission.ADMINISTRATION); ProjectInstance project = cubeService.getProjectManager().getProject(projectName); accessService.inherit(createdCube, project); } catch (Exception e) { logger.error(STR, e); throw new InternalErrorException(e.getLocalizedMessage(), e); } cubeRequest.setUuid(desc.getUuid()); cubeRequest.setSuccessful(true); return cubeRequest; }","old_code_raw":"@RequestMapping(value = STR, method = { RequestMethod.POST })\n@ResponseBody\npublic CubeRequest saveCubeDesc(@RequestBody CubeRequest cubeRequest) {\n    MetadataManager metaManager = MetadataManager.getInstance(KylinConfig.getInstanceFromEnv());\n    DataModelDesc modelDesc = deserializeDataModelDesc(cubeRequest);\n    if (modelDesc == null || StringUtils.isEmpty(modelDesc.getName())) {\n        return cubeRequest;\n    }\n    try {\n        DataModelDesc existingModel = metaManager.getDataModelDesc(modelDesc.getName());\n        if (existingModel == null) {\n            metaManager.createDataModelDesc(modelDesc);\n        } else {\n            modelDesc.setLastModified(existingModel.getLastModified());\n            metaManager.updateDataModelDesc(modelDesc);\n        }\n    } catch (IOException e) {\n        logger.error(STR + e.getLocalizedMessage(), e);\n        throw new InternalErrorException(STR + e.getLocalizedMessage());\n    }\n    CubeDesc desc = deserializeCubeDesc(cubeRequest);\n    if (desc == null) {\n        return cubeRequest;\n    }\n    String name = CubeService.getCubeNameFromDesc(desc.getName());\n    if (StringUtils.isEmpty(name)) {\n        logger.info(STR);\n        throw new BadRequestException(STR);\n    }\n    try {\n        desc.setUuid(UUID.randomUUID().toString());\n        String projectName = (null == cubeRequest.getProject()) ? ProjectInstance.DEFAULT_PROJECT_NAME : cubeRequest.getProject();\n        cubeService.createCubeAndDesc(name, projectName, desc);\n    } catch (Exception e) {\n        logger.error(STR, e);\n        throw new InternalErrorException(e.getLocalizedMessage(), e);\n    }\n    cubeRequest.setUuid(desc.getUuid());\n    cubeRequest.setSuccessful(true);\n    return cubeRequest;\n}","new_comment_raw":"@return cubeRequest cube change request","old_comment_raw":"@return Table metadata array","label":1,"pre_label":0,"AST_level":8,"line_counts":46,"new_code_token_num":321},{"new_code_raw":"public boolean start(final FileDownloadListener listener, final boolean isSerial) { if (listener == null) { FileDownloadLog.w(this, \"Tasks with the listener can't start, because the listener \" + \"provided is null: [null, %B]\", isSerial); return false; } return isSerial ? startSerialTasks(listener) : startParallelTasks(listener); }","old_code_raw":"    public boolean start(final FileDownloadListener listener, final boolean isSerial) {\n\n        if (listener == null) {\n            FileDownloadLog.w(this, \"Tasks with the listener can't start, because the listener \" +\n                    \"provided is null: [null, %B]\", isSerial);\n            return false;\n        }\n\n        final List<BaseDownloadTask> list = FileDownloadList.getImpl().copy(listener);\n\n        if (FileDownloadMonitor.isValid()) {\n            FileDownloadMonitor.getMonitor().onRequestStart(list.size(), isSerial, listener);\n        }\n\n        if (FileDownloadLog.NEED_LOG) {\n            FileDownloadLog.v(this, \"start list size[%d] listener[%s] isSerial[%B]\", list.size(),\n                    listener, isSerial);\n        }\n\n        if (null == list || list.isEmpty()) {\n            FileDownloadLog.w(this, \"Tasks with the listener can't start, because can't find any \" +\n                    \"task with the provided listener: [%s, %B]\", listener, isSerial);\n            return false;\n        }\n\n        if (isSerial) {\n            \/\/ serial\n            final Handler serialHandler = createSerialHandler(list);\n            Message msg = serialHandler.obtainMessage();\n            msg.what = WHAT_SERIAL_NEXT;\n            msg.arg1 = 0;\n            serialHandler.sendMessage(msg);\n            synchronized (RUNNING_SERIAL_MAP) {\n                RUNNING_SERIAL_MAP.put(listener, serialHandler);\n            }\n        } else {\n            \/\/ parallel\n            for (final BaseDownloadTask downloadTask : list) {\n                downloadTask.start();\n            }\n        }\n\n        return true;\n    }\n","new_comment_raw":"@return Whether start tasks successfully.","old_comment_raw":"@return Whether start tasks successfully.","label":0,"pre_label":1,"AST_level":8,"line_counts":12,"new_code_token_num":73},{"new_code_raw":"public float get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }","old_code_raw":"public float get(WithAttributes attributes) {\n    return attributes.getAttributes().get(this);\n}","new_comment_raw":"@return the value of this attribute if this attribute is present in the extracted map. Otherwise {@link #getDefaultValue()}","old_comment_raw":"@return the value of this attribute if this attribute is present in the map. Otherwise {@link #getDefaultValue()}","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":19},{"new_code_raw":"public WebDriver augment(WebDriver driver) { \/\/ TODO(simon): We should really add a \"SelfDescribing\" interface for this if (!(driver instanceof RemoteWebDriver)) { return driver; } Map<String, ?> capabilities = ((RemoteWebDriver) driver).getCapabilities().asMap(); CompoundHandler handler = new CompoundHandler((RemoteWebDriver) driver); for (Map.Entry<String, ?> capablityName : capabilities.entrySet()) { AugmenterProvider augmenter = augmentors.get(capablityName.getKey()); if (augmenter == null) { continue; } Object value = capablityName.getValue(); if (value instanceof Boolean && !((Boolean) value).booleanValue()) { continue; } handler.addCapabilityHander(augmenter.getDescribedInterface(), augmenter.getImplementation(value)); } if (handler.isNeedingApplication()) { \/\/ Gather the existing interfaces Set<Class<?>> interfaces = new HashSet<Class<?>>(); interfaces.addAll(handler.getInterfaces()); interfaces.addAll(getInterfacesFrom(driver.getClass())); Enhancer enhancer = new Enhancer(); enhancer.setInterfaces(interfaces.toArray(new Class<?>[interfaces.size()])); enhancer.setCallback(handler); enhancer.setSuperclass(driver.getClass()); RemoteWebDriver remote = (RemoteWebDriver) enhancer.create(); remote.setCommandExecutor(((RemoteWebDriver) driver).getCommandExecutor()); remote.setElementConverter(((RemoteWebDriver) driver).getElementConverter()); return remote; } return driver; }","old_code_raw":"  public WebDriver augment(WebDriver driver) {\n    \/\/ TODO(simon): We should really add a \"SelfDescribing\" interface for this\n    if (!(driver instanceof RemoteWebDriver)) {\n      return driver;\n    }\n\n    Map<String, ?> capabilities = ((RemoteWebDriver) driver).getCapabilities().asMap();\n\n    CompoundHandler handler = new CompoundHandler((RemoteWebDriver) driver);\n\n    for (Map.Entry<String, ?> capablityName : capabilities.entrySet()) {\n      AugmenterProvider augmenter = augmentors.get(capablityName.getKey());\n      if (augmenter == null) {\n        continue;\n      }\n\n      Object value = capablityName.getValue();\n      if (value instanceof Boolean && !((Boolean) value).booleanValue()) {\n        continue;\n      }\n\n      handler.addCapabilityHander(augmenter.getDescribedInterface(),\n          augmenter.getImplementation(value));\n    }\n\n    if (handler.isNeedingApplication()) {\n      \/\/ Gather the existing interfaces\n      Set<Class<?>> interfaces = new HashSet<Class<?>>();\n      interfaces.addAll(handler.getInterfaces());\n      interfaces.addAll(getInterfacesFrom(driver.getClass()));\n\n      return (WebDriver) Proxy.newProxyInstance(getClass().getClassLoader(),\n          interfaces.toArray(new Class<?>[interfaces.size()]), handler);\n    }\n\n    return driver;\n  }\n","new_comment_raw":"@return A class implementing the described interfaces.","old_comment_raw":"@return A class implementing the described interfaces.","label":0,"pre_label":1,"AST_level":11,"line_counts":45,"new_code_token_num":281},{"new_code_raw":"protected IListFrame createListFrame(SQLElement elem) { return null; }","old_code_raw":"protected IListFrame createListFrame(SQLElement elem) {\n    return new IListFrame(new ListeModifyPanel(elem));\n}","new_comment_raw":"@return the frame to be displayed, <code>null<\/code> to keep the default value.","old_comment_raw":"@return the frame to be displayed.","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":12},{"new_code_raw":"public String fakeOuterStringSerialize(String body) throws ApiException { Object localVarPostBody = body; \/\/ create path and map variables String localVarPath = \"\/fake\/outer\/string\"; \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<String> localVarReturnType = new GenericType<String>() {}; return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public String fakeOuterStringSerialize(String body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/fake\/outer\/string\";\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<String> localVarReturnType = new GenericType<String>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@return String","old_comment_raw":"@return String","label":0,"pre_label":1,"AST_level":8,"line_counts":31,"new_code_token_num":166},{"new_code_raw":"public Object next() throws java.io.IOException { int zzInput; int zzAction; \/\/ cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { \/\/ store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); \/\/ get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } \/\/ store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 38: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } if (normalizeSpace) { \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, yytext()); } case 55: break; case 43: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 9; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 10; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/\/ try to work around an apparent jflex bug where it \/\/ gets a space at the token end by getting \/\/ wrong the length of the trailing context. while (yylength() > 0) { char last = yycharat(yylength()-1); if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) { yypushback(1); } else { break; } } return getNext(); } case 56: break; case 11: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 57: break; case 19: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 58: break; case 8: { return handleQuotes(yytext(), false); } case 59: break; case 35: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), false); } case 60: break; case 27: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 61: break; case 33: \/\/ lookahead expression with fixed lookahead length yypushback(1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 62: break; case 49: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return getNormalizedAmpNext(); } case 63: break; case 36: { return getNormalizedAmpNext(); } case 64: break; case 23: { if (invertible) { prevWordAfter.append(yytext()); } } case 65: break; case 37: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } if (normalizeSpace) { \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, yytext()); } case 66: break; case 53: \/\/ lookahead expression with fixed lookahead length yypushback(4); { return getNext(); } case 67: break; case 46: \/\/ lookahead expression with fixed lookahead length yypushback(2); { return getNext(); } case 68: break; case 42: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 69: break; case 41: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 16; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 17; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 70: break; case 40: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 13; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 71: break; case 3: { return getNext(); } case 72: break; case 24: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return getNext(); } case 73: break; case 51: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } return getNext(txt, yytext()); } case 74: break; case 26: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, origTxt); } case 75: break; case 6: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 76: break; case 29: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 77: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 78: break; case 2: { return getNext(\"<\", yytext()); } case 79: break; case 48: { yypushback(2) ; return getNext(); } case 80: break; case 30: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 81: break; case 18: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 82: break; case 54: { String txt = yytext(); if (normalizeSpace) { \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 83: break; case 50: { yypushback(3) ; return getNext(); } case 84: break; case 25: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), true); } case 85: break; case 39: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 86: break; case 21: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 87: break; case 17: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 88: break; case 13: { return handleEllipsis(yytext()); } case 89: break; case 34: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 1; { \/* invert quote - often but not always right *\/ return handleQuotes(yytext(), true); } case 90: break; case 14: { return normalizeFractions(yytext()); } case 91: break; case 15: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(); } } case 92: break; case 47: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 11; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 12; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 93: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 94: break; case 9: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 95: break; case 45: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 96: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 97: break; case 28: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 98: break; case 20: { if (normalizeOtherBrackets) { return getNext(\"-RSB-\", yytext()); } else { return getNext(); } } case 99: break; case 12: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 100: break; case 31: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 101: break; case 10: { return getNext(\">\", yytext()); } case 102: break; case 32: { \/\/ this one should only match if we're basically at the end of file \/\/ since the last one matches two things, even newlines String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 103: break; case 22: { if (normalizeOtherBrackets) { return getNext(\"-LSB-\", yytext()); } else { return getNext(); } } case 104: break; case 52: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/\/ try to work around an apparent jflex bug where it \/\/ gets a space at the token end by getting \/\/ wrong the length of the trailing context. while (yylength() > 0) { char last = yycharat(yylength()-1); if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) { yypushback(1); } else { break; } } String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 105: break; case 1: { String str = yytext(); int first = str.charAt(0); String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } LOGGER.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: LOGGER.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 106: break; case 44: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 107: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 108: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }","old_code_raw":"  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    \/\/ cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            \/\/ store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            \/\/ get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          int zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      \/\/ store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 39: \n          { String txt = yytext();\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '\/');\n                  }\n                  if (normalizeSpace) {\n                    \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                    txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n\n                  }\n                  return getNext(txt, yytext());\n          }\n        case 55: break;\n        case 43: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 9;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 10;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { \/\/ try to work around an apparent jflex bug where it\n                          \/\/ gets a space at the token end by getting\n                          \/\/ wrong the length of the trailing context.\n                          while (yylength() > 0) {\n                            char last = yycharat(yylength()-1);\n                            if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) {\n                              yypushback(1);\n                            } else {\n                              break;\n                            }\n                          }\n\t\t\t  return getNext();\n          }\n        case 56: break;\n        case 11: \n          { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 57: break;\n        case 19: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 58: break;\n        case 36: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return handleQuotes(yytext(), false);\n          }\n        case 59: break;\n        case 8: \n          { return handleQuotes(yytext(), false);\n          }\n        case 60: break;\n        case 28: \n          { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n          }\n        case 61: break;\n        case 34: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n          }\n        case 62: break;\n        case 49: \n          { if (splitAssimilations) {\n                            yypushback(2) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 63: break;\n        case 50: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNormalizedAmpNext();\n          }\n        case 64: break;\n        case 37: \n          { return getNormalizedAmpNext();\n          }\n        case 65: break;\n        case 23: \n          { if (invertible) {\n                            prevWordAfter.append(yytext());\n                        }\n          }\n        case 66: break;\n        case 38: \n          { String txt = yytext();\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '\/');\n                  }\n                  if (normalizeSpace) {\n                    \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                    txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                  }\n                  return getNext(txt, yytext());\n          }\n        case 67: break;\n        case 53: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(4);\n          { return getNext();\n          }\n        case 68: break;\n        case 47: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(2);\n          { return getNext();\n          }\n        case 69: break;\n        case 46: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 7;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 8;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { \/\/ try to work around an apparent jflex bug where it\n                          \/\/ gets a space at the token end by getting\n                          \/\/ wrong the length of the trailing context.\n                          while (yylength() > 0) {\n                            char last = yycharat(yylength()-1);\n                            if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) {\n                              yypushback(1);\n                            } else {\n                              break;\n                            }\n                          }\n                          String s;\n\t\t\t  if (yylength() == 2) { \/\/ \"I.\", etc.\n\t\t\t    yypushback(1); \/\/ return a period next time;\n\t\t\t    s = yytext(); \/\/ return the word without the final period\n                          } else if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext(); \/\/ return the word without the final period\n                          } else {\n                            s = yytext(); \/\/ return the word WITH the final period\n                            yypushback(1); \/\/ (redpulication:) also return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 70: break;\n        case 42: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 15;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 14;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 71: break;\n        case 41: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 16;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 17;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 72: break;\n        case 3: \n          { return getNext();\n          }\n        case 73: break;\n        case 24: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 13;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 14;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 74: break;\n        case 25: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext();\n          }\n        case 75: break;\n        case 52: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 76: break;\n        case 27: \n          { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n          }\n        case 77: break;\n        case 6: \n          { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n          }\n        case 78: break;\n        case 30: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 3;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 4;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n          }\n        case 79: break;\n        case 16: \n          { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 80: break;\n        case 2: \n          { return getNext(\"<\", yytext());\n          }\n        case 81: break;\n        case 31: \n          { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '\/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 82: break;\n        case 18: \n          { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 83: break;\n        case 54: \n          { String txt = yytext();\n                          if (normalizeSpace) {\n                            \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 84: break;\n        case 26: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return handleQuotes(yytext(), true);\n          }\n        case 85: break;\n        case 40: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 5;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 6;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String txt = yytext();\n                          return getNext(removeSoftHyphens(txt),\n                                         txt);\n          }\n        case 86: break;\n        case 21: \n          { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 87: break;\n        case 51: \n          { if (splitAssimilations) {\n                            yypushback(3) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 88: break;\n        case 17: \n          { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 89: break;\n        case 13: \n          { return handleEllipsis(yytext());\n          }\n        case 90: break;\n        case 35: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 1;\n          { \/* invert quote - often but not always right *\/\n                  return handleQuotes(yytext(), true);\n          }\n        case 91: break;\n        case 14: \n          { return normalizeFractions(yytext());\n          }\n        case 92: break;\n        case 15: \n          { if (normalizeCurrency) {\n                            return getNext(normalizeCurrency(yytext()), yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 93: break;\n        case 48: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 11;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 12;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 94: break;\n        case 7: \n          { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n          }\n        case 95: break;\n        case 9: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '\/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 96: break;\n        case 45: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext(removeSoftHyphens(yytext()),\n                                               yytext());\n          }\n        case 97: break;\n        case 4: \n          { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n          }\n        case 98: break;\n        case 29: \n          { return getNext(removeSoftHyphens(yytext()), yytext());\n          }\n        case 99: break;\n        case 20: \n          { if (normalizeOtherBrackets) {\n                    return getNext(\"-RSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 100: break;\n        case 12: \n          { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n          }\n        case 101: break;\n        case 32: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n          }\n        case 102: break;\n        case 10: \n          { return getNext(\">\", yytext());\n          }\n        case 103: break;\n        case 33: \n          { \/\/ this one should only match if we're basically at the end of file\n                          \/\/ since the last one matches two things, even newlines\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 104: break;\n        case 22: \n          { if (normalizeOtherBrackets) {\n                    return getNext(\"-LSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 105: break;\n        case 1: \n          { String str = yytext();\n          int first = str.charAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n          }\n        case 106: break;\n        case 44: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 107: break;\n        case 5: \n          { if (tokenizeNLs) {\n                      return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns\n                  } else if (invertible) {\n                      prevWordAfter.append(yytext());\n                  }\n          }\n        case 108: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                if (invertible) {\n            prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            prevWordAfter.setLength(0);\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n          }\n          return null;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n","new_comment_raw":"@return the next token","old_comment_raw":"@return the next token","label":0,"pre_label":1,"AST_level":17,"line_counts":698,"new_code_token_num":4291},{"new_code_raw":"public final double getValue(long timestamp) { compute(timestamp, timestamp); Score s = getComputedByTimestamp(timestamp); if (s == null) throw new IllegalStateException(); return s.getValue(); }","old_code_raw":"public int getValue(long timestamp) {\n    computeAll();\n    String[] args = { habit.getId().toString(), Long.toString(timestamp) };\n    return SQLiteUtils.intQuery(STR, args);\n}","new_comment_raw":"@return score value for that day","old_comment_raw":"@return score for that day","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":41},{"new_code_raw":"public Property weekOfWeekyear() { return new Property(this, getChronology().weekOfWeekyear()); }","old_code_raw":"    public ReadWritableInstantFieldProperty weekOfWeekyear() {\n        return new ReadWritableInstantFieldProperty(this, getChronology().weekOfWeekyear());\n    }\n","new_comment_raw":"@return the week of a week based year property","old_comment_raw":"@return the week of a week based year property","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":21},{"new_code_raw":"public MergedSelectionSet collectFields(FieldCollectorParameters parameters, SelectionSet selectionSet) { Map<String, MergedFields> subFields = new LinkedHashMap<>(); List<String> visitedFragments = new ArrayList<>(); this.collectFields(parameters, selectionSet, visitedFragments, subFields); return newMergedSelectionSet().subFields(subFields).build(); }","old_code_raw":"    private void collectFields(FieldCollectorParameters parameters, SelectionSet selectionSet, List<String> visitedFragments, Map<String, MergedFields> fields) {\n\n        for (Selection selection : selectionSet.getSelections()) {\n            if (selection instanceof Field) {\n                collectField(parameters, fields, (Field) selection);\n            } else if (selection instanceof InlineFragment) {\n                collectInlineFragment(parameters, visitedFragments, fields, (InlineFragment) selection);\n            } else if (selection instanceof FragmentSpread) {\n                collectFragmentSpread(parameters, visitedFragments, fields, (FragmentSpread) selection);\n            }\n        }\n    }\n","new_comment_raw":"@return a map of the sub field selections","old_comment_raw":"@return a map of the sub field selections","label":0,"pre_label":1,"AST_level":6,"line_counts":7,"new_code_token_num":54},{"new_code_raw":"public Player asPlayer() { return Bukkit.getPlayer(raw); }","old_code_raw":"public Player asPlayer() {\n    return Bukkit.getPlayer(arg);\n}","new_comment_raw":"@return The player by the name of the raw raw - null if (s)he isn't online","old_comment_raw":"@return The player by the name of the raw arg - null if (s)he isn't online","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":14},{"new_code_raw":"public String loginUser(String username, String password) throws RestClientException { return loginUserWithHttpInfo(username, password).getBody(); }","old_code_raw":"    public String loginUser(String username, String password) throws RestClientException {\n        Object postBody = null;\n        \n        \/\/ verify the required parameter 'username' is set\n        if (username == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'username' when calling loginUser\");\n        }\n        \n        \/\/ verify the required parameter 'password' is set\n        if (password == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'password' when calling loginUser\");\n        }\n        \n        String path = apiClient.expandPath(\"\/user\/login\", Collections.<String, Object>emptyMap());\n\n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        queryParams.putAll(apiClient.parameterToMultiValueMap(null, \"username\", username));\n        queryParams.putAll(apiClient.parameterToMultiValueMap(null, \"password\", password));\n\n        final String[] accepts = { \n            \"application\/xml\", \"application\/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<String> returnType = new ParameterizedTypeReference<String>() {};\n        return apiClient.invokeAPI(path, HttpMethod.GET, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n","new_comment_raw":"@return String","old_comment_raw":"@return String","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":25},{"new_code_raw":"public Collection getDistancesMap(Group run, String year) { IWContext iwc = IWContext.getInstance(); Map disMap = new LinkedHashMap(); Collection distances = null; Collection type = new ArrayList(); type.add(IWMarathonConstants.GROUP_TYPE_RUN_DISTANCE); Iterator yearsIter = getYears(run).iterator(); while (yearsIter.hasNext()) { Group y = (Group) yearsIter.next(); if (y.getName().equals(year)) { try { distances = getGroupBiz(iwc).getChildGroupsRecursiveResultFiltered(y, type, true); } catch (Exception e) { distances = null; } } } return distances; }","old_code_raw":"public Map getDistancesMap(Group run, String year) {\n    IWContext iwc = IWContext.getInstance();\n    Map disMap = new LinkedHashMap();\n    Collection distances = null;\n    Collection type = new ArrayList();\n    type.add(IWMarathonConstants.GROUP_TYPE_RUN_DISTANCE);\n    Iterator yearsIter = getYears(run).iterator();\n    while (yearsIter.hasNext()) {\n        Group y = (Group) yearsIter.next();\n        if (y.getName().equals(year)) {\n            try {\n                distances = getGroupBiz(iwc).getChildGroupsRecursiveResultFiltered(y, type, true);\n            } catch (Exception e) {\n                distances = null;\n            }\n        } else {\n            distances = null;\n        }\n    }\n    if (distances != null) {\n        Iterator disIter = distances.iterator();\n        while (disIter.hasNext()) {\n            Group dis = (Group) disIter.next();\n            disMap.put(dis.getPrimaryKey().toString(), dis.getName());\n        }\n    }\n    return disMap;\n}","new_comment_raw":"@return Collection of all distances for a specific run on a specific year","old_comment_raw":"@return Map of all distances for a specific run on a specific year","label":1,"pre_label":0,"AST_level":12,"line_counts":19,"new_code_token_num":116},{"new_code_raw":"public ArrayList<Activity> getAllOpenedActivities() { return activitiyUtils.getAllOpenedActivities(); }","old_code_raw":"\tpublic ArrayList<Activity> getAllOpenedActivities()\n\t{\n\t\treturn ensureArrayListOrNull(activitiyUtils.getAllOpenedActivities());\n\t}\n","new_comment_raw":"@return an  ArrayList of all the opened\/active activities","old_comment_raw":"@return an ArrayList of all the opened\/active activities","label":0,"pre_label":1,"AST_level":5,"line_counts":5,"new_code_token_num":14},{"new_code_raw":"public static SecureConnectionMode parse(String value, String defaultValue) { SecureConnectionMode mode = parse(value); if (mode == null && defaultValue != null) mode = parse(defaultValue); return mode; }","old_code_raw":"        public static SnapshotMode parse(String value, String defaultValue) {\n            SnapshotMode mode = parse(value);\n            if (mode == null && defaultValue != null) mode = parse(defaultValue);\n            return mode;\n        }\n","new_comment_raw":"@return the matching option, or null if no match is found and the non-null default is invalid","old_comment_raw":"@return the matching option, or null if no match is found and the non-null default is invalid","label":0,"pre_label":1,"AST_level":7,"line_counts":6,"new_code_token_num":39},{"new_code_raw":"private static FunctionExprNode createLikeFunctionExprNode(String fieldName, LikeFilter likeFilter) { if (likeFilter == null) { return null; } return new FunctionExprNode(LIKE_FUNCTION, likeFilter.hasEscape() ? ImmutableList.of( new FieldExprNode(fieldName), new ConstantExprNode(likeFilter.getPattern()), new ConstantExprNode(likeFilter.getEscape())) : ImmutableList.of( new FieldExprNode(fieldName), new ConstantExprNode(likeFilter.getPattern())) ); }","old_code_raw":"  private static FunctionExprNode createLikeFunctionExprNode(String fieldName, LikeFilter likeFilter) {\n    if (likeFilter == null) {\n      return null;\n    }\n\n    return new FunctionExprNode(LIKE_FUNCTION,\n        likeFilter.hasEscape() ?\n            ImmutableList.of(\n                new FieldExprNode(fieldName),\n                new ConstantExprNode(likeFilter.getRegex()),\n                new ConstantExprNode(likeFilter.getEscape())) :\n            ImmutableList.of(\n                new FieldExprNode(fieldName),\n                new ConstantExprNode(likeFilter.getRegex()))\n    );\n  }\n","new_comment_raw":"@return  FunctionExprNode for given arguments. Null if the likeFilter is null.","old_comment_raw":"@return FunctionExprNode for given arguments. Null if the likeFilter is null.","label":0,"pre_label":1,"AST_level":8,"line_counts":17,"new_code_token_num":82},{"new_code_raw":"private boolean isAncestorOf(Object object1, Object object2) { if (object2 == null) return false; Object parent = getParent(object2); if (parent == object1) return true; return isAncestorOf(object1, parent); }","old_code_raw":"private boolean isAncestorOf(Object node, Object target) {\n    if (target == null)\n        return false;\n    Object parent = getParent(target);\n    if (parent == node)\n        return true;\n    return isAncestorOf(node, parent);\n}","new_comment_raw":"@return true if the first object is the ancestor of the second object2.","old_comment_raw":"@return true if the node is an ancestor of the target node.","label":1,"pre_label":0,"AST_level":6,"line_counts":8,"new_code_token_num":43},{"new_code_raw":"public Annotation readUndelimited(File in) throws IOException { FileInputStream delimited = new FileInputStream(in); FileInputStream undelimited = new FileInputStream(in); CoreNLPProtos.Document doc; try { doc = CoreNLPProtos.Document.parseFrom(delimited); } catch (Exception e) { doc = CoreNLPProtos.Document.parseDelimitedFrom(undelimited); } finally { delimited.close(); undelimited.close(); } return fromProto(doc); }","old_code_raw":"  public Annotation readUndelimited(InputStream is) throws IOException {\n    return fromProto(CoreNLPProtos.Document.parseDelimitedFrom(is));\n  }\n","new_comment_raw":"@return A parsed Annotation.","old_comment_raw":"@return A parsed Annotation.","label":0,"pre_label":1,"AST_level":8,"line_counts":15,"new_code_token_num":76},{"new_code_raw":"public Category getCategory() { if (payload != null) { return payload.category; } return null; }","old_code_raw":"public Category getCategory() {\n    return payload.category;\n}","new_comment_raw":"@return The category else return null","old_comment_raw":"@return The category","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":22},{"new_code_raw":"public SessionFactory getSessionFactory() { return daoTest.getSessionFactory(); }","old_code_raw":"    public SessionFactory getSessionFactory() {\n        return sessionFactory;\n    }\n","new_comment_raw":"@return  SessionFactory with an open session.","old_comment_raw":"@return SessionFactory with an open session.","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":13},{"new_code_raw":"private ObjectNode getSelectedRegionJson(Cluster cluster, String selectedRegionFullPath) { PulseLogWriter LOGGER = PulseLogWriter.getLogger(); Long totalHeapSize = cluster.getTotalHeapSize(); Long totalDiskUsage = cluster.getTotalBytesOnDisk(); Cluster.Region reg = cluster.getClusterRegion(selectedRegionFullPath); if (reg != null) { ObjectNode regionJSON = mapper.createObjectNode(); regionJSON.put(STR, reg.getName()); regionJSON.put(STR, reg.getFullPath()); regionJSON.put(STR, totalHeapSize); regionJSON.put(STR, reg.getSystemRegionEntryCount()); regionJSON.put(STR, reg.getMemberCount()); final String regionType = reg.getRegionType(); regionJSON.put(STR, regionType); regionJSON.put(STR, reg.getGetsRate()); regionJSON.put(STR, reg.getPutsRate()); regionJSON.put(STR, reg.getLruEvictionRate()); DecimalFormat df2 = new DecimalFormat(PulseConstants.DECIMAL_FORMAT_PATTERN); Cluster.Member[] clusterMembersList = cluster.getMembers(); List<Cluster.Member> clusterMembersL = new ArrayList<Cluster.Member>(); for (String memberName : reg.getMemberName()) { for (Cluster.Member member : clusterMembersList) { String name = member.getName(); name = name.replace(STR, STR); String id = member.getId(); id = id.replace(STR, STR); if ((memberName.equals(id)) || (memberName.equals(name))) { clusterMembersL.add(member); } } } Collections.sort(clusterMembersL, memberCurrentHeapUsageComparator); ArrayNode memberArray = mapper.createArrayNode(); for (Cluster.Member member : clusterMembersL) { ObjectNode regionMember = mapper.createObjectNode(); regionMember.put(STR, member.getId()); regionMember.put(STR, member.getName()); regionMember.put(STR, member.getHost()); long usedHeapSize = cluster.getUsedHeapSize(); long currentHeap = member.getCurrentHeapSize(); if (usedHeapSize > NUM) { float heapUsage = ((float) currentHeap \/ (float) usedHeapSize) * NUM; regionMember.put(STR, Double.valueOf(df2.format(heapUsage))); } else { regionMember.put(STR, NUM); } Float currentCPUUsage = member.getCpuUsage(); regionMember.put(STR, Float.valueOf(df2.format(currentCPUUsage))); regionMember.put(STR, member.getCurrentHeapSize()); regionMember.put(STR, member.isManager()); regionMember.put(STR, TimeUtils.convertTimeSecondsToHMS(member.getUptime())); regionMember.put(STR, member.getLoadAverage()); regionMember.put(STR, member.getTotalFileDescriptorOpen()); regionMember.put(STR, member.getNumThreads()); if (PulseController.getPulseProductSupport().equalsIgnoreCase(PulseConstants.PRODUCT_NAME_SQLFIRE)) { regionMember.put(STR, member.getNumSqlfireClients()); } else { regionMember.put(STR, member.getMemberClientsHMap().size()); } regionMember.put(STR, member.getQueueBacklog()); memberArray.add(regionMember); } regionJSON.put(STR, memberArray); regionJSON.put(STR, reg.getSystemRegionEntryCount()); regionJSON.put(STR, reg.getPersistentEnabled() ? PulseService.VALUE_ON : PulseService.VALUE_OFF); regionJSON.put(STR, reg.isEnableOffHeapMemory() ? PulseService.VALUE_ON : PulseService.VALUE_OFF); if (regionType.startsWith(STR)) { regionJSON.put(STR, reg.isHdfsWriteOnly() ? PulseService.VALUE_ON : PulseService.VALUE_OFF); } else { regionJSON.put(STR, PulseService.VALUE_NA); } String regCompCodec = reg.getCompressionCodec(); if (StringUtils.isNotNullNotEmptyNotWhiteSpace(regCompCodec)) { regionJSON.put(STR, reg.getCompressionCodec()); } else { regionJSON.put(STR, PulseService.VALUE_NA); } if (PulseConstants.PRODUCT_NAME_SQLFIRE.equalsIgnoreCase(PulseController.getPulseProductSupport())) { regionJSON.put(STR, StringUtils.getTableNameFromRegionName(reg.getFullPath())); } else { regionJSON.put(STR, reg.getFullPath()); } regionJSON.put(STR, mapper.valueToTree(reg.getRegionStatisticTrend(Cluster.Region.REGION_STAT_GETS_PER_SEC_TREND))); regionJSON.put(STR, mapper.valueToTree(reg.getRegionStatisticTrend(Cluster.Region.REGION_STAT_PUTS_PER_SEC_TREND))); regionJSON.put(STR, mapper.valueToTree(reg.getRegionStatisticTrend(Cluster.Region.REGION_STAT_DISK_READS_PER_SEC_TREND))); regionJSON.put(STR, mapper.valueToTree(reg.getRegionStatisticTrend(Cluster.Region.REGION_STAT_DISK_WRITES_PER_SEC_TREND))); regionJSON.put(STR, reg.getEmptyNode()); Long entrySize = reg.getEntrySize(); DecimalFormat form = new DecimalFormat(PulseConstants.DECIMAL_FORMAT_PATTERN_2); String entrySizeInMB = form.format(entrySize \/ (NUM * NUM)); if (entrySize < NUM) { regionJSON.put(this.ENTRY_SIZE, PulseService.VALUE_NA); } else { regionJSON.put(this.ENTRY_SIZE, entrySizeInMB); } regionJSON.put(STR, reg.getDiskUsage()); regionJSON.put(STR, reg.getWanEnabled()); regionJSON.put(STR, totalDiskUsage); regionJSON.put(STR, entrySizeInMB); LOGGER.fine(STR + regionJSON); return regionJSON; } else { ObjectNode responseJSON = mapper.createObjectNode(); responseJSON.put(STR, STR + selectedRegionFullPath + STR); return responseJSON; } }","old_code_raw":"private JSONObject getSelectedRegionJson(Cluster cluster, String selectedRegionFullPath) throws JSONException {\n    PulseLogWriter LOGGER = PulseLogWriter.getLogger();\n    Long totalHeapSize = cluster.getTotalHeapSize();\n    Long totalDiskUsage = cluster.getTotalBytesOnDisk();\n    Cluster.Region reg = cluster.getClusterRegion(selectedRegionFullPath);\n    if (reg != null) {\n        JSONObject regionJSON = new JSONObject();\n        regionJSON.put(STR, reg.getName());\n        regionJSON.put(STR, reg.getFullPath());\n        regionJSON.put(STR, totalHeapSize);\n        regionJSON.put(STR, reg.getSystemRegionEntryCount());\n        regionJSON.put(STR, reg.getMemberCount());\n        final String regionType = reg.getRegionType();\n        regionJSON.put(STR, regionType);\n        regionJSON.put(STR, reg.getGetsRate());\n        regionJSON.put(STR, reg.getPutsRate());\n        regionJSON.put(STR, reg.getLruEvictionRate());\n        DecimalFormat df2 = new DecimalFormat(PulseConstants.DECIMAL_FORMAT_PATTERN);\n        Cluster.Member[] clusterMembersList = cluster.getMembers();\n        List<Cluster.Member> clusterMembersL = new ArrayList<Cluster.Member>();\n        for (String memberName : reg.getMemberName()) {\n            for (Cluster.Member member : clusterMembersList) {\n                String name = member.getName();\n                name = name.replace(STR, STR);\n                String id = member.getId();\n                id = id.replace(STR, STR);\n                if ((memberName.equals(id)) || (memberName.equals(name))) {\n                    clusterMembersL.add(member);\n                }\n            }\n        }\n        Collections.sort(clusterMembersL, memberCurrentHeapUsageComparator);\n        JSONArray memberArray = new JSONArray();\n        for (Cluster.Member member : clusterMembersL) {\n            JSONObject regionMember = new JSONObject();\n            regionMember.put(STR, member.getId());\n            regionMember.put(STR, member.getName());\n            regionMember.put(STR, member.getHost());\n            long usedHeapSize = cluster.getUsedHeapSize();\n            long currentHeap = member.getCurrentHeapSize();\n            if (usedHeapSize > NUM) {\n                float heapUsage = ((float) currentHeap \/ (float) usedHeapSize) * NUM;\n                regionMember.put(STR, Double.valueOf(df2.format(heapUsage)));\n            } else {\n                regionMember.put(STR, NUM);\n            }\n            Float currentCPUUsage = member.getCpuUsage();\n            regionMember.put(STR, Float.valueOf(df2.format(currentCPUUsage)));\n            regionMember.put(STR, member.getCurrentHeapSize());\n            regionMember.put(STR, member.isManager());\n            regionMember.put(STR, TimeUtils.convertTimeSecondsToHMS(member.getUptime()));\n            regionMember.put(STR, member.getLoadAverage());\n            regionMember.put(STR, member.getTotalFileDescriptorOpen());\n            regionMember.put(STR, member.getNumThreads());\n            if (PulseController.getPulseProductSupport().equalsIgnoreCase(PulseConstants.PRODUCT_NAME_SQLFIRE)) {\n                regionMember.put(STR, member.getNumSqlfireClients());\n            } else {\n                regionMember.put(STR, member.getMemberClientsHMap().size());\n            }\n            regionMember.put(STR, member.getQueueBacklog());\n            memberArray.put(regionMember);\n        }\n        regionJSON.put(STR, memberArray);\n        regionJSON.put(STR, reg.getSystemRegionEntryCount());\n        Boolean persistent = reg.getPersistentEnabled();\n        if (persistent) {\n            regionJSON.put(STR, PulseService.VALUE_ON);\n        } else {\n            regionJSON.put(STR, PulseService.VALUE_OFF);\n        }\n        Boolean isEnableOffHeapMemory = reg.isEnableOffHeapMemory();\n        if (isEnableOffHeapMemory) {\n            regionJSON.put(STR, PulseService.VALUE_ON);\n        } else {\n            regionJSON.put(STR, PulseService.VALUE_OFF);\n        }\n        Boolean isHDFSWriteOnly = reg.isHdfsWriteOnly();\n        if (regionType.startsWith(STR)) {\n            if (isHDFSWriteOnly) {\n                regionJSON.put(STR, PulseService.VALUE_ON);\n            } else {\n                regionJSON.put(STR, PulseService.VALUE_OFF);\n            }\n        } else {\n            regionJSON.put(STR, PulseService.VALUE_NA);\n        }\n        String regCompCodec = reg.getCompressionCodec();\n        if (StringUtils.isNotNullNotEmptyNotWhiteSpace(regCompCodec)) {\n            regionJSON.put(STR, reg.getCompressionCodec());\n        } else {\n            regionJSON.put(STR, PulseService.VALUE_NA);\n        }\n        if (PulseConstants.PRODUCT_NAME_SQLFIRE.equalsIgnoreCase(PulseController.getPulseProductSupport())) {\n            regionJSON.put(STR, StringUtils.getTableNameFromRegionName(reg.getFullPath()));\n        } else {\n            regionJSON.put(STR, reg.getFullPath());\n        }\n        regionJSON.put(STR, new JSONArray(reg.getRegionStatisticTrend(Cluster.Region.REGION_STAT_GETS_PER_SEC_TREND)));\n        regionJSON.put(STR, new JSONArray(reg.getRegionStatisticTrend(Cluster.Region.REGION_STAT_PUTS_PER_SEC_TREND)));\n        regionJSON.put(STR, new JSONArray(reg.getRegionStatisticTrend(Cluster.Region.REGION_STAT_DISK_READS_PER_SEC_TREND)));\n        regionJSON.put(STR, new JSONArray(reg.getRegionStatisticTrend(Cluster.Region.REGION_STAT_DISK_WRITES_PER_SEC_TREND)));\n        regionJSON.put(STR, reg.getEmptyNode());\n        Long entrySize = reg.getEntrySize();\n        DecimalFormat form = new DecimalFormat(PulseConstants.DECIMAL_FORMAT_PATTERN_2);\n        String entrySizeInMB = form.format(entrySize \/ (NUM * NUM));\n        if (entrySize < NUM) {\n            regionJSON.put(this.ENTRY_SIZE, PulseService.VALUE_NA);\n        } else {\n            regionJSON.put(this.ENTRY_SIZE, entrySizeInMB);\n        }\n        regionJSON.put(STR, reg.getDiskUsage());\n        regionJSON.put(STR, reg.getWanEnabled());\n        regionJSON.put(STR, totalDiskUsage);\n        regionJSON.put(STR, entrySizeInMB);\n        LOGGER.fine(STR + regionJSON);\n        return regionJSON;\n    } else {\n        JSONObject responseJSON = new JSONObject();\n        responseJSON.put(STR, STR + selectedRegionFullPath + STR);\n        return responseJSON;\n    }\n}","new_comment_raw":"@return ObjectNode Array List","old_comment_raw":"@return JSONObject Array List","label":1,"pre_label":0,"AST_level":14,"line_counts":107,"new_code_token_num":941},{"new_code_raw":"public static long toEpochMicros(Object value) { LocalDateTime dateTime = Conversions.toLocalDateTime(value); long epochNanos = Conversions.toEpochNanos(dateTime); return Math.floorDiv(epochNanos, Conversions.NANOSECONDS_PER_MICROSECOND); }","old_code_raw":"    public static Long toEpochMicros(Object value) {\n        if ( value == null ) return null;\n        LocalDateTime dateTime = Conversions.toLocalDateTime(value);\n        long epochNanos = Conversions.toEpochNanos(dateTime);\n        return Math.floorDiv(epochNanos, Conversions.NANOSECONDS_PER_MICROSECOND);\n    }\n","new_comment_raw":"@return the epoch microseconds","old_comment_raw":"@return the epoch microseconds","label":0,"pre_label":1,"AST_level":6,"line_counts":6,"new_code_token_num":36},{"new_code_raw":"private boolean optimize(Visitor optimizer, boolean performInline) { int optimizeCount = 0; final UseCounter useCounter = new UseCounter(); for (Statement statement : statements) { if (statement instanceof DeclarationStatement && performInline) { DeclarationStatement decl = (DeclarationStatement) statement; useCounter.map.put(decl.parameter, new Slot()); } \/\/ We are added only counters up to current statement. \/\/ It is fine to count usages as the latter declarations cannot be used \/\/ in more recent statements. if (!useCounter.map.isEmpty()) { statement.accept(useCounter); } } final Map<ParameterExpression, Expression> subMap = new IdentityHashMap<ParameterExpression, Expression>( useCounter.map.size()); final SubstituteVariableVisitor visitor = new SubstituteVariableVisitor( subMap); final ArrayList<Statement> oldStatements = new ArrayList<Statement>( statements); statements.clear(); for (Statement oldStatement : oldStatements) { if (oldStatement instanceof DeclarationStatement) { DeclarationStatement statement = (DeclarationStatement) oldStatement; final Slot slot = useCounter.map.get(statement.parameter); int count = slot == null ? 100 : slot.count; if (count > 1 && isSafeForReuse(statement) && isSimpleExpression(statement.initializer)) { \/\/ Inline simple final constants count = 1; } if (statement.parameter.name.startsWith(\"_\")) { \/\/ Don't inline variables whose name begins with \"_\". This \/\/ is a hacky way to prevent inlining. E.g. \/\/ final int _count = collection.size(); \/\/ foo(collection); \/\/ return collection.size() - _count; count = 100; } if (statement.initializer instanceof NewExpression && ((NewExpression) statement.initializer).memberDeclarations != null) { \/\/ Don't inline anonymous inner classes. Janino gets \/\/ confused referencing variables from deeply nested \/\/ anonymous classes. count = 100; } Expression normalized = normalizeDeclaration(statement); expressionForReuse.remove(normalized); switch (count) { case 0: \/\/ Only declared, never used. Throw away declaration. break; case 1: \/\/ declared, used once. inline it. subMap.put(statement.parameter, normalized); break; default: Statement beforeOptimize = oldStatement; if (!subMap.isEmpty()) { oldStatement = oldStatement.accept(visitor); \/\/ remap } oldStatement = oldStatement.accept(optimizer); if (beforeOptimize != oldStatement) { ++optimizeCount; } if (oldStatement != OptimizeVisitor.EMPTY_STATEMENT) { if (oldStatement instanceof DeclarationStatement) { addExpresisonForReuse((DeclarationStatement) oldStatement); } statements.add(oldStatement); } break; } } else { Statement beforeOptimize = oldStatement; if (!subMap.isEmpty()) { oldStatement = oldStatement.accept(visitor); \/\/ remap } oldStatement = oldStatement.accept(optimizer); if (beforeOptimize != oldStatement) { ++optimizeCount; } if (oldStatement != OptimizeVisitor.EMPTY_STATEMENT) { statements.add(oldStatement); } } } return optimizeCount > 0; }","old_code_raw":"  private boolean optimize(Visitor optimizer, boolean performInline) {\n    boolean optimized = false;\n    final UseCounter useCounter = new UseCounter();\n    for (Statement statement : statements) {\n      if (statement instanceof DeclarationStatement && performInline) {\n        DeclarationStatement decl = (DeclarationStatement) statement;\n        useCounter.map.put(decl.parameter, new Slot());\n      }\n      \/\/ We are added only counters up to current statement.\n      \/\/ It is fine to count usages as the latter declarations cannot be used\n      \/\/ in more recent statements.\n      if (!useCounter.map.isEmpty()) {\n        statement.accept(useCounter);\n      }\n    }\n    final Map<ParameterExpression, Expression> subMap =\n        new IdentityHashMap<ParameterExpression, Expression>(\n            useCounter.map.size());\n    final SubstituteVariableVisitor visitor = new SubstituteVariableVisitor(\n        subMap);\n    final ArrayList<Statement> oldStatements = new ArrayList<Statement>(\n        statements);\n    statements.clear();\n\n    for (Statement oldStatement : oldStatements) {\n      if (oldStatement instanceof DeclarationStatement) {\n        DeclarationStatement statement = (DeclarationStatement) oldStatement;\n        final Slot slot = useCounter.map.get(statement.parameter);\n        int count = slot == null ? 100 : slot.count;\n        if (count > 1 && isSafeForReuse(statement)\n            && isSimpleExpression(statement.initializer)) {\n          \/\/ Inline simple final constants\n          count = 1;\n        }\n        if (statement.parameter.name.startsWith(\"_\")) {\n          \/\/ Don't inline variables whose name begins with \"_\". This\n          \/\/ is a hacky way to prevent inlining. E.g.\n          \/\/   final int _count = collection.size();\n          \/\/   foo(collection);\n          \/\/   return collection.size() - _count;\n          count = 100;\n        }\n        if (statement.initializer instanceof NewExpression\n            && ((NewExpression) statement.initializer).memberDeclarations\n                != null) {\n          \/\/ Don't inline anonymous inner classes. Janino gets\n          \/\/ confused referencing variables from deeply nested\n          \/\/ anonymous classes.\n          count = 100;\n        }\n        Expression normalized = normalizeDeclaration(statement);\n        expressionForReuse.remove(normalized);\n        switch (count) {\n        case 0:\n          \/\/ Only declared, never used. Throw away declaration.\n          break;\n        case 1:\n          \/\/ declared, used once. inline it.\n          subMap.put(statement.parameter, normalized);\n          break;\n        default:\n          Statement beforeOptimize = oldStatement;\n          if (!subMap.isEmpty()) {\n            oldStatement = oldStatement.accept(visitor); \/\/ remap\n          }\n          oldStatement = oldStatement.accept(optimizer);\n          optimized |= beforeOptimize != oldStatement;\n          if (oldStatement != OptimizeVisitor.EMPTY_STATEMENT) {\n            if (oldStatement instanceof DeclarationStatement) {\n              addExpresisonForReuse((DeclarationStatement) oldStatement);\n            }\n            statements.add(oldStatement);\n          }\n          break;\n        }\n      } else {\n        Statement beforeOptimize = oldStatement;\n        if (!subMap.isEmpty()) {\n          oldStatement = oldStatement.accept(visitor); \/\/ remap\n        }\n        oldStatement = oldStatement.accept(optimizer);\n        optimized |= beforeOptimize != oldStatement;\n        if (oldStatement != OptimizeVisitor.EMPTY_STATEMENT) {\n          statements.add(oldStatement);\n        }\n      }\n    }\n    return optimized;\n  }\n","new_comment_raw":"@return whether any optimizations were made","old_comment_raw":"@return if any optimizations were made or not","label":1,"pre_label":0,"AST_level":16,"line_counts":94,"new_code_token_num":547},{"new_code_raw":"public Network getNet() throws ErrorException { throw new ErrorException(STR); }","old_code_raw":"public VirNetwork getNet() throws VirErrorException {\n    throw new VirErrorException(STR);\n}","new_comment_raw":"@return Network object","old_comment_raw":"@return VirNetwork object","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":16},{"new_code_raw":"public QName getPortTypeName() { return portTypeName == null ? new QName(STR) : portTypeName; }","old_code_raw":"public QName getPortTypeName() {\n    return portName == null ? new QName(STR) : portName;\n}","new_comment_raw":"@return QName Fully qualified name of the port type","old_comment_raw":"@return QName Fully qualified name of the port","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":19},{"new_code_raw":"public List<Pet> findPetsByStatus(List<String> status) throws ApiException { Object localVarPostBody = null; \/\/ verify the required parameter 'status' is set if (status == null) { throw new ApiException(400, \"Missing the required parameter 'status' when calling findPetsByStatus\"); } \/\/ create path and map variables String localVarPath = \"\/pet\/findByStatus\".replaceAll(\"\\\\{format\\\\}\",\"json\"); \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, String> localVarCookieParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); localVarQueryParams.addAll(apiClient.parameterToPairs(\"csv\", \"status\", status)); final String[] localVarAccepts = { \"application\/xml\", \"application\/json\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { \"petstore_auth\" }; GenericType<List<Pet>> localVarReturnType = new GenericType<List<Pet>>() {}; return apiClient.invokeAPI(localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public List<Pet> findPetsByStatus(List<String> status) throws ApiException {\n    Object localVarPostBody = null;\n    \n    \/\/ verify the required parameter 'status' is set\n    if (status == null) {\n      throw new ApiException(400, \"Missing the required parameter 'status' when calling findPetsByStatus\");\n    }\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/pet\/findByStatus\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n    localVarQueryParams.addAll(apiClient.parameterToPairs(\"csv\", \"status\", status));\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application\/xml\", \"application\/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] { \"petstore_auth\" };\n\n    GenericType<List<Pet>> localVarReturnType = new GenericType<List<Pet>>() {};\n    return apiClient.invokeAPI(localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@return a  List","old_comment_raw":"@return a List","label":0,"pre_label":1,"AST_level":10,"line_counts":38,"new_code_token_num":258},{"new_code_raw":"public List<String> dependencyPathBetween(int start, int end, Optional<Function<Sentence, List<String>>> selector) { \/\/ Get paths from a node to the root of the sentence LinkedList<Integer> rootToStart = new LinkedList<>(); LinkedList<Integer> rootToEnd = new LinkedList<>(); int startAncestor = start; List<Optional<Integer>> governors = sentence.governors(); Set<Integer> seenVertices = new HashSet<>(); while (startAncestor >= 0 && governors.get(startAncestor).isPresent()) { if (seenVertices.contains(startAncestor)) { \/\/ Found loopiness -- revert to BFS return loopyDependencyPathBetween(start, end, selector); } seenVertices.add(startAncestor); rootToStart.addFirst(startAncestor); startAncestor = governors.get(startAncestor).get(); } if (startAncestor == -1) { rootToStart.addFirst(-1); } int endAncestor = end; seenVertices.clear(); while (endAncestor >= 0 && governors.get(endAncestor).isPresent()) { if (seenVertices.contains(endAncestor)) { \/\/ Found loopiness -- revert to BFS return loopyDependencyPathBetween(start, end, selector); } seenVertices.add(endAncestor); rootToEnd.addFirst(endAncestor); endAncestor = governors.get(endAncestor).get(); } if (endAncestor == -1) { rootToEnd.addFirst(-1); } \/\/ Get least common node int leastCommonNodeIndex = (rootToStart.size() == 0 || rootToEnd.size() == 0 || !rootToStart.get(0).equals(rootToEnd.get(0))) ? -1 : 0; for (int i = 1; i < Math.min(rootToStart.size(), rootToEnd.size()); ++i) { if (rootToStart.get(i).equals(rootToEnd.get(i))) { leastCommonNodeIndex = i; } } \/\/ Construct the path if (leastCommonNodeIndex < 0) { return Collections.emptyList(); } List<String> path = new ArrayList<>(); Optional<List<String>> words = selector.map(x -> x.apply(sentence)); for (int i = rootToStart.size() - 1; i > leastCommonNodeIndex; --i) { final int index = i; words.ifPresent(x -> path.add(x.get(rootToStart.get(index)))); path.add(\"<-\" + sentence.incomingDependencyLabel(rootToStart.get(i)).orElse(\"dep\") + \"-\"); } if (words.isPresent()) { path.add(words.get().get(rootToStart.get(leastCommonNodeIndex))); } for (int i = leastCommonNodeIndex + 1; i < rootToEnd.size(); ++i) { final int index = i; path.add(\"-\" + sentence.incomingDependencyLabel(rootToEnd.get(i)).orElse(\"dep\") + \"->\"); words.ifPresent(x -> path.add(x.get(rootToEnd.get(index)))); } return path; }","old_code_raw":"  public List<String> dependencyPathBetween(int start, int end, Function<Sentence, List<String>> selector) {\n    \/\/ Get paths from a node to the root of the sentence\n    LinkedList<Integer> rootToStart = new LinkedList<>();\n    LinkedList<Integer> rootToEnd = new LinkedList<>();\n    int startAncestor = start;\n    List<Optional<Integer>> governors = sentence.governors();\n    Set<Integer> seenVertices = new HashSet<>();\n    while (startAncestor >= 0 && governors.get(startAncestor).isPresent()) {\n      if (seenVertices.contains(startAncestor)) {\n        return Collections.EMPTY_LIST;\n      }\n      seenVertices.add(startAncestor);\n      rootToStart.addFirst(startAncestor);\n      startAncestor = governors.get(startAncestor).get();\n    }\n    if (startAncestor == -1) {\n      rootToStart.addFirst(-1);\n    }\n    int endAncestor = end;\n    seenVertices.clear();\n    while (endAncestor >= 0 && governors.get(endAncestor).isPresent()) {\n      if (seenVertices.contains(endAncestor)) {\n        return Collections.EMPTY_LIST;\n      }\n      seenVertices.add(endAncestor);\n      rootToEnd.addFirst(endAncestor);\n      endAncestor = governors.get(endAncestor).get();\n    }\n    if (endAncestor == -1) {\n      rootToEnd.addFirst(-1);\n    }\n\n    \/\/ Get least common node\n    int leastCommonNodeIndex = (rootToStart.size() == 0 || rootToEnd.size() == 0 || !rootToStart.get(0).equals(rootToEnd.get(0))) ? -1 : 0;\n    for (int i = 1; i < Math.min(rootToStart.size(), rootToEnd.size()); ++i) {\n      if (rootToStart.get(i).equals(rootToEnd.get(i))) {\n        leastCommonNodeIndex = i;\n      }\n    }\n\n    \/\/ Construct the path\n    if (leastCommonNodeIndex < 0) {\n      return Collections.EMPTY_LIST;\n    }\n    List<String> path = new ArrayList<>();\n    for (int i = rootToStart.size() - 1; i > leastCommonNodeIndex; --i) {\n      path.add(selector.apply(sentence).get(rootToStart.get(i)));\n      path.add(\"<-\" + sentence.incomingDependencyLabel(rootToStart.get(i)).orElse(\"dep\") + \"-\");\n    }\n    path.add(selector.apply(sentence).get(rootToStart.get(leastCommonNodeIndex)));\n    for (int i = leastCommonNodeIndex + 1; i < rootToEnd.size(); ++i) {\n      path.add(\"-\" + sentence.incomingDependencyLabel(rootToEnd.get(i)).orElse(\"dep\") + \"->\");\n      path.add(selector.apply(sentence).get(rootToEnd.get(i)));\n    }\n    return path;\n  }\n","new_comment_raw":"@return A list encoding the dependency path between the vertices, suitable for inclusion as features.","old_comment_raw":"@return The most common element of the given property in the sentence.","label":1,"pre_label":0,"AST_level":11,"line_counts":64,"new_code_token_num":555},{"new_code_raw":"protected Object convertTimeToMillisPastMidnightAsDate(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0L; \/\/ return epoch } try { return new java.util.Date(Time.toMilliOfDay(data)); } catch (IllegalArgumentException e) { return handleUnknownData(column, fieldDefn, data); } }","old_code_raw":"    protected Object convertTimeToMillisPastMidnightAsDate(Column column, Field fieldDefn, Object data) {\n        if ( data == null ) return null;\n        try {\n            return new java.util.Date(Time.toMilliOfDay(data));\n        } catch (IllegalArgumentException e) {\n            return handleUnknownData(column, fieldDefn, data);\n        }\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made","label":1,"pre_label":0,"AST_level":8,"line_counts":15,"new_code_token_num":88},{"new_code_raw":"public static IdentifierProperty buildIdentifierProperty(EntityBinding mappedEntity, IdentifierGenerator generator) { final SimpleAttributeBinding property = mappedEntity.getEntityIdentifier().getValueBinding(); \/\/ TODO: the following will cause an NPE with \"virtual\" IDs; how should they be set? final String mappedUnsavedValue = property.getUnsavedValue(); final Type type = property.getHibernateTypeDescriptor().getExplicitType(); IdentifierValue unsavedValue = UnsavedValueFactory.getUnsavedIdentifierValue( mappedUnsavedValue, getGetter( property ), type, getConstructor( mappedEntity ) ); if ( property == null ) { \/\/ this is a virtual id property... return new IdentifierProperty( type, mappedEntity.getEntityIdentifier().isEmbedded(), mappedEntity.getEntityIdentifier().isIdentifierMapper(), unsavedValue, generator ); } else { return new IdentifierProperty( property.getAttribute().getName(), property.getNodeName(), type, mappedEntity.getEntityIdentifier().isEmbedded(), unsavedValue, generator ); } }","old_code_raw":"\tpublic static IdentifierProperty buildIdentifierProperty(EntityBinding mappedEntity, IdentifierGenerator generator) {\n\n\t\tfinal SimpleAttributeBinding property = mappedEntity.getEntityIdentifier().getValueBinding();\n\n\t\t\/\/ TODO: the following will cause an NPE with \"virtual\" IDs; how should they be set?\n\t\tfinal String mappedUnsavedValue = property.getUnsavedValue();\n\t\tfinal Type type = property.getHibernateTypeDescriptor().getResolvedTypeMapping();\n\n\t\tIdentifierValue unsavedValue = UnsavedValueFactory.getUnsavedIdentifierValue(\n\t\t\t\tmappedUnsavedValue,\n\t\t\t\tgetGetter( property ),\n\t\t\t\ttype,\n\t\t\t\tgetConstructor( mappedEntity )\n\t\t\t);\n\n\t\tif ( property == null ) {\n\t\t\t\/\/ this is a virtual id property...\n\t\t\treturn new IdentifierProperty(\n\t\t\t        type,\n\t\t\t\t\tmappedEntity.getEntityIdentifier().isEmbedded(),\n\t\t\t\t\tmappedEntity.getEntityIdentifier().isIdentifierMapper(),\n\t\t\t\t\tunsavedValue,\n\t\t\t\t\tgenerator\n\t\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn new IdentifierProperty(\n\t\t\t\t\tproperty.getAttribute().getName(),\n\t\t\t\t\tnull,\n\t\t\t\t\ttype,\n\t\t\t\t\tmappedEntity.getEntityIdentifier().isEmbedded(),\n\t\t\t\t\tunsavedValue,\n\t\t\t\t\tgenerator\n\t\t\t\t);\n\t\t}\n\t}\n","new_comment_raw":"@return The appropriate IdentifierProperty definition.","old_comment_raw":"@return The appropriate IdentifierProperty definition.","label":0,"pre_label":1,"AST_level":8,"line_counts":37,"new_code_token_num":162},{"new_code_raw":"protected Object convertRowId(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return ByteBuffer.wrap(new byte[0]); } if (data instanceof java.sql.RowId) { java.sql.RowId row = (java.sql.RowId) data; return ByteBuffer.wrap(row.getBytes()); } return handleUnknownData(column, fieldDefn, data); }","old_code_raw":"    protected Object convertRowId(Column column, Field fieldDefn, Object data) {\n        if (data == null) return null;\n        if (data instanceof java.sql.RowId) {\n            java.sql.RowId row = (java.sql.RowId) data;\n            return ByteBuffer.wrap(row.getBytes());\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made","label":1,"pre_label":0,"AST_level":10,"line_counts":15,"new_code_token_num":100},{"new_code_raw":"public String toString() { long millis = getMillis(); StringBuffer buf = new StringBuffer(); buf.append(\"PT\"); FormatUtils.appendUnpaddedInteger(buf, millis \/ 1000); long part = Math.abs(millis % 1000); if (part > 0) { buf.append('.'); FormatUtils.appendPaddedInteger(buf, part, 3); } buf.append('S'); return buf.toString(); }","old_code_raw":"    public String toString() {\n        return ISOPeriodFormat.getInstance().standard().print(toPeriod());\n    }\n","new_comment_raw":"@return the value as an ISO8601 string","old_comment_raw":"@return the value as an ISO8601 string","label":0,"pre_label":1,"AST_level":7,"line_counts":14,"new_code_token_num":86},{"new_code_raw":"public float getX() { if (left == null) { calculateLeft(); } return left.floatValue(); }","old_code_raw":"public float getX() {\n    return center[NUM];\n}","new_comment_raw":"@return The x location of the left side of this shape.","old_comment_raw":"@return The x location of the center of this circle","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":24},{"new_code_raw":"public boolean isBoolean() { return raw.equals(STR) || raw.equals(STR); }","old_code_raw":"public boolean isBoolean() {\n    return arg.equals(STR) || arg.equals(STR);\n}","new_comment_raw":"@return Whether this ChatSection's value can be parsed as a boolean","old_comment_raw":"@return Whether this ChatSection's argument can be parsed as a boolean","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":21},{"new_code_raw":"@Override public Class<? extends Service> getInterface() { return PauseTransitService.class; }","old_code_raw":"@Override\npublic Class<? extends Service> getInterface() {\n    return BundlePauseStartService.class;\n}","new_comment_raw":"@return {@link PauseTransitService}.","old_comment_raw":"@return {@link BundlePauseStartService}.","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":16},{"new_code_raw":"public static String moveFile(UploadFile uploadFile) { if (uploadFile == null) return null; File file = uploadFile.getFile(); if (!file.exists()) { return null; } String webRoot = PathKit.getWebRootPath(); String uuid = UUID.randomUUID().toString().replace(\"-\", \"\"); StringBuilder newFileName = new StringBuilder(webRoot).append(File.separator).append(\"attachment\") .append(File.separator).append(dateFormat.format(new Date())).append(File.separator).append(uuid) .append(FileUtils.getSuffix(file.getName())); File newfile = new File(newFileName.toString()); if (!newfile.getParentFile().exists()) { newfile.getParentFile().mkdirs(); } file.renameTo(newfile); return FileUtils.removePrefix(newfile.getAbsolutePath(), webRoot); }","old_code_raw":"\tpublic static String moveFile(UploadFile uploadFile) {\n\t\tif (uploadFile == null)\n\t\t\treturn null;\n\n\t\tFile file = uploadFile.getFile();\n\t\tString webRoot = PathKit.getWebRootPath();\n\n\t\tString uuid = UUID.randomUUID().toString().replace(\"-\", \"\");\n\n\t\tStringBuilder newFileName = new StringBuilder(webRoot).append(File.separator).append(\"attachment\")\n\t\t\t\t.append(File.separator).append(dateFormat.format(new Date())).append(File.separator).append(uuid)\n\t\t\t\t.append(FileUtils.getSuffix(file.getName()));\n\n\t\tFile newfile = new File(newFileName.toString());\n\n\t\tif (!newfile.getParentFile().exists()) {\n\t\t\tnewfile.getParentFile().mkdirs();\n\t\t}\n\n\t\tfile.renameTo(newfile);\n\n\t\treturn FileUtils.removePrefix(newfile.getAbsolutePath(), webRoot);\n\t}\n","new_comment_raw":"@return new file relative path","old_comment_raw":"@return new file relative path","label":0,"pre_label":1,"AST_level":9,"line_counts":28,"new_code_token_num":169},{"new_code_raw":"private static File[] determineInputs(List<File> inputs, FilenameFilter filter) { Set<File> fileSet = new LinkedHashSet<>(); \/\/ preserve order and uniqueness for (File file : inputs) { \/\/ if directory, look at contents to see what files match extension if (file.isDirectory()) { File[] files = file.listFiles(filter); Collections.addAll(fileSet, files != null ? files : new File[0]); } \/\/ otherwise, just add the file. else { fileSet.add(file); } } if (fileSet.size() > 0) { System.err.println(\"Input files to compile:\"); for (File file : fileSet) { System.err.println(\" \" + file); } } else { System.err.println(\"No input files found.\"); } return fileSet.toArray(new File[0]); }","old_code_raw":"  private static File[] determineInputs(List<File> inputs, FilenameFilter filter) {\n    Set<File> fileSet = new LinkedHashSet<>(); \/\/ preserve order and uniqueness\n\n    for (File file : inputs) {\n      \/\/ if directory, look at contents to see what files match extension\n      if (file.isDirectory()) {\n        for (File f : file.listFiles(filter)) {\n          fileSet.add(f);\n        }\n      }\n      \/\/ otherwise, just add the file.\n      else {\n        fileSet.add(file);\n      }\n    }\n\n    if (fileSet.size() > 0) {\n      System.err.println(\"Input files to compile:\");\n      for (File file : fileSet) {\n        System.err.println(\"  \" + file);\n      }\n    }\n    else {\n      System.err.println(\"No input files found.\");\n    }\n\n    return fileSet.toArray((new File[fileSet.size()]));\n  }\n","new_comment_raw":"@return Unique array of files","old_comment_raw":"@return Unique array of files","label":0,"pre_label":1,"AST_level":11,"line_counts":28,"new_code_token_num":175},{"new_code_raw":"public static ValueType decode(final String value) { if (value == null || value.trim().isEmpty()) throw new IllegalArgumentException(STR); final ValueType v = decodeByInt.get(value.trim().charAt(NUM)); return v == null ? DIRECTED : v; }","old_code_raw":"public static ValueType decode(final String value) {\n    if (value == null || value.trim().isEmpty())\n        throw new IllegalArgumentException(STR);\n    final ValueType v = decodeByInt.get(value.trim().charAt(NUM));\n    return v == null ? X : v;\n}","new_comment_raw":"@return the decoded ValueType or {@link #DIRECTED} if the char does not map to a ValueType","old_comment_raw":"@return the decoded ValueType or {@link #X} if the char does not map to a ValueType","label":1,"pre_label":0,"AST_level":8,"line_counts":6,"new_code_token_num":56},{"new_code_raw":"public GremlinPipeline id() { return this.add(new IdPipe()); }","old_code_raw":"public T id() {\n    return this.add(new IdPipe());\n}","new_comment_raw":"@return the extended Pipeline","old_comment_raw":"@return the extended FluentPipeline","label":1,"pre_label":0,"AST_level":7,"line_counts":3,"new_code_token_num":17},{"new_code_raw":"public Iterable<DocumentRequest> getDocumentRequests() { return documentRequests; }","old_code_raw":"public Iterable<DocumentRequest> getDocumentRequests() {\n    throw new UnsupportedOperationException(STR);\n}","new_comment_raw":"@return a non-null object iterating over no nulls, containing at least one element.","old_comment_raw":"@return a non-null object iterating over no nulls.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":11},{"new_code_raw":"public Score score(List<Collection<TypedDependency>> system) { int parserCnt = 0; int goldCnt = 0; int correctAttachment = 0; int correctUnlabeledAttachment = 0; int labelCnt = 0; int labelCorrect = 0; ClassicCounter<String> unlabeledErrorCounts = new ClassicCounter<String>(); ClassicCounter<String> labeledErrorCounts = new ClassicCounter<String>(); \/\/System.out.println(\"Gold size: \"+ goldDeps.size() + \" System size: \"+system.size()); for (int i = 0; i < system.size(); i++) { List<Set<TypedDependency>> l = toSets(system.get(i)); if (ignorePunc) { removeHeadsAssignedToPunc(l.get(0)); removeHeadsAssignedToPunc(l.get(1)); } parserCnt += l.get(0).size(); goldCnt += goldDeps.get(i).size(); l.get(0).retainAll(goldDeps.get(i)); \/\/System.out.println(\"UGold: \"+goldDepsUnlabeled.get(i)+\"\\n\"); \/\/System.out.println(\"USys: \"+l.get(1)+\"\\n\"); l.get(1).retainAll(goldDepsUnlabeled.get(i)); correctAttachment += l.get(0).size(); correctUnlabeledAttachment += l.get(1).size(); labelCnt += l.get(1).size(); labelCorrect += l.get(0).size(); \/\/System.out.println(\"\"+i+\" Acc: \"+(l.get(0).size())\/(double)localCnt+\" \"+l.get(0).size()+\"\/\"+localCnt); \/\/ identify errors List<Set<TypedDependency>> errl = toSets(system.get(i)); errl.get(0).removeAll(goldDeps.get(i)); errl.get(1).removeAll(goldDepsUnlabeled.get(i)); Map<String,String> childCorrectWithLabel = new HashMap<String,String>(); Map<String,String> childCorrectWithOutLabel = new HashMap<String,String>(); for (TypedDependency goldDep: goldDeps.get(i)) { \/\/System.out.print(goldDep); String sChild = goldDep.dep().label().toString().replaceFirst(\"-[^-]*$\", \"\"); String prefixLabeled = \"\"; String prefixUnlabeled = \"\"; if (childCorrectWithLabel.containsKey(sChild)) { prefixLabeled = childCorrectWithLabel.get(sChild)+\", \"; prefixUnlabeled = childCorrectWithOutLabel.get(sChild)+\", \"; } childCorrectWithLabel.put(sChild, prefixLabeled + goldDep.reln()+\"(\"+goldDep.gov().label().toString().replaceFirst(\"-[^-]*$\", \"\")+\", \"+sChild+\")\"); childCorrectWithOutLabel.put(sChild, prefixUnlabeled + \"dep(\"+goldDep.gov().label().toString().replaceFirst(\"-[^-]*$\", \"\")+\", \"+sChild+\")\"); } for (TypedDependency labeledError: errl.get(0)) { String sChild = labeledError.dep().label().toString().replaceFirst(\"-[^-]*$\", \"\"); String sGov = labeledError.gov().label().toString().replaceFirst(\"-[^-]*$\", \"\"); labeledErrorCounts.incrementCount(labeledError.reln().toString()+\"(\"+sGov+\", \"+sChild+\") <= \"+childCorrectWithLabel.get(sChild)); } for (TypedDependency unlabeledError: errl.get(1)) { String sChild = unlabeledError.dep().label().toString().replaceFirst(\"-[^-]*$\", \"\"); String sGov = unlabeledError.gov().label().toString().replaceFirst(\"-[^-]*$\", \"\"); unlabeledErrorCounts.incrementCount(\"dep(\"+sGov+\", \"+sChild+\") <= \"+childCorrectWithOutLabel.get(sChild)); } } return new Score(parserCnt, goldCnt, correctAttachment, correctUnlabeledAttachment, labelCnt, labelCorrect, labeledErrorCounts, unlabeledErrorCounts); }","old_code_raw":"  public Score score(List<Collection<TypedDependency>> system) {\n    int parserCnt = 0;\n    int goldCnt = 0;\n    int parserUnlabeledCnt = 0;\n    int goldUnlabeledCnt = 0;\n    int correctAttachment = 0;\n    int correctUnlabeledAttachment = 0;\n    int labelCnt = 0;\n    int labelCorrect = 0;\n\n    ClassicCounter<String> unlabeledErrorCounts = new ClassicCounter<String>();\n    ClassicCounter<String> labeledErrorCounts = new ClassicCounter<String>();\n    \/\/System.out.println(\"Gold size: \"+ goldDeps.size() + \" System size: \"+system.size());\n    for (int i = 0; i < system.size(); i++) {\n      List<Set<TypedDependency>> l = toSets(system.get(i));\n      if (ignorePunc) {\n        removeHeadsAssignedToPunc(l.get(0));\n        removeHeadsAssignedToPunc(l.get(1));\n      }\n\n      parserCnt += l.get(0).size();\n      goldCnt += goldDeps.get(i).size();\n\n      parserUnlabeledCnt += l.get(1).size();\n      goldUnlabeledCnt += goldDepsUnlabeled.get(i).size();\n\n      l.get(0).retainAll(goldDeps.get(i));\n      l.get(1).retainAll(goldDepsUnlabeled.get(i));\n      correctAttachment += l.get(0).size();\n      correctUnlabeledAttachment += l.get(1).size();\n      labelCnt += l.get(1).size();\n      labelCorrect += l.get(0).size();\n      \/\/System.out.println(\"\"+i+\" Acc: \"+(l.get(0).size())\/(double)localCnt+\" \"+l.get(0).size()+\"\/\"+localCnt);\n\n\n      \/\/ identify errors\n      List<Set<TypedDependency>> errl = toSets(system.get(i));\n      errl.get(0).removeAll(goldDeps.get(i));\n      errl.get(1).removeAll(goldDepsUnlabeled.get(i));\n      Map<String,String> childCorrectWithLabel = Generics.newHashMap();\n      Map<String,String> childCorrectWithOutLabel = Generics.newHashMap();\n\n      for (TypedDependency goldDep: goldDeps.get(i)) {\n          \/\/System.out.print(goldDep);\n          String sChild = goldDep.dep().label().toString().replaceFirst(\"-[^-]*$\", \"\");\n          String prefixLabeled = \"\";\n          String prefixUnlabeled = \"\";\n          if (childCorrectWithLabel.containsKey(sChild)) {\n            prefixLabeled = childCorrectWithLabel.get(sChild)+\", \";\n            prefixUnlabeled = childCorrectWithOutLabel.get(sChild)+\", \";\n          }\n          childCorrectWithLabel.put(sChild, prefixLabeled + goldDep.reln()+\"(\"+goldDep.gov().label().toString().replaceFirst(\"-[^-]*$\", \"\")+\", \"+sChild+\")\");\n          childCorrectWithOutLabel.put(sChild, prefixUnlabeled + \"dep(\"+goldDep.gov().label().toString().replaceFirst(\"-[^-]*$\", \"\")+\", \"+sChild+\")\");\n      }\n\n      for (TypedDependency labeledError: errl.get(0)) {\n          String sChild = labeledError.dep().label().toString().replaceFirst(\"-[^-]*$\", \"\");\n          String sGov   = labeledError.gov().label().toString().replaceFirst(\"-[^-]*$\", \"\");\n          labeledErrorCounts.incrementCount(labeledError.reln().toString()+\"(\"+sGov+\", \"+sChild+\") <= \"+childCorrectWithLabel.get(sChild));\n      }\n      for (TypedDependency unlabeledError: errl.get(1)) {\n          String sChild = unlabeledError.dep().label().toString().replaceFirst(\"-[^-]*$\", \"\");\n          String sGov   = unlabeledError.gov().label().toString().replaceFirst(\"-[^-]*$\", \"\");\n          unlabeledErrorCounts.incrementCount(\"dep(\"+sGov+\", \"+sChild+\") <= \"+childCorrectWithOutLabel.get(sChild));\n      }\n    }\n    return new Score(parserCnt, goldCnt, parserUnlabeledCnt, goldUnlabeledCnt, correctAttachment, correctUnlabeledAttachment, labelCnt, labelCorrect, labeledErrorCounts, unlabeledErrorCounts);\n  }\n","new_comment_raw":"@return a triple consisting of (labeled attachment, unlabeled attachment, label accuracy)","old_comment_raw":"@return a triple consisting of (labeled attachment, unlabeled attachment, label accuracy)","label":0,"pre_label":1,"AST_level":16,"line_counts":64,"new_code_token_num":813},{"new_code_raw":"public Complex getComplex() { return get(); }","old_code_raw":"public Complex getComplex(final int i) {\n    return get(i);\n}","new_comment_raw":"@return item in first position","old_comment_raw":"@return item in given position","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":12},{"new_code_raw":"public long getColumnValueCount(SchemaPath column) { ColumnStatistics<?> columnStats = getTableMetadata().getColumnStatistics(column); ColumnStatistics<?> nonInterestingColStats = columnStats == null ? getNonInterestingColumnsMetadata().getColumnStatistics(column) : null; long tableRowCount; if (columnStats != null) { tableRowCount = TableStatisticsKind.ROW_COUNT.getValue(getTableMetadata()); } else if (nonInterestingColStats != null) { tableRowCount = TableStatisticsKind.ROW_COUNT.getValue(getNonInterestingColumnsMetadata()); columnStats = nonInterestingColStats; } else if (hasNestedStatsForColumn(column, getTableMetadata()) || hasNestedStatsForColumn(column, getNonInterestingColumnsMetadata())) { \/\/ When statistics for nested field exists, this is complex column which is present in table. \/\/ But its nested fields statistics can't be used to extract tableRowCount for this column. \/\/ So NO_COLUMN_STATS returned here to avoid problems described in DRILL-7491. return Statistic.NO_COLUMN_STATS; } else { return 0; \/\/ returns 0 if the column doesn't exist in the table. } Long nulls = ColumnStatisticsKind.NULLS_COUNT.getFrom(columnStats); if (nulls == null || Statistic.NO_COLUMN_STATS == nulls || Statistic.NO_COLUMN_STATS == tableRowCount) { return Statistic.NO_COLUMN_STATS; } else { return tableRowCount - nulls; } }","old_code_raw":"  public long getColumnValueCount(SchemaPath column) {\n    long tableRowCount, colNulls;\n    Long nulls;\n    ColumnStatistics<?> columnStats = getTableMetadata().getColumnStatistics(column);\n    ColumnStatistics<?> nonInterestingColStats = null;\n    if (columnStats == null) {\n      nonInterestingColStats = getNonInterestingColumnsMetadata().getColumnStatistics(column);\n    }\n\n    if (columnStats != null) {\n      tableRowCount = TableStatisticsKind.ROW_COUNT.getValue(getTableMetadata());\n    } else if (nonInterestingColStats != null) {\n      tableRowCount = TableStatisticsKind.ROW_COUNT.getValue(getNonInterestingColumnsMetadata());\n    } else {\n      return 0; \/\/ returns 0 if the column doesn't exist in the table.\n    }\n\n    columnStats = columnStats != null ? columnStats : nonInterestingColStats;\n    nulls = ColumnStatisticsKind.NULLS_COUNT.getFrom(columnStats);\n    colNulls = nulls != null ? nulls : Statistic.NO_COLUMN_STATS;\n\n    return Statistic.NO_COLUMN_STATS == tableRowCount\n            || Statistic.NO_COLUMN_STATS == colNulls\n            ? Statistic.NO_COLUMN_STATS : tableRowCount - colNulls;\n  }\n","new_comment_raw":"@return column value count","old_comment_raw":"@return column value count","label":0,"pre_label":1,"AST_level":9,"line_counts":29,"new_code_token_num":215},{"new_code_raw":"public Client build(String name) { if ((environment == null) && (executorService == null) && (objectMapper == null)) { throw new IllegalStateException(\"Must have either an environment or both \" + \"an executor service and an object mapper\"); } if (environment == null) { return build(executorService, objectMapper, validator, name); } return build(environment.getLifecycleEnvironment() .executorService(\"jersey-client-\" + name + \"-%d\") .minThreads(configuration.getMinThreads()) .maxThreads(configuration.getMaxThreads()) .build(), environment.getObjectMapper(), environment.getValidator(), name); }","old_code_raw":"    public Client build(String name) {\n        if ((environment == null) && (executorService == null) && (objectMapper == null)) {\n            throw new IllegalStateException(\"Must have either an environment or both \" +\n                                                    \"an executor service and an object mapper\");\n        }\n\n        if (environment == null) {\n            return build(executorService, objectMapper, validator, name);\n        }\n\n        return build(environment.getLifecycleEnvironment()\n                                .managedExecutorService(\"jersey-client-%d\",\n                                                        configuration.getMinThreads(),\n                                                        configuration.getMaxThreads(),\n                                                        60,\n                                                        TimeUnit.SECONDS),\n                     environment.getObjectMapper(),\n                     environment.getValidator(),\n                     name);\n    }\n","new_comment_raw":"@return a fully-configured  Client","old_comment_raw":"@return a fully-configured Client","label":0,"pre_label":1,"AST_level":9,"line_counts":20,"new_code_token_num":129},{"new_code_raw":"public byte[] evaluateChallenge(byte[] challenge) throws MessagingException { try { String result = STR + username + STR + password; if (authzid != null && authzid.length() > NUM) { result = authzid + result; } complete = true; return result.getBytes(STR); } catch (UnsupportedEncodingException e) { throw new MessagingException(STR); } }","old_code_raw":"public byte[] evaluateChallenge(byte[] challenge) throws MessagingException {\n    try {\n        byte[] userBytes = username.getBytes(STR);\n        byte[] passBytes = password.getBytes(STR);\n        byte[] tokenBytes = new byte[(userBytes.length * NUM) + passBytes.length + NUM];\n        System.arraycopy(userBytes, NUM, tokenBytes, NUM, userBytes.length);\n        System.arraycopy(userBytes, NUM, tokenBytes, userBytes.length + NUM, userBytes.length);\n        System.arraycopy(passBytes, NUM, tokenBytes, (userBytes.length * NUM) + NUM, passBytes.length);\n        complete = true;\n        return tokenBytes;\n    } catch (UnsupportedEncodingException e) {\n        throw new MessagingException(STR);\n    }\n}","new_comment_raw":"@return A formatted challenge response, as an array of bytes.","old_comment_raw":"@return A formatted challege response, as an array of bytes.","label":1,"pre_label":0,"AST_level":9,"line_counts":12,"new_code_token_num":72},{"new_code_raw":"public EString substring(int beginIndex, int endIndex) { return OString.create(Ops.SUBSTR_2ARGS, this, ENumber.create(beginIndex), ENumber.create(endIndex)); }","old_code_raw":"    public EString substring(int beginIndex, int endIndex) {\n        return new OString(Ops.SUBSTR_2ARGS, this, ENumber.create(beginIndex), ENumber.create(endIndex));\n    }\n","new_comment_raw":"@return this.substring(beginIndex, endIndex)","old_comment_raw":"@return this.substring(beginIndex, endIndex)","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":34},{"new_code_raw":"public static String resolve(String originalHost) { String currentHost = originalHost; if (isLocalOrIp(currentHost)) { return originalHost; } try { String targetHost = null; do { Attributes attrs = dirContext.getAttributes(currentHost, new String[] { A_RECORD_TYPE, CNAME_RECORD_TYPE }); Attribute attr = attrs.get(A_RECORD_TYPE); if (attr != null) { targetHost = attr.get().toString(); } attr = attrs.get(CNAME_RECORD_TYPE); if (attr != null) { currentHost = attr.get().toString(); } else { targetHost = currentHost; } } while (targetHost == null); return targetHost; } catch (NamingException e) { logger.warn(STR + currentHost + STR + originalHost, e); return originalHost; } }","old_code_raw":"static String resolve(String originalHost) {\n    String currentHost = originalHost;\n    if (isLocalOrIp(currentHost)) {\n        return originalHost;\n    }\n    try {\n        String targetHost = null;\n        do {\n            Attributes attrs = dirContext.getAttributes(currentHost, new String[] { A_RECORD_TYPE, CNAME_RECORD_TYPE });\n            Attribute attr = attrs.get(A_RECORD_TYPE);\n            if (attr != null) {\n                targetHost = attr.get().toString();\n            }\n            attr = attrs.get(CNAME_RECORD_TYPE);\n            if (attr != null) {\n                currentHost = attr.get().toString();\n            } else {\n                targetHost = currentHost;\n            }\n        } while (targetHost == null);\n        return targetHost;\n    } catch (NamingException e) {\n        logger.warn(STR + currentHost + STR + originalHost, e);\n        return originalHost;\n    }\n}","new_comment_raw":"@return resolved host name","old_comment_raw":"@return URI identical to the one provided, with host name swapped with the resolved value","label":1,"pre_label":0,"AST_level":11,"line_counts":26,"new_code_token_num":142},{"new_code_raw":"public Instant timestampOfLsn(Lsn lsn) throws SQLException { final String query = \"SELECT sys.fn_cdc_map_lsn_to_time(?)\"; if (lsn.getBinary() == null) { return null; } return prepareQueryAndMap(query, statement -> { statement.setBytes(1, lsn.getBinary()); }, singleResultMapper(rs -> { final Timestamp ts = rs.getTimestamp(1); final Instant ret = (ts == null) ? null : ts.toInstant(); LOGGER.trace(\"Timestamp of lsn {} is {}\", lsn, ret); return ret; }, \"LSN to timestamp query must return exactly one value\")); }","old_code_raw":"    public Instant timestampOfLsn(Lsn lsn) throws SQLException {\n        final String LSN_TIMESTAMP_ERROR = \"LSN to timestamp query must return exactly one value\";\n        final String query = \"SELECT sys.fn_cdc_map_lsn_to_time(?)\";\n\n        if (lsn.getBinary() == null) {\n            return null;\n        }\n\n        return prepareQueryAndMap(query, statement -> {\n            statement.setBytes(1, lsn.getBinary());\n        }, rs -> {\n            if (rs.next()) {\n                final Timestamp ts = rs.getTimestamp(1);\n                final Instant ret = ts == null ? null : ts.toInstant();\n                if (!rs.next()) {\n                    LOGGER.trace(\"Timestamp of lsn {} is {}\", lsn, ret);\n                    return ret;\n                }\n            }\n            throw new IllegalStateException(LSN_TIMESTAMP_ERROR);\n        });\n    }\n","new_comment_raw":"@return time when the commit was recorded into the database log","old_comment_raw":"@return time when the commit was recorded into the database log","label":0,"pre_label":1,"AST_level":11,"line_counts":16,"new_code_token_num":124},{"new_code_raw":"public Integer getHttpDaemonPort() { return port; }","old_code_raw":"public int getHttpDaemonPort() {\n    return port;\n}","new_comment_raw":"@return an integer with a value greater than 0, or null if undefined.","old_comment_raw":"@return a value greater than 0.","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":10},{"new_code_raw":"public static HashMap getXmlRpcWorkflowTaskConfiguration(WorkflowTaskConfiguration config) { HashMap configuration = new HashMap(); for (Object o : config.getProperties().keySet()) { String name = (String) o; String value = (String) config.getProperties().get(name); configuration.put(name, value); } return configuration; }","old_code_raw":"public static Hashtable getXmlRpcWorkflowTaskConfiguration(WorkflowTaskConfiguration config) {\n    Hashtable configuration = new Hashtable();\n    for (Object o : config.getProperties().keySet()) {\n        String name = (String) o;\n        String value = (String) config.getProperties().get(name);\n        configuration.put(name, value);\n    }\n    return configuration;\n}","new_comment_raw":"@return A {@link HashMap} representation of the passed in {@link WorkflowTaskConfiguration}'s {@link Properties}.","old_comment_raw":"@return A {@link Hashtable} representation of the passed in {@link WorkflowTaskConfiguration}'s {@link Properties}.","label":1,"pre_label":0,"AST_level":10,"line_counts":9,"new_code_token_num":64},{"new_code_raw":"public static String[] decodeArray(String encoded) { if (encoded.isEmpty()) return EMPTY_STRING_ARRAY; char[] chars = encoded.trim().toCharArray(); \/\/--Parse the String \/\/ (state) char quoteCloseChar = (char) 0; List<String> terms = new ArrayList<>(); StringBuilder current = new StringBuilder(); \/\/(start\/stop overhead) int start = 0; int end = chars.length; if(chars[0] == '('){ start += 1; end -= 1; if(chars[end] != ')') throw new IllegalArgumentException(\"Unclosed paren in encoded array: \" + encoded); } if(chars[0] == '['){ start += 1; end -= 1; if(chars[end] != ']') throw new IllegalArgumentException(\"Unclosed bracket in encoded array: \" + encoded); } if(chars[0] == '{'){ start += 1; end -= 1; if(chars[end] != '}') throw new IllegalArgumentException(\"Unclosed bracket in encoded array: \" + encoded); } \/\/ (finite state automaton) for (int i=start; i<end; i++) { if (chars[i] == '\\r') { \/\/ Ignore funny windows carriage return continue; } else if (quoteCloseChar != 0) { \/\/(case: in quotes) if(chars[i] == quoteCloseChar){ quoteCloseChar = (char) 0; }else{ current.append(chars[i]); } } else if(chars[i] == '\\\\'){ \/\/(case: escaped character) if(i == chars.length - 1) throw new IllegalArgumentException(\"Last character of encoded array is escape character: \" + encoded); current.append(chars[i+1]); i += 1; } else { \/\/(case: normal) if (chars[i] == '\"') { quoteCloseChar = '\"'; } else if(chars[i] == '\\'') { quoteCloseChar = '\\''; } else if(chars[i] == ',' || chars[i] == ';' || chars[i] == ' ' || chars[i] == '\\t' || chars[i] == '\\n') { \/\/break if (current.length() > 0) { terms.add(current.toString().trim()); } current = new StringBuilder(); } else { current.append(chars[i]); } } } \/\/--Return if (current.length() > 0) { terms.add(current.toString().trim()); } return terms.toArray(EMPTY_STRING_ARRAY); }","old_code_raw":"  public static String[] decodeArray(String encoded){\n    if (encoded.isEmpty()) return EMPTY_STRING_ARRAY;\n    char[] chars = encoded.trim().toCharArray();\n\n    \/\/--Parse the String\n    \/\/ (state)\n    char quoteCloseChar = (char) 0;\n    List<StringBuilder> terms = new LinkedList<>();\n    StringBuilder current = new StringBuilder();\n    \/\/(start\/stop overhead)\n    int start = 0; int end = chars.length;\n    if(chars[0] == '('){ start += 1; end -= 1; if(chars[end] != ')') throw new IllegalArgumentException(\"Unclosed paren in encoded array: \" + encoded); }\n    if(chars[0] == '['){ start += 1; end -= 1; if(chars[end] != ']') throw new IllegalArgumentException(\"Unclosed bracket in encoded array: \" + encoded); }\n    if(chars[0] == '{'){ start += 1; end -= 1; if(chars[end] != '}') throw new IllegalArgumentException(\"Unclosed bracket in encoded array: \" + encoded); }\n    \/\/ (finite state automaton)\n    for (int i=start; i<end; i++) {\n      if (chars[i] == '\\r') {\n        \/\/ Ignore funny windows carriage return\n        continue;\n      } else if (quoteCloseChar != 0) {\n        \/\/(case: in quotes)\n        if(chars[i] == quoteCloseChar){\n          quoteCloseChar = (char) 0;\n        }else{\n          current.append(chars[i]);\n        }\n      } else if(chars[i] == '\\\\'){\n        \/\/(case: escaped character)\n        if(i == chars.length - 1) throw new IllegalArgumentException(\"Last character of encoded array is escape character: \" + encoded);\n        current.append(chars[i+1]);\n        i += 1;\n      } else {\n        \/\/(case: normal)\n        if(chars[i] == '\"'){\n          quoteCloseChar = '\"';\n        } else if(chars[i] == '\\''){\n          quoteCloseChar = '\\'';\n        } else if(chars[i] == ',' || chars[i] == ';' || chars[i] == ' ' || chars[i] == '\\t' || chars[i] == '\\n'){\n          \/\/break\n          if (current.length() > 0) {\n            terms.add(current);\n          }\n          current = new StringBuilder();\n        }else{\n          current.append(chars[i]);\n        }\n      }\n    }\n\n    \/\/--Return\n    if(current.length() > 0) terms.add(current);\n    String[] rtn = new String[terms.size()];\n    int i=0;\n    for(StringBuilder b : terms){\n      rtn[i] = b.toString().trim();\n      i += 1;\n    }\n    return rtn;\n  }\n","new_comment_raw":"@return A String array corresponding to the encoded array","old_comment_raw":"@return A String array corresponding to the encoded array","label":0,"pre_label":1,"AST_level":19,"line_counts":56,"new_code_token_num":553},{"new_code_raw":"public static DurationFieldType halfdays() { return HALFDAYS_TYPE; }","old_code_raw":"    public static DurationFieldType halfdays() {\n        return HALFDAYS;\n    }\n","new_comment_raw":"@return the DateTimeFieldType constant","old_comment_raw":"@return the DateTimeFieldType constant","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":11},{"new_code_raw":"public ArrayList<ErrorMsg> getErrors() { return _parser.getErrors(); }","old_code_raw":"public Vector getErrors() {\n    return _parser.getErrors();\n}","new_comment_raw":"@return A List containing all compile error messages","old_comment_raw":"@return A Vector containing all compile error messages","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":14},{"new_code_raw":"private ZapTextArea getDefaultOutput() { if (defaultOutput == null) { defaultOutput = new ZapTextArea(); defaultOutput.setEditable(false); defaultOutput.setLineWrap(true); defaultOutput.setFont(new java.awt.Font(\"Dialog\", java.awt.Font.PLAIN, 12)); defaultOutput.setName(\"\"); defaultOutput.append(Constant.messages.getString(\"alerts.label.defaultMessage\")); } return defaultOutput; }","old_code_raw":"\tprivate JTextArea getDefaultOutput() {\n\t\tif (defaultOutput == null) {\n\t\t\tdefaultOutput = new JTextArea();\n\t\t\tdefaultOutput.setEditable(false);\n\t\t\tdefaultOutput.setLineWrap(true);\n\t\t\tdefaultOutput.setFont(new java.awt.Font(\"Dialog\", java.awt.Font.PLAIN, 12));\n\t\t\tdefaultOutput.setName(\"\");\n\t\t\tdefaultOutput.append(Constant.messages.getString(\"alerts.label.defaultMessage\"));\n\t\t}\n\t\treturn defaultOutput;\n\t}\n","new_comment_raw":"@return javax.swing.ZapTextArea","old_comment_raw":"@return javax.swing.JTextArea","label":1,"pre_label":0,"AST_level":10,"line_counts":12,"new_code_token_num":78},{"new_code_raw":"public Long getCountOfTheWords(String studySetName) { return (Long) EM.createQuery(STR).setParameter(STR, studySetName).getSingleResult(); }","old_code_raw":"public Long getCountOfTheWords() {\n    return (Long) EM.createQuery(STR).getSingleResult();\n}","new_comment_raw":"@return current number of words for study from respective study set","old_comment_raw":"@return current number of words for study","label":1,"pre_label":0,"AST_level":7,"line_counts":3,"new_code_token_num":28},{"new_code_raw":"public String getConnectedServer(AccessToken accessToken, String node) { AgentMgtDao agentMgtDao = new AgentMgtDao(); return agentMgtDao.getConnectedServer(accessToken.getId(), node); }","old_code_raw":"public String getConnectedServer(AccessToken accessToken) {\n    AgentMgtDao agentMgtDao = new AgentMgtDao();\n    return agentMgtDao.getConnectedServer(accessToken.getId());\n}","new_comment_raw":"@returnConnected Server Hostname \/ IP","old_comment_raw":"@return Connected Node","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":31},{"new_code_raw":"public View waitForView(View view, int timeout, boolean scroll, boolean checkIsShown){ if(view == null) return null; long endTime = SystemClock.uptimeMillis() + timeout; while (SystemClock.uptimeMillis() < endTime) { sleeper.sleep(); final boolean foundAnyMatchingView = searcher.searchFor(view); if (foundAnyMatchingView){ return view; } if(checkIsShown && view != null && view.isShown()){ return view; } View identicalView = viewFetcher.getIdenticalView(view); if(identicalView != null && !view.equals(identicalView)){ view = identicalView; continue; } if(scroll) scroller.scrollDown(); } return null; }","old_code_raw":"\tpublic boolean waitForView(View view, int timeout, boolean scroll, boolean checkIsShown){\n\n\t\tif(view == null)\n\t\t\treturn false;\n\n\t\tlong endTime = SystemClock.uptimeMillis() + timeout;\n\n\t\twhile (SystemClock.uptimeMillis() < endTime) {\n\t\t\tsleeper.sleep();\n\n\t\t\tfinal boolean foundAnyMatchingView = searcher.searchFor(view);\n\n\t\t\tif (foundAnyMatchingView){\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif(checkIsShown && view != null && view.isShown()){\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif(checkIsShown && view != null){\n\t\t\t\tView identicalView = viewFetcher.getIdenticalView(view);\n\t\t\t\tif(identicalView != null){\n\t\t\t\t\tview = identicalView;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(scroll) \n\t\t\t\tscroller.scrollDown();\n\t\t}\n\t\treturn false;\n\t}\n","new_comment_raw":"@return  true if view is shown and  false if it is not shown before the timeout","old_comment_raw":"@return true if view is shown and false if it is not shown before the timeout","label":0,"pre_label":1,"AST_level":9,"line_counts":32,"new_code_token_num":129},{"new_code_raw":"public final SQLRow getSelectedRow() { if (this.isEmpty()) { return null; } else { final IComboSelectionItem o = this.getValue(); final SQLRowAccessor r = o.getRow(); if (r != null) { return r.asRow(); } else { return new SQLRow(this.getForeignTable(), o.getId()); } } }","old_code_raw":"public final SQLRow getSelectedRow() {\n    if (this.isEmpty())\n        return null;\n    else {\n        return new SQLRow(this.getForeignTable(), this.getSelectedId());\n    }\n}","new_comment_raw":"@return a SQLRow or <code>null<\/code>.","old_comment_raw":"@return a SQLRow (non fetched) or <code>null<\/code>.","label":1,"pre_label":0,"AST_level":10,"line_counts":13,"new_code_token_num":71},{"new_code_raw":"public TracingContext beginValidation() { return traceToMap(validationMap); }","old_code_raw":"    public TracingContext beginValidation() {\n        long startValidation = System.nanoTime();\n        return () -> {\n            long now = System.nanoTime();\n            long duration = now - startValidation;\n            long startOffset = now - startRequestNanos;\n\n            validationMap.put(\"startOffset\", startOffset);\n            validationMap.put(\"duration\", duration);\n        };\n    }\n","new_comment_raw":"@return a context to call end on","old_comment_raw":"@return a context to call end on","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":13},{"new_code_raw":"public static String export() { RequestLog current = RLOG.get(); record(new Durations(current.aggregateDurations())); record(new Threads(current.threadIds)); return LogFormatterProvider.getInstance().format(current.info); }","old_code_raw":"public static String export() {\n    RequestLog current = RLOG.get();\n    record(new Durations(current.aggregateDurations()));\n    record(new Threads(current.threadIds));\n    try {\n        return current.mapper.writeValueAsString(current.info);\n    } catch (JsonProcessingException jpe) {\n        String msg = String.format(STR, current.logId);\n        LOG.warn(msg, jpe);\n        return msg;\n    }\n}","new_comment_raw":"@return log object as a formatted string","old_comment_raw":"@return log object as a JSON formatted string","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":48},{"new_code_raw":"private static Gobbling gobble(Treepath<SyntacticTree> gobbleStart, int indentation) { Preconditions.checkArgument(gobbleStart.getTreeAtEnd().isOneOf(_PLACEHOLDER_)); Treepath<SyntacticTree> start = gobbleStart; do { if (TreepathTools.hasNextSibling(start)) { final Treepath<SyntacticTree> next = TreepathTools.getNextSibling(start); if (isRawItem(next)) { final Treepath<SyntacticTree> minusNext = TreepathTools.removeNextSibling(start); return new Gobbling(minusNext, makeEmbeddedListItem(next), indentation); } else { final SyntacticTree nextTree = next.getTreeAtEnd(); if (nextTree.isOneOf(WHITESPACE_, LINE_BREAK_)) { start = TreepathTools.removeNextSibling(start); if (nextTree.isOneOf(WHITESPACE_)) { indentation = getWhitespaceLength(next); } continue; } } } return new Gobbling(start); } while (true); }","old_code_raw":"private static Gobbling gobble(Treepath<SyntacticTree> gobbleStart) {\n    if (null == gobbleStart) {\n        return null;\n    }\n    Preconditions.checkArgument(gobbleStart.getTreeAtEnd().isOneOf(_PLACEHOLDER_));\n    gobbleStart = TreepathTools.getNextSibling(gobbleStart);\n    do {\n        if (isRawItem(gobbleStart)) {\n            if (TreepathTools.hasNextSibling(gobbleStart)) {\n                final Treepath<SyntacticTree> nextStart = TreepathTools.getNextSibling(gobbleStart);\n                final Treepath<SyntacticTree> nextStartMinusPrevious = TreepathTools.removePreviousSibling(nextStart);\n                return new Gobbling(nextStartMinusPrevious, makeEmbeddedListItem(gobbleStart), true);\n            } else {\n                final Treepath<SyntacticTree> minusPrevious = TreepathTools.removeEnd(gobbleStart);\n                return new Gobbling(minusPrevious, makeEmbeddedListItem(gobbleStart), false);\n            }\n        } else if (gobbleStart.getTreeAtEnd().isOneOf(WHITESPACE_, LINE_BREAK_)) {\n            if (TreepathTools.hasNextSibling(gobbleStart)) {\n                gobbleStart = TreepathTools.getNextSibling(gobbleStart);\n            }\n        } else {\n            return null;\n        }\n    } while (true);\n}","new_comment_raw":"@return a {@code Gobbling} object containing the result of the gobble.","old_comment_raw":"@return null if {@code gobbleStart} was null, or a {@code Gobbling} object containing the result of the gobble. {@code Gobbling#treepathMinusGobbled} still refers to the _PLACEHOLDER_ but some separators and one raw item have been removed. {@code Gobbling#gobbledTree} is the result of the gobbling","label":1,"pre_label":0,"AST_level":16,"line_counts":23,"new_code_token_num":148},{"new_code_raw":"Node getAssignedValue() { return (parent.getType() == Token.FUNCTION) ? parent : NodeUtil.getAssignedValue(getNameNode()); }","old_code_raw":"Node getAssignedValue() {\n    return NodeUtil.getAssignedValue(getNameNode());\n}","new_comment_raw":"@return For an assignment, variable declaration, or function declaration return the assigned value, otherwise null.","old_comment_raw":"@return For an assignment or variable declaration return the assigned value, otherwise null.","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":26},{"new_code_raw":"private ASN1Object toASN1Object(X509Certificate cert) throws CertificateEncodingException { try { return new ASN1InputStream(cert.getEncoded()).readObject(); } catch (Exception e) { throw new CertificateEncodingException(STR + e.toString()); } }","old_code_raw":"private DERObject toASN1Object(X509Certificate cert) throws CertificateEncodingException {\n    try {\n        return new ASN1InputStream(cert.getEncoded()).readObject();\n    } catch (Exception e) {\n        throw new CertificateEncodingException(STR + e.toString());\n    }\n}","new_comment_raw":"@return the ASN1Object","old_comment_raw":"@return the DERObject","label":1,"pre_label":0,"AST_level":8,"line_counts":7,"new_code_token_num":46},{"new_code_raw":"public Object next() throws java.io.IOException { int zzInput; int zzAction; \/\/ cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { \/\/ store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); \/\/ get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } \/\/ store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 38: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } if (normalizeSpace) { \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, yytext()); } case 55: break; case 43: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 9; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 10; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/\/ try to work around an apparent jflex bug where it \/\/ gets a space at the token end by getting \/\/ wrong the length of the trailing context. while (yylength() > 0) { char last = yycharat(yylength()-1); if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) { yypushback(1); } else { break; } } return getNext(); } case 56: break; case 11: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 57: break; case 19: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 58: break; case 8: { return handleQuotes(yytext(), false); } case 59: break; case 35: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), false); } case 60: break; case 27: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 61: break; case 33: \/\/ lookahead expression with fixed lookahead length yypushback(1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 62: break; case 49: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return getNormalizedAmpNext(); } case 63: break; case 36: { return getNormalizedAmpNext(); } case 64: break; case 23: { if (invertible) { prevWordAfter.append(yytext()); } } case 65: break; case 37: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } if (normalizeSpace) { \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, yytext()); } case 66: break; case 53: \/\/ lookahead expression with fixed lookahead length yypushback(4); { return getNext(); } case 67: break; case 46: \/\/ lookahead expression with fixed lookahead length yypushback(2); { return getNext(); } case 68: break; case 42: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 69: break; case 41: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 16; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 17; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 70: break; case 40: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 13; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 71: break; case 3: { return getNext(); } case 72: break; case 24: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return getNext(); } case 73: break; case 51: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } return getNext(txt, yytext()); } case 74: break; case 26: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, origTxt); } case 75: break; case 6: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 76: break; case 29: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 77: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 78: break; case 2: { return getNext(\"<\", yytext()); } case 79: break; case 48: { yypushback(2) ; return getNext(); } case 80: break; case 30: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 81: break; case 18: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 82: break; case 54: { String txt = yytext(); if (normalizeSpace) { \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 83: break; case 50: { yypushback(3) ; return getNext(); } case 84: break; case 25: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), true); } case 85: break; case 39: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 86: break; case 21: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 87: break; case 17: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 88: break; case 13: { return handleEllipsis(yytext()); } case 89: break; case 34: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 1; { \/* invert quote - often but not always right *\/ return handleQuotes(yytext(), true); } case 90: break; case 14: { return normalizeFractions(yytext()); } case 91: break; case 15: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(); } } case 92: break; case 47: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 11; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 12; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 93: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 94: break; case 9: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 95: break; case 45: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 96: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 97: break; case 28: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 98: break; case 20: { if (normalizeOtherBrackets) { return getNext(\"-RSB-\", yytext()); } else { return getNext(); } } case 99: break; case 12: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 100: break; case 31: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 101: break; case 10: { return getNext(\">\", yytext()); } case 102: break; case 32: { \/\/ this one should only match if we're basically at the end of file \/\/ since the last one matches two things, even newlines String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 103: break; case 22: { if (normalizeOtherBrackets) { return getNext(\"-LSB-\", yytext()); } else { return getNext(); } } case 104: break; case 52: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/\/ try to work around an apparent jflex bug where it \/\/ gets a space at the token end by getting \/\/ wrong the length of the trailing context. while (yylength() > 0) { char last = yycharat(yylength()-1); if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) { yypushback(1); } else { break; } } String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 105: break; case 1: { String str = yytext(); int first = str.charAt(0); String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } LOGGER.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: LOGGER.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 106: break; case 44: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 107: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 108: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }","old_code_raw":"  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    \/\/ cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            \/\/ store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            \/\/ get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          int zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      \/\/ store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 38: \n          { String txt = yytext();\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '\/');\n                  }\n                  if (normalizeSpace) {\n                    \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                    txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n\n                  }\n                  return getNext(txt, yytext());\n          }\n        case 55: break;\n        case 43: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 9;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 10;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { \/\/ try to work around an apparent jflex bug where it\n                          \/\/ gets a space at the token end by getting\n                          \/\/ wrong the length of the trailing context.\n                          while (yylength() > 0) {\n                            char last = yycharat(yylength()-1);\n                            if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) {\n                              yypushback(1);\n                            } else {\n                              break;\n                            }\n                          }\n\t\t\t  return getNext();\n          }\n        case 56: break;\n        case 11: \n          { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 57: break;\n        case 19: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 58: break;\n        case 8: \n          { return handleQuotes(yytext(), false);\n          }\n        case 59: break;\n        case 35: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return handleQuotes(yytext(), false);\n          }\n        case 60: break;\n        case 27: \n          { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n          }\n        case 61: break;\n        case 33: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n          }\n        case 62: break;\n        case 48: \n          { if (splitAssimilations) {\n                            yypushback(2) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 63: break;\n        case 49: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNormalizedAmpNext();\n          }\n        case 64: break;\n        case 36: \n          { return getNormalizedAmpNext();\n          }\n        case 65: break;\n        case 23: \n          { if (invertible) {\n                            prevWordAfter.append(yytext());\n                        }\n          }\n        case 66: break;\n        case 37: \n          { String txt = yytext();\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '\/');\n                  }\n                  if (normalizeSpace) {\n                    \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                    txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                  }\n                  return getNext(txt, yytext());\n          }\n        case 67: break;\n        case 53: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(4);\n          { return getNext();\n          }\n        case 68: break;\n        case 46: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(2);\n          { return getNext();\n          }\n        case 69: break;\n        case 42: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 15;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 14;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 70: break;\n        case 41: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 16;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 17;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 71: break;\n        case 40: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 13;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 14;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 72: break;\n        case 3: \n          { return getNext();\n          }\n        case 73: break;\n        case 24: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext();\n          }\n        case 74: break;\n        case 51: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 75: break;\n        case 26: \n          { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n          }\n        case 76: break;\n        case 6: \n          { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n          }\n        case 77: break;\n        case 29: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 3;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 4;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n          }\n        case 78: break;\n        case 16: \n          { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 79: break;\n        case 2: \n          { return getNext(\"<\", yytext());\n          }\n        case 80: break;\n        case 30: \n          { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '\/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 81: break;\n        case 18: \n          { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 82: break;\n        case 54: \n          { String txt = yytext();\n                          if (normalizeSpace) {\n                            \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 83: break;\n        case 25: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return handleQuotes(yytext(), true);\n          }\n        case 84: break;\n        case 39: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 5;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 6;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String txt = yytext();\n                          return getNext(removeSoftHyphens(txt),\n                                         txt);\n          }\n        case 85: break;\n        case 21: \n          { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 86: break;\n        case 50: \n          { if (splitAssimilations) {\n                            yypushback(3) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 87: break;\n        case 17: \n          { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 88: break;\n        case 13: \n          { return handleEllipsis(yytext());\n          }\n        case 89: break;\n        case 34: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 1;\n          { \/* invert quote - often but not always right *\/\n                  return handleQuotes(yytext(), true);\n          }\n        case 90: break;\n        case 14: \n          { return normalizeFractions(yytext());\n          }\n        case 91: break;\n        case 15: \n          { if (normalizeCurrency) {\n                            return getNext(normalizeCurrency(yytext()), yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 92: break;\n        case 47: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 11;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 12;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 93: break;\n        case 7: \n          { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n          }\n        case 94: break;\n        case 9: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '\/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 95: break;\n        case 45: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext(removeSoftHyphens(yytext()),\n                                               yytext());\n          }\n        case 96: break;\n        case 4: \n          { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n          }\n        case 97: break;\n        case 28: \n          { return getNext(removeSoftHyphens(yytext()), yytext());\n          }\n        case 98: break;\n        case 20: \n          { if (normalizeOtherBrackets) {\n                    return getNext(\"-RSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 99: break;\n        case 12: \n          { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n          }\n        case 100: break;\n        case 31: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n          }\n        case 101: break;\n        case 10: \n          { return getNext(\">\", yytext());\n          }\n        case 102: break;\n        case 32: \n          { \/\/ this one should only match if we're basically at the end of file\n                          \/\/ since the last one matches two things, even newlines\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 103: break;\n        case 22: \n          { if (normalizeOtherBrackets) {\n                    return getNext(\"-LSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 104: break;\n        case 52: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 7;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 8;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { \/\/ try to work around an apparent jflex bug where it\n                          \/\/ gets a space at the token end by getting\n                          \/\/ wrong the length of the trailing context.\n                          while (yylength() > 0) {\n                            char last = yycharat(yylength()-1);\n                            if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) {\n                              yypushback(1);\n                            } else {\n                              break;\n                            }\n                          }\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 105: break;\n        case 1: \n          { String str = yytext();\n          int first = str.charAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n          }\n        case 106: break;\n        case 44: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 107: break;\n        case 5: \n          { if (tokenizeNLs) {\n                      return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns\n                  } else if (invertible) {\n                      prevWordAfter.append(yytext());\n                  }\n          }\n        case 108: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                if (invertible) {\n            prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            prevWordAfter.setLength(0);\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n          }\n          return null;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n","new_comment_raw":"@return the next token","old_comment_raw":"@return the next token","label":0,"pre_label":1,"AST_level":17,"line_counts":698,"new_code_token_num":4291},{"new_code_raw":"static boolean isAllNulls(Statistics stat, long rowCount) { Preconditions.checkArgument(rowCount >= 0, String.format(\"negative rowCount %d is not valid\", rowCount)); return stat.getNumNulls() == rowCount; }","old_code_raw":"  static boolean isAllNulls(Statistics stat, long rowCount) {\n    return stat.isNumNullsSet() && stat.getNumNulls() == rowCount;\n  }\n","new_comment_raw":"@return true if all rows are null in the parquet file and false otherwise","old_comment_raw":"@return True if all rows are null in the parquet file False if at least one row is not null.","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":42},{"new_code_raw":"public static Result createGemFireErrorResult(String message) { return createErrorResult(ERRORCODE_GEODE_ERROR, STR + message); }","old_code_raw":"public static Result createGemFireErrorResult(String message) {\n    return createErrorResult(ERRORCODE_GEMFIRE_ERROR, STR + message);\n}","new_comment_raw":"@return Result for error in Geode while executing command.","old_comment_raw":"@return Result for error in GemFire while executing command.","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":20},{"new_code_raw":"public static byte[] sha3omit12(byte[] input) { byte[] hash = sha3(input); byte[] address = copyOfRange(hash, NUM, hash.length); address[NUM] = Wallet.getAddressPreFixByte(); return address; }","old_code_raw":"public static byte[] sha3omit12(byte[] input) {\n    byte[] hash = sha3(input);\n    return copyOfRange(hash, NUM, hash.length);\n}","new_comment_raw":"@return - add_pre_fix + 20 right bytes of the hash keccak of the data","old_comment_raw":"@return - 20 right bytes of the hash keccak of the data","label":1,"pre_label":0,"AST_level":7,"line_counts":6,"new_code_token_num":49},{"new_code_raw":"public BooleanExpression endsWith(Expression<String> str) { return BooleanOperation.create(Ops.ENDS_WITH, mixin, str); }","old_code_raw":"    public BooleanExpression endsWith(Expression<String> str) {\n        return BooleanOperation.create(Ops.ENDS_WITH, this, str);\n    }\n","new_comment_raw":"@return this.endsWith(str)","old_comment_raw":"@return this.endsWith(str)","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":22},{"new_code_raw":"public Value valueFor(String unescapedTag) { Value value = attributes.get(Tag.from(escapeTag(unescapedTag), false)); return value == null ? Value.NULL_VALUE : value; }","old_code_raw":"public Entry valueFor(String unescapedTag) {\n    Entry entry = attributes.get(unescapedTag);\n    return entry == null ? Entry.NULL_ENTRY : entry;\n}","new_comment_raw":"@return the <code>Value<\/code> object for the given unescaped tag.","old_comment_raw":"@return the <code>Entry<\/code> for the given unescaped tag.","label":1,"pre_label":0,"AST_level":8,"line_counts":4,"new_code_token_num":35},{"new_code_raw":"public boolean next() throws SQLException { if ( ! initialSchemaLoaded ) { throw new IllegalStateException( \"next() called but loadInitialSchema() was not called\" ); } assert afterFirstBatch : \"afterFirstBatch still false in next()\"; if ( afterLastRow ) { \/\/ We're already after end of rows\/records--just report that after end. return false; } else if ( returnTrueForNextCallToNext ) { ++currentRowNumber; \/\/ We have a deferred \"not after end\" to report--reset and report that. returnTrueForNextCallToNext = false; return true; } else { accessors.clearLastColumnIndexedInRow(); boolean res = nextRowInternally(); if (res) { ++ currentRowNumber; } return res; } }","old_code_raw":"  public boolean next() throws SQLException {\n    if ( ! initialSchemaLoaded ) {\n      throw new IllegalStateException(\n          \"next() called but loadInitialSchema() was not called\" );\n    }\n    assert afterFirstBatch : \"afterFirstBatch still false in next()\";\n\n    if ( afterLastRow ) {\n      \/\/ We're already after end of rows\/records--just report that after end.\n      return false;\n    }\n    else if ( returnTrueForNextCallToNext ) {\n      \/\/ We have a deferred \"not after end\" to report--reset and report that.\n      returnTrueForNextCallToNext = false;\n      return true;\n    }\n    else {\n      accessors.clearLastColumnIndexedInRow();\n      return nextRowInternally();\n    }\n  }\n","new_comment_raw":"@return whether cursor is positioned at a row (false when after end of results)","old_comment_raw":"@return whether cursor is positioned at a row (false when after end of results)","label":0,"pre_label":1,"AST_level":9,"line_counts":26,"new_code_token_num":139},{"new_code_raw":"@Processor @OAuthProtected @OAuthInvalidateAccessTokenOn(exception = OAuthTokenExpiredException.class) @Paged public PagingDelegate<CalendarList> getCalendarList(@Optional @Default(STR) final boolean showHidden, final PagingConfiguration pagingConfiguration) throws IOException { return new TokenBasedPagingDelegate<CalendarList>() { @Override public List<CalendarList> doGetPage() throws IOException { com.google.api.services.calendar.Calendar.CalendarList.List calendars = client.calendarList().list(); com.google.api.services.calendar.model.CalendarList list = calendars.setMaxResults(pagingConfiguration.getFetchSize()).setPageToken(this.getPageToken()).setShowHidden(showHidden).execute(); setPageToken(list.getNextPageToken()); return CalendarList.valueOf(list.getItems(), CalendarList.class); } }; }","old_code_raw":"@Processor\n@Inject\n@OAuthProtected\n@OAuthInvalidateAccessTokenOn(exception = OAuthTokenExpiredException.class)\npublic List<CalendarList> getCalendarList(MuleMessage message, @Optional @Default(STR) int maxResults, @Optional String pageToken, @Optional @Default(STR) boolean showHidden) throws IOException {\n    com.google.api.services.calendar.Calendar.CalendarList.List calendars = this.client.calendarList().list();\n    com.google.api.services.calendar.model.CalendarList list = calendars.setMaxResults(maxResults).setPageToken(pageToken).setShowHidden(showHidden).execute();\n    this.saveNextPageToken(list, message);\n    return CalendarList.valueOf(list.getItems(), CalendarList.class);\n}","new_comment_raw":"@return a paginated iterator with instances of {@link org.mule.module.google.calendar.model.CalendarList}","old_comment_raw":"@return a list with instances of {@link org.mule.module.google.calendar.model.CalendarList}","label":1,"pre_label":0,"AST_level":14,"line_counts":16,"new_code_token_num":127},{"new_code_raw":"@Override public final String toString() { StringBuilder sb = new StringBuilder(); sb.append(STR); Iterator<E> it = iterator(); if (it.hasNext()) { for (; ; ) { Object e = it.next(); sb.append(e == this ? STR : e); if (!it.hasNext()) { break; } sb.append(STR).append(STR); } } return sb.append(STR).toString(); }","old_code_raw":"@Override\npublic String toString() {\n    Node<K, V>[] t;\n    int f = (t = table) == null ? NUM : t.length;\n    Traverser<K, V> it = new Traverser<K, V>(t, f, NUM, f);\n    StringBuilder sb = new StringBuilder();\n    sb.append(STR);\n    Node<K, V> p;\n    if ((p = it.advance()) != null) {\n        for (; ; ) {\n            K k = p.key;\n            V v = p.val;\n            sb.append(k == this ? STR : k);\n            sb.append(STR);\n            sb.append(v == this ? STR : v);\n            if ((p = it.advance()) == null) {\n                break;\n            }\n            sb.append(STR).append(STR);\n        }\n    }\n    return sb.append(STR).toString();\n}","new_comment_raw":"@return a string representation of this collection","old_comment_raw":"@return a string representation of this map","label":1,"pre_label":0,"AST_level":11,"line_counts":17,"new_code_token_num":96},{"new_code_raw":"public Queue createQueue(String queueName) throws JMSException { checkClosed(); if (queueName.startsWith(ActiveMQDestination.TEMP_DESTINATION_NAME_PREFIX)) { return new ActiveMQTempQueue(queueName); } return new ActiveMQQueue(queueName); }","old_code_raw":"    public Queue createQueue(String queueName) throws JMSException {\n        checkClosed();\n        return new ActiveMQQueue(queueName);\n    }\n","new_comment_raw":"@return a Queue with the given name","old_comment_raw":"@return a Queue with the given name","label":0,"pre_label":1,"AST_level":7,"line_counts":8,"new_code_token_num":40},{"new_code_raw":"public int getMaximumValue() { return getField().getMaximumValue(getReadablePartial()); }","old_code_raw":"    public int getMaximumValue() {\n        return getField().getMaximumValue(getPartialInstant());\n    }\n","new_comment_raw":"@return the maximum value","old_comment_raw":"@return the maximum value","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":18},{"new_code_raw":"public synchronized List<ColumnIdentifier> getColumns(TableIdentifier tbl) { String schema = getSchemaToUse(tbl.getSchema()); TableIdentifier toSearch = tbl.createCopy(); toSearch.adjustCase(dbConnection); if (toSearch.getSchema() == null) { toSearch.setSchema(schema); } List<ColumnIdentifier> cols = this.objects.get(toSearch); if (cols == null) { try { TableDefinition def = dbConnection.getMetadata().getTableDefinition(toSearch); addTable(def); } catch (SQLException sql) { LogMgr.logWarning(STR, STR, sql); return null; } } if (retrieveOraclePublicSynonyms && toSearch.getSchema() != null && cols == null) { toSearch.setSchema(null); toSearch.setType(null); cols = this.objects.get(toSearch); if (cols == null) { this.getTables(STR); cols = this.objects.get(toSearch); } } if (CollectionUtil.isEmpty(cols)) { TableIdentifier tblToUse = null; if (objects.containsKey(toSearch)) { tblToUse = findEntry(toSearch); } else { tblToUse = this.dbConnection.getMetadata().findObject(toSearch); } try { cols = this.dbConnection.getMetadata().getTableColumns(tblToUse); } catch (Throwable e) { LogMgr.logError(STR, STR + tblToUse, e); cols = null; } if (tblToUse != null && CollectionUtil.isNonEmpty(cols)) { this.objects.put(tblToUse, cols); } } return Collections.unmodifiableList(cols); }","old_code_raw":"public List<ColumnIdentifier> getColumns(TableIdentifier tbl) {\n    String schema = getSchemaToUse(tbl.getSchema());\n    if (this.objects.size() == NUM || !schemasInCache.contains(schema == null ? NULL_SCHEMA : schema)) {\n        this.getTables(schema);\n    }\n    TableIdentifier toSearch = tbl.createCopy();\n    toSearch.adjustCase(dbConnection);\n    if (toSearch.getSchema() == null) {\n        toSearch.setSchema(schema);\n    }\n    List<ColumnIdentifier> cols = this.objects.get(toSearch);\n    if (retrieveOraclePublicSynonyms && toSearch.getSchema() != null && cols == null) {\n        toSearch.setSchema(null);\n        toSearch.setType(null);\n        cols = this.objects.get(toSearch);\n        if (cols == null) {\n            this.getTables(STR);\n            cols = this.objects.get(toSearch);\n        }\n    }\n    if (CollectionUtil.isEmpty(cols)) {\n        TableIdentifier tblToUse = null;\n        if (objects.containsKey(toSearch)) {\n            tblToUse = findEntry(toSearch);\n        } else {\n            tblToUse = this.dbConnection.getMetadata().findObject(toSearch);\n        }\n        try {\n            cols = this.dbConnection.getMetadata().getTableColumns(tblToUse);\n        } catch (Throwable e) {\n            LogMgr.logError(STR, STR + tblToUse, e);\n            cols = null;\n        }\n        if (tblToUse != null && CollectionUtil.isNonEmpty(cols)) {\n            this.objects.put(tblToUse, cols);\n        }\n    }\n    return Collections.unmodifiableList(cols);\n}","new_comment_raw":"@return the columns of the table.","old_comment_raw":"@return a List with {@link workbench.db.ColumnIdentifier} objects","label":1,"pre_label":0,"AST_level":11,"line_counts":45,"new_code_token_num":276},{"new_code_raw":"public static String getSqlTypeName(final MajorType type) { if (type.getMode() == DataMode.REPEATED || type.getMinorType() == MinorType.LIST) { return \"ARRAY\"; } switch (type.getMinorType()) { \/\/ Standard SQL atomic data types: case BIT: return \"BOOLEAN\"; case SMALLINT: return \"SMALLINT\"; case INT: return \"INTEGER\"; case BIGINT: return \"BIGINT\"; case FLOAT4: return \"FLOAT\"; case FLOAT8: return \"DOUBLE\"; case DECIMAL9: case DECIMAL18: case DECIMAL28DENSE: case DECIMAL28SPARSE: case DECIMAL38DENSE: case DECIMAL38SPARSE: return \"DECIMAL\"; case VARCHAR: return \"CHARACTER VARYING\"; case FIXEDCHAR: return \"CHARACTER\"; case VAR16CHAR: return \"NATIONAL CHARACTER VARYING\"; case FIXED16CHAR: return \"NATIONAL CHARACTER\"; case VARBINARY: return \"BINARY VARYING\"; case FIXEDBINARY: return \"BINARY\"; case DATE: return \"DATE\"; case TIME: return \"TIME\"; case TIMETZ: return \"TIME WITH TIME ZONE\"; case TIMESTAMP: return \"TIMESTAMP\"; case TIMESTAMPTZ: return \"TIMESTAMP WITH TIME ZONE\"; case INTERVALYEAR: return \"INTERVAL YEAR TO MONTH\"; case INTERVALDAY: return \"INTERVAL DAY TO SECOND\"; \/\/ Non-standard SQL atomic data types: case INTERVAL: return \"INTERVAL\"; case MONEY: return \"DECIMAL\"; case TINYINT: return \"TINYINT\"; \/\/ Composite types and other types that are not atomic types (SQL standard \/\/ or not) except ARRAY types (handled above): case MAP: return \"MAP\"; case LATE: return \"ANY\"; case NULL: return \"NULL\"; case UNION: return \"UNION\"; case GENERIC_OBJECT: return \"JAVA_OBJECT\"; \/\/ Internal types not actually used at level of SQL types(?): case UINT1: return \"TINYINT\"; case UINT2: return \"SMALLINT\"; case UINT4: return \"INTEGER\"; case UINT8: return \"BIGINT\"; default: throw new AssertionError( \"Unexpected\/unhandled MinorType value \" + type.getMinorType() ); } }","old_code_raw":"  public static String getSqlTypeName(final MajorType type) {\n    if (type.getMode() == DataMode.REPEATED || type.getMinorType() == MinorType.LIST) {\n      return \"ARRAY\";\n    }\n\n    switch (type.getMinorType()) {\n\n      \/\/ Standard SQL atomic data types:\n\n      case BIT:             return \"BOOLEAN\";\n\n      case SMALLINT:        return \"SMALLINT\";\n      case INT:             return \"INTEGER\";\n      case BIGINT:          return \"BIGINT\";\n\n      case FLOAT4:          return \"FLOAT\";\n      case FLOAT8:          return \"DOUBLE\";\n\n      case DECIMAL9:\n      case DECIMAL18:\n      case DECIMAL28DENSE:\n      case DECIMAL28SPARSE:\n      case DECIMAL38DENSE:\n      case DECIMAL38SPARSE: return \"DECIMAL\";\n\n      case VARCHAR:         return \"CHARACTER VARYING\";\n      case FIXEDCHAR:       return \"CHARACTER\";\n\n      case VAR16CHAR:       return \"NATIONAL CHARACTER VARYING\";\n      case FIXED16CHAR:     return \"NATIONAL CHARACTER\";\n\n      case VARBINARY:       return \"BINARY VARYING\";\n      case FIXEDBINARY:     return \"BINARY\";\n\n      case DATE:            return \"DATE\";\n      case TIME:            return \"TIME\";\n      case TIMETZ:          return \"TIME WITH TIME ZONE\";\n      case TIMESTAMP:       return \"TIMESTAMP\";\n      case TIMESTAMPTZ:     return \"TIMESTAMP WITH TIME ZONE\";\n\n      case INTERVALYEAR:    return \"INTERVAL YEAR TO MONTH\";\n      case INTERVALDAY:     return \"INTERVAL DAY TO SECOND\";\n\n      \/\/ Non-standard SQL atomic data types:\n\n      case INTERVAL:        return \"INTERVAL\";\n      case MONEY:           return \"DECIMAL\";\n      case TINYINT:         return \"TINYINT\";\n\n      \/\/ Composite types and other types that are not atomic types (SQL standard\n      \/\/ or not) except ARRAY types (handled above):\n\n      case MAP:             return \"MAP\";\n      case LATE:            return \"ANY\";\n      case NULL:            return \"NULL\";\n      case UNION:           return \"UNION\";\n\n      \/\/ Internal types not actually used at level of SQL types(?):\n\n      case UINT1:          return \"TINYINT\";\n      case UINT2:          return \"SMALLINT\";\n      case UINT4:          return \"INTEGER\";\n      case UINT8:          return \"BIGINT\";\n\n      default:\n        throw new AssertionError(\n            \"Unexpected\/unhandled MinorType value \" + type.getMinorType() );\n    }\n  }\n","new_comment_raw":"@return canonical keyword sequence for SQL data type (leading keywords in corresponding  ; what  INFORMATION_SCHEMA.COLUMNS.TYPE_NAME would list)","old_comment_raw":"@return canonical keyword sequence for SQL data type (leading keywords in corresponding ; what INFORMATION_SCHEMA.COLUMNS.TYPE_NAME would list)","label":0,"pre_label":1,"AST_level":8,"line_counts":71,"new_code_token_num":414},{"new_code_raw":"boolean recordRead(int bufferIndex, Node<K, V> node) { final AtomicLong counter = readBufferWriteCount()[bufferIndex]; final long writeCount = counter.get(); final int index = (int) (writeCount & READ_BUFFER_INDEX_MASK); AtomicReference<Node<K, V>> slot = readBuffers()[bufferIndex][index]; if (slot.get() != null) { return false; } else if (slot.compareAndSet(null, node)) { counter.lazySet(writeCount + NUM); } return true; }","old_code_raw":"long recordRead(int bufferIndex, Node<K, V> node) {\n    final AtomicLong counter = readBufferWriteCount()[bufferIndex];\n    final long writeCount = counter.get();\n    counter.lazySet(writeCount + NUM);\n    final int index = (int) (writeCount & READ_BUFFER_INDEX_MASK);\n    readBuffers()[bufferIndex][index].lazySet(node);\n    return writeCount;\n}","new_comment_raw":"@return if draining the read buffer can be delayed","old_comment_raw":"@return the number of writes on the chosen read buffer","label":1,"pre_label":0,"AST_level":9,"line_counts":12,"new_code_token_num":98},{"new_code_raw":"Context findNewNode(final VirtualHost.HostEntry entry) { return electNode(entry.getContexts(), false, null); }","old_code_raw":"Node findNewNode(final VirtualHost.HostEntry entry) {\n    return electNode(entry.getContexts(), false, null);\n}","new_comment_raw":"@return the context, {@code null} if not found","old_comment_raw":"@return the node, {@code null} if no node could be found","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":23},{"new_code_raw":"public String createSessionId(final String sessionId, final String memcachedId) { if (memcachedId == null) { return sessionId; } final int idx = sessionId.indexOf(STR); if (idx < NUM) { return sessionId + STR + memcachedId; } else { return sessionId.substring(NUM, idx) + STR + memcachedId + sessionId.substring(idx); } }","old_code_raw":"public String createSessionId(final String sessionId, final String memcachedId) {\n    final int idx = sessionId.indexOf(STR);\n    if (idx < NUM) {\n        return sessionId + STR + memcachedId;\n    } else {\n        return sessionId.substring(NUM, idx) + STR + memcachedId + sessionId.substring(idx);\n    }\n}","new_comment_raw":"@return the sessionId which now contains the memcachedId if one was provided, otherwise the sessionId unmodified.","old_comment_raw":"@return the sessionId which now contains the memcachedId.","label":1,"pre_label":0,"AST_level":10,"line_counts":11,"new_code_token_num":69},{"new_code_raw":"public static TimeExtractionFunction createExtractFromGranularity(Granularity granularity) { switch (granularity) { case DAY: return new TimeExtractionFunction(\"d\", null, \"UTC\", Locale.getDefault().toLanguageTag()); case MONTH: return new TimeExtractionFunction(\"M\", null, \"UTC\", Locale.getDefault().toLanguageTag()); case YEAR: return new TimeExtractionFunction(\"yyyy\", null, \"UTC\", Locale.getDefault().toLanguageTag()); case WEEK: return new TimeExtractionFunction(\"w\", null, \"UTC\", Locale.getDefault().toLanguageTag()); default: throw new IllegalArgumentException(\"Granularity [\" + granularity + \"] is not supported\"); } }","old_code_raw":"  public static TimeExtractionFunction createExtractFromGranularity(Granularity granularity) {\n    switch (granularity) {\n    case DAY:\n      return new TimeExtractionFunction(\"d\", null, \"UTC\", Locale.getDefault().toLanguageTag());\n    case MONTH:\n      return new TimeExtractionFunction(\"M\", null, \"UTC\", Locale.getDefault().toLanguageTag());\n    case YEAR:\n      return new TimeExtractionFunction(\"yyyy\", null, \"UTC\", Locale.getDefault().toLanguageTag());\n    default:\n      throw new AssertionError(\"Extraction \" + granularity.value + \" is not valid\");\n    }\n  }\n","new_comment_raw":"@return the time extraction function corresponding to the granularity input unit  TimeExtractionFunction#VALID_TIME_EXTRACT for supported granularity","old_comment_raw":"@return the time extraction function or null if granularity is not supported","label":1,"pre_label":0,"AST_level":9,"line_counts":15,"new_code_token_num":141},{"new_code_raw":"private String buildQuery2(String expression) { \/\/ \"values (1 < 5)\" \/\/ becomes \/\/ \"select p0 < p1 from (values (1, 5)) as t(p0, p1)\" SqlNode x; final String sql = \"values (\" + expression + \")\"; try { x = parseQuery(sql); } catch (SqlParseException e) { throw new RuntimeException(e); } final Collection<SqlNode> literalSet = new LinkedHashSet<SqlNode>(); x.accept( new SqlShuttle() { private final List<SqlOperator> ops = ImmutableList.<SqlOperator>of( SqlStdOperatorTable.literalChainOperator, SqlStdOperatorTable.localTimeFunc, SqlStdOperatorTable.localTimestampFunc, SqlStdOperatorTable.currentTimeFunc, SqlStdOperatorTable.currentTimestampFunc); @Override public SqlNode visit(SqlLiteral literal) { if (!isNull(literal) && literal.getTypeName() != SqlTypeName.SYMBOL) { literalSet.add(literal); } return literal; } @Override public SqlNode visit(SqlCall call) { final SqlOperator operator = call.getOperator(); if (operator == SqlStdOperatorTable.castFunc && isNull(call.getOperandList().get(0))) { literalSet.add(call); return call; } else if (ops.contains(operator)) { \/\/ \"Argument to function 'LOCALTIME' must be a \/\/ literal\" return call; } else { return super.visit(call); } } private boolean isNull(SqlNode sqlNode) { return sqlNode instanceof SqlLiteral && ((SqlLiteral) sqlNode).getTypeName() == SqlTypeName.NULL; } }); final List<SqlNode> nodes = new ArrayList<SqlNode>(literalSet); Collections.sort( nodes, new Comparator<SqlNode>() { public int compare(SqlNode o1, SqlNode o2) { final SqlParserPos pos0 = o1.getParserPosition(); final SqlParserPos pos1 = o2.getParserPosition(); int c = -Utilities.compare( pos0.getLineNum(), pos1.getLineNum()); if (c != 0) { return c; } return -Utilities.compare( pos0.getColumnNum(), pos1.getColumnNum()); } }); String sql2 = sql; final List<Pair<String, String>> values = new ArrayList<Pair<String, String>>(); int p = 0; for (SqlNode literal : nodes) { final SqlParserPos pos = literal.getParserPosition(); final int start = SqlParserUtil.lineColToIndex( sql, pos.getLineNum(), pos.getColumnNum()); final int end = SqlParserUtil.lineColToIndex( sql, pos.getEndLineNum(), pos.getEndColumnNum()) + 1; String param = \"p\" + (p++); values.add(Pair.of(sql2.substring(start, end), param)); sql2 = sql2.substring(0, start) + param + sql2.substring(end); } if (values.isEmpty()) { values.add(Pair.of(\"1\", \"p0\")); } return \"select \" + sql2.substring(\"values (\".length(), sql2.length() - 1) + \" from (values (\" + Util.commaList(Pair.left(values)) + \")) as t(\" + Util.commaList(Pair.right(values)) + \")\"; }","old_code_raw":"        private String buildQuery2(String expression)\n        {\n            \/\/ \"values (1 < 5)\"\n            \/\/ becomes\n            \/\/ \"select p0 < p1 from (values (1, 5)) as t(p0, p1)\"\n            SqlNode x;\n            final String sql = \"values (\" + expression + \")\";\n            try {\n                x = parseQuery(sql);\n            } catch (SqlParseException e) {\n                throw new RuntimeException(e);\n            }\n            final Collection<SqlNode> literalSet = new LinkedHashSet<SqlNode>();\n            x.accept(\n                new SqlShuttle() {\n                    private final List<SqlOperator> ops =\n                        ImmutableList.<SqlOperator>of(\n                            SqlStdOperatorTable.literalChainOperator,\n                            SqlStdOperatorTable.localTimeFunc,\n                            SqlStdOperatorTable.localTimestampFunc,\n                            SqlStdOperatorTable.currentTimeFunc,\n                            SqlStdOperatorTable.currentTimestampFunc);\n\n                    @Override\n                    public SqlNode visit(SqlLiteral literal) {\n                        if (!isNull(literal)\n                            && literal.getTypeName() != SqlTypeName.SYMBOL)\n                        {\n                            literalSet.add(literal);\n                        }\n                        return literal;\n                    }\n\n                    @Override\n                    public SqlNode visit(SqlCall call) {\n                        final SqlOperator operator = call.getOperator();\n                        if (operator == SqlStdOperatorTable.castFunc\n                            && isNull(call.getOperandList().get(0)))\n                        {\n                            literalSet.add(call);\n                            return call;\n                        } else if (ops.contains(operator)) {\n                            \/\/ \"Argument to function 'LOCALTIME' must be a\n                            \/\/ literal\"\n                            return call;\n                        } else {\n                            return super.visit(call);\n                        }\n                    }\n\n                    private boolean isNull(SqlNode sqlNode) {\n                        return sqlNode instanceof SqlLiteral\n                            && ((SqlLiteral) sqlNode).getTypeName()\n                               == SqlTypeName.NULL;\n                    }\n                });\n            final List<SqlNode> nodes = new ArrayList<SqlNode>(literalSet);\n            Collections.sort(\n                nodes,\n                new Comparator<SqlNode>() {\n                    public int compare(SqlNode o1, SqlNode o2) {\n                        final SqlParserPos pos0 = o1.getParserPosition();\n                        final SqlParserPos pos1 = o2.getParserPosition();\n                        int c = -Integer.compare(\n                            pos0.getLineNum(), pos1.getLineNum());\n                        if (c != 0) {\n                            return c;\n                        }\n                        return -Integer.compare(\n                            pos0.getColumnNum(), pos1.getColumnNum());\n                    }\n                });\n            String sql2 = sql;\n            final List<Pair<String, String>> values =\n                new ArrayList<Pair<String, String>>();\n            int p = 0;\n            for (SqlNode literal : nodes) {\n                final SqlParserPos pos = literal.getParserPosition();\n                final int start =\n                    SqlParserUtil.lineColToIndex(\n                        sql, pos.getLineNum(), pos.getColumnNum());\n                final int end =\n                    SqlParserUtil.lineColToIndex(\n                        sql,\n                        pos.getEndLineNum(),\n                        pos.getEndColumnNum()) + 1;\n                String param = \"p\" + (p++);\n                values.add(Pair.of(sql2.substring(start, end), param));\n                sql2 = sql2.substring(0, start)\n                    + param\n                    + sql2.substring(end);\n            }\n            if (values.isEmpty()) {\n                values.add(Pair.of(\"1\", \"p0\"));\n            }\n            return \"select \"\n                   + sql2.substring(\"values (\".length(), sql2.length() - 1)\n                   + \" from (values (\"\n                   + Util.commaList(Pair.left(values))\n                   + \")) as t(\"\n                   + Util.commaList(Pair.right(values))\n                   + \")\";\n        }\n","new_comment_raw":"@return Query that evaluates a scalar expression","old_comment_raw":"@return Query that evaluates a scalar expression","label":0,"pre_label":1,"AST_level":12,"line_counts":104,"new_code_token_num":598},{"new_code_raw":"protected final long currentTimeMillis() { return nanosToMillis(ticker.read()); }","old_code_raw":"protected long currentTimeMillis() {\n    return nanoToMillis(ticker.read());\n}","new_comment_raw":"@return the current time in milliseconds","old_comment_raw":"@return an approximate of the current time in milliseconds","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":17},{"new_code_raw":"public ParameterList getQueryStringParams() { try { ParameterList result = new ParameterList(); String queryString = new URL(url).getQuery(); result.addQuerystring(queryString); result.addAll(querystringParams); return result; } catch (MalformedURLException mue) { throw new OAuthException(STR, mue); } }","old_code_raw":"public Map<String, String> getQueryStringParams() {\n    try {\n        Map<String, String> params = new HashMap<String, String>();\n        String queryString = new URL(url).getQuery();\n        params.putAll(MapUtils.queryStringToMap(queryString));\n        params.putAll(this.querystringParams);\n        return params;\n    } catch (MalformedURLException mue) {\n        throw new OAuthException(STR, mue);\n    }\n}","new_comment_raw":"@return a {@link ParameterList} containing the query string parameters.","old_comment_raw":"@return a map containing the query string parameters","label":1,"pre_label":0,"AST_level":7,"line_counts":11,"new_code_token_num":59},{"new_code_raw":"public Object next() throws java.io.IOException { int zzInput; int zzAction; \/\/ cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; \/\/ set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { \/\/ store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); \/\/ get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } \/\/ store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { String str = yytext(); int first = str.charAt(0); String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } logger.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: logger.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 67: break; case 2: { return getNext(\"<\", yytext()); } case 68: break; case 3: { return getNext(); } case 69: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 70: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 71: break; case 6: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 72: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 73: break; case 8: { return handleQuotes(yytext(), false); } case 74: break; case 9: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 75: break; case 10: { return getNext(\">\", yytext()); } case 76: break; case 11: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 77: break; case 12: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 78: break; case 13: { return handleEllipsis(yytext()); } case 79: break; case 14: { return normalizeFractions(yytext()); } case 80: break; case 15: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(); } } case 81: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 82: break; case 17: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 83: break; case 18: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 84: break; case 19: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 85: break; case 20: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 86: break; case 21: { if (normalizeOtherBrackets) { return getNext(\"-RSB-\", yytext()); } else { return getNext(); } } case 87: break; case 22: { if (normalizeOtherBrackets) { return getNext(\"-LSB-\", yytext()); } else { return getNext(); } } case 88: break; case 23: { if (invertible) { prevWordAfter.append(yytext()); } } case 89: break; case 24: { return getNext(\"\\u2022\", yytext()); } case 90: break; case 25: { return getNext(\"\\u2122\", yytext()); } case 91: break; case 26: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 92: break; case 27: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return getNext(); } case 93: break; case 28: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), true); } case 94: break; case 29: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 95: break; case 30: { breakByHyphens(yytext()); return getNext(removeSoftHyphens(yytext()), yytext()); } case 96: break; case 31: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 97: break; case 32: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 98: break; case 33: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 99: break; case 34: { \/\/ this one should only match if we're basically at the end of file \/\/ since the last one matches two things, even newlines (if not tokenize per line) String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 100: break; case 35: \/\/ lookahead expression with fixed lookahead length yypushback(1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 101: break; case 36: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 1; { \/* invert quote - often but not always right *\/ return handleQuotes(yytext(), true); } case 102: break; case 37: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), false); } case 103: break; case 38: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 104: break; case 39: { String txt = yytext(); \/\/ if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space... if (strictTreebank3) { int spaceIndex = indexOfSpace(txt); if (spaceIndex >= 0) { yypushback(txt.length() - spaceIndex); String newText = yytext(); return getNext(newText, newText); } } if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, txt); } case 105: break; case 40: { return getNormalizedAmpNext(); } case 106: break; case 41: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, origTxt); } case 107: break; case 42: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space } return getNext(txt, origTxt); } case 108: break; case 43: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 109: break; case 44: { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 110: break; case 45: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 17; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 111: break; case 46: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 3; { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 112: break; case 47: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 113: break; case 48: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 22; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 114: break; case 49: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 18; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 19; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 115: break; case 50: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 116: break; case 51: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 21; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 117: break; case 52: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 118: break; case 53: \/\/ lookahead expression with fixed lookahead length yypushback(1); { breakByHyphens(yytext()); return getNext(removeSoftHyphens(yytext()), yytext()); } case 119: break; case 54: { if (splitAssimilations) { yypushback(3) ; return getNext(); } else { return getNext(); } } case 120: break; case 55: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return getNormalizedAmpNext(); } case 121: break; case 56: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 9; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 122: break; case 57: \/\/ lookahead expression with fixed lookahead length yypushback(2); { return getNext(); } case 123: break; case 58: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 124: break; case 59: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 125: break; case 60: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 13; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 126: break; case 61: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } return getNext(txt, yytext()); } case 127: break; case 62: \/\/ lookahead expression with fixed lookahead length yypushback(4); { return getNext(); } case 128: break; case 63: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 3; { return getNext(); } case 129: break; case 64: { String txt = yytext(); if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 130: break; case 65: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 25; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 131: break; case 66: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 24; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 132: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }","old_code_raw":"  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    \/\/ cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      \/\/ set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            \/\/ store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            \/\/ get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      \/\/ store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n        zzAtEOF = true;\n              {\n                if (invertible) {\n            prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            prevWordAfter.setLength(0);\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n          }\n          return null;\n              }\n      }\n      else {\n        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n          case 1: \n            { String str = yytext();\n          int first = str.codePointAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n            }\n          case 67: break;\n          case 2: \n            { return getNext(\"<\", yytext());\n            }\n          case 68: break;\n          case 3: \n            { return getNext();\n            }\n          case 69: break;\n          case 4: \n            { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n            }\n          case 70: break;\n          case 5: \n            { if (tokenizeNLs) {\n                      return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns\n                  } else if (invertible) {\n                      prevWordAfter.append(yytext());\n                  }\n            }\n          case 71: break;\n          case 6: \n            { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n            }\n          case 72: break;\n          case 7: \n            { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n            }\n          case 73: break;\n          case 8: \n            { return handleQuotes(yytext(), false);\n            }\n          case 74: break;\n          case 9: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '\/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 75: break;\n          case 10: \n            { return getNext(\">\", yytext());\n            }\n          case 76: break;\n          case 11: \n            { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n            }\n          case 77: break;\n          case 12: \n            { return getNext(removeFromNumber(yytext()), yytext());\n            }\n          case 78: break;\n          case 13: \n            { return handleEllipsis(yytext());\n            }\n          case 79: break;\n          case 14: \n            { return normalizeFractions(yytext());\n            }\n          case 80: break;\n          case 15: \n            { if (normalizeCurrency) {\n                            return getNext(normalizeCurrency(yytext()), yytext());\n                        } else {\n                            return getNext(minimallyNormalizeCurrency(yytext()), yytext());\n                          }\n            }\n          case 81: break;\n          case 16: \n            { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 82: break;\n          case 17: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-RSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 83: break;\n          case 18: \n            { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 84: break;\n          case 19: \n            { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 85: break;\n          case 20: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 86: break;\n          case 21: \n            { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 87: break;\n          case 22: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-LSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 88: break;\n          case 23: \n            { if (invertible) {\n                            prevWordAfter.append(yytext());\n                        }\n            }\n          case 89: break;\n          case 24: \n            { return getNext(\"\\u2022\", yytext());\n            }\n          case 90: break;\n          case 25: \n            { return getNext(\"\\u2122\", yytext());\n            }\n          case 91: break;\n          case 26: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 15;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 92: break;\n          case 27: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext();\n            }\n          case 93: break;\n          case 28: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return handleQuotes(yytext(), true);\n            }\n          case 94: break;\n          case 29: \n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 95: break;\n          case 30: \n            { breakByHyphens(yytext());\n                    return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 96: break;\n          case 31: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 3;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 4;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n            }\n          case 97: break;\n          case 32: \n            { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '\/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 98: break;\n          case 33: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 99: break;\n          case 34: \n            { \/\/ this one should only match if we're basically at the end of file\n                          \/\/ since the last one matches two things, even newlines (if not tokenize per line)\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n                          return getNext(s, yytext());\n            }\n          case 100: break;\n          case 35: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 101: break;\n          case 36: \n            \/\/ lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 1);\n            { \/* invert quote - often but not always right *\/\n                  return handleQuotes(yytext(), true);\n            }\n          case 102: break;\n          case 37: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return handleQuotes(yytext(), false);\n            }\n          case 103: break;\n          case 38: \n            { return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 104: break;\n          case 39: \n            { String txt = yytext();\n                  \/\/ if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space...\n                  if (strictTreebank3) {\n                    int spaceIndex = indexOfSpace(txt);\n                    if (spaceIndex >= 0) {\n                      yypushback(txt.length() - spaceIndex);\n                      String newText = yytext();\n                      return getNext(newText, newText);\n                    }\n                  }\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '\/');\n                  }\n                  if (normalizeSpace) {\n                    txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                  }\n                  return getNext(txt, txt);\n            }\n          case 105: break;\n          case 40: \n            { return getNormalizedAmpNext();\n            }\n          case 106: break;\n          case 41: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 107: break;\n          case 42: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 108: break;\n          case 43: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 5;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 6;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String txt = yytext();\n                          return getNext(removeSoftHyphens(txt),\n                                         txt);\n            }\n          case 109: break;\n          case 44: \n            { if (splitAssimilations) {\n                            yypushback(2) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 110: break;\n          case 45: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 17;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 111: break;\n          case 46: \n            \/\/ lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);\n            { if (splitAssimilations) {\n                            yypushback(2) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 112: break;\n          case 47: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 10;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 113: break;\n          case 48: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 22;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 114: break;\n          case 49: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 18;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 19;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 115: break;\n          case 50: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 10;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 116: break;\n          case 51: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 21;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 117: break;\n          case 52: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 118: break;\n          case 53: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { breakByHyphens(yytext());\n                    return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 119: break;\n          case 54: \n            { if (splitAssimilations) {\n                            yypushback(3) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 120: break;\n          case 55: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNormalizedAmpNext();\n            }\n          case 121: break;\n          case 56: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 9;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 122: break;\n          case 57: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { return getNext();\n            }\n          case 123: break;\n          case 58: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 14;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 124: break;\n          case 59: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 8;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 125: break;\n          case 60: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 13;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 126: break;\n          case 61: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 127: break;\n          case 62: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4);\n            { return getNext();\n            }\n          case 128: break;\n          case 63: \n            \/\/ lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);\n            { return getNext();\n            }\n          case 129: break;\n          case 64: \n            { String txt = yytext();\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 130: break;\n          case 65: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 23;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 25;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 131: break;\n          case 66: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 23;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 24;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 132: break;\n          default:\n            zzScanError(ZZ_NO_MATCH);\n        }\n      }\n    }\n  }\n","new_comment_raw":"@return the next token","old_comment_raw":"@return the next token","label":0,"pre_label":1,"AST_level":17,"line_counts":921,"new_code_token_num":5750},{"new_code_raw":"@RequestMapping(value = STR, method = { RequestMethod.PUT }) @ResponseBody public CubeRequest updateCubeDesc(@RequestBody CubeRequest cubeRequest) throws JsonProcessingException { CubeDesc desc = deserializeCubeDesc(cubeRequest); if (desc == null) { return cubeRequest; } final String cubeName = cubeRequest.getCubeName(); if (StringUtils.isEmpty(cubeName)) { return errorRequest(cubeRequest, STR); } MetadataManager metadataManager = MetadataManager.getInstance(cubeService.getConfig()); DataModelDesc modelDesc = null; DataModelDesc oldModelDesc = null; if (StringUtils.isNotEmpty(cubeRequest.getModelDescData())) { modelDesc = deserializeDataModelDesc(cubeRequest); if (modelDesc == null) { return cubeRequest; } final String modeName = modelDesc.getName(); if (!StringUtils.equals(desc.getModelName(), modeName)) { return errorRequest(cubeRequest, STR + desc.getModelName() + STR + modeName); } oldModelDesc = metadataManager.getDataModelDesc(modeName); if (oldModelDesc == null) { return errorRequest(cubeRequest, STR + modeName + STR); } } if (!cubeService.isCubeDescEditable(desc)) { String error = STR + desc.getName().toUpperCase() + STR; return errorRequest(cubeRequest, error); } boolean updateModelSuccess = false, updateCubeSuccess = false; try { if (modelDesc != null) { metadataManager.updateDataModelDesc(modelDesc); updateModelSuccess = true; } CubeInstance cube = cubeService.getCubeManager().getCube(cubeName); String projectName = (null == cubeRequest.getProject()) ? ProjectInstance.DEFAULT_PROJECT_NAME : cubeRequest.getProject(); desc = cubeService.updateCubeAndDesc(cube, desc, projectName); ProjectManager projectManager = cubeService.getProjectManager(); if (!cubeService.isCubeInProject(projectName, cube)) { String owner = SecurityContextHolder.getContext().getAuthentication().getName(); ProjectInstance newProject = projectManager.moveRealizationToProject(RealizationType.CUBE, cube.getName(), projectName, owner); accessService.inherit(cube, newProject); } if (desc.getError().isEmpty()) { cubeRequest.setSuccessful(true); updateCubeSuccess = true; } else { logger.warn(STR + desc.getName() + STR + desc.getError()); errorRequest(cubeRequest, omitMessage(desc.getError())); } } catch (AccessDeniedException accessDeniedException) { throw new ForbiddenException(STR); } catch (Exception e) { logger.error(STR + e.getLocalizedMessage(), e); throw new InternalErrorException(STR + e.getLocalizedMessage()); } finally { if (updateModelSuccess == true && updateCubeSuccess == false) { try { oldModelDesc.setLastModified(modelDesc.getLastModified()); metadataManager.updateDataModelDesc(oldModelDesc); } catch (IOException e) { logger.error(STR + e.getLocalizedMessage(), e); throw new InternalErrorException(STR + e.getLocalizedMessage()); } } } String descData = JsonUtil.writeValueAsIndentString(desc); cubeRequest.setCubeDescData(descData); return cubeRequest; }","old_code_raw":"@RequestMapping(value = STR, method = { RequestMethod.PUT })\n@ResponseBody\npublic CubeRequest updateCubeDesc(@RequestBody CubeRequest cubeRequest) throws JsonProcessingException {\n    CubeDesc desc = deserializeCubeDesc(cubeRequest);\n    if (desc == null) {\n        return cubeRequest;\n    }\n    final String cubeName = desc.getName();\n    if (StringUtils.isEmpty(cubeName)) {\n        return errorRequest(cubeRequest, STR);\n    }\n    MetadataManager metadataManager = MetadataManager.getInstance(KylinConfig.getInstanceFromEnv());\n    DataModelDesc modelDesc = null;\n    if (StringUtils.isNotEmpty(cubeRequest.getModelDescData())) {\n        modelDesc = deserializeDataModelDesc(cubeRequest);\n        if (modelDesc == null) {\n            return cubeRequest;\n        }\n        final String modeName = modelDesc.getName();\n        if (!StringUtils.equals(desc.getModelName(), modeName)) {\n            return errorRequest(cubeRequest, STR + desc.getModelName() + STR + modeName);\n        }\n        DataModelDesc oldModelDesc = metadataManager.getDataModelDesc(modeName);\n        if (oldModelDesc == null) {\n            return errorRequest(cubeRequest, STR + modeName + STR);\n        }\n        if (!modelDesc.compatibleWith(oldModelDesc)) {\n            return errorRequest(cubeRequest, STR);\n        }\n    }\n    if (!cubeService.isCubeDescEditable(desc)) {\n        String error = STR + desc.getName().toUpperCase() + STR;\n        return errorRequest(cubeRequest, error);\n    }\n    try {\n        if (modelDesc != null)\n            metadataManager.updateDataModelDesc(modelDesc);\n        CubeInstance cube = cubeService.getCubeManager().getCube(cubeName);\n        String projectName = (null == cubeRequest.getProject()) ? ProjectInstance.DEFAULT_PROJECT_NAME : cubeRequest.getProject();\n        desc = cubeService.updateCubeAndDesc(cube, desc, projectName);\n    } catch (AccessDeniedException accessDeniedException) {\n        throw new ForbiddenException(STR);\n    } catch (Exception e) {\n        logger.error(STR + e.getLocalizedMessage(), e);\n        throw new InternalErrorException(STR + e.getLocalizedMessage());\n    }\n    if (desc.getError().isEmpty()) {\n        cubeRequest.setSuccessful(true);\n    } else {\n        logger.warn(STR + desc.getName() + STR + desc.getError());\n        errorRequest(cubeRequest, omitMessage(desc.getError()));\n    }\n    String descData = JsonUtil.writeValueAsIndentString(desc);\n    cubeRequest.setCubeDescData(descData);\n    return cubeRequest;\n}","new_comment_raw":"@return cubeRequest cube change request","old_comment_raw":"@return Table metadata array","label":1,"pre_label":0,"AST_level":12,"line_counts":74,"new_code_token_num":526},{"new_code_raw":"public boolean searchToggleButton(String text, int minimumNumberOfMatches) { return searcher.searchWithTimeoutFor(ToggleButton.class, text, minimumNumberOfMatches, true, false); }","old_code_raw":"\tpublic boolean searchToggleButton(String text, int minimumNumberOfMatches) {\n\t\tboolean found = searcher.searchWithTimeoutFor(ToggleButton.class, text, minimumNumberOfMatches, true, false);\n\t\treturn found;\n\t}\n","new_comment_raw":"@return  true if a  ToggleButton with the given text is found a given number of times and  false if it is not found","old_comment_raw":"@return true if a ToggleButton with the given text is found a given number of times and false if it is not found","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":28},{"new_code_raw":"public Date getTimeStamp() { return timeStamp; }","old_code_raw":"public String getTimeStamp() {\n    return timeStamp;\n}","new_comment_raw":"@return a date instance representing the timestamp","old_comment_raw":"@return a string of the format \"Thu Oct 18 20:21:13 2001\"","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":10},{"new_code_raw":"public short getGreen() { return data[getFirst1DIndex() + NUM]; }","old_code_raw":"public short getGreen(final int i) {\n    return data[get1DIndex(i) + NUM];\n}","new_comment_raw":"@return green value in the first position","old_comment_raw":"@return green value in given position","label":1,"pre_label":0,"AST_level":7,"line_counts":3,"new_code_token_num":17},{"new_code_raw":"public Sentence caseless() { return new Sentence(this.docFn, impl.build(), Document.CASELESS_PROPS); }","old_code_raw":"  public Sentence caseless() {\n    this.defaultProps = Document.CASELESS_PROPS;\n    return this;\n  }\n","new_comment_raw":"@return A new sentence with the default properties swapped out.","old_comment_raw":"@return This same sentence, but with the default properties swapped out.","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":23},{"new_code_raw":"public boolean isBreakpoint(Message aMessage, boolean isRequest, boolean onlyIfInScope) { if (aMessage.isForceIntercept()) { \/\/ The browser told us to do it Your Honour return true; } if (onlyIfInScope && ! aMessage.isInScope()) { return false; } if (isBreakOnAllRequests(aMessage, isRequest)) { \/\/ Break on all requests return true; } else if (isBreakOnAllResponses(aMessage, isRequest)) { \/\/ Break on all responses return true; } else if (isBreakOnStepping(aMessage, isRequest)) { \/\/ Stopping through all requests and responses return true; } return isBreakOnEnabledBreakpoint(aMessage, isRequest, onlyIfInScope); }","old_code_raw":"    public boolean isBreakpoint(Message aMessage, boolean isRequest, boolean onlyIfInScope) {\n    \tif (onlyIfInScope && ! aMessage.isInScope()) {\n    \t\treturn false;\n    \t}\n    \t\n        if (isBreakOnAllRequests(aMessage, isRequest)) {\n            \/\/ Break on all requests\n            return true;\n        } else if (isBreakOnAllResponses(aMessage, isRequest)) {\n            \/\/ Break on all responses\n            return true;\n        } else if (isBreakOnStepping(aMessage, isRequest)) {\n            \/\/ Stopping through all requests and responses\n            return true;\n        }\n        \n        return isBreakOnEnabledBreakpoint(aMessage, isRequest, onlyIfInScope);\n    }\n","new_comment_raw":"@return True if a breakpoint for given message exists.","old_comment_raw":"@return True if a breakpoint for given message exists.","label":0,"pre_label":1,"AST_level":8,"line_counts":24,"new_code_token_num":128},{"new_code_raw":"@Override public int onReceiveLiquid(int type, int vol, byte side) { if (type == this.type) { int rejectedVolume = Math.max((this.getStoredLiquid(type) + vol) - this.capacity, NUM); this.liquidStored = vol - rejectedVolume; return rejectedVolume; } return vol; }","old_code_raw":"@Override\npublic int onReceiveLiquid(int type, int amt, byte side) {\n    if (type == this.type) {\n        int rejectedLiquid = Math.max((this.getStoredLiquid(type) + amt) - this.capacity, NUM);\n        this.liquidStored += watt - rejectedElectricity;\n        return rejectedLiquid;\n    }\n    return watt;\n}","new_comment_raw":"@return vol - The amount of rejected power to be sent back into the conductor","old_comment_raw":"@return watt - The amount of rejected power to be sent back into the conductor","label":1,"pre_label":0,"AST_level":12,"line_counts":9,"new_code_token_num":58},{"new_code_raw":"protected Account doMultiRealmAuthentication(Collection<? extends Realm> realms, AuthenticationToken token) { ModularAuthenticationStrategy strategy = getModularAuthenticationStrategy(); strategy.beforeAllAttempts(realms, token); Account aggregatedInfo = createAggregatedAccount(token); if (log.isDebugEnabled()) { log.debug(STR + realms.size() + STR); } for (Realm realm : realms) { strategy.beforeAttempt(realm, token); if (realm.supports(token.getClass())) { if (log.isDebugEnabled()) { log.debug(STR + token + STR + STR + realm.getClass() + STR); } Account realmInfo = null; Throwable t = null; try { realmInfo = realm.getAccount(token); } catch (Throwable throwable) { t = throwable; if (log.isTraceEnabled()) { String msg = STR + realm + STR; log.trace(msg, t); } } strategy.afterAttempt(realm, token, realmInfo, t); if (realmInfo != null) { if (log.isDebugEnabled()) { log.debug(STR + realm.getClass().getName() + STR); } merge(aggregatedInfo, realmInfo); } } else { if (log.isDebugEnabled()) { log.debug(STR + realm.getClass().getName() + STR + STR + token.getClass().getName() + STR); } } } strategy.afterAllAttempts(token, aggregatedInfo); return aggregatedInfo; }","old_code_raw":"protected AuthenticationInfo doMultiRealmAuthentication(Collection<? extends Realm> realms, AuthenticationToken token) {\n    ModularAuthenticationStrategy strategy = getModularAuthenticationStrategy();\n    strategy.beforeAllAttempts(realms, token);\n    AuthenticationInfo aggregatedInfo = createAggregatedAuthenticationInfo(token);\n    if (log.isDebugEnabled()) {\n        log.debug(STR + realms.size() + STR);\n    }\n    for (Realm realm : realms) {\n        strategy.beforeAttempt(realm, token);\n        if (realm.supports(token.getClass())) {\n            if (log.isDebugEnabled()) {\n                log.debug(STR + token + STR + STR + realm.getClass() + STR);\n            }\n            AuthenticationInfo realmInfo = null;\n            Throwable t = null;\n            try {\n                realmInfo = realm.getAuthenticationInfo(token);\n            } catch (Throwable throwable) {\n                t = throwable;\n                if (log.isTraceEnabled()) {\n                    String msg = STR + realm + STR;\n                    log.trace(msg, t);\n                }\n            }\n            strategy.afterAttempt(realm, token, realmInfo, t);\n            if (realmInfo != null) {\n                if (log.isDebugEnabled()) {\n                    log.debug(STR + realm.getClass().getName() + STR);\n                }\n                merge(aggregatedInfo, realmInfo);\n            }\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(STR + realm.getClass().getName() + STR + STR + token.getClass().getName() + STR);\n            }\n        }\n    }\n    strategy.afterAllAttempts(token, aggregatedInfo);\n    return aggregatedInfo;\n}","new_comment_raw":"@return an aggregated Account instance representing account data across all the successfully consulted realms.","old_comment_raw":"@return an aggregated AuthenticationInfo instance representing authentication info across all the successfully consulted realms.","label":1,"pre_label":0,"AST_level":17,"line_counts":40,"new_code_token_num":272},{"new_code_raw":"public AvroCollector getCollector(String namedOutput, Reporter reporter) throws IOException { return getCollector(namedOutput, null, reporter,namedOutput,null); }","old_code_raw":"  public AvroCollector getCollector(String namedOutput, Reporter reporter)\n    throws IOException {\n    return getCollector(namedOutput, null, reporter);\n  }\n","new_comment_raw":"@return the output collector for the given named output","old_comment_raw":"@return the output collector for the given named output","label":0,"pre_label":1,"AST_level":5,"line_counts":5,"new_code_token_num":28},{"new_code_raw":"protected Set<String> populateWhat(Set<String> what) throws Exception { checkOption(what); if (what.contains(WHAT_HELP)) throw new Exception(STR + whatHelp()); if (!what.contains(WHAT_CLIENT) && !what.contains(WHAT_SERVER) && !what.contains(WHAT_BOTH)) { what.add(WHAT_BOTH); what.add(WHAT_CLIENT); what.add(WHAT_SERVER); } else if (what.contains(WHAT_BOTH)) { what.add(WHAT_CLIENT); what.add(WHAT_SERVER); } else if (what.contains(WHAT_CLIENT) && what.contains(WHAT_SERVER)) { what.add(WHAT_BOTH); } Assertion.check((what.contains(WHAT_CLIENT) && !what.contains(WHAT_SERVER) && !what.contains(WHAT_BOTH)) || (!what.contains(WHAT_CLIENT) && what.contains(WHAT_SERVER) && !what.contains(WHAT_BOTH)) || (what.contains(WHAT_CLIENT) && what.contains(WHAT_SERVER) && what.contains(WHAT_BOTH)), STR); if (!what.contains(WHAT_ALL) && !what.contains(WHAT_NONE) && !what.contains(WHAT_INTF) && !what.contains(WHAT_MAIN) && !what.contains(WHAT_IMPL)) { what.add(WHAT_INTF); } if (what.contains(WHAT_ALL)) { what.add(WHAT_INTF); what.add(WHAT_MAIN); what.add(WHAT_IMPL); what.remove(WHAT_ALL); what.remove(WHAT_NONE); } if (what.contains(WHAT_NONE)) { what.remove(WHAT_INTF); what.remove(WHAT_MAIN); what.remove(WHAT_IMPL); what.remove(WHAT_NONE); } return what; }","old_code_raw":"protected Set<String> populateWhat(Set<String> what) {\n    if (!checkOption(what)) {\n        return null;\n    }\n    if (what.contains(WHAT_ALL)) {\n        what.add(WHAT_IMPL);\n        what.add(WHAT_MAIN);\n        what.add(WHAT_HELPER);\n    }\n    if (!what.contains(WHAT_CLIENT) && !what.contains(WHAT_SERVER) && !what.contains(WHAT_BOTH)) {\n        what.add(WHAT_BOTH);\n    }\n    if (what.contains(WHAT_BOTH)) {\n        what.add(WHAT_CLIENT);\n        what.add(WHAT_SERVER);\n    }\n    if (what.contains(WHAT_NONE)) {\n        what.clear();\n    }\n    return what;\n}","new_comment_raw":"@return what modified to account for interaction of options.","old_comment_raw":"@return what modified to account for all, both, and none options.","label":1,"pre_label":0,"AST_level":10,"line_counts":33,"new_code_token_num":333},{"new_code_raw":"protected Object convertBit(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return false; } if (data instanceof Boolean) return data; if (data instanceof Short) return ((Short) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE; if (data instanceof Integer) return ((Integer) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE; if (data instanceof Long) return ((Long) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE; return handleUnknownData(column, fieldDefn, data); }","old_code_raw":"    protected Object convertBit(Column column, Field fieldDefn, Object data) {\n        if (data == null) return null;\n        if (data instanceof Boolean) return data;\n        if (data instanceof Short) return ((Short) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;\n        if (data instanceof Integer) return ((Integer) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;\n        if (data instanceof Long) return ((Long) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;\n        return handleUnknownData(column, fieldDefn, data);\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made","label":1,"pre_label":0,"AST_level":8,"line_counts":15,"new_code_token_num":142},{"new_code_raw":"public DurationType getDurationType(Object object, boolean precise) { ReadableTimePeriod period = (ReadableTimePeriod) object; if (precise) { if (period.getDurationType().isPrecise()) { return period.getDurationType(); } else { return DurationType.getPreciseAllType(); } } return period.getDurationType(); }","old_code_raw":"    public DurationType getDurationType(Object object, boolean precise) {\n        return DurationType.getPreciseAllType();\n    }\n","new_comment_raw":"@return the duration type from the readable duration","old_comment_raw":"@return the duration type from the readable duration","label":0,"pre_label":1,"AST_level":8,"line_counts":12,"new_code_token_num":58},{"new_code_raw":"public AspectRatio inverse() { \/\/noinspection SuspiciousNameCombination return AspectRatio.of(mY, mX); }","old_code_raw":"    public AspectRatio inverse() {\n        \/\/noinspection SuspiciousNameCombination\n        return new AspectRatio(mY, mX);\n    }\n","new_comment_raw":"@return The inverse of this  AspectRatio.","old_comment_raw":"@return The inverse of this AspectRatio.","label":0,"pre_label":1,"AST_level":5,"line_counts":5,"new_code_token_num":20},{"new_code_raw":"public Object getResult() { return this.result; }","old_code_raw":"public Presentable getResult() {\n    return this.result;\n}","new_comment_raw":"@return An object.","old_comment_raw":"@return A {@link Presentable} object.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":11},{"new_code_raw":"private String getTargetEntity(List<? extends AnnotationMirror> annotations) { String fullyQualifiedTargetEntityName = null; for ( AnnotationMirror mirror : annotations ) { if ( TypeUtils.isAnnotationMirrorOfType( mirror, ElementCollection.class ) ) { fullyQualifiedTargetEntityName = getFullyQualifiedClassNameOfTargetEntity( mirror, \"targetClass\" ); } else if ( TypeUtils.isAnnotationMirrorOfType( mirror, OneToMany.class ) || TypeUtils.isAnnotationMirrorOfType( mirror, ManyToMany.class ) || TypeUtils.isAnnotationMirrorOfType( mirror, ManyToOne.class ) || TypeUtils.isAnnotationMirrorOfType( mirror, OneToOne.class ) ) { fullyQualifiedTargetEntityName = getFullyQualifiedClassNameOfTargetEntity( mirror, \"targetEntity\" ); } } return fullyQualifiedTargetEntityName; }","old_code_raw":"\tprivate String getTargetEntity(List<? extends AnnotationMirror> annotations) {\n\n\t\tfor ( AnnotationMirror mirror : annotations ) {\n\t\t\tif ( TypeUtils.isAnnotationMirrorOfType( mirror, ElementCollection.class )\n\t\t\t\t\t|| TypeUtils.isAnnotationMirrorOfType( mirror, OneToMany.class )\n\t\t\t\t\t|| TypeUtils.isAnnotationMirrorOfType( mirror, ManyToMany.class )\n\t\t\t\t\t|| TypeUtils.isAnnotationMirrorOfType( mirror, ManyToOne.class )\n\t\t\t\t\t|| TypeUtils.isAnnotationMirrorOfType( mirror, OneToOne.class ) ) {\n\t\t\t\tfinal String targetEntity = getTargetEntity( mirror );\n\t\t\t\tif ( targetEntity != null ) {\n\t\t\t\t\treturn targetEntity;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n","new_comment_raw":"@return target entity class name as string or  null if no targetEntity is here or if equals to void","old_comment_raw":"@return target entity class name as string or null if no targetEntity is here or if equals to void","label":0,"pre_label":1,"AST_level":12,"line_counts":17,"new_code_token_num":105},{"new_code_raw":"public static long toNanoOfDay(Object value, boolean acceptLargeValues) { if (value instanceof Duration) { Duration duration = (Duration) value; if (!acceptLargeValues && (duration.isNegative() || duration.compareTo(ONE_DAY) > 0)) { throw new IllegalArgumentException(\"Time values must be between 00:00:00 and 24:00:00 (inclusive): \" + duration); } return ((Duration) value).toNanos(); } \/\/ TODO only needed for SQL Server\/Oracle, where we don't produce Duration right away; \/\/ this should go eventually, as the conversion to LocalTime is superfluous LocalTime time = Conversions.toLocalTime(value); return time.toNanoOfDay(); }","old_code_raw":"    public static long toNanoOfDay(Object value, TemporalAdjuster adjuster) {\n        LocalTime time = Conversions.toLocalTime(value);\n        if (adjuster !=null) {\n            time = time.with(adjuster);\n        }\n        return time.toNanoOfDay();\n    }\n","new_comment_raw":"@return the milliseconds past midnight","old_comment_raw":"@return the nanoseconds past midnight","label":1,"pre_label":0,"AST_level":10,"line_counts":16,"new_code_token_num":141},{"new_code_raw":"Problem findProblem(int line) { int currentTab = getSketch().getCurrentCodeIndex(); return problems.stream() .filter(p -> p.getTabIndex() == currentTab) .filter(p -> { int pStartLine = p.getLineNumber(); int pEndOffset = p.getStopOffset(); int pEndLine = textarea.getLineOfOffset(pEndOffset); return line >= pStartLine && line <= pEndLine; }) .findFirst() .orElse(null); }","old_code_raw":"  protected Problem findProblem(int line) {\n    List<Problem> problems = findProblems(line);\n    for (Problem p : problems) {\n      if (p.isError()) return p;\n    }\n    return problems.isEmpty() ? null : problems.get(0);\n  }\n","new_comment_raw":"@return the Problem for the first error or warning on 'line'","old_comment_raw":"@return the Problem for the most relevant error or warning on 'line', defaults to the first error, if there are no errors first warning.","label":1,"pre_label":0,"AST_level":10,"line_counts":14,"new_code_token_num":77},{"new_code_raw":"public static String[] list() { if (NativeInterface.isSimulated()) { \/\/ as on the Raspberry Pi return new String[]{ \"spidev0.0\", \"spidev0.1\" }; } ArrayList<String> devs = new ArrayList<String>(); File dir = new File(\"\/dev\"); File[] files = dir.listFiles(); if (files != null) { for (File file : files) { if (file.getName().startsWith(\"spidev\")) { devs.add(file.getName()); } } } \/\/ listFiles() does not guarantee ordering String[] tmp = devs.toArray(new String[devs.size()]); Arrays.sort(tmp); return tmp; }","old_code_raw":"  public static String[] list() {\n    ArrayList<String> devs = new ArrayList<String>();\n    File dir = new File(\"\/dev\");\n    File[] files = dir.listFiles();\n    if (files != null) {\n      for (File file : files) {\n        if (file.getName().startsWith(\"spidev\")) {\n          devs.add(file.getName());\n        }\n      }\n    }\n    \/\/ listFiles() does not guarantee ordering\n    String[] tmp = devs.toArray(new String[devs.size()]);\n    Arrays.sort(tmp);\n    return tmp;\n  }\n","new_comment_raw":"@return String array","old_comment_raw":"@return String array","label":0,"pre_label":1,"AST_level":11,"line_counts":22,"new_code_token_num":148},{"new_code_raw":"private long insertData(ContentValues inputValues, boolean callerIsSyncAdapter) { final Long rawContactId = inputValues.getAsLong(Data.RAW_CONTACT_ID); if (rawContactId == null) { throw new IllegalArgumentException(Data.RAW_CONTACT_ID + STR); } final String mimeType = inputValues.getAsString(Data.MIMETYPE); if (TextUtils.isEmpty(mimeType)) { throw new IllegalArgumentException(Data.MIMETYPE + STR); } final ContentValues values = new ContentValues(inputValues); replacePackageNameByPackageId(values); values.put(DataColumns.MIMETYPE_ID, mDbHelper.get().getMimeTypeId(mimeType)); values.remove(Data.MIMETYPE); final SQLiteDatabase db = mDbHelper.get().getWritableDatabase(); final TransactionContext context = mTransactionContext.get(); final long dataId = getDataRowHandler(mimeType).insert(db, context, rawContactId, values); context.markRawContactDirtyAndChanged(rawContactId, callerIsSyncAdapter); context.rawContactUpdated(rawContactId); return dataId; }","old_code_raw":"private long insertData(ContentValues values, boolean callerIsSyncAdapter) {\n    long id = NUM;\n    mValues.clear();\n    mValues.putAll(values);\n    Long rawContactId = mValues.getAsLong(Data.RAW_CONTACT_ID);\n    if (rawContactId == null) {\n        throw new IllegalArgumentException(Data.RAW_CONTACT_ID + STR);\n    }\n    final String packageName = mValues.getAsString(Data.RES_PACKAGE);\n    if (packageName != null) {\n        mValues.put(DataColumns.PACKAGE_ID, mDbHelper.get().getPackageId(packageName));\n    }\n    mValues.remove(Data.RES_PACKAGE);\n    final String mimeType = mValues.getAsString(Data.MIMETYPE);\n    if (TextUtils.isEmpty(mimeType)) {\n        throw new IllegalArgumentException(Data.MIMETYPE + STR);\n    }\n    mValues.put(DataColumns.MIMETYPE_ID, mDbHelper.get().getMimeTypeId(mimeType));\n    mValues.remove(Data.MIMETYPE);\n    DataRowHandler rowHandler = getDataRowHandler(mimeType);\n    final SQLiteDatabase db = mDbHelper.get().getWritableDatabase();\n    id = rowHandler.insert(db, mTransactionContext.get(), rawContactId, mValues);\n    mTransactionContext.get().markRawContactDirtyAndChanged(rawContactId, callerIsSyncAdapter);\n    mTransactionContext.get().rawContactUpdated(rawContactId);\n    return id;\n}","new_comment_raw":"@return The ID of the newly-created row.","old_comment_raw":"@return the row ID of the newly created row","label":1,"pre_label":0,"AST_level":8,"line_counts":20,"new_code_token_num":160},{"new_code_raw":"public static boolean isTextBasedContentType(String contentType) { return contentType != null && (contentType.startsWith(STR) || contentType.startsWith(STR)); }","old_code_raw":"public static boolean isTextBasedContentType(String contentType) {\n    return contentType.startsWith(STR) || contentType.startsWith(STR);\n}","new_comment_raw":"@return whether it is not {@code null} and text-based","old_comment_raw":"@return whether it is text","label":1,"pre_label":0,"AST_level":7,"line_counts":3,"new_code_token_num":31},{"new_code_raw":"protected Object convertTimestampToEpochMicros(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0L; \/\/ return epoch } try { return MicroTimestamp.toEpochMicros(data); } catch (IllegalArgumentException e) { return handleUnknownData(column, fieldDefn, data); } }","old_code_raw":"    protected Object convertTimestampToEpochMicros(Column column, Field fieldDefn, Object data) {\n        if ( data == null ) return null;\n        try {\n            return MicroTimestamp.toEpochMicros(data);\n        } catch (IllegalArgumentException e) {\n            return handleUnknownData(column, fieldDefn, data);\n        }\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made","label":1,"pre_label":0,"AST_level":8,"line_counts":15,"new_code_token_num":82},{"new_code_raw":"public IBuildConfiguration[] getBuildConfigurations(IProject project, boolean makeCopy) { IBuildConfiguration[] configs = cachedBuildConfigs; if (configs != null && !project.equals(configs[NUM].getProject())) configs = null; if (configs == null) { if (configNames.length == NUM) configs = new IBuildConfiguration[] { new BuildConfiguration(project) }; else { configs = new IBuildConfiguration[configNames.length]; for (int i = NUM; i < configs.length; i++) configs[i] = new BuildConfiguration(project, configNames[i]); } cachedBuildConfigs = configs; } return makeCopy ? (IBuildConfiguration[]) configs.clone() : configs; }","old_code_raw":"public IBuildConfiguration[] getBuildConfigurations(boolean makeCopy) {\n    if (buildConfigs.length == NUM)\n        return EMPTY_BUILD_CONFIGS;\n    return makeCopy ? (IBuildConfiguration[]) buildConfigs.clone() : buildConfigs;\n}","new_comment_raw":"@return the project configurations","old_comment_raw":"@return the project configurations of an empty array if none exist.","label":1,"pre_label":0,"AST_level":13,"line_counts":15,"new_code_token_num":127},{"new_code_raw":"public DateTimeFormatterBuilder appendSecondOfDay(int minDigits) { return appendDecimal(DateTimeFieldType.secondOfDay(), minDigits, 5); }","old_code_raw":"    public DateTimeFormatterBuilder appendSecondOfDay(final int minDigits) {\n        return appendDecimal(iChronoUTC.secondOfDay(), minDigits, 5);\n    }\n","new_comment_raw":"@return this DateTimeFormatterBuilder","old_comment_raw":"@return this DateTimeFormatterBuilder","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":22},{"new_code_raw":"public synchronized static String hashPassword(long accountId, String password) { try { return sha1Hash(getBytes(STR + accountId + password)); } catch (NoSuchAlgorithmException e) { throw new FxCreateException(STR).asRuntimeException(); } }","old_code_raw":"public synchronized static final String hashPassword(String password) {\n    if (digest == null) {\n        try {\n            digest = MessageDigest.getInstance(STR);\n        } catch (NoSuchAlgorithmException nsae) {\n            System.err.println(STR + STR);\n            nsae.printStackTrace();\n        }\n    }\n    digest.update(getBytes(password));\n    String result = FxFormatUtils.encodeHex(digest.digest());\n    return result.replaceAll(STR, STR);\n}","new_comment_raw":"@return a hashed password","old_comment_raw":"@return a hashed version of the passed-in String","label":1,"pre_label":0,"AST_level":9,"line_counts":7,"new_code_token_num":47},{"new_code_raw":"public Object next() throws java.io.IOException { int zzInput; int zzAction; \/\/ cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; \/\/ set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { \/\/ store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); \/\/ get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } \/\/ store back cached position zzMarkedPos = zzMarkedPosL; if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { String str = yytext(); int first = str.codePointAt(0); String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } logger.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: logger.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 67: break; case 2: { return getNext(\"<\", yytext()); } case 68: break; case 3: { return getNext(); } case 69: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 70: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 71: break; case 6: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 72: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 73: break; case 8: { return handleQuotes(yytext(), false); } case 74: break; case 9: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 75: break; case 10: { return getNext(\">\", yytext()); } case 76: break; case 11: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 77: break; case 12: { handleHyphenatedNumber(yytext()); return getNext(removeFromNumber(yytext()), yytext()); } case 78: break; case 13: { return handleEllipsis(yytext()); } case 79: break; case 14: { return normalizeFractions(yytext()); } case 80: break; case 15: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(minimallyNormalizeCurrency(yytext()), yytext()); } } case 81: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 82: break; case 17: { if (normalizeOtherBrackets) { return getNext(\"-RSB-\", yytext()); } else { return getNext(); } } case 83: break; case 18: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 84: break; case 19: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 85: break; case 20: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 86: break; case 21: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 87: break; case 22: { if (normalizeOtherBrackets) { return getNext(\"-LSB-\", yytext()); } else { return getNext(); } } case 88: break; case 23: { if (invertible) { prevWordAfter.append(yytext()); } } case 89: break; case 24: { return getNext(\"\\u2022\", yytext()); } case 90: break; case 25: { return getNext(\"\\u2122\", yytext()); } case 91: break; case 26: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 92: break; case 27: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(); } case 93: break; case 28: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return handleQuotes(yytext(), true); } case 94: break; case 29: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 95: break; case 30: { breakByHyphens(yytext()); return getNext(removeSoftHyphens(yytext()), yytext()); } case 96: break; case 31: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 97: break; case 32: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 98: break; case 33: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 99: break; case 34: { \/\/ this one should only match if we're basically at the end of file \/\/ since the last one matches two things, even newlines (if not tokenize per line) String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 100: break; case 35: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 101: break; case 36: \/\/ lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 1); { \/* invert quote - often but not always right *\/ return handleQuotes(yytext(), true); } case 102: break; case 37: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return handleQuotes(yytext(), false); } case 103: break; case 38: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 104: break; case 39: { String txt = yytext(); \/\/ if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space... if (strictTreebank3) { int spaceIndex = indexOfSpace(txt); if (spaceIndex >= 0) { yypushback(txt.length() - spaceIndex); String newText = yytext(); return getNext(newText, newText); } } if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, txt); } case 105: break; case 40: { return getNormalizedAmpNext(); } case 106: break; case 41: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, origTxt); } case 107: break; case 42: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space } return getNext(txt, origTxt); } case 108: break; case 43: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 109: break; case 44: { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 110: break; case 45: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 17; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 111: break; case 46: \/\/ lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 112: break; case 47: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 113: break; case 48: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 22; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 114: break; case 49: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 18; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 19; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 115: break; case 50: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 116: break; case 51: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 21; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 117: break; case 52: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 118: break; case 53: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { breakByHyphens(yytext()); return getNext(removeSoftHyphens(yytext()), yytext()); } case 119: break; case 54: { if (splitAssimilations) { yypushback(3) ; return getNext(); } else { return getNext(); } } case 120: break; case 55: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNormalizedAmpNext(); } case 121: break; case 56: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 9; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 122: break; case 57: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { return getNext(); } case 123: break; case 58: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 124: break; case 59: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 125: break; case 60: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 13; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 126: break; case 61: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } return getNext(txt, yytext()); } case 127: break; case 62: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4); { return getNext(); } case 128: break; case 63: \/\/ lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { return getNext(); } case 129: break; case 64: { String txt = yytext(); if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 130: break; case 65: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 25; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 131: break; case 66: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 24; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 132: break; default: zzScanError(ZZ_NO_MATCH); } } } }","old_code_raw":"  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    \/\/ cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      \/\/ set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            \/\/ store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            \/\/ get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      \/\/ store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { String str = yytext();\n          int first = str.charAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n          }\n        case 67: break;\n        case 2: \n          { return getNext(\"<\", yytext());\n          }\n        case 68: break;\n        case 3: \n          { return getNext();\n          }\n        case 69: break;\n        case 4: \n          { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n          }\n        case 70: break;\n        case 5: \n          { if (tokenizeNLs) {\n                      return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns\n                  } else if (invertible) {\n                      prevWordAfter.append(yytext());\n                  }\n          }\n        case 71: break;\n        case 6: \n          { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n          }\n        case 72: break;\n        case 7: \n          { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n          }\n        case 73: break;\n        case 8: \n          { return handleQuotes(yytext(), false);\n          }\n        case 74: break;\n        case 9: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '\/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 75: break;\n        case 10: \n          { return getNext(\">\", yytext());\n          }\n        case 76: break;\n        case 11: \n          { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 77: break;\n        case 12: \n          { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n          }\n        case 78: break;\n        case 13: \n          { return handleEllipsis(yytext());\n          }\n        case 79: break;\n        case 14: \n          { return normalizeFractions(yytext());\n          }\n        case 80: break;\n        case 15: \n          { if (normalizeCurrency) {\n                            return getNext(normalizeCurrency(yytext()), yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 81: break;\n        case 16: \n          { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 82: break;\n        case 17: \n          { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 83: break;\n        case 18: \n          { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 84: break;\n        case 19: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 85: break;\n        case 20: \n          { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 86: break;\n        case 21: \n          { if (normalizeOtherBrackets) {\n                    return getNext(\"-RSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 87: break;\n        case 22: \n          { if (normalizeOtherBrackets) {\n                    return getNext(\"-LSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 88: break;\n        case 23: \n          { if (invertible) {\n                            prevWordAfter.append(yytext());\n                        }\n          }\n        case 89: break;\n        case 24: \n          { return getNext(\"\\u2022\", yytext());\n          }\n        case 90: break;\n        case 25: \n          { return getNext(\"\\u2122\", yytext());\n          }\n        case 91: break;\n        case 26: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 15;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 16;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 92: break;\n        case 27: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext();\n          }\n        case 93: break;\n        case 28: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return handleQuotes(yytext(), true);\n          }\n        case 94: break;\n        case 29: \n          { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n          }\n        case 95: break;\n        case 30: \n          { breakByHyphens(yytext());\n                    return getNext(removeSoftHyphens(yytext()), yytext());\n          }\n        case 96: break;\n        case 31: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 3;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 4;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n          }\n        case 97: break;\n        case 32: \n          { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '\/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 98: break;\n        case 33: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext(removeSoftHyphens(yytext()), yytext());\n          }\n        case 99: break;\n        case 34: \n          { \/\/ this one should only match if we're basically at the end of file\n                          \/\/ since the last one matches two things, even newlines (if not tokenize per line)\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 100: break;\n        case 35: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n          }\n        case 101: break;\n        case 36: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 1;\n          { \/* invert quote - often but not always right *\/\n                  return handleQuotes(yytext(), true);\n          }\n        case 102: break;\n        case 37: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return handleQuotes(yytext(), false);\n          }\n        case 103: break;\n        case 38: \n          { return getNext(removeSoftHyphens(yytext()), yytext());\n          }\n        case 104: break;\n        case 39: \n          { String txt = yytext();\n                  \/\/ if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space...\n                  if (strictTreebank3) {\n                    int spaceIndex = indexOfSpace(txt);\n                    if (spaceIndex >= 0) {\n                      yypushback(txt.length() - spaceIndex);\n                      String newText = yytext();\n                      return getNext(newText, newText);\n                    }\n                  }\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '\/');\n                  }\n                  if (normalizeSpace) {\n                    txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                  }\n                  return getNext(txt, txt);\n          }\n        case 105: break;\n        case 40: \n          { return getNormalizedAmpNext();\n          }\n        case 106: break;\n        case 41: \n          { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n          }\n        case 107: break;\n        case 42: \n          { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n          }\n        case 108: break;\n        case 43: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 5;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 6;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String txt = yytext();\n                          return getNext(removeSoftHyphens(txt),\n                                         txt);\n          }\n        case 109: break;\n        case 44: \n          { if (splitAssimilations) {\n                            yypushback(2) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 110: break;\n        case 45: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 17;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 16;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 111: break;\n        case 46: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 3;\n          { if (splitAssimilations) {\n                            yypushback(2) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 112: break;\n        case 47: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 10;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 11;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return processAbbrev3();\n          }\n        case 113: break;\n        case 48: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 20;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 22;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n          }\n        case 114: break;\n        case 49: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 18;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 19;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 115: break;\n        case 50: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 10;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 11;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return processAbbrev3();\n          }\n        case 116: break;\n        case 51: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 20;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 21;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n          }\n        case 117: break;\n        case 52: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 118: break;\n        case 53: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { breakByHyphens(yytext());\n                    return getNext(removeSoftHyphens(yytext()), yytext());\n          }\n        case 119: break;\n        case 54: \n          { if (splitAssimilations) {\n                            yypushback(3) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 120: break;\n        case 55: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNormalizedAmpNext();\n          }\n        case 121: break;\n        case 56: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 7;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 9;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return processAcronym();\n          }\n        case 122: break;\n        case 57: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(2);\n          { return getNext();\n          }\n        case 123: break;\n        case 58: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 12;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 14;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return processAbbrev1();\n          }\n        case 124: break;\n        case 59: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 7;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 8;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return processAcronym();\n          }\n        case 125: break;\n        case 60: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 12;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 13;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return processAbbrev1();\n          }\n        case 126: break;\n        case 61: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 127: break;\n        case 62: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(4);\n          { return getNext();\n          }\n        case 128: break;\n        case 63: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 3;\n          { return getNext();\n          }\n        case 129: break;\n        case 64: \n          { String txt = yytext();\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 130: break;\n        case 65: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 23;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 25;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n          }\n        case 131: break;\n        case 66: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 23;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 24;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n          }\n        case 132: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                if (invertible) {\n            prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            prevWordAfter.setLength(0);\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n          }\n          return null;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n","new_comment_raw":"@return the next token","old_comment_raw":"@return the next token","label":0,"pre_label":1,"AST_level":19,"line_counts":966,"new_code_token_num":6274},{"new_code_raw":"public boolean matches(Method method, Class targetClass) { return ((method.getAnnotation(PermissionRequired.class) != null) || (method.getAnnotation(RolesRequired.class) != null)); }","old_code_raw":"public boolean matches(Method method, Class targetClass) {\n    return ((method.getAnnotation(Implies.class) != null) || (method.getAnnotation(HasRole.class) != null));\n}","new_comment_raw":"@return <tt>true<\/tt> if the method has a JSecurity <tt>RolesRequired<\/tt> or <tt>PermissionRequired<\/tt> annotation, false otherwise.","old_comment_raw":"@return <tt>true<\/tt> if the method has a JSecurity <tt>HasRole<\/tt> or <tt>Implies<\/tt> annotation, false otherwise.","label":1,"pre_label":0,"AST_level":8,"line_counts":3,"new_code_token_num":38},{"new_code_raw":"protected Project getRightChild(RelOptRuleCall call) { return call.rel(NUM); }","old_code_raw":"protected ProjectRelBase getRightChild(RelOptRuleCall call) {\n    return call.rel(NUM);\n}","new_comment_raw":"@return LogicalProject corresponding to the right child","old_comment_raw":"@return ProjectRel corresponding to the right child","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":16},{"new_code_raw":"public boolean onKeyDown(int keyCode, KeyEvent event) { if (LOG_KEY_EVENTS) { Log.w(TAG, \"onKeyDown \" + keyCode); } if (handleControlKey(keyCode, true)) { return true; } else if (handleFnKey(keyCode, true)) { return true; } else if (isSystemKey(keyCode, event)) { if (! isInterceptedSystemKey(keyCode) ) { \/\/ Don't intercept the system keys return super.onKeyDown(keyCode, event); } } \/\/ Translate the keyCode into an ASCII character. try { mKeyListener.keyDown(keyCode, event, getKeypadApplicationMode()); } catch (IOException e) { \/\/ Ignore I\/O exceptions } return true; }","old_code_raw":"    public boolean onKeyDown(int keyCode, KeyEvent event) {\n        if (LOG_KEY_EVENTS) {\n            Log.w(TAG, \"onKeyDown \" + keyCode);\n        }\n        if (keyCode == KeyEvent.KEYCODE_MENU) {\n            return super.onKeyDown(keyCode,  event);\n        }\n        if (mTermKeyListener == null) {\n            mTermKeyListener = new TermKeyListener(mControlKeyCode, mFnKeyCode, mBackKeyCharacter, mAltSendsEsc, getKeypadApplicationMode());\n        }\n        boolean isHandled = mTermKeyListener.keyDown(event);\n        if (isHandled) {\n            byte[] seq = mTermKeyListener.extractCharSequence();\n            if (seq != null) {\n                mTermSession.write(seq, 0, seq.length);\n            }\n        } else if (isSystemKey(keyCode, event)) {\n            if (! isInterceptedSystemKey(keyCode) ) {\n                \/\/ Don't intercept the system keys\n                isHandled = super.onKeyDown(keyCode, event);\n            }\n        }\n        return isHandled;\n    }\n","new_comment_raw":"@return Whether the event was handled.","old_comment_raw":"@return Whether the event was handled.","label":0,"pre_label":1,"AST_level":11,"line_counts":25,"new_code_token_num":140},{"new_code_raw":"public static IPath getNpmWorkingDir(IProject project, final String... ignores) throws CoreException { IPath workingDir = null; final List<IFile> foundFiles = new ArrayList<>(); if (project != null && project.exists()) { project.accept(new IResourceVisitor() { @Override public boolean visit(IResource resource) throws CoreException { if (!foundFiles.isEmpty()) { return false; } else if (resource.getType() == IResource.FOLDER && ignores != null) { for (String ignore : ignores) { if (resource.getName().equals(ignore)) { return false; } } } else if (resource.getType() == IResource.FILE && NpmConstants.PACKAGE_JSON.equals(resource.getName())) { foundFiles.add((IFile) resource); } return true; } }); } if (!foundFiles.isEmpty()) { workingDir = foundFiles.get(NUM).getParent().getLocation(); } return workingDir; }","old_code_raw":"public static String getNpmWorkingDir(IProject project, final String... ignores) throws CoreException {\n    String workingDir = null;\n    final List<IFile> foundFiles = new ArrayList<>();\n    if (project != null && project.exists()) {\n        project.accept(new IResourceVisitor() {\n\n            @Override\n            public boolean visit(IResource resource) throws CoreException {\n                if (!foundFiles.isEmpty()) {\n                    return false;\n                } else if (resource.getType() == IResource.FOLDER && ignores != null) {\n                    for (String ignore : ignores) {\n                        if (resource.getName().equals(ignore)) {\n                            return false;\n                        }\n                    }\n                } else if (resource.getType() == IResource.FILE && NpmConstants.PACKAGE_JSON.equals(resource.getName())) {\n                    foundFiles.add((IFile) resource);\n                }\n                return true;\n            }\n        });\n    }\n    if (!foundFiles.isEmpty()) {\n        workingDir = foundFiles.get(NUM).getParent().getFullPath().toOSString();\n    }\n    return workingDir;\n}","new_comment_raw":"@return path to directory in which native npm call must be performed. Basically, the method scans project for package.json file and returns it's parent, ignoring \"node_modules\"","old_comment_raw":"@return absolute path to directory in which native npm call must be performed. Basically, the method scans project for package.json file and returns it's parent, ignoring \"node_modules\"","label":1,"pre_label":0,"AST_level":17,"line_counts":28,"new_code_token_num":183},{"new_code_raw":"@Processor @OAuthProtected @OAuthInvalidateAccessTokenOn(exception = OAuthTokenExpiredException.class) @Paged public PagingDelegate<TaskList> getTaskLists(final PagingConfiguration pagingConfiguration) throws IOException { return new TokenBasedPagingDelegate<TaskList>() { @Override protected List<TaskList> doGetPage() throws IOException { TaskLists list = client.tasklists().list().setMaxResults(new Long(pagingConfiguration.getFetchSize())).setPageToken(this.getPageToken()).execute(); this.setPageToken(list.getNextPageToken()); return TaskList.valueOf(list.getItems(), TaskList.class); } }; }","old_code_raw":"@Processor\n@OAuthProtected\n@OAuthInvalidateAccessTokenOn(exception = OAuthTokenExpiredException.class)\n@Inject\npublic List<TaskList> getTaskLists(MuleMessage message, @Optional @Default(STR) long maxResults, @Optional String pageToken) throws IOException {\n    TaskLists list = this.client.tasklists().list().setMaxResults(maxResults).setPageToken(pageToken).execute();\n    PaginationUtils.savePageToken(NEXT_PAGE_TOKEN, list.getNextPageToken(), message);\n    return TaskList.valueOf(list.getItems(), TaskList.class);\n}","new_comment_raw":"@return an auto paginated iterator with instances of {@link org.mule.module.google.task.model.TaskList}","old_comment_raw":"@return a list with instances of {@link org.mule.module.google.task.model.TaskList}","label":1,"pre_label":0,"AST_level":11,"line_counts":15,"new_code_token_num":100},{"new_code_raw":"public List<LogRecord> getLogRecords(SessionId sessionId) throws IOException { LogFile logFile = sessionToLogFileMap.get(sessionId); if (logFile == null) { return new ArrayList<>(); } List<LogRecord> logRecords = new ArrayList<>(); try { logFile.openLogReader(); ObjectInputStream logObjInStream = logFile.getLogReader(); LogRecord tmpLogRecord; while (null != (tmpLogRecord = (LogRecord) logObjInStream .readObject())) { logRecords.add(tmpLogRecord); } } catch (IOException ex) { logFile.closeLogReader(); return logRecords; } catch (ClassNotFoundException e) { logFile.closeLogReader(); return logRecords; } logFile.closeLogReader(); return logRecords; }","old_code_raw":"  public List<LogRecord> getLogRecords(SessionId sessionId) throws IOException {\n    LogFile logFile = sessionToLogFileMap.get(sessionId);\n    if (logFile == null) {\n      return new ArrayList<LogRecord>();\n    }\n\n    List<LogRecord> logRecords = new ArrayList<LogRecord>();\n    try {\n      logFile.openLogReader();\n      ObjectInputStream logObjInStream = logFile.getLogReader();\n      LogRecord tmpLogRecord;\n      while (null != (tmpLogRecord = (LogRecord) logObjInStream\n          .readObject())) {\n        logRecords.add(tmpLogRecord);\n      }\n    } catch (IOException ex) {\n      logFile.closeLogReader();\n      return logRecords;\n    } catch (ClassNotFoundException e) {\n      logFile.closeLogReader();\n      return logRecords;\n    }\n    logFile.closeLogReader();\n    return logRecords;\n  }\n","new_comment_raw":"@return A List of LogRecord objects, which can be null.","old_comment_raw":"@return A List of LogRecord objects, which can be null.","label":0,"pre_label":1,"AST_level":8,"line_counts":26,"new_code_token_num":120},{"new_code_raw":"protected Object convertTimestampToEpochMillisAsDate(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return new java.util.Date(0L); \/\/ return epoch } try { return new java.util.Date(Timestamp.toEpochMillis(data)); } catch (IllegalArgumentException e) { return handleUnknownData(column, fieldDefn, data); } }","old_code_raw":"    protected Object convertTimestampToEpochMillisAsDate(Column column, Field fieldDefn, Object data) {\n        if ( data == null ) return null;\n        try {\n            return new java.util.Date(Timestamp.toEpochMillis(data));\n        } catch (IllegalArgumentException e) {\n            return handleUnknownData(column, fieldDefn, data);\n        }\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made","label":1,"pre_label":0,"AST_level":9,"line_counts":15,"new_code_token_num":94},{"new_code_raw":"private Set<Alert> getAlertNodes() { if (!isMultiSelect()) { return extAlert.getAlertPanel().getSelectedAlert(); } return extAlert.getAlertPanel().getSelectedAlerts(); }","old_code_raw":"    private Set<Alert> getAlertNodes() {\n        TreePath[] paths = this.extAlert.getAlertPanel().getTreeAlert().getSelectionPaths();\n        if (paths == null || paths.length == 0) {\n            return Collections.emptySet();\n        }\n\n        HashSet<Alert> alertNodes = new HashSet<Alert>();\n        if (!isMultiSelect()) {\n            DefaultMutableTreeNode alertNode = (DefaultMutableTreeNode) paths[0].getLastPathComponent();\n            alertNodes.add((Alert) alertNode.getUserObject());\n            return alertNodes;\n        }\n\n        for(int i = 0; i < paths.length; i++ ) {\n            DefaultMutableTreeNode alertNode = (DefaultMutableTreeNode)paths[i].getLastPathComponent();\n            if(alertNode.getChildCount() == 0) {\n                alertNodes.add((Alert)alertNode.getUserObject());\n                continue;\n            }\n            for(int j = 0; j < alertNode.getChildCount(); j++ ) {\n                DefaultMutableTreeNode node = (DefaultMutableTreeNode)alertNode.getChildAt(j);\n                alertNodes.add((Alert)node.getUserObject());\n            }\n        }\n        return alertNodes;\n    }\n","new_comment_raw":"@return  true if the menu item supports multiple selected alerts,  false otherwise.","old_comment_raw":"@return true if the menu item supports multiple selected alerts, false otherwise.","label":0,"pre_label":1,"AST_level":7,"line_counts":7,"new_code_token_num":35},{"new_code_raw":"protected Object convertReal(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0.0f; } if (data instanceof Float) return data; if (data instanceof Number) { Number value = (Number) data; return new Float(value.floatValue()); } if (data instanceof Boolean) { return ((Boolean) data).booleanValue() ? FLOAT_TRUE : FLOAT_FALSE; } return handleUnknownData(column, fieldDefn, data); }","old_code_raw":"    protected Object convertReal(Column column, Field fieldDefn, Object data) {\n        if (data == null) return null;\n        if (data instanceof Float) return data;\n        if (data instanceof Number) {\n            Number value = (Number) data;\n            return new Float(value.floatValue());\n        }\n        if (data instanceof Boolean) {\n            return ((Boolean) data).booleanValue() ? FLOAT_TRUE : FLOAT_FALSE;\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made","label":1,"pre_label":0,"AST_level":8,"line_counts":19,"new_code_token_num":119},{"new_code_raw":"public static DocumentFactory createDocumentFactory(ServiceManager manager, Session session) { DocumentFactory factory; DocumentManager docManager = null; try { docManager = (DocumentManager) manager.lookup(DocumentManager.ROLE); factory = docManager.createDocumentIdentityMap(session); } catch (ServiceException e) { throw new RuntimeException(e); } finally { if (docManager != null) { manager.release(docManager); } } return factory; }","old_code_raw":"public static DocumentFactory createDocumentFactory(ServiceManager manager, Session session) {\n    DocumentFactory map;\n    DocumentManager docManager = null;\n    try {\n        docManager = (DocumentManager) manager.lookup(DocumentManager.ROLE);\n        map = docManager.createDocumentIdentityMap(session);\n    } catch (ServiceException e) {\n        throw new RuntimeException(e);\n    } finally {\n        if (docManager != null) {\n            manager.release(docManager);\n        }\n    }\n    return map;\n}","new_comment_raw":"@return a document factory.","old_comment_raw":"@return if an error occurs.","label":1,"pre_label":0,"AST_level":8,"line_counts":15,"new_code_token_num":75},{"new_code_raw":"@Override public Object getItem(int position) { return ((DeviceAdminListItem) (mAdmins.get(position))).info; }","old_code_raw":"@Override\npublic Object getItem(int position) {\n    if (position < NUM) {\n        throw new ArrayIndexOutOfBoundsException();\n    }\n    int adminPosition = position;\n    final int n = mAdminsByProfile.size();\n    int i = NUM;\n    for (; i < n; ++i) {\n        final int listSize = mAdminsByProfile.valueAt(i).size() + NUM;\n        if (adminPosition < listSize) {\n            break;\n        }\n        adminPosition -= listSize;\n    }\n    if (i == n) {\n        throw new ArrayIndexOutOfBoundsException();\n    }\n    if (adminPosition == NUM) {\n        Resources res = getActivity().getResources();\n        if (mAdminsByProfile.keyAt(i) == UserHandle.myUserId()) {\n            return res.getString(R.string.personal_device_admin_title);\n        } else {\n            return res.getString(R.string.managed_device_admin_title);\n        }\n    } else {\n        return mAdminsByProfile.valueAt(i).get(adminPosition - NUM);\n    }\n}","new_comment_raw":"@return DeviceAdminInfo object for actual device admins.","old_comment_raw":"@return a String object for title items and a DeviceAdminInfo object for actual device admins.","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":26},{"new_code_raw":"public static Method findSetMethod(Field field, boolean throwExceptions) throws IllegalArgumentException { Method fieldSetMethod; if (Locale.ENGLISH.equals(Locale.getDefault())) { fieldSetMethod = findMethodFromNames(field, false, throwExceptions, methodFromField(field, STR, null)); } else { fieldSetMethod = findMethodFromNames(field, false, throwExceptions, methodFromField(field, STR, null), methodFromField(field, STR, Locale.ENGLISH)); } if (fieldSetMethod == null) { return null; } if (fieldSetMethod.getReturnType() != void.class) { if (throwExceptions) { throw new IllegalArgumentException(STR + fieldSetMethod.getName() + STR + fieldSetMethod.getReturnType() + STR); } else { return null; } } return fieldSetMethod; }","old_code_raw":"public static Method findSetMethod(Field field, boolean throwExceptions) {\n    String methodName = methodFromField(field, STR);\n    Method fieldSetMethod;\n    try {\n        fieldSetMethod = field.getDeclaringClass().getMethod(methodName, field.getType());\n    } catch (Exception e) {\n        if (throwExceptions) {\n            throw new IllegalArgumentException(STR + field);\n        } else {\n            return null;\n        }\n    }\n    if (fieldSetMethod.getReturnType() != void.class) {\n        if (throwExceptions) {\n            throw new IllegalArgumentException(STR + methodName + STR + fieldSetMethod.getReturnType() + STR);\n        } else {\n            return null;\n        }\n    }\n    return fieldSetMethod;\n}","new_comment_raw":"@return Set method or null (or throws IllegalArgumentException) if none found.","old_comment_raw":"@return Set method or null if none found.","label":1,"pre_label":0,"AST_level":13,"line_counts":19,"new_code_token_num":141},{"new_code_raw":"public int getExtraInt(String key) throws JSONException { return mExtraData.getInt(key); }","old_code_raw":"public double getExtraInt(String key) {\n    return mExtraData.optInt(key);\n}","new_comment_raw":"@return The stored value.","old_comment_raw":"@return The stored value or null if it doesn't exist in specified form.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":18},{"new_code_raw":"public static String getId(final Widget widget) { String result = (String) widget.getData(CUSTOM_WIDGET_ID); if (result == null) { result = getAdapter(widget).getId(); } return result; }","old_code_raw":"public static String getId(final Widget widget) {\n    return getAdapter(widget).getId();\n}","new_comment_raw":"@return the id for the given <code>widget<\/code>","old_comment_raw":"@return the id","label":1,"pre_label":0,"AST_level":8,"line_counts":7,"new_code_token_num":41},{"new_code_raw":"private Notification makeNotification() { JSONObject settings = BackgroundMode.getSettings(); Context context = getApplicationContext(); String pkgName = context.getPackageName(); Intent intent = context.getPackageManager() .getLaunchIntentForPackage(pkgName); Notification.Builder notification = new Notification.Builder(context) .setContentTitle(settings.optString(\"title\", \"\")) .setContentText(settings.optString(\"text\", \"\")) .setOngoing(true) .setSmallIcon(getIconResId()); if (intent != null && settings.optBoolean(\"resume\")) { PendingIntent contentIntent = PendingIntent.getActivity( context, NOTIFICATION_ID, intent, PendingIntent.FLAG_UPDATE_CURRENT); notification.setContentIntent(contentIntent); } return notification.build(); }","old_code_raw":"    private Notification makeNotification() {\n        JSONObject settings = BackgroundMode.getSettings();\n        Context context     = getApplicationContext();\n        String pkgName      = context.getPackageName();\n        Intent intent       = context.getPackageManager()\n                .getLaunchIntentForPackage(pkgName);\n\n        notification = new Notification.Builder(context)\n            .setContentTitle(settings.optString(\"title\", \"\"))\n            .setContentText(settings.optString(\"text\", \"\"))\n            .setTicker(settings.optString(\"ticker\", \"\"))\n            .setOngoing(true)\n            .setSmallIcon(getIconResId());\n\n        if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n            if(settings.optBoolean(\"isPublic\") == true) {\n                notification.setVisibility(Notification.VISIBILITY_PUBLIC);\n            }\n\n            if(!settings.optString(\"color\").equals(\"\")) {\n                try {\n                    notification.setColor(Color.parseColor(settings.optString(\"color\")));\n                } catch (Exception e) {\n                    Log.e(\"BackgroundMode\", settings.optString(\"color\") + \" is not a valid color\");\n                }\n            }\n        }\n\n        if (intent != null && settings.optBoolean(\"resume\")) {\n\n            PendingIntent contentIntent = PendingIntent.getActivity(\n                    context, NOTIFICATION_ID, intent, PendingIntent.FLAG_UPDATE_CURRENT);\n\n            notification.setContentIntent(contentIntent);\n        }\n\n\n        if (Build.VERSION.SDK_INT < 16) {\n            \/\/ Build notification for HoneyComb to ICS\n            return notification.getNotification();\n        } else {\n            \/\/ Notification for Jellybean and above\n            return notification.build();\n        }\n    }\n","new_comment_raw":"@return A local ongoing notification which pending intent is bound to the main activity.","old_comment_raw":"@return A local ongoing notification which pending intent is bound to the main activity.","label":0,"pre_label":1,"AST_level":8,"line_counts":24,"new_code_token_num":128},{"new_code_raw":"@Processor @OAuthProtected @OAuthInvalidateAccessTokenOn(exception = OAuthTokenExpiredException.class) @Paged public PagingDelegate<Comment> listComments(final String fileId, @Optional @Default(STR) final boolean includeDeleted, @Optional @Default(STR) final int maxResults, @Optional final String updatedMin, final PagingConfiguration pagingConfiguration) throws IOException { return new TokenBasedPagingDelegate<Comment>() { @Override protected List<Comment> doGetPage() throws IOException { CommentList response = client.comments().list(fileId).setIncludeDeleted(includeDeleted).setMaxResults(maxResults).setPageToken(this.getPageToken()).setUpdatedMin(updatedMin).execute(); this.setPageToken(response.getNextPageToken()); return Comment.valueOf(response.getItems(), Comment.class); } }; }","old_code_raw":"@Processor\n@OAuthProtected\n@OAuthInvalidateAccessTokenOn(exception = OAuthTokenExpiredException.class)\n@Inject\npublic List<Comment> listComments(MuleMessage message, String fileId, @Optional @Default(STR) boolean includeDeleted, @Optional @Default(STR) int maxResults, @Optional @Default(STR) String pageToken, @Optional String updatedMin) throws IOException {\n    CommentList response = this.client.comments().list(fileId).setIncludeDeleted(includeDeleted).setMaxResults(maxResults).setPageToken(pageToken).setUpdatedMin(updatedMin).execute();\n    PaginationUtils.savePageToken(NEXT_PAGE_TOKEN, response.getNextPageToken(), message);\n    return Comment.valueOf(response.getItems(), Comment.class);\n}","new_comment_raw":"@return a paginated iterator with instances of {@link org.mule.module.google.drive.model.Comment}","old_comment_raw":"@return a list with instances of {@link org.mule.module.google.drive.model.Comment}","label":1,"pre_label":0,"AST_level":11,"line_counts":15,"new_code_token_num":134},{"new_code_raw":"public static String readFully(InputStream inputStream) throws IOException { return readFully(inputStream, new UnsynchronizedBuffer(1024)); }","old_code_raw":"  public static String readFully(InputStream inputStream) throws IOException {\n    return _readFully(inputStream).toString();\n  }\n","new_comment_raw":"@return Plugin instance","old_comment_raw":"@return Plugin instance","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":24},{"new_code_raw":"protected MedicationMedicalRecordBodyType mapBody(final EHREXTRACT ehrExtract, final int compositionIndex) { final COMPOSITION composition = ehrExtract.getAllCompositions().get(compositionIndex); Map<String, String> ehr13606values = retrieveValues(composition, compositionIndex); return buildBody(ehr13606values); }","old_code_raw":"protected MedicationMedicalRecordBodyType mapBody(final EHREXTRACT ehrExtract, final int compositionIndex) {\n    final COMPOSITION composition = ehrExtract.getAllCompositions().get(compositionIndex);\n    final MedicationMedicalRecordBodyType bodyType = new MedicationMedicalRecordBodyType();\n    AdditionalPatientInformationType apit = new AdditionalPatientInformationType();\n    apit.setDateOfBirth(STR);\n    CVType gender = new CVType();\n    gender.setCode(STR);\n    gender.setCodeSystem(STR);\n    gender.setDisplayName(STR);\n    gender.setOriginalText(STR);\n    apit.setGender(gender);\n    bodyType.setAdditionalPatientInformation(apit);\n    MedicationPrescriptionType mpt = new MedicationPrescriptionType();\n    mpt.setDispensationAuthorization(new DispensationAuthorizationType());\n    mpt.setEndOfTreatment(STR);\n    mpt.setEndOfTreatmentReason(new CVType());\n    mpt.setEvaluator(new HealthcareProfessionalType());\n    mpt.setPrecedingPrescriptionId(new IIType());\n    mpt.setPrescriber(new HealthcareProfessionalType());\n    mpt.setPrescriptionChainId(new IIType());\n    mpt.setPrescriptionId(new IIType());\n    mpt.setPrescriptionStatus(new CVType());\n    mpt.setSelfMedication(false);\n    mpt.setStartOfFirstTreatment(STR);\n    mpt.setSucceedingPrescriptionId(new IIType());\n    mpt.setTypeOfPrescription(TypeOfPrescriptionEnum.INS\u00c4TTNING);\n    bodyType.setMedicationPrescription(mpt);\n    for (final CONTENT content : composition.getContent()) {\n        for (final ITEM item : ((ENTRY) content).getItems()) {\n            log.debug(item.getMeaning().getCode() + STR + item.getMeaning().getDisplayName().getValue() + STR + (item instanceof ELEMENT ? STR : STR));\n            switch(item.getMeaning().getCode()) {\n                case STR:\n                    mpt.setStartOfTreatment(STR);\n                    log.debug(item.getMeaning().getCode() + STR + item.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) item));\n                    break;\n                case STR:\n                    mpt.setPrescriptionNote(STR);\n                    log.debug(item.getMeaning().getCode() + STR + item.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) item));\n                    break;\n                case STR:\n                    mpt.setEvaluationTime(STR);\n                    log.debug(item.getMeaning().getCode() + STR + item.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) item));\n                    break;\n                case STR:\n                    mpt.setTreatmentPurpose(STR);\n                    log.debug(item.getMeaning().getCode() + STR + item.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) item));\n                    break;\n                case STR:\n                    log.debug(item.getMeaning().getCode() + STR + item.getMeaning().getDisplayName().getValue());\n                    CLUSTER c = (CLUSTER) item;\n                    List<ITEM> parts = c.getParts();\n                    for (ITEM part : parts) {\n                        log.debug(part.getMeaning().getCode());\n                        if (STR.equals(part.getMeaning().getCode())) {\n                            c = (CLUSTER) part;\n                            List<ITEM> dosparts = c.getParts();\n                            for (ITEM dospart : dosparts) {\n                                log.debug(dospart.getMeaning().getCode() + STR + dospart.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) dospart));\n                            }\n                        }\n                    }\n                    break;\n                case STR:\n                    log.debug(item.getMeaning().getCode() + STR + item.getMeaning().getDisplayName().getValue());\n                    c = (CLUSTER) item;\n                    parts = c.getParts();\n                    for (ITEM part : parts) {\n                        log.debug(part.getMeaning().getCode());\n                        switch(item.getMeaning().getCode()) {\n                            case STR:\n                                log.debug(part.getMeaning().getCode() + STR + part.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) part));\n                                break;\n                            case STR:\n                                log.debug(part.getMeaning().getCode() + STR + part.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) part));\n                                break;\n                            case STR:\n                                log.debug(part.getMeaning().getCode() + STR + part.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) part));\n                                break;\n                            case STR:\n                                log.debug(part.getMeaning().getCode() + STR + part.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) part));\n                                break;\n                        }\n                    }\n                    break;\n                case STR:\n                    mpt.setStartOfTreatment(STR);\n                    break;\n                case STR:\n                    log.debug(item.getMeaning().getCode() + STR + item.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) item));\n                    break;\n                case STR:\n                    log.debug(item.getMeaning().getCode() + STR + item.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) item));\n                    break;\n                case STR:\n                    log.debug(item.getMeaning().getCode() + STR + item.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) item));\n                    break;\n                case STR:\n                    log.debug(item.getMeaning().getCode() + STR + item.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) item));\n                    break;\n                case STR:\n                    log.debug(item.getMeaning().getCode() + STR + item.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) item));\n                    break;\n            }\n        }\n    }\n    return bodyType;\n}","new_comment_raw":"@return a new MedicationMedicalRecord","old_comment_raw":"@return the target body information.","label":1,"pre_label":0,"AST_level":7,"line_counts":5,"new_code_token_num":44},{"new_code_raw":"public TreeGraphNode headWordNode() { TreeGraphNode hwn = safeCast(label.get(TreeCoreAnnotations.HeadWordAnnotation.class)); if (hwn == null || (hwn.treeGraph() != null && !(hwn.treeGraph().equals(this.treeGraph())))) { return null; } return hwn; }","old_code_raw":"  public TreeGraphNode headWordNode() {\n    return headWordNode;\n   }\n","new_comment_raw":"@return the node containing the head word for this node","old_comment_raw":"@return the node containing the head word for this node","label":0,"pre_label":1,"AST_level":8,"line_counts":8,"new_code_token_num":59},{"new_code_raw":"public static Integer toEpochDay(Object value) { if ( value == null ) return null; return (int)Conversions.toLocalDate(value).toEpochDay(); }","old_code_raw":"    public static Long toEpochDay(Object value) {\n        if ( value == null ) return null;\n        return Conversions.toLocalDate(value).toEpochDay();\n    }\n","new_comment_raw":"@return the number of days past epoch","old_comment_raw":"@return the microseconds past midnight","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":31},{"new_code_raw":"public boolean isRunning() { lock.lock(); try { if (process == null) { return false; } process.exitValue(); return false; } catch (IllegalThreadStateException e) { return true; } finally { lock.unlock(); } }","old_code_raw":"  public boolean isRunning() {\n    lock.lock();\n    try {\n      if (process == null) {\n        return false;\n      }\n      process.exitValue();\n      return true;\n    } catch (IllegalThreadStateException e) {\n      return false;\n    } finally {\n      lock.unlock();\n    }\n  }\n","new_comment_raw":"@return Whether the chromedriver child process is still running.","old_comment_raw":"@return Whether the chromedriver child process is still running.","label":0,"pre_label":1,"AST_level":7,"line_counts":15,"new_code_token_num":51},{"new_code_raw":"public FailoverListComposite getFailoverList() { return failoverList != null ? failoverList : new FailoverListComposite(new ArrayList<ServerEntry>()); }","old_code_raw":"public FailoverListComposite getFailoverList() {\n    return failoverList;\n}","new_comment_raw":"@return the FailoverListComposite assigned to it by the server (will not be <code>null<\/code> but may be empty)","old_comment_raw":"@return the FailoverListComposite assigned to it by the server","label":1,"pre_label":0,"AST_level":9,"line_counts":3,"new_code_token_num":24},{"new_code_raw":"public static ClassLoader getProxyClassLoader() { return WrappedClob.class.getClassLoader(); }","old_code_raw":"\tpublic static ClassLoader getProxyClassLoader() {\n\t\tClassLoader cl = ClassLoaderHelper.getContextClassLoader();\n\t\tif ( cl == null ) {\n\t\t\tcl = WrappedClob.class.getClassLoader();\n\t\t}\n\t\treturn cl;\n\t}\n","new_comment_raw":"@return The class loader appropriate for proxy construction.","old_comment_raw":"@return The class loader appropriate for proxy construction.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":15},{"new_code_raw":"public static Predicate<Connectivity> hasType(final int... types) { final int[] extendedTypes = appendUnknownNetworkTypeToTypes(types); return new Predicate<Connectivity>() { @Override public boolean test(@NonNull Connectivity connectivity) throws Exception { for (int type : extendedTypes) { if (connectivity.type() == type) { return true; } } return false; } }; }","old_code_raw":"  public static Predicate<Connectivity> hasType(final int... types) {\n    final int[] extendedTypes = appendUnknownNetworkTypeToTypes(types);\n    return new Predicate<Connectivity>() {\n      @Override public boolean test(@NonNull Connectivity connectivity) throws Exception {\n        for (int type : extendedTypes) {\n          if (connectivity.getType() == type) {\n            return true;\n          }\n        }\n        return false;\n      }\n    };\n  }\n","new_comment_raw":"@return true if at least one given type occurred","old_comment_raw":"@return true if at least one given type occurred","label":0,"pre_label":1,"AST_level":11,"line_counts":14,"new_code_token_num":71},{"new_code_raw":"public final int querySingleInt(String sqlCmd, Connection conn) { return querySingleInt(sqlCmd, null, NUM, conn); }","old_code_raw":"public final int querySingleInt(String sqlCmd, Connection conn) {\n    return querySingleInt(sqlCmd, NUM, conn);\n}","new_comment_raw":"@return the result as a int value","old_comment_raw":"@return the result as a int value, if no result the int value 0","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":25},{"new_code_raw":"public String getSubject() { SubjectHeader subject = (SubjectHeader) getStackMessage().getHeader(SubjectHeader.NAME); if (subject != null) { return subject.getSubject(); } else { return STR; } }","old_code_raw":"public String getSubject() {\n    SubjectHeader subject = (SubjectHeader) getStackMessage().getHeader(SubjectHeader.NAME);\n    if (subject != null) {\n        return subject.getSubject();\n    } else {\n        return null;\n    }\n}","new_comment_raw":"@return Subject or empty","old_comment_raw":"@return Subject or null if there is no subject","label":1,"pre_label":0,"AST_level":8,"line_counts":8,"new_code_token_num":41},{"new_code_raw":"protected boolean authenticate(ContainerRequestContext requestContext, C credentials, String scheme) { try { if (credentials == null) { return false; } final Optional<P> principal = authenticator.authenticate(credentials); if (!principal.isPresent()) { return false; } boolean secure = requestContext.getSecurityContext().isSecure(); requestContext.setSecurityContext(new SecurityContext() { @Override public Principal getUserPrincipal() { return principal.get(); } @Override public boolean isUserInRole(String role) { return authorizer.authorize(principal.get(), role); } @Override public boolean isSecure() { return secure; } @Override public String getAuthenticationScheme() { return scheme; } }); return true; } catch (AuthenticationException e) { logger.warn(\"Error authenticating credentials\", e); throw new InternalServerErrorException(); } }","old_code_raw":"    protected boolean authenticate(ContainerRequestContext requestContext, C credentials, String scheme) {\n        try {\n            if (credentials == null) {\n                return false;\n            }\n\n            final Optional<P> principal = authenticator.authenticate(credentials);\n            if (!principal.isPresent()) {\n                return false;\n            }\n\n            requestContext.setSecurityContext(new SecurityContext() {\n                @Override\n                public Principal getUserPrincipal() {\n                    return principal.get();\n                }\n\n                @Override\n                public boolean isUserInRole(String role) {\n                    return authorizer.authorize(principal.get(), role);\n                }\n\n                @Override\n                public boolean isSecure() {\n                    return requestContext.getSecurityContext().isSecure();\n                }\n\n                @Override\n                public String getAuthenticationScheme() {\n                    return scheme;\n                }\n            });\n            return true;\n        } catch (AuthenticationException e) {\n            logger.warn(\"Error authenticating credentials\", e);\n            throw new InternalServerErrorException();\n        }\n    }\n","new_comment_raw":"@return  true, if the request is authenticated, otherwise  false","old_comment_raw":"@return true, if the request is authenticated, otherwise false","label":0,"pre_label":1,"AST_level":10,"line_counts":40,"new_code_token_num":162},{"new_code_raw":"public ResourceTestRule build() { return new ResourceTestRule(buildResource()); }","old_code_raw":"public ResourceTestRule build() {\n    return new ResourceTestRule(new ResourceTestJerseyConfiguration(singletons, providers, properties, mapper, validator, clientConfigurator, testContainerFactory, registerDefaultExceptionMappers));\n}","new_comment_raw":"@return a new {@link ResourceExtension}","old_comment_raw":"@return a new {@link ResourceTestRule}","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":16},{"new_code_raw":"public long getResponseContentLength() { String contentLengthString = responseHeaders.getFirst(Headers.CONTENT_LENGTH); if (contentLengthString == null) { return -NUM; } return Long.parseLong(contentLengthString); }","old_code_raw":"public Long getResponseContentLength() {\n    String contentLengthString = responseHeaders.getFirst(Headers.CONTENT_LENGTH);\n    if (contentLengthString == null) {\n        return null;\n    }\n    return Long.parseLong(contentLengthString);\n}","new_comment_raw":"@return The content length of the response, or <code>-1<\/code> if it has not been set","old_comment_raw":"@return The content length of the response, or <code>null<\/code> if it has not been set","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":34},{"new_code_raw":"public String getSelectedIndex(String selectLocator) { return (String) seleneseMethods.get(\"getSelectedIndex\").apply(driver, selectLocator); }","old_code_raw":"  public String getSelectedIndex(String selectLocator) {\n    List<WebElement> options = getOptions(selectLocator);\n\n    for (int i = 0; i < options.size(); i++) {\n      WebElement option = options.get(i);\n      if (option.isSelected())\n        return String.valueOf(i);\n    }\n\n    throw new SeleniumException(\"No option is selected: \" + selectLocator);\n  }\n","new_comment_raw":"@return the selected option index in the specified select drop-down","old_comment_raw":"@return the selected option index in the specified select drop-down","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":27},{"new_code_raw":"public boolean report(Location location) { if (lastReport != null) { if (location.getTime() - lastReport.getTime() < locationRequest.getFastestInterval()) { return true; } if (location.distanceTo(lastReport) < locationRequest.getSmallestDesplacement()) { return true; } } Log.d(TAG, \"sending Location: \" + location); if (listener != null) { try { listener.onLocationChanged(location); } catch (RemoteException e) { return false; } } else if (pendingIntent != null) { Intent intent = new Intent(); intent.putExtra(\"com.google.android.location.LOCATION\", location); try { pendingIntent.send(context, 0, intent); } catch (PendingIntent.CanceledException e) { return false; } } else if (callback != null) { try { callback.onLocationResult(LocationResult.create(Arrays.asList(location))); } catch (RemoteException e) { return false; } } lastReport = location; numReports++; return numReports < locationRequest.getNumUpdates(); }","old_code_raw":"    public boolean report(Location location) {\n        if (lastReport != null) {\n            if (location.getTime() - lastReport.getTime() < locationRequest.getFastestInterval()) {\n                return true;\n            }\n            if (location.distanceTo(lastReport) < locationRequest.getSmallestDesplacement()) {\n                return true;\n            }\n        }\n        Log.d(TAG, \"sending Location: \" + location);\n        if (listener != null) {\n            try {\n                listener.onLocationChanged(location);\n            } catch (RemoteException e) {\n                return false;\n            }\n        } else if (pendingIntent != null) {\n            Intent intent = new Intent();\n            intent.putExtra(\"com.google.android.location.LOCATION\", location);\n            try {\n                pendingIntent.send(context, 0, intent);\n            } catch (PendingIntent.CanceledException e) {\n                return false;\n            }\n        }\n        lastReport = location;\n        numReports++;\n        return numReports < locationRequest.getNumUpdates();\n    }\n","new_comment_raw":"@return whether to continue sending reports to this  LocationRequestHelper","old_comment_raw":"@return whether to continue sending reports to this LocationRequestHelper","label":0,"pre_label":1,"AST_level":12,"line_counts":36,"new_code_token_num":200},{"new_code_raw":"public static LocalDate fromCalendarFields(Calendar calendar) { if (calendar == null) { throw new IllegalArgumentException(\"The calendar must not be null\"); } int era = calendar.get(Calendar.ERA); int yearOfEra = calendar.get(Calendar.YEAR); return new LocalDate( (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra), calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH) ); }","old_code_raw":"    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        return new LocalDate(\n            calendar.get(Calendar.YEAR),\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }\n","new_comment_raw":"@return the created local date, not null","old_comment_raw":"@return the created LocalDate","label":1,"pre_label":0,"AST_level":7,"line_counts":13,"new_code_token_num":82},{"new_code_raw":"public static String sanitizeCSV(String csv) { String[] tokens = csv.split(\",\"); return Arrays.stream(tokens) .map(String::trim) .filter(StringUtils::isNotEmpty) .collect(Collectors.joining(\",\")); }","old_code_raw":"  public static String sanitizeCSV(String csv) {\n    \/\/ tokenize\n    String[] tokens = csv.split(\",\");\n    ArrayList<String> sanitizedTokens = new ArrayList<String>(tokens.length);\n    \/\/ check for empties\n    for (String s : tokens) {\n      String trimmedToken = s.trim();\n      if (trimmedToken.length() != 0) {\n        sanitizedTokens.add(trimmedToken);\n      }\n    }\n    String result = \"\";\n    if (sanitizedTokens.size() != 0) {\n      result = Joiner.on(\",\").join(sanitizedTokens);\n    }\n    return result;\n  }\n","new_comment_raw":"@return The sanitized CSV string","old_comment_raw":"@return The sanitized CSV string","label":0,"pre_label":1,"AST_level":7,"line_counts":8,"new_code_token_num":53},{"new_code_raw":"public Number getXpathCount(String xpath) { return (Number) seleneseMethods.get(\"getXpathCount\").apply(driver, xpath); }","old_code_raw":"  public Number getXpathCount(String xpath) {\n    return driver.findElements(By.xpath(xpath)).size();\n  }\n","new_comment_raw":"@return the number of nodes that match the specified xpath","old_comment_raw":"@return the number of nodes that match the specified xpath","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":27},{"new_code_raw":"public TwitterTokenStream duplicate() { DuplicatedTokenStream duplicate = new DuplicatedTokenStream(inputStream); duplicatedStreams.add(duplicate); return duplicate; }","old_code_raw":"public TokenStream duplicate() {\n    DuplicatedTokenStream duplicate = new DuplicatedTokenStream(inputStream);\n    duplicatedStreams.add(duplicate);\n    return duplicate;\n}","new_comment_raw":"@return a duplicated TwitterTokenStream","old_comment_raw":"@return a duplicated TokenStream","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":24},{"new_code_raw":"public SessionFactoryImpl getEntityManagerFactory() { return sessionFactory; }","old_code_raw":"\tpublic  EntityManagerFactoryImpl getEntityManagerFactory() {\n\t\treturn entityManagerFactory;\n\t}\n","new_comment_raw":"@return The underlying  SessionFactoryImpl","old_comment_raw":"@return The underlying EntityManagerFactoryImpl","label":1,"pre_label":0,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"protected MediaType mediaType() { return MediaType.APPLICATION_JSON_TYPE; }","old_code_raw":"    protected MediaType mediaType() {\n        return MediaType.TEXT_PLAIN_TYPE;\n    }\n","new_comment_raw":"@return the media type of the error message entity","old_comment_raw":"@return the media type of the error message entity","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":11},{"new_code_raw":"public List<X_AD_ReplicationDocument> getReplicationDocuments() { final String whereClause = I_AD_ReplicationDocument.COLUMNNAME_AD_ReplicationStrategy_ID + STR; return new Query(getCtx(), I_AD_ReplicationDocument.Table_Name, whereClause, get_TrxName()).setClient_ID().setParameters(getAD_ReplicationStrategy_ID()).setOnlyActiveRecords(true).setApplyAccessFilter(false).list(); }","old_code_raw":"public Collection<X_AD_ReplicationDocument> getReplicationDocuments() {\n    String whereClause = STR;\n    return new Query(getCtx(), X_AD_ReplicationDocument.Table_Name, whereClause, get_TrxName()).setClient_ID().setParameters(getAD_ReplicationStrategy_ID()).setOnlyActiveRecords(true).setApplyAccessFilter(false).list();\n}","new_comment_raw":"@return the list the X_AD_ReplicationDocument","old_comment_raw":"@return the collection the X_AD_ReplicationDocument","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":54},{"new_code_raw":"public static HashMap getXmlRpcWorkflowInstance(WorkflowInstance wInst) { HashMap workflowInstance = new HashMap(); workflowInstance.put(STR, wInst.getCurrentTaskId()); workflowInstance.put(STR, wInst.getStatus()); workflowInstance.put(STR, wInst.getId()); workflowInstance.put(STR, getXmlRpcWorkflow(wInst.getWorkflow())); workflowInstance.put(STR, wInst.getStartDateTimeIsoStr() != null ? wInst.getStartDateTimeIsoStr() : STR); workflowInstance.put(STR, wInst.getEndDateTimeIsoStr() != null ? wInst.getEndDateTimeIsoStr() : STR); workflowInstance.put(STR, wInst.getCurrentTaskStartDateTimeIsoStr() != null ? wInst.getCurrentTaskStartDateTimeIsoStr() : STR); workflowInstance.put(STR, wInst.getCurrentTaskEndDateTimeIsoStr() != null ? wInst.getCurrentTaskEndDateTimeIsoStr() : STR); workflowInstance.put(STR, wInst.getSharedContext() != null ? wInst.getSharedContext().getMap() : new HashMap()); workflowInstance.put(STR, wInst.getPriority() != null ? String.valueOf(wInst.getPriority().getValue()) : String.valueOf(Priority.getDefault().getValue())); return workflowInstance; }","old_code_raw":"public static Hashtable getXmlRpcWorkflowInstance(WorkflowInstance wInst) {\n    Hashtable workflowInstance = new Hashtable();\n    workflowInstance.put(STR, wInst.getCurrentTaskId());\n    workflowInstance.put(STR, wInst.getStatus());\n    workflowInstance.put(STR, wInst.getId());\n    workflowInstance.put(STR, getXmlRpcWorkflow(wInst.getWorkflow()));\n    workflowInstance.put(STR, wInst.getStartDateTimeIsoStr() != null ? wInst.getStartDateTimeIsoStr() : STR);\n    workflowInstance.put(STR, wInst.getEndDateTimeIsoStr() != null ? wInst.getEndDateTimeIsoStr() : STR);\n    workflowInstance.put(STR, wInst.getCurrentTaskStartDateTimeIsoStr() != null ? wInst.getCurrentTaskStartDateTimeIsoStr() : STR);\n    workflowInstance.put(STR, wInst.getCurrentTaskEndDateTimeIsoStr() != null ? wInst.getCurrentTaskEndDateTimeIsoStr() : STR);\n    workflowInstance.put(STR, wInst.getSharedContext() != null ? wInst.getSharedContext().getMap() : new Hashtable());\n    workflowInstance.put(STR, wInst.getPriority() != null ? String.valueOf(wInst.getPriority().getValue()) : String.valueOf(Priority.getDefault().getValue()));\n    return workflowInstance;\n}","new_comment_raw":"@return A {@link HashMap} representation of a {@link WorkflowInstance}.","old_comment_raw":"@return A {@link Hashtable} representation of a {@link WorkflowInstance}.","label":1,"pre_label":0,"AST_level":8,"line_counts":14,"new_code_token_num":210},{"new_code_raw":"public ZapTextField getTxtPattern() { if (txtPattern == null) { txtPattern = new ZapTextField(); } return txtPattern; }","old_code_raw":"\tpublic JTextField getTxtPattern() {\n\t\tif (txtPattern == null) {\n\t\t\ttxtPattern = new JTextField();\n\t\t}\n\t\treturn txtPattern;\n\t}\n","new_comment_raw":"@return javax.swing.ZapTextField","old_comment_raw":"@return javax.swing.JTextField","label":1,"pre_label":0,"AST_level":8,"line_counts":7,"new_code_token_num":23},{"new_code_raw":"public CodegenType getTag() { return CodegenType.SERVER; }","old_code_raw":"    public CodegenType getTag() {\n        return CodegenType.CLIENT;\n    }\n","new_comment_raw":"@return the CodegenType for this generator","old_comment_raw":"@return the CodegenType for this generator","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":11},{"new_code_raw":"private Way getWayForNode(Node n) { Way way = null; for (Way w : Main.ds.ways) { int i = w.nodes.indexOf(n); if (i == -NUM) continue; if (i == NUM || i == w.nodes.size() - NUM) { if (way != null) return null; way = w; } } return way; }","old_code_raw":"private Way getWayForNode(Node n) {\n    Way way = null;\n    for (Way w : Main.ds.ways) {\n        for (Segment s : w.segments) {\n            if (s.from == n || s.to == n) {\n                if (way != null)\n                    return null;\n                if (s.from == s.to)\n                    return null;\n                way = w;\n            }\n        }\n    }\n    return way;\n}","new_comment_raw":"@return If the node is the end of exactly one way, return this. <code>null<\/code> otherwise.","old_comment_raw":"@return If the node is part of exactly one way, return this. <code>null<\/code> otherwise.","label":1,"pre_label":0,"AST_level":9,"line_counts":14,"new_code_token_num":73},{"new_code_raw":"public static String quote(String name) { if ( name == null || name.length() == 0 || isQuoted( name ) ) { return name; } else { return new StringBuffer( name.length() + 2 ).append('`').append( name ).append( '`' ).toString(); } }","old_code_raw":"\tpublic static String quote(String name) {\n\t\tif ( name == null || name.length() == 0 || isQuoted( name ) ) {\n\t\t\treturn name;\n\t\t}\n\t\telse {\n\t\t\treturn new StringBuilder( name.length() + 2 ).append('`').append( name ).append( '`' ).toString();\n\t\t}\n\t}\n","new_comment_raw":"@return The quoted version.","old_comment_raw":"@return The quoted version.","label":0,"pre_label":1,"AST_level":8,"line_counts":9,"new_code_token_num":65},{"new_code_raw":"List<String> getTempFiles() { List<String> tempFiles = new ArrayList<String>(); for (Entry<ManagedFile, FilePath> entry : file2Path.entrySet()) { boolean noTargetGiven = StringUtils.isBlank(entry.getKey().targetLocation); if (noTargetGiven) { tempFiles.add(entry.getValue().getRemote()); } } return tempFiles; }","old_code_raw":"public List<FilePath> getTempFiles() {\n    List<FilePath> tempFiles = new ArrayList<FilePath>();\n    for (Entry<ManagedFile, FilePath> entry : file2Path.entrySet()) {\n        boolean noTargetGiven = StringUtils.isBlank(entry.getKey().targetLocation);\n        if (noTargetGiven) {\n            tempFiles.add(entry.getValue());\n        }\n    }\n    return tempFiles;\n}","new_comment_raw":"@return a list of paths to the temp files (remotes)","old_comment_raw":"@return a list of temp files","label":1,"pre_label":0,"AST_level":10,"line_counts":10,"new_code_token_num":64},{"new_code_raw":"public RexNode apply(Integer i) { return rexBuilder.makeCall( SqlStdOperatorTable.EQUALS, leftKeys[i], bb.convertExpression( call.getOperands()[i])); }","old_code_raw":"                      public RexNode apply(Integer i) {\n                        return rexBuilder.makeCall(\n                            SqlStdOperatorTable.equalsOperator,\n                            leftKeys[i],\n                            bb.convertExpression(\n                                call.getOperands()[i]));\n                      }\n","new_comment_raw":"@return converted expression","old_comment_raw":"@return converted expression","label":0,"pre_label":1,"AST_level":8,"line_counts":8,"new_code_token_num":34},{"new_code_raw":"private SourceRange getResultRange(String identPattern) { int offset = resultCode.indexOf(identPattern); assertThat(offset).describedAs(identPattern + STR + resultCode).isPositive(); String identifier = identPattern.substring(NUM, NOT_IDENTIFIER_MATCHER.indexIn(identPattern)); return new SourceRange(offset, identifier.length()); }","old_code_raw":"private SourceRange getResultRange(String wordPattern) {\n    int offset = resultCode.indexOf(wordPattern);\n    assertThat(offset).describedAs(wordPattern + STR + resultCode).isPositive();\n    String word = StringUtils.substringBefore(wordPattern, STR);\n    return new SourceRange(offset, word.length());\n}","new_comment_raw":"@return the {@link SourceRange} of \"identPattern\" in {@link #resultCode}.","old_comment_raw":"@return the {@link SourceRange} of \"wordPattern\" in {@link #resultCode}.","label":1,"pre_label":0,"AST_level":8,"line_counts":6,"new_code_token_num":59},{"new_code_raw":"protected boolean authenticate(ContainerRequestContext requestContext, C credentials, String scheme) { try { if (credentials == null) { return false; } final Optional<P> principal = authenticator.authenticate(credentials); if (!principal.isPresent()) { return false; } requestContext.setSecurityContext(new SecurityContext() { @Override public Principal getUserPrincipal() { return principal.get(); } @Override public boolean isUserInRole(String role) { return authorizer.authorize(principal.get(), role); } @Override public boolean isSecure() { return requestContext.getSecurityContext().isSecure(); } @Override public String getAuthenticationScheme() { return scheme; } }); return true; } catch (AuthenticationException e) { logger.warn(\"Error authenticating credentials\", e); throw new InternalServerErrorException(); } }","old_code_raw":"    protected boolean authenticate(ContainerRequestContext requestContext, C credentials, String scheme) {\n        try {\n            if (credentials == null) {\n                return false;\n            }\n\n            final Optional<P> principal = authenticator.authenticate(credentials);\n            if (!principal.isPresent()) {\n                return false;\n            }\n\n            final SecurityContext securityContext = requestContext.getSecurityContext();\n            final boolean secure = securityContext != null && securityContext.isSecure();\n            \n            requestContext.setSecurityContext(new SecurityContext() {\n                @Override\n                public Principal getUserPrincipal() {\n                    return principal.get();\n                }\n\n                @Override\n                public boolean isUserInRole(String role) {\n                    return authorizer.authorize(principal.get(), role);\n                }\n\n                @Override\n                public boolean isSecure() {\n                    return secure;\n                }\n\n                @Override\n                public String getAuthenticationScheme() {\n                    return scheme;\n                }\n            });\n            return true;\n        } catch (AuthenticationException e) {\n            logger.warn(\"Error authenticating credentials\", e);\n            throw new InternalServerErrorException();\n        }\n    }\n","new_comment_raw":"@return  true, if the request is authenticated, otherwise  false","old_comment_raw":"@return true, if the request is authenticated, otherwise false","label":0,"pre_label":1,"AST_level":10,"line_counts":39,"new_code_token_num":158},{"new_code_raw":"public ApiResponse<Void> updatePetWithFormWithHttpInfo(Long petId, String name, String status) throws ApiException { okhttp3.Call localVarCall = updatePetWithFormValidateBeforeCall(petId, name, status, null, null); return localVarApiClient.execute(localVarCall); }","old_code_raw":"    public ApiResponse<Void> updatePetWithFormWithHttpInfo(Long petId, String name, String status) throws ApiException {\n        okhttp3.Call call = updatePetWithFormValidateBeforeCall(petId, name, status, null, null);\n        return apiClient.execute(call);\n    }\n","new_comment_raw":"@return ApiResponse&lt;Void&gt;","old_comment_raw":"@return ApiResponse&lt;Void&gt;","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":41},{"new_code_raw":"public static MatchFinder allOf(final MatchFinder... finders) { return new MatchFinder() { @Override public boolean matches(UiElement element) { for (MatchFinder finder : finders) { if (!finder.matches(element)) { return false; } } return true; } @Override public String toString() { return STR + Joiner.on(STR).join(finders) + STR; } }; }","old_code_raw":"public static ElementMatcher allOf(final ElementMatcher... matchers) {\n    return new ElementMatcher() {\n\n        @Override\n        public boolean matches(UiElement element) {\n            for (ElementMatcher matcher : matchers) {\n                if (!matcher.matches(element)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        @Override\n        public String toString() {\n            return STR + Joiner.on(STR).join(matchers) + STR;\n        }\n    };\n}","new_comment_raw":"@return a finder that is the logical conjunction of given finders","old_comment_raw":"@return a matcher that is the logical conjunction of given matchers","label":1,"pre_label":0,"AST_level":11,"line_counts":19,"new_code_token_num":80},{"new_code_raw":"public static ApiResponseSet<String> httpMessageToSet(int historyId, int historyType, HttpMessage msg) { Map<String, String> map = new HashMap<>(); map.put(\"id\", String.valueOf(historyId)); map.put(\"type\", String.valueOf(historyType)); map.put(\"timestamp\", String.valueOf(msg.getTimeSentMillis())); map.put(\"rtt\", String.valueOf(msg.getTimeElapsedMillis())); map.put(\"cookieParams\", msg.getCookieParamsAsString()); map.put(\"note\", msg.getNote()); map.put(\"requestHeader\", msg.getRequestHeader().toString()); map.put(\"requestBody\", msg.getRequestBody().toString()); map.put(\"responseHeader\", msg.getResponseHeader().toString()); if (HttpHeader.GZIP.equals(msg.getResponseHeader().getHeader(HttpHeader.CONTENT_ENCODING))) { \/\/ Uncompress gziped content try (ByteArrayInputStream bais = new ByteArrayInputStream(msg.getResponseBody().getBytes()); GZIPInputStream gis = new GZIPInputStream(bais); InputStreamReader isr = new InputStreamReader(gis); BufferedReader br = new BufferedReader(isr);) { StringBuilder sb = new StringBuilder(); String line = null; while ((line = br.readLine()) != null) { sb.append(line); } map.put(\"responseBody\", sb.toString()); } catch (IOException e) { LOGGER.error(\"Unable to uncompress gzip content: \" + e.getMessage(), e); map.put(\"responseBody\", msg.getResponseBody().toString()); } } else { map.put(\"responseBody\", msg.getResponseBody().toString()); } List<String> tags = Collections.emptyList(); try { tags = HistoryReference.getTags(historyId); } catch (DatabaseException e) { LOGGER.warn(\"Failed to obtain the tags for message with ID \" + historyId, e); } return new HttpMessageResponseSet(map, tags); }","old_code_raw":"    public static ApiResponseSet<String> httpMessageToSet(int historyId, int historyType, HttpMessage msg) {\n        Map<String, String> map = new HashMap<>();\n        map.put(\"id\", String.valueOf(historyId));\n        map.put(\"type\", String.valueOf(historyType));\n        map.put(\"timestamp\", String.valueOf(msg.getTimeSentMillis()));\n        map.put(\"rtt\", String.valueOf(msg.getTimeElapsedMillis()));\n        map.put(\"cookieParams\", msg.getCookieParamsAsString());\n        map.put(\"note\", msg.getNote());\n        map.put(\"requestHeader\", msg.getRequestHeader().toString());\n        map.put(\"requestBody\", msg.getRequestBody().toString());\n        map.put(\"responseHeader\", msg.getResponseHeader().toString());\n\n        if (HttpHeader.GZIP.equals(msg.getResponseHeader().getHeader(HttpHeader.CONTENT_ENCODING))) {\n            \/\/ Uncompress gziped content\n            try (ByteArrayInputStream bais = new ByteArrayInputStream(msg.getResponseBody().getBytes());\n                 GZIPInputStream gis = new GZIPInputStream(bais);\n                 InputStreamReader isr = new InputStreamReader(gis);\n                 BufferedReader br = new BufferedReader(isr);) {\n                StringBuilder sb = new StringBuilder();\n                String line = null;\n                while ((line = br.readLine()) != null) {\n                    sb.append(line);\n                }\n                map.put(\"responseBody\", sb.toString());\n            } catch (IOException e) {\n                LOGGER.error(\"Unable to uncompress gzip content: \" + e.getMessage(), e);\n                map.put(\"responseBody\", msg.getResponseBody().toString());\n            }\n        } else {\n            map.put(\"responseBody\", msg.getResponseBody().toString());\n        }\n\n        return new ApiResponseSet<String>(\"message\", map);\n    }\n","new_comment_raw":"@return the  ApiResponseSet with the ID, type and the HTTP message","old_comment_raw":"@return the ApiResponseSet with the ID, type and the HTTP message","label":0,"pre_label":1,"AST_level":10,"line_counts":41,"new_code_token_num":390},{"new_code_raw":"private int updateRedundancy() { int numBucketHosts = getNumInitializedBuckets(); if (!isClosed()) { redundancyTracker.updateStatistics(numBucketHosts); } return numBucketHosts; }","old_code_raw":"private int updateRedundancy() {\n    int desiredRedundancy = this.pRegion.getRedundantCopies();\n    int numBucketHosts = getNumInitializedBuckets();\n    if (isClosed()) {\n        return numBucketHosts;\n    }\n    int actualRedundancy = numBucketHosts - NUM;\n    this.redundancy = actualRedundancy;\n    if (this.redundancySatisfied && numBucketHosts > NUM && actualRedundancy < desiredRedundancy) {\n        incLowRedundancyBucketCount(NUM);\n        this.redundancySatisfied = false;\n    } else if (!this.redundancySatisfied && numBucketHosts > NUM && actualRedundancy >= desiredRedundancy) {\n        incLowRedundancyBucketCount(-NUM);\n        this.redundancySatisfied = true;\n        this.redundancyEverSatisfied = true;\n    }\n    return numBucketHosts;\n}","new_comment_raw":"@return number of current bucket hosts","old_comment_raw":"@return current number of hosts for this bucket","label":1,"pre_label":0,"AST_level":7,"line_counts":7,"new_code_token_num":31},{"new_code_raw":"public AnimationBuilder animateScale(float scale) { if (!isImageReady()) { return null; } return new AnimationBuilder(scale); }","old_code_raw":"public ScaleAnimationBuilder animateScale(float scale) {\n    if (!isImageReady()) {\n        return null;\n    }\n    return new ScaleAnimationBuilder(scale);\n}","new_comment_raw":"@return {@link AnimationBuilder} instance. Call {@link com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView.AnimationBuilder#start()} to start the anim.","old_comment_raw":"@return {@link ScaleAnimationBuilder} instance. Call {@link com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView.ScaleAnimationBuilder#start()} to start the anim.","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":28},{"new_code_raw":"public ApiResponse<Client> testClassnameWithHttpInfo(Client body) throws ApiException { okhttp3.Call localVarCall = testClassnameValidateBeforeCall(body, null, null); Type localVarReturnType = new TypeToken<Client>(){}.getType(); return localVarApiClient.execute(localVarCall, localVarReturnType); }","old_code_raw":"    public ApiResponse<Client> testClassnameWithHttpInfo(Client body) throws ApiException {\n        okhttp3.Call call = testClassnameValidateBeforeCall(body, null, null);\n        Type localVarReturnType = new TypeToken<Client>(){}.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n","new_comment_raw":"@return ApiResponse&lt;Client&gt;","old_comment_raw":"@return ApiResponse&lt;Client&gt;","label":0,"pre_label":1,"AST_level":8,"line_counts":6,"new_code_token_num":46},{"new_code_raw":"public Node getSecondNode() { return m_node2; }","old_code_raw":"public NodeItem getSecondNode() {\n    return m_node2;\n}","new_comment_raw":"@return the second (target) VisualItem","old_comment_raw":"@return the second (target) GraphItem","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":10},{"new_code_raw":"public ApnsServiceBuilder asQueued() { return asQueued(Executors.defaultThreadFactory()); }","old_code_raw":"    public ApnsServiceBuilder asQueued() {\n        this.isQueued = true;\n        return this;\n    }\n","new_comment_raw":"@return this","old_comment_raw":"@return this","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":16},{"new_code_raw":"public static <T extends CharSequence> T validIndex(final T chars, final int index, final String message, final Object... values) { Validate.notNull(chars); if (index < NUM || index >= chars.length()) { throw new IndexOutOfBoundsException(String.format(message, values)); } return chars; }","old_code_raw":"public static <T extends Collection<?>> T validIndex(final T collection, final int index, final String message, final Object... values) {\n    Validate.notNull(collection);\n    if (index < NUM || index >= collection.size()) {\n        throw new IndexOutOfBoundsException(String.format(message, values));\n    }\n    return collection;\n}","new_comment_raw":"@return the validated character sequence (never {@code null} for method chaining)","old_comment_raw":"@return the validated collection (never {@code null} for chaining)","label":1,"pre_label":0,"AST_level":8,"line_counts":7,"new_code_token_num":62},{"new_code_raw":"public static String getProgramFilesPath() { return getEnvVarPath(\"ProgramFiles\", \"C:\\\\Program Files\"); }","old_code_raw":"  public static String getProgramFilesPath() {\n    loadEnvironment();\n    String pf = getEnvVarIgnoreCase(\"ProgramFiles\");\n    if (pf != null) {\n      File ProgramFiles = new File(pf);\n      if (ProgramFiles.exists()) {\n        return ProgramFiles.getAbsolutePath();\n      }\n    }\n    return new File(\"C:\\\\Program Files\").getAbsolutePath();\n  }\n","new_comment_raw":"@return the path to the Windows Program Files","old_comment_raw":"@return the path to the Windows Program Files","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":25},{"new_code_raw":"public static GrammaticalRelation getAcl(String aclString) { \/* Check for nmod subtypes which are not stored in the `nmods` map. *\/ if (aclString.equals(\"relcl\")) { return RELATIVE_CLAUSE_MODIFIER; } GrammaticalRelation result = acls.get(aclString); if (result == null) { synchronized(acls) { result = acls.get(aclString); if (result == null) { result = new GrammaticalRelation(Language.UniversalEnglish, \"acl\", \"acl_preposition\", CLAUSAL_MODIFIER, aclString); acls.put(aclString, result); threadSafeAddRelation(result); } } } return result; }","old_code_raw":"  public static GrammaticalRelation getAcl(String aclString) {\n    GrammaticalRelation result = acls.get(aclString);\n    if (result == null) {\n      synchronized(acls) {\n        result = acls.get(aclString);\n        if (result == null) {\n          result = new GrammaticalRelation(Language.UniversalEnglish, \"acl\", \"acl_preposition\", CLAUSAL_MODIFIER, aclString);\n          acls.put(aclString, result);\n          threadSafeAddRelation(result);\n        }\n      }\n    }\n    return result;\n  }\n","new_comment_raw":"@return A grammatical relation for this preposition","old_comment_raw":"@return A grammatical relation for this preposition","label":0,"pre_label":1,"AST_level":11,"line_counts":21,"new_code_token_num":112},{"new_code_raw":"public static List<SLARegistrationBean> fromJSONArray(JSONArray array) { List<SLARegistrationBean> list = new ArrayList<SLARegistrationBean>(); for (Object obj : array) { list.add(new SLARegistrationBean((JSONObject) obj)); } return list; }","old_code_raw":"public static List<SLAEvent> fromJSONArray(JSONArray array) {\n    List<SLAEvent> list = new ArrayList<SLAEvent>();\n    for (Object obj : array) {\n        list.add(new JsonSLARegistrationEvent((JSONObject) obj));\n    }\n    return list;\n}","new_comment_raw":"@return the corresponding SLA SLARegistrationBean list.","old_comment_raw":"@return the corresponding SLA event list.","label":1,"pre_label":0,"AST_level":9,"line_counts":7,"new_code_token_num":45},{"new_code_raw":"private GraphQLInputType buildInputType(BuildContext buildCtx, Type rawType) { TypeDefinition typeDefinition = buildCtx.getTypeDefinition(rawType); TypeInfo typeInfo = TypeInfo.typeInfo(rawType); GraphQLInputType inputType = buildCtx.hasInputType(typeDefinition); if (inputType != null) { return typeInfo.decorate(inputType); } if (buildCtx.stackContains(typeInfo)) { \/\/ we have circled around so put in a type reference and fix it later return typeInfo.decorate(new GraphQLTypeReference(typeInfo.getName())); } buildCtx.push(typeInfo); if (typeDefinition instanceof InputObjectTypeDefinition) { inputType = buildInputObjectType(buildCtx, (InputObjectTypeDefinition) typeDefinition); } else if (typeDefinition instanceof EnumTypeDefinition) { inputType = buildEnumType((EnumTypeDefinition) typeDefinition); } else { inputType = buildScalar(buildCtx, (ScalarTypeDefinition) typeDefinition); } buildCtx.put(inputType); buildCtx.pop(); return typeInfo.decorate(inputType); }","old_code_raw":"    private GraphQLInputType buildInputType(BuildContext buildCtx, Type rawType) {\n\n        TypeDefinition typeDefinition = buildCtx.getTypeDefinition(rawType);\n\n        GraphQLInputType inputType = buildCtx.hasInputType(typeDefinition);\n        if (inputType != null) {\n            return inputType;\n        }\n        TypeInfo typeInfo = TypeInfo.typeInfo(rawType);\n\n        if (buildCtx.stackContains(typeInfo)) {\n            \/\/ we have circled around so put in a type reference and fix it later\n            return typeInfo.decorate(new GraphQLTypeReference(typeInfo.getName()));\n        }\n\n        buildCtx.push(typeInfo);\n\n        if (typeDefinition instanceof InputObjectTypeDefinition) {\n            inputType = buildInputObjectType(buildCtx, (InputObjectTypeDefinition) typeDefinition);\n        } else if (typeDefinition instanceof EnumTypeDefinition) {\n            inputType = buildEnumType((EnumTypeDefinition) typeDefinition);\n        } else {\n            inputType = buildScalar(buildCtx, (ScalarTypeDefinition) typeDefinition);\n        }\n\n        buildCtx.put(inputType);\n        buildCtx.pop();\n        return typeInfo.decorate(inputType);\n    }\n","new_comment_raw":"@return an output type","old_comment_raw":"@return an output type","label":0,"pre_label":1,"AST_level":10,"line_counts":30,"new_code_token_num":166},{"new_code_raw":"public int compare(Pair<E, Double> a, Pair<E, Double> b) { int candidate = Double.compare(a.second, b.second); if (candidate == 0.0 && a.first instanceof Comparable && b.first instanceof Comparable) { \/\/ Try to create a stable ordering, breaking ties with the key's natural order return ((Comparable) a.first).compareTo(b.first); } else { return candidate; } }","old_code_raw":"      public int compare(Pair<E, Double> a, Pair<E, Double> b) {\n        return Double.compare(b.second, a.second);\n      }\n","new_comment_raw":"@return A List of the keys in c, sorted from highest count to lowest.","old_comment_raw":"@return A List of the keys in c, sorted from highest count to lowest.","label":0,"pre_label":1,"AST_level":7,"line_counts":10,"new_code_token_num":88},{"new_code_raw":"public PMetadata getCache(PGraphics renderer) { if (cacheMap == null) return null; return cacheMap.get(renderer); }","old_code_raw":"  public Object getCache(Object parent) {\n    if (cacheMap == null) return null;\n    return cacheMap.get(parent);\n  }\n","new_comment_raw":"@return metadata stored for the specified renderer","old_comment_raw":"@return data stored for the specified parent","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":24},{"new_code_raw":"public FlyoutFragment getTrashFragment() { return mTrashFragment; }","old_code_raw":"public TrashFragment getTrashFragment() {\n    return mTrashFragment;\n}","new_comment_raw":"@return The currently attached trash {@link FlyoutFragment}.","old_comment_raw":"@return The currently attached {@link TrashFragment}.","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":10},{"new_code_raw":"public byte[] getObjectDigest() { if (holder.getObjectDigestInfo() != null) { return holder.getObjectDigestInfo().getObjectDigest().getBytes(); } return null; }","old_code_raw":"public byte[] getObjectDigest() {\n    if (holder.getObjectDigestInfo() != null) {\n        holder.getObjectDigestInfo().getObjectDigest().getBytes();\n    }\n    return null;\n}","new_comment_raw":"@return The hash or <code>null<\/code> if ObjectDigestInfo is absent.","old_comment_raw":"@return The hash or <code>null<\/code> if no object digest info is set.","label":1,"pre_label":0,"AST_level":7,"line_counts":6,"new_code_token_num":35},{"new_code_raw":"public Property centuryOfEra() { return new Property(this, getChronology().centuryOfEra()); }","old_code_raw":"    public ReadWritableInstantFieldProperty centuryOfEra() {\n        return new ReadWritableInstantFieldProperty(this, getChronology().centuryOfEra());\n    }\n","new_comment_raw":"@return the year of era property","old_comment_raw":"@return the year of era property","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":21},{"new_code_raw":"public static BinaryVisitor<String, Writer> write() { return new Write(); }","old_code_raw":"public static BinaryPredicate<String, Writer> write() {\n    return new Write();\n}","new_comment_raw":"@return a {@link BinaryVisitor} that will call {@code write(x)} on the {@link java.io.Writer} {@code y}","old_comment_raw":"@return a {@link BinaryPredicate} that will call {@code write(x)} on the {@link java.io.Writer} {@code y}","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":17},{"new_code_raw":"public ComponentAdapter createComponentAdapter(ComponentMonitor componentMonitor, LifecycleStrategy lifecycleStrategy, ComponentCharacteristic registerationCharacteristic, Object componentKey, Class componentImplementation, Parameter... parameters) throws PicoIntrospectionException, AssignabilityRegistrationException, NotConcreteRegistrationException { return new SetterInjectionComponentAdapter(componentKey, componentImplementation, parameters, componentMonitor, lifecycleStrategy); }","old_code_raw":"public ComponentAdapter createComponentAdapter(ComponentCharacteristic registerationCharacteristic, Object componentKey, Class componentImplementation, Parameter... parameters) throws PicoIntrospectionException, AssignabilityRegistrationException, NotConcreteRegistrationException {\n    return new SetterInjectionComponentAdapter(componentKey, componentImplementation, parameters, currentMonitor(), lifecycleStrategy);\n}","new_comment_raw":"the number of the setter. @return Returns a new {@link org.picocontainer.adapters.SetterInjectionComponentAdapter}. @throws PicoIntrospectionException if dependencies cannot be solved","old_comment_raw":"the number of the setter. @return Returns a new {@link SetterInjectionComponentAdapter}.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":45},{"new_code_raw":"protected FieldValueInfo completeField(ExecutionContext executionContext, ExecutionStrategyParameters parameters, Object fetchedValue) { Field field = parameters.getField().get(0); GraphQLObjectType parentType = parameters.getTypeInfo().castType(GraphQLObjectType.class); GraphQLFieldDefinition fieldDef = getFieldDef(executionContext.getGraphQLSchema(), parentType, field); ExecutionTypeInfo fieldTypeInfo = fieldTypeInfo(parameters, fieldDef); Instrumentation instrumentation = executionContext.getInstrumentation(); InstrumentationFieldCompleteParameters instrumentationParams = new InstrumentationFieldCompleteParameters(executionContext, parameters, fieldDef, fieldTypeInfo, fetchedValue); InstrumentationContext<ExecutionResult> ctxCompleteField = instrumentation.beginFieldComplete( instrumentationParams ); GraphqlFieldVisibility fieldVisibility = executionContext.getGraphQLSchema().getFieldVisibility(); Map<String, Object> argumentValues = valuesResolver.getArgumentValues(fieldVisibility, fieldDef.getArguments(), field.getArguments(), executionContext.getVariables()); NonNullableFieldValidator nonNullableFieldValidator = new NonNullableFieldValidator(executionContext, fieldTypeInfo); ExecutionStrategyParameters newParameters = parameters.transform(builder -> builder.typeInfo(fieldTypeInfo) .arguments(argumentValues) .source(fetchedValue) .nonNullFieldValidator(nonNullableFieldValidator) ); log.debug(\"'{}' completing field '{}'...\", executionContext.getExecutionId(), fieldTypeInfo.getPath()); FieldValueInfo fieldValueInfo = completeValue(executionContext, newParameters); CompletableFuture<ExecutionResult> executionResultFuture = fieldValueInfo.getFieldValue(); ctxCompleteField.onDispatched(executionResultFuture); executionResultFuture.whenComplete(ctxCompleteField::onCompleted); return fieldValueInfo; }","old_code_raw":"    protected CompletableFuture<ExecutionResult> completeField(ExecutionContext executionContext, ExecutionStrategyParameters parameters, Object fetchedValue) {\n        Field field = parameters.getField().get(0);\n        GraphQLObjectType parentType = parameters.getTypeInfo().castType(GraphQLObjectType.class);\n        GraphQLFieldDefinition fieldDef = getFieldDef(executionContext.getGraphQLSchema(), parentType, field);\n        ExecutionTypeInfo fieldTypeInfo = fieldTypeInfo(parameters, fieldDef);\n\n        Instrumentation instrumentation = executionContext.getInstrumentation();\n        InstrumentationFieldCompleteParameters instrumentationParams = new InstrumentationFieldCompleteParameters(executionContext, parameters, fieldDef, fieldTypeInfo, fetchedValue);\n        InstrumentationContext<ExecutionResult> ctxCompleteField = instrumentation.beginFieldComplete(\n                instrumentationParams\n        );\n\n        GraphqlFieldVisibility fieldVisibility = executionContext.getGraphQLSchema().getFieldVisibility();\n        Map<String, Object> argumentValues = valuesResolver.getArgumentValues(fieldVisibility, fieldDef.getArguments(), field.getArguments(), executionContext.getVariables());\n\n        NonNullableFieldValidator nonNullableFieldValidator = new NonNullableFieldValidator(executionContext, fieldTypeInfo);\n\n        ExecutionStrategyParameters newParameters = parameters.transform(builder ->\n                builder.typeInfo(fieldTypeInfo)\n                        .arguments(argumentValues)\n                        .source(fetchedValue)\n                        .nonNullFieldValidator(nonNullableFieldValidator)\n        );\n\n        log.debug(\"'{}' completing field '{}'...\", executionContext.getExecutionId(), fieldTypeInfo.getPath());\n\n        CompletableFuture<ExecutionResult> cf = completeValue(executionContext, newParameters);\n\n        ctxCompleteField.onDispatched(cf);\n        cf.whenComplete(ctxCompleteField::onCompleted);\n        return cf;\n    }\n","new_comment_raw":"@return a  FieldValueInfo","old_comment_raw":"@return an ExecutionResult","label":1,"pre_label":0,"AST_level":9,"line_counts":34,"new_code_token_num":227},{"new_code_raw":"public DateTimeFormatterBuilder appendYearOfCentury(int minDigits, int maxDigits) { return appendDecimal(DateTimeFieldType.yearOfCentury(), minDigits, maxDigits); }","old_code_raw":"    public DateTimeFormatterBuilder appendYearOfCentury(final int minDigits, final int maxDigits) {\n        return appendDecimal(iChronoUTC.yearOfCentury(), minDigits, maxDigits);\n    }\n","new_comment_raw":"@return this DateTimeFormatterBuilder","old_comment_raw":"@return this DateTimeFormatterBuilder","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":25},{"new_code_raw":"static protected String session(final String query) { return Query.arg(STR, query, STR); }","old_code_raw":"static protected String session(final String query) {\n    return Query.arg(null, query, STR);\n}","new_comment_raw":"@return corresponding session key, or empty string if none","old_comment_raw":"@return corresponding session key","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":22},{"new_code_raw":"public int getStack(int k) { int nStack = getStackSize(); return (k >= NUM && k < nStack) ? stack.get(nStack - NUM - k) : Config.NONEXIST; }","old_code_raw":"public int getStack(int k) {\n    int nStack = getStackSize();\n    return (k >= NUM && k < nStack) ? stack.get(nStack - NUM - k) : CONST.NONEXIST;\n}","new_comment_raw":"@return Sentence index or {@link Config#NONEXIST} if stack doesn't have an element at this index","old_comment_raw":"@return Sentence index or {@link CONST#NONEXIST} if stack doesn't have an element at this index","label":1,"pre_label":0,"AST_level":8,"line_counts":4,"new_code_token_num":38},{"new_code_raw":"public boolean equals(Object o) { return this == o || o instanceof CallingConvention && ordinal == ((CallingConvention) o).ordinal; }","old_code_raw":"    public boolean equals(Object o)\n    {\n        if (o == null) {\n            return false;\n        }\n\n        return ordinal == ((CallingConvention) o).ordinal;\n    }\n","new_comment_raw":"@return true if they are equal, false otherwise","old_comment_raw":"@return true if they are equal, false otherwise","label":0,"pre_label":1,"AST_level":8,"line_counts":7,"new_code_token_num":28},{"new_code_raw":"public static TimeExtractionFunction createDefault(String timeZone) { return new TimeExtractionFunction(ISO_TIME_FORMAT, null, timeZone, null); }","old_code_raw":"  public static TimeExtractionFunction createDefault() {\n    return new TimeExtractionFunction(ISO_TIME_FORMAT, null, \"UTC\", null);\n  }\n","new_comment_raw":"@return the time extraction function","old_comment_raw":"@return the time extraction function","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":23},{"new_code_raw":"private static String literalValue(RexLiteral literal) { Object value = literal.getValue2(); return String.valueOf(value); }","old_code_raw":"    private static String literalValue(RexLiteral literal) {\n      Object value = literal.getValue2();\n      StringBuilder buf = new StringBuilder();\n      buf.append(value);\n      return buf.toString();\n    }\n","new_comment_raw":"@return String representation of the literal","old_comment_raw":"@return String representation of the literal","label":0,"pre_label":1,"AST_level":5,"line_counts":5,"new_code_token_num":24},{"new_code_raw":"@Deprecated public List<WorkflowCondition> getConditions() { List<WorkflowCondition> allConds = new Vector<WorkflowCondition>(); allConds.addAll(preConditions); allConds.addAll(this.postConditions); return allConds; }","old_code_raw":"public List<WorkflowCondition> getConditions() {\n    return conditions;\n}","new_comment_raw":"@return All pre-and-post conditions.","old_comment_raw":"@return the conditions","label":1,"pre_label":0,"AST_level":8,"line_counts":7,"new_code_token_num":35},{"new_code_raw":"public ArrayList<GridView> getCurrentGridViews() { return getCurrentViews(GridView.class); }","old_code_raw":"\tpublic ArrayList<GridView> getCurrentGridViews() {\n\t\tArrayList<GridView> gridViewList = new ArrayList<GridView>();\n\t\tArrayList<View> viewList = getViews();\n\t\tfor(View view : viewList){\n\t\t\tif (view instanceof android.widget.GridView)\n\t\t\t\tgridViewList.add((GridView) view);\n\t\t}\n\t\treturn gridViewList;\n\t}\n","new_comment_raw":"@return a  List of the  GridViews contained in the current  Activity","old_comment_raw":"@return a List of the GridViews contained in the current Activity","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":15},{"new_code_raw":"synchronized SortedSet<Integer> getFileIDs() { return new TreeSet<Integer>(fileIDCounts.keySet()); }","old_code_raw":"synchronized Set<Integer> getFileIDs() {\n    return new HashSet<Integer>(fileIDCounts.keySet());\n}","new_comment_raw":"@return a copy of the set of fileIDs which are currently on the queue will be normally be used when deciding which data files can be deleted","old_comment_raw":"@return the set of fileIDs which are currently on the queue will be normally be used when deciding which data files can be deleted","label":1,"pre_label":0,"AST_level":7,"line_counts":3,"new_code_token_num":19},{"new_code_raw":"public ArrayList<ToggleButton> getCurrentToggleButtons() { return ensureArrayListOrNull(viewFetcher.getCurrentViews(ToggleButton.class)); }","old_code_raw":"\tpublic ArrayList<ToggleButton> getCurrentToggleButtons() {\n\t\tArrayList<ToggleButton> toggleButtonList = viewFetcher.getCurrentViews(ToggleButton.class);\n\t\treturn toggleButtonList;\n\t}\n","new_comment_raw":"@return a  List of the  ToggleButtons contained in the current  Activity","old_comment_raw":"@return a List of the ToggleButtons contained in the current Activity","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":19},{"new_code_raw":"protected long[] executeBatchInternal() throws SQLException { for (int i = NUM; i < connection.maxRetriesPerExecute; i++) { try { return connection.prepareAndUpdateBatch(this, batchedSql).updateCounts; } catch (NoSuchStatementException e) { resetStatement(); } } throw new RuntimeException(STR + connection.maxRetriesPerExecute + STR); }","old_code_raw":"protected int[] executeBatchInternal() throws SQLException {\n    for (int i = NUM; i < connection.maxRetriesPerExecute; i++) {\n        try {\n            Meta.ExecuteBatchResult result = connection.prepareAndUpdateBatch(this, batchedSql);\n            return result.updateCounts;\n        } catch (NoSuchStatementException e) {\n            resetStatement();\n        }\n    }\n    throw new RuntimeException(STR + connection.maxRetriesPerExecute + STR);\n}","new_comment_raw":"@return an array of long mapping to the update count per SQL command.","old_comment_raw":"@return an array of integers mapping to the update count per SQL command.","label":1,"pre_label":0,"AST_level":8,"line_counts":10,"new_code_token_num":63},{"new_code_raw":"public int getRegistryVersion() { DataChangeVersion version = new DataChangeVersion(); boolean contains = false; try { contains = registry.contains(REGISTRY_PATH, version); } catch (Exception e) { logger.error(\"Problem during trying to access remote function registry [{}]\", REGISTRY_PATH, e); } if (contains) { return version.getVersion(); } else { logger.error(\"Remote function registry [{}] is unreachable\", REGISTRY_PATH); return DataChangeVersion.NOT_AVAILABLE; } }","old_code_raw":"  public long getRegistryVersion() {\n    DataChangeVersion version = new DataChangeVersion();\n    boolean contains = false;\n    try {\n      contains = registry.contains(registry_path, version);\n    } catch (Exception e) {\n      logger.error(\"Problem during trying to access remote function registry [{}]\", registry_path, e);\n    }\n    if (contains) {\n      return version.getVersion();\n    } else {\n      logger.error(\"Remote function registry [{}] is unreachable\", registry_path);\n      return -1;\n    }\n  }\n","new_comment_raw":"@return remote function registry version if any, -1 otherwise","old_comment_raw":"@return remote function registry version if any, -1 otherwise","label":0,"pre_label":1,"AST_level":7,"line_counts":16,"new_code_token_num":97},{"new_code_raw":"public static String optimizeImage(Context context, String path) { if (context == null || TextUtils.isEmpty(path)) { return path; } File file = new File(path); if (!file.exists()) { return path; } String mimeType = MediaUtils.getMediaFileMimeType(file); if (mimeType.equals(STR)) { return path; } Uri imageUri = Uri.parse(path); if (imageUri == null) { return path; } String fileName = MediaUtils.getMediaFileName(file, mimeType); String fileExtension = MimeTypeMap.getFileExtensionFromUrl(fileName).toLowerCase(); int[] dimensions = getImageSize(imageUri, context); int selectedWidth = dimensions[NUM]; final int maxImageWidth = NUM; if (selectedWidth > maxImageWidth) { selectedWidth = maxImageWidth; } int orientation = getImageOrientation(context, path); File resizedImageFile; FileOutputStream out; try { resizedImageFile = File.createTempFile(STR, STR + fileExtension); out = new FileOutputStream(resizedImageFile); } catch (IOException e) { AppLog.e(AppLog.T.MEDIA, STR); return path; } catch (SecurityException e) { AppLog.e(AppLog.T.MEDIA, STR); return path; } try { boolean res = resizeImageAndWriteToStream(context, imageUri, fileExtension, selectedWidth, orientation, NUM, out); if (!res) { AppLog.w(AppLog.T.MEDIA, STR); return path; } } catch (IOException e) { AppLog.e(AppLog.T.MEDIA, STR); return path; } catch (OutOfMemoryError e) { AppLog.e(AppLog.T.MEDIA, STR); return path; } finally { try { out.flush(); out.close(); } catch (IOException e) { } } String tempFilePath = resizedImageFile.getPath(); if (!TextUtils.isEmpty(tempFilePath)) { return tempFilePath; } else { AppLog.e(AppLog.T.MEDIA, STR); } return path; }","old_code_raw":"public static String optimizeImage(Context context, String path) {\n    File file = new File(path);\n    if (!file.exists()) {\n        return path;\n    }\n    String mimeType = MediaUtils.getMediaFileMimeType(file);\n    if (mimeType.equals(STR)) {\n        return path;\n    }\n    String fileName = MediaUtils.getMediaFileName(file, mimeType);\n    String fileExtension = MimeTypeMap.getFileExtensionFromUrl(fileName).toLowerCase();\n    int[] dimensions = getImageSize(Uri.fromFile(file), context);\n    int orientation = getImageOrientation(context, path);\n    Uri imageUri = Uri.parse(path);\n    if (context == null || imageUri == null) {\n        return path;\n    }\n    File resizedImageFile;\n    FileOutputStream out;\n    try {\n        resizedImageFile = File.createTempFile(STR, STR + fileExtension);\n        out = new FileOutputStream(resizedImageFile);\n    } catch (IOException e) {\n        AppLog.e(AppLog.T.MEDIA, STR);\n        return path;\n    } catch (SecurityException e) {\n        AppLog.e(AppLog.T.MEDIA, STR);\n        return path;\n    }\n    try {\n        boolean res = resizeImageAndWriteToStream(context, imageUri, fileExtension, dimensions[NUM], orientation, NUM, out);\n        if (!res) {\n            AppLog.w(AppLog.T.MEDIA, STR);\n            return path;\n        }\n    } catch (IOException e) {\n        AppLog.e(AppLog.T.MEDIA, STR);\n        return path;\n    } catch (OutOfMemoryError e) {\n        AppLog.e(AppLog.T.MEDIA, STR);\n        return path;\n    } finally {\n        try {\n            out.flush();\n            out.close();\n        } catch (IOException e) {\n        }\n    }\n    String tempFilePath = resizedImageFile.getPath();\n    if (!TextUtils.isEmpty(tempFilePath)) {\n        return tempFilePath;\n    } else {\n        AppLog.e(AppLog.T.MEDIA, STR);\n    }\n    return path;\n}","new_comment_raw":"@return the path to the optimized image","old_comment_raw":"@return the path to the optmized image","label":1,"pre_label":0,"AST_level":8,"line_counts":64,"new_code_token_num":362},{"new_code_raw":"public T setDecodeAllFrames(boolean decodeAllFrames) { mDecodeAllFrames = decodeAllFrames; return getThis(); }","old_code_raw":"  public ImageDecodeOptionsBuilder setDecodeAllFrames(boolean decodeAllFrames) {\n    mDecodeAllFrames = decodeAllFrames;\n    return this;\n  }\n","new_comment_raw":"@return this builder","old_comment_raw":"@return this builder","label":0,"pre_label":1,"AST_level":5,"line_counts":5,"new_code_token_num":17},{"new_code_raw":"public int getJdbcId() { return jdbcId; }","old_code_raw":"    public int getJdbcId() {\n        return jdbc;\n    }\n","new_comment_raw":"@return JDBC id of the type as reported by JDBC metadata","old_comment_raw":"@return JDBC id of the type as reported by JDBC metadata","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"public PeriodType withMonthsRemoved() { return withFieldRemoved(1, \"NoMonths\"); }","old_code_raw":"    public PeriodType withMonthsRemoved() {\n        if (!months().isSupported()) {\n            return this;\n        }\n        return MaskedType.mask(this, 1 << 1);\n    }\n","new_comment_raw":"@return a new period type that supports the original set of fields except months","old_comment_raw":"@return a new period type that supports the original set of fields except months","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":17},{"new_code_raw":"public static long asLong(byte[] bytes) { return asLong(bytes, 0); }","old_code_raw":"\tpublic static long asLong(byte[] bytes) {\n\t\tif ( bytes == null ) {\n\t\t\treturn 0;\n\t\t}\n\t\tif ( bytes.length != 8 ) {\n\t\t\tthrow new IllegalArgumentException( \"Expecting 8 byte values to construct a long\" );\n\t\t}\n\t\tlong value = 0;\n\t\tfor (int i=0; i<8; i++) {\n\t\t\tvalue = (value << 8) | (bytes[i] & 0xff);\n\t\t}\n\t\treturn value;\n\t}\n","new_comment_raw":"@return The long","old_comment_raw":"@return The long","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"protected String fillAliasInSelectClause(StringBuilder sb) { final List<String> aliases = new LinkedList<String>(); final int startPos = shallowIndexOf( sb, SELECT_WITH_SPACE, 0 ); int endPos = shallowIndexOfWord( sb, FROM, startPos ); int nextComa = startPos; int prevComa = startPos; int unique = 0; boolean selectsMultipleColumns = false; while ( nextComa != -1 ) { prevComa = nextComa; nextComa = shallowIndexOf( sb, \",\", nextComa ); if ( nextComa > endPos ) { break; } if ( nextComa != -1 ) { String expression = sb.substring( prevComa, nextComa ); if ( selectsMultipleColumns( expression ) ) { selectsMultipleColumns = true; } else { String alias = getAlias( expression ); if ( alias == null ) { \/\/ Inserting alias. It is unlikely that we would have to add alias, but just in case. alias = StringHelper.generateAlias( \"page\", unique ); sb.insert( nextComa, \" as \" + alias ); ++unique; nextComa += ( \" as \" + alias ).length(); } aliases.add( alias ); } ++nextComa; } } \/\/ Processing last column. endPos = shallowIndexOfWord( sb, FROM, startPos ); \/\/ Refreshing end position, because we might have inserted new alias. String expression = sb.substring( prevComa, endPos ); if ( selectsMultipleColumns( expression ) ) { selectsMultipleColumns = true; } else { String alias = getAlias( expression ); if ( alias == null ) { \/\/ Inserting alias. It is unlikely that we would have to add alias, but just in case. alias = StringHelper.generateAlias( \"page\", unique ); sb.insert( endPos - 1, \" as \" + alias ); } aliases.add( alias ); } \/\/ In case of '*' or '{table}.*' expressions adding an alias breaks SQL syntax, returning '*'. return selectsMultipleColumns ? \"*\" : StringHelper.join( \", \", aliases.iterator() ); }","old_code_raw":"\tprotected String fillAliasInSelectClause(StringBuilder sb) {\n\t\tfinal List<String> aliases = new LinkedList<String>();\n\t\tfinal int startPos = shallowIndexOf( sb, SELECT_WITH_SPACE, 0 );\n\t\tint endPos = shallowIndexOfWord( sb, FROM, startPos );\n\t\tint nextComa = startPos;\n\t\tint prevComa = startPos;\n\t\tint unique = 0;\n\n\t\twhile ( nextComa != -1 ) {\n\t\t\tprevComa = nextComa;\n\t\t\tnextComa = shallowIndexOf( sb, \",\", nextComa );\n\t\t\tif ( nextComa > endPos ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( nextComa != -1 ) {\n\t\t\t\tString expression = sb.substring( prevComa, nextComa );\n\t\t\t\tString alias = getAlias( expression );\n\t\t\t\tif ( alias == null ) {\n\t\t\t\t\t\/\/ Inserting alias. It is unlikely that we would have to add alias, but just in case.\n\t\t\t\t\talias = StringHelper.generateAlias( \"page\", unique );\n\t\t\t\t\tsb.insert( nextComa, \" as \" + alias );\n\t\t\t\t\t++unique;\n\t\t\t\t\tnextComa += ( \" as \" + alias ).length();\n\t\t\t\t}\n\t\t\t\taliases.add( alias );\n\t\t\t\t++nextComa;\n\t\t\t}\n\t\t}\n\t\t\/\/ Processing last column.\n\t\tendPos = shallowIndexOfWord( sb, FROM, startPos ); \/\/ Refreshing end position, because we might have inserted new alias.\n\t\tString expression = sb.substring( prevComa, endPos );\n\t\tString alias = getAlias( expression );\n\t\tif ( alias == null ) {\n\t\t\t\/\/ Inserting alias. It is unlikely that we would have to add alias, but just in case.\n\t\t\talias = StringHelper.generateAlias( \"page\", unique );\n\t\t\tsb.insert( endPos - 1, \" as \" + alias );\n\t\t}\n\t\taliases.add( alias );\n\n\t\treturn StringHelper.join( \", \", aliases.iterator() );\n\t}\n","new_comment_raw":"@return List of aliases separated with comas or @literal .","old_comment_raw":"@return List of aliases separated with comas.","label":1,"pre_label":0,"AST_level":14,"line_counts":54,"new_code_token_num":372},{"new_code_raw":"protected TheInnerClass newTheInnerClass( ) { return this.injectMembers(new TheInnerClass()); }","old_code_raw":"  protected TheInnerClass newTheInnerClass( ) {\n    return new TheInnerClass();\n  }\n","new_comment_raw":"@return an instance of the inner class, at runtime the generated subclass (or replacement) of the template inner class","old_comment_raw":"@return an instance of the inner class, at runtime the generated subclass (or replacement) of the template inner class","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":17},{"new_code_raw":"public AvaticaHandler getHandler(Service service, Driver.Serialization serialization) { return getHandler(service, serialization, NoopMetricsSystemConfiguration.getInstance()); }","old_code_raw":"  public Handler getHandler(Service service, Driver.Serialization serialization) {\n    return getHandler(service, serialization, NoopMetricsSystemConfiguration.getInstance());\n  }\n","new_comment_raw":"@return The  AvaticaHandler.","old_comment_raw":"@return The Handler.","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":26},{"new_code_raw":"private List<WorkerInfo> checkWorkers() { boolean failJob = true; int pollAttempt = NUM; List<WorkerInfo> healthyWorkerInfoList = new ArrayList<WorkerInfo>(); List<WorkerInfo> unhealthyWorkerInfoList = new ArrayList<WorkerInfo>(); int totalResponses = -NUM; while (pollAttempt < maxPollAttempts) { getAllWorkerInfos(getSuperstep(), healthyWorkerInfoList, unhealthyWorkerInfoList); totalResponses = healthyWorkerInfoList.size() + unhealthyWorkerInfoList.size(); if ((totalResponses * NUM \/ maxWorkers) >= minPercentResponded) { failJob = false; break; } getContext().setStatus(getGraphMapper().getMapFunctions() + STR + STR + totalResponses + STR + maxWorkers + STR + getSuperstep()); if (getWorkerHealthRegistrationChangedEvent().waitMsecs(msecsPollPeriod)) { if (LOG.isDebugEnabled()) { LOG.debug(STR + STR); } getWorkerHealthRegistrationChangedEvent().reset(); continue; } if (LOG.isInfoEnabled()) { LOG.info(STR + totalResponses + STR + maxWorkers + STR + getSuperstep() + STR + msecsPollPeriod + STR + pollAttempt + STR + maxPollAttempts + STR); if ((maxWorkers - totalResponses) <= partitionLongTailMinPrint) { Set<Integer> partitionSet = new TreeSet<Integer>(); for (WorkerInfo workerInfo : healthyWorkerInfoList) { partitionSet.add(workerInfo.getPartitionId()); } for (WorkerInfo workerInfo : unhealthyWorkerInfoList) { partitionSet.add(workerInfo.getPartitionId()); } for (int i = NUM; i <= maxWorkers; ++i) { if (partitionSet.contains(new Integer(i))) { continue; } else if (i == getTaskPartition()) { continue; } else { LOG.info(STR + STR + i + STR); } } } } ++pollAttempt; } if (failJob) { LOG.error(STR + STR + totalResponses + STR + minWorkers + STR + STR + STR + STR); return null; } if (healthyWorkerInfoList.size() < minWorkers) { LOG.error(STR + healthyWorkerInfoList.size() + STR + minWorkers + STR); return null; } return healthyWorkerInfoList; }","old_code_raw":"private Map<String, JSONArray> checkWorkers() {\n    boolean failJob = true;\n    int pollAttempt = NUM;\n    List<String> healthyWorkerList = new ArrayList<String>();\n    List<String> unhealthyWorkerList = new ArrayList<String>();\n    int totalResponses = -NUM;\n    while (pollAttempt < maxPollAttempts) {\n        getWorkers(getSuperstep(), healthyWorkerList, unhealthyWorkerList);\n        totalResponses = healthyWorkerList.size() + unhealthyWorkerList.size();\n        if ((totalResponses * NUM \/ maxWorkers) >= minPercentResponded) {\n            failJob = false;\n            break;\n        }\n        getContext().setStatus(getGraphMapper().getMapFunctions() + STR + STR + totalResponses + STR + maxWorkers + STR + getSuperstep());\n        if (getWorkerHealthRegistrationChangedEvent().waitMsecs(msecsPollPeriod)) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(STR + STR);\n            }\n            getWorkerHealthRegistrationChangedEvent().reset();\n            continue;\n        }\n        if (LOG.isInfoEnabled()) {\n            LOG.info(STR + totalResponses + STR + maxWorkers + STR + getSuperstep() + STR + msecsPollPeriod + STR + pollAttempt + STR + maxPollAttempts + STR);\n            if ((maxWorkers - totalResponses) <= partitionLongTailMinPrint) {\n                Set<Integer> partitionSet = new TreeSet<Integer>();\n                for (String hostnamePartitionId : healthyWorkerList) {\n                    int lastIndex = hostnamePartitionId.lastIndexOf(STR);\n                    Integer partition = Integer.parseInt(hostnamePartitionId.substring(lastIndex + NUM));\n                    partitionSet.add(partition);\n                }\n                for (String hostnamePartitionId : unhealthyWorkerList) {\n                    int lastIndex = hostnamePartitionId.lastIndexOf(STR);\n                    Integer partition = Integer.parseInt(hostnamePartitionId.substring(lastIndex + NUM));\n                    partitionSet.add(partition);\n                }\n                for (int i = NUM; i <= maxWorkers; ++i) {\n                    if (partitionSet.contains(new Integer(i))) {\n                        continue;\n                    } else if (i == getTaskPartition()) {\n                        continue;\n                    } else {\n                        LOG.info(STR + STR + i + STR);\n                    }\n                }\n            }\n        }\n        ++pollAttempt;\n    }\n    if (failJob) {\n        LOG.error(STR + STR + totalResponses + STR + minWorkers + STR + STR + STR + STR);\n        return null;\n    }\n    if (healthyWorkerList.size() < minWorkers) {\n        LOG.error(STR + healthyWorkerList.size() + STR + minWorkers + STR);\n        return null;\n    }\n    Map<String, JSONArray> workerHostnamePortMap = new HashMap<String, JSONArray>();\n    for (String healthyWorker : healthyWorkerList) {\n        String healthyWorkerPath = null;\n        try {\n            healthyWorkerPath = getWorkerHealthyPath(getApplicationAttempt(), getSuperstep()) + STR + healthyWorker;\n            JSONArray hostnamePortArray = new JSONArray(new String(getZkExt().getData(healthyWorkerPath, false, null)));\n            workerHostnamePortMap.put(healthyWorker, hostnamePortArray);\n        } catch (JSONException e) {\n            throw new RuntimeException(STR + healthyWorker + STR + healthyWorkerPath);\n        } catch (KeeperException e) {\n            throw new IllegalStateException(STR, e);\n        } catch (InterruptedException e) {\n            throw new IllegalStateException(STR, e);\n        }\n    }\n    return workerHostnamePortMap;\n}","new_comment_raw":"@return List of of healthy workers","old_comment_raw":"@return map of healthy worker list to JSONArray(hostname, port)","label":1,"pre_label":0,"AST_level":21,"line_counts":54,"new_code_token_num":376},{"new_code_raw":"public static SlidrInterface attach(final Activity activity, final int statusBarColor1, final int statusBarColor2) { ViewGroup decorView = (ViewGroup) activity.getWindow().getDecorView(); View oldScreen = decorView.getChildAt(NUM); decorView.removeViewAt(NUM); final SliderPanel panel = new SliderPanel(activity, oldScreen); panel.setId(R.id.slidable_panel); panel.addView(oldScreen); decorView.addView(panel, NUM); panel.setOnPanelSlideListener(new SliderPanel.OnPanelSlideListener() { private final ArgbEvaluator mEvaluator = new ArgbEvaluator(); @Override public void onClosed() { activity.finish(); activity.overridePendingTransition(NUM, NUM); } @Override public void onOpened() { } @Override public void onSlideChange(float percent) { if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) { int newColor = (int) mEvaluator.evaluate(percent, statusBarColor1, statusBarColor2); activity.getWindow().setStatusBarColor(newColor); } } }); SlidrInterface slidrInterface = new SlidrInterface() { @Override public void lock() { panel.lock(); } @Override public void unlock() { panel.unlock(); } }; return slidrInterface; }","old_code_raw":"public static SlideLockInterface attach(final Activity activity) {\n    ViewGroup decorView = (ViewGroup) activity.getWindow().getDecorView();\n    View oldScreen = decorView.getChildAt(NUM);\n    decorView.removeViewAt(NUM);\n    final SliderPanel panel = new SliderPanel(activity, oldScreen);\n    panel.setId(R.id.slidable_panel);\n    panel.addView(oldScreen);\n    decorView.addView(panel, NUM);\n    panel.setOnPanelSlideListener(new SliderPanel.OnPanelSlideListener() {\n\n        @Override\n        public void onClosed() {\n            activity.finish();\n            activity.overridePendingTransition(NUM, NUM);\n        }\n\n        @Override\n        public void onOpened() {\n        }\n    });\n    SlideLockInterface lockInterface = new SlideLockInterface() {\n\n        @Override\n        public void lock() {\n            panel.lock();\n        }\n\n        @Override\n        public void unlock() {\n            panel.unlock();\n        }\n    };\n    return lockInterface;\n}","new_comment_raw":"@return a {@link com.r0adkll.slidr.SlidrInterface} that allows the user to lock\/unlock the sliding mechanism for whatever purpose.","old_comment_raw":"@return a {@link com.r0adkll.slidableactivity.SlideLockInterface} that allows the user to lock\/unlock the sliding mechanism for whatever purpose.","label":1,"pre_label":0,"AST_level":13,"line_counts":44,"new_code_token_num":217},{"new_code_raw":"public Future<HttpResponse> executeAsync(Executor executor) { FutureTask<HttpResponse> future = new FutureTask<HttpResponse>(new Callable<HttpResponse>() { public HttpResponse call() throws Exception { return execute(); } }); executor.execute(future); return future; }","old_code_raw":"public Future<HttpResponse> executeAsync(Executor exec) {\n    final SettableFuture<HttpResponse> future = SettableFuture.create();\n    exec.execute(new Runnable() {\n\n        public void run() {\n            try {\n                future.set(execute());\n            } catch (IOException ex) {\n                future.setException(ex);\n            }\n        }\n    });\n    return future;\n}","new_comment_raw":"@return future for accessing the HTTP response","old_comment_raw":"@return A future for accessing the results of the asynchronous request.","label":1,"pre_label":0,"AST_level":9,"line_counts":10,"new_code_token_num":49},{"new_code_raw":"private File[] getDirectoryHistory() { return Settings.instance().getDirectoryHistory(); }","old_code_raw":"private File[] getDirectoryHistory() {\n    File[] dirhist = Settings.instance().getDirectoryHistory();\n    if (dirhist == null || dirhist.length == NUM)\n        return new File[] { new File(STR).getAbsoluteFile() };\n    else\n        return dirhist;\n}","new_comment_raw":"@return current directory history. Should never return null.","old_comment_raw":"@return current directory history, or if empty, only current directory (as File[0]).","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":18},{"new_code_raw":"public char get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }","old_code_raw":"public char get(WithAttributes attributes) {\n    return attributes.getAttributes().get(this);\n}","new_comment_raw":"@return the value of this attribute if this attribute is present in the extracted map. Otherwise {@link #getDefaultValue()}","old_comment_raw":"@return the value of this attribute if this attribute is present in the map. Otherwise {@link #getDefaultValue()}","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":19},{"new_code_raw":"public List<EndpointAffinity> getOperatorAffinity() { return this.endpointAffinities; }","old_code_raw":"  public List<EndpointAffinity> getOperatorAffinity() {\n\n    if (this.endpointAffinities == null) {\n      BlockMapBuilder bmb = new BlockMapBuilder(fs, formatPlugin.getContext().getBits());\n      try {\n        List<TimedRunnable<Void>> blockMappers = Lists.newArrayList();\n        for (RowGroupInfo rgi : rowGroupInfos) {\n          blockMappers.add(new BlockMapper(bmb, rgi));\n        }\n        TimedRunnable.run(\"Load Parquet RowGroup block maps\", logger, blockMappers, 16);\n      } catch (IOException e) {\n        logger.warn(\"Failure while determining operator affinity.\", e);\n        return Collections.emptyList();\n      }\n\n      this.endpointAffinities = AffinityCreator.getAffinityMap(rowGroupInfos);\n    }\n    return this.endpointAffinities;\n  }\n","new_comment_raw":"@return a list of EndpointAffinity objects","old_comment_raw":"@return a list of EndpointAffinity objects","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":12},{"new_code_raw":"public static InvalidOperationBehavior parse(String value) { if (value == null) { return null; } value = value.trim(); for (InvalidOperationBehavior option : InvalidOperationBehavior.values()) { if (option.getValue().equalsIgnoreCase(value)) { return option; } } return null; }","old_code_raw":"        public static InvalidOperationBehavior parse(String value, String defaultValue) {\n            InvalidOperationBehavior mode = parse(value);\n            if (mode == null && defaultValue != null) mode = parse(defaultValue);\n            return mode;\n        }\n","new_comment_raw":"@return the matching option, or null if no match is found","old_comment_raw":"@return the matching option, or null if no match is found and the non-null default is invalid","label":1,"pre_label":0,"AST_level":8,"line_counts":13,"new_code_token_num":57},{"new_code_raw":"private synchronized static Supplier<Annotator> getOrCreate(AnnotatorFactory factory) { return () -> { Annotator rtn = customAnnotators.get(factory.signature()); if (rtn == null) { \/\/ Create the annotator rtn = factory.create(); \/\/ Register the annotator customAnnotators.put(factory.signature(), factory.create()); \/\/ Clean up memory if needed while (customAnnotators.size() > 10) { customAnnotators.keySet().iterator().remove(); } } return rtn; }; }","old_code_raw":"  private synchronized static Supplier<Annotator> getOrCreate(String name, Properties props, Supplier<Annotator> annotator) {\n    StanfordCoreNLP.AnnotatorSignature key = new StanfordCoreNLP.AnnotatorSignature(name, PropertiesUtils.getSignature(name, props));\n    customAnnotators.register(name, props, StanfordCoreNLP.GLOBAL_ANNOTATOR_CACHE.computeIfAbsent(key, (sig) -> Lazy.cache(annotator)));\n    return () -> customAnnotators.get(name);\n  }\n","new_comment_raw":"@return An annotator created by that factory.","old_comment_raw":"@return An annotator as specified by the given name and properties.","label":1,"pre_label":0,"AST_level":11,"line_counts":17,"new_code_token_num":98},{"new_code_raw":"public static ValueAnimator createValueAnimator(Drawable drawable) { if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) { return null; } if (drawable instanceof AnimatedDrawable2) { return AnimatedDrawable2ValueAnimatorHelper.createValueAnimator((AnimatedDrawable2) drawable); } return null; }","old_code_raw":"  public static ValueAnimator createValueAnimator(Drawable drawable) {\n    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {\n      return null;\n    }\n\n    if (drawable instanceof AnimatableDrawable) {\n      return ((AnimatableDrawable) drawable).createValueAnimator();\n    }\n\n    if (drawable instanceof AnimatedDrawable2) {\n      return AnimatedDrawable2ValueAnimatorHelper.createValueAnimator((AnimatedDrawable2) drawable);\n    }\n    return null;\n  }\n","new_comment_raw":"@return the animator to use","old_comment_raw":"@return the animator to use","label":0,"pre_label":1,"AST_level":8,"line_counts":11,"new_code_token_num":45},{"new_code_raw":"public Bundle getActivityLaunchOptions(Launcher launcher, View v) { if (hasControlRemoteAppTransitionPermission()) { try { RemoteAnimationRunnerCompat runner = new LauncherAnimationRunner(mLauncher) { @Override public void onAnimationStart(RemoteAnimationTargetCompat[] targets, Runnable finishedCallback) { \/\/ Post at front of queue ignoring sync barriers to make sure it gets \/\/ processed before the next frame. postAtFrontOfQueueAsynchronously(v.getHandler(), () -> { mAnimator = new AnimatorSet(); setCurrentAnimator(mAnimator); mAnimator.play(getLauncherAnimators(v)); mAnimator.play(getWindowAnimators(v, targets)); mAnimator.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { \/\/ Reset launcher to normal state v.setVisibility(View.VISIBLE); ((ViewGroup) mDragLayer.getParent()).removeView(mFloatingView); mDragLayer.setAlpha(1f); mDragLayer.setTranslationY(0f); View appsView = mLauncher.getAppsView(); appsView.setAlpha(1f); appsView.setTranslationY(0f); finishedCallback.run(); } }); mAnimator.start(); \/\/ Because t=0 has the app icon in its original spot, we can skip the \/\/ first frame and have the same movement one frame earlier. mAnimator.setCurrentPlayTime(REFRESH_RATE_MS); }); } }; return ActivityOptionsCompat.makeRemoteAnimation( new RemoteAnimationAdapterCompat(runner, 500, 380)).toBundle(); } catch (NoClassDefFoundError e) { \/\/ Gracefully fall back to default launch options if the user's platform doesn't \/\/ have the latest changes. } } return getDefaultActivityLaunchOptions(launcher, v); }","old_code_raw":"    public ActivityOptions getActivityLaunchOptions(Launcher launcher, View v) {\n        if (hasControlRemoteAppTransitionPermission()) {\n            try {\n                RemoteAnimationRunnerCompat runner = new LauncherAnimationRunner(mHandler) {\n\n                    @Override\n                    public AnimatorSet getAnimator(RemoteAnimationTargetCompat[] targetCompats) {\n                        AnimatorSet anim = new AnimatorSet();\n\n\n                        if (!composeRecentsLaunchAnimator(v, targetCompats, anim)) {\n                            \/\/ Set the state animation first so that any state listeners are called\n                            \/\/ before our internal listeners.\n                            mLauncher.getStateManager().setCurrentAnimation(anim);\n\n                            anim.play(getIconAnimator(v));\n                            if (launcherIsATargetWithMode(targetCompats, MODE_CLOSING)) {\n                                anim.play(getLauncherContentAnimator(false \/* show *\/));\n                            }\n                            anim.play(getWindowAnimators(v, targetCompats));\n                        }\n                        return anim;\n                    }\n                };\n\n                int duration = findTaskViewToLaunch(launcher, v, null) != null\n                        ? RECENTS_LAUNCH_DURATION : APP_LAUNCH_DURATION;\n                int statusBarTransitionDelay = duration - STATUS_BAR_TRANSITION_DURATION;\n                return ActivityOptionsCompat.makeRemoteAnimation(new RemoteAnimationAdapterCompat(\n                        runner, duration, statusBarTransitionDelay));\n            } catch (NoClassDefFoundError e) {\n                \/\/ Gracefully fall back to default launch options if the user's platform doesn't\n                \/\/ have the latest changes.\n            }\n        }\n        return getDefaultActivityLaunchOptions(launcher, v);\n    }\n","new_comment_raw":"@return A Bundle with remote animations that controls how the window of the opening targets are displayed.","old_comment_raw":"@return ActivityOptions with remote animations that controls how the window of the opening targets are displayed.","label":1,"pre_label":0,"AST_level":19,"line_counts":49,"new_code_token_num":300},{"new_code_raw":"protected Object convertYearToInt(Column column, Field fieldDefn, Object data) { return convertValue(column, fieldDefn, data, 0, (r) -> { Object mutData = data; if (data instanceof java.time.Year) { \/\/ The MySQL binlog always returns a Year object ... r.deliver(adjustYear(((java.time.Year) data).getValue())); } else if (data instanceof java.sql.Date) { \/\/ MySQL JDBC driver sometimes returns a Java SQL Date object ... r.deliver(adjustYear(((java.sql.Date) data).getYear())); } else if (data instanceof String) { mutData = Integer.parseInt((String) data); } if (mutData instanceof Number) { \/\/ MySQL JDBC driver sometimes returns a short ... r.deliver(adjustYear(((Number) mutData).intValue())); } }); }","old_code_raw":"    protected Object convertYearToInt(Column column, Field fieldDefn, Object data) {\n        if (data == null && !fieldDefn.schema().isOptional()) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return 0;\n        }\n        if (data instanceof java.time.Year) {\n            \/\/ The MySQL binlog always returns a Year object ...\n            return adjustYear(((java.time.Year) data).getValue());\n        }\n        if (data instanceof java.sql.Date) {\n            \/\/ MySQL JDBC driver sometimes returns a Java SQL Date object ...\n            return adjustYear(((java.sql.Date) data).getYear());\n        }\n        if (data instanceof String) {\n            data = Integer.parseInt((String) data);\n        }\n        if (data instanceof Number) {\n            \/\/ MySQL JDBC driver sometimes returns a short ...\n            return adjustYear(((Number) data).intValue());\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","label":0,"pre_label":1,"AST_level":15,"line_counts":21,"new_code_token_num":172},{"new_code_raw":"public Dictionary getProperties() { return m_properties; }","old_code_raw":"public Properties getProperties() {\n    return m_properties;\n}","new_comment_raw":"@return the properties as a Dictionary","old_comment_raw":"@return the property descriptors as a Collection","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":10},{"new_code_raw":"public int getSize() { return (srcAdapter.getSize() == 0) ? 0 :Integer.MAX_VALUE; }","old_code_raw":"        public int getSize() {\n          return Integer.MAX_VALUE;\n        }\n","new_comment_raw":"@return The infinite version of this SimpleAdapter","old_comment_raw":"@return The infinite version of this SimpleAdapter","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":21},{"new_code_raw":"static Stream<Arguments> prepareParameters(final IntBinaryOperator resultCalc) { final List<Arguments> testData = new ArrayList<>(); for (int i = -NUM; i < NUM; i++) { for (int j = -NUM; j < NUM; j++) { testData.add(Arguments.of(new NumberExpression(i), new NumberExpression(j), resultCalc.applyAsInt(i, j))); } } return testData.stream(); }","old_code_raw":"static List<Object[]> prepareParameters(final IntBinaryOperator resultCalc) {\n    final List<Object[]> testData = new ArrayList<>();\n    for (int i = -NUM; i < NUM; i++) {\n        for (int j = -NUM; j < NUM; j++) {\n            testData.add(new Object[] { new NumberExpression(i), new NumberExpression(j), resultCalc.applyAsInt(i, j) });\n        }\n    }\n    return testData;\n}","new_comment_raw":"@return A stream with test entries","old_comment_raw":"@return A data set with test entries","label":1,"pre_label":0,"AST_level":11,"line_counts":9,"new_code_token_num":86},{"new_code_raw":"public Action doCometSupport(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException { req.setAttribute(BROADCASTER_FACTORY, broadcasterFactory); req.setAttribute(PROPERTY_USE_STREAM, useStreamForFlushingComments); req.setAttribute(BROADCASTER_CLASS, broadcasterClassName); req.setAttribute(SUPPORT_TRACKABLE, config.getInitParameter(SUPPORT_TRACKABLE)); try { if (config.getInitParameter(ALLOW_QUERYSTRING_AS_HEADER) != null) { return cometSupport.service(new AtmosphereRequest.Builder().headers(configureHeader(req)).request(req).build(), res); } else { return cometSupport.service(req, res); } } catch (IllegalStateException ex) { logger.warn(ex.getMessage(), ex); if (ex.getMessage() != null && ex.getMessage().startsWith(\"Tomcat failed\")) { if (!isFilter) { logger.warn(\"Failed using comet support: {}, error: {}\", cometSupport.getClass().getName(), ex.getMessage()); logger.warn(\"Using BlockingIOCometSupport.\"); } cometSupport = new BlockingIOCometSupport(config); service(req, res); } else { logger.error(\"AtmosphereServlet exception\", ex); throw ex; } } return null; }","old_code_raw":"    public Action doCometSupport(HttpServletRequest req, HttpServletResponse res)\n            throws IOException, ServletException {\n        req.setAttribute(BROADCASTER_FACTORY, broadcasterFactory);\n        req.setAttribute(PROPERTY_USE_STREAM, useStreamForFlushingComments);\n        req.setAttribute(BROADCASTER_CLASS, broadcasterClassName);\n        req.setAttribute(SUPPORT_TRACKABLE, config.getInitParameter(SUPPORT_TRACKABLE));\n\n        try {\n            return cometSupport.service(req, res);\n        } catch (IllegalStateException ex) {\n            logger.warn(ex.getMessage(), ex);\n            if (ex.getMessage() != null && ex.getMessage().startsWith(\"Tomcat failed\")) {\n                if (!isFilter) {\n                    logger.warn(\"Failed using comet support: {}, error: {}\", cometSupport.getClass().getName(),\n                            ex.getMessage());\n                    logger.warn(\"Using BlockingIOCometSupport.\");\n                }\n\n                cometSupport = new BlockingIOCometSupport(config);\n                service(req, res);\n            } else {\n                logger.error(\"AtmosphereServlet exception\", ex);\n                throw ex;\n            }\n        }\n        return null;\n    }\n","new_comment_raw":"@return an  Action","old_comment_raw":"@return an Action","label":0,"pre_label":1,"AST_level":12,"line_counts":32,"new_code_token_num":230},{"new_code_raw":"public static boolean supportsRefCursors(DatabaseMetaData meta) { \/\/ Standard JDBC REF_CURSOR support was not added until Java 8, so we need to use reflection to attempt to \/\/ access these fields\/methods... try { return (Boolean) meta.getClass().getMethod( \"supportsRefCursors\" ).invoke( null ); } catch (NoSuchMethodException e) { log.trace( \"JDBC DatabaseMetaData class does not define supportsRefCursors method...\" ); } catch (Exception e) { log.debug( \"Unexpected error trying to gauge level of JDBC REF_CURSOR support : \" + e.getMessage() ); } return false; }","old_code_raw":"\tpublic static boolean supportsRefCursors(DatabaseMetaData meta) {\n\t\t\/\/ Standard JDBC REF_CURSOR support was not added until Java 8, so we need to use reflection to attempt to\n\t\t\/\/ access these fields\/methods...\n\t\ttry {\n\t\t\treturn ( (Boolean) meta.getClass().getMethod( \"supportsRefCursors\" ).invoke( null ) ).booleanValue();\n\t\t}\n\t\tcatch (NoSuchMethodException e) {\n\t\t\tlog.trace( \"JDBC DatabaseMetaData class does not define supportsRefCursors method...\" );\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tlog.debug( \"Unexpected error trying to gauge level of JDBC REF_CURSOR support : \" + e.getMessage() );\n\t\t}\n\t\treturn false;\n\t}\n","new_comment_raw":"@return  true if the metadata indicates that the driver defines REF_CURSOR support","old_comment_raw":"@return true if the metadata indicates that the driver defines REF_CURSOR support","label":0,"pre_label":1,"AST_level":8,"line_counts":15,"new_code_token_num":116},{"new_code_raw":"protected Object convertDouble(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0.0d; } if (data instanceof Double) return data; if (data instanceof Number) { Number value = (Number) data; return new Double(value.doubleValue()); } if (data instanceof Boolean) { return ((Boolean) data).booleanValue() ? DOUBLE_TRUE : DOUBLE_FALSE; } return handleUnknownData(column, fieldDefn, data); }","old_code_raw":"    protected Object convertDouble(Column column, Field fieldDefn, Object data) {\n        if (data == null) return null;\n        if (data instanceof Double) return data;\n        if (data instanceof Number) {\n            Number value = (Number) data;\n            return new Double(value.doubleValue());\n        }\n        if (data instanceof Boolean) {\n            return ((Boolean) data).booleanValue() ? DOUBLE_TRUE : DOUBLE_FALSE;\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made","label":1,"pre_label":0,"AST_level":8,"line_counts":19,"new_code_token_num":119},{"new_code_raw":"public ResultSetMetaData getMetaData() throws SQLException { try { debugCodeCall(STR); checkClosed(); ResultInterface result = command.getMetaData(); if (result == null) { return null; } int id = getNextId(TraceObject.RESULT_SET_META_DATA); if (debug()) { debugCodeAssign(STR, TraceObject.RESULT_SET_META_DATA, id); debugCodeCall(STR); } JdbcResultSetMetaData meta = new JdbcResultSetMetaData(null, this, result, session.getTrace(), id); return meta; } catch (Throwable e) { throw logAndConvert(e); } }","old_code_raw":"public ResultSetMetaData getMetaData() throws SQLException {\n    try {\n        debugCodeCall(STR);\n        checkClosed();\n        return null;\n    } catch (Throwable e) {\n        throw logAndConvert(e);\n    }\n}","new_comment_raw":"@return the meta data or null if this is not a query","old_comment_raw":"@return null as the method is not supported","label":1,"pre_label":0,"AST_level":8,"line_counts":19,"new_code_token_num":104},{"new_code_raw":"public Q addFetchGroup(String fetchGroupName) { fetchGroups.add(fetchGroupName); return queryMixin.getSelf(); }","old_code_raw":"    public Q addFetchGroup(String fetchGroupName) {\n        fetchGroups.add(fetchGroupName);\n        return (Q) this;\n    }\n","new_comment_raw":"@return the current object","old_comment_raw":"@return the current object","label":0,"pre_label":1,"AST_level":5,"line_counts":5,"new_code_token_num":21},{"new_code_raw":"@Deprecated public long getNumBytesUploaded() { return totalBytesServerReceived; }","old_code_raw":"public long getNumBytesUploaded() {\n    return bytesUploaded;\n}","new_comment_raw":"@return the number of bytes the server received so far","old_comment_raw":"@return the number of bytes uploaded","label":1,"pre_label":0,"AST_level":4,"line_counts":4,"new_code_token_num":12},{"new_code_raw":"protected Iterator<JobLocation> getAllScheduledJobs(Transaction tx) throws IOException { return new Iterator<JobLocation>() { final Iterator<Map.Entry<Long, List<JobLocation>>> mapIterator = index.iterator(tx); Iterator<JobLocation> iterator; @Override public boolean hasNext() { while (iterator == null || !iterator.hasNext()) { if (!mapIterator.hasNext()) { break; } iterator = new ArrayList<>(mapIterator.next().getValue()).iterator(); } return iterator != null && iterator.hasNext(); } @Override public JobLocation next() { return iterator.next(); } }; }","old_code_raw":"    protected List<JobLocation> getAllScheduledJobs(Transaction tx) throws IOException {\n        List<JobLocation> references = new ArrayList<>();\n\n        for (Iterator<Map.Entry<Long, List<JobLocation>>> i = this.index.iterator(tx); i.hasNext();) {\n            Map.Entry<Long, List<JobLocation>> entry = i.next();\n            List<JobLocation> scheduled = entry.getValue();\n            for (JobLocation job : scheduled) {\n                references.add(job);\n            }\n        }\n\n        return references;\n    }\n","new_comment_raw":"@return a iterator of all referenced Location values for this JobSchedulerImpl","old_comment_raw":"@return a list of all referenced Location values for this JobSchedulerImpl","label":1,"pre_label":0,"AST_level":13,"line_counts":27,"new_code_token_num":117},{"new_code_raw":"public static SchemaGenSource interpret(String value) { if ( StringHelper.isEmpty( value ) ) { \/\/ empty is in fact valid as means to interpret default value based on other settings return null; } if ( METADATA.externalName.equals( value ) ) { return METADATA; } else if ( SCRIPT.externalName.equals( value ) ) { return SCRIPT; } else if ( METADATA_THEN_SCRIPT.externalName.equals( value ) ) { return METADATA_THEN_SCRIPT; } else if ( SCRIPT_THEN_METADATA.externalName.equals( value ) ) { return SCRIPT_THEN_METADATA; } throw new IllegalArgumentException( \"Unrecognized schema generation source value : \" + value ); }","old_code_raw":"\tpublic static SchemaGenSource interpret(String value) {\n\t\tif ( StringHelper.isEmpty( value ) ) {\n\t\t\t\/\/ empty is in fact valid as means to interpret default value based on other settings\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( METADATA.externalName.equals( value ) ) {\n\t\t\treturn METADATA;\n\t\t}\n\t\telse if ( SCRIPTS.externalName.equals( value ) ) {\n\t\t\treturn SCRIPTS;\n\t\t}\n\t\telse if ( METADATA_THEN_SCRIPTS.externalName.equals( value ) ) {\n\t\t\treturn METADATA_THEN_SCRIPTS;\n\t\t}\n\t\telse if ( SCRIPTS_THEN_METADATA.externalName.equals( value ) ) {\n\t\t\treturn SCRIPTS_THEN_METADATA;\n\t\t}\n\n\t\tthrow new IllegalArgumentException( \"Unrecognized schema generation source value : \" + value );\n\t}\n","new_comment_raw":"@return The matching enum value. An empty value will return  null.","old_comment_raw":"@return The matching enum value. An empty value will return null.","label":0,"pre_label":1,"AST_level":9,"line_counts":22,"new_code_token_num":115},{"new_code_raw":"public static LoopBound calculateWCA(String wcaA) throws BadAnnotationException { int ai = wcaA.indexOf(STR); if (ai != -NUM) { String annotString = wcaA.substring(ai + STR.length()); if (annotString.indexOf(STR) < NUM) return null; Pattern pattern1 = Pattern.compile(STR); Pattern pattern2 = Pattern.compile(STR); Matcher matcher1 = pattern1.matcher(annotString); if (matcher1.matches()) { int ub = Integer.parseInt(matcher1.group(NUM)); int lb = (matcher1.group(NUM).equals(STR)) ? ub : NUM; return new LoopBound(lb, ub); } Matcher matcher2 = pattern2.matcher(annotString); if (matcher2.matches()) { int lb = Integer.parseInt(matcher2.group(NUM)); int ub = Integer.parseInt(matcher2.group(NUM)); return new LoopBound(lb, ub); } throw new BadAnnotationException(STR + annotString); } return null; }","old_code_raw":"public static int calculateWCA(String wcaA) {\n    int ai = wcaA.indexOf(STR);\n    if (ai != -NUM) {\n        String c = wcaA.substring(ai + STR.length());\n        Pattern pattern = Pattern.compile(STR);\n        Matcher matcher = pattern.matcher(c);\n        if (!matcher.matches()) {\n            logger.error(STR + c + STR);\n            return -NUM;\n        }\n        int val = Integer.parseInt(matcher.group(NUM));\n        return val;\n    }\n    return -NUM;\n}","new_comment_raw":"@return the loop bound limit or null if no annotation was found","old_comment_raw":"@return the loop bound limit or -1 if no annotation was found or the annotation was erroneous","label":1,"pre_label":0,"AST_level":11,"line_counts":24,"new_code_token_num":188},{"new_code_raw":"public boolean isWifiConnected(Context context) { if (context != null) { ConnectivityManager mConnectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE); if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) { Network[] networks = mConnectivityManager.getAllNetworks(); for (Network network : networks) { NetworkInfo networkInfo = mConnectivityManager.getNetworkInfo(network); if (networkInfo != null && networkInfo.getType() == ConnectivityManager.TYPE_WIFI) return networkInfo.isAvailable() && networkInfo.isConnected(); } } else { @SuppressWarnings(\"deprecation\") NetworkInfo mWiFiNetworkInfo = mConnectivityManager.getNetworkInfo(ConnectivityManager.TYPE_WIFI); return mWiFiNetworkInfo != null && mWiFiNetworkInfo.isAvailable() && mWiFiNetworkInfo.isConnected(); } } return false; }","old_code_raw":"    public boolean isWifiConnected(Context context) {\n        if (context != null) {\n            ConnectivityManager mConnectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n                Network[] networks = mConnectivityManager.getAllNetworks();\n                for (Network network : networks) {\n                    NetworkInfo networkInfo = mConnectivityManager.getNetworkInfo(network);\n                    if (networkInfo.getType() == ConnectivityManager.TYPE_WIFI)\n                        return networkInfo.isAvailable() && networkInfo.isConnected();\n                }\n            } else {\n                @SuppressWarnings(\"deprecation\")\n                NetworkInfo mWiFiNetworkInfo = mConnectivityManager.getNetworkInfo(ConnectivityManager.TYPE_WIFI);\n                if (mWiFiNetworkInfo != null)\n                    return mWiFiNetworkInfo.isAvailable() && mWiFiNetworkInfo.isConnected();\n            }\n        }\n        return false;\n    }\n","new_comment_raw":"@return Open return true, close returns false","old_comment_raw":"@return Open return true, close returns false","label":0,"pre_label":1,"AST_level":12,"line_counts":19,"new_code_token_num":131},{"new_code_raw":"public long getMillis(long value) { return FieldUtils.safeMultiply(value, getUnitMillis()); }","old_code_raw":"    public long getMillis(long value) {\n        return value * getUnitMillis();\n    }\n","new_comment_raw":"@return the milliseconds that the field represents, which may be negative","old_comment_raw":"@return the milliseconds that the field represents, which may be negative","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"@Override public void createRecord(DBRecord rec, Connection conn) { throw new NotImplementedException(this, STR); }","old_code_raw":"@Override\npublic boolean createRecord(DBRecord rec, Connection conn) {\n    return error(Errors.NotImplemented, STR);\n}","new_comment_raw":"@return a not implemented error","old_comment_raw":"@return an error, because querys could't add new records to the database","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":23},{"new_code_raw":"public boolean highlightNode(ASTGenerator astGenerator){ if(!(Node instanceof SimpleName)){ return false; } SimpleName nodeName = (SimpleName) Node; try { \/\/TODO: Redundant code. See ASTGenerator.getJavaSourceCodeline() int javaLineNumber = getLineNumber(nodeName); int pdeOffs[] = astGenerator.errorCheckerService .calculateTabIndexAndLineNumber(javaLineNumber); PlainDocument javaSource = new PlainDocument(); javaSource.insertString(0, astGenerator.errorCheckerService.sourceCode, null); Element lineElement = javaSource.getDefaultRootElement() .getElement(javaLineNumber-1); if(lineElement == null) { log(lineNumber + \" line element null while highlighting \" + nodeName); return false; } String javaLine = javaSource.getText(lineElement.getStartOffset(), lineElement.getEndOffset() - lineElement.getStartOffset()); astGenerator.editor.getSketch().setCurrentCode(pdeOffs[0]); String pdeLine = astGenerator.editor.getLineText(pdeOffs[1]); String lookingFor = nodeName.toString(); log(lookingFor + \", \" + nodeName.getStartPosition()); log(javaLineNumber +\" JL \" + javaLine + \" LSO \" + lineElement.getStartOffset() + \",\" + lineElement.getEndOffset()); log(pdeOffs[1] + \" PL \" + pdeLine); if (!javaLine.contains(lookingFor) || !pdeLine.contains(lookingFor)) { logE(\"Logical error in highLightNode(). Please file a bug report.\"); return false; } OffsetMatcher ofm = new OffsetMatcher(pdeLine, javaLine); int highlightStart = ofm.getPdeOffForJavaOff(nodeName.getStartPosition() - lineElement.getStartOffset(), nodeName.getLength()); if (highlightStart == -1) { logE(\"Logical error in highLightNode() during offset matching. \" + \"Please file a bug report.\"); return false; } int lso = astGenerator.editor.ta.getLineStartOffset(pdeOffs[1]); highlightStart += lso; astGenerator.editor.setSelection(highlightStart, highlightStart + nodeName.getLength()); \/* \/\/ First find the name in the java line, and marks its index Pattern toFind = Pattern.compile(\"\\\\b\" + nodeName.toString() + \"\\\\b\"); Matcher matcher = toFind.matcher(javaLine); int count = 0, index = 0; int lsto = lineElement.getStartOffset(); while(matcher.find()){ count++; \/\/log(matcher.start() + lsto); if(lsto + matcher.start() == nodeName.getStartPosition()) break; } log(\"count=\" + count); index = 0; \/\/ find the same name in the pde line by its index and get its offsets matcher = toFind.matcher(pdeLine); while(matcher.find()){ count--; if(count == 0){ log(\"Found on pde line lso: \" + matcher.start()); index = matcher.end(); break; } } log(\"pde lso \" + (index - lookingFor.length())); int lso = astGenerator.editor.ta.getLineStartOffset(pdeOffs[1]); astGenerator.editor.setSelection(lso + index - lookingFor.length(), lso + index); *\/ return true; } catch (BadLocationException e) { logE(\"BLE in highLightNode() for \" + nodeName); e.printStackTrace(); } return false; }","old_code_raw":"  public boolean highlightNode(ASTGenerator astGenerator){\n    if(!(Node instanceof SimpleName)){\n      return false; \n    }\n    SimpleName nodeName = (SimpleName) Node;\n    try {\n      \/\/TODO: Redundant code. See ASTGenerator.getJavaSourceCodeline()\n      int javaLineNumber = getLineNumber(nodeName);\n      int pdeOffs[] = astGenerator.errorCheckerService\n          .calculateTabIndexAndLineNumber(javaLineNumber);\n      PlainDocument javaSource = new PlainDocument();\n      javaSource.insertString(0, astGenerator.errorCheckerService.sourceCode, null);\n      Element lineElement = javaSource.getDefaultRootElement()\n          .getElement(javaLineNumber-1);\n      if(lineElement == null) {\n        log(lineNumber + \" line element null while highlighting \" + nodeName);\n        return false;\n      }\n      \n      String javaLine = javaSource.getText(lineElement.getStartOffset(),\n                                           lineElement.getEndOffset()\n                                               - lineElement.getStartOffset());\n      astGenerator.editor.getSketch().setCurrentCode(pdeOffs[0]);\n      String pdeLine = astGenerator.editor.getLineText(pdeOffs[1]);\n      String lookingFor = nodeName.toString();\n      log(lookingFor + \", \" + nodeName.getStartPosition());\n      log(javaLineNumber +\" JL \" + javaLine + \" LSO \" + lineElement.getStartOffset() + \",\"\n          + lineElement.getEndOffset());\n      log(pdeOffs[1] + \" PL \" + pdeLine);\n      if (!javaLine.contains(lookingFor) || !pdeLine.contains(lookingFor)) {\n        logE(\"Logical error in highLightNode(). Please file a bug report.\");\n        return false;\n      }\n      \n      \/\/ First find the name in the java line, and marks its index\n      Pattern toFind = Pattern.compile(\"\\\\b\" + nodeName.toString() + \"\\\\b\");\n      Matcher matcher = toFind.matcher(javaLine);\n      int count = 0, index = 0;\n      int lsto = lineElement.getStartOffset();\n      while(matcher.find()){\n        count++;\n        \/\/log(matcher.start() + lsto);\n        if(lsto + matcher.start() == nodeName.getStartPosition())\n          break;\n      }\n      log(\"count=\" + count);\n      index = 0;\n      \/\/ find the same name in the pde line by its index and get its offsets\n      matcher = toFind.matcher(pdeLine);\n      while(matcher.find()){\n        count--;\n        if(count == 0){\n          log(\"Found on pde line lso: \" + matcher.start());\n          index = matcher.end();\n          break;\n        }\n      }\n      log(\"pde lso \" + (index - lookingFor.length()));\n      \n      int lso = astGenerator.editor.ta.getLineStartOffset(pdeOffs[1]);\n      astGenerator.editor.setSelection(lso + index - lookingFor.length(), lso\n          + index);\n      return true;\n    } catch (BadLocationException e) {\n      logE(\"BLE in highLightNode() for \" + nodeName);\n      e.printStackTrace();\n    }\n    return false;\n  }\n","new_comment_raw":"@return - true if highlighting was successful","old_comment_raw":"@return - true if highlighting was successful","label":0,"pre_label":1,"AST_level":12,"line_counts":85,"new_code_token_num":629},{"new_code_raw":"public boolean setTaskCompleted(List<FileDownloadTaskAtom> taskAtomList) { FileDownloadLog.w(this, STR + STR); return true; }","old_code_raw":"public boolean setTaskCompleted(List<FileDownloadTaskAtom> taskAtomList) {\n    return FileDownloadServiceProxy.getImpl().setTaskCompleted(taskAtomList);\n}","new_comment_raw":"@return Whether is successful to update all tasks' status to the Filedownloader Engine. If one task atom among them is not match the Rules in FileDownloadMgr#obtainCompletedTaskShelfModel(String, String, long) will receive false, and non of them would be updated to DB.","old_comment_raw":"@return Whether is successful to update all tasks' status to the Filedownloader Engine. If one task atom among them is not match the Rules in {@link com.liulishuo.filedownloader.services.FileDownloadMgr#obtainCompletedTaskShelfModel(String, String, long)} will receive false, and non of them would be updated to DB.","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":23},{"new_code_raw":"protected SqlStatementLogger sqlStatementLogger() { return sqlStatementLogger; }","old_code_raw":"\tprotected SqlStatementLogger sqlStatementLogger() {\n\t\treturn jdbcCoordinator.getTransactionCoordinator()\n\t\t\t\t.getTransactionContext()\n\t\t\t\t.getTransactionEnvironment()\n\t\t\t\t.getJdbcServices()\n\t\t\t\t.getSqlStatementLogger();\n\t}\n","new_comment_raw":"@return The underlying JDBC services.","old_comment_raw":"@return The underlying JDBC services.","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"protected Configuration doConfigure(InputStream stream, String resourceName) throws HibernateException { try { List errors = new ArrayList(); Document document = xmlHelper.createSAXReader( resourceName, errors, entityResolver ) .read( new InputSource( stream ) ); if ( errors.size() != 0 ) { throw new MappingException( \"invalid configuration\", (Throwable) errors.get( 0 ) ); } doConfigure( document ); } catch (DocumentException e) { throw new HibernateException( \"Could not parse configuration: \" + resourceName, e ); } finally { try { stream.close(); } catch (IOException ioe) { log.warn( \"could not close input stream for: \" + resourceName, ioe ); } } return this; }","old_code_raw":"\tprotected Configuration doConfigure(InputStream stream, String resourceName) throws HibernateException {\n\n\t\torg.dom4j.Document doc;\n\t\ttry {\n\t\t\tList errors = new ArrayList();\n\t\t\tdoc = xmlHelper.createSAXReader( resourceName, errors, entityResolver )\n\t\t\t\t\t.read( new InputSource( stream ) );\n\t\t\tif ( errors.size() != 0 ) {\n\t\t\t\tthrow new MappingException(\n\t\t\t\t\t\t\"invalid configuration\",\n\t\t\t\t\t\t(Throwable) errors.get( 0 )\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tcatch (DocumentException e) {\n\t\t\tthrow new HibernateException(\n\t\t\t\t\t\"Could not parse configuration: \" + resourceName,\n\t\t\t\t\te\n\t\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tstream.close();\n\t\t\t}\n\t\t\tcatch (IOException ioe) {\n\t\t\t\tlog.warn( \"could not close input stream for: \" + resourceName, ioe );\n\t\t\t}\n\t\t}\n\n\t\treturn doConfigure( doc );\n\n\t}\n","new_comment_raw":"@return this for method chaining","old_comment_raw":"@return A configuration configured via the stream","label":1,"pre_label":0,"AST_level":10,"line_counts":24,"new_code_token_num":142},{"new_code_raw":"private boolean isLogicalOneToOne(Type type) { return type.isEntityType() && ( (EntityType) type ).isLogicalOneToOne(); }","old_code_raw":"\tprivate boolean isLogicalOneToOne(Type type) {\n\t\tif ( ! type.isEntityType() ) {\n\t\t\treturn false;\n\t\t}\n\t\tfinal EntityType entityType = (EntityType) type;\n\t\tif ( entityType.isOneToOne() ) {\n\t\t\t\/\/ physical one-to-one\n\t\t\treturn true;\n\t\t}\n\t\t\/\/ todo : still need to handle the many-to-one w\/ property-ref\n\t\t\/\/\t\tactually there is a question about whether the constrained side\n\t\t\/\/\t\tcan declare the orphan-delete.  If not, then the side declaring\n\t\t\/\/\t\tthe orphan-delete can only ever be a <one-to-one\/>\n\t\treturn false;\n\t}\n","new_comment_raw":"@return True if the attribute represents a logical one to one association","old_comment_raw":"@return True if the attribute represents a logical one to one association","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":26},{"new_code_raw":"public String getTypeDeclaration(Schema p) { String openAPIType = getSchemaType(p); if (p instanceof ArraySchema) { ArraySchema ap = (ArraySchema) p; Schema inner = ap.getItems(); return getSchemaType(p) + \"<\" + getTypeDeclaration(inner) + \">\"; } else if (isMapSchema(p)) { Schema inner = (Schema) p.getAdditionalProperties(); return getSchemaType(p) + \"<std::string, \" + getTypeDeclaration(inner) + \">\"; } else if (p instanceof StringSchema || SchemaTypeUtil.STRING_TYPE.equals(p.getType()) || p instanceof DateSchema || p instanceof DateTimeSchema || p instanceof FileSchema || languageSpecificPrimitives.contains(openAPIType)) { return toModelName(openAPIType); } return \"std::shared_ptr<\" + openAPIType + \">\"; }","old_code_raw":"    public String getTypeDeclaration(Schema p) {\n        String swaggerType = getSchemaType(p);\n\n        if (p instanceof ArraySchema) {\n            ArraySchema ap = (ArraySchema) p;\n            Schema inner = ap.getItems();\n            return getSchemaType(p) + \"<\" + getTypeDeclaration(inner) + \">\";\n        }\n        if (isMapSchema(p)) {\n            Schema inner = (Schema) p.getAdditionalProperties();\n            return getSchemaType(p) + \"<std::string, \" + getTypeDeclaration(inner) + \">\";\n        }\n        if (p instanceof StringSchema || p instanceof DateSchema\n                || p instanceof DateTimeSchema || p instanceof FileSchema\n                || languageSpecificPrimitives.contains(swaggerType)) {\n            return toModelName(swaggerType);\n        }\n\n        return \"std::shared_ptr<\" + swaggerType + \">\";\n    }\n","new_comment_raw":"@return a string value used as the `dataType` field for model templates, `returnType` for api templates","old_comment_raw":"@return a string value used as the `dataType` field for model templates, `returnType` for api templates","label":0,"pre_label":1,"AST_level":12,"line_counts":20,"new_code_token_num":158},{"new_code_raw":"public Timer getTimer(TimerDesc timerDesc) { return getTimer(timerDesc.getName(), timerDesc.getDurationUnit(), timerDesc.getTimeUnit()); }","old_code_raw":"public Timer getTimer(String name) {\n    return getTimer(name, TimeUnit.MILLISECONDS, TimeUnit.SECONDS);\n}","new_comment_raw":"@return new {@link Timer}","old_comment_raw":"@return a new {@link com.yammer.metrics.core.Timer}","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":28},{"new_code_raw":"public boolean isNullGenerating(int factIdx) { return joinTypes.get(factIdx).isOuterJoin(); }","old_code_raw":"  public boolean isNullGenerating(int factIdx) {\n    return joinTypes.get(factIdx) != JoinRelType.INNER;\n  }\n","new_comment_raw":"@return whether or not the factor corresponds to a null-generating factor in a left or right outer join","old_comment_raw":"@return whether or not the factor corresponds to a null-generating factor in a left or right outer join","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":19},{"new_code_raw":"public JSONArray getExtraJSONArray(String key) throws JSONException { return mExtraData.getJSONArray(key); }","old_code_raw":"public JSONArray getExtraJSONArray(String key) {\n    return mExtraData.optJSONArray(key);\n}","new_comment_raw":"@return The stored value.","old_comment_raw":"@return The stored value or null if it doesn't exist in specified form.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":18},{"new_code_raw":"public static InternetObservingSettings create() { return new Builder().build(); }","old_code_raw":"  public static InternetObservingSettings create() {\n    return new InternetObservingSettings.Builder().build();\n  }\n","new_comment_raw":"@return settings with default parameters","old_comment_raw":"@return settings with default parameters","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":17},{"new_code_raw":"public List<Pet> findPetsByStatus (List<String> status) throws ApiException { Object postBody = null; \/\/ create path and map variables String path = \"\/pet\/findByStatus\".replaceAll(\"\\\\{format\\\\}\",\"json\"); \/\/ query params List<Pair> queryParams = new ArrayList<Pair>(); Map<String, String> headerParams = new HashMap<String, String>(); Map<String, Object> formParams = new HashMap<String, Object>(); queryParams.addAll(apiClient.parameterToPairs(\"multi\", \"status\", status)); final String[] accepts = { \"application\/json\", \"application\/xml\" }; final String accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final String contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { \"petstore_auth\" }; TypeRef returnType = new TypeRef<List<Pet>>() {}; return apiClient.invokeAPI(path, \"GET\", queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }","old_code_raw":"  public List<Pet> findPetsByStatus (List<String> status) throws ApiException {\n    Object postBody = null;\n    \n\n    \/\/ create path and map variables\n    String path = \"\/pet\/findByStatus\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    \/\/ query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    Map<String, String> headerParams = new HashMap<String, String>();\n    Map<String, String> formParams = new HashMap<String, String>();\n\n    \n    queryParams.addAll(apiClient.parameterToPairs(\"multi\", \"status\", status));\n    \n\n    \n\n    final String[] accepts = {\n      \"application\/json\", \"application\/xml\"\n    };\n    final String accept = apiClient.selectHeaderAccept(accepts);\n\n    final String[] contentTypes = {\n      \n    };\n    final String contentType = apiClient.selectHeaderContentType(contentTypes);\n\n    if(contentType.startsWith(\"multipart\/form-data\")) {\n      boolean hasFields = false;\n      FormDataMultiPart mp = new FormDataMultiPart();\n      \n      if(hasFields)\n        postBody = mp;\n    }\n    else {\n      \n    }\n\n    try {\n      String[] authNames = new String[] { \"petstore_auth\" };\n      String response = apiClient.invokeAPI(path, \"GET\", queryParams, postBody, headerParams, formParams, accept, contentType, authNames);\n      if(response != null){\n        return (List<Pet>) apiClient.deserialize(response, \"array\", Pet.class);\n      }\n      else {\n        return null;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n","new_comment_raw":"@return List","old_comment_raw":"@return List","label":0,"pre_label":1,"AST_level":10,"line_counts":37,"new_code_token_num":203},{"new_code_raw":"private static String getValue(RDFTerm resource) { if (resource instanceof IRI) { return ((IRI) resource).getUnicodeString(); } else if (resource instanceof Literal) { return ((Literal) resource).getLexicalForm(); } else { return resource.toString(); } }","old_code_raw":"private static String getValue(Resource resource) {\n    if (resource instanceof UriRef) {\n        return ((UriRef) resource).getUnicodeString();\n    } else if (resource instanceof Literal) {\n        return ((Literal) resource).getLexicalForm();\n    } else {\n        return resource.toString();\n    }\n}","new_comment_raw":"@return returns the unicode string of an IRI or the lexical form of a Literal or the return value of a toString() on a BlankNode","old_comment_raw":"@return returns the unicode string of an UriRef or the lexical form of a Literal or the return value of a toString() on a BNode","label":1,"pre_label":0,"AST_level":8,"line_counts":9,"new_code_token_num":58},{"new_code_raw":"public boolean isAggregator() { return false; }","old_code_raw":"  public boolean isAggregator() {\n    return this instanceof SqlAggFunction;\n  }\n","new_comment_raw":"@return whether this operator is an aggregator","old_comment_raw":"@return whether this operator is an aggregator","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"protected Object[] createWriteMethodArguments(Method method, Object value) throws IllegalAccessException, ClassCastException { try { if (value != null) { Class<?>[] types = method.getParameterTypes(); if (types != null && types.length > 0) { Class<?> paramType = types[0]; if (paramType.isPrimitive()) { paramType = Primitives.wrap(paramType); } if (!paramType.isAssignableFrom(value.getClass())) { value = convertType(paramType, value); } } } return new Object[]{value}; } catch (InvocationTargetException e) { throw new IllegalArgumentException(e.getMessage()); } catch (InstantiationException e) { throw new IllegalArgumentException(e.getMessage()); } }","old_code_raw":"    protected Object[] createWriteMethodArguments(Method method, Object value) throws IllegalAccessException, ClassCastException {\n        try {\n            if (value != null) {\n                Class<?>[] types = method.getParameterTypes();\n                if (types != null && types.length > 0) {\n                    Class<?> paramType = types[0];\n                    if (paramType.isPrimitive()) {\n                        paramType = Primitives.wrap(paramType);\n                    }\n                    if (!paramType.isAssignableFrom(value.getClass())) {\n                        value = convertType(paramType, value);\n                    }\n                }\n            }\n            Object[] answer = {value};\n            return answer;\n        } catch (InvocationTargetException e) {\n            throw new IllegalArgumentException(e.getMessage());\n        } catch (InstantiationException e) {\n            throw new IllegalArgumentException(e.getMessage());\n        }\n    }\n","new_comment_raw":"@return an array containing one object that is either the given value or a transformed value","old_comment_raw":"@return an array containing one object that is either the given value or a transformed value","label":0,"pre_label":1,"AST_level":13,"line_counts":22,"new_code_token_num":141},{"new_code_raw":"public static LocalDate fromDateFields(Date date) { if (date == null) { throw new IllegalArgumentException(\"The date must not be null\"); } if (date.getTime() < 0) { \/\/ handle years in era BC GregorianCalendar cal = new GregorianCalendar(); cal.setTime(date); return fromCalendarFields(cal); } return new LocalDate( date.getYear() + 1900, date.getMonth() + 1, date.getDate() ); }","old_code_raw":"    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return new LocalDate(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }\n","new_comment_raw":"@return the created local date, not null","old_comment_raw":"@return the created LocalDate","label":1,"pre_label":0,"AST_level":8,"line_counts":17,"new_code_token_num":91},{"new_code_raw":"@Deprecated public List<String> readScopes() { return SENTINEL_EMPTY_SCOPES; }","old_code_raw":"public List<String> readScopes() {\n    return readScopes;\n}","new_comment_raw":"@return an empty list","old_comment_raw":"@return the allowed read scopes","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":13},{"new_code_raw":"public List<TaggedWord> apply(List<? extends HasWord> in) { TestSentence testSentence = new TestSentence(this); return testSentence.tagSentence(in, false); }","old_code_raw":"  public ArrayList<TaggedWord> apply(List<? extends HasWord> in) {\n    TestSentence testSentence = new TestSentence(this);\n    return testSentence.tagSentence(in, false);\n  }\n","new_comment_raw":"@return A Sentence of TaggedWord","old_comment_raw":"@return A Sentence of TaggedWord","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":30},{"new_code_raw":"public static AbstractSchema getTemporaryWorkspace(SchemaPlus defaultSchema, DrillConfig config) { String temporarySchema = config.getString(ExecConstants.DEFAULT_TEMPORARY_WORKSPACE); List<String> temporarySchemaPath = Lists.newArrayList(temporarySchema); SchemaPlus schema = findSchema(defaultSchema, temporarySchemaPath); return schema == null ? null : unwrapAsDrillSchemaInstance(schema); }","old_code_raw":"  public static AbstractSchema getTemporaryWorkspace(SchemaPlus defaultSchema, DrillConfig config) {\n    List<String> temporarySchemaPath = Lists.newArrayList(config.getString(ExecConstants.DEFAULT_TEMPORARY_WORKSPACE));\n    AbstractSchema temporarySchema = resolveToMutableDrillSchema(defaultSchema, temporarySchemaPath);\n    if (!(temporarySchema instanceof WorkspaceSchemaFactory.WorkspaceSchema)) {\n      DrillRuntimeException.format(\"Temporary workspace [%s] must be file-based, instance of \" +\n          \"WorkspaceSchemaFactory.WorkspaceSchema\", temporarySchemaPath);\n    }\n    return temporarySchema;\n  }\n","new_comment_raw":"@return default temporary workspace, null if workspace was not found","old_comment_raw":"@return default temporary workspace","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":51},{"new_code_raw":"public String[] punctuationWords() { return punctWords; }","old_code_raw":"  public String[] punctuationWords() {\n    return frenchPunctWords;\n  }\n","new_comment_raw":"@return The punctuation words","old_comment_raw":"@return The punctuation words","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":12},{"new_code_raw":"protected Map<Object, ComponentAdapter<?>> getComponentKeyToAdapterCache() { return keyToAdapterCache; }","old_code_raw":"protected Map<Object, ComponentAdapter<?>> getComponentKeyToAdapterCache() {\n    return componentKeyToAdapterCache;\n}","new_comment_raw":"@return the keyToAdapterCache","old_comment_raw":"@return the componentKeyToAdapterCache","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":14},{"new_code_raw":"public long getConfigMemorySizePerBatch() { return configMemorySizePerBatch; }","old_code_raw":"  public int getConfigMemorySizePerBatch() {\n    return configMemorySizePerBatch;\n  }\n","new_comment_raw":"@return configured memory size per batch (may be different from the enforced one)","old_comment_raw":"@return configured memory size per batch (may be different from the enforced one)","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"public AccessType getAccessType() { if (isPublic()) { return AccessType.ACC_PUBLIC; } if (isPrivate()) { return AccessType.ACC_PRIVATE; } if (isProtected()) { return AccessType.ACC_PROTECTED; } return AccessType.ACC_PACKAGE; }","old_code_raw":"public int getAccessType() {\n    if (isPublic()) {\n        return ACC_PUBLIC;\n    }\n    if (isPrivate()) {\n        return ACC_PRIVATE;\n    }\n    if (isProtected()) {\n        return ACC_PROTECTED;\n    }\n    return ACC_PACKAGE;\n}","new_comment_raw":"@return a value of {@link AccessType}.","old_comment_raw":"@return one of {@link #ACC_PRIVATE}, {@link #ACC_PROTECTED}, {@link #ACC_PACKAGE} or {@link #ACC_PUBLIC}.","label":1,"pre_label":0,"AST_level":6,"line_counts":12,"new_code_token_num":47},{"new_code_raw":"public int[] getValues() { int[] result = new int[getFieldSize()]; for (int i = 0; i < result.length; i++) { result[i] = getValue(i); } return result; }","old_code_raw":"    public int[] getValues() {\n        return (int[]) iValues.clone();\n    }\n","new_comment_raw":"@return the current values of each field in an array that may be altered, largest to smallest","old_comment_raw":"@return the current values of each field (cloned), largest to smallest","label":1,"pre_label":0,"AST_level":9,"line_counts":8,"new_code_token_num":49},{"new_code_raw":"public DirectRowSet rowSet() throws RpcException { \/\/ Ignore all but the first non-empty batch. QueryDataBatch dataBatch = null; for (QueryDataBatch batch : results()) { if (dataBatch == null && batch.getHeader().getRowCount() != 0) { dataBatch = batch; } else { batch.release(); } } \/\/ No results? if (dataBatch == null) { return null; } \/\/ Unload the batch and convert to a row set. final RecordBatchLoader loader = new RecordBatchLoader(client.allocator()); try { loader.load(dataBatch.getHeader().getDef(), dataBatch.getData()); dataBatch.release(); VectorContainer container = loader.getContainer(); container.setRecordCount(loader.getRecordCount()); return DirectRowSet.fromContainer(container); } catch (SchemaChangeException e) { throw new IllegalStateException(e); } }","old_code_raw":"  public DirectRowSet rowSet() throws RpcException {\n\n    \/\/ Ignore all but the first non-empty batch.\n\n    QueryDataBatch dataBatch = null;\n    for (QueryDataBatch batch : results()) {\n      if (dataBatch == null  &&  batch.getHeader().getRowCount() != 0) {\n        dataBatch = batch;\n      } else {\n        batch.release();\n      }\n    }\n\n    \/\/ No results?\n\n    if (dataBatch == null) {\n      return null;\n    }\n\n    \/\/ Unload the batch and convert to a row set.\n\n    final RecordBatchLoader loader = new RecordBatchLoader(client.allocator());\n    try {\n      loader.load(dataBatch.getHeader().getDef(), dataBatch.getData());\n      dataBatch.release();\n      VectorContainer container = loader.getContainer();\n      container.setRecordCount(loader.getRecordCount());\n      return new DirectRowSet(client.allocator(), container);\n    } catch (SchemaChangeException e) {\n      throw new IllegalStateException(e);\n    }\n  }\n","new_comment_raw":"@return a row set that represents the first batch returned from the query","old_comment_raw":"@return a row set that represents the first batch returned from the query","label":0,"pre_label":1,"AST_level":9,"line_counts":33,"new_code_token_num":164},{"new_code_raw":"public Domain getDom() throws ErrorException { throw new ErrorException(STR); }","old_code_raw":"public VirDomain getDom() throws VirErrorException {\n    throw new VirErrorException(STR);\n}","new_comment_raw":"@return Domain object","old_comment_raw":"@return VirDomain object","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":16},{"new_code_raw":"public static <T extends CharSequence> T validIndex(final T chars, final int index) { return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index)); }","old_code_raw":"public static <T extends Collection<?>> T validIndex(final T collection, final int index) {\n    return validIndex(collection, index, DEFAULT_VALID_INDEX_COLLECTION_EX_MESSAGE, Integer.valueOf(index));\n}","new_comment_raw":"@return the validated character sequence (never {@code null} for method chaining)","old_comment_raw":"@return the validated collection (never {@code null} for method chaining)","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":34},{"new_code_raw":"private static File findBinary(String... binaryNames) { final String[] paths = System.getenv(\"PATH\").split(File.pathSeparator); for (String binaryName : binaryNames) { for (String path : paths) { File file = new File(path, binaryName); if (file.exists()) { return file; } if (Platform.getCurrent().is(Platform.WINDOWS)) { File exe = new File(path, binaryName + \".exe\"); if (exe.exists()) { return exe; } } } } return null; }","old_code_raw":"  private static File findBinary(String... binaryNames) {\n    final String[] paths = System.getenv(\"PATH\").split(File.pathSeparator);\n    for (String binaryName : binaryNames) {\n      for (String path : paths) {\n        File file = new File(path, binaryName);\n        if (file.exists()) {\n          return file;\n        }\n      }\n    }\n    return null;\n  }\n","new_comment_raw":"@return the first binary found matching that name.","old_comment_raw":"@return the first binary found matching that name.","label":0,"pre_label":1,"AST_level":13,"line_counts":19,"new_code_token_num":111},{"new_code_raw":"@Action(value = STR) public String execute() throws Exception { if (statusMessage == null || statusMessage.trim().length() == NUM) { request.setAttribute(STR, STR); return STR; } SASFHelper helper = SASFStaticHelper.getHelper(request); SocialAuthManager manager = helper.getAuthManager(); AuthProvider provider = null; if (manager != null) { provider = manager.getCurrentAuthProvider(); } if (provider != null) { try { provider.updateStatus(statusMessage); request.setAttribute(STR, STR); return STR; } catch (SocialAuthException e) { request.setAttribute(STR, e.getMessage()); e.printStackTrace(); } } return STR; }","old_code_raw":"@Override\npublic ActionForward execute(final ActionMapping mapping, final ActionForm form, final HttpServletRequest request, final HttpServletResponse response) throws Exception {\n    String statusMsg = request.getParameter(STR);\n    if (statusMsg == null || statusMsg.trim().length() == NUM) {\n        request.setAttribute(STR, STR);\n        return mapping.findForward(STR);\n    }\n    SASFHelper helper = SASFStaticHelper.getHelper(request);\n    SocialAuthManager manager = helper.getAuthManager();\n    AuthProvider provider = null;\n    if (manager != null) {\n        provider = manager.getCurrentAuthProvider();\n    }\n    if (provider != null) {\n        try {\n            provider.updateStatus(statusMsg);\n            request.setAttribute(STR, STR);\n            return mapping.findForward(STR);\n        } catch (SocialAuthException e) {\n            request.setAttribute(STR, e.getMessage());\n            e.printStackTrace();\n        }\n    }\n    return mapping.findForward(STR);\n}","new_comment_raw":"@return String where the action should flow","old_comment_raw":"@return ActionForward where the action should flow","label":1,"pre_label":0,"AST_level":9,"line_counts":24,"new_code_token_num":130},{"new_code_raw":"public static ClusterFixture standardCluster(BaseDirTestWatcher dirTestWatcher) { return builder(dirTestWatcher).build(); }","old_code_raw":"  public static ClusterFixture standardCluster() {\n    return builder().build();\n  }\n","new_comment_raw":"@return a cluster fixture with standard options","old_comment_raw":"@return a cluster fixture with standard options","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":19},{"new_code_raw":"public static Builder newExecutionInput(String query) { return new Builder().query(query); }","old_code_raw":"    public static Builder newExecutionInput() {\n        return new Builder();\n    }\n","new_comment_raw":"@return a new builder of ExecutionInput objects","old_comment_raw":"@return a new builder of ExecutionInput objects","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"public RelNode decorrelate(SqlNode query, RelNode rootRel) { if (!enableDecorrelation()) { return rootRel; } final RelNode result = decorrelateQuery(rootRel); if (result != rootRel) { checkConvertedType(query, result); } return result; }","old_code_raw":"  public RelNode decorrelate(SqlNode query, RelNode rootRel) {\n    RelNode result = rootRel;\n    if (enableDecorrelation()\n        && hasCorrelation()) {\n      result = decorrelateQuery(result);\n      checkConvertedType(query, result);\n    }\n    return result;\n  }\n","new_comment_raw":"@return New root relational expression after decorrelation","old_comment_raw":"@return New root relational expression after decorrelation","label":0,"pre_label":1,"AST_level":7,"line_counts":11,"new_code_token_num":50},{"new_code_raw":"public synchronized IConfigurationElement[] getContainerExtensions(String containerid, String[] containerPaths) { if (extensions == null) processProxyExtensionExtensionPoint(); return (IConfigurationElement[]) extensions.containerPathContributions.getContributors(containerid, containerPaths); }","old_code_raw":"public synchronized IConfigurationElement[] getContainerExtensions(String containerid) {\n    if (containerToExtensions == null)\n        processProxyExtensionExtensionPoint();\n    return (IConfigurationElement[]) containerToExtensions.get(containerid);\n}","new_comment_raw":"@return Array of configuration elements.","old_comment_raw":"@return Array of extension registration elements or <code>null<\/code> if this container has no contributions.","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":41},{"new_code_raw":"public boolean getBoolean(String name, boolean defaultValue) { String value = getString(name); return (value != null) && (value.equals(\"1\") || value.toLowerCase().equals(\"true\")); }","old_code_raw":"  public boolean getBoolean(String name, boolean defaultValue) {\n    String value = this.getAttribute(name, Boolean.toString(defaultValue));\n    return value.equals(\"1\") || value.toLowerCase().equals(\"true\");\n  }\n","new_comment_raw":"@return the value, or defaultValue if the attribute does not exist.","old_comment_raw":"@return the value, or defaultValue if the attribute does not exist.","label":0,"pre_label":1,"AST_level":8,"line_counts":5,"new_code_token_num":49},{"new_code_raw":"public String toLowerCase() { return CaseMapper.toLowerCase(Locale.getDefault(), this, value, offset, count); }","old_code_raw":"public String toLowerCase() {\n    return toLowerCase(Locale.getDefault());\n}","new_comment_raw":"@return a new lowercase string, or {@code this} if it's already all-lowercase.","old_comment_raw":"@return a new string containing the lowercase characters equivalent to the characters in this string.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":25},{"new_code_raw":"public boolean searchButton(String text, int minimumNumberOfMatches, boolean onlyVisible) { return searcher.searchWithTimeoutFor(Button.class, text, minimumNumberOfMatches, true, onlyVisible); }","old_code_raw":"\tpublic boolean searchButton(String text, int minimumNumberOfMatches, boolean onlyVisible) {\n\t\tboolean found = searcher.searchWithTimeoutFor(Button.class, text, minimumNumberOfMatches, true, onlyVisible);\n\t\treturn found;\n\t}\n","new_comment_raw":"@return  true if a  Button with the given text is found a given number of times and  false if it is not found","old_comment_raw":"@return true if a Button with the given text is found a given number of times and false if it is not found","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":31},{"new_code_raw":"public boolean dependsOn(Collection<AddOn> addOns) { if (dependencies == null || dependencies.getAddOns().isEmpty()) { return false; } for (AddOn addOn : addOns) { if (dependsOn(addOn)) { return true; } } return false; }","old_code_raw":"public boolean dependsOn(AddOn addOn) {\n    if (dependencies == null || dependencies.getAddOns().isEmpty()) {\n        return false;\n    }\n    return dependsOn(dependencies.getAddOns(), addOn);\n}","new_comment_raw":"@return {@code true} if it depends on any of the given add-ons, {@code false} otherwise.","old_comment_raw":"@return {@code true} if it depends on the given add-on, {@code false} otherwise.","label":1,"pre_label":0,"AST_level":8,"line_counts":11,"new_code_token_num":53},{"new_code_raw":"public Connection getConnection(IBasicRequest request) { Logger.d(STR); Headers responseHeaders = new HttpHeaders(); InputStream inputStream = null; Exception exception = null; Network network = null; String url = request.url(); try { if (!NetUtil.isNetworkAvailable()) throw new NetworkError(STR + STR + url); network = createConnectionAndWriteData(request); Logger.d(STR); int responseCode = network.getResponseCode(); responseHeaders = parseResponseHeaders(new URI(request.url()), responseCode, network.getResponseHeaders()); if (responseCode == NUM || responseCode == NUM || responseCode == NUM || responseCode == NUM) { Connection redirectConnection = handleRedirect(request, responseHeaders); responseHeaders = redirectConnection.responseHeaders(); inputStream = redirectConnection.serverStream(); exception = redirectConnection.exception(); } else if (hasResponseBody(request.getRequestMethod(), responseCode)) { inputStream = network.getServerStream(responseCode, responseHeaders); } Logger.d(STR); } catch (MalformedURLException e) { exception = new URLError(STR + url + STR); } catch (UnknownHostException e) { exception = new UnKnownHostError(STR + url + STR); } catch (SocketTimeoutException e) { exception = new TimeoutError(STR + url + STR); } catch (Exception e) { exception = e; } finally { if (exception != null) Logger.e(exception); } Logger.d(STR); return new Connection(network, responseHeaders, inputStream, exception); }","old_code_raw":"public ConnectionResult getConnection(IBasicRequest request) {\n    Logger.d(STR);\n    Headers responseHeaders = new HttpHeaders();\n    InputStream inputStream = null;\n    Exception exception = null;\n    Network network = null;\n    String url = request.url();\n    try {\n        if (!NetUtil.isNetworkAvailable())\n            throw new NetworkError(STR + url);\n        network = createConnectionAndWriteData(request);\n        Logger.d(STR);\n        int responseCode = network.getResponseCode();\n        responseHeaders = parseResponseHeaders(new URI(request.url()), responseCode, network.getResponseHeaders());\n        if (responseCode == NUM || responseCode == NUM || responseCode == NUM || responseCode == NUM) {\n            ConnectionResult redirectConnection = handleRedirect(request, responseHeaders);\n            responseHeaders = redirectConnection.responseHeaders();\n            inputStream = redirectConnection.serverStream();\n            exception = redirectConnection.exception();\n        } else if (hasResponseBody(request.getRequestMethod(), responseCode)) {\n            inputStream = network.getServerStream(responseCode, responseHeaders);\n        }\n        Logger.d(STR);\n    } catch (MalformedURLException e) {\n        exception = new URLError(STR + url + STR);\n    } catch (UnknownHostException e) {\n        exception = new UnKnownHostError(STR + url + STR);\n    } catch (SocketTimeoutException e) {\n        exception = new TimeoutError(STR + url + STR);\n    } catch (Exception e) {\n        exception = e;\n    } finally {\n        if (exception != null)\n            Logger.e(exception);\n    }\n    Logger.d(STR);\n    return new ConnectionResult(network, responseHeaders, inputStream, exception);\n}","new_comment_raw":"@return {@link Connection}.","old_comment_raw":"@return {@link ProtocolResult}.","label":1,"pre_label":0,"AST_level":10,"line_counts":38,"new_code_token_num":276},{"new_code_raw":"@Deprecated public Object getField() { return getValue(); }","old_code_raw":"public Object getField() {\n    return field;\n}","new_comment_raw":"@return the value for this accumulator","old_comment_raw":"@return the field for this accumulator","label":1,"pre_label":0,"AST_level":4,"line_counts":4,"new_code_token_num":14},{"new_code_raw":"public static Builder create() { return new Builder() { private Properties props = new Properties(); @Override public Builder with(String key, String value) { props.setProperty(key, value); return this; } @Override public Builder withDefault(String key, String value) { if (!props.containsKey(key)) { props.setProperty(key, value); } return this; } @Override public Builder apply(Consumer<Builder> function) { function.accept(this); return this; } @Override public JdbcConfiguration build() { return JdbcConfiguration.adapt(Configuration.from(props)); } @Override public String toString() { return props.toString(); } }; }","old_code_raw":"    public static Builder create() {\n        return new Builder() {\n            private Properties props = new Properties();\n\n            @Override\n            public Builder with(String key, String value) {\n                props.setProperty(key, value);\n                return this;\n            }\n\n            @Override\n            public JdbcConfiguration build() {\n                return JdbcConfiguration.adapt(Configuration.from(props));\n            }\n\n            @Override\n            public String toString() {\n                return props.toString();\n            }\n        };\n    }\n","new_comment_raw":"@return the configuration builder","old_comment_raw":"@return the configuration builder","label":0,"pre_label":1,"AST_level":10,"line_counts":36,"new_code_token_num":141},{"new_code_raw":"public String getAuthorizationUrl(Map<String, String> additionalParams) { return createAuthorizationUrlBuilder() .additionalParams(additionalParams) .build(); }","old_code_raw":"    public String getAuthorizationUrl(String state, Map<String, String> additionalParams, PKCE pkce) {\n        return createAuthorizationUrlBuilder()\n                .state(state)\n                .additionalParams(additionalParams)\n                .pkce(pkce)\n                .build();\n    }\n","new_comment_raw":"@return the URL where you should redirect your users","old_comment_raw":"@return url","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":24},{"new_code_raw":"public boolean isEmpty(){ return pendingCount <= 0; }","old_code_raw":"    public boolean isEmpty(){\n        return empty;\n    }\n","new_comment_raw":"@return true if there are no pendingCount messages","old_comment_raw":"@return true if there are no pending messages","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":11},{"new_code_raw":"public BrowserLauncher getBrowserLauncher(String browser, String sessionId) { if (browser == null) throw new IllegalArgumentException(\"browser may not be null\"); for (Iterator<String> iterator = supportedBrowsers.keySet().iterator(); iterator.hasNext();) { String name = iterator.next(); Class<? extends BrowserLauncher> c = supportedBrowsers.get(name); Pattern pat = Pattern.compile(\"^\\\\*\" + name + \"( .*)?$\"); Matcher mat = pat.matcher(browser); if (mat.find()) { String browserStartCommand; if (browser.equals(\"*\" + name)) { browserStartCommand = null; } else { browserStartCommand = mat.group(1).substring(1); } return createBrowserLauncher(c, browserStartCommand, sessionId); } } Matcher CustomMatcher = CUSTOM_PATTERN.matcher(browser); if (CustomMatcher.find()) { String browserStartCommand = CustomMatcher.group(1); if (browserStartCommand == null) { throw new RuntimeException(\"You must specify the path to an executable when using *custom!\\n\\n\"); } browserStartCommand = browserStartCommand.substring(1); return new DestroyableRuntimeExecutingBrowserLauncher(browserStartCommand, sessionId); } throw browserNotSupported(browser); }","old_code_raw":"    public BrowserLauncher getBrowserLauncher(String browser, String sessionId, CommandQueue queue) {\n        if (browser == null) throw new IllegalArgumentException(\"browser may not be null\");\n\n        for (Iterator<String> iterator = supportedBrowsers.keySet().iterator(); iterator.hasNext();) {\n            String name = iterator.next();\n            Class<? extends BrowserLauncher> c = supportedBrowsers.get(name);\n            Pattern pat = Pattern.compile(\"^\\\\*\" + name + \"( .*)?$\");\n            Matcher mat = pat.matcher(browser);\n            if (mat.find()) {\n                String browserStartCommand;\n                if (browser.equals(\"*\" + name)) {\n                    browserStartCommand = null;\n                } else {\n                    browserStartCommand = mat.group(1).substring(1);\n                }\n                return createBrowserLauncher(c, browserStartCommand, sessionId, queue);\n            }\n        }\n        Matcher CustomMatcher = CUSTOM_PATTERN.matcher(browser);\n        if (CustomMatcher.find()) {\n            String browserStartCommand = CustomMatcher.group(1);\n            if (browserStartCommand == null) {\n                throw new RuntimeException(\"You must specify the path to an executable when using *custom!\\n\\n\");\n            }\n            browserStartCommand = browserStartCommand.substring(1);\n            return new DestroyableRuntimeExecutingBrowserLauncher(browserStartCommand, sessionId);\n        }\n        throw browserNotSupported(browser);\n    }\n","new_comment_raw":"@return the BrowserLauncher ready to launch","old_comment_raw":"@return the BrowserLauncher ready to launch","label":0,"pre_label":1,"AST_level":13,"line_counts":30,"new_code_token_num":232},{"new_code_raw":"public final Entity getEntity() { return entity; }","old_code_raw":"public final BranchingInputStream getEntity() {\n    return entity;\n}","new_comment_raw":"@return The entity.","old_comment_raw":"@return The entity as an input stream.","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":11},{"new_code_raw":"public int yylex() throws java.io.IOException { int zzInput; int zzAction; \/\/ cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; \/\/ set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { \/\/ store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); \/\/ get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } \/\/ store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { if (DBG) System.err.printf(\"Accepting |%s|%n\", yytext()); return ACCEPT; } case 4: break; case 2: { return IGNORE; } case 5: break; case 3: { if (DBG) System.err.printf(\"Ignoring |%s|%n\", yytext()); return IGNORE; } case 6: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; return YYEOF; } else { zzScanError(ZZ_NO_MATCH); } } } }","old_code_raw":"  public int yylex() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    \/\/ cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      \/\/ set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            \/\/ store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            \/\/ get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      \/\/ store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { if (DBG) System.err.printf(\"Accepting |%s|, staying in YYINITIAL%n\", yytext());\n                          return ACCEPT;\n          }\n        case 19: break;\n        case 2: \n          { return IGNORE;\n          }\n        case 20: break;\n        case 3: \n          { reportError(yytext());\n          }\n        case 21: break;\n        case 4: \n          { if (DBG) System.err.printf(\"Ignoring |%s|, staying in YYINITIAL%n\", yytext());\n                          return IGNORE;\n          }\n        case 22: break;\n        case 5: \n          { if (DBG) System.err.printf(\"Ignoring |%s|, moving to DATETIME%n\", yytext());\n                          yybegin(DATETIME); return IGNORE;\n          }\n        case 23: break;\n        case 6: \n          { yybegin(DATEINHEADER); return IGNORE;\n          }\n        case 24: break;\n        case 7: \n          { if (DBG) System.err.printf(\"Ignoring |%s|, moving to DOCNO%n\", yytext());\n                          yybegin(DOCNO); return IGNORE;\n          }\n        case 25: break;\n        case 8: \n          { if (DBG) System.err.printf(\"Ignoring |%s|, moving to SRCID%n\", yytext());\n                          yybegin(SRCID); return IGNORE;\n          }\n        case 26: break;\n        case 9: \n          { \/\/System.err.println(\"Transitioning to YYINITIAL\");\n                   yybegin(YYINITIAL); return IGNORE;\n          }\n        case 27: break;\n        case 10: \n          { yybegin(HEADER); return IGNORE;\n          }\n        case 28: break;\n        case 11: \n          { if (DBG) System.err.printf(\"Ignoring |%s|, moving to HEADER%n\", yytext());\n                          yybegin(HEADER); return IGNORE;\n          }\n        case 29: break;\n        case 12: \n          { \/\/ System.err.println(\"Transitioning to YYINITIAL\");\n                  yybegin(YYINITIAL); return IGNORE;\n          }\n        case 30: break;\n        case 13: \n          { \/\/System.err.println(\"In SRCID; Transitioning to YYINITIAL\");\n                yybegin(YYINITIAL); return IGNORE;\n          }\n        case 31: break;\n        case 14: \n          { \/\/System.err.println(\"Transitioning to YYINITIAL\");\n                yybegin(YYINITIAL); return IGNORE;\n          }\n        case 32: break;\n        case 15: \n          { if (DBG) System.err.printf(\"Ignoring |%s|, moving to DOCTYPE%n\", yytext());\n                          yybegin(DOCTYPE); return IGNORE;\n          }\n        case 33: break;\n        case 16: \n          { if (DBG) System.err.printf(\"Ignoring |%s|, moving to PREAMBLE%n\", yytext());\n                          yybegin(PREAMBLE); return IGNORE;\n          }\n        case 34: break;\n        case 17: \n          { \/\/System.err.println(\"Transitioning to YYINITIAL\");\n                  yybegin(YYINITIAL); return IGNORE;\n          }\n        case 35: break;\n        case 18: \n          { yybegin(YYINITIAL); return IGNORE;\n          }\n        case 36: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            return YYEOF;\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n","new_comment_raw":"@return the next token","old_comment_raw":"@return the next token","label":0,"pre_label":1,"AST_level":17,"line_counts":102,"new_code_token_num":415},{"new_code_raw":"private boolean isSpillNeeded(int incomingSize) { if (bufferedBatches.size() >= config.getBufferedBatchLimit()) { return true; } \/\/ Can't spill if less than two batches else the merge \/\/ can't make progress. final boolean spillNeeded = memManager.isSpillNeeded(allocator.getAllocatedMemory(), incomingSize); if (bufferedBatches.size() < 2) { \/\/ If we can't fit the batch into memory, then place a definite error \/\/ message into the log to simplify debugging. if (spillNeeded) { logger.error(\"Insufficient memory to merge two batches. Incoming batch size: {}, available memory: {}\", incomingSize, memManager.freeMemory(allocator.getAllocatedMemory())); } return false; } return spillNeeded; }","old_code_raw":"  private boolean isSpillNeeded(int incomingSize) {\n\n    \/\/ Can't spill if less than two batches else the merge\n    \/\/ can't make progress.\n\n    if (bufferedBatches.size() < 2) {\n      return false; }\n\n    if (bufferedBatches.size() >= config.getBufferedBatchLimit()) {\n      return true; }\n    return memManager.isSpillNeeded(allocator.getAllocatedMemory(), incomingSize);\n  }\n","new_comment_raw":"@return true if spilling is needed (and possible), false otherwise","old_comment_raw":"@return true if spilling is needed, false otherwise","label":1,"pre_label":0,"AST_level":10,"line_counts":25,"new_code_token_num":145},{"new_code_raw":"public long set(long instant, int era) { Utils.verifyValueBounds(this, era, DateTimeConstants.BCE, DateTimeConstants.CE); int oldEra = get(instant); if (oldEra != era) { int year = iChronology.year().get(instant); return iChronology.year().set(instant, -year); } else { return instant; } }","old_code_raw":"    public long set(long millis, int era) {\n        super.verifyValueBounds(era, DateTimeConstants.BCE, DateTimeConstants.CE);\n            \n        int oldEra = get(millis);\n        if (oldEra != era) {\n            int year = iChronology.year().get(millis);\n            return iChronology.year().set(millis, -year);\n        } else {\n            return millis;\n        }\n    }\n","new_comment_raw":"@return the updated time instant.","old_comment_raw":"@return the updated time instant.","label":0,"pre_label":1,"AST_level":9,"line_counts":12,"new_code_token_num":71},{"new_code_raw":"private ConnectionJDBC getConnection() throws SQLException { return (ConnectionJDBC) statement.getConnection(); }","old_code_raw":"private ConnectionJDBC2 getConnection() throws SQLException {\n    return (ConnectionJDBC2) statement.getConnection();\n}","new_comment_raw":"@return {@link ConnectionJDBC} object.","old_comment_raw":"@return {@link ConnectionJDBC2} object.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":18},{"new_code_raw":"private ZapTextField getTxtProxyIp() { if (txtProxyIp == null) { txtProxyIp = new ZapTextField(); txtProxyIp.setText(\"\"); } return txtProxyIp; }","old_code_raw":"\tprivate JTextField getTxtProxyIp() {\n\t\tif (txtProxyIp == null) {\n\t\t\ttxtProxyIp = new JTextField();\n\t\t\ttxtProxyIp.setText(\"\");\n\t\t}\n\t\treturn txtProxyIp;\n\t}\n","new_comment_raw":"@return javax.swing.ZapTextField","old_comment_raw":"@return javax.swing.JTextField","label":1,"pre_label":0,"AST_level":8,"line_counts":8,"new_code_token_num":30},{"new_code_raw":"public static String getEventTypeFromMI(MIBreakpoint miBreakpoint) { if (miBreakpoint.getWhat().equals(STR)) { return EventBreakpoint.CATCH; } else if (miBreakpoint.getWhat().equals(STR)) { return EventBreakpoint.THROW; } return null; }","old_code_raw":"public static String getEventTypeFromMI(MIBreakpoint miBreakpoint) {\n    if (miBreakpoint.getWhat().equals(STR)) {\n        return Catchpoint.CATCH;\n    } else if (miBreakpoint.getWhat().equals(STR)) {\n        return Catchpoint.THROW;\n    }\n    return null;\n}","new_comment_raw":"@return null if unknown type, null cannot be used to create valid EventBreakpoint","old_comment_raw":"@return null if unknown type, null cannot be used to create valid Catchpoint","label":1,"pre_label":0,"AST_level":7,"line_counts":8,"new_code_token_num":48},{"new_code_raw":"public boolean clearReference() { return sScheduler.clearReference(this); }","old_code_raw":"    public void clearReference() {\n        sScheduler.clearReference(this);\n    }\n","new_comment_raw":"@return true if the handler wants to stay alive.","old_comment_raw":"@return true if the handler wants to stay alive.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":14},{"new_code_raw":"public Level getLevel(String logType) { return prefs.get(logType) == null ? Level.OFF : prefs.get(logType); }","old_code_raw":"  public Level getLevel(String logType) {\n    return prefs.get(logType);\n  }\n","new_comment_raw":"@return the  Level for the given  LogType if enabled. Otherwise returns  Level.OFF.","old_comment_raw":"@return the Level for the given LogType if enabled. Otherwise returns NULL.","label":1,"pre_label":0,"AST_level":7,"line_counts":4,"new_code_token_num":26},{"new_code_raw":"protected Object convertNumeric(Column column, Field fieldDefn, Object data) { return convertDecimal(column, fieldDefn, data); }","old_code_raw":"    protected Object convertNumeric(Column column, Field fieldDefn, Object data) {\n        if (data == null) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) {\n                return null;\n            }\n            else {\n                return BigDecimal.ZERO;\n            }\n        }\n        BigDecimal decimal = null;\n        if (data instanceof BigDecimal)\n            decimal = (BigDecimal) data;\n        else if (data instanceof Boolean)\n            decimal = NumberConversions.getBigDecimal((Boolean) data);\n        else if (data instanceof Short)\n            decimal = new BigDecimal(((Short) data).intValue());\n        else if (data instanceof Integer)\n            decimal = new BigDecimal(((Integer) data).intValue());\n        else if (data instanceof Long)\n            decimal = BigDecimal.valueOf(((Long) data).longValue());\n        else if (data instanceof Float)\n            decimal = BigDecimal.valueOf(((Float) data).doubleValue());\n        else if (data instanceof Double)\n            decimal = BigDecimal.valueOf(((Double) data).doubleValue());\n        else if (data instanceof SpecialValue)\n            return null;\n        else {\n            return handleUnknownData(column, fieldDefn, data);\n        }\n        return decimal;\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":25},{"new_code_raw":"public String toVarName(String name) { if (reservedWords.contains(name)) { return escapeReservedWord(name); } else if (((CharSequence) name).chars().anyMatch(character -> specialCharReplacements.keySet().contains( \"\" + ((char) character)))) { return escapeSpecialCharacters(name, null, null); } else { return name; } }","old_code_raw":"    public String toVarName(String name) {\n        if (reservedWords.contains(name)) {\n            return escapeReservedWord(name);\n        } else {\n            return name;\n        }\n    }\n","new_comment_raw":"@return the sanitized variable name","old_comment_raw":"@return the sanitized variable name","label":0,"pre_label":1,"AST_level":8,"line_counts":10,"new_code_token_num":77},{"new_code_raw":"protected EngineParameterMetaData getParameterMetaData() throws SQLException { if (stmtPmeta != null) return stmtPmeta; stmtPmeta = ((EnginePreparedStatement) ps).getEmbedParameterSetMetaData(); return stmtPmeta; }","old_code_raw":"protected EmbedParameterSetMetaData getParameterMetaData() throws SQLException {\n    if (stmtPmeta != null)\n        return stmtPmeta;\n    EmbedParameterSetMetaData pmeta = null;\n    Class[] getParameterMetaDataParam = {};\n    try {\n        Method sh = getPreparedStatement().getClass().getMethod(STR, getParameterMetaDataParam);\n        pmeta = (EmbedParameterSetMetaData) sh.invoke(getPreparedStatement(), null);\n        stmtPmeta = pmeta;\n    } catch (Exception e) {\n        handleReflectionException(e);\n    }\n    return stmtPmeta;\n}","new_comment_raw":"@return EngineParameterMetaData for the prepared statement. Note: there is no separate BrokeredParameterSetMetaData.","old_comment_raw":"@return EmbedParameterSetMetaData for the prepared statement. Note: there is no separate BrokeredParameterSetMetaData.","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":32},{"new_code_raw":"public List<Integer> getHistoryIdsOfHistType(long sessionId, int... histTypes) throws DatabaseException { return getHistoryIdsByParams(sessionId, 0, true, histTypes); }","old_code_raw":"    public List<Integer> getHistoryIdsOfHistType(long sessionId, int... histTypes) throws DatabaseException {\n        try {\n\t\t\tboolean hasHistTypes = histTypes != null && histTypes.length > 0;\n\t\t\tint strLength = hasHistTypes ? 97 : 68;\n\t\t\tStringBuilder strBuilder = new StringBuilder(strLength);\n\t\t\tstrBuilder.append(\"SELECT \").append(HISTORYID);\n\t\t\tstrBuilder.append(\" FROM \").append(TABLE_NAME).append(\" WHERE \").append(SESSIONID).append(\" = ?\");\n\t\t\tif (hasHistTypes) {\n\t\t\t    strBuilder.append(\" AND \").append(HISTTYPE).append(\" IN ( UNNEST(?) )\");\n\t\t\t}\n\t\t\tstrBuilder.append(\" ORDER BY \").append(HISTORYID);\n\n\t\t\ttry (PreparedStatement psReadSession = getConnection().prepareStatement(strBuilder.toString())) {\n\n\t\t\t    psReadSession.setLong(1, sessionId);\n\t\t\t    if (hasHistTypes) {\n\t\t\t        Array arrayHistTypes = getConnection().createArrayOf(\"INTEGER\", ArrayUtils.toObject(histTypes));\n\t\t\t        psReadSession.setArray(2, arrayHistTypes);\n\t\t\t    }\n\t\t\t    try (ResultSet rs = psReadSession.executeQuery()) {\n\t\t\t        ArrayList<Integer> ids = new ArrayList<>();\n\t\t\t        while (rs.next()) {\n\t\t\t            ids.add(rs.getInt(HISTORYID));\n\t\t\t        }\n\t\t\t        ids.trimToSize();\n\n\t\t\t        return ids;\n\t\t\t    }\n\t\t\t}\n\t\t} catch (SQLException e) {\n\t\t\tthrow new DatabaseException(e);\n\t\t}\n    }\n","new_comment_raw":"@return a  List with all the history IDs of the given session and history types, never  null","old_comment_raw":"@return a List with all the history IDs of the given session and history types, never null","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":27},{"new_code_raw":"public List<MediaType> selectHeaderAccept(String[] accepts) { if (accepts.length == 0) { return null; } for (String accept : accepts) { MediaType mediaType = MediaType.parseMediaType(accept); if (isJsonMime(mediaType)) { return Collections.singletonList(mediaType); } } return MediaType.parseMediaTypes(StringUtils.arrayToCommaDelimitedString(accepts)); }","old_code_raw":"    public List<MediaType> selectHeaderAccept(String[] accepts) {\n        if (accepts.length == 0) {\n            return null;\n        }\n        for (String accept : accepts) {\n            MediaType mediaType = MediaType.parseMediaType(accept);\n            if (isJsonMime(mediaType)) {\n                return Arrays.asList(mediaType);\n            }\n        }\n        return MediaType.parseMediaTypes(StringUtils.arrayToCommaDelimitedString(accepts));\n    }\n","new_comment_raw":"@return List The list of MediaTypes to use for the Accept header","old_comment_raw":"@return List The list of MediaTypes to use for the Accept header","label":0,"pre_label":1,"AST_level":9,"line_counts":13,"new_code_token_num":67},{"new_code_raw":"public static String asJson(Object object) throws IOException { return JSON.writeValueAsString(object); }","old_code_raw":"public static JsonNode asJson(Object object) throws IOException {\n    return JSON.writeValueAsTree(object);\n}","new_comment_raw":"@return {@code object} as a JSON string","old_comment_raw":"@return {@code object} as a JSON AST node","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":19},{"new_code_raw":"protected final Map<K, V> copyMap(Map<K, Expirable<V>> map) { ClassLoader classLoader = cacheManager.getClassLoader(); return map.entrySet().stream().collect(toMap(entry -> copier.copy(entry.getKey(), classLoader), entry -> copier.copy(entry.getValue().get(), classLoader))); }","old_code_raw":"protected final Map<K, V> copyMap(Map<K, Expirable<V>> map) {\n    ClassLoader classLoader = cacheManager.getClassLoader();\n    return map.entrySet().stream().collect(Collectors.toMap(entry -> copier.copy(entry.getKey(), classLoader), entry -> copier.copy(entry.getValue().get(), classLoader)));\n}","new_comment_raw":"@return a deep or shallow copy of the mappings depending on the store by value setting","old_comment_raw":"@return a copy of the mappings if storing by value or the same instance if by reference","label":1,"pre_label":0,"AST_level":10,"line_counts":4,"new_code_token_num":67},{"new_code_raw":"public boolean equals(Object obj) { if (this == obj) { return true; } else if (obj instanceof UnsupportedDurationField) { UnsupportedDurationField other = (UnsupportedDurationField) obj; if (other.getName() == null) { return (getName() == null); } return (other.getName().equals(getName())); } return false; }","old_code_raw":"    public boolean equals(Object obj) {\n        if (obj instanceof UnsupportedDurationField) {\n            return (((UnsupportedDurationField) obj).getName().equals(getName()));\n        }\n        return false;\n    }\n","new_comment_raw":"@return true if equal","old_comment_raw":"@return true if equal","label":0,"pre_label":1,"AST_level":10,"line_counts":13,"new_code_token_num":70},{"new_code_raw":"public Set<TSentryRole> getTSentryRolesByGroupName(final Set<String> groupNames, final boolean checkAllGroups) throws Exception { if (groupNames.isEmpty()) { return Collections.emptySet(); } return tm.executeTransaction(new TransactionBlock<Set<TSentryRole>>() { @Override public Set<TSentryRole> execute(PersistenceManager pm) throws Exception { pm.setDetachAllOnCommit(false); Set<String> roleNames = new HashSet<>(NUM); Set<TSentryRole> result = new HashSet<>(NUM); for (String group : groupNames) { if (group == null) { List<MSentryRole> roles = getAllRoles(pm); for (MSentryRole role : roles) { result.add(convertToTSentryRole(role)); } return result; } String trimmedGroup = group.trim(); Query query = pm.newQuery(MSentryGroup.class); query.setFilter(STR); query.setUnique(true); MSentryGroup mGroup = (MSentryGroup) query.execute(trimmedGroup); if (mGroup != null) { for (MSentryRole role : mGroup.getRoles()) { String roleName = role.getRoleName(); if (roleNames.add(roleName)) { result.add(convertToTSentryRole(role)); } } } else if (!checkAllGroups) { throw noSuchGroup(trimmedGroup); } query.closeAll(); } return result; } }); }","old_code_raw":"public Set<TSentryRole> getTSentryRolesByGroupName(Set<String> groupNames, boolean checkAllGroups) throws Exception {\n    Set<MSentryRole> roleSet = Sets.newHashSet();\n    for (String groupName : groupNames) {\n        try {\n            roleSet.addAll(getMSentryRolesByGroupName(groupName));\n        } catch (SentryNoSuchObjectException e) {\n            if (!checkAllGroups) {\n                throw e;\n            }\n        }\n    }\n    return convertToTSentryRoles(roleSet);\n}","new_comment_raw":"@return Set of TSentryRole toles corresponding to the given set of groups.","old_comment_raw":"@return : Set of thrift sentry role objects","label":1,"pre_label":0,"AST_level":18,"line_counts":40,"new_code_token_num":237},{"new_code_raw":"public String toExampleValue(Property p) { if(p.getExample() != null) { return p.getExample().toString(); } if (p instanceof StringProperty) { return \"null\"; } else if (p instanceof BooleanProperty) { return \"null\"; } else if (p instanceof DateProperty) { return \"null\"; } else if (p instanceof DateTimeProperty) { return \"null\"; } else if (p instanceof DoubleProperty) { DoubleProperty dp = (DoubleProperty) p; if (dp.getExample() != null) { return dp.getExample().toString(); } return \"null\"; } else if (p instanceof FloatProperty) { FloatProperty dp = (FloatProperty) p; if (dp.getExample() != null) { return dp.getExample().toString(); } return \"null\"; } else if (p instanceof IntegerProperty) { IntegerProperty dp = (IntegerProperty) p; if (dp.getExample() != null) { return dp.getExample().toString(); } return \"null\"; } else if (p instanceof LongProperty) { LongProperty dp = (LongProperty) p; if (dp.getExample() != null) { return dp.getExample().toString(); } return \"null\"; } else { return \"null\"; } }","old_code_raw":"    public String toExampleValue(Property p) {\n        if (p instanceof StringProperty) {\n            return \"null\";\n        } else if (p instanceof BooleanProperty) {\n            return \"null\";\n        } else if (p instanceof DateProperty) {\n            return \"null\";\n        } else if (p instanceof DateTimeProperty) {\n            return \"null\";\n        } else if (p instanceof DoubleProperty) {\n            DoubleProperty dp = (DoubleProperty) p;\n            if (dp.getExample() != null) {\n                return dp.getExample().toString();\n            }\n            return \"null\";\n        } else if (p instanceof FloatProperty) {\n            FloatProperty dp = (FloatProperty) p;\n            if (dp.getExample() != null) {\n                return dp.getExample().toString();\n            }\n            return \"null\";\n        } else if (p instanceof IntegerProperty) {\n            IntegerProperty dp = (IntegerProperty) p;\n            if (dp.getExample() != null) {\n                return dp.getExample().toString();\n            }\n            return \"null\";\n        } else if (p instanceof LongProperty) {\n            LongProperty dp = (LongProperty) p;\n            if (dp.getExample() != null) {\n                return dp.getExample().toString();\n            }\n            return \"null\";\n        } else {\n            return \"null\";\n        }\n    }\n","new_comment_raw":"@return string presentation of the example value of the property","old_comment_raw":"@return string presentation of the example value of the property","label":0,"pre_label":1,"AST_level":16,"line_counts":41,"new_code_token_num":256},{"new_code_raw":"public ConciseSet evaluate(TupleFilter filter) { if (filter == null) return null; if (filter instanceof LogicalTupleFilter) return evalLogical((LogicalTupleFilter) filter); if (filter instanceof CompareTupleFilter) return evalCompare((CompareTupleFilter) filter); if (filter instanceof ConstantTupleFilter) { if (!filter.evaluate(null, null)) { return new ConciseSet(); } } return null; \/\/ unable to evaluate }","old_code_raw":"    public ConciseSet evaluate(TupleFilter filter) {\n        if (filter == null)\n            return null;\n\n        if (filter instanceof LogicalTupleFilter)\n            return evalLogical((LogicalTupleFilter) filter);\n\n        if (filter instanceof CompareTupleFilter)\n            return evalCompare((CompareTupleFilter) filter);\n\n        return null; \/\/ unable to evaluate\n    }\n","new_comment_raw":"@return a set of records that match the filter; or null if filter is null or unable to evaluate","old_comment_raw":"@return a set of records that match the filter; or null if filter is null or unable to evaluate","label":0,"pre_label":1,"AST_level":9,"line_counts":19,"new_code_token_num":82},{"new_code_raw":"protected SqlSelect createSourceSelectForDelete(SqlDelete call) { final SqlNodeList selectList = new SqlNodeList(SqlParserPos.ZERO); selectList.add(SqlIdentifier.star(SqlParserPos.ZERO)); SqlNode sourceTable = call.getTargetTable(); if (call.getAlias() != null) { sourceTable = SqlValidatorUtil.addAlias( sourceTable, call.getAlias().getSimple()); } return new SqlSelect(SqlParserPos.ZERO, null, selectList, sourceTable, call.getCondition(), null, null, null, null, null, null, null); }","old_code_raw":"  protected SqlSelect createSourceSelectForDelete(SqlDelete call) {\n    final SqlNodeList selectList = new SqlNodeList(SqlParserPos.ZERO);\n    selectList.add(SqlIdentifier.star(SqlParserPos.ZERO));\n    SqlNode sourceTable = call.getTargetTable();\n    if (call.getAlias() != null) {\n      sourceTable =\n          SqlValidatorUtil.addAlias(\n              sourceTable,\n              call.getAlias().getSimple());\n    }\n    return new SqlSelect(SqlParserPos.ZERO, null, selectList, sourceTable,\n        call.getCondition(), null, null, null, null, null, null);\n  }\n","new_comment_raw":"@return select statement","old_comment_raw":"@return select statement","label":0,"pre_label":1,"AST_level":9,"line_counts":14,"new_code_token_num":96},{"new_code_raw":"public IncidentsTask createReportsTask() { return new IncidentsTask(url); }","old_code_raw":"public ReportsTask createReportsTask() {\n    return new ReportsTask(url);\n}","new_comment_raw":"@return The incidents task","old_comment_raw":"@return The report task","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":14},{"new_code_raw":"public T setMinDecodeIntervalMs(int intervalMs) { mMinDecodeIntervalMs = intervalMs; return getThis(); }","old_code_raw":"  public ImageDecodeOptionsBuilder setMinDecodeIntervalMs(int intervalMs) {\n    mMinDecodeIntervalMs = intervalMs;\n    return this;\n  }\n","new_comment_raw":"@return this builder","old_comment_raw":"@return this builder","label":0,"pre_label":1,"AST_level":5,"line_counts":5,"new_code_token_num":17},{"new_code_raw":"public long getId() { return id; }","old_code_raw":"  public int getId() {\n    return id;\n  }\n","new_comment_raw":"@return integer id","old_comment_raw":"@return integer id","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"public JSONArray getJSONArray(String key) { Object object = this.get(key); if (object == null) { return null; } if (object instanceof JSONArray) { return (JSONArray) object; } throw new RuntimeException(STR + quote(key) + STR); }","old_code_raw":"public JSONArray getJSONArray(String key) {\n    Object object = this.get(key);\n    if (object instanceof JSONArray) {\n        return (JSONArray) object;\n    }\n    throw new RuntimeException(STR + quote(key) + STR);\n}","new_comment_raw":"@return A JSONArray which is the value, or null if not present","old_comment_raw":"@return A JSONArray which is the value.","label":1,"pre_label":0,"AST_level":8,"line_counts":10,"new_code_token_num":55},{"new_code_raw":"private ZapTextField getTxtFind() { if (txtFind == null) { txtFind = new ZapTextField(); txtFind.setMinimumSize(new java.awt.Dimension(120,24)); txtFind.setPreferredSize(new java.awt.Dimension(120,24)); } return txtFind; }","old_code_raw":"\tprivate JTextField getTxtFind() {\n\t\tif (txtFind == null) {\n\t\t\ttxtFind = new JTextField();\n\t\t\ttxtFind.setMinimumSize(new java.awt.Dimension(120,24));\n\t\t\ttxtFind.setPreferredSize(new java.awt.Dimension(120,24));\n\t\t}\n\t\treturn txtFind;\n\t}\n","new_comment_raw":"@return javax.swing.ZapTextField","old_comment_raw":"@return javax.swing.JTextField","label":1,"pre_label":0,"AST_level":10,"line_counts":9,"new_code_token_num":51},{"new_code_raw":"public static fb_status findByValue(int value) { switch (value) { case 0: return DEAD; case 1: return STARTING; case 2: return ALIVE; case 3: return STOPPING; case 4: return STOPPED; case 5: return WARNING; default: return null; } }","old_code_raw":"  public static fb_status findByValue(int value) { \n    return BY_VALUE.get(value);\n  }\n","new_comment_raw":"@return null if the value is not found.","old_comment_raw":"@return null if the value is not found.","label":0,"pre_label":1,"AST_level":6,"line_counts":19,"new_code_token_num":57},{"new_code_raw":"public boolean searchForText(String regex, int matches, boolean scroll) { sleeper.sleep(); inst.waitForIdleSync(); Pattern p = Pattern.compile(regex); Matcher matcher; ArrayList<TextView> textViewList = viewFetcher.getCurrentViews(TextView.class); if(matches == 0) matches = 1; for(TextView textView : textViewList){ matcher = p.matcher(textView.getText().toString()); if(matcher.find()){ countMatches++; } if (countMatches == matches) { countMatches=0; return true; } } if (scroll && scroller.scroll(Scroller.Direction.DOWN)) { return searchForText(regex, matches, scroll); } else { if (countMatches > 0) Log.d(LOG_TAG, \" There are only \" + countMatches + \" matches of \" + regex); countMatches=0; return false; } }","old_code_raw":"\tpublic boolean searchForText(String search, int matches, boolean scroll) {\n\t\tsleeper.sleep();\n\t\tinst.waitForIdleSync();\n\t\tPattern p = Pattern.compile(search);\n\t\tMatcher matcher;\n\t\tArrayList<TextView> textViewList = viewFetcher.getCurrentViews(TextView.class);\n\t\tif(matches == 0)\n\t\t\tmatches = 1;\n\t\tfor(TextView textView : textViewList){\n\t\t\tmatcher = p.matcher(textView.getText().toString());\n\t\t\tif(matcher.find()){\t\n\t\t\t\tcountMatches++;\n\t\t\t}\n\t\t\tif (countMatches == matches) {\n\t\t\t\tcountMatches=0;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tif (scroll && scroller.scroll(Scroller.Direction.DOWN)) {\n\t\t\treturn searchForText(search, matches, scroll);\n\t\t} else {\n\t\t\tif (countMatches > 0)\n\t\t\t\tLog.d(LOG_TAG, \" There are only \" + countMatches + \" matches of \" + search);\n\t\t\tcountMatches=0;\n\t\t\treturn false;\n\t\t}\n\t\t\n\t}\n","new_comment_raw":"@return true if regex string is found a given number of times and false if the regex string is not found","old_comment_raw":"@return true if search string is found a given number of times and false if the search string is not found","label":1,"pre_label":0,"AST_level":11,"line_counts":30,"new_code_token_num":162},{"new_code_raw":"public Object next() throws java.io.IOException { int zzInput; int zzAction; \/\/ cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; \/\/ set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { \/\/ store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); \/\/ get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } \/\/ store back cached position zzMarkedPos = zzMarkedPosL; if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { String str = yytext(); int first = str.codePointAt(0); String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } logger.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: logger.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 67: break; case 2: { return getNext(\"<\", yytext()); } case 68: break; case 3: { return getNext(); } case 69: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 70: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 71: break; case 6: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 72: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 73: break; case 8: { return handleQuotes(yytext(), false); } case 74: break; case 9: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 75: break; case 10: { return getNext(\">\", yytext()); } case 76: break; case 11: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 77: break; case 12: { handleHyphenatedNumber(yytext()); return getNext(removeFromNumber(yytext()), yytext()); } case 78: break; case 13: { return handleEllipsis(yytext()); } case 79: break; case 14: { return normalizeFractions(yytext()); } case 80: break; case 15: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(minimallyNormalizeCurrency(yytext()), yytext()); } } case 81: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 82: break; case 17: { if (normalizeOtherBrackets) { return getNext(\"-RSB-\", yytext()); } else { return getNext(); } } case 83: break; case 18: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 84: break; case 19: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 85: break; case 20: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 86: break; case 21: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 87: break; case 22: { if (normalizeOtherBrackets) { return getNext(\"-LSB-\", yytext()); } else { return getNext(); } } case 88: break; case 23: { if (invertible) { prevWordAfter.append(yytext()); } } case 89: break; case 24: { return getNext(\"\\u2022\", yytext()); } case 90: break; case 25: { return getNext(\"\\u2122\", yytext()); } case 91: break; case 26: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 92: break; case 27: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(); } case 93: break; case 28: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return handleQuotes(yytext(), true); } case 94: break; case 29: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 95: break; case 30: { breakByHyphens(yytext()); return getNext(removeSoftHyphens(yytext()), yytext()); } case 96: break; case 31: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 97: break; case 32: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 98: break; case 33: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 99: break; case 34: { \/\/ this one should only match if we're basically at the end of file \/\/ since the last one matches two things, even newlines (if not tokenize per line) String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 100: break; case 35: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 101: break; case 36: \/\/ lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 1); { \/* invert quote - often but not always right *\/ return handleQuotes(yytext(), true); } case 102: break; case 37: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return handleQuotes(yytext(), false); } case 103: break; case 38: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 104: break; case 39: { String txt = yytext(); \/\/ if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space... if (strictTreebank3) { int spaceIndex = indexOfSpace(txt); if (spaceIndex >= 0) { yypushback(txt.length() - spaceIndex); String newText = yytext(); return getNext(newText, newText); } } if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, txt); } case 105: break; case 40: { return getNormalizedAmpNext(); } case 106: break; case 41: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, origTxt); } case 107: break; case 42: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space } return getNext(txt, origTxt); } case 108: break; case 43: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 109: break; case 44: { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 110: break; case 45: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 17; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 111: break; case 46: \/\/ lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 112: break; case 47: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 113: break; case 48: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 22; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 114: break; case 49: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 18; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 19; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 115: break; case 50: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 116: break; case 51: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 21; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 117: break; case 52: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 118: break; case 53: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { breakByHyphens(yytext()); return getNext(removeSoftHyphens(yytext()), yytext()); } case 119: break; case 54: { if (splitAssimilations) { yypushback(3) ; return getNext(); } else { return getNext(); } } case 120: break; case 55: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNormalizedAmpNext(); } case 121: break; case 56: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 9; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 122: break; case 57: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { return getNext(); } case 123: break; case 58: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 124: break; case 59: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 125: break; case 60: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 13; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 126: break; case 61: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } return getNext(txt, yytext()); } case 127: break; case 62: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4); { return getNext(); } case 128: break; case 63: \/\/ lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { return getNext(); } case 129: break; case 64: { String txt = yytext(); if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 130: break; case 65: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 25; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 131: break; case 66: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 24; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 132: break; default: zzScanError(ZZ_NO_MATCH); } } } }","old_code_raw":"  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    \/\/ cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      \/\/ set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            \/\/ store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            \/\/ get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      \/\/ store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n        zzAtEOF = true;\n              {\n                if (invertible) {\n            \/\/ prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            \/\/ System.err.println(\"At end of text making after: |\" + str + \"|\");\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n            \/\/ System.err.println(\"prevWord is |\" + prevWord.get(CoreAnnotations.TextAnnotation.class) + \"|, its after is |\" +\n            \/\/         prevWord.get(CoreAnnotations.AfterAnnotation.class) + \"|\");\n            prevWordAfter.setLength(0);\n          }\n          return null;\n              }\n      }\n      else {\n        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n          case 1: \n            { String str = yytext();\n          int first = str.codePointAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\",\n                          yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n            }\n          case 74: break;\n          case 2: \n            { return getNext(\"<\", yytext());\n            }\n          case 75: break;\n          case 3: \n            { return getNext();\n            }\n          case 76: break;\n          case 4: \n            { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n            }\n          case 77: break;\n          case 5: \n            { if (tokenizeNLs) {\n                      return getNext(AbstractTokenizer.NEWLINE_TOKEN, yytext()); \/\/ for tokenizing newliens\n                  } else if (invertible) {\n                    \/\/ System.err.println(\"Appending newline: |\" + yytext() + \"|\");\n                    prevWordAfter.append(yytext());\n                  }\n            }\n          case 78: break;\n          case 6: \n            { final String origTxt = yytext();\n                          String tok = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tok = Americanize.americanize(tok);\n                          }\n                          if (DEBUG) { logger.info(\"Used {WORD} (2) to recognize \" + origTxt + \" as \" + tok +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(tok, origTxt);\n            }\n          case 79: break;\n          case 7: \n            { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n            }\n          case 80: break;\n          case 8: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} (3) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 81: break;\n          case 9: \n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 82: break;\n          case 10: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '\/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 83: break;\n          case 11: \n            { return getNext(\">\", yytext());\n            }\n          case 84: break;\n          case 12: \n            { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n            }\n          case 85: break;\n          case 13: \n            { handleHyphenatedNumber(yytext());\n                          if (DEBUG) { logger.info(\"Used {NUMBER} to recognize \" + yytext() + \" as \" + removeFromNumber(yytext())); }\n                          return getNext(removeFromNumber(yytext()), yytext());\n            }\n          case 86: break;\n          case 14: \n            { return handleEllipsis(yytext());\n            }\n          case 87: break;\n          case 15: \n            { \/\/ breakByHyphens(yytext()); \/\/ this is causing fail of attempted to pushback too much!\n                  String tok = yytext();\n                  \/* A THING can contain quote like O'Malley *\/\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {THING} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 88: break;\n          case 16: \n            { String txt = yytext();\n                  String norm = normalizeFractions(yytext());\n                  if (DEBUG) { logger.info(\"Used {FRAC2} to recognize \" + txt + \" as \" + norm +\n                                       \"; normalizeFractions=\" + normalizeFractions +\n                                       \", escapeForwardSlashAsterisk=\" + escapeForwardSlashAsterisk); }\n                  return getNext(norm, txt);\n            }\n          case 89: break;\n          case 17: \n            { if (normalizeCurrency) {\n                            return getNext(normalizeCurrency(yytext()), yytext());\n                        } else {\n                            return getNext(minimallyNormalizeCurrency(yytext()), yytext());\n                          }\n            }\n          case 90: break;\n          case 18: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-RSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 91: break;\n          case 19: \n            { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 92: break;\n          case 20: \n            { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 93: break;\n          case 21: \n            { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 94: break;\n          case 22: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 95: break;\n          case 23: \n            { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 96: break;\n          case 24: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-LSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 97: break;\n          case 25: \n            { String tok = yytext();\n                        String norm = processCp1252misc(tok);\n                        if (DEBUG) { logger.info(\"Used {CP1252_MISC_SYMBOL} to recognize \" + tok + \" as \" + norm); }\n                        return getNext(norm, tok);\n            }\n          case 98: break;\n          case 26: \n            { if (invertible) {\n                            prevWordAfter.append(yytext());\n                        }\n            }\n          case 99: break;\n          case 27: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 15;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 100: break;\n          case 28: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext();\n            }\n          case 101: break;\n          case 29: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {REDAUX} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 102: break;\n          case 30: \n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {APOWORD} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 103: break;\n          case 31: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                                   String norm = handleQuotes(tok, true);\n                                   if (DEBUG) { logger.info(\"Used {DBLQUOT} to recognize \" + tok + \" as \" + norm +\n                                                            \"; probablyLeft=\" + true); }\n                                   return getNext(norm, tok);\n            }\n          case 104: break;\n          case 32: \n            { String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {PROG_LANGS} to recognize \" + tok + \" as \" + tok); }\n                    return getNext(tok, tok);\n            }\n          case 105: break;\n          case 33: \n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 106: break;\n          case 34: \n            { breakByHyphens(yytext());\n                  if (DEBUG) { logger.info(\"Used {HTHING} to recognize \" + yytext() + \" as \" + removeSoftHyphens(yytext())); }\n                  return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 107: break;\n          case 35: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 3;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 4;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String origTxt = yytext();\n                          String tok = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tok = Americanize.americanize(tok);\n                          }\n                          if (DEBUG) { logger.info(\"Used {WORD} to recognize \" + origTxt + \" as \" + tok +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(tok, origTxt);\n            }\n          case 108: break;\n          case 36: \n            { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '\/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 109: break;\n          case 37: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 110: break;\n          case 38: \n            { \/\/ this one should only match if we're basically at the end of file\n                          \/\/ since the last one matches two things, even newlines (if not tokenize per line)\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n                          return getNext(s, yytext());\n            }\n          case 111: break;\n          case 39: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 112: break;\n          case 40: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { \/\/ Extra context is to not match on ones like 'd but you do want words like \"a\"\n                  \/\/ can't have digit here because of cases like '90s\n                  String tok = yytext();\n                  \/* invert single quote - often but not always right *\/\n                  String norm = handleQuotes(tok, true);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + true); }\n                  return getNext(norm, tok);\n            }\n          case 113: break;\n          case 41: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {REDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 114: break;\n          case 42: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { \/\/ Extra context is to not match on ones like 'd but you do want words like \"a\"\n                  \/\/ can't have digit here because of cases like '90s\n                  String tok = yytext();\n                  \/* invert single quote - often but not always right *\/\n                  String norm = handleQuotes(tok, true);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + true); }\n                  return getNext(norm, tok);\n            }\n          case 115: break;\n          case 43: \n            { return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 116: break;\n          case 44: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {SREDAUX} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 117: break;\n          case 45: \n            { if (splitAssimilations) {\n                      yypushback(2);\n                    }\n                    String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {ASSIMILATIONS3} to recognize \" + tok + \" as \" + tok +\n                            \"; splitAssimilations=\" + splitAssimilations); }\n                    return getNext(tok, tok);\n            }\n          case 118: break;\n          case 46: \n            { String txt = yytext();\n                  \/\/ if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space...\n                  if (strictTreebank3) {\n                    int spaceIndex = indexOfSpace(txt);\n                    if (spaceIndex >= 0) {\n                      yypushback(txt.length() - spaceIndex);\n                      return getNext();\n                    }\n                  }\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '\/');\n                  }\n                  if (normalizeSpace) {\n                    txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                  }\n                  return getNext(txt, yytext());\n            }\n          case 119: break;\n          case 47: \n            { return getNormalizedAmpNext();\n            }\n          case 120: break;\n          case 48: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 121: break;\n          case 49: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 122: break;\n          case 50: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 5;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 6;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String txt = yytext();\n                          return getNext(removeSoftHyphens(txt),\n                                         txt);\n            }\n          case 123: break;\n          case 51: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 17;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 124: break;\n          case 52: \n            { String txt = yytext();\n                  String normTok = txt;\n                  if (escapeForwardSlashAsterisk) {\n                    normTok = delimit(normTok, '*');\n                  }\n                  if (DEBUG) { logger.info(\"Used {SWEARING} to recognize \" + txt + \" as \" + normTok); }\n                  return getNext(normTok, txt);\n            }\n          case 125: break;\n          case 53: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 126: break;\n          case 54: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 10;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 127: break;\n          case 55: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 22;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 128: break;\n          case 56: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 18;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 19;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 129: break;\n          case 57: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 10;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 130: break;\n          case 58: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 21;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 131: break;\n          case 59: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 132: break;\n          case 60: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                  breakByHyphens(tok);\n                  tok = yytext();\n                  String norm = removeSoftHyphens(tok);\n                  if (DEBUG) { logger.info(\"Used {HTHING} (2) to recognize \" + tok + \" as \" + norm); }\n                  return getNext(norm, tok);\n            }\n          case 133: break;\n          case 61: \n            { if (splitAssimilations) {\n                      yypushback(3);\n                    }\n                    String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {ASSIMILATIONS3} to recognize \" + tok + \" as \" + tok +\n                            \"; splitAssimilations=\" + splitAssimilations); }\n                    return getNext(tok, tok);\n            }\n          case 134: break;\n          case 62: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNormalizedAmpNext();\n            }\n          case 135: break;\n          case 63: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 9;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 136: break;\n          case 64: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { return getNext();\n            }\n          case 137: break;\n          case 65: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 14;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 138: break;\n          case 66: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 8;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 139: break;\n          case 67: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 13;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 140: break;\n          case 68: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 141: break;\n          case 69: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4);\n            { return getNext();\n            }\n          case 142: break;\n          case 70: \n            \/\/ lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);\n            { return getNext();\n            }\n          case 143: break;\n          case 71: \n            { String txt = yytext();\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          if (DEBUG) { logger.info(\"Used {PHONE} to recognize \" + yytext() + \" as \" + txt); }\n                          return getNext(txt, yytext());\n            }\n          case 144: break;\n          case 72: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 23;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 25;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 145: break;\n          case 73: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 23;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 24;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 146: break;\n          default:\n            zzScanError(ZZ_NO_MATCH);\n        }\n      }\n    }\n  }\n","new_comment_raw":"@return the next token","old_comment_raw":"@return the next token","label":0,"pre_label":1,"AST_level":19,"line_counts":966,"new_code_token_num":6274},{"new_code_raw":"@Override public Refactoring getParent() { return this.parent; }","old_code_raw":"@Override\npublic EmfRefactoring getParent() {\n    return this.parent;\n}","new_comment_raw":"@return Refactoring supported by the controller.","old_comment_raw":"@return EmfRefactoring supported by the controller.","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":13},{"new_code_raw":"public <V extends Visitor<? super X>> V visit(V visitor) { for (X x : this) { visitor.visit(x); } return visitor; }","old_code_raw":"public <P extends Visitor<? super X>> P visit(P predicate) {\n    for (X x : this) {\n        predicate.visit(x);\n    }\n    return predicate;\n}","new_comment_raw":"@return {@code visitor}","old_comment_raw":"@return {@code predicate}","label":1,"pre_label":0,"AST_level":7,"line_counts":6,"new_code_token_num":33},{"new_code_raw":"public AggregateCall copy(List<Integer> args, int filterArg) { return new AggregateCall(aggFunction, distinct, args, filterArg, type, name); }","old_code_raw":"  public AggregateCall copy(List<Integer> args) {\n    return new AggregateCall(aggFunction, distinct, args, type, name);\n  }\n","new_comment_raw":"@return AggregateCall that suits new inputs and GROUP BY columns","old_comment_raw":"@return AggregateCall that suits new inputs and GROUP BY columns","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":30},{"new_code_raw":"public PendingMessageCursor getSubscriberPendingMessageCursor(Broker broker,String clientId, String name, int maxBatchSize, Subscription sub) { StoreDurableSubscriberCursor cursor = new StoreDurableSubscriberCursor(broker,clientId, name, maxBatchSize, sub); cursor.setImmediatePriorityDispatch(isImmediatePriorityDispatch()); return cursor; }","old_code_raw":"    public PendingMessageCursor getSubscriberPendingMessageCursor(Broker broker,String clientId, String name, int maxBatchSize, Subscription sub) {\n        return new StoreDurableSubscriberCursor(broker,clientId, name, maxBatchSize, sub);\n    }\n","new_comment_raw":"@return the Pending Message cursor","old_comment_raw":"@return the Pending Message cursor","label":0,"pre_label":1,"AST_level":6,"line_counts":6,"new_code_token_num":48},{"new_code_raw":"public static final Weblogger getRoller() { if (rollerInstance == null) { throw new IllegalStateException(STR); } return rollerInstance; }","old_code_raw":"public static final Roller getRoller() {\n    if (rollerInstance == null) {\n        throw new IllegalStateException(STR);\n    }\n    return rollerInstance;\n}","new_comment_raw":"@return Weblogger An instance of Weblogger.","old_comment_raw":"@return Roller An instance of Roller.","label":1,"pre_label":0,"AST_level":7,"line_counts":6,"new_code_token_num":26},{"new_code_raw":"public DurationField months() { return UnsupportedDurationField.getInstance(DurationFieldType.months()); }","old_code_raw":"    public DurationField months() {\n        return UnsupportedDurationField.getInstance(\"months\");\n    }\n","new_comment_raw":"@return DurationField or UnsupportedDurationField if unsupported","old_comment_raw":"@return DurationField or UnsupportedDurationField if unsupported","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":17},{"new_code_raw":"protected Object convertTimeToMillisPastMidnight(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0; \/\/ return epoch } try { return Time.toMilliOfDay(data); } catch (IllegalArgumentException e) { return handleUnknownData(column, fieldDefn, data); } }","old_code_raw":"    protected Object convertTimeToMillisPastMidnight(Column column, Field fieldDefn, Object data) {\n        if ( data == null ) return null;\n        try {\n            return Time.toMilliOfDay(data);\n        } catch (IllegalArgumentException e) {\n            return handleUnknownData(column, fieldDefn, data);\n        }\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made","label":1,"pre_label":0,"AST_level":8,"line_counts":15,"new_code_token_num":82},{"new_code_raw":"public TraversalControl visitDocument(Document node, TraverserContext<Node> context) { Document changedNode = node.transform(builder -> { List<Definition> definitions = sort(node.getDefinitions(), comparingDefinitions()); builder.definitions(definitions); }); return changeNode(context, changedNode); }","old_code_raw":"            public TraversalControl visitDocument(Document node, TraverserContext<Node> context) {\n                Document changedNode = node.transform(builder -> {\n                    List<Definition> definitions = sort(node.getDefinitions(), comparingDefinitions());\n                    builder.definitions(definitions);\n                });\n                return newNode(context, changedNode);\n            }\n","new_comment_raw":"@return a new sorted node (because  graphql.language.Nodes are immutable)","old_comment_raw":"@return a new sorted node (because graphql.language.Nodes are immutable)","label":0,"pre_label":1,"AST_level":10,"line_counts":8,"new_code_token_num":53},{"new_code_raw":"private static File getKylinPropertiesFile(String path) { if (path == null) return null; File propFile = new File(path, KYLIN_CONF_PROPERTIES_FILE); if (propFile.exists()) { logger.info(KYLIN_CONF_PROPERTIES_FILE + \" was found at \" + propFile.getAbsolutePath()); } logger.info(KYLIN_CONF_PROPERTIES_FILE + \" was NOT found at \" + propFile.getAbsolutePath()); return null; }","old_code_raw":"    private static File getKylinPropertiesFile(String path, String env) {\n        File dir = new File(path);\n        System.out.println(dir.getAbsolutePath());\n        if (dir.exists() && dir.isDirectory()) {\n            File propFile = new File(dir, KYLIN_CONF_PROPERTIES_FILE);\n            String fName = KYLIN_CONF_PROPERTIES_FILE;\n            File envPropFile = null;\n            if (env != null) {\n                fName = fName.replace(\".\", \"_\" + env + \".\");\n                envPropFile = new File(dir, fName);\n            }\n            if (envPropFile != null && envPropFile.exists()) {\n                logger.info(fName + \" found in \" + path);\n                return envPropFile;\n            }\n            if (propFile != null && propFile.exists()) {\n                logger.info(KYLIN_CONF_PROPERTIES_FILE + \" found in \" + path);\n                return propFile;\n            }\n        }\n        return null;\n    }\n","new_comment_raw":"@return the properties file","old_comment_raw":"@return the properties file","label":0,"pre_label":1,"AST_level":9,"line_counts":13,"new_code_token_num":75},{"new_code_raw":"@Override public int hashCode() { int hash = NUM; hash = hash * NUM + ((mGroupId == null) ? NUM : mGroupId.hashCode()); hash = hash * NUM + mPwPairs.hashCode(); return hash; }","old_code_raw":"@Override\npublic int hashCode() {\n    assert false : STR;\n    return NUM;\n}","new_comment_raw":"@return hash code","old_comment_raw":"@return 42.","label":1,"pre_label":0,"AST_level":8,"line_counts":7,"new_code_token_num":45},{"new_code_raw":"protected TokenResponse executeRefreshToken() throws IOException { if (refreshToken == null) { return null; } return new RefreshTokenRequest(transport, jsonFactory, new GenericUrl(tokenServerEncodedUrl), refreshToken).setClientAuthentication(clientAuthentication).setRequestInitializer(requestInitializer).execute(); }","old_code_raw":"protected TokenResponse executeRefreshToken() throws IOException {\n    return new RefreshTokenRequest(transport, jsonFactory, new GenericUrl(tokenServerEncodedUrl), refreshToken).setClientAuthentication(clientAuthentication).setRequestInitializer(requestInitializer).execute();\n}","new_comment_raw":"@return successful response from the token server or {@code null} if it is not possible to refresh the access token","old_comment_raw":"@return whether a new access token was successfully retrieved","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":47},{"new_code_raw":"public int size() { return data.length(); }","old_code_raw":"    public int size() {\n        return data.size();\n    }\n","new_comment_raw":"@return the value of the count field, which is the number of valid bytes in this output stream.","old_comment_raw":"@return the value of the count field, which is the number of valid bytes in this output stream.","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":13},{"new_code_raw":"public LocalDate getDate() { return date; }","old_code_raw":"    public Date getDate() {\n        return date;\n    }\n","new_comment_raw":"@return date","old_comment_raw":"@return date","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"public FxValue getDefaultValue() { if (defaultValue == null) defaultValue = getEmptyValue(); return defaultValue; }","old_code_raw":"public FxString getDefaultValue() {\n    return defaultValue;\n}","new_comment_raw":"@return default value","old_comment_raw":"@return default value as string representation","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":20},{"new_code_raw":"public Throwable initCause(Throwable cause) { return super.initCause(cause); }","old_code_raw":"public Throwable initCause(Throwable cause) {\n    throw new IllegalStateException();\n}","new_comment_raw":"@return This exception.","old_comment_raw":"@return This object.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":16},{"new_code_raw":"public static StringTemplate stringTemplate(Template template, ImmutableList<?> args) { return new StringTemplate(template, args); }","old_code_raw":"    public static StringTemplate stringTemplate(Template template, ImmutableList<?> args) {\n        return new StringTemplate(template, ImmutableList.copyOf(args));\n    }\n","new_comment_raw":"@return template expression","old_comment_raw":"@return template expression","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":23},{"new_code_raw":"static boolean observe(@Nullable final Object object) { return !(object instanceof ComponentObservable) || asComponentObservable(object).observe(); }","old_code_raw":"static boolean observe(@Nonnull final Object object) {\n    return asComponentObservable(object).observe();\n}","new_comment_raw":"@return false if the component is not disposing or disposed, true otherwise.","old_comment_raw":"@return true if the component is \"alive\" a.k.a. not disposing or disposed.","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":29},{"new_code_raw":"public Response serve(IHTTPSession session) { Map<String, String> files = new HashMap<String, String>(); Method method = session.getMethod(); if (Method.PUT.equals(method) || Method.POST.equals(method)) { try { session.parseBody(files); } catch (IOException ioe) { return Response.newFixedLengthResponse(Status.INTERNAL_ERROR, NanoHTTPD.MIME_PLAINTEXT, STR + ioe.getMessage()); } catch (ResponseException re) { return Response.newFixedLengthResponse(re.getStatus(), NanoHTTPD.MIME_PLAINTEXT, re.getMessage()); } } Map<String, String> parms = session.getParms(); parms.put(NanoHTTPD.QUERY_STRING_PARAMETER, session.getQueryParameterString()); return serve(session.getUri(), method, session.getHeaders(), parms, files); }","old_code_raw":"@Deprecated\nprotected Response serve(IHTTPSession session) {\n    return Response.newFixedLengthResponse(Status.NOT_FOUND, NanoHTTPD.MIME_PLAINTEXT, STR);\n}","new_comment_raw":"@return HTTP response, see class Response for details","old_comment_raw":"@return A response to the given request.","label":1,"pre_label":0,"AST_level":10,"line_counts":16,"new_code_token_num":149},{"new_code_raw":"public static Iterable<Runnable> thread(final String title, Iterable<Runnable> runnables){ \/\/--Preparation \/\/(variables) final AtomicBoolean haveStarted = new AtomicBoolean(false); final ReentrantLock metaInfoLock = new ReentrantLock(); final AtomicInteger numPending = new AtomicInteger(0); final Iterator<Runnable> iter = runnables.iterator(); \/\/--Create Runnables return new IterableIterator<>(new Iterator<Runnable>() { @Override public boolean hasNext() { synchronized (iter) { return iter.hasNext(); } } @Override public synchronized Runnable next() { final Runnable runnable; synchronized (iter) { runnable = iter.next(); } \/\/ (don't flood the queu) while (numPending.get() > 100) { try { Thread.sleep(100); } catch (InterruptedException e) { } } numPending.incrementAndGet(); \/\/ (add the job) Runnable toReturn = new Runnable() { public void run() { boolean threadFinished = false; try { \/\/(signal start of threads) metaInfoLock.lock(); if (!haveStarted.getAndSet(true)) { startThreads(title); \/\/<--this must be a blocking operation } metaInfoLock.unlock(); \/\/(run runnable) try { runnable.run(); } catch (Exception | AssertionError e) { e.printStackTrace(); System.exit(1); } \/\/(signal end of thread) finishThread(); threadFinished = true; \/\/(signal end of threads) int numStillPending = numPending.decrementAndGet(); synchronized (iter) { if (numStillPending <= 0 && !iter.hasNext()) { endThreads(title); } } } catch (Throwable t) { t.printStackTrace(); if (!threadFinished) { finishThread(); } } } }; return toReturn; } @Override public void remove() { synchronized (iter) { iter.remove(); } } }); }","old_code_raw":"    public static ArrayList<Runnable> thread(final String title, Iterable<Runnable> runnables){\n      \/\/--Preparation\n      \/\/(variables)\n      final AtomicBoolean haveStarted = new AtomicBoolean(false);\n      final ReentrantLock metaInfoLock = new ReentrantLock();\n      int count = 0;\n      \/\/(count runnables)\n      Iterator<Runnable> iterableRunnables = runnables.iterator();\n      while (iterableRunnables.hasNext()) {\n        count++;\n        iterableRunnables.next();\n      }\n      final int numToRun = count;\n      \/\/--Create Runnables\n      ArrayList<Runnable> rtn = new ArrayList<Runnable>(numToRun);\n      final AtomicInteger runnablesSeen = new AtomicInteger(0);\n      for(final Runnable runnable : runnables){\n        rtn.add(new Runnable(){\n          public void run(){\n            try{\n              \/\/(signal start of threads)\n              metaInfoLock.lock();\n              if(!haveStarted.getAndSet(true)){\n                startThreads(title); \/\/<--this must be a blocking operation\n              }\n              metaInfoLock.unlock();\n              \/\/(run runnable)\n              try{\n                runnable.run();\n              } catch (Exception e){\n                e.printStackTrace();\n                System.exit(1);\n              } catch (AssertionError e) {\n                e.printStackTrace();\n                System.exit(1);\n              }\n              \/\/(signal end of thread)\n              finishThread();\n              \/\/(signal end of threads)\n              int seen = runnablesSeen.getAndIncrement() + 1;\n              if(seen == numToRun){\n                endThreads(title);\n              }\n            } catch(Throwable t){\n              t.printStackTrace();\n              System.exit(1);\n            }\n          }\n        });\n      }\n      \/\/--Return\n      return rtn;\n    }\n","new_comment_raw":"@return A new collection of Runnables with the Redwood overhead taken care of","old_comment_raw":"@return A new collection of Runnables with the Redwood overhead taken care of","label":0,"pre_label":1,"AST_level":17,"line_counts":78,"new_code_token_num":377},{"new_code_raw":"public Button getButton(int index) { return getter.getView(Button.class, index); }","old_code_raw":"\tpublic Button getButton(int index) {\n\t\tButton button = getter.getView(Button.class, index);\n\t\treturn button;\n\t}\n","new_comment_raw":"@return the  Button with a specified index or  null if index is invalid","old_comment_raw":"@return the Button with a specified index or null if index is invalid","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":19},{"new_code_raw":"@Override public int getItemCount() { return getAdapterItemCount() + totalAdditionalItems(); }","old_code_raw":"@Override\npublic int getItemCount() {\n    int headerOrFooter = NUM;\n    if (customHeaderView != null)\n        headerOrFooter++;\n    if (customLoadMoreView != null)\n        headerOrFooter++;\n    return getAdapterItemCount() + headerOrFooter;\n}","new_comment_raw":"@return the int","old_comment_raw":"@return The total number of items in this adapter.","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":18},{"new_code_raw":"public IBuildConfiguration[] getBuildOrder() { if (buildOrder != null) return buildOrder; String[] order = description.getBuildOrder(false); if (order != null) { LinkedHashSet configs = new LinkedHashSet(); for (int i = NUM; i < order.length; i++) { IProject project = getRoot().getProject(order[i]); if (project.isAccessible()) configs.add(((Project) project).internalGetActiveBuildConfig()); } configs.addAll(Arrays.asList(vertexOrderToProjectBuildConfigOrder(computeActiveBuildConfigurationOrder()).buildConfigurations)); IBuildConfiguration[] bo = new IBuildConfiguration[configs.size()]; configs.toArray(bo); this.buildOrder = bo; } else buildOrder = vertexOrderToProjectBuildConfigOrder(computeActiveBuildConfigurationOrder()).buildConfigurations; return buildOrder; }","old_code_raw":"public IProject[] getBuildOrder() {\n    if (buildOrder != null) {\n        return buildOrder;\n    }\n    String[] order = description.getBuildOrder(false);\n    if (order != null) {\n        List projectList = new ArrayList(order.length);\n        for (int i = NUM; i < order.length; i++) {\n            IProject project = getRoot().getProject(order[i]);\n            if (project.isAccessible()) {\n                projectList.add(project);\n            }\n        }\n        buildOrder = new IProject[projectList.size()];\n        projectList.toArray(buildOrder);\n    } else {\n        buildOrder = computeFullProjectOrder().projects;\n    }\n    return buildOrder;\n}","new_comment_raw":"@return the list of currently open projects active buildConfigs (and the project buildConfigs they depend on) in the workspace in the order in which they would be built by <code>IWorkspace.build<\/code>.","old_comment_raw":"@return the list of currently open projects in the workspace in the order in which they would be built by <code>IWorkspace.build<\/code>.","label":1,"pre_label":0,"AST_level":13,"line_counts":19,"new_code_token_num":145},{"new_code_raw":"protected Account getServiceCredentials() { return this.account; }","old_code_raw":"protected ServiceCredentials getServiceCredentials() {\n    return this.serviceCredentials;\n}","new_comment_raw":"@return {@link com.jakeapp.core.domain.Account} if they are already set.","old_comment_raw":"@return {@link ServiceCredentials} if they are already set.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":11},{"new_code_raw":"public Object next() throws java.io.IOException { int zzInput; int zzAction; \/\/ cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { \/\/ store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); \/\/ get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } \/\/ store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 38: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } if (normalizeSpace) { \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, yytext()); } case 55: break; case 43: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 9; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 10; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/\/ try to work around an apparent jflex bug where it \/\/ gets a space at the token end by getting \/\/ wrong the length of the trailing context. while (yylength() > 0) { char last = yycharat(yylength()-1); if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) { yypushback(1); } else { break; } } return getNext(); } case 56: break; case 11: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 57: break; case 19: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 58: break; case 8: { return handleQuotes(yytext(), false); } case 59: break; case 35: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), false); } case 60: break; case 27: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 61: break; case 33: \/\/ lookahead expression with fixed lookahead length yypushback(1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 62: break; case 49: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return getNormalizedAmpNext(); } case 63: break; case 36: { return getNormalizedAmpNext(); } case 64: break; case 23: { if (invertible) { prevWordAfter.append(yytext()); } } case 65: break; case 37: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } if (normalizeSpace) { \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, yytext()); } case 66: break; case 53: \/\/ lookahead expression with fixed lookahead length yypushback(4); { return getNext(); } case 67: break; case 46: \/\/ lookahead expression with fixed lookahead length yypushback(2); { return getNext(); } case 68: break; case 42: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 69: break; case 41: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 16; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 17; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 70: break; case 40: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 13; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 71: break; case 3: { return getNext(); } case 72: break; case 24: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return getNext(); } case 73: break; case 51: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } return getNext(txt, yytext()); } case 74: break; case 26: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, origTxt); } case 75: break; case 6: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 76: break; case 29: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 77: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 78: break; case 2: { return getNext(\"<\", yytext()); } case 79: break; case 30: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 80: break; case 18: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 81: break; case 54: { String txt = yytext(); if (normalizeSpace) { \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 82: break; case 50: { yypushback(3) ; return getNext(); } case 83: break; case 25: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), true); } case 84: break; case 39: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 85: break; case 21: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 86: break; case 17: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 87: break; case 13: { return handleEllipsis(yytext()); } case 88: break; case 34: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 1; { \/* invert quote - often but not always right *\/ return handleQuotes(yytext(), true); } case 89: break; case 14: { return normalizeFractions(yytext()); } case 90: break; case 15: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(); } } case 91: break; case 47: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 11; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 12; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 92: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 93: break; case 9: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 94: break; case 45: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 95: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 96: break; case 28: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 97: break; case 48: { if (keepAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 98: break; case 20: { if (normalizeOtherBrackets) { return getNext(\"-RSB-\", yytext()); } else { return getNext(); } } case 99: break; case 12: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 100: break; case 31: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 101: break; case 10: { return getNext(\">\", yytext()); } case 102: break; case 32: { \/\/ this one should only match if we're basically at the end of file \/\/ since the last one matches two things, even newlines String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 103: break; case 22: { if (normalizeOtherBrackets) { return getNext(\"-LSB-\", yytext()); } else { return getNext(); } } case 104: break; case 52: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/\/ try to work around an apparent jflex bug where it \/\/ gets a space at the token end by getting \/\/ wrong the length of the trailing context. while (yylength() > 0) { char last = yycharat(yylength()-1); if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) { yypushback(1); } else { break; } } String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 105: break; case 1: { String str = yytext(); int first = str.charAt(0); String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } LOGGER.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: LOGGER.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 106: break; case 44: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 107: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 108: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }","old_code_raw":"  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    \/\/ cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            \/\/ store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            \/\/ get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          int zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      \/\/ store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 38: \n          { String txt = yytext();\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '\/');\n                  }\n                  if (normalizeSpace) {\n                    \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                    txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n\n                  }\n                  return getNext(txt, yytext());\n          }\n        case 55: break;\n        case 43: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 9;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 10;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { \/\/ try to work around an apparent jflex bug where it\n                          \/\/ gets a space at the token end by getting\n                          \/\/ wrong the length of the trailing context.\n                          while (yylength() > 0) {\n                            char last = yycharat(yylength()-1);\n                            if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) {\n                              yypushback(1);\n                            } else {\n                              break;\n                            }\n                          }\n\t\t\t  return getNext();\n          }\n        case 56: break;\n        case 11: \n          { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 57: break;\n        case 19: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 58: break;\n        case 8: \n          { return handleQuotes(yytext(), false);\n          }\n        case 59: break;\n        case 35: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return handleQuotes(yytext(), false);\n          }\n        case 60: break;\n        case 27: \n          { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n          }\n        case 61: break;\n        case 33: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n          }\n        case 62: break;\n        case 48: \n          { if (splitAssimilations) {\n                            yypushback(2) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 63: break;\n        case 49: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNormalizedAmpNext();\n          }\n        case 64: break;\n        case 36: \n          { return getNormalizedAmpNext();\n          }\n        case 65: break;\n        case 23: \n          { if (invertible) {\n                            prevWordAfter.append(yytext());\n                        }\n          }\n        case 66: break;\n        case 37: \n          { String txt = yytext();\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '\/');\n                  }\n                  if (normalizeSpace) {\n                    \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                    txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                  }\n                  return getNext(txt, yytext());\n          }\n        case 67: break;\n        case 53: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(4);\n          { return getNext();\n          }\n        case 68: break;\n        case 46: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(2);\n          { return getNext();\n          }\n        case 69: break;\n        case 42: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 15;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 14;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 70: break;\n        case 41: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 16;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 17;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 71: break;\n        case 40: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 13;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 14;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 72: break;\n        case 3: \n          { return getNext();\n          }\n        case 73: break;\n        case 24: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext();\n          }\n        case 74: break;\n        case 51: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 75: break;\n        case 26: \n          { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n          }\n        case 76: break;\n        case 6: \n          { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n          }\n        case 77: break;\n        case 29: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 3;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 4;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n          }\n        case 78: break;\n        case 16: \n          { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 79: break;\n        case 2: \n          { return getNext(\"<\", yytext());\n          }\n        case 80: break;\n        case 30: \n          { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '\/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 81: break;\n        case 18: \n          { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 82: break;\n        case 54: \n          { String txt = yytext();\n                          if (normalizeSpace) {\n                            \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 83: break;\n        case 25: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return handleQuotes(yytext(), true);\n          }\n        case 84: break;\n        case 39: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 5;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 6;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String txt = yytext();\n                          return getNext(removeSoftHyphens(txt),\n                                         txt);\n          }\n        case 85: break;\n        case 21: \n          { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 86: break;\n        case 50: \n          { if (splitAssimilations) {\n                            yypushback(3) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 87: break;\n        case 17: \n          { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 88: break;\n        case 13: \n          { return handleEllipsis(yytext());\n          }\n        case 89: break;\n        case 34: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 1;\n          { \/* invert quote - often but not always right *\/\n                  return handleQuotes(yytext(), true);\n          }\n        case 90: break;\n        case 14: \n          { return normalizeFractions(yytext());\n          }\n        case 91: break;\n        case 15: \n          { if (normalizeCurrency) {\n                            return getNext(normalizeCurrency(yytext()), yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 92: break;\n        case 47: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 11;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 12;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 93: break;\n        case 7: \n          { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n          }\n        case 94: break;\n        case 9: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '\/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 95: break;\n        case 45: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext(removeSoftHyphens(yytext()),\n                                               yytext());\n          }\n        case 96: break;\n        case 4: \n          { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n          }\n        case 97: break;\n        case 28: \n          { return getNext(removeSoftHyphens(yytext()), yytext());\n          }\n        case 98: break;\n        case 20: \n          { if (normalizeOtherBrackets) {\n                    return getNext(\"-RSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 99: break;\n        case 12: \n          { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n          }\n        case 100: break;\n        case 31: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n          }\n        case 101: break;\n        case 10: \n          { return getNext(\">\", yytext());\n          }\n        case 102: break;\n        case 32: \n          { \/\/ this one should only match if we're basically at the end of file\n                          \/\/ since the last one matches two things, even newlines\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 103: break;\n        case 22: \n          { if (normalizeOtherBrackets) {\n                    return getNext(\"-LSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 104: break;\n        case 52: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 7;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 8;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { \/\/ try to work around an apparent jflex bug where it\n                          \/\/ gets a space at the token end by getting\n                          \/\/ wrong the length of the trailing context.\n                          while (yylength() > 0) {\n                            char last = yycharat(yylength()-1);\n                            if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) {\n                              yypushback(1);\n                            } else {\n                              break;\n                            }\n                          }\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 105: break;\n        case 1: \n          { String str = yytext();\n          int first = str.charAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n          }\n        case 106: break;\n        case 44: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 107: break;\n        case 5: \n          { if (tokenizeNLs) {\n                      return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns\n                  } else if (invertible) {\n                      prevWordAfter.append(yytext());\n                  }\n          }\n        case 108: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                if (invertible) {\n            prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            prevWordAfter.setLength(0);\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n          }\n          return null;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n","new_comment_raw":"@return the next token","old_comment_raw":"@return the next token","label":0,"pre_label":1,"AST_level":17,"line_counts":702,"new_code_token_num":4305},{"new_code_raw":"public boolean validatePassword(String passString) { if (passString.length() >= 8) { return true; } else { Snackbar snackbar = Snackbar .make(findViewById(android.R.id.content), R.string.password_length, Snackbar.LENGTH_LONG); snackbar.show(); return false; } }","old_code_raw":"    public boolean validatePassword(String passString) {\n        if (passString.length() >= 8) {\n            Pattern pattern;\n            Matcher matcher;\n            final String PASSWORD_PATTERN = \"^(?=.*[0-9])(?=.*[A-Z])(?=.*[_@#$%^?&+=!])(?=\\\\S+$).{4,}$\";\n            pattern = Pattern.compile(PASSWORD_PATTERN);\n            matcher = pattern.matcher(passString);\n\n            if (matcher.matches()) {\n                return true;\n            } else {\n                Snackbar snackbar = Snackbar\n                        .make(findViewById(android.R.id.content), R.string.invalid_password, Snackbar.LENGTH_LONG);\n                snackbar.show();\n                return false;\n            }\n        } else {\n            Snackbar snackbar = Snackbar\n                    .make(findViewById(android.R.id.content), R.string.password_length, Snackbar.LENGTH_LONG);\n            snackbar.show();\n            return false;\n        }\n    }\n","new_comment_raw":"@return Boolean returns true if email format is correct, otherwise false","old_comment_raw":"@return Boolean returns true if email format is correct, otherwise false","label":0,"pre_label":1,"AST_level":9,"line_counts":11,"new_code_token_num":54},{"new_code_raw":"public static Seconds parseSeconds(String periodStr) { throw ExceptionUtils.unsupportedInGwt(); \/\/ if (periodStr == null) { \/\/ return Seconds.ZERO; \/\/ } \/\/ Period p = PARSER.parsePeriod(periodStr); \/\/ return Seconds.seconds(p.getSeconds()); }","old_code_raw":"    public static Seconds parseSeconds(String periodStr) {\n        if (periodStr == null) {\n            return Seconds.ZERO;\n        }\n        Period p = PARSER.parsePeriod(periodStr);\n        return Seconds.seconds(p.getSeconds());\n    }\n","new_comment_raw":"@return the period in seconds","old_comment_raw":"@return the period in seconds","label":0,"pre_label":1,"AST_level":4,"line_counts":9,"new_code_token_num":55},{"new_code_raw":"public Date getStart() { if (records.size() == NUM) { return new Date(); } else { Date first = records.get(NUM).getDate(); for (Entry e : records) { if (e.getDate().before(first)) { first = e.getDate(); } } return first; } }","old_code_raw":"public Date getStart() {\n    if (records.size() == NUM) {\n        return null;\n    } else {\n        Date first = records.get(NUM).getDate();\n        for (Entry e : records) {\n            if (e.getDate().before(first)) {\n                first = e.getDate();\n            }\n        }\n        return first;\n    }\n}","new_comment_raw":"@return The time of the first record, or the current time if there are no records","old_comment_raw":"@return The time of the first record or null if there are no records","label":1,"pre_label":0,"AST_level":11,"line_counts":13,"new_code_token_num":68},{"new_code_raw":"public Frame readFrame() throws IOException { byte[] header = new byte[HEADER_SIZE]; int actualHeaderSize = 0; do { int headerCount = inputStream.read(header, actualHeaderSize, HEADER_SIZE - actualHeaderSize); if (headerCount == -1) { return null; } actualHeaderSize += headerCount; } while (actualHeaderSize < HEADER_SIZE); int payloadSize = ((header[4] & 0xff) << 24) + ((header[5] & 0xff) << 16) + ((header[6] & 0xff) << 8) + (header[7] & 0xff); byte[] payload = new byte[payloadSize]; int actualPayloadSize = 0; do { int count = inputStream.read(payload, actualPayloadSize, payloadSize - actualPayloadSize); if (count == -1) { if (actualPayloadSize != payloadSize) { throw new IOException(String.format(\"payload must be %d bytes long, but was %d\", payloadSize, actualPayloadSize)); } break; } actualPayloadSize += count; } while (actualPayloadSize < payloadSize); return new Frame(streamType(header[0]), payload); }","old_code_raw":"    public Frame readFrame() throws IOException {\n\n        if (rawStreamDetected) {\n\n\n            int read = inputStream.read(rawBuffer);\n\n            return new Frame(StreamType.RAW, Arrays.copyOf(rawBuffer, read));\n\n        } else {\n\n            byte[] header = new byte[HEADER_SIZE];\n\n            int actualHeaderSize = 0;\n\n            do {\n                int headerCount = inputStream.read(header, actualHeaderSize, HEADER_SIZE - actualHeaderSize);\n\n                if (headerCount == -1) {\n                    return null;\n                }\n                actualHeaderSize += headerCount;\n            } while (actualHeaderSize < HEADER_SIZE);\n\n            StreamType streamType = streamType(header[0]);\n\n            if(streamType.equals(StreamType.RAW)) {\n                rawStreamDetected = true;\n                return new Frame(StreamType.RAW, Arrays.copyOf(header, HEADER_SIZE));\n            }\n\n            int payloadSize = ((header[4] & 0xff) << 24) + ((header[5] & 0xff) << 16) + ((header[6] & 0xff) << 8)\n                    + (header[7] & 0xff);\n\n            byte[] payload = new byte[payloadSize];\n            int actualPayloadSize = 0;\n\n            do {\n                int count = inputStream.read(payload, actualPayloadSize, payloadSize - actualPayloadSize);\n\n                if (count == -1) {\n                    if (actualPayloadSize != payloadSize) {\n                        throw new IOException(String.format(\"payload must be %d bytes long, but was %d\", payloadSize,\n                                actualPayloadSize));\n                    }\n                    break;\n                }\n                actualPayloadSize += count;\n            } while (actualPayloadSize < payloadSize);\n\n            return new Frame(streamType, payload);\n        }\n    }\n","new_comment_raw":"@return A frame, or null if no more frames.","old_comment_raw":"@return A frame, or null if no more frames.","label":0,"pre_label":1,"AST_level":12,"line_counts":36,"new_code_token_num":210},{"new_code_raw":"public boolean isThisMyUrl(String url) { final String myUrlConfigured = serverConfig.getMyUrl(); if (myUrlConfigured != null) { return myUrlConfigured.equals(url); } return isInstanceURL(url, applicationInfoManager.getInfo()); }","old_code_raw":"    public boolean isThisMyUrl(String url) {\n        return isInstanceURL(url, applicationInfoManager.getInfo());\n    }\n","new_comment_raw":"@return true, if the url represents the current node which is trying to replicate, false otherwise.","old_comment_raw":"@return true, if the url represents the current node which is trying to replicate, false otherwise.","label":0,"pre_label":1,"AST_level":7,"line_counts":8,"new_code_token_num":43},{"new_code_raw":"public AnsiClazzes processCode(String code) { if (code == null || code.length() < NUM) return null; if (code.charAt(NUM) != STR && code.charAt(code.length() - NUM) != STR) return null; if (code.length() == NUM) { clazzes_.clear(); blockClazzes_.clear(); return null; } int extendedColor = NUM; boolean extendedMarkerSeen = false; boolean extendedRGBMarkerSeen = false; int extendedRGBColorsSeen = NUM; String[] tokens = code.substring(NUM, code.length() - NUM).split(STR); for (String token : tokens) { int codeVal = StringUtil.parseInt(token, -NUM); if (codeVal == -NUM) continue; if (extendedColor > NUM) { if (!extendedMarkerSeen && !extendedRGBMarkerSeen) { if (codeVal == EXT_BY_INDEX) { extendedMarkerSeen = true; continue; } else if (codeVal == EXT_BY_RGB) { extendedRGBMarkerSeen = true; extendedRGBColorsSeen = NUM; } else { clazzes_.clear(); blockClazzes_.clear(); return null; } } else { if (extendedRGBMarkerSeen) { extendedRGBColorsSeen++; if (extendedRGBColorsSeen == NUM) { extendedColor = NUM; extendedRGBMarkerSeen = false; extendedRGBColorsSeen = NUM; } } else { if (extendedColor == FOREGROUND_EXT) { if (codeVal >= NUM && codeVal <= NUM) { currentColor_.setExtended(codeVal); resetForeground(); clazzes_.add(Color.clazzForColorIndex(codeVal, false)); } } else { if (codeVal >= NUM && codeVal <= NUM) { currentBgColor_.setExtended(codeVal); resetBackground(); clazzes_.add(Color.clazzForColorIndex(codeVal, true)); } } extendedColor = NUM; extendedMarkerSeen = false; } } } else if (codeVal == RESET) { inverted_ = false; currentColor_.reset(); currentBgColor_.reset(); clazzes_.clear(); blockClazzes_.clear(); } else if (codeVal == BOLD) { clazzes_.add(BOLD_STYLE); } else if (codeVal == BLURRED) { } else if (codeVal == BOLD_BLURRED_OFF) { clazzes_.remove(BOLD_STYLE); } else if (codeVal == ITALIC) { clazzes_.add(ITALIC_STYLE); } else if (codeVal == ITALIC_OFF) { clazzes_.remove(ITALIC_STYLE); } else if (codeVal == UNDERLINE) { clazzes_.add(UNDERLINE_STYLE); } else if (codeVal == UNDERLINE_OFF) { clazzes_.remove(UNDERLINE_STYLE); } else if (codeVal == BLINKSLOW || codeVal == BLINKFAST) { clazzes_.add(BLINK_STYLE); } else if (codeVal == BLINK_OFF) { clazzes_.remove(BLINK_STYLE); } else if (codeVal == INVERSE) { if (!inverted_) { resetForeground(); resetBackground(); Color newFg = invertFgColor(); Color newBg = invertBgColor(); currentColor_ = newFg; currentBgColor_ = newBg; inverted_ = true; } } else if (codeVal == INVERSE_OFF) { if (inverted_) { resetForeground(); resetBackground(); Color newFg = invertFgColor(); Color newBg = invertBgColor(); currentColor_ = newFg; currentBgColor_ = newBg; inverted_ = false; } } else if (codeVal == HIDDEN) { clazzes_.add(HIDDEN_STYLE); } else if (codeVal == HIDDEN_OFF) { clazzes_.remove(HIDDEN_STYLE); } else if (codeVal == STRIKETHROUGH) { clazzes_.add(STRIKETHROUGH_STYLE); } else if (codeVal == STRIKETHROUGH_OFF) { clazzes_.remove(STRIKETHROUGH_STYLE); } else if (Color.isFgColorCode(codeVal)) { currentColor_.setCode(codeVal); resetForeground(); clazzes_.add(clazzForColor(codeVal)); } else if (Color.isBgColorCode(codeVal)) { currentBgColor_ = new Color(false, codeVal); resetBackground(); clazzes_.add(clazzForBgColor(codeVal)); } else if (codeVal == RESET_FOREGROUND) { currentColor_.reset(); resetForeground(); } else if (codeVal == RESET_BACKGROUND) { currentBgColor_.reset(); resetBackground(); } else if (codeVal == FOREGROUND_EXT) { extendedColor = codeVal; extendedMarkerSeen = false; } else if (codeVal == BACKGROUND_EXT) { extendedColor = codeVal; extendedMarkerSeen = false; } else if (codeVal == FONT_NINE) { blockClazzes_.add(FONT_NINE_STYLE); } else if (codeVal == DEFAULT_FONT || (codeVal >= FONT_ONE && codeVal <= FONT_EIGHT)) { blockClazzes_.remove(FONT_NINE_STYLE); } else { } } return getStyles(); }","old_code_raw":"public String processCode(String code) {\n    if (code == null || code.length() < NUM)\n        return null;\n    if (code.charAt(NUM) != STR && code.charAt(code.length() - NUM) != STR)\n        return null;\n    if (code.length() == NUM) {\n        clazzes_.clear();\n        return null;\n    }\n    int extendedColor = NUM;\n    boolean extendedMarkerSeen = false;\n    boolean extendedRGBMarkerSeen = false;\n    int extendedRGBColorsSeen = NUM;\n    String[] tokens = code.substring(NUM, code.length() - NUM).split(STR);\n    for (String token : tokens) {\n        int codeVal = StringUtil.parseInt(token, -NUM);\n        if (codeVal == -NUM)\n            continue;\n        if (extendedColor > NUM) {\n            if (!extendedMarkerSeen && !extendedRGBMarkerSeen) {\n                if (codeVal == EXT_BY_INDEX) {\n                    extendedMarkerSeen = true;\n                    continue;\n                } else if (codeVal == EXT_BY_RGB) {\n                    extendedRGBMarkerSeen = true;\n                    extendedRGBColorsSeen = NUM;\n                } else {\n                    clazzes_.clear();\n                    return null;\n                }\n            } else {\n                if (extendedRGBMarkerSeen) {\n                    extendedRGBColorsSeen++;\n                    if (extendedRGBColorsSeen == NUM) {\n                        extendedColor = NUM;\n                        extendedRGBMarkerSeen = false;\n                        extendedRGBColorsSeen = NUM;\n                    }\n                } else {\n                    if (extendedColor == FOREGROUND_EXT) {\n                        if (codeVal >= NUM && codeVal <= NUM) {\n                            currentColor_.setExtended(codeVal);\n                            resetForeground();\n                            clazzes_.add(Color.clazzForColorIndex(codeVal, false));\n                        }\n                    } else {\n                        if (codeVal >= NUM && codeVal <= NUM) {\n                            currentBgColor_.setExtended(codeVal);\n                            resetBackground();\n                            clazzes_.add(Color.clazzForColorIndex(codeVal, true));\n                        }\n                    }\n                    extendedColor = NUM;\n                    extendedMarkerSeen = false;\n                }\n            }\n        } else if (codeVal == RESET) {\n            inverted_ = false;\n            currentColor_.reset();\n            currentBgColor_.reset();\n            clazzes_.clear();\n        } else if (codeVal == BOLD) {\n            clazzes_.add(BOLD_STYLE);\n        } else if (codeVal == BLURRED) {\n        } else if (codeVal == BOLD_BLURRED_OFF) {\n            clazzes_.remove(BOLD_STYLE);\n        } else if (codeVal == ITALIC) {\n            clazzes_.add(ITALIC_STYLE);\n        } else if (codeVal == ITALIC_OFF) {\n            clazzes_.remove(ITALIC_STYLE);\n        } else if (codeVal == UNDERLINE) {\n            clazzes_.add(UNDERLINE_STYLE);\n        } else if (codeVal == UNDERLINE_OFF) {\n            clazzes_.remove(UNDERLINE_STYLE);\n        } else if (codeVal == BLINKSLOW || codeVal == BLINKFAST) {\n            clazzes_.add(BLINK_STYLE);\n        } else if (codeVal == BLINK_OFF) {\n            clazzes_.remove(BLINK_STYLE);\n        } else if (codeVal == INVERSE) {\n            if (!inverted_) {\n                resetForeground();\n                resetBackground();\n                Color newFg = invertFgColor();\n                Color newBg = invertBgColor();\n                currentColor_ = newFg;\n                currentBgColor_ = newBg;\n                inverted_ = true;\n            }\n        } else if (codeVal == INVERSE_OFF) {\n            if (inverted_) {\n                resetForeground();\n                resetBackground();\n                Color newFg = invertFgColor();\n                Color newBg = invertBgColor();\n                currentColor_ = newFg;\n                currentBgColor_ = newBg;\n                inverted_ = false;\n            }\n        } else if (codeVal == HIDDEN) {\n            clazzes_.add(HIDDEN_STYLE);\n        } else if (codeVal == HIDDEN_OFF) {\n            clazzes_.remove(HIDDEN_STYLE);\n        } else if (codeVal == STRIKETHROUGH) {\n            clazzes_.add(STRIKETHROUGH_STYLE);\n        } else if (codeVal == STRIKETHROUGH_OFF) {\n            clazzes_.remove(STRIKETHROUGH_STYLE);\n        } else if (Color.isFgColorCode(codeVal)) {\n            currentColor_.setCode(codeVal);\n            resetForeground();\n            clazzes_.add(clazzForColor(codeVal));\n        } else if (Color.isBgColorCode(codeVal)) {\n            currentBgColor_ = new Color(false, codeVal);\n            resetBackground();\n            clazzes_.add(clazzForBgColor(codeVal));\n        } else if (codeVal == RESET_FOREGROUND) {\n            currentColor_.reset();\n            resetForeground();\n        } else if (codeVal == RESET_BACKGROUND) {\n            currentBgColor_.reset();\n            resetBackground();\n        } else if (codeVal == FOREGROUND_EXT) {\n            extendedColor = codeVal;\n            extendedMarkerSeen = false;\n        } else if (codeVal == BACKGROUND_EXT) {\n            extendedColor = codeVal;\n            extendedMarkerSeen = false;\n        } else {\n        }\n    }\n    return getStyle();\n}","new_comment_raw":"@return AnsiClazzes, containing both span-level and block-level styles","old_comment_raw":"@return Clazzes or null if no color classes were applied","label":1,"pre_label":0,"AST_level":33,"line_counts":138,"new_code_token_num":782},{"new_code_raw":"public synchronized boolean start(final String workDir, final Cryptor cryptor) { final ServerConnector connector = new ServerConnector(server); connector.setHost(LOCALHOST); final String contextPath = STR; final ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS); context.addServlet(getMiltonServletHolder(workDir, contextPath, cryptor), STR); context.setContextPath(contextPath); server.setHandler(context); try { server.setConnectors(new Connector[] { connector }); server.start(); port = connector.getLocalPort(); return true; } catch (Exception ex) { LOG.error(STR, ex); return false; } }","old_code_raw":"public int start(final String workDir, final Cryptor cryptor) {\n    final ServerConnector connector = new ServerConnector(server);\n    connector.setHost(LOCALHOST);\n    final String contextPath = STR;\n    final ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);\n    context.addServlet(getMiltonServletHolder(workDir, contextPath, cryptor), STR);\n    context.setContextPath(contextPath);\n    server.setHandler(context);\n    try {\n        server.setConnectors(new Connector[] { connector });\n        server.start();\n    } catch (Exception ex) {\n        LOG.error(STR, ex);\n    }\n    return connector.getLocalPort();\n}","new_comment_raw":"@return <code>true<\/code> upon success","old_comment_raw":"@return port, on which the server did start","label":1,"pre_label":0,"AST_level":8,"line_counts":18,"new_code_token_num":119},{"new_code_raw":"public static Platform fromString(String name) { try { return Platform.valueOf(name); } catch (IllegalArgumentException ex) { for (Platform os : Platform.values()) { for (String matcher : os.partOfOsName) { if (name.toLowerCase().equals(matcher.toLowerCase())) { return os; } } } throw new WebDriverException(\"Unrecognized platform: \" + name); } }","old_code_raw":"  public static Platform fromString(String name) {\n    for (Platform os : Platform.values()) {\n      for (String matcher : os.partOfOsName) {\n        if (name.toLowerCase().equals(matcher.toLowerCase())) {\n          return os;\n        }\n      }\n    }\n    throw new WebDriverException(\"Unknown platform: \" + name);\n  }\n","new_comment_raw":"@return the Platform enum value matching the parameter","old_comment_raw":"@return the Platform enum value matching the parameter","label":0,"pre_label":1,"AST_level":12,"line_counts":15,"new_code_token_num":81},{"new_code_raw":"public static SecureConnectionMode parse(String value, String defaultValue) { SecureConnectionMode mode = parse(value); if (mode == null && defaultValue != null) { mode = parse(defaultValue); } return mode; }","old_code_raw":"        public static TopicSelectionStrategy parse(String value) {\n            if (value == null) {\n                return null;\n            }\n            value = value.trim();\n            for (TopicSelectionStrategy option : TopicSelectionStrategy.values()) {\n                if (option.getValue().equalsIgnoreCase(value)) {\n                    return option;\n                }\n            }\n            return null;\n        }\n","new_comment_raw":"@return the matching option, or null if no match is found and the non-null default is invalid","old_comment_raw":"@return the matching option, or null if no match is found","label":1,"pre_label":0,"AST_level":8,"line_counts":8,"new_code_token_num":41},{"new_code_raw":"private IAnnotationModel createExternalSearchAnnotationModel(ExternalEditorInput externalInput) { IStorage storage = externalInput.getStorage(); IResource markerResource = externalInput.getMarkerResource(); return createExternalSearchAnnotationModel(storage, markerResource); }","old_code_raw":"private IAnnotationModel createExternalSearchAnnotationModel(ExternalEditorInput externalInput) {\n    IStorage storage = externalInput.getStorage();\n    IResource resourceToUseForMarker = null;\n    IFile resourceFile = CUIPlugin.getWorkspace().getRoot().getFileForLocation(storage.getFullPath());\n    if (resourceFile == null) {\n        resourceToUseForMarker = externalInput.getMarkerResource();\n        if (null == resourceToUseForMarker) {\n            IProject[] proj = CUIPlugin.getWorkspace().getRoot().getProjects();\n            for (int i = NUM; i < proj.length; i++) {\n                if (proj[i].isOpen()) {\n                    resourceToUseForMarker = proj[i];\n                    break;\n                }\n            }\n        }\n    } else {\n        resourceToUseForMarker = resourceFile.getProject();\n    }\n    if (resourceToUseForMarker != null) {\n        ExternalSearchAnnotationModel model = new ExternalSearchAnnotationModel(resourceToUseForMarker, storage);\n        return model;\n    }\n    return null;\n}","new_comment_raw":"@return a new annotation model for the external editor input","old_comment_raw":"@return a new annotation model for the editor input","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":31},{"new_code_raw":"public String getSpeed() { \/\/ no-op. Pretend we work instantly. Which we do return \"0\"; }","old_code_raw":"  public String getSpeed() {\n    throw new UnsupportedOperationException(\"getSpeed\");\n  }\n","new_comment_raw":"@return the execution speed in milliseconds.","old_comment_raw":"@return the execution speed in milliseconds.","label":0,"pre_label":1,"AST_level":4,"line_counts":5,"new_code_token_num":24},{"new_code_raw":"private Connection handleRedirect(IBasicRequest oldRequest, Headers responseHeaders) { IBasicRequest redirectRequest = null; RedirectHandler redirectHandler = oldRequest.getRedirectHandler(); if (redirectHandler != null) { if (redirectHandler.isDisallowedRedirect(responseHeaders)) return new Connection(null, responseHeaders, null, null); else redirectRequest = redirectHandler.onRedirect(responseHeaders); } if (redirectRequest == null) { redirectRequest = new StringRequest(responseHeaders.getLocation(), oldRequest.getRequestMethod()); redirectRequest.setSSLSocketFactory(oldRequest.getSSLSocketFactory()); redirectRequest.setHostnameVerifier(oldRequest.getHostnameVerifier()); redirectRequest.setProxy(oldRequest.getProxy()); } return getConnection(redirectRequest); }","old_code_raw":"private ConnectionResult handleRedirect(IBasicRequest oldRequest, Headers responseHeaders) {\n    IBasicRequest redirectRequest = null;\n    RedirectHandler redirectHandler = oldRequest.getRedirectHandler();\n    if (redirectHandler != null) {\n        if (redirectHandler.isDisallowedRedirect(responseHeaders))\n            return new ConnectionResult(null, responseHeaders, null, null);\n        else\n            redirectRequest = redirectHandler.onRedirect(responseHeaders);\n    }\n    if (redirectRequest == null) {\n        redirectRequest = new StringRequest(responseHeaders.getLocation(), oldRequest.getRequestMethod());\n        redirectRequest.setSSLSocketFactory(oldRequest.getSSLSocketFactory());\n        redirectRequest.setHostnameVerifier(oldRequest.getHostnameVerifier());\n        redirectRequest.setProxy(oldRequest.getProxy());\n    }\n    return getConnection(redirectRequest);\n}","new_comment_raw":"@return {@link Connection}.","old_comment_raw":"@return {@link ProtocolResult}.","label":1,"pre_label":0,"AST_level":9,"line_counts":17,"new_code_token_num":115},{"new_code_raw":"public CacheManager getCacheFactory() { return jbcFactory; }","old_code_raw":"\tpublic JBossCacheFactory getCacheFactory() {\n        return jbcFactory;\n    }\n","new_comment_raw":"@return Value for property 'cacheFactory'.","old_comment_raw":"@return Value for property 'cacheFactory'.","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"public User getUserByName(String username) throws ApiException { ApiResponse<User> localVarResp = getUserByNameWithHttpInfo(username); return localVarResp.getData(); }","old_code_raw":"    public User getUserByName(String username) throws ApiException {\n        ApiResponse<User> resp = getUserByNameWithHttpInfo(username);\n        return resp.getData();\n    }\n","new_comment_raw":"@return User","old_comment_raw":"@return User","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":25},{"new_code_raw":"public ChromeDriverService build() { return (ChromeDriverService) super.build(); }","old_code_raw":"    public ChromeDriverService build() {\n      if (port == 0) {\n        port = PortProber.findFreePort();\n      }\n\n      checkState(exe != null, \"Path to the chromedriver executable not specified\");\n\n      try {\n        return new ChromeDriverService(exe, port, environment, logFile);\n      } catch (IOException e) {\n        throw new WebDriverException(e);\n      }\n    }\n","new_comment_raw":"@return The new binary.","old_comment_raw":"@return The new binary.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":16},{"new_code_raw":"public Client call123testSpecialTags(Client body) throws ApiException { Object localVarPostBody = body; \/\/ verify the required parameter 'body' is set if (body == null) { throw new ApiException(400, \"Missing the required parameter 'body' when calling call123testSpecialTags\"); } \/\/ create path and map variables String localVarPath = \"\/another-fake\/dummy\".replaceAll(\"\\\\{format\\\\}\",\"json\"); \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, String> localVarCookieParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { \"application\/json\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { \"application\/json\" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Client> localVarReturnType = new GenericType<Client>() {}; return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public Client call123testSpecialTags(Client body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    \/\/ verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling call123testSpecialTags\");\n    }\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/another-fake\/dummy\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application\/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application\/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@return a  Client","old_comment_raw":"@return a Client","label":0,"pre_label":1,"AST_level":8,"line_counts":37,"new_code_token_num":234},{"new_code_raw":"private static boolean containsItem(Collection<String> itemCollection, String item) { return itemCollection.contains(item.toLowerCase()); }","old_code_raw":"private static boolean containsItem(Collection itemCollection, String key) {\n    return itemCollection.contains(key.toLowerCase());\n}","new_comment_raw":"@return true if itemCollection contains the item, false otherwise.","old_comment_raw":"@return true if itemCollection contains the key, false otherwise.","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":24},{"new_code_raw":"public Object next() throws java.io.IOException { int zzInput; int zzAction; \/\/ cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { \/\/ store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); \/\/ get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } \/\/ store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 25: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 32: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 33: break; case 12: { final String origTxt = yytext(); return getNext(asciiQuotes(origTxt), origTxt); } case 34: break; case 15: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 35: break; case 10: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { String origTxt = yytext(); return getNext(asciiDash(origTxt), origTxt); } } case 36: break; case 1: { String str = yytext(); int first = str.charAt(0); String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } LOGGER.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: LOGGER.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 37: break; case 27: \/\/ lookahead expression with fixed lookahead length yypushback(2); { return getNext(); } case 38: break; case 24: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 39: break; case 23: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 1; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 2; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 40: break; case 18: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return getNext(); } case 41: break; case 4: { return getNext(); } case 42: break; case 28: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 43: break; case 7: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 44: break; case 9: { return handleEllipsis(yytext()); } case 45: break; case 17: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 46: break; case 2: { if (normalizeOtherBrackets) { return getNext(openparen, yytext()); } else { return getNext(); } } case 47: break; case 30: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } return getNext(txt, yytext()); } case 48: break; case 14: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 49: break; case 11: { return normalizeFractions(yytext()); } case 50: break; case 31: { String txt = yytext(); if (normalizeParentheses) { txt = txt.replaceAll(\"\\\\(\", openparen); txt = txt.replaceAll(\"\\\\)\", closeparen); } return getNext(txt, yytext()); } case 51: break; case 26: { return getNormalizedAmpNext(); } case 52: break; case 22: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String txt = asciiQuotes(origTxt); return getNext(asciiDash(txt), origTxt); } case 53: break; case 20: { \/\/ this one should only match if we're basically at the end of file \/\/ since the last one matches two things, even newlines String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 54: break; case 8: { if (invertible) { prevWordAfter.append(yytext()); } } case 55: break; case 29: { yypushback(3) ; return getNext(); } case 56: break; case 3: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 57: break; case 21: { final String origTxt = yytext(); return getNext(asciiDash(origTxt), origTxt); } case 58: break; case 13: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 59: break; case 19: { if (!noSGML) { return getNext(); } } case 60: break; case 6: { if (normalizeOtherBrackets) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 61: break; case 16: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 62: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }","old_code_raw":"  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    \/\/ cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      \/\/ set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            \/\/ store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            \/\/ get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      \/\/ store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { String str = yytext();\n          int first = str.charAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n          }\n        case 33: break;\n        case 2: \n          { if (normalizeOtherBrackets) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 34: break;\n        case 3: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '\/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 35: break;\n        case 4: \n          { return getNext();\n          }\n        case 36: break;\n        case 5: \n          { if (tokenizeNLs) {\n                      return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns\n                  } else if (invertible) {\n                      prevWordAfter.append(yytext());\n                  }\n          }\n        case 37: break;\n        case 6: \n          { if (normalizeOtherBrackets) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 38: break;\n        case 7: \n          { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 39: break;\n        case 8: \n          { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n          }\n        case 40: break;\n        case 9: \n          { return handleEllipsis(yytext());\n          }\n        case 41: break;\n        case 10: \n          { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n\t            return getNext(ptbmdash, yytext());\n                  } else {\n\t\t    String origTxt = yytext();\n                    return getNext(asciiDash(origTxt), origTxt);\n\t\t  }\n          }\n        case 42: break;\n        case 11: \n          { return normalizeFractions(yytext());\n          }\n        case 43: break;\n        case 12: \n          { final String origTxt = yytext();\n                          return getNext(asciiQuotes(origTxt), origTxt);\n          }\n        case 44: break;\n        case 13: \n          { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 45: break;\n        case 14: \n          { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 46: break;\n        case 15: \n          { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 47: break;\n        case 16: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 48: break;\n        case 17: \n          { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 49: break;\n        case 18: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext();\n          }\n        case 50: break;\n        case 19: \n          { if (!noSGML) {\n                            return getNext();\n\t\t\t  }\n          }\n        case 51: break;\n        case 20: \n          { \/\/ this one should only match if we're basically at the end of file\n\t\t\t  \/\/ since the last one matches two things, even newlines\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n\t                  return getNext(s, yytext());\n          }\n        case 52: break;\n        case 21: \n          { final String origTxt = yytext();\n                          return getNext(asciiDash(origTxt), origTxt, COMPOUND_ANNOTATION);\n          }\n        case 53: break;\n        case 22: \n          { final String origTxt = yytext();\n                          return getNext(asciiDash(origTxt), origTxt);\n          }\n        case 54: break;\n        case 23: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 3;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 4;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String origTxt = yytext();\n                          String txt = asciiQuotes(origTxt);\n                          return getNext(asciiDash(txt), origTxt);\n          }\n        case 55: break;\n        case 24: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 1;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 2;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 56: break;\n        case 25: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 7;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 8;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 57: break;\n        case 26: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 58: break;\n        case 27: \n          { return getNormalizedAmpNext();\n          }\n        case 59: break;\n        case 28: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(2);\n          { return getNext();\n          }\n        case 60: break;\n        case 29: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 5;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 6;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n\t                  return getNext(s, yytext());\n          }\n        case 61: break;\n        case 30: \n          { yypushback(3) ; return getNext();\n          }\n        case 62: break;\n        case 31: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 63: break;\n        case 32: \n          { String txt = yytext();\n\t\t\t  if (normalizeParentheses) {\n\t\t\t    txt = txt.replaceAll(\"\\\\(\", openparen);\n\t\t\t    txt = txt.replaceAll(\"\\\\)\", closeparen);\n\t\t\t  }\n\t\t\t  return getNext(txt, yytext());\n          }\n        case 64: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                if (invertible) {\n            prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            prevWordAfter.setLength(0);\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n          }\n          return null;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n","new_comment_raw":"@return the next token","old_comment_raw":"@return the next token","label":0,"pre_label":1,"AST_level":17,"line_counts":422,"new_code_token_num":2344},{"new_code_raw":"public static int getKeyLength(AsymmetricKeyParameter keyParams) { if (keyParams instanceof RSAKeyParameters) { return ((RSAKeyParameters) keyParams).getModulus().bitLength(); } else if (keyParams instanceof DSAKeyParameters) { return ((DSAKeyParameters) keyParams).getParameters().getP().bitLength(); } else if (keyParams instanceof DHKeyParameters) { return ((DHKeyParameters) keyParams).getParameters().getP().bitLength(); } else if (keyParams instanceof ECKeyParameters) { return UNKNOWN_KEY_SIZE; } LOG.warning(STR + keyParams); return UNKNOWN_KEY_SIZE; }","old_code_raw":"public static int getKeyLength(AsymmetricKeyParameter keyParams) throws CryptoException {\n    if (keyParams instanceof RSAKeyParameters) {\n        return ((RSAKeyParameters) keyParams).getModulus().bitLength();\n    } else if (keyParams instanceof DSAKeyParameters) {\n        return ((DSAKeyParameters) keyParams).getParameters().getP().bitLength();\n    } else if (keyParams instanceof DHKeyParameters) {\n        return ((DHKeyParameters) keyParams).getParameters().getP().bitLength();\n    } else {\n        throw new CryptoException(RB.getString(STR));\n    }\n}","new_comment_raw":"@return The key size, {@link #UNKNOWN_KEY_SIZE} if not known","old_comment_raw":"@return The key size","label":1,"pre_label":0,"AST_level":9,"line_counts":13,"new_code_token_num":107},{"new_code_raw":"private MessageBatcher getBatcher(final String serviceUrl, String pBatcherName) { String batcherName = null; try { batcherName = new URL(serviceUrl).getHost(); } catch (MalformedURLException e1) { batcherName = serviceUrl; } String absoluteBatcherName = batcherName + \"-\" + pBatcherName; ConfigurationManager.getConfigInstance().setProperty( \"batcher.\" + absoluteBatcherName + \".queue.maxMessages\", config.getMaxElementsInPeerReplicationPool()); ConfigurationManager.getConfigInstance().setProperty( \"batcher.\" + absoluteBatcherName + \".batch.maxMessages\", 250); ConfigurationManager.getConfigInstance().setProperty( \"batcher.\" + absoluteBatcherName + \".keepAliveTime\", config.getMaxIdleThreadAgeInMinutesForPeerReplication() * 60); ConfigurationManager.getConfigInstance().setProperty( \"batcher.\" + absoluteBatcherName + \".maxThreads\", config.getMaxThreadsForPeerReplication()); return BatcherFactory.createBatcher(absoluteBatcherName, new MessageProcessor<ReplicationTask>() { private String BATCH_URL_PATH = \"peerreplication\/batch\/\";; @Override public void process(List<ReplicationTask> tasks) { if (!tasks.get(0).isBatchingSupported()) { executeSingle(tasks); } else if (!executeBatch(tasks)) { executeSingle(tasks); } } private boolean executeBatch(List<ReplicationTask> tasks) { boolean success = true; boolean done = true; PeerEurekaNode.ReplicationList list = new PeerEurekaNode.ReplicationList(); for (ReplicationTask task : tasks) { if (System.currentTimeMillis() - config.getMaxTimeForReplication() > task .getSubmitTime()) { Object[] args = { task.getAppName(), task.getId(), task.getAction(), new Date(System.currentTimeMillis()), new Date(task.getSubmitTime()) }; logger.warn( \"Replication events older than the threshold. AppName : {}, Id: {}, Action : {}, Current Time : {}, Submit Time :{}\", args); continue; } PeerEurekaNode.ReplicationInstance instance = new PeerEurekaNode.ReplicationInstance(); instance.setAppName(task.getAppName()); instance.setId(task.getId()); InstanceInfo instanceInfo = task.getInstanceInfo(); if (instanceInfo != null) { String overriddenStatus = (task .getOverriddenStatus() == null ? null : task.getOverriddenStatus().name()); instance.setOverriddenStatus(overriddenStatus); instance.setLastDirtyTimestamp(instanceInfo .getLastDirtyTimestamp()); if (task.shouldReplicateInstanceInfo()) { instance.setInstanceInfo(instanceInfo); } String instanceStatus = instanceInfo .getStatus() == null ? null : instanceInfo.getStatus().name(); instance.setStatus(instanceStatus); } instance.setAction(task.getAction()); list.addReplicationInstance(instance); } if (list.getList().size() == 0) { return true; } Action action = list.getList().get(0).action; DynamicCounter.increment(\"Batch_\" + action + \"_tries\"); do { done = true; ClientResponse response = null; try { response = jerseyApacheClient .resource(serviceUrl) .path(BATCH_URL_PATH) .accept(MediaType.APPLICATION_JSON_TYPE) .type(MediaType.APPLICATION_JSON_TYPE) .post(ClientResponse.class, list); if (!isSuccess(response)) { return false; } DynamicCounter.increment(\"Batch_\" + action + \"_success\"); PeerEurekaNode.ReplicationListResponse batchResponse = response .getEntity(PeerEurekaNode.ReplicationListResponse.class); int ctr = 0; for (PeerEurekaNode.ReplicationInstanceResponse singleResponse : batchResponse .getResponseList()) { int statusCode = singleResponse .getStatusCode(); if ((!isSuccess(response)) || (singleResponse .getResponseEntity() != null)) { if (singleResponse.getResponseEntity() != null) { tasks.get(ctr) .setPeerInstanceInfo( singleResponse .getResponseEntity()); } tasks.get(ctr) .handleFailure(statusCode); } ++ctr; } done = true; } catch (Throwable e) { if ((isNetworkConnectException(e))) { DynamicCounter.increment(\"Batch_\" + action + \"_retries\"); done = false; } else { success = false; logger.info( \"Not re-trying this exception because it does not seem to be a network exception\", e); } } finally { if (response != null) { response.close(); } } } while (!done); return success; } private boolean isSuccess(ClientResponse response) { return response.getStatus() < 200 || response.getStatus() >= 300; } private void executeSingle(List<ReplicationTask> tasks) { for (ReplicationTask task : tasks) { boolean done = true; do { done = true; try { if (System.currentTimeMillis() - config.getMaxTimeForReplication() > task .getSubmitTime()) { Object[] args = { task.getAppName(), task.getId(), task.getAction(), new Date(System.currentTimeMillis()), new Date(task.getSubmitTime()) }; logger.warn( \"Replication events older than the threshold. AppName : {}, Id: {}, Action : {}, Current Time : {}, Submit Time :{}\", args); continue; } DynamicCounter.increment(\"Single_\" + task.getAction().name() + \"_tries\"); int statusCode = task.execute(); if (statusCode < 200 && statusCode > 299) { task.handleFailure(statusCode); } DynamicCounter.increment(\"Single_\" + task.getAction().name() + \"_success\"); } catch (Throwable e) { logger.error( name + task.getAppName() + \"\/\" + task.getId() + \":\" + task.getAction(), e); try { Thread.sleep(RETRY_SLEEP_TIME_MS); } catch (InterruptedException e1) { } if ((isNetworkConnectException(e))) { DynamicCounter.increment(task .getAction().name() + \"_retries\"); done = false; } else { logger.info( \"Not re-trying this exception because it does not seem to be a network exception\", e); } } } while (!done); } } }); }","old_code_raw":"    private MessageBatcher getBatcher(final String serviceUrl, String pBatcherName) {\n        String batcherName = null;\n        try {\n            batcherName = new URL(serviceUrl).getHost();\n        } catch (MalformedURLException e1) {\n            batcherName = serviceUrl;\n        }\n        String absoluteBatcherName = batcherName + \"-\" + pBatcherName;\n        ConfigurationManager.getConfigInstance().setProperty(\n                \"batcher.\" + absoluteBatcherName + \".queue.maxMessages\",\n                config.getMaxElementsInPeerReplicationPool());\n        ConfigurationManager.getConfigInstance().setProperty(\n                \"batcher.\" + absoluteBatcherName + \".batch.maxMessages\",\n                 250);\n        ConfigurationManager.getConfigInstance().setProperty(\n                \"batcher.\" + absoluteBatcherName + \".keepAliveTime\",\n                config.getMaxIdleThreadAgeInMinutesForPeerReplication() * 60);\n        ConfigurationManager.getConfigInstance().setProperty(\n                \"batcher.\" + absoluteBatcherName + \".maxThreads\",\n                config.getMaxThreadsForPeerReplication());\n\n        return BatcherFactory.createBatcher(absoluteBatcherName,\n                new MessageProcessor<ReplicationTask>() {\n\n            private String BATCH_URL_PATH = \"apps\/batch\/\";;\n\n            @Override\n            public void process(List<ReplicationTask> tasks) {\n                if (!tasks.get(0).isBatchingSupported()) {\n                    executeSingle(tasks);\n                } else if (!executeBatch(tasks)) {\n                    executeSingle(tasks);\n                }\n            }\n\n            private boolean executeBatch(List<ReplicationTask> tasks) {\n                boolean success = true;\n                boolean done = true;\n                PeerEurekaNode.ReplicationList list = new PeerEurekaNode.ReplicationList();\n                for (ReplicationTask task : tasks) {\n                   if (System.currentTimeMillis()\n                            - config.getMaxTimeForReplication() > task\n                            .getSubmitTime()) {\n                       Object[] args = { task.getAppName(), task.getId(),\n                               task.getAction(),\n                               new Date(System.currentTimeMillis()),\n                               new Date(task.getSubmitTime()) };\n                    \n                        logger.warn(\n                                \"Replication events older than the threshold. AppName : {}, Id: {}, Action : {}, Current Time : {}, Submit Time :{}\",\n                                args);\n\n                        continue;\n                    }\n                    PeerEurekaNode.ReplicationInstance instance = new PeerEurekaNode.ReplicationInstance();\n                    instance.setAppName(task.getAppName());\n                    instance.setId(task.getId());\n                    InstanceInfo instanceInfo = task.getInstanceInfo();\n                    if (instanceInfo != null) {\n                        String overriddenStatus = (task\n                                .getOverriddenStatus() == null ? null\n                                        : task.getOverriddenStatus().name());\n                        instance.setOverriddenStatus(overriddenStatus);\n                        instance.setLastDirtyTimestamp(instanceInfo\n                                .getLastDirtyTimestamp());\n                        if (task.shouldReplicateInstanceInfo()) {\n                            instance.setInstanceInfo(instanceInfo);\n                        }\n                        String instanceStatus = instanceInfo\n                        .getStatus() == null ? null\n                                : instanceInfo.getStatus().name();\n                        instance.setStatus(instanceStatus);\n                    }\n                    instance.setAction(task.getAction());\n                    list.addReplicationInstance(instance);\n                }\n                if (list.getList().size() == 0) {\n                    return true;\n                }\n                Action action = list.getList().get(0).action;\n                DynamicCounter.increment(\"Batch_\"\n                        + action\n\n                        + \"_tries\");\n\n                do {\n                    done = true;\n                    ClientResponse response = null;\n                    try {\n                        response = jerseyApacheClient\n                        .resource(serviceUrl)\n                        .path(BATCH_URL_PATH)\n                        .accept(MediaType.APPLICATION_JSON_TYPE)\n                        .type(MediaType.APPLICATION_JSON_TYPE)\n                        .post(ClientResponse.class, list);\n                        if (!isSuccess(response)) {\n                            return false;\n                        }\n                        DynamicCounter.increment(\"Batch_\"\n                                + action\n\n                                + \"_success\");\n\n                        PeerEurekaNode.ReplicationListResponse batchResponse = response\n                        .getEntity(PeerEurekaNode.ReplicationListResponse.class);\n                        int ctr = 0;\n                        for (PeerEurekaNode.ReplicationInstanceResponse singleResponse : batchResponse\n                                .getResponseList()) {\n                            int statusCode = singleResponse\n                            .getStatusCode();\n                            if ((!isSuccess(response))\n                                    || (singleResponse\n                                    .getResponseEntity() != null)) {\n                                if (singleResponse.getResponseEntity() != null) {\n                                    tasks.get(ctr)\n                                    .setPeerInstanceInfo(\n                                            singleResponse\n                                            .getResponseEntity());\n                                }\n                                tasks.get(ctr)\n                                .handleFailure(statusCode);\n                            }\n\n                            ++ctr;\n                        }\n                        done = true;\n\n                    } catch (Throwable e) {\n\n                        if ((isNetworkConnectException(e))) {\n                            DynamicCounter.increment(\"Batch_\"\n                                    + action\n                              + \"_retries\");\n                            done = false;\n                        } else {\n                            success = false;\n                            logger.info(\n                                    \"Not re-trying this exception because it does not seem to be a network exception\",\n                                    e);\n                        }\n                    } finally {\n                        if (response != null) {\n                            response.close();\n                        }\n                    }\n                } while (!done);\n                return success;\n            }\n\n            private boolean isSuccess(ClientResponse response) {\n                return response.getStatus() < 200\n                        || response.getStatus() >= 300;\n            }\n\n            private void executeSingle(List<ReplicationTask> tasks) {\n                for (ReplicationTask task : tasks) {\n                    boolean done = true;\n                    do {\n                        done = true;\n                        try {\n                              if (System.currentTimeMillis()\n                                    - config.getMaxTimeForReplication() > task\n                                    .getSubmitTime()) {\n                                  Object[] args = {\n                                          task.getAppName(),\n                                          task.getId(),\n                                          task.getAction(),\n                                          new Date(System.currentTimeMillis()),\n                                          new Date(task.getSubmitTime()) };\n       \n                                logger.warn(\n                                        \"Replication events older than the threshold. AppName : {}, Id: {}, Action : {}, Current Time : {}, Submit Time :{}\",\n                                        args);\n\n                                continue;\n                            }\n                            DynamicCounter.increment(\"Single_\"\n                                    + task.getAction().name()\n\n                                    + \"_tries\");\n\n                            int statusCode = task.execute();\n                            if (statusCode < 200 && statusCode > 299) {\n                                task.handleFailure(statusCode);\n                            }\n                            DynamicCounter.increment(\"Single_\"\n                                    + task.getAction().name()\n\n                                    + \"_success\");\n\n                        } catch (Throwable e) {\n                            logger.error(\n                                    name + task.getAppName() + \"\/\"\n                                    + task.getId() + \":\"\n                                    + task.getAction(), e);\n                            try {\n                                Thread.sleep(RETRY_SLEEP_TIME_MS);\n                            } catch (InterruptedException e1) {\n\n                            }\n                            if ((isNetworkConnectException(e))) {\n                                DynamicCounter.increment(task\n                                        .getAction().name()\n                                        + \"_retries\");\n                                done = false;\n                            } else {\n                                logger.info(\n                                        \"Not re-trying this exception because it does not seem to be a network exception\",\n                                        e);\n                            }\n                        }\n                    } while (!done);\n                }\n            }\n        });\n    }\n","new_comment_raw":"@return The batcher instance","old_comment_raw":"@return The batcher instance","label":0,"pre_label":1,"AST_level":20,"line_counts":217,"new_code_token_num":1115},{"new_code_raw":"public Date getEnd() { if (records.size() == NUM) { return new Date(); } else { Date last = records.get(NUM).getDate(); for (Entry e : records) { if (e.getDate().after(last)) { last = e.getDate(); } } return last; } }","old_code_raw":"public Date getEnd() {\n    if (records.size() == NUM) {\n        return null;\n    } else {\n        Date last = records.get(NUM).getDate();\n        for (Entry e : records) {\n            if (e.getDate().after(last)) {\n                last = e.getDate();\n            }\n        }\n        return last;\n    }\n}","new_comment_raw":"@return The time of the last record, or the current time if there are no records","old_comment_raw":"@return The time of the last record or null if there are no records","label":1,"pre_label":0,"AST_level":11,"line_counts":13,"new_code_token_num":68},{"new_code_raw":"public boolean isStarting() { return status.get() == STARTING; }","old_code_raw":"    public boolean isStarting() {\n        return starting.get();\n    }\n","new_comment_raw":"@return true if the Connection is starting","old_comment_raw":"@return true if the Connection is starting","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":14},{"new_code_raw":"public ChuckInterceptor maxContentLength(long max) { this.maxContentLength = max; return this; }","old_code_raw":"    public ChuckInterceptor maxContentLength(long max) {\n        this.maxContentLength = max;\n    }\n","new_comment_raw":"@return The  ChuckInterceptor instance.","old_comment_raw":"@return The ChuckInterceptor instance.","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":16},{"new_code_raw":"protected boolean hasCustomerRevealAnimator() { return true; }","old_code_raw":"  protected boolean hasCustomerRevealAnimator() {\n    return false;\n  }\n","new_comment_raw":"@return True if you don't want use Android native reveal animator in order to use your own custom one","old_comment_raw":"@return True if you don't want use Android native reveal animator in order to use your own custom one","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"protected final List<SyntaxTreeNode> getContents() { return _contents; }","old_code_raw":"protected final Vector getContents() {\n    return _contents;\n}","new_comment_raw":"@return A List containing all the child nodes of this node.","old_comment_raw":"@return A Vector containing all the child nodes of this node.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":12},{"new_code_raw":"@Override public AbstractContainerRequestValueFactory<?> createValueFactory(Parameter parameter) { if (!principalClass.equals(parameter.getRawType())) { return null; } return new AbstractContainerRequestValueFactory<Principal>() { public Principal provide() { final Principal principal = getContainerRequest().getSecurityContext().getUserPrincipal(); if (principal == null) { throw new IllegalStateException(STR); } return principal; } }; }","old_code_raw":"@Override\npublic AbstractContainerRequestValueFactory<?> createValueFactory(Parameter parameter) {\n    Class<?> classType = parameter.getRawType();\n    if (classType == null || (!classType.equals(clazz))) {\n        return null;\n    }\n    return new AuthValueFactory<T>();\n}","new_comment_raw":"@return the factory if parameter matched type","old_comment_raw":"@return {@link AuthValueFactory} if parameter matched type","label":1,"pre_label":0,"AST_level":10,"line_counts":16,"new_code_token_num":75},{"new_code_raw":"protected Object convertBigInt(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0L; } if (data instanceof Long) return data; if (data instanceof Number) { Number value = (Number) data; return new Long(value.longValue()); } if (data instanceof Boolean) { return NumberConversions.getLong((Boolean) data); } return handleUnknownData(column, fieldDefn, data); }","old_code_raw":"    protected Object convertBigInt(Column column, Field fieldDefn, Object data) {\n        if (data == null) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return 0L;\n        }\n        if (data instanceof Long) return data;\n        if (data instanceof Number) {\n            Number value = (Number) data;\n            return new Long(value.longValue());\n        }\n        if (data instanceof Boolean) {\n            return ((Boolean) data).booleanValue() ? LONG_TRUE : LONG_FALSE;\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","label":0,"pre_label":1,"AST_level":8,"line_counts":19,"new_code_token_num":113},{"new_code_raw":"public int removeAll(Predicate<K> predicate) { ArrayList<Entry<K, V>> oldEntries; synchronized (this) { mExclusiveEntries.removeAll(predicate); oldEntries = mCachedEntries.removeAll(predicate); makeOrphans(oldEntries); } maybeClose(oldEntries); maybeUpdateCacheParams(); maybeEvictEntries(); return oldEntries.size(); }","old_code_raw":"public long removeAll(Predicate<K> match) {\n    long numEvictedEntries = NUM;\n    List<CacheEntry<K, V>> matchingEntriesFromEvictionQueue;\n    synchronized (this) {\n        matchingEntriesFromEvictionQueue = getMatchingEntriesFromEvictionQueue(match);\n        numEvictedEntries += matchingEntriesFromEvictionQueue.size();\n        for (CacheEntry<K, V> cacheEntry : matchingEntriesFromEvictionQueue) {\n            removeFromEvictionQueue(cacheEntry);\n            removeFromCachedEntries(cacheEntry);\n            mMemoryCacheIndex.removeEntry(cacheEntry.key, cacheEntry.value);\n        }\n        List<CacheEntry<K, V>> matchingCachedEntries = getMatchingCachedEntries(match);\n        numEvictedEntries += matchingCachedEntries.size();\n        for (CacheEntry<K, V> cacheEntry : matchingCachedEntries) {\n            moveFromCachedEntriesToOrphans(cacheEntry);\n            mMemoryCacheIndex.removeEntry(cacheEntry.key, cacheEntry.value);\n        }\n    }\n    for (CacheEntry<K, V> cacheEntry : matchingEntriesFromEvictionQueue) {\n        cacheEntry.value.close();\n    }\n    return numEvictedEntries;\n}","new_comment_raw":"@return number of the items removed from the cache","old_comment_raw":"@return number of entries that were evicted from the cache","label":1,"pre_label":0,"AST_level":8,"line_counts":12,"new_code_token_num":60},{"new_code_raw":"private ColumnState buildMap(ContainerState parent, ColumnReadProjection colProj) { ColumnMetadata columnSchema = colProj.providedSchema(); \/\/ When dynamically adding columns, must add the (empty) \/\/ map by itself, then add columns to the map via separate \/\/ calls. assert columnSchema.isMap(); assert columnSchema.mapSchema().size() == 0; \/\/ Create the vector, vector state and writer. if (columnSchema.isArray()) { return buildMapArray(parent, colProj); } else { return buildSingleMap(parent, colProj); } }","old_code_raw":"  private ColumnState buildMap(ContainerState parent, ColumnTransform outputCol) {\n    ColumnMetadata columnSchema = outputCol.outputSchema();\n\n    \/\/ When dynamically adding columns, must add the (empty)\n    \/\/ map by itself, then add columns to the map via separate\n    \/\/ calls.\n\n    assert columnSchema.isMap();\n    assert columnSchema.mapSchema().size() == 0;\n\n    \/\/ Create the vector, vector state and writer.\n\n    if (columnSchema.isArray()) {\n      return buildMapArray(parent, outputCol);\n    } else {\n      return buildSingleMap(parent, outputCol);\n    }\n  }\n","new_comment_raw":"@return column state for the map column","old_comment_raw":"@return column state for the map column","label":0,"pre_label":1,"AST_level":7,"line_counts":19,"new_code_token_num":103},{"new_code_raw":"public EString append(String str) { return append(EStringConst.create(str)); }","old_code_raw":"    public EString append(String str) {\n        return append(EString.__create(str));\n    }\n","new_comment_raw":"@return this + str","old_comment_raw":"@return this + str","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":19},{"new_code_raw":"public static List getEditorSearchPath() { String[] paths = PropertyEditorManager.getEditorSearchPath(); List pathList = new ArrayList(paths.length); for (int i = NUM; i < paths.length; i++) { pathList.add(paths[i]); } return pathList; }","old_code_raw":"public static List getEditorSearchPath() {\n    String[] path = PropertyEditorManager.getEditorSearchPath();\n    List list = new ArrayList(path.length);\n    for (int i = NUM; i < path.length; i++) {\n        list.add(path[i]);\n    }\n    return list;\n}","new_comment_raw":"@return a List object containing all of the registered search paths.","old_comment_raw":"@return The package names that will be searched for property editors.","label":1,"pre_label":0,"AST_level":9,"line_counts":8,"new_code_token_num":54},{"new_code_raw":"public String getName() { String name = path.getFileName().toString(); if (name.toLowerCase().endsWith(Aes256Cryptor.FOLDER_EXTENSION.toLowerCase())) { name = name.substring(0, name.length() - Aes256Cryptor.FOLDER_EXTENSION.length()); } return name; }","old_code_raw":"\tpublic String getName() {\n\t\treturn path.getFileName().toString();\n\t}\n","new_comment_raw":"@return Directory name without preceeding path components","old_comment_raw":"@return Directory name without preceeding path components","label":0,"pre_label":1,"AST_level":9,"line_counts":8,"new_code_token_num":55},{"new_code_raw":"public <T> int querySimpleList(Class<T> c, String sqlCmd, Connection conn, Collection<T> result) { if (checkOpen() == false) return -NUM; ResultSet rs = null; try { long start = System.currentTimeMillis(); if (log.isInfoEnabled()) log.info(STR + sqlCmd); rs = driver.executeQuery(sqlCmd, null, false, conn); if (rs == null) { error(driver); return -NUM; } int count = NUM; while (rs.next()) { T item = ObjectUtils.convert(c, rs.getObject(NUM)); result.add(item); count++; } if (log.isInfoEnabled()) log.info(STR + String.valueOf(count) + STR + String.valueOf(System.currentTimeMillis() - start) + STR); clearError(); return count; } catch (ClassCastException e) { log.error(STR, e); error(Errors.Exception, e); return -NUM; } catch (SQLException e) { log.error(STR, e); error(DBErrors.QueryFailed, e); return -NUM; } finally { closeResultSet(rs); } }","old_code_raw":"public <T> List<T> querySimpleList(Class<T> c, String sqlCmd, Connection conn) {\n    if (checkOpen() == false)\n        return null;\n    ResultSet rs = null;\n    try {\n        if (checkOpen() == false)\n            return null;\n        long start = System.currentTimeMillis();\n        if (log.isInfoEnabled())\n            log.info(STR + sqlCmd);\n        rs = driver.executeQuery(sqlCmd, null, false, conn);\n        if (rs == null) {\n            error(driver);\n            return null;\n        }\n        List<T> result = new ArrayList<T>();\n        while (rs.next()) {\n            T item = ObjectUtils.convert(c, rs.getObject(NUM));\n            result.add(item);\n        }\n        if (log.isInfoEnabled())\n            log.info(STR + String.valueOf(result.size()) + STR + String.valueOf(System.currentTimeMillis() - start) + STR);\n        clearError();\n        return result;\n    } catch (ClassCastException e) {\n        log.error(STR, e);\n        error(Errors.Exception, e);\n        return null;\n    } catch (SQLException e) {\n        log.error(STR, e);\n        error(DBErrors.QueryFailed, e);\n        return null;\n    } finally {\n        closeResultSet(rs);\n    }\n}","new_comment_raw":"@return the number of elements that have been added to the collection or -1 if an error occurred","old_comment_raw":"@return a list of the values of the first column of an sql query","label":1,"pre_label":0,"AST_level":12,"line_counts":35,"new_code_token_num":230},{"new_code_raw":"public static int getIEVersion(WebDriver driver) { String userAgent = getUserAgent(driver); \/\/ extract browser string Pattern browserPattern = Pattern.compile(\"MSIE\\\\s+\\\\d+\\\\.\"); Matcher browserMatcher = browserPattern.matcher(userAgent); \/\/ IE dropped the \"MSIE\" token from its user agent string starting with IE11. Pattern tridentPattern = Pattern.compile(\"Trident\/\\\\d+\\\\.\"); Matcher tridentMatcher = tridentPattern.matcher(userAgent); Matcher versionMatcher; if (browserMatcher.find()) { versionMatcher = Pattern.compile(\"(\\\\d+)\").matcher(browserMatcher.group()); } else if (tridentMatcher.find()) { versionMatcher = Pattern.compile(\"rv:(\\\\d+)\").matcher(userAgent); } else { return 0; } \/\/ extract version string if (!versionMatcher.find()) { return 0; } return Integer.parseInt(versionMatcher.group(1)); }","old_code_raw":"  public static int getIEVersion(WebDriver driver) {\n    \/\/ extract browser string\n    Pattern browserPattern = Pattern.compile(\"MSIE\\\\s+\\\\d+\\\\.\");\n    Matcher browserMatcher = browserPattern.matcher(getUserAgent(driver));\n    if (!browserMatcher.find()) {\n      return 0;\n    }\n    String browserStr = browserMatcher.group();\n\n    \/\/ extract version string\n    Pattern versionPattern = Pattern.compile(\"\\\\d+\");\n    Matcher versionMatcher = versionPattern.matcher(browserStr);\n    if (!versionMatcher.find()) {\n      return 0;\n    }\n    return Integer.parseInt(versionMatcher.group());\n  }\n","new_comment_raw":"@return The found version, or 0 if no version could be found.","old_comment_raw":"@return The found version, or 0 if no version could be found.","label":0,"pre_label":1,"AST_level":10,"line_counts":25,"new_code_token_num":190},{"new_code_raw":"public DateTimeField halfdayOfDay() { return UnsupportedDateTimeField.getInstance (DateTimeFieldType.halfdayOfDay(), UnsupportedDurationField.getInstance(\"halfdays\")); }","old_code_raw":"    public DateTimeField halfdayOfDay() {\n        return UnsupportedDateTimeField.getInstance\n            (\"halfdayOfDay\", UnsupportedDurationField.getInstance(\"halfdays\"));\n    }\n","new_comment_raw":"@return DateTimeField or UnsupportedDateTimeField if unsupported","old_comment_raw":"@return DateTimeField or UnsupportedDateTimeField if unsupported","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":25},{"new_code_raw":"public final int getValue(long timestamp) { Score s = getByTimestamp(timestamp); if (s != null) return s.getValue(); return NUM; }","old_code_raw":"public int getValue(long timestamp) {\n    computeAll();\n    String[] args = { habit.getId().toString(), Long.toString(timestamp) };\n    return SQLiteUtils.intQuery(STR, args);\n}","new_comment_raw":"@return score value for that day","old_comment_raw":"@return score for that day","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":32},{"new_code_raw":"public Integer getIndexForColumnName(String columnName, ResultSet rs) throws SQLException { final Integer cached = columnNameToIndexCache.get( columnName ); if ( cached != null ) { return cached; } else { final Integer index = Integer.valueOf( rs.findColumn( columnName ) ); columnNameToIndexCache.put( columnName, index); return index; } }","old_code_raw":"\tpublic int getIndexForColumnName(String columnName, ResultSet rs) throws SQLException {\n\t\tfinal Integer cached = columnNameToIndexCache.get( columnName );\n\t\tif ( cached != null ) {\n\t\t\treturn cached;\n\t\t}\n\t\telse {\n\t\t\tfinal int index = rs.findColumn( columnName );\n\t\t\tcolumnNameToIndexCache.put( columnName, index);\n\t\t\treturn index;\n\t\t}\n\t}\n","new_comment_raw":"@return The index","old_comment_raw":"@return The index","label":0,"pre_label":1,"AST_level":9,"line_counts":12,"new_code_token_num":61},{"new_code_raw":"public static SchemaPath parseFromString(String expr) { if (expr == null || expr.isEmpty()) { return null; } if (SchemaPath.DYNAMIC_STAR.equals(expr)) { return SchemaPath.getSimplePath(expr); } LogicalExpression logicalExpression = LogicalExpressionParser.parse(expr); if (logicalExpression instanceof SchemaPath) { return (SchemaPath) logicalExpression; } else { throw new IllegalStateException(String.format(\"Schema path is not a valid format: %s.\", logicalExpression)); } }","old_code_raw":"  public static SchemaPath parseFromString(String expr) {\n    if (expr == null || expr.isEmpty()) {\n      return null;\n    }\n    try {\n      if (SchemaPath.DYNAMIC_STAR.equals(expr)) {\n        return SchemaPath.getSimplePath(expr);\n      }\n      ExprLexer lexer = new ExprLexer(new ANTLRStringStream(expr));\n      CommonTokenStream tokens = new CommonTokenStream(lexer);\n      ExprParser parser = new ExprParser(tokens);\n\n      parse_return ret = parser.parse();\n\n      if (ret.e instanceof SchemaPath) {\n        return (SchemaPath) ret.e;\n      } else {\n        throw new IllegalStateException(\"Schema path is not a valid format.\");\n      }\n    } catch (RecognitionException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","new_comment_raw":"@return  SchemaPath instance","old_comment_raw":"@return SchemaPath instance","label":0,"pre_label":1,"AST_level":8,"line_counts":17,"new_code_token_num":93},{"new_code_raw":"public String[] getAttributeFromAllWindows(String attributeName) { String current = driver.getWindowHandle(); List<String> attributes = new ArrayList<String>(); for (String handle : driver.getWindowHandles()) { driver.switchTo().window(handle); String value = (String) ((JavascriptExecutor) driver).executeScript( \"return '' + window[arguments[0]];\", attributeName); attributes.add(value); } driver.switchTo().window(current); return attributes.toArray(new String[attributes.size()]); }","old_code_raw":"  public String[] getAttributeFromAllWindows(String attributeName) {\n    throw new UnsupportedOperationException(\"getAttributeFromAllWindows\");\n  }\n","new_comment_raw":"@return the set of values of this attribute from all known windows.","old_comment_raw":"@return the set of values of this attribute from all known windows.","label":0,"pre_label":1,"AST_level":9,"line_counts":16,"new_code_token_num":108},{"new_code_raw":"public PingResult performCheck(PingConfiguration configuration) { PingResult info = client.ping(configuration); setPingInfo(info, configuration, client); return info; }","old_code_raw":"public PingInfo performCheck(PingConfiguration configuration) {\n    PingInfo info = client.ping(configuration);\n    setPingInfo(info, configuration, client);\n    return info;\n}","new_comment_raw":"@return {@link PingResult}","old_comment_raw":"@return {@link PingInfo}","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":29},{"new_code_raw":"CloseableReference<Bitmap> decodeFromEncodedImage(EncodedImage encodedImage) { return doDecodeStaticImage(encodedImage.getInputStream(), encodedImage.getSampleSize()); }","old_code_raw":"  CloseableReference<Bitmap> decodeFromEncodedImage(EncodedImage encodedImage) {\n    return doDecodeStaticImage(encodedImage.getInputStream());\n  }\n","new_comment_raw":"@return the bitmap","old_comment_raw":"@return the bitmap","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":23},{"new_code_raw":"public boolean searchEditText(String search) { Pattern p = Pattern.compile(search); Matcher matcher; ArrayList<EditText> editTextList = getCurrentEditTexts(); Iterator<EditText> iterator = editTextList.iterator(); while (iterator.hasNext()) { EditText editText = (EditText) iterator.next(); matcher = p.matcher(editText.getText().toString()); if (matcher.matches()) { return true; } } if (scrollDownList()) return searchEditText(search); else return false; }","old_code_raw":"public EditText searchEditText(String search) {\n    ArrayList<EditText> editTextList = getCurrentEditTexts();\n    Iterator<EditText> iterator = editTextList.iterator();\n    while (iterator.hasNext()) {\n        EditText editText = (EditText) iterator.next();\n        if (editText.getText().toString().equals(search)) {\n            return editText;\n        }\n    }\n    return null;\n}","new_comment_raw":"@return true if an edit text with the given text is found or false if it is not found","old_comment_raw":"@return the EditText found or null if nothing is found","label":1,"pre_label":0,"AST_level":9,"line_counts":17,"new_code_token_num":95},{"new_code_raw":"public static List<CoreMap> findAndMergeNumbers(CoreMap annotationRaw){ \/\/copy annotation to preserve its integrity CoreMap annotation = new ArrayCoreMap(annotationRaw); \/\/ Find and label numbers List<CoreMap> numbers = NumberNormalizer.findNumbers(annotation); CoreMapAggregator numberAggregator = CoreMapAggregator.getAggregator(CoreMapAttributeAggregator.DEFAULT_NUMERIC_AGGREGATORS, CoreAnnotations.TokensAnnotation.class); \/\/ We are going to mark the token begin and token end for each token so we can more easily deal with \/\/ ensuring correct token offsets for merging \/\/get sentence offset Integer startTokenOffset = annotation.get(CoreAnnotations.TokenBeginAnnotation.class); if (startTokenOffset == null) { startTokenOffset = 0; } \/\/set token offsets int i = 0; List<Integer> savedTokenBegins = new LinkedList<Integer>(); List<Integer> savedTokenEnds = new LinkedList<Integer>(); for (CoreMap c:annotation.get(CoreAnnotations.TokensAnnotation.class)) { \/\/set token begin if( (i==0 && c.get(CoreAnnotations.TokenBeginAnnotation.class) != null) || (i > 0 && !savedTokenBegins.isEmpty()) ){ savedTokenBegins.add(c.get(CoreAnnotations.TokenBeginAnnotation.class)); } c.set(CoreAnnotations.TokenBeginAnnotation.class, i+startTokenOffset); i++; \/\/set token end if( (i==1 && c.get(CoreAnnotations.TokenEndAnnotation.class) != null) || (i > 1 && !savedTokenEnds.isEmpty()) ){ savedTokenEnds.add(c.get(CoreAnnotations.TokenEndAnnotation.class)); } c.set(CoreAnnotations.TokenEndAnnotation.class, i+startTokenOffset); } \/\/merge numbers final Integer startTokenOffsetFinal = startTokenOffset; List<CoreMap> mergedNumbers = numberAggregator.merge(annotation.get(CoreAnnotations.TokensAnnotation.class), numbers, in -> Interval.toInterval( in.get(CoreAnnotations.TokenBeginAnnotation.class) - startTokenOffsetFinal, in.get(CoreAnnotations.TokenEndAnnotation.class) - startTokenOffsetFinal) ); \/\/restore token offsets if (!savedTokenBegins.isEmpty() && !savedTokenEnds.isEmpty()) { for (CoreMap c : mergedNumbers) { \/\/ get new indices int newBegin = c.get(CoreAnnotations.TokenBeginAnnotation.class) - startTokenOffset; int newEnd = c.get(CoreAnnotations.TokenEndAnnotation.class) - startTokenOffset; \/\/ get token offsets for those indices c.set(CoreAnnotations.TokenBeginAnnotation.class, savedTokenBegins.get(newBegin)); c.set(CoreAnnotations.TokenEndAnnotation.class, savedTokenEnds.get(newEnd-1)); } } \/\/return return mergedNumbers; }","old_code_raw":"  public static List<CoreMap> findAndMergeNumbers(CoreMap annotationRaw){\n    \/\/copy annotation to preserve its integrity\n    CoreMap annotation = new ArrayCoreMap(annotationRaw);\n    \/\/ Find and label numbers\n    List<CoreMap> numbers = NumberNormalizer.findNumbers(annotation);\n    CoreMapAggregator numberAggregator = CoreMapAggregator.getAggregator(CoreMapAttributeAggregator.DEFAULT_NUMERIC_AGGREGATORS, CoreAnnotations.TokensAnnotation.class);\n\n    \/\/ We are going to mark the token begin and token end for each token so we can more easily deal with\n    \/\/ ensuring correct token offsets for merging\n    \/\/get sentence offset\n    Integer startTokenOffset = annotation.get(CoreAnnotations.TokenBeginAnnotation.class);\n    if (startTokenOffset == null) {\n      startTokenOffset = 0;\n    }\n    \/\/set token offsets\n    int i = 0;\n    List<Integer> savedTokenBegins = new LinkedList<Integer>();\n    List<Integer> savedTokenEnds = new LinkedList<Integer>();\n    for (CoreMap c:annotation.get(CoreAnnotations.TokensAnnotation.class)) {\n      \/\/set token begin\n      if( (i==0 && c.get(CoreAnnotations.TokenBeginAnnotation.class) != null) || (i > 0 && !savedTokenBegins.isEmpty()) ){\n        savedTokenBegins.add(c.get(CoreAnnotations.TokenBeginAnnotation.class));\n      }\n      c.set(CoreAnnotations.TokenBeginAnnotation.class, i+startTokenOffset);\n      i++;\n      \/\/set token end\n      if( (i==1 && c.get(CoreAnnotations.TokenEndAnnotation.class) != null) || (i > 1 && !savedTokenEnds.isEmpty()) ){\n        savedTokenEnds.add(c.get(CoreAnnotations.TokenEndAnnotation.class));\n      }\n      c.set(CoreAnnotations.TokenEndAnnotation.class, i+startTokenOffset);\n    }\n    \/\/merge numbers\n    final Integer startTokenOffsetFinal = startTokenOffset;\n    List<CoreMap> mergedNumbers = numberAggregator.merge(annotation.get(CoreAnnotations.TokensAnnotation.class), numbers,\n          new Function<CoreMap, Interval<Integer>>() {\n            @Override\n            public Interval<Integer> apply(CoreMap in) {\n              return Interval.toInterval(\n                    in.get(CoreAnnotations.TokenBeginAnnotation.class) - startTokenOffsetFinal,\n                    in.get(CoreAnnotations.TokenEndAnnotation.class) - startTokenOffsetFinal);\n            }\n          });\n    \/\/restore token offsets\n    if (!savedTokenBegins.isEmpty() && !savedTokenEnds.isEmpty()) {\n      for (CoreMap c : mergedNumbers) {\n        \/\/ get new indices\n        int newBegin = c.get(CoreAnnotations.TokenBeginAnnotation.class) - startTokenOffset;\n        int newEnd = c.get(CoreAnnotations.TokenEndAnnotation.class) - startTokenOffset;\n        \/\/ get token offsets for those indices\n        c.set(CoreAnnotations.TokenBeginAnnotation.class, savedTokenBegins.get(newBegin));\n        c.set(CoreAnnotations.TokenEndAnnotation.class, savedTokenEnds.get(newEnd-1));\n      }\n    }\n    \/\/return\n    return mergedNumbers;\n  }\n","new_comment_raw":"@return list of CoreMap representing the identified numbers","old_comment_raw":"@return list of CoreMap representing the identified numbers","label":0,"pre_label":1,"AST_level":12,"line_counts":53,"new_code_token_num":437},{"new_code_raw":"public Task<EncodedImage> get(CacheKey key, AtomicBoolean isCancelled) { final EncodedImage pinnedImage = mStagingArea.get(key); if (pinnedImage != null) { return foundPinnedImage(key, pinnedImage); } return getAsync(key, isCancelled); }","old_code_raw":"public Task<EncodedImage> get(final CacheKey key, final AtomicBoolean isCancelled) {\n    Preconditions.checkNotNull(key);\n    Preconditions.checkNotNull(isCancelled);\n    final EncodedImage pinnedImage = mStagingArea.get(key);\n    if (pinnedImage != null) {\n        FLog.v(TAG, STR, key.toString());\n        mImageCacheStatsTracker.onStagingAreaHit();\n        return Task.forResult(pinnedImage);\n    }\n    try {\n        return Task.call(new Callable<EncodedImage>() {\n\n            @Override\n            public EncodedImage call() throws Exception {\n                if (isCancelled.get()) {\n                    throw new CancellationException();\n                }\n                EncodedImage result = mStagingArea.get(key);\n                if (result != null) {\n                    FLog.v(TAG, STR, key.toString());\n                    mImageCacheStatsTracker.onStagingAreaHit();\n                } else {\n                    FLog.v(TAG, STR, key.toString());\n                    mImageCacheStatsTracker.onStagingAreaMiss();\n                    try {\n                        final PooledByteBuffer buffer = readFromDiskCache(key);\n                        CloseableReference<PooledByteBuffer> ref = CloseableReference.of(buffer);\n                        try {\n                            result = new EncodedImage(ref);\n                        } finally {\n                            CloseableReference.closeSafely(ref);\n                        }\n                    } catch (Exception exception) {\n                        return null;\n                    }\n                }\n                if (Thread.interrupted()) {\n                    FLog.v(TAG, STR);\n                    if (result != null) {\n                        result.close();\n                    }\n                    throw new InterruptedException();\n                } else {\n                    return result;\n                }\n            }\n        }, mReadExecutor);\n    } catch (Exception exception) {\n        FLog.w(TAG, exception, STR, key.toString());\n        return Task.forError(exception);\n    }\n}","new_comment_raw":"@return Task that resolves to cached element or null if one cannot be retrieved; returned task never rethrows any exception","old_comment_raw":"@return ListenableFuture that resolves to cached element or null if one cannot be retrieved; returned future never rethrows any exception","label":1,"pre_label":0,"AST_level":7,"line_counts":7,"new_code_token_num":46},{"new_code_raw":"public List<ResourceFilter> create(AbstractMethod am) { LinkedList<ResourceFilter> list = new LinkedList<ResourceFilter>(); Filter f; if (logger.isDebugEnabled()) { for (Annotation annotation : am.getAnnotations()) { logger.debug(\"AtmosphereFilter processing annotation: {}\", annotation); } } if (am.getMethod() == null) { return null; } if (SuspendResponse.class.isAssignableFrom(am.getMethod().getReturnType())) { list.addLast(new Filter(Action.SUSPEND_RESPONSE)); return list; } if (am.isAnnotationPresent(Broadcast.class)) { int delay = am.getAnnotation(Broadcast.class).delay(); Class[] suspendTimeout = am.getAnnotation(Broadcast.class).value(); if (am.getAnnotation(Broadcast.class).resumeOnBroadcast()) { f = new Filter(Action.RESUME_ON_BROADCAST, delay, 0, Suspend.SCOPE.APPLICATION, true, suspendTimeout); } else { f = new Filter(Action.BROADCAST, delay, 0, Suspend.SCOPE.APPLICATION, true, suspendTimeout); } list.addLast((ResourceFilter) f); if (am.isAnnotationPresent(Cluster.class)) { suspendTimeout = am.getAnnotation(Cluster.class).value(); for (Class<ClusterBroadcastFilter> c : suspendTimeout) { try { ClusterBroadcastFilter cbf = c.newInstance(); InjectorProvider.getInjector().inject(cbf); cbf.setUri(am.getAnnotation(Cluster.class).name()); f.addCluster(cbf); } catch (Throwable t) { logger.warn(\"Invalid ClusterBroadcastFilter\", t); } } } } if (am.isAnnotationPresent(Suspend.class)) { long suspendTimeout = am.getAnnotation(Suspend.class).period(); TimeUnit tu = am.getAnnotation(Suspend.class).timeUnit(); suspendTimeout = translateTimeUnit(suspendTimeout,tu); Suspend.SCOPE scope = am.getAnnotation(Suspend.class).scope(); boolean outputComments = am.getAnnotation(Suspend.class).outputComments(); if (am.getAnnotation(Suspend.class).resumeOnBroadcast()) { f = new Filter(Action.SUSPEND_RESUME, suspendTimeout, 0, scope, outputComments); } else { f = new Filter(Action.SUSPEND, suspendTimeout, 0, scope, outputComments); } f.setListeners(am.getAnnotation(Suspend.class).listeners()); list.addFirst((ResourceFilter) f); } if (am.isAnnotationPresent(Resume.class)) { int suspendTimeout = am.getAnnotation(Resume.class).value(); list.addFirst(new Filter(Action.RESUME, suspendTimeout)); } if (am.isAnnotationPresent(Schedule.class)) { int period = am.getAnnotation(Schedule.class).period(); int waitFor = am.getAnnotation(Schedule.class).waitFor(); if (am.getAnnotation(Schedule.class).resumeOnBroadcast()) { list.addFirst(new Filter(Action.SCHEDULE_RESUME, period, waitFor)); } else { list.addFirst(new Filter(Action.SCHEDULE, period, waitFor)); } } \/\/ Nothing, normal Jersey application. return list.size() > 0 ? list : null; }","old_code_raw":"    public List<ResourceFilter> create(AbstractMethod am) {\n        LinkedList<ResourceFilter> list = new LinkedList<ResourceFilter>();\n        Filter f;\n\n        if (logger.isDebugEnabled()) {\n            for (Annotation annotation : am.getAnnotations()) {\n                logger.debug(\"AtmosphereFilter processing annotation: {}\", annotation);\n            }\n        }\n\n        if (SuspendResponse.class.isAssignableFrom(am.getMethod().getReturnType())) {\n            list.addLast(new Filter(Action.SUSPEND_RESPONSE));\n            return list;\n        }\n\n        if (am.isAnnotationPresent(Broadcast.class)) {\n            int delay = am.getAnnotation(Broadcast.class).delay();\n            Class[] suspendTimeout = am.getAnnotation(Broadcast.class).value();\n\n            if (am.getAnnotation(Broadcast.class).resumeOnBroadcast()) {\n                f = new Filter(Action.RESUME_ON_BROADCAST, delay, 0, Suspend.SCOPE.APPLICATION, true, suspendTimeout);\n            } else {\n                f = new Filter(Action.BROADCAST, delay, 0, Suspend.SCOPE.APPLICATION, true, suspendTimeout);\n            }\n\n            list.addLast((ResourceFilter) f);\n\n            if (am.isAnnotationPresent(Cluster.class)) {\n                suspendTimeout = am.getAnnotation(Cluster.class).value();\n                for (Class<ClusterBroadcastFilter> c : suspendTimeout) {\n                    try {\n                        ClusterBroadcastFilter cbf = c.newInstance();\n                        InjectorProvider.getInjector().inject(cbf);\n                        cbf.setUri(am.getAnnotation(Cluster.class).name());\n                        f.addCluster(cbf);\n                    }\n                    catch (Throwable t) {\n                        logger.warn(\"Invalid ClusterBroadcastFilter\", t);\n                    }\n                }\n            }\n        }\n\n        if (am.isAnnotationPresent(Suspend.class)) {\n\n            long suspendTimeout = am.getAnnotation(Suspend.class).period();\n            TimeUnit tu = am.getAnnotation(Suspend.class).timeUnit();\n            suspendTimeout = translateTimeUnit(suspendTimeout,tu);\n\n            Suspend.SCOPE scope = am.getAnnotation(Suspend.class).scope();\n            boolean outputComments = am.getAnnotation(Suspend.class).outputComments();\n\n            if (am.getAnnotation(Suspend.class).resumeOnBroadcast()) {\n                f = new Filter(Action.SUSPEND_RESUME, suspendTimeout, 0, scope, outputComments);\n            } else {\n                f = new Filter(Action.SUSPEND, suspendTimeout, 0, scope, outputComments);\n            }\n            f.setListeners(am.getAnnotation(Suspend.class).listeners());\n\n            list.addFirst((ResourceFilter) f);\n        }\n\n        if (am.isAnnotationPresent(Resume.class)) {\n            int suspendTimeout = am.getAnnotation(Resume.class).value();\n            list.addFirst(new Filter(Action.RESUME, suspendTimeout));\n        }\n\n        if (am.isAnnotationPresent(Schedule.class)) {\n            int period = am.getAnnotation(Schedule.class).period();\n            int waitFor = am.getAnnotation(Schedule.class).waitFor();\n\n            if (am.getAnnotation(Schedule.class).resumeOnBroadcast()) {\n                list.addFirst(new Filter(Action.SCHEDULE_RESUME, period, waitFor));\n            } else {\n                list.addFirst(new Filter(Action.SCHEDULE, period, waitFor));\n            }\n        }\n\n        \/\/ Nothing, normal Jersey application.\n        return list.size() > 0 ? list : null;\n    }\n","new_comment_raw":"@return a List of  ResourceFilter to invoke.","old_comment_raw":"@return a List of ResourceFilter to invoke.","label":0,"pre_label":1,"AST_level":14,"line_counts":86,"new_code_token_num":570},{"new_code_raw":"protected boolean useGzipWhenAccepted(Response r) { return r.getMimeType() != null && r.getMimeType().toLowerCase().contains(\"text\/\"); }","old_code_raw":"    protected boolean useGzipWhenAccepted() {\n        return false;\n    }\n","new_comment_raw":"@return true if the gzip compression should be used if the client accespts it. Default this option is on for text content and off for everything else.","old_comment_raw":"@return true if the gzip compression should be used if the client accespts it. Default this option is tuned off.","label":1,"pre_label":0,"AST_level":7,"line_counts":4,"new_code_token_num":33},{"new_code_raw":"public int toStatusCode(Throwable e) { if (e == null) { return SUCCESS; } Set<Integer> possibleMatches = KNOWN_ERRORS.stream() .filter(knownError -> knownError.getException().equals(e.getClass())) .filter(knownError -> knownError.isCanonicalJsonCodeForException) .map(KnownError::getJsonCode) .collect(Collectors.toSet()); return Iterables.getOnlyElement(possibleMatches, UNHANDLED_ERROR); }","old_code_raw":"  public int toStatusCode(Throwable e) {\n    if (e == null) {\n      return SUCCESS;\n    }\n\n    \/\/ Handle the cases where the JSON wire protocol was more specific than the W3C one\n    if (ImeNotAvailableException.class.equals(e.getClass())) {\n      return IME_NOT_AVAILABLE;\n    }\n    if (ImeActivationFailedException.class.equals(e.getClass())) {\n      return IME_ENGINE_ACTIVATION_FAILED;\n    }\n\n    \/\/ And then handle the other cases\n    Stream<StatusTuple> allCodesStream = ALL_CODES.values().stream()\n      .flatMap(Collection::stream)\n      .filter(tuple -> tuple.getException() != null)\n      .filter(tuple -> tuple.associatedException.isAssignableFrom(e.getClass()));\n\n    if (e instanceof WebDriverException && ((WebDriverException)e).getStatusCode() != null) {\n      allCodesStream = allCodesStream.filter(tuple -> ((WebDriverException)e).getStatusCode() == tuple.jsonStatus );\n    }\n\n    Set<Integer> possibleMatches = allCodesStream\n      .map(StatusTuple::getStatusFromException)\n      .collect(Collectors.toSet());\n\n    if (possibleMatches.size() > 1) {\n      \/\/ if there's multiple matches, let's try filtering on the exact exception class to see if we\n      \/\/ can reduce the possibilities\n      Set<Integer> reducedPossibleMatches = ALL_CODES.values().stream()\n        .flatMap(Collection::stream)\n        .filter(tuple -> tuple.getException() != null)\n        .filter(tuple -> tuple.associatedException.equals(e.getClass()))\n        .map(StatusTuple::getStatusFromException)\n        .collect(Collectors.toSet());\n\n      if (reducedPossibleMatches.size() > 0) {\n        possibleMatches = reducedPossibleMatches;\n      }\n    }\n\n    return Preconditions.checkNotNull(Iterables.getFirst(possibleMatches, UNHANDLED_ERROR));\n  }\n","new_comment_raw":"@return The exception type that corresponds to the provided status code or  null if  statusCode == 0.","old_comment_raw":"@return The exception type that corresponds to the provided status code or null if statusCode == 0.","label":0,"pre_label":1,"AST_level":10,"line_counts":14,"new_code_token_num":73},{"new_code_raw":"protected int getInSubqueryThreshold() { return IN_SUBQUERY_THRESHOLD; }","old_code_raw":"  protected int getInSubqueryThreshold() {\n    return 20;\n  }\n","new_comment_raw":"@return threshold, default  #IN_SUBQUERY_THRESHOLD","old_comment_raw":"@return threshold, default 20","label":1,"pre_label":0,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"public Double memory(RelNode rel) { for (;;) { try { return memoryHandler.memory(rel, this); } catch (JaninoRelMetadataProvider.NoHandler e) { memoryHandler = metadataProvider.revise(e.relClass, BuiltInMetadata.Memory.DEF); } } }","old_code_raw":"  public Double memory(RelNode rel) {\n    final BuiltInMetadata.Memory metadata =\n        rel.metadata(BuiltInMetadata.Memory.class, this);\n    return metadata.memory();\n  }\n","new_comment_raw":"@return the expected amount of memory, in bytes, required by a physical operator implementing this relational expression, across all splits, or null if not known","old_comment_raw":"@return the expected amount of memory, in bytes, required by a physical operator implementing this relational expression, across all splits, or null if not known","label":0,"pre_label":1,"AST_level":10,"line_counts":11,"new_code_token_num":48},{"new_code_raw":"@Action(value = STR) public String execute() throws Exception { LOG.info(STR + id); SASFHelper helper = SASFStaticHelper.getHelper(request); if (mode == null) { url = STR + id; return STR; } else if (STR.equals(mode)) { SocialAuthManager manager = null; if (helper != null) { manager = helper.getAuthManager(); if (manager != null) { manager.disconnectProvider(id); } } return STR; } return STR; }","old_code_raw":"@Override\npublic ActionForward execute(final ActionMapping mapping, final ActionForm form, final HttpServletRequest request, final HttpServletResponse response) throws Exception {\n    SASFHelper helper = SASFStaticHelper.getHelper(request);\n    AuthForm authForm = (AuthForm) form;\n    String id = authForm.getId();\n    String mode = request.getParameter(STR);\n    ActionForward fwd = null;\n    if (mode == null) {\n        String filterUrl = STR + id;\n        fwd = new ActionForward(STR, filterUrl, true);\n    } else if (mode.equals(STR)) {\n        SocialAuthManager manager = null;\n        if (helper != null) {\n            manager = helper.getAuthManager();\n            if (manager != null)\n                manager.disconnectProvider(id);\n        }\n        fwd = mapping.findForward(STR);\n    }\n    return fwd;\n}","new_comment_raw":"@return String where the action should flow","old_comment_raw":"@return ActionForward where the action should flow","label":1,"pre_label":0,"AST_level":12,"line_counts":19,"new_code_token_num":95},{"new_code_raw":"public boolean isResolvable(PicoContainer container, ComponentAdapter adapter, Class expectedType) { final Class collectionType = getCollectionType(expectedType); return collectionType != null && (emptyCollection || getResolvingAdapters(container, adapter, expectedType).length > NUM); }","old_code_raw":"public boolean isResolvable(PicoContainer container, ComponentAdapter adapter, Class expectedType) {\n    final Class collectionType = getCollectionType(expectedType);\n    if (collectionType != null) {\n        return emptyCollection || !getMatchingComponentAdapters(container, adapter, componentKeyType, getValueType(expectedType)).isEmpty();\n    }\n    return false;\n}","new_comment_raw":"@return <code>true<\/code> if matching components were found or an empty collective type is allowed","old_comment_raw":"@return <code>true<\/code> the instance of the collection type or <code>null<\/code>","label":1,"pre_label":0,"AST_level":8,"line_counts":4,"new_code_token_num":45},{"new_code_raw":"public int getCurrentHour() { return getHourForDegrees(mSelectionDegrees[HOURS], mIsOnInnerCircle); }","old_code_raw":"    public int getCurrentHour() {\n        return getHourForDegrees(\n                mSelectionDegrees[mIsOnInnerCircle ? HOURS_INNER : HOURS], mIsOnInnerCircle);\n    }\n","new_comment_raw":"@return the current hour between 0 and 23 (inclusive)","old_comment_raw":"@return the current hour between 0 and 23 (inclusive)","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":18},{"new_code_raw":"private ZapTextField getTxtHeadline() { if (txtHeadline == null) { txtHeadline = new ZapTextField(); txtHeadline.setBorder(javax.swing.BorderFactory.createEtchedBorder(javax.swing.border.EtchedBorder.RAISED)); txtHeadline.setEditable(false); txtHeadline.setEnabled(false); txtHeadline.setBackground(java.awt.Color.white); txtHeadline.setFont(new java.awt.Font(\"Default\", java.awt.Font.BOLD, 12)); } return txtHeadline; }","old_code_raw":"\tprivate JTextField getTxtHeadline() {\n\t\tif (txtHeadline == null) {\n\t\t\ttxtHeadline = new JTextField();\n\t\t\ttxtHeadline.setBorder(javax.swing.BorderFactory.createEtchedBorder(javax.swing.border.EtchedBorder.RAISED));\n\t\t\ttxtHeadline.setEditable(false);\n\t\t\ttxtHeadline.setEnabled(false);\n\t\t\ttxtHeadline.setBackground(java.awt.Color.white);\n\t\t\ttxtHeadline.setFont(new java.awt.Font(\"Default\", java.awt.Font.BOLD, 12));\n\t\t}\n\t\treturn txtHeadline;\n\t}\n","new_comment_raw":"@return javax.swing.ZapTextField","old_comment_raw":"@return javax.swing.JTextField","label":1,"pre_label":0,"AST_level":10,"line_counts":12,"new_code_token_num":81},{"new_code_raw":"public static int getIntParam(JSONObject params, String paramName) throws ApiException { if (!params.containsKey(paramName)) { throw new ApiException(ApiException.Type.MISSING_PARAMETER, paramName); } try { return params.getInt(paramName); } catch (JSONException e) { throw new ApiException(ApiException.Type.ILLEGAL_PARAMETER, paramName, e); } }","old_code_raw":"\tpublic static int getIntParam(JSONObject params, String paramName) throws ApiException {\n\t\tint value;\n\t\ttry {\n\t\t\tvalue = params.getInt(paramName);\n\t\t} catch (Exception ex) {\n\t\t\tthrow new ApiException(Type.MISSING_PARAMETER, paramName + \": \" + ex.getLocalizedMessage());\n\t\t}\n\t\treturn value;\n\t}\n","new_comment_raw":"@return the int param","old_comment_raw":"@return the int param","label":0,"pre_label":1,"AST_level":7,"line_counts":12,"new_code_token_num":67},{"new_code_raw":"public SqlNode getTargetTable() { return targetTable; }","old_code_raw":"  public SqlIdentifier getTargetTable() {\n    return targetTable;\n  }\n","new_comment_raw":"@return the identifier for the target table of the insertion","old_comment_raw":"@return the identifier for the target table of the insertion","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"public static boolean isLocalContactUri(Uri uri) { return isLocalContentUri(uri) && ContactsContract.AUTHORITY.equals(uri.getAuthority()) && !uri.getPath().startsWith(LOCAL_CONTACT_IMAGE_URI.getPath()); }","old_code_raw":"  public static boolean isLocalContactUri(Uri uri) {\n    return isLocalContentUri(uri)\n        && ContactsContract.AUTHORITY.equals(uri.getAuthority())\n        && !uri.getPath().startsWith(LOCAL_CONTACT_IMAGE_PREFIX);\n  }\n","new_comment_raw":"@return true if the uri is a Contact URI, and is not already specifying a display photo.","old_comment_raw":"@return true if the uri is a Contact URI, and is not already specifying a display photo.","label":0,"pre_label":1,"AST_level":7,"line_counts":6,"new_code_token_num":41},{"new_code_raw":"protected boolean isOutOfRange(int year, int month, int day) { if (mController.getSelectableDays() != null) { return !isSelectable(year, month, day); } if (isBeforeMin(year, month, day)) { return true; } else if (isAfterMax(year, month, day)) { return true; } return false; }","old_code_raw":"protected boolean isOutOfRange(int year, int month, int day) {\n    if (isBeforeMin(year, month, day)) {\n        return true;\n    } else if (isAfterMax(year, month, day)) {\n        return true;\n    }\n    return false;\n}","new_comment_raw":"@return true if the specified year\/month\/day are within the selectable days or the range set by minDate and maxDate. If one or either have not been set, they are considered as Integer.MIN_VALUE and Integer.MAX_VALUE.","old_comment_raw":"@return true if the specified year\/month\/day are within the range set by minDate and maxDate. If one or either have not been set, they are considered as Integer.MIN_VALUE and Integer.MAX_VALUE.","label":1,"pre_label":0,"AST_level":7,"line_counts":11,"new_code_token_num":73},{"new_code_raw":"public static String getMessageId(SipRequest request) { String result = null; try { String content = request.getContent(); int index = content.indexOf(ImdnUtils.HEADER_IMDN_MSG_ID); if (index != -NUM) { index = index + ImdnUtils.HEADER_IMDN_MSG_ID.length() + NUM; String part = content.substring(index); String msgId = part.substring(NUM, part.indexOf(CRLF)); result = msgId.trim(); } } catch (Exception e) { } return result; }","old_code_raw":"public static String getMessageId(SipRequest request) {\n    ExtensionHeader messageIdHeader = (ExtensionHeader) request.getHeader(ImdnUtils.HEADER_IMDN_MSG_ID);\n    if (messageIdHeader != null) {\n        return messageIdHeader.getValue();\n    }\n    try {\n        String content = request.getContent();\n        int index = content.indexOf(ImdnUtils.HEADER_IMDN_MSG_ID);\n        if (index != -NUM) {\n            index = index + ImdnUtils.HEADER_IMDN_MSG_ID.length() + NUM;\n            String part = content.substring(index);\n            String msgId = part.substring(NUM, part.indexOf(SipUtils.CRLF));\n            return msgId.trim();\n        }\n    } catch (Exception e) {\n    }\n    return null;\n}","new_comment_raw":"@return Message ID","old_comment_raw":"@return String or empty","label":1,"pre_label":0,"AST_level":10,"line_counts":15,"new_code_token_num":91},{"new_code_raw":"public static Drawable mockDrawable() { return mockDrawable(FakeDrawable.class); }","old_code_raw":"  public static Drawable mockDrawable() {\n    FakeDrawable drawable = mock(FakeDrawable.class);\n    when(drawable.mutate()).thenReturn(drawable);\n    stubGetAndSetBounds(drawable);\n    stubGetAndSetCallback(drawable);\n    stubSetVisibilityCallback(drawable);\n    stubSetAlpha(drawable);\n    return drawable;\n  }\n","new_comment_raw":"@return mock Drawable","old_comment_raw":"@return mock Drawable","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":15},{"new_code_raw":"public String getterAndSetterCapitalize(String name) { if (name == null || name.length() == 0) { return name; } return org.openapitools.codegen.utils.StringUtils.camelize(toVarName(name)); }","old_code_raw":"    public String getterAndSetterCapitalize(String name) {\n        if (name == null || name.length() == 0) {\n            return name;\n        }\n        return camelize(toVarName(name));\n    }\n","new_comment_raw":"@return Camelized string","old_comment_raw":"@return Camelized string","label":0,"pre_label":1,"AST_level":6,"line_counts":7,"new_code_token_num":40},{"new_code_raw":"public String toString() { StringBuffer msg = new StringBuffer(getMessage()); String[] params = getParameters(); for (int i = NUM; i < params.length; i++) { msg.append(STR + params[i]); } return msg.toString(); }","old_code_raw":"public String toString() {\n    return message;\n}","new_comment_raw":"@return A string representation, the parameters are included as a comma-separated list.","old_comment_raw":"@return a string representation disregarding any parameters","label":1,"pre_label":0,"AST_level":10,"line_counts":8,"new_code_token_num":58},{"new_code_raw":"public List<TaggedWord> tagSentence(List<? extends HasWord> sentence) { TestSentence testSentence = new TestSentence(this); return testSentence.tagSentence(sentence, false); }","old_code_raw":"  public ArrayList<TaggedWord> tagSentence(List<? extends HasWord> sentence) {\n    TestSentence testSentence = new TestSentence(this);\n    return testSentence.tagSentence(sentence, false);\n  }\n","new_comment_raw":"@return tagged sentence","old_comment_raw":"@return tagged sentence","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":30},{"new_code_raw":"public Object getValue() { if (isPresenceType()) return null; if (multiValued) return ((Object[]) value)[NUM]; return value; }","old_code_raw":"public Object getValue() {\n    if (isPresenceType())\n        return null;\n    if (valueIsArray)\n        return ((Object[]) value)[NUM];\n    return value;\n}","new_comment_raw":"@return the value of this <code>Value<\/code> object (in case it is single valued), or the first value of this entry (in case it is multivalued).","old_comment_raw":"@return the value of this entry (in case it is single valued), or the first value of this entry (in case it is multivalued).","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":36},{"new_code_raw":"public PlaceType getPlaceType(String placeTypeName) throws InvalidPlaceType { PlaceType type = placeTypeNameCache.get(placeTypeName); if (type == null) throw new InvalidPlaceType(placeTypeName); return type; }","old_code_raw":"public PlaceType getPlaceType(String placeType) {\n    return placeTypesCache.get(placeType);\n}","new_comment_raw":"@return the PlaceType corresponding to the provided name.","old_comment_raw":"@return the PlaceType corresponding to the provided name, or null.","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":34},{"new_code_raw":"public HttpSession getSelectedSession() { final int selectedRow = this.sessionsTable.getSelectedRow(); if (selectedRow == -1) { \/\/ No row selected return null; } final int rowIndex = sessionsTable.convertRowIndexToModel(this.sessionsTable.getSelectedRow()); return this.sessionsModel.getHttpSessionAt(rowIndex); }","old_code_raw":"\tpublic HttpSession getSelectedSession() {\n\t\tfinal int rowIndex = sessionsTable.convertRowIndexToModel(this.sessionsTable.getSelectedRow());\n\t\treturn this.sessionsModel.getHttpSessionAt(rowIndex);\n\t}\n","new_comment_raw":"@return the selected session, or null if nothing is selected","old_comment_raw":"@return the selected session, or null if nothing is selected","label":0,"pre_label":1,"AST_level":7,"line_counts":10,"new_code_token_num":53},{"new_code_raw":"private ZapTextField getTxtPattern() { if (txtPattern == null) { txtPattern = new ZapTextField(); } return txtPattern; }","old_code_raw":"\tprivate JTextField getTxtPattern() {\n\t\tif (txtPattern == null) {\n\t\t\ttxtPattern = new JTextField();\n\t\t}\n\t\treturn txtPattern;\n\t}\n","new_comment_raw":"@return javax.swing.ZapTextField","old_comment_raw":"@return javax.swing.JTextField","label":1,"pre_label":0,"AST_level":8,"line_counts":7,"new_code_token_num":23},{"new_code_raw":"public static String quantityToRSDecimalStack(int quantity, boolean precise) { String quantityStr = String.valueOf(quantity); if (quantityStr.length() <= 4) { return quantityStr; } int power = (int) Math.log10(quantity); \/\/ Output thousandths for values above a million NumberFormat format = precise && power >= 6 ? PRECISE_DECIMAL_FORMATTER : DECIMAL_FORMATTER; return format.format(quantity \/ (Math.pow(10, (power \/ 3) * 3))) + SUFFIXES[power \/ 3]; }","old_code_raw":"\tpublic static String quantityToRSDecimalStack(int quantity)\n\t{\n\t\tString quantityStr = String.valueOf(quantity);\n\t\tif (quantityStr.length() <= 4)\n\t\t{\n\t\t\treturn quantityStr;\n\t\t}\n\n\t\tint power = (int) Math.log10(quantity);\n\t\treturn DECIMAL_FORMATTER.format(quantity \/ (Math.pow(10, (power \/ 3) * 3))) + SUFFIXES[power \/ 3];\n\t}\n","new_comment_raw":"@return The stack size as it would appear in RS, with decimals, with K after 100,000 and M after 10,000,000","old_comment_raw":"@return The stack size as it would appear in RS, with decimals, with K after 100,000 and M after 10,000,000","label":0,"pre_label":1,"AST_level":10,"line_counts":18,"new_code_token_num":96},{"new_code_raw":"public int pingAndWaitForReply(Message message, int numPings, long timeout) throws JMSException, InterruptedException { String messageCorrelationId = Long.toString(idGenerator.incrementAndGet()); message.setJMSCorrelationID(messageCorrelationId); for (int i = NUM; i < numPings; i++) { message.setLongProperty(STR, System.currentTimeMillis()); _producer.send(message); } commitTx(getProducerSession()); if (_verbose) { _logger.info(timestampFormatter.format(new Date()) + STR + messageCorrelationId); } CountDownLatch trafficLight = new CountDownLatch(numPings); trafficLights.put(messageCorrelationId, trafficLight); trafficLight.await(timeout, TimeUnit.MILLISECONDS); int numReplies = numPings - (int) trafficLight.getCount(); if ((numReplies < numPings) && _verbose) { _logger.info(STR + messageCorrelationId); } else if (_verbose) { _logger.info(STR + messageCorrelationId); } return numReplies; }","old_code_raw":"public Message pingAndWaitForReply(Message message, long timeout) throws JMSException, InterruptedException {\n    _producer.send(message);\n    String messageId = message.getJMSMessageID();\n    commitTx();\n    BooleanLatch trafficLight = new BooleanLatch();\n    trafficLights.put(messageId, trafficLight);\n    trafficLight.await(timeout * NUM);\n    Message result = replies.get(messageId);\n    return result;\n}","new_comment_raw":"@return The number of replies received. This may be less than the number sent if the timeout terminated the wait for all prematurely.","old_comment_raw":"@return The reply, or null if no reply arrives before the timeout.","label":1,"pre_label":0,"AST_level":11,"line_counts":22,"new_code_token_num":173},{"new_code_raw":"public DateTimeFormatterBuilder appendTimeZoneName() { return append0(new TimeZonePrinter(false), null); }","old_code_raw":"    public DateTimeFormatterBuilder appendTimeZoneName() {\n        return append0(new TimeZonePrinter( iLocale, false), null);\n    }\n","new_comment_raw":"@return this DateTimeFormatterBuilder","old_comment_raw":"@return this DateTimeFormatterBuilder","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":19},{"new_code_raw":"public RollCycle getRollCycle() { return queue.rollCycle(); }","old_code_raw":"public RollCycle getRollCycle() {\n    return rollCycle;\n}","new_comment_raw":"@return the queue file roll cycle","old_comment_raw":"@return the rollCycle","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":13},{"new_code_raw":"public static boolean isResolvableDevice(UrlDevice urlDevice) { String type = urlDevice.optExtraString(TYPE_KEY, STR); return type.equals(BLE_DEVICE_TYPE) || type.equals(SSDP_DEVICE_TYPE) || type.equals(MDNS_PUBLIC_DEVICE_TYPE); }","old_code_raw":"public static boolean isResolvableDevice(UrlDevice urlDevice) {\n    try {\n        urlDevice.getExtraString(TITLE_KEY);\n    } catch (JSONException e) {\n        return false;\n    }\n    return true;\n}","new_comment_raw":"@return If the device is resolvable or not.","old_comment_raw":"@return If the device is local or not.","label":1,"pre_label":0,"AST_level":7,"line_counts":4,"new_code_token_num":41},{"new_code_raw":"Class[] getServiceClasses(final Class type, final List issues) { final ServiceDescriptorSet set = (ServiceDescriptorSet) type.getAnnotation(ServiceDescriptorSet.class); if (null != set) { final ServiceDescriptor[] descriptors = set.value(); final Class[] services = new Class[descriptors.length]; for (int i = NUM; i < descriptors.length; i++) { ServiceDescriptor descriptor = descriptors[i]; services[i] = descriptor.type(); } return services; } else { return new Class[NUM]; } }","old_code_raw":"Class[] getServiceClasses(final Class type, final List issues) {\n    final List services = new ArrayList();\n    final ClassLoader classLoader = type.getClassLoader();\n    final Attribute[] attributes = Attributes.getAttributes(type, STR);\n    for (int i = NUM; i < attributes.length; i++) {\n        final String classname = attributes[i].getParameter(STR);\n        try {\n            final Class clazz = classLoader.loadClass(classname);\n            services.add(clazz);\n        } catch (final Throwable t) {\n            final Object[] args = new Object[] { classname, t };\n            final String message = getMessage(STR, args);\n            final VerifyIssue issue = new VerifyIssue(VerifyIssue.ERROR, message);\n            issues.add(issue);\n        }\n    }\n    return (Class[]) services.toArray(new Class[services.size()]);\n}","new_comment_raw":"@return an array of Classes for all the value","old_comment_raw":"@return an array of Classes for all the services","label":1,"pre_label":0,"AST_level":11,"line_counts":14,"new_code_token_num":103},{"new_code_raw":"@RequestMapping(value = STR, method = { RequestMethod.PUT }) @ResponseBody public CubeRequest updateCubeDesc(@RequestBody CubeRequest cubeRequest) throws JsonProcessingException { CubeDesc desc = deserializeCubeDesc(cubeRequest); CubeDesc oldCubeDesc = null; if (desc == null) { return cubeRequest; } if (!cubeService.isCubeDescEditable(desc)) { String error = STR + desc.getName(); updateRequest(cubeRequest, false, error); return cubeRequest; } if (!cubeRequest.getCubeName().equalsIgnoreCase(CubeService.getCubeNameFromDesc(desc.getName()))) { deleteCube(cubeRequest.getCubeName()); saveCubeDesc(cubeRequest); } String projectName = (null == cubeRequest.getProject()) ? ProjectInstance.DEFAULT_PROJECT_NAME : cubeRequest.getProject(); try { CubeInstance cube = cubeService.getCubeManager().getCube(cubeRequest.getCubeName()); oldCubeDesc = cube.getDescriptor(); desc = cubeService.updateCubeAndDesc(cube, desc, projectName); } catch (AccessDeniedException accessDeniedException) { throw new ForbiddenException(STR); } catch (Exception e) { logger.error(STR + e.getLocalizedMessage(), e); throw new InternalErrorException(STR + e.getLocalizedMessage()); } if (!desc.getError().isEmpty()) { logger.warn(STR + desc.getName() + STR + desc.getError()); updateRequest(cubeRequest, false, omitMessage(desc.getError())); return cubeRequest; } String descData = JsonUtil.writeValueAsIndentString(desc); cubeRequest.setCubeDescData(descData); cubeRequest.setSuccessful(true); return cubeRequest; }","old_code_raw":"@RequestMapping(value = STR, method = { RequestMethod.PUT })\n@ResponseBody\npublic CubeRequest updateCubeDesc(@RequestBody CubeRequest cubeRequest) throws JsonProcessingException {\n    CubeDesc desc = deserializeCubeDesc(cubeRequest);\n    if (desc == null) {\n        return cubeRequest;\n    }\n    final String cubeName = cubeRequest.getCubeName();\n    if (StringUtils.isEmpty(cubeName)) {\n        return errorRequest(cubeRequest, STR);\n    }\n    MetadataManager metadataManager = MetadataManager.getInstance(cubeService.getConfig());\n    DataModelDesc modelDesc = null;\n    DataModelDesc oldModelDesc = null;\n    if (StringUtils.isNotEmpty(cubeRequest.getModelDescData())) {\n        modelDesc = deserializeDataModelDesc(cubeRequest);\n        if (modelDesc == null) {\n            return cubeRequest;\n        }\n        final String modeName = modelDesc.getName();\n        if (!StringUtils.equals(desc.getModelName(), modeName)) {\n            return errorRequest(cubeRequest, STR + desc.getModelName() + STR + modeName);\n        }\n        oldModelDesc = metadataManager.getDataModelDesc(modeName);\n        if (oldModelDesc == null) {\n            return errorRequest(cubeRequest, STR + modeName + STR);\n        }\n    }\n    if (!cubeService.isCubeDescEditable(desc)) {\n        String error = STR + desc.getName().toUpperCase() + STR;\n        return errorRequest(cubeRequest, error);\n    }\n    boolean updateModelSuccess = false, updateCubeSuccess = false;\n    try {\n        if (modelDesc != null) {\n            metadataManager.updateDataModelDesc(modelDesc);\n            updateModelSuccess = true;\n        }\n        CubeInstance cube = cubeService.getCubeManager().getCube(cubeName);\n        String projectName = (null == cubeRequest.getProject()) ? ProjectInstance.DEFAULT_PROJECT_NAME : cubeRequest.getProject();\n        desc = cubeService.updateCubeAndDesc(cube, desc, projectName);\n        ProjectManager projectManager = cubeService.getProjectManager();\n        if (!cubeService.isCubeInProject(projectName, cube)) {\n            String owner = SecurityContextHolder.getContext().getAuthentication().getName();\n            ProjectInstance newProject = projectManager.moveRealizationToProject(RealizationType.CUBE, cube.getName(), projectName, owner);\n            accessService.inherit(cube, newProject);\n        }\n        if (desc.getError().isEmpty()) {\n            cubeRequest.setSuccessful(true);\n            updateCubeSuccess = true;\n        } else {\n            logger.warn(STR + desc.getName() + STR + desc.getError());\n            errorRequest(cubeRequest, omitMessage(desc.getError()));\n        }\n    } catch (AccessDeniedException accessDeniedException) {\n        throw new ForbiddenException(STR);\n    } catch (Exception e) {\n        logger.error(STR + e.getLocalizedMessage(), e);\n        throw new InternalErrorException(STR + e.getLocalizedMessage());\n    } finally {\n        if (updateModelSuccess == true && updateCubeSuccess == false) {\n            try {\n                oldModelDesc.setLastModified(modelDesc.getLastModified());\n                metadataManager.updateDataModelDesc(oldModelDesc);\n            } catch (IOException e) {\n                logger.error(STR + e.getLocalizedMessage(), e);\n                throw new InternalErrorException(STR + e.getLocalizedMessage());\n            }\n        }\n    }\n    String descData = JsonUtil.writeValueAsIndentString(desc);\n    cubeRequest.setCubeDescData(descData);\n    return cubeRequest;\n}","new_comment_raw":"@return Table metadata array","old_comment_raw":"@return cubeRequest cube change request","label":1,"pre_label":0,"AST_level":10,"line_counts":38,"new_code_token_num":284},{"new_code_raw":"public String getConsoleOutput() throws IOException { if (process == null || stream == null) { return null; } return stream instanceof CircularOutputStream ? stream.toString() : null; }","old_code_raw":"  public String getConsoleOutput() throws IOException {\n    if (process == null) {\n      return null;\n    }\n\n    return Streams.drainStream(stream);\n  }\n","new_comment_raw":"@return the console output of the executed binary.","old_comment_raw":"@return the console output of the executed binary.","label":0,"pre_label":1,"AST_level":6,"line_counts":8,"new_code_token_num":35},{"new_code_raw":"public ResponseEntity<Void> deleteUserWithHttpInfo(String username) throws RestClientException { Object postBody = null; \/\/ verify the required parameter 'username' is set if (username == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'username' when calling deleteUser\"); } \/\/ create path and map variables final Map<String, Object> uriVariables = new HashMap<String, Object>(); uriVariables.put(\"username\", username); String path = apiClient.expandPath(\"\/user\/{username}\", uriVariables); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<Void> returnType = new ParameterizedTypeReference<Void>() {}; return apiClient.invokeAPI(path, HttpMethod.DELETE, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType); }","old_code_raw":"    public ResponseEntity<Void> deleteUserWithHttpInfo(String username) throws RestClientException {\n        Object postBody = null;\n        \n        \/\/ verify the required parameter 'username' is set\n        if (username == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'username' when calling deleteUser\");\n        }\n        \n        \/\/ create path and map variables\n        final Map<String, Object> uriVariables = new HashMap<String, Object>();\n        uriVariables.put(\"username\", username);\n        String path = apiClient.expandPath(\"\/user\/{username}\", uriVariables);\n\n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<Void> returnType = new ParameterizedTypeReference<Void>() {};\n        return apiClient.invokeAPI(path, HttpMethod.DELETE, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n","new_comment_raw":"@return ResponseEntity&lt;Void&gt;","old_comment_raw":"@return ResponseEntity&lt;Void&gt;","label":0,"pre_label":1,"AST_level":8,"line_counts":29,"new_code_token_num":238},{"new_code_raw":"public Iterator getPorts() throws ServiceException { if (wsdlService == null || wsdlService.getPorts() == null) { return new Vector().iterator(); } return wsdlService.getPorts().keySet().iterator(); }","old_code_raw":"public Iterator getPorts() throws ServiceException {\n    if (wsdlService == null || wsdlService.getPorts() == null) {\n        return new Vector().iterator();\n    }\n    return wsdlService.getPorts().values().iterator();\n}","new_comment_raw":"@return Returns <code>java.util.Iterator<\/code> with elements of type <code>javax.xml.namespace.QName<\/code>","old_comment_raw":"@return Iterator The ports specified in the WSDL file","label":1,"pre_label":0,"AST_level":7,"line_counts":6,"new_code_token_num":44},{"new_code_raw":"private JsonNode catIndices(Collection<String> indices, String... fields) { final String fieldNames = String.join(STR, fields); final Cat request = new Cat.IndicesBuilder().addIndex(indices).setParameter(STR, fieldNames).build(); final CatResult response = JestUtils.execute(jestClient, request, () -> STR + indices); return response.getJsonObject().path(STR); }","old_code_raw":"private JsonArray catIndices(Collection<String> indices, String... fields) {\n    final String fieldNames = String.join(STR, fields);\n    final Cat request = new Cat.IndicesBuilder().addIndex(indices).setParameter(STR, fieldNames).build();\n    final CatResult response = JestUtils.execute(jestClient, request, () -> STR + indices);\n    return Optional.of(response.getJsonObject()).map(json -> GsonUtils.asJsonArray(json.get(STR))).orElse(new JsonArray());\n}","new_comment_raw":"@return A {@link JsonNode} with the result of the cat indices request.","old_comment_raw":"@return A {@link JsonArray} with the result of the cat indices request.","label":1,"pre_label":0,"AST_level":8,"line_counts":6,"new_code_token_num":74},{"new_code_raw":"public static String getPrincipalFromParts(final String primary, final String instance, final String realm) { checkNotNull(primary); checkNotNull(realm); return primary + ((instance != \"\") ? \"\/\" + instance : \"\") + \"@\" + realm; }","old_code_raw":"  public static String getPrincipalFromParts(final String primary, final String instance, final String realm) {\n    return checkNotNull(primary) + \"\/\" +\n        checkNotNull(instance) + \"@\" +\n        checkNotNull(realm);\n  }\n","new_comment_raw":"@return principal of format primary\/instance@REALM or primary@REALM","old_comment_raw":"@return principal of format primary\/instance@REALM","label":1,"pre_label":0,"AST_level":9,"line_counts":9,"new_code_token_num":56},{"new_code_raw":"public String getResourceManagerId() throws JMSException { waitForBrokerInfo(); if( brokerInfo==null ) throw new JMSException(\"Connection failed before Broker info was received.\"); return brokerInfo.getBrokerId().getValue(); }","old_code_raw":"    public String getResourceManagerId() throws JMSException {\n        waitForBrokerInfo();\n        if( brokerInfo==null )\n            throw new JMSException(\"Connection failed before Broker info was received.\");            \n        return brokerInfo.getBrokerId().getBrokerId();\n    }\n","new_comment_raw":"@return Returns the resourceManagerId.","old_comment_raw":"@return Returns the resourceManagerId.","label":0,"pre_label":1,"AST_level":6,"line_counts":7,"new_code_token_num":42},{"new_code_raw":"public long getRequestContentLength() { String contentLengthString = requestHeaders.getFirst(Headers.CONTENT_LENGTH); if (contentLengthString == null) { return -NUM; } return Long.parseLong(contentLengthString); }","old_code_raw":"public Long getRequestContentLength() {\n    String contentLengthString = requestHeaders.getFirst(Headers.CONTENT_LENGTH);\n    if (contentLengthString == null) {\n        return null;\n    }\n    return Long.parseLong(contentLengthString);\n}","new_comment_raw":"@return The content length of the request, or <code>-1<\/code> if it has not been set","old_comment_raw":"@return The content length of the request, or <code>null<\/code> if it has not been set","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":34},{"new_code_raw":"@Deprecated public int getTileSize() { return Math.max(tileHeight, tileWidth); }","old_code_raw":"public int getTileSize() {\n    return tileSize;\n}","new_comment_raw":"@return tile height or width, whichever is larger","old_comment_raw":"@return the size of tiles in pixels","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":18},{"new_code_raw":"public static RelNode copyRelHints(RelNode originalRel, RelNode newRel, boolean filterHints) { if (originalRel instanceof Hintable && newRel instanceof Hintable && ((Hintable) originalRel).getHints().size() > 0) { final List<RelHint> hints = ((Hintable) originalRel).getHints(); if (filterHints) { HintStrategyTable hintStrategies = originalRel.getCluster().getHintStrategies(); return ((Hintable) newRel).attachHints(hintStrategies.apply(hints, newRel)); } else { \/\/ Keep all the hints if filterHints is false for 2 reasons: \/\/ 1. Keep sync with the hints propagation logic, \/\/ see RelHintPropagateShuttle for details. \/\/ 2. We may re-propagate these hints when decorrelating a query. return ((Hintable) newRel).attachHints(hints); } } return newRel; }","old_code_raw":"  public static RelNode copyRelHints(RelNode originalRel, RelNode newRel) {\n    if (originalRel instanceof Hintable\n        && newRel instanceof Hintable\n        && ((Hintable) originalRel).getHints().size() > 0) {\n      HintStrategyTable hintStrategies = originalRel.getCluster().getHintStrategies();\n      final List<RelHint> hints = ((Hintable) originalRel).getHints();\n      \/\/ Keep all the hints of project node for 2 reasons:\n      \/\/ 1. Keep sync with the hints propagation logic,\n      \/\/ see RelHintPropagateShuttle for details.\n      \/\/ 2. We may re-propagate these hints when decorrelating a query.\n      if (originalRel instanceof Project\n          && newRel instanceof Project) {\n        return ((Hintable) newRel).attachHints(hints);\n      } else {\n        return ((Hintable) newRel)\n            .attachHints(hintStrategies.apply(hints, newRel));\n      }\n    }\n    return newRel;\n  }\n","new_comment_raw":"@return A copy of  newRel with attached hints from  originalRel, or  newRel directly if one of them are not  Hintable","old_comment_raw":"@return A copy of newRel with hints of originalRel, or newRel directly if one of them are not Hintable","label":1,"pre_label":0,"AST_level":10,"line_counts":19,"new_code_token_num":155},{"new_code_raw":"public static SchemaGenAction interpret(Object value) { if ( value == null ) { return NONE; } if ( SchemaGenAction.class.isInstance( value ) ) { return (SchemaGenAction) value; } final String name = value.toString(); if ( StringHelper.isEmpty( name ) || NONE.externalName.equals( name ) ) { \/\/ default is NONE return NONE; } if ( CREATE.externalName.equals( name ) ) { return CREATE; } else if ( DROP.externalName.equals( name ) ) { return DROP; } else if ( BOTH.externalName.equals( name ) ) { return BOTH; } throw new IllegalArgumentException( String.format( \"Unrecognized '%s' or '%s' value : %s\", AvailableSettings.SCHEMA_GEN_DATABASE_ACTION, AvailableSettings.SCHEMA_GEN_SCRIPTS_ACTION, value ) ); }","old_code_raw":"\tpublic static SchemaGenAction interpret(String value) {\n\t\tif ( StringHelper.isEmpty( value ) || NONE.externalName.equals( value ) ) {\n\t\t\t\/\/ default is NONE\n\t\t\treturn NONE;\n\t\t}\n\n\t\tif ( CREATE.externalName.equals( value ) ) {\n\t\t\treturn CREATE;\n\t\t}\n\t\telse if ( DROP.externalName.equals( value ) ) {\n\t\t\treturn DROP;\n\t\t}\n\t\telse if ( BOTH.externalName.equals( value ) ) {\n\t\t\treturn BOTH;\n\t\t}\n\n\t\tthrow new IllegalArgumentException(\n\t\t\t\tString.format(\n\t\t\t\t\t\t\"Unrecognized '%s' or '%s' value : %s\",\n\t\t\t\t\t\tAvailableSettings.SCHEMA_GEN_DATABASE_ACTION,\n\t\t\t\t\t\tAvailableSettings.SCHEMA_GEN_SCRIPTS_ACTION,\n\t\t\t\t\t\tvalue\n\t\t\t\t)\n\t\t);\n\t}\n","new_comment_raw":"@return The matching enum value. An empty value will return  #NONE.","old_comment_raw":"@return The matching enum value. An empty value will return #NONE.","label":0,"pre_label":1,"AST_level":8,"line_counts":35,"new_code_token_num":149},{"new_code_raw":"public SubProjectData getProjectInfo(AbstractProject context) { SubProjectData subProjectData = new SubProjectData(); iterateBuilds(context, projects, subProjectData); subProjectData.getTriggered().removeAll(subProjectData.getDynamic()); subProjectData.getTriggered().removeAll(subProjectData.getFixed()); return subProjectData; }","old_code_raw":"public List<Set<?>> getProjectInfo(AbstractProject context) {\n    Comparator customComparator = new Comparator<AbstractProject>() {\n\n        public int compare(AbstractProject abstractProject1, AbstractProject abstractProject2) {\n            return abstractProject1.getFullName().compareTo(abstractProject2.getFullName());\n        }\n    };\n    Set<AbstractProject> dynamicProject = new TreeSet<AbstractProject>(customComparator);\n    Set<AbstractProject> staticProject = new TreeSet<AbstractProject>(customComparator);\n    Set<AbstractProject> triggeredProject = new TreeSet<AbstractProject>(customComparator);\n    Set<String> unresolvedProject = new TreeSet<String>();\n    iterateBuilds(context, projects, dynamicProject, staticProject, triggeredProject, unresolvedProject);\n    triggeredProject.removeAll(dynamicProject);\n    triggeredProject.removeAll(staticProject);\n    return Arrays.asList(staticProject, dynamicProject, triggeredProject, unresolvedProject);\n}","new_comment_raw":"@return A data object containing sets with projects","old_comment_raw":"@return A list containing sets with Projects","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":52},{"new_code_raw":"private JsonNode catNodes(String... fields) { final String fieldNames = String.join(STR, fields); final Cat request = new Cat.NodesBuilder().setParameter(STR, fieldNames).setParameter(STR, true).build(); final CatResult response = JestUtils.execute(jestClient, request, () -> STR); return response.getJsonObject().path(STR); }","old_code_raw":"private JsonArray catNodes(String... fields) {\n    final String fieldNames = String.join(STR, fields);\n    final Cat request = new Cat.NodesBuilder().setParameter(STR, fieldNames).setParameter(STR, true).build();\n    final CatResult response = JestUtils.execute(jestClient, request, () -> STR);\n    return GsonUtils.asJsonArray(response.getJsonObject().get(STR));\n}","new_comment_raw":"@return A {@link JsonNode} with the result of the cat nodes request.","old_comment_raw":"@return A {@link JsonArray} with the result of the cat nodes request.","label":1,"pre_label":0,"AST_level":7,"line_counts":6,"new_code_token_num":70},{"new_code_raw":"protected Object convertGeometry(Column column, Field fieldDefn, Object data) { final MySqlGeometry empty = MySqlGeometry.createEmpty(); return convertValue(column, fieldDefn, data, io.debezium.data.geometry.Point.createValue(fieldDefn.schema(), empty.getWkb(), empty.getSrid()), (r) -> { if (data instanceof byte[]) { \/\/ The binlog utility sends a byte array for any Geometry type, we will use our own binaryParse to parse the byte to WKB, hence \/\/ to the suitable class if (data instanceof byte[]) { \/\/ The binlog utility sends a byte array for any Geometry type, we will use our own binaryParse to parse the byte to WKB, hence \/\/ to the suitable class MySqlGeometry mySqlGeometry = MySqlGeometry.fromBytes((byte[]) data); r.deliver(io.debezium.data.geometry.Geometry.createValue(fieldDefn.schema(), mySqlGeometry.getWkb(), mySqlGeometry.getSrid())); } } }); }","old_code_raw":"    protected Object convertGeometry(Column column, Field fieldDefn, Object data) {\n        return convertValue(column, fieldDefn, data, (Supplier<?>)() -> {\n            final MySqlGeometry empty = MySqlGeometry.createEmpty();\n            return io.debezium.data.geometry.Point.createValue(fieldDefn.schema(), empty.getWkb(), empty.getSrid());\n        }, (r) -> {\n            if (data instanceof byte[]) {\n                \/\/ The binlog utility sends a byte array for any Geometry type, we will use our own binaryParse to parse the byte to WKB, hence\n                \/\/ to the suitable class\n                if (data instanceof byte[]) {\n                    \/\/ The binlog utility sends a byte array for any Geometry type, we will use our own binaryParse to parse the byte to WKB, hence\n                    \/\/ to the suitable class\n                    MySqlGeometry mySqlGeometry = MySqlGeometry.fromBytes((byte[]) data);\n                    r.deliver(io.debezium.data.geometry.Geometry.createValue(fieldDefn.schema(), mySqlGeometry.getWkb(), mySqlGeometry.getSrid()));\n                }\n            }\n        });\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","label":0,"pre_label":1,"AST_level":14,"line_counts":16,"new_code_token_num":191},{"new_code_raw":"public Collection<IndexedWord> getSiblings(IndexedWord vertex) { IndexedWord parent = this.getParent(vertex); if (parent != null) { Set<IndexedWord> result = wordMapFactory.newSet(); result.addAll(this.getChildren(parent)); result.remove(vertex);\/\/remove this vertex - you're not your own sibling return result; } else { return Collections.emptySet(); } }","old_code_raw":"  public Collection<IndexedWord> getSiblings(IndexedWord vertex) {\n    IndexedWord parent = this.getParent(vertex);\n    if(parent != null) {\n      List<IndexedWord> result = this.getChildList(parent);\n      result.remove(vertex);\/\/remove this vertex - you're not your own sibling\n      return result;\n    }\n    else return new ArrayList<IndexedWord>();\n  }\n","new_comment_raw":"@return collection of sibling nodes (does not include vertex) the collection is empty if your parent is null","old_comment_raw":"@return collection of sibling nodes (does not include vertex) the collection is empty if your parent is null","label":0,"pre_label":1,"AST_level":9,"line_counts":12,"new_code_token_num":75},{"new_code_raw":"public static String deprocess(String str, STextProcessor processor) { if ((str == null) || (str.length() <= NUM)) return str; STextEnvironment env = new STextEnvironment(null, false, STextEnvironment.ORIENT_UNKNOWN); if (!env.isProcessingNeeded()) return str; return STextEngine.fullToLeanText(processor, env, str, null); }","old_code_raw":"public static String deprocess(String str, STextProcessor processor) {\n    if ((str == null) || (str.length() <= NUM) || !isProcessingNeeded())\n        return str;\n    STextEnvironment env = new STextEnvironment(null, false, STextEnvironment.ORIENT_UNKNOWN);\n    return STextEngine.fullToLeanText(processor, env, str, null);\n}","new_comment_raw":"@return string without directional formatting characters","old_comment_raw":"@return string with no directional formatting characters.","label":1,"pre_label":0,"AST_level":6,"line_counts":8,"new_code_token_num":69},{"new_code_raw":"public Date getFinalFireTime() { if (endTime == null) return null; Date finalTime = null; java.util.Calendar currCal = java.util.Calendar.getInstance(); currCal.setTime(this.endTime); while ((finalTime == null) && (this.startTime.before(currCal.getTime()))) { currCal.add(java.util.Calendar.DATE, -NUM); finalTime = getFireTimeAfter(currCal.getTime()); } return finalTime; }","old_code_raw":"public Date getFinalFireTime() {\n    Date finalTime = null;\n    java.util.Calendar currCal = java.util.Calendar.getInstance();\n    currCal.setTime(this.endTime);\n    while ((finalTime == null) && (this.startTime.before(currCal.getTime()))) {\n        currCal.add(java.util.Calendar.DATE, -NUM);\n        finalTime = getFireTimeAfter(currCal.getTime());\n    }\n    return finalTime;\n}","new_comment_raw":"@return the last time the trigger will fire, or null if there is no last time.","old_comment_raw":"@return the last time the trigger will fire.","label":1,"pre_label":0,"AST_level":8,"line_counts":12,"new_code_token_num":83},{"new_code_raw":"public Struct struct(String databaseName) { this.databaseName = databaseName; return struct((TableId) null); }","old_code_raw":"    public Struct struct() {\n        return struct(null);\n    }\n","new_comment_raw":"@return the source partition and offset  Struct; never null","old_comment_raw":"@return the source partition and offset Struct; never null","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":22},{"new_code_raw":"public BackupResultStatus backupSession(final Session session) { if (_log.isInfoEnabled()) { _log.debug(STR + session.getId()); } final MemcachedBackupSession backupSession = (MemcachedBackupSession) session; final BackupSessionTask task = getOrCreateBackupSessionTask(backupSession); final Map<String, Object> attributes = backupSession.getAttributesInternal(); final byte[] attributesData = _transcoderService.serializeAttributes(backupSession, attributes); final int hashCode = Arrays.hashCode(attributesData); if (backupSession.getDataHashCode() != hashCode || task.sessionCookieWasRelocated()) { final byte[] data = _transcoderService.serialize(backupSession, attributesData); final BackupResult result = task.backupSession(data, attributesData); if (result.getAttributesData() != null) { backupSession.setDataHashCode(Arrays.hashCode(result.getAttributesData())); } return result.getStatus(); } else { return BackupResultStatus.SKIPPED; } }","old_code_raw":"public BackupResult backupSession(final Session session) {\n    if (_log.isInfoEnabled()) {\n        _log.debug(STR + session.getId());\n    }\n    final BackupSessionTask task = getOrCreateBackupSessionTask((MemcachedBackupSession) session);\n    return task.backupSession();\n}","new_comment_raw":"@return the {@link SessionTrackerValve.SessionBackupService.BackupResultStatus}","old_comment_raw":"@return the {@link SessionTrackerValve.SessionBackupService.BackupResult}","label":1,"pre_label":0,"AST_level":10,"line_counts":20,"new_code_token_num":157},{"new_code_raw":"protected Object suspendAndGet(Object key, FlagAdapter opt, boolean suppressTimeout) throws CacheException { Transaction tx = suspend(); try { if (suppressTimeout) return cacheAdapter.getAllowingTimeout(key); else return cacheAdapter.get(key); } finally { resume(tx); } }","old_code_raw":"   protected Object suspendAndGet(Object key, Flag opt, boolean suppressTimeout) throws CacheException {\n       Transaction tx = suspend();\n       try {\n           if (suppressTimeout)\n               return CacheHelper.getAllowingTimeout(cache, key);\n           else\n               return CacheHelper.get(cache, key);\n       } finally {\n           resume(tx);\n       }\n   }\n","new_comment_raw":"@return The retrieved object","old_comment_raw":"@return The retrieved object","label":0,"pre_label":1,"AST_level":7,"line_counts":12,"new_code_token_num":53},{"new_code_raw":"public JSONObject getJSONObject(String key) { Object object = this.get(key); if (object == null) { return null; } if (object instanceof JSONObject) { return (JSONObject)object; } throw new RuntimeException(\"JSONObject[\" + quote(key) + \"] is not a JSONObject.\"); }","old_code_raw":"  public JSONObject getJSONObject(String key) {\n    Object object = this.get(key);\n    if (object instanceof JSONObject) {\n      return (JSONObject)object;\n    }\n    throw new RuntimeException(\"JSONObject[\" + quote(key) + \"] is not a JSONObject.\");\n  }\n","new_comment_raw":"@return A JSONObject which is the value or null if not available.","old_comment_raw":"@return A JSONObject which is the value.","label":1,"pre_label":0,"AST_level":8,"line_counts":11,"new_code_token_num":64},{"new_code_raw":"public static GtidNewChannelPosition parse(String value, String defaultValue) { GtidNewChannelPosition mode = parse(value); if (mode == null && defaultValue != null) { mode = parse(defaultValue); } return mode; }","old_code_raw":"        public static EventProcessingFailureHandlingMode parse(String value) {\n            if (value == null) {\n                return null;\n            }\n\n            value = value.trim();\n\n            for (EventProcessingFailureHandlingMode option : EventProcessingFailureHandlingMode.values()) {\n                if (option.getValue().equalsIgnoreCase(value)) {\n                    return option;\n                }\n            }\n\n            return null;\n        }\n","new_comment_raw":"@return the matching option, or null if no match is found and the non-null default is invalid","old_comment_raw":"@return the matching option, or null if no match is found","label":1,"pre_label":0,"AST_level":8,"line_counts":8,"new_code_token_num":41},{"new_code_raw":"public static Path relativize(Path baseDir, Path childPath) { Path fullPathWithoutSchemeAndAuthority = Path.getPathWithoutSchemeAndAuthority(childPath); Path basePathWithoutSchemeAndAuthority = Path.getPathWithoutSchemeAndAuthority(baseDir); \/\/ Since hadoop Path hasn't relativize() we use uri.relativize() to get relative path Path relativeFilePath = new Path(basePathWithoutSchemeAndAuthority.toUri() .relativize(fullPathWithoutSchemeAndAuthority.toUri())); if (relativeFilePath.isAbsolute()) { throw new IllegalStateException(String.format(\"Path %s is not a subpath of %s.\", basePathWithoutSchemeAndAuthority.toUri().getPath(), fullPathWithoutSchemeAndAuthority.toUri().getPath())); } return relativeFilePath; }","old_code_raw":"  public static String relativize(String baseDir, String childPath) {\n    Path fullPathWithoutSchemeAndAuthority = Path.getPathWithoutSchemeAndAuthority(new Path(childPath));\n    Path basePathWithoutSchemeAndAuthority = Path.getPathWithoutSchemeAndAuthority(new Path(baseDir));\n\n    \/\/ Since hadoop Path hasn't relativize() we use uri.relativize() to get relative path\n    Path relativeFilePath = new Path(basePathWithoutSchemeAndAuthority.toUri()\n        .relativize(fullPathWithoutSchemeAndAuthority.toUri()));\n    if (relativeFilePath.isAbsolute()) {\n      throw new IllegalStateException(String.format(\"Path %s is not a subpath of %s.\",\n          basePathWithoutSchemeAndAuthority.toUri().getPath(), fullPathWithoutSchemeAndAuthority.toUri().getPath()));\n    }\n    return relativeFilePath.toUri().getPath();\n  }\n","new_comment_raw":"@return relative path","old_comment_raw":"@return relative path","label":0,"pre_label":1,"AST_level":9,"line_counts":14,"new_code_token_num":118},{"new_code_raw":"public GremlinPipeline<S, Vertex> bothV() { return this.add(new BothVerticesPipe()); }","old_code_raw":"public T bothV() {\n    return this.add(new BothVerticesPipe());\n}","new_comment_raw":"@return the extended Pipeline","old_comment_raw":"@return the extended FluentPipeline","label":1,"pre_label":0,"AST_level":7,"line_counts":3,"new_code_token_num":20},{"new_code_raw":"public boolean isOrdered(String locator1, String locator2) { return (Boolean) seleneseMethods.get(\"isOrdered\").apply(driver, locator1, locator2); }","old_code_raw":"  public boolean isOrdered(String locator1, String locator2) {\n    WebElement one = elementFinder.findElement(driver, locator1);\n    WebElement two = elementFinder.findElement(driver, locator2);\n    \n    String ordered =\n      \"    if (arguments[0] === arguments[1]) return false;\\n\" + \n      \"\\n\" + \n      \"    var previousSibling;\\n\" + \n      \"    while ((previousSibling = arguments[1].previousSibling) != null) {\\n\" + \n      \"        if (previousSibling === arguments[0]) {\\n\" + \n      \"            return true;\\n\" + \n      \"        }\\n\" + \n      \"        arguments[1] = previousSibling;\\n\" + \n      \"    }\\n\" + \n      \"    return false;\\n\";\n    \n    Boolean result = (Boolean) javascriptLibrary.executeScript(driver, ordered, one, two);\n    return result != null && result.booleanValue();\n  }\n","new_comment_raw":"@return true if element1 is the previous sibling of element2, false otherwise","old_comment_raw":"@return true if element1 is the previous sibling of element2, false otherwise","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":32},{"new_code_raw":"private ZapTextField getTxtSessionName() { if (txtSessionName == null) { txtSessionName = new ZapTextField(); } return txtSessionName; }","old_code_raw":"\tprivate JTextField getTxtSessionName() {\n\t\tif (txtSessionName == null) {\n\t\t\ttxtSessionName = new JTextField();\n\t\t}\n\t\treturn txtSessionName;\n\t}\n","new_comment_raw":"@return javax.swing.ZapTextField","old_comment_raw":"@return javax.swing.JTextField","label":1,"pre_label":0,"AST_level":8,"line_counts":7,"new_code_token_num":23},{"new_code_raw":"public Applications getApplications(String serviceUrl) { if (shouldUseExperimentalTransport()) { try { EurekaHttpResponse<Applications> response = clientConfig.getRegistryRefreshSingleVipAddress() == null ? eurekaHttpClient.getApplications() : eurekaHttpClient.getVip(clientConfig.getRegistryRefreshSingleVipAddress()); if (response.getStatusCode() == 200) { logger.debug(PREFIX + appPathIdentifier + \" - refresh status: \" + response.getStatusCode()); return response.getEntity(); } logger.error(PREFIX + appPathIdentifier + \" - was unable to refresh its cache! status = \" + response.getStatusCode()); } catch (Throwable th) { logger.error(PREFIX + appPathIdentifier + \" - was unable to refresh its cache! status = \" + th.getMessage(), th); } } else { ClientResponse response = null; try { response = makeRemoteCall(Action.Refresh); Applications apps = response.getEntity(Applications.class); logger.debug(PREFIX + appPathIdentifier + \" - refresh status: \" + response.getStatus()); return apps; } catch (Throwable th) { logger.error(PREFIX + appPathIdentifier + \" - was unable to refresh its cache! status = \" + th.getMessage(), th); } finally { closeResponse(response); } } return null; }","old_code_raw":"    public Applications getApplications(String serviceUrl) {\n        ClientResponse response = null;\n        Applications apps = null;\n        try {\n            response = makeRemoteCall(Action.Refresh);\n            apps = response.getEntity(Applications.class);\n            logger.debug(PREFIX + appPathIdentifier + \" -  refresh status: \"\n                    + response.getStatus());\n            return apps;\n        } catch (Throwable th) {\n            logger.error(\n                    PREFIX + appPathIdentifier\n                            + \" - was unable to refresh its cache! status = \"\n                            + th.getMessage(), th);\n\n        } finally {\n            if (response != null) {\n                response.close();\n            }\n        }\n        return apps;\n    }\n","new_comment_raw":"@return - The registry information containing all applications.","old_comment_raw":"@return - The registry information containing all applications.","label":0,"pre_label":1,"AST_level":13,"line_counts":30,"new_code_token_num":232},{"new_code_raw":"public static DateTimeFormatter ordinalDate() { return Constants.od; }","old_code_raw":"    public static DateTimeFormatter ordinalDate() {\n        if (od == null) {\n            od = new DateTimeFormatterBuilder()\n                .append(yearElement())\n                .append(dayOfYearElement())\n                .toFormatter();\n        }\n        return od;\n    }\n","new_comment_raw":"@return a formatter for yyyy-DDD","old_comment_raw":"@return a formatter for yyyy-DDD","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":12},{"new_code_raw":"public Object next() throws java.io.IOException { int zzInput; int zzAction; \/\/ cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; \/\/ set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { \/\/ store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); \/\/ get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } \/\/ store back cached position zzMarkedPos = zzMarkedPosL; if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { String str = yytext(); int first = str.charAt(0); String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } LOGGER.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: LOGGER.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 35: break; case 2: { if (normalizeOtherBrackets) { return getNext(openparen, yytext()); } else { return getNext(); } } case 36: break; case 3: { if (escapeForwardSlashAsterisk) { return getNext(LexerUtils.escapeChar(yytext(), '\/'), yytext()); } else { return getNext(); } } case 37: break; case 4: { return getNext(); } case 38: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 39: break; case 6: { if (normalizeOtherBrackets) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 40: break; case 7: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 41: break; case 8: { if (invertible) { prevWordAfter.append(yytext()); } } case 42: break; case 9: { return handleEllipsis(yytext()); } case 43: break; case 10: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { String origTxt = yytext(); return getNext(asciiDash(origTxt), origTxt); } } case 44: break; case 11: { return normalizeFractions(yytext()); } case 45: break; case 12: { final String origTxt = yytext(); return getNext(asciiQuotes(origTxt), origTxt); } case 46: break; case 13: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 47: break; case 14: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 48: break; case 15: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 49: break; case 16: { if (escapeForwardSlashAsterisk) { return getNext(LexerUtils.escapeChar(yytext(), '*'), yytext()); } else { return getNext(); } } case 50: break; case 17: { String txt = yytext(); if (DEBUG) { LOGGER.info(\"Used {EMOJI} to recognize \" + txt); } return getNext(txt, txt); } case 51: break; case 18: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 52: break; case 19: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(); } case 53: break; case 20: { final String origTxt = yytext(); return getNext(origTxt, origTxt, CONTR_ANNOTATION); } case 54: break; case 21: { if (!noSGML) { return getNext(); } } case 55: break; case 22: { \/\/ this one should only match if we're basically at the end of file \/\/ since the last one matches two things, even newlines String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 56: break; case 23: { final String origTxt = yytext(); return getNext(asciiDash(origTxt), origTxt, COMPOUND_ANNOTATION); } case 57: break; case 24: { final String origTxt = yytext(); return getNext(asciiDash(origTxt), origTxt); } case 58: break; case 25: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String txt = asciiQuotes(origTxt); return getNext(asciiDash(txt), origTxt); } case 59: break; case 26: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 1; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 2; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 60: break; case 27: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 61: break; case 28: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = LexerUtils.escapeChar(txt, '\/'); txt = LexerUtils.escapeChar(txt, '*'); } return getNext(txt, yytext()); } case 62: break; case 29: { return getNormalizedAmpNext(); } case 63: break; case 30: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { return getNext(); } case 64: break; case 31: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 65: break; case 32: { yypushback(3) ; return getNext(); } case 66: break; case 33: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = LexerUtils.escapeChar(txt, '\/'); } return getNext(txt, yytext()); } case 67: break; case 34: { String txt = yytext(); if (normalizeParentheses) { txt = txt.replaceAll(\"\\\\(\", openparen); txt = txt.replaceAll(\"\\\\)\", closeparen); } return getNext(txt, yytext()); } case 68: break; default: zzScanError(ZZ_NO_MATCH); } } } }","old_code_raw":"  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    \/\/ cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      \/\/ set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            \/\/ store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            \/\/ get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      \/\/ store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n        zzAtEOF = true;\n              {\n                if (invertible) {\n            prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            prevWordAfter.setLength(0);\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n          }\n          return null;\n              }\n      }\n      else {\n        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n          case 1: \n            { String str = yytext();\n          int first = str.charAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n            }\n          case 34: break;\n          case 2: \n            { if (normalizeOtherBrackets) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 35: break;\n          case 3: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '\/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 36: break;\n          case 4: \n            { return getNext();\n            }\n          case 37: break;\n          case 5: \n            { if (tokenizeNLs) {\n                      return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns\n                  } else if (invertible) {\n                      prevWordAfter.append(yytext());\n                  }\n            }\n          case 38: break;\n          case 6: \n            { if (normalizeOtherBrackets) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 39: break;\n          case 7: \n            { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n            }\n          case 40: break;\n          case 8: \n            { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n            }\n          case 41: break;\n          case 9: \n            { return handleEllipsis(yytext());\n            }\n          case 42: break;\n          case 10: \n            { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n\t            return getNext(ptbmdash, yytext());\n                  } else {\n\t\t    String origTxt = yytext();\n                    return getNext(asciiDash(origTxt), origTxt);\n\t\t  }\n            }\n          case 43: break;\n          case 11: \n            { return normalizeFractions(yytext());\n            }\n          case 44: break;\n          case 12: \n            { final String origTxt = yytext();\n                          return getNext(asciiQuotes(origTxt), origTxt);\n            }\n          case 45: break;\n          case 13: \n            { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 46: break;\n          case 14: \n            { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 47: break;\n          case 15: \n            { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 48: break;\n          case 16: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 49: break;\n          case 17: \n            { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 50: break;\n          case 18: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext();\n            }\n          case 51: break;\n          case 19: \n            { final String origTxt = yytext();\n                          return getNext(origTxt, origTxt, CONTR_ANNOTATION);\n            }\n          case 52: break;\n          case 20: \n            { if (!noSGML) {\n                            return getNext();\n\t\t\t  }\n            }\n          case 53: break;\n          case 21: \n            { \/\/ this one should only match if we're basically at the end of file\n\t\t\t  \/\/ since the last one matches two things, even newlines\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n\t                  return getNext(s, yytext());\n            }\n          case 54: break;\n          case 22: \n            { final String origTxt = yytext();\n                          return getNext(asciiDash(origTxt), origTxt, COMPOUND_ANNOTATION);\n            }\n          case 55: break;\n          case 23: \n            { final String origTxt = yytext();\n                          return getNext(asciiDash(origTxt), origTxt);\n            }\n          case 56: break;\n          case 24: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 3;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 4;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String origTxt = yytext();\n                          String txt = asciiQuotes(origTxt);\n                          return getNext(asciiDash(txt), origTxt);\n            }\n          case 57: break;\n          case 25: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 1;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 2;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 58: break;\n          case 26: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 8;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 59: break;\n          case 27: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 60: break;\n          case 28: \n            { return getNormalizedAmpNext();\n            }\n          case 61: break;\n          case 29: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { return getNext();\n            }\n          case 62: break;\n          case 30: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 5;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 6;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n\t                  return getNext(s, yytext());\n            }\n          case 63: break;\n          case 31: \n            { yypushback(3) ; return getNext();\n            }\n          case 64: break;\n          case 32: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 65: break;\n          case 33: \n            { String txt = yytext();\n\t\t\t  if (normalizeParentheses) {\n\t\t\t    txt = txt.replaceAll(\"\\\\(\", openparen);\n\t\t\t    txt = txt.replaceAll(\"\\\\)\", closeparen);\n\t\t\t  }\n\t\t\t  return getNext(txt, yytext());\n            }\n          case 66: break;\n          default:\n            zzScanError(ZZ_NO_MATCH);\n        }\n      }\n    }\n  }\n","new_comment_raw":"@return the next token","old_comment_raw":"@return the next token","label":0,"pre_label":1,"AST_level":19,"line_counts":469,"new_code_token_num":2667},{"new_code_raw":"protected DimensionValueLoadTask buildDruidDimensionsLoader(DruidWebService webService, PhysicalTableDictionary physicalTableDictionary, DimensionDictionary dimensionDictionary) { DruidDimensionValueLoader druidDimensionRowProvider = new DruidDimensionValueLoader(physicalTableDictionary, dimensionDictionary, webService); return new DimensionValueLoadTask(Collections.singletonList(druidDimensionRowProvider)); }","old_code_raw":"protected DruidDimensionsLoader buildDruidDimensionsLoader(DruidWebService webService, PhysicalTableDictionary physicalTableDictionary, DimensionDictionary dimensionDictionary) {\n    return new DruidDimensionsLoader(physicalTableDictionary, dimensionDictionary, webService);\n}","new_comment_raw":"@return A DimensionValueLoadTask","old_comment_raw":"@return A DruidDimensionsLoader","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":38},{"new_code_raw":"public static List<Pattern> listOfRegex(String input, int regexFlags) { return listOf(input, RegExSplitter::split, (str) -> Pattern.compile(str, regexFlags)); }","old_code_raw":"    public static Set<Pattern> listOfRegex(String input, int regexFlags) {\n        return listOf(input, RegExSplitter::split, (str) -> Pattern.compile(str, regexFlags));\n    }\n","new_comment_raw":"@return the list of regular expression  Patterns included in the list; never null","old_comment_raw":"@return the list of regular expression Patterns included in the list; never null","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":37},{"new_code_raw":"protected Object convertRowId(Column column, Field fieldDefn, Object data) { return convertValue(column, fieldDefn, data, BYTE_BUFFER_ZERO, (r) -> { if (data instanceof java.sql.RowId) { java.sql.RowId row = (java.sql.RowId) data; r.deliver(ByteBuffer.wrap(row.getBytes())); } }); }","old_code_raw":"    protected Object convertRowId(Column column, Field fieldDefn, Object data) {\n        if (data == null && !fieldDefn.schema().isOptional()) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return ByteBuffer.wrap(new byte[0]);\n        }\n        if (data instanceof java.sql.RowId) {\n            java.sql.RowId row = (java.sql.RowId) data;\n            return ByteBuffer.wrap(row.getBytes());\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","label":0,"pre_label":1,"AST_level":13,"line_counts":9,"new_code_token_num":68},{"new_code_raw":"public PrototypeFactoryDeprecated getQuestionElementsFactory() { if (questionFactory == null) { questionFactory = new PrototypeFactoryDeprecated(); addAnswerDataPrototype(new DateData()); addAnswerDataPrototype(new IntegerData()); addAnswerDataPrototype(new SelectMultiData()); addAnswerDataPrototype(new SelectOneData()); addAnswerDataPrototype(new StringData()); addAnswerDataPrototype(new TimeData()); } return questionFactory; }","old_code_raw":"public PrototypeFactory getQuestionElementsFactory() {\n    if (questionFactory == null) {\n        questionFactory = new PrototypeFactory();\n        addAnswerDataPrototype(new DateData());\n        addAnswerDataPrototype(new IntegerData());\n        addAnswerDataPrototype(new SelectMultiData());\n        addAnswerDataPrototype(new SelectOneData());\n        addAnswerDataPrototype(new StringData());\n        addAnswerDataPrototype(new TimeData());\n    }\n    return questionFactory;\n}","new_comment_raw":"@return a PrototypeFactoryDeprecated containing prototypes for IAnswerData's, IDataReferences, and QuestionDataGroups. If a factory doesn't yet exist, one is created, and default IAnswerData implementing classes are pre-populated.","old_comment_raw":"@return a PrototypeFactory containing prototypes for IAnswerData's, IDataReferences, and QuestionDataGroups. If a factory doesn't yet exist, one is created, and default IAnswerData implementing classes are pre-populated.","label":1,"pre_label":0,"AST_level":8,"line_counts":12,"new_code_token_num":71},{"new_code_raw":"protected String computeDigest() { RelDigestWriter rdw = new RelDigestWriter(); explain(rdw); return rdw.digest; }","old_code_raw":"  protected String computeDigest() {\n    StringWriter sw = new StringWriter();\n    RelWriter pw =\n        new RelWriterImpl(\n            new PrintWriter(sw),\n            SqlExplainLevel.DIGEST_ATTRIBUTES, false) {\n          protected void explain_(\n              RelNode rel, List<Pair<String, Object>> values) {\n            pw.write(getRelTypeName());\n\n            for (RelTrait trait : traitSet) {\n              pw.write(\".\");\n              pw.write(trait.toString());\n            }\n\n            pw.write(\"(\");\n            int j = 0;\n            for (Pair<String, Object> value : values) {\n              if (j++ > 0) {\n                pw.write(\",\");\n              }\n              pw.write(value.left);\n              pw.write(\"=\");\n              if (value.right instanceof RelNode) {\n                RelNode input = (RelNode) value.right;\n                pw.write(input.getRelTypeName());\n                pw.write(\"#\");\n                pw.write(Integer.toString(input.getId()));\n              } else {\n                pw.write(String.valueOf(value.right));\n              }\n            }\n            pw.write(\")\");\n          }\n        };\n    explain(pw);\n    return sw.toString();\n  }\n","new_comment_raw":"@return Digest","old_comment_raw":"@return Digest","label":0,"pre_label":1,"AST_level":6,"line_counts":6,"new_code_token_num":23},{"new_code_raw":"private ZapTextField getTxtReverseProxyIp() { if (txtReverseProxyIp == null) { txtReverseProxyIp = new ZapTextField(); } return txtReverseProxyIp; }","old_code_raw":"\tprivate JTextField getTxtReverseProxyIp() {\n\t\tif (txtReverseProxyIp == null) {\n\t\t\ttxtReverseProxyIp = new JTextField();\n\t\t}\n\t\treturn txtReverseProxyIp;\n\t}\n","new_comment_raw":"@return javax.swing.ZapTextField","old_comment_raw":"@return javax.swing.JTextField","label":1,"pre_label":0,"AST_level":8,"line_counts":7,"new_code_token_num":23},{"new_code_raw":"public int getMaxConnections() { return getConnectionsPool().getMaxIdlePerKey(); }","old_code_raw":"    public int getMaxConnections() {\n        return getConnectionsPool().getMaxIdle();\n    }\n","new_comment_raw":"@return the maxConnections that will be created for this pool.","old_comment_raw":"@return the maxConnections that will be created for this pool.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":15},{"new_code_raw":"protected CompletableFuture<ExecutionResult> completeValue(ExecutionContext executionContext, ExecutionStrategyParameters parameters) throws NonNullableFieldWasNullException { ExecutionTypeInfo typeInfo = parameters.typeInfo(); Object result = unboxPossibleOptional(parameters.source()); GraphQLType fieldType = typeInfo.getType(); if (result == null) { return completeValueForNull(parameters); } else if (fieldType instanceof GraphQLList) { return completeValueForList(executionContext, parameters, result); } else if (fieldType instanceof GraphQLScalarType) { return completeValueForScalar(executionContext, parameters, (GraphQLScalarType) fieldType, result); } else if (fieldType instanceof GraphQLEnumType) { return completeValueForEnum(executionContext, parameters, (GraphQLEnumType) fieldType, result); } \/\/ \/\/ when we are here, we have a complex type: Interface, Union or Object \/\/ and we must go deeper \/\/ GraphQLObjectType resolvedObjectType = resolveType(executionContext, parameters, fieldType); return completeValueForObject(executionContext, parameters, resolvedObjectType, result); }","old_code_raw":"    protected CompletableFuture<ExecutionResult> completeValue(ExecutionContext executionContext, ExecutionStrategyParameters parameters) throws NonNullableFieldWasNullException {\n        ExecutionTypeInfo typeInfo = parameters.typeInfo();\n        Object result = unboxPossibleOptional(parameters.source());\n        GraphQLType fieldType = typeInfo.getType();\n\n        if (result == null) {\n            return completedFuture(new ExecutionResultImpl(parameters.nonNullFieldValidator().validate(parameters.path(), null), null));\n        } else if (fieldType instanceof GraphQLList) {\n            return completeValueForList(executionContext, parameters, result);\n        } else if (fieldType instanceof GraphQLScalarType) {\n            return completeValueForScalar(executionContext, parameters, (GraphQLScalarType) fieldType, result);\n        } else if (fieldType instanceof GraphQLEnumType) {\n            return completeValueForEnum(executionContext, parameters, (GraphQLEnumType) fieldType, result);\n        }\n\n\n        \/\/ when we are here, we have a complex type: Interface, Union or Object\n        \/\/ and we must go deeper\n\n        GraphQLObjectType resolvedType = resolveType(executionContext, parameters, fieldType);\n\n        FieldCollectorParameters collectorParameters = newParameters()\n                .schema(executionContext.getGraphQLSchema())\n                .objectType(resolvedType)\n                .fragments(executionContext.getFragmentsByName())\n                .variables(executionContext.getVariables())\n                .build();\n\n        Map<String, List<Field>> subFields = fieldCollector.collectFields(collectorParameters, parameters.field());\n\n        ExecutionTypeInfo newTypeInfo = typeInfo.treatAs(resolvedType);\n        NonNullableFieldValidator nonNullableFieldValidator = new NonNullableFieldValidator(executionContext, newTypeInfo);\n\n        ExecutionStrategyParameters newParameters = ExecutionStrategyParameters.newParameters()\n                .typeInfo(newTypeInfo)\n                .fields(subFields)\n                .nonNullFieldValidator(nonNullableFieldValidator)\n                .path(parameters.path())\n                .source(result).build();\n\n        \/\/ Calling this from the executionContext to ensure we shift back from mutation strategy to the query strategy.\n\n        return executionContext.getQueryStrategy().execute(executionContext, newParameters);\n    }\n","new_comment_raw":"@return an  ExecutionResult","old_comment_raw":"@return an ExecutionResult","label":0,"pre_label":1,"AST_level":11,"line_counts":23,"new_code_token_num":171},{"new_code_raw":"protected DrillRel convertToRawDrel(final RelNode relNode) throws SqlUnsupportedException { if (context.getOptions().getOption(ExecConstants.EARLY_LIMIT0_OPT) && context.getPlannerSettings().isTypeInferenceEnabled() && FindLimit0Visitor.containsLimit0(relNode)) { \/\/ if the schema is known, return the schema directly final DrillRel shorterPlan; if ((shorterPlan = FindLimit0Visitor.getDirectScanRelIfFullySchemaed(relNode)) != null) { return shorterPlan; } if (FindHardDistributionScans.canForceSingleMode(relNode)) { \/\/ disable distributed mode context.getPlannerSettings().forceSingleMode(); } } try { \/\/ HEP for rules, which are failed at the LOGICAL_PLANNING stage for Volcano planner final RelNode setOpTransposeNode = transform(PlannerType.HEP, PlannerPhase.PRE_LOGICAL_PLANNING, relNode); \/\/ HEP Directory pruning. final RelNode pruned = transform(PlannerType.HEP_BOTTOM_UP, PlannerPhase.DIRECTORY_PRUNING, setOpTransposeNode); final RelTraitSet logicalTraits = pruned.getTraitSet().plus(DrillRel.DRILL_LOGICAL); final RelNode convertedRelNode; if (!context.getPlannerSettings().isHepOptEnabled()) { \/\/ hep is disabled, use volcano convertedRelNode = transform(PlannerType.VOLCANO, PlannerPhase.LOGICAL_PRUNE_AND_JOIN, pruned, logicalTraits); } else { final RelNode intermediateNode2; final RelNode intermediateNode3; if (context.getPlannerSettings().isHepPartitionPruningEnabled()) { final RelNode intermediateNode = transform(PlannerType.VOLCANO, PlannerPhase.LOGICAL, pruned, logicalTraits); \/\/ HEP Join Push Transitive Predicates final RelNode transitiveClosureNode = transform(PlannerType.HEP, PlannerPhase.TRANSITIVE_CLOSURE, intermediateNode); \/\/ hep is enabled and hep pruning is enabled. intermediateNode2 = transform(PlannerType.HEP_BOTTOM_UP, PlannerPhase.PARTITION_PRUNING, transitiveClosureNode); } else { \/\/ Only hep is enabled final RelNode intermediateNode = transform(PlannerType.VOLCANO, PlannerPhase.LOGICAL_PRUNE, pruned, logicalTraits); \/\/ HEP Join Push Transitive Predicates intermediateNode2 = transform(PlannerType.HEP, PlannerPhase.TRANSITIVE_CLOSURE, intermediateNode); } \/\/ Do Join Planning. intermediateNode3 = transform(PlannerType.HEP_BOTTOM_UP, PlannerPhase.JOIN_PLANNING, intermediateNode2); if (context.getPlannerSettings().isRowKeyJoinConversionEnabled()) { \/\/ Covert Join to RowKeyJoin, where applicable. convertedRelNode = transform(PlannerType.HEP_BOTTOM_UP, PlannerPhase.ROWKEYJOIN_CONVERSION, intermediateNode3); } else { convertedRelNode = intermediateNode3; } } \/\/ Convert SUM to $SUM0 final RelNode convertedRelNodeWithSum0 = transform(PlannerType.HEP_BOTTOM_UP, PlannerPhase.SUM_CONVERSION, convertedRelNode); DrillRel drillRel = (DrillRel) convertedRelNodeWithSum0; \/\/ If the query contains a limit 0 clause, disable distributed mode since it is overkill for determining schema. if (FindLimit0Visitor.containsLimit0(convertedRelNodeWithSum0) && FindHardDistributionScans.canForceSingleMode(convertedRelNodeWithSum0)) { context.getPlannerSettings().forceSingleMode(); if (context.getOptions().getOption(ExecConstants.LATE_LIMIT0_OPT)) { drillRel = FindLimit0Visitor.addLimitOnTopOfLeafNodes(drillRel); } } return drillRel; } catch (RelOptPlanner.CannotPlanException ex) { logger.error(ex.getMessage()); if (JoinUtils.checkCartesianJoin(relNode)) { throw JoinUtils.cartesianJoinPlanningException(); } else { throw ex; } } }","old_code_raw":"  protected DrillRel convertToRawDrel(final RelNode relNode) throws SqlUnsupportedException {\n    if (context.getOptions().getOption(ExecConstants.EARLY_LIMIT0_OPT) &&\n        context.getPlannerSettings().isTypeInferenceEnabled() &&\n        FindLimit0Visitor.containsLimit0(relNode)) {\n      \/\/ if the schema is known, return the schema directly\n      final DrillRel shorterPlan;\n      if ((shorterPlan = FindLimit0Visitor.getDirectScanRelIfFullySchemaed(relNode)) != null) {\n        return shorterPlan;\n      }\n\n      if (FindHardDistributionScans.canForceSingleMode(relNode)) {\n        \/\/ disable distributed mode\n        context.getPlannerSettings().forceSingleMode();\n      }\n    }\n\n    try {\n      \/\/ HEP for rules, which are failed at the LOGICAL_PLANNING stage for Volcano planner\n      final RelNode setOpTransposeNode = transform(PlannerType.HEP, PlannerPhase.PRE_LOGICAL_PLANNING, relNode);\n\n      \/\/ HEP Directory pruning.\n      final RelNode pruned = transform(PlannerType.HEP_BOTTOM_UP, PlannerPhase.DIRECTORY_PRUNING, setOpTransposeNode);\n      final RelTraitSet logicalTraits = pruned.getTraitSet().plus(DrillRel.DRILL_LOGICAL);\n\n      final RelNode convertedRelNode;\n      if (!context.getPlannerSettings().isHepOptEnabled()) {\n        \/\/ hep is disabled, use volcano\n        convertedRelNode = transform(PlannerType.VOLCANO, PlannerPhase.LOGICAL_PRUNE_AND_JOIN, pruned, logicalTraits);\n\n      } else {\n        final RelNode intermediateNode2;\n        final RelNode intermediateNode3;\n        if (context.getPlannerSettings().isHepPartitionPruningEnabled()) {\n\n          final RelNode intermediateNode = transform(PlannerType.VOLCANO, PlannerPhase.LOGICAL, pruned, logicalTraits);\n\n          \/\/ HEP Join Push Transitive Predicates\n          final RelNode transitiveClosureNode =\n              transform(PlannerType.HEP, PlannerPhase.TRANSITIVE_CLOSURE, intermediateNode);\n\n          \/\/ hep is enabled and hep pruning is enabled.\n          intermediateNode2 = transform(PlannerType.HEP_BOTTOM_UP, PlannerPhase.PARTITION_PRUNING, transitiveClosureNode);\n\n        } else {\n          \/\/ Only hep is enabled\n          final RelNode intermediateNode =\n              transform(PlannerType.VOLCANO, PlannerPhase.LOGICAL_PRUNE, pruned, logicalTraits);\n\n          \/\/ HEP Join Push Transitive Predicates\n          intermediateNode2 = transform(PlannerType.HEP, PlannerPhase.TRANSITIVE_CLOSURE, intermediateNode);\n        }\n\n        \/\/ Do Join Planning.\n        intermediateNode3 = transform(PlannerType.HEP_BOTTOM_UP, PlannerPhase.JOIN_PLANNING, intermediateNode2);\n\n        if (context.getPlannerSettings().isRowKeyJoinConversionEnabled()) {\n          \/\/ Covert Join to RowKeyJoin, where applicable.\n          convertedRelNode = transform(PlannerType.HEP_BOTTOM_UP, PlannerPhase.ROWKEYJOIN_CONVERSION, intermediateNode3);\n        } else {\n          convertedRelNode = intermediateNode3;\n        }\n      }\n\n      \/\/ Convert SUM to $SUM0\n      final RelNode convertedRelNodeWithSum0 = transform(PlannerType.HEP_BOTTOM_UP, PlannerPhase.SUM_CONVERSION, convertedRelNode);\n\n      final DrillRel drillRel = (DrillRel) convertedRelNodeWithSum0;\n\n      if (drillRel instanceof DrillStoreRel) {\n        throw new UnsupportedOperationException();\n      } else {\n\n        \/\/ If the query contains a limit 0 clause, disable distributed mode since it is overkill for determining schema.\n        if (FindLimit0Visitor.containsLimit0(convertedRelNodeWithSum0) &&\n            FindHardDistributionScans.canForceSingleMode(convertedRelNodeWithSum0)) {\n          context.getPlannerSettings().forceSingleMode();\n          if (context.getOptions().getOption(ExecConstants.LATE_LIMIT0_OPT)) {\n            return FindLimit0Visitor.addLimitOnTopOfLeafNodes(drillRel);\n          }\n        }\n\n        return drillRel;\n      }\n    } catch (RelOptPlanner.CannotPlanException ex) {\n      logger.error(ex.getMessage());\n\n      if (JoinUtils.checkCartesianJoin(relNode)) {\n        throw JoinUtils.cartesianJoinPlanningException();\n      } else {\n        throw ex;\n      }\n    }\n  }\n","new_comment_raw":"@return Drill Logical RelNode tree","old_comment_raw":"@return Drill Logical RelNode tree","label":0,"pre_label":1,"AST_level":11,"line_counts":88,"new_code_token_num":522},{"new_code_raw":"public static boolean isGZipFile(String file) { String ext = getExtension(file); return STR.equals(ext) || STR.equals(ext); }","old_code_raw":"public static boolean isGZipFile(String file) {\n    return STR.equals(getExtension(file));\n}","new_comment_raw":"@return true if the extension is \".gz\" or \".Z\", false otherwise","old_comment_raw":"@return true if the extension is \".gz\", false otherwise","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":31},{"new_code_raw":"public SequenceService createSequenceService() { return createSequenceService(defaultEndpointUrl); }","old_code_raw":"public SequenceService createSequenceService() {\n    return createSequenceService(defaultServerUrl);\n}","new_comment_raw":"@return a new sequence service with the default endpoint URL","old_comment_raw":"@return a new sequence service with the default server URL","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":13},{"new_code_raw":"public String toExampleValue(Schema schema) { if (schema.getExample() != null) { return schema.getExample().toString(); } if (ModelUtils.isBooleanSchema(schema)) { return \"null\"; } else if (ModelUtils.isDateSchema(schema)) { return \"null\"; } else if (ModelUtils.isDateTimeSchema(schema)) { return \"null\"; } else if (ModelUtils.isNumberSchema(schema)) { return \"null\"; } else if (ModelUtils.isIntegerSchema(schema)) { return \"null\"; } else if (ModelUtils.isStringSchema(schema)) { return \"null\"; } else if (ModelUtils.isObjectSchema(schema)) { return \"null\"; } else { return \"null\"; } }","old_code_raw":"    public String toExampleValue(Property p) {\n        if(p.getExample() != null) {\n            return p.getExample().toString();\n        }\n        if (p instanceof StringProperty) {\n            return \"null\";\n        } else if (p instanceof BooleanProperty) {\n            return \"null\";\n        } else if (p instanceof DateProperty) {\n            return \"null\";\n        } else if (p instanceof DateTimeProperty) {\n            return \"null\";\n        } else if (p instanceof DoubleProperty) {\n            DoubleProperty dp = (DoubleProperty) p;\n            if (dp.getExample() != null) {\n                return dp.getExample().toString();\n            }\n            return \"null\";\n        } else if (p instanceof FloatProperty) {\n            FloatProperty dp = (FloatProperty) p;\n            if (dp.getExample() != null) {\n                return dp.getExample().toString();\n            }\n            return \"null\";\n        } else if (p instanceof IntegerProperty) {\n            IntegerProperty dp = (IntegerProperty) p;\n            if (dp.getExample() != null) {\n                return dp.getExample().toString();\n            }\n            return \"null\";\n        } else if (p instanceof LongProperty) {\n            LongProperty dp = (LongProperty) p;\n            if (dp.getExample() != null) {\n                return dp.getExample().toString();\n            }\n            return \"null\";\n        } else {\n            return \"null\";\n        }\n    }\n","new_comment_raw":"@return string presentation of the example value of the property","old_comment_raw":"@return string presentation of the example value of the property","label":0,"pre_label":1,"AST_level":12,"line_counts":24,"new_code_token_num":148},{"new_code_raw":"public InstrumentationFieldFetchParameters withNewState(InstrumentationState instrumentationState) { return new InstrumentationFieldFetchParameters( this.getExecutionContext(), this.getField(), this.getEnvironment(), instrumentationState, executionStrategyParameters, trivialDataFetcher); }","old_code_raw":"    public InstrumentationFieldFetchParameters withNewState(InstrumentationState instrumentationState) {\n        return new InstrumentationFieldFetchParameters(\n                this.getExecutionContext(), this.getField(), this.getEnvironment(),\n                instrumentationState, executionStrategyParameters);\n    }\n","new_comment_raw":"@return a new parameters object with the new state","old_comment_raw":"@return a new parameters object with the new state","label":0,"pre_label":1,"AST_level":6,"line_counts":6,"new_code_token_num":35},{"new_code_raw":"public long reorganizeSpace(Connection con, SequencerEngine seq, FxTreeMode sourceMode, FxTreeMode destMode, long nodeId, boolean includeNodeId, BigDecimal overrideSpacing, BigDecimal overrideLeft, FxTreeNodeInfo insertParent, int insertPosition, BigDecimal insertSpace, BigDecimal[] insertBoundaries, int depthDelta, Long destinationNode, boolean createMode, boolean createKeepIds) throws FxTreeException { long firstCreatedNodeId = -NUM; FxTreeNodeInfoSpreaded nodeInfo; try { nodeInfo = (FxTreeNodeInfoSpreaded) getTreeNodeInfo(con, sourceMode, nodeId); } catch (Exception e) { return -NUM; } if (!nodeInfo.isSpaceOptimizable()) { if (nodeId == ROOT_NODE) { return -NUM; } return reorganizeSpace(con, seq, sourceMode, destMode, nodeInfo.getParentId(), includeNodeId, overrideSpacing, overrideLeft, insertParent, insertPosition, insertSpace, insertBoundaries, depthDelta, destinationNode, createMode, createKeepIds); } BigDecimal SPACING = nodeInfo.getDefaultSpacing(); if (overrideSpacing != null && overrideSpacing.compareTo(SPACING) < NUM) { SPACING = overrideSpacing; } else { if (SPACING.compareTo(GO_UP) < NUM) { return reorganizeSpace(con, seq, sourceMode, destMode, nodeInfo.getParentId(), includeNodeId, overrideSpacing, overrideLeft, insertParent, insertPosition, insertSpace, insertBoundaries, depthDelta, destinationNode, createMode, createKeepIds); } } Statement stmt = null; PreparedStatement ps = null; ResultSet rs; BigDecimal left = overrideLeft == null ? nodeInfo.getLeft() : overrideLeft; BigDecimal right = null; String includeNode = includeNodeId ? STR : STR; long counter = NUM; long newId = -NUM; try { String createProps = createMode ? STR : STR; String sql = STR + createProps + STR + createProps + STR + getTable(sourceMode) + STR + STR + includeNode + nodeInfo.getLeft() + STR + includeNode + nodeInfo.getRight() + STR + STR; stmt = con.createStatement(); rs = stmt.executeQuery(sql); if (createMode) { ps = con.prepareStatement(STR + getTable(destMode) + STR + STR + STR); } else { ps = con.prepareStatement(STR + getTable(sourceMode) + STR); } long id; int total_childs; int direct_childs; BigDecimal nextLeft; int lastDepth = nodeInfo.getDepth() + (includeNodeId ? NUM : NUM); int depth; BigDecimal _rgt; BigDecimal _lft; Long ref = null; String template = null; String name = STR; Stack<Long> currentParent = null; if (createMode) { currentParent = new Stack<Long>(); currentParent.push(destinationNode); } while (rs.next()) { id = rs.getLong(NUM); total_childs = rs.getInt(NUM); direct_childs = rs.getInt(NUM); _lft = rs.getBigDecimal(NUM); _rgt = rs.getBigDecimal(NUM); depth = rs.getInt(NUM); if (createMode) { ref = rs.getLong(NUM); if (rs.wasNull()) ref = null; name = rs.getString(NUM); template = rs.getString(NUM); if (rs.wasNull()) template = null; } left = left.add(SPACING).add(BigDecimal.ONE); if (lastDepth - depth > NUM) { BigDecimal depthDifference = SPACING.add(BigDecimal.ONE); left = left.add(depthDifference.multiply(new BigDecimal(lastDepth - depth))); } if (createMode) { if (lastDepth < depth) { currentParent.push(newId); } else if (lastDepth > depth) { currentParent.pop(); } } right = left.add(SPACING).add(BigDecimal.ONE); if (total_childs > NUM) { BigDecimal childSpace = SPACING.multiply(new BigDecimal(total_childs * NUM)); childSpace = childSpace.add(new BigDecimal((total_childs * NUM) - NUM)); right = right.add(childSpace); nextLeft = left; } else { nextLeft = right; } if (insertBoundaries != null) { if (_lft.compareTo(insertBoundaries[NUM]) > NUM) { left = left.add(insertSpace); } if (_rgt.compareTo(insertBoundaries[NUM]) > NUM) { right = right.add(insertSpace); } } if (createMode) { newId = createKeepIds ? id : seq.getId(destMode.getSequencer()); if (firstCreatedNodeId == -NUM) { firstCreatedNodeId = newId; } ps.setLong(NUM, newId); ps.setLong(NUM, currentParent.peek()); ps.setLong(NUM, depth + depthDelta); ps.setBoolean(NUM, destMode != FxTreeMode.Live); if (ref == null) { ps.setNull(NUM, java.sql.Types.NUMERIC); } else { ps.setLong(NUM, ref); } if (template == null) { ps.setNull(NUM, java.sql.Types.VARCHAR); } else { ps.setString(NUM, template); } ps.setBigDecimal(NUM, left); ps.setBigDecimal(NUM, right); ps.setInt(NUM, total_childs); ps.setInt(NUM, direct_childs); ps.setString(NUM, name); ps.setLong(NUM, System.currentTimeMillis()); ps.addBatch(); } else { ps.setBigDecimal(NUM, left); ps.setBigDecimal(NUM, right); ps.setInt(NUM, depth + depthDelta); ps.setLong(NUM, id); ps.addBatch(); ps.executeBatch(); ps.clearBatch(); } left = nextLeft; lastDepth = depth; counter++; if (counter % NUM == NUM) { ps.executeBatch(); ps.clearBatch(); } } rs.close(); stmt.close(); stmt = null; ps.executeBatch(); return firstCreatedNodeId; } catch (Throwable e) { throw new FxTreeException(LOG, e, STR, counter, left, right, e.getMessage()); } finally { try { if (stmt != null) stmt.close(); } catch (Throwable t) { } try { if (ps != null) ps.close(); } catch (Throwable t) { } } }","old_code_raw":"public boolean reorganizeSpace(Connection con, SequencerEngine seq, FxTreeMode sourceMode, FxTreeMode destMode, long nodeId, boolean includeNodeId, BigDecimal overrideSpacing, BigDecimal overrideLeft, FxTreeNodeInfo insertParent, int insertPosition, BigDecimal insertSpace, BigDecimal[] insertBoundaries, int depthDelta, Long destinationNode, boolean createMode, boolean createKeepIds, Long firstCreatedNodeId) throws FxTreeException {\n    FxTreeNodeInfoSpreaded nodeInfo;\n    try {\n        nodeInfo = (FxTreeNodeInfoSpreaded) getTreeNodeInfo(con, sourceMode, nodeId);\n    } catch (Exception e) {\n        return false;\n    }\n    if (!nodeInfo.isSpaceOptimizable()) {\n        if (nodeId == ROOT_NODE) {\n            return false;\n        }\n        return reorganizeSpace(con, seq, sourceMode, destMode, nodeInfo.getParentId(), includeNodeId, overrideSpacing, overrideLeft, insertParent, insertPosition, insertSpace, insertBoundaries, depthDelta, destinationNode, createMode, createKeepIds, firstCreatedNodeId);\n    }\n    BigDecimal SPACING = nodeInfo.getDefaultSpacing();\n    if (overrideSpacing != null && overrideSpacing.compareTo(SPACING) < NUM) {\n        SPACING = overrideSpacing;\n    } else {\n        if (SPACING.compareTo(GO_UP) < NUM) {\n            return reorganizeSpace(con, seq, sourceMode, destMode, nodeInfo.getParentId(), includeNodeId, overrideSpacing, overrideLeft, insertParent, insertPosition, insertSpace, insertBoundaries, depthDelta, destinationNode, createMode, createKeepIds, firstCreatedNodeId);\n        }\n    }\n    Statement stmt = null;\n    PreparedStatement ps = null;\n    ResultSet rs;\n    BigDecimal left = overrideLeft == null ? nodeInfo.getLeft() : overrideLeft;\n    BigDecimal right = null;\n    String includeNode = includeNodeId ? STR : STR;\n    long counter = NUM;\n    firstCreatedNodeId = -NUM;\n    long newId = -NUM;\n    try {\n        String createProps = createMode ? STR : STR;\n        String sql = STR + createProps + STR + createProps + STR + getTable(sourceMode) + STR + STR + includeNode + nodeInfo.getLeft() + STR + includeNode + nodeInfo.getRight() + STR + STR;\n        stmt = con.createStatement();\n        rs = stmt.executeQuery(sql);\n        if (createMode) {\n            ps = con.prepareStatement(STR + getTable(destMode) + STR + STR + STR);\n        } else {\n            ps = con.prepareStatement(STR + getTable(sourceMode) + STR);\n        }\n        long id;\n        int total_childs;\n        int direct_childs;\n        BigDecimal nextLeft;\n        int lastDepth = nodeInfo.getDepth() + (includeNodeId ? NUM : NUM);\n        int depth;\n        BigDecimal _rgt;\n        BigDecimal _lft;\n        Long ref = null;\n        String template = null;\n        String name = STR;\n        Stack<Long> currentParent = null;\n        if (createMode) {\n            currentParent = new Stack<Long>();\n            currentParent.push(destinationNode);\n        }\n        while (rs.next()) {\n            id = rs.getLong(NUM);\n            total_childs = rs.getInt(NUM);\n            direct_childs = rs.getInt(NUM);\n            _lft = rs.getBigDecimal(NUM);\n            _rgt = rs.getBigDecimal(NUM);\n            depth = rs.getInt(NUM);\n            if (createMode) {\n                ref = rs.getLong(NUM);\n                if (rs.wasNull())\n                    ref = null;\n                name = rs.getString(NUM);\n                template = rs.getString(NUM);\n                if (rs.wasNull())\n                    template = null;\n            }\n            left = left.add(SPACING).add(BigDecimal.ONE);\n            if (lastDepth - depth > NUM) {\n                BigDecimal depthDifference = SPACING.add(BigDecimal.ONE);\n                left = left.add(depthDifference.multiply(new BigDecimal(lastDepth - depth)));\n            }\n            if (createMode) {\n                if (lastDepth < depth) {\n                    currentParent.push(newId);\n                } else if (lastDepth > depth) {\n                    currentParent.pop();\n                }\n            }\n            right = left.add(SPACING).add(BigDecimal.ONE);\n            if (total_childs > NUM) {\n                BigDecimal childSpace = SPACING.multiply(new BigDecimal(total_childs * NUM));\n                childSpace = childSpace.add(new BigDecimal((total_childs * NUM) - NUM));\n                right = right.add(childSpace);\n                nextLeft = left;\n            } else {\n                nextLeft = right;\n            }\n            if (insertBoundaries != null) {\n                if (_lft.compareTo(insertBoundaries[NUM]) > NUM) {\n                    left = left.add(insertSpace);\n                }\n                if (_rgt.compareTo(insertBoundaries[NUM]) > NUM) {\n                    right = right.add(insertSpace);\n                }\n            }\n            if (createMode) {\n                newId = createKeepIds ? id : seq.getId(destMode.getSequencer());\n                if (firstCreatedNodeId == -NUM) {\n                    firstCreatedNodeId = newId;\n                }\n                ps.setLong(NUM, newId);\n                ps.setLong(NUM, currentParent.peek());\n                ps.setLong(NUM, depth + depthDelta);\n                ps.setBoolean(NUM, destMode != FxTreeMode.Live);\n                if (ref == null) {\n                    ps.setNull(NUM, java.sql.Types.NUMERIC);\n                } else {\n                    ps.setLong(NUM, ref);\n                }\n                if (template == null) {\n                    ps.setNull(NUM, java.sql.Types.VARCHAR);\n                } else {\n                    ps.setString(NUM, template);\n                }\n                ps.setBigDecimal(NUM, left);\n                ps.setBigDecimal(NUM, right);\n                ps.setInt(NUM, total_childs);\n                ps.setInt(NUM, direct_childs);\n                ps.setString(NUM, name);\n                ps.setLong(NUM, System.currentTimeMillis());\n                ps.addBatch();\n            } else {\n                ps.setBigDecimal(NUM, left);\n                ps.setBigDecimal(NUM, right);\n                ps.setInt(NUM, depth + depthDelta);\n                ps.setLong(NUM, id);\n                ps.addBatch();\n                ps.executeBatch();\n                ps.clearBatch();\n            }\n            left = nextLeft;\n            lastDepth = depth;\n            counter++;\n            if (counter % NUM == NUM) {\n                ps.executeBatch();\n                ps.clearBatch();\n            }\n        }\n        rs.close();\n        stmt.close();\n        stmt = null;\n        ps.executeBatch();\n        return true;\n    } catch (Throwable e) {\n        throw new FxTreeException(LOG, e, STR, counter, left, right, e.getMessage());\n    } finally {\n        try {\n            if (stmt != null)\n                stmt.close();\n        } catch (Throwable t) {\n        }\n        try {\n            if (ps != null)\n                ps.close();\n        } catch (Throwable t) {\n        }\n    }\n}","new_comment_raw":"@return first created node id or -1 if no node was created using this method","old_comment_raw":"@return true if the function was successfully","label":1,"pre_label":0,"AST_level":20,"line_counts":164,"new_code_token_num":1108},{"new_code_raw":"public RelDistribution distribution(RelNode rel) { for (;;) { try { return distributionHandler.distribution(rel, this); } catch (JaninoRelMetadataProvider.NoHandler e) { distributionHandler = metadataProvider.revise(e.relClass, BuiltInMetadata.Distribution.DEF); } } }","old_code_raw":"  public RelDistribution distribution(RelNode rel) {\n    final BuiltInMetadata.Distribution metadata =\n        rel.metadata(BuiltInMetadata.Distribution.class, this);\n    return metadata.distribution();\n  }\n","new_comment_raw":"@return List of sorted column combinations, or null if not enough information is available to make that determination","old_comment_raw":"@return List of sorted column combinations, or null if not enough information is available to make that determination","label":0,"pre_label":1,"AST_level":10,"line_counts":11,"new_code_token_num":48},{"new_code_raw":"public Collection<OsmPrimitive> getSelected() { return Collections.unmodifiableSet(selectedPrimitives); }","old_code_raw":"public Collection<OsmPrimitive> getSelected() {\n    return new ArrayList<OsmPrimitive>(selectedPrimitives);\n}","new_comment_raw":"@return unmodifiable collection of primitives","old_comment_raw":"@return List of all selected objects.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":15},{"new_code_raw":"@Nullable public synchronized Habit getHabitByPosition(int position) { if (position < NUM || position >= data.habits.size()) return null; return data.habits.get(position); }","old_code_raw":"@NonNull\npublic Habit getHabitByPosition(int position) {\n    return data.habits.get(position);\n}","new_comment_raw":"@return the habit at given position or null if position is invalid","old_comment_raw":"@return the habit at given position","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":36},{"new_code_raw":"public TreeMap<String, List<String>> getFontFamilies(Collection<String> filenames) { LinkedList<String[]> familyAndFont = new LinkedList<String[]>(); String[] family; BaseFont bf = null; int i = NUM; Collection<String> files = checkNotNull(filenames); for (String filename : files) { family = extractFamilyNames(filename, bf); System.out.println(STR + family[NUM] + STR + filename); String[] x = { family[NUM], filename }; familyAndFont.add(x); i++; } gdd.diag(STR + i + STR); try { for (String[] kv : familyAndFont) { if (familyTree.containsKey(kv[NUM])) { List v = familyTree.get(kv[NUM]); v.add(kv[NUM]); } else { List l = new LinkedList<String>(); l.add(kv[NUM]); familyTree.put(kv[NUM], l); } } } catch (Exception e) { System.err.println(STR); } return (familyTree); }","old_code_raw":"public List<String[]> getFontFamilies(Collection<String> filenames) {\n    LinkedList<String[]> familyAndFont = new LinkedList<String[]>();\n    String[] family = null;\n    BaseFont bf = null;\n    Collection<String> files = checkNotNull(filenames);\n    for (String filename : files) {\n        family = extractFamilyNames(filename, bf);\n        System.out.println(STR + family[NUM] + STR + filename);\n        String[] x = { family[NUM], filename };\n        familyAndFont.add(x);\n    }\n    return (familyAndFont);\n}","new_comment_raw":"@return a tree with entries consisting the family (key) and a linked list of font files in that family (value)","old_comment_raw":"@return a sorted list of arrays of two strings consisting of the family and a font file in that family","label":1,"pre_label":0,"AST_level":13,"line_counts":30,"new_code_token_num":211},{"new_code_raw":"public AuditEvent convertToAuditEvent(PersistentAuditEvent persistentAuditEvent) { return new AuditEvent(Date.from(persistentAuditEvent.getAuditEventDate()), persistentAuditEvent.getPrincipal(), persistentAuditEvent.getAuditEventType(), convertDataToObjects(persistentAuditEvent.getData())); }","old_code_raw":"    public AuditEvent convertToAuditEvent(PersistentAuditEvent persistentAuditEvent) {\n        Instant instant = persistentAuditEvent.getAuditEventDate().atZone(ZoneId.systemDefault()).toInstant();\n        return new AuditEvent(Date.from(instant), persistentAuditEvent.getPrincipal(),\n            persistentAuditEvent.getAuditEventType(), convertDataToObjects(persistentAuditEvent.getData()));\n    }\n","new_comment_raw":"@return the converted list.","old_comment_raw":"@return the converted list.","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":41},{"new_code_raw":"UserInformationResponse processUserInfoResponse(HTTPRequest request) throws UserInfoException { UserInformationResponse userInformationResponse = new UserInformationResponse(); UserInfoResponse response; try { response = com.nimbusds.openid.connect.sdk.UserInfoResponse.parse(request.send()); } catch (ParseException | IOException e) { throw new UserInfoException(STR, e); } if (response instanceof UserInfoErrorResponse) { return userInformationResponse; } UserInfoSuccessResponse userInfoSuccessResponse = (UserInfoSuccessResponse) response; userInformationResponse.setUserInfo(userInfoSuccessResponse.getUserInfo().toJSONObject().toJSONString()); return userInformationResponse; }","old_code_raw":"UserInfoResponse processUserInfoResponse(HTTPRequest request) throws UserInfoException {\n    UserInfoResponse userInfoResponse = new UserInfoResponse();\n    com.nimbusds.openid.connect.sdk.UserInfoResponse response;\n    try {\n        response = com.nimbusds.openid.connect.sdk.UserInfoResponse.parse(request.send());\n    } catch (ParseException | IOException e) {\n        throw new UserInfoException(STR, e);\n    }\n    if (response instanceof UserInfoErrorResponse) {\n        return userInfoResponse;\n    }\n    UserInfoSuccessResponse userInfoSuccessResponse = (UserInfoSuccessResponse) response;\n    userInfoResponse.setUserInfo(userInfoSuccessResponse.getUserInfo().toJSONObject().toJSONString());\n    return userInfoResponse;\n}","new_comment_raw":"@return {@link UserInformationResponse} Object with received values.","old_comment_raw":"@return UserInfoResponse object","label":1,"pre_label":0,"AST_level":7,"line_counts":15,"new_code_token_num":92},{"new_code_raw":"@Override public String toString() { if (stringRep == null) { stringRep = toString(true); } return stringRep; }","old_code_raw":"public String toString(boolean altMemberSep) {\n    StringBuffer s = new StringBuffer();\n    if (className != null) {\n        s.append(className);\n    }\n    if (memberName != null) {\n        if (className != null) {\n            s.append(altMemberSep ? ALT_MEMBER_SEPARATOR : STR);\n        }\n        s.append(memberName);\n    }\n    if (descriptor != null && (className == null || memberName != null)) {\n        s.append(descriptor);\n    }\n    return s.toString();\n}","new_comment_raw":"@return a unique representation of this member ID.","old_comment_raw":"@return the signature string","label":1,"pre_label":0,"AST_level":8,"line_counts":7,"new_code_token_num":25},{"new_code_raw":"protected Object convertInteger(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0; } if (data instanceof Integer) return data; if (data instanceof Number) { Number value = (Number) data; return Integer.valueOf(value.intValue()); } if (data instanceof Boolean) { return NumberConversions.getInteger((Boolean) data); } return handleUnknownData(column, fieldDefn, data); }","old_code_raw":"    protected Object convertInteger(Column column, Field fieldDefn, Object data) {\n        if (data == null) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return 0;\n        }\n        if (data instanceof Integer) return data;\n        if (data instanceof Number) {\n            Number value = (Number) data;\n            return new Integer(value.intValue());\n        }\n        if (data instanceof Boolean) {\n            return NumberConversions.getInteger((Boolean) data);\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","label":0,"pre_label":1,"AST_level":8,"line_counts":19,"new_code_token_num":113},{"new_code_raw":"public ListNode[] rehashing(ListNode[] hashTable) { if (hashTable == null || hashTable.length == 0) { return hashTable; } \/\/Calculate new capacity, double the hashtable size int capacity = hashTable.length * 2; ListNode[] rst = new ListNode[capacity]; for (int i = 0; i < hashTable.length; i++) { ListNode node = hashTable[i]; \/\/ process one hashkey (a linked list) while (node != null) { ListNode newNode = new ListNode(node.val); int hCode = hashcode(newNode.val, capacity); if (rst[hCode] == null) { rst[hCode] = newNode; } else { ListNode collisionNode = rst[hCode]; while (collisionNode.next != null) { collisionNode = collisionNode.next; } collisionNode.next = newNode; } node = node.next; } } return rst; }","old_code_raw":"    public ListNode[] rehashing(ListNode[] hashTable) {\n        if (hashTable == null || hashTable.length == 0) {\n            return hashTable;\n        }\n        \/\/Find longest size\n        \/*\n        int longest = 0;\n        for (int i = 0; i < hashTable.length; i++) {\n            ListNode node = hashTable[i];\n            int count = 0;\n            while (node != null) {\n                count++;\n                node = node.next;\n            }\n            longest = Math.max(longest, count);\n        }*\/\n        \/\/Calculate new capacity\n        \/\/Just to clarify, this problem asks to double the hashtable size, rather than 'longest' times longer.\n        int capacity = hashTable.length * 2;\n        if (capacity == hashTable.length) {\n            return hashTable;\n        }\n        \n        ListNode[] rst = new ListNode[capacity];\n        for (int i = 0; i < hashTable.length; i++) {\n            ListNode node = hashTable[i];\n            while (node != null) {\n                ListNode newNode = new ListNode(node.val);\n                int hCode = hashcode(newNode.val, capacity);\n                if (rst[hCode] == null) {\n                    rst[hCode] = newNode;\n                } else {\n                    ListNode move = rst[hCode];\n                    while (move.next != null) {\n                        move = move.next;\n                    }\n                    move.next = newNode;\n                }\n                node = node.next;\n            }\n        }\n\n        return rst;\n    }\n","new_comment_raw":"@return: A list of The first node of linked list which have twice size","old_comment_raw":"@return: A list of The first node of linked list which have twice size","label":0,"pre_label":1,"AST_level":13,"line_counts":30,"new_code_token_num":165},{"new_code_raw":"protected Object convertBoolean(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return false; } if (data instanceof Boolean) return data; if (data instanceof Short) return ((Short) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE; if (data instanceof Integer) return ((Integer) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE; if (data instanceof Long) return ((Long) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE; return handleUnknownData(column, fieldDefn, data); }","old_code_raw":"    protected Object convertBoolean(Column column, Field fieldDefn, Object data) {\n        if (data == null) return null;\n        if (data instanceof Boolean) return data;\n        if (data instanceof Short) return ((Short) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;\n        if (data instanceof Integer) return ((Integer) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;\n        if (data instanceof Long) return ((Long) data).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;\n        return handleUnknownData(column, fieldDefn, data);\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made","label":1,"pre_label":0,"AST_level":8,"line_counts":15,"new_code_token_num":142},{"new_code_raw":"public static Project createThermalProject(File file) { return createProject(file, THERMAL); }","old_code_raw":"public static Project createThermalProject(File file) {\n    return createProject(file, Type.THERMAL);\n}","new_comment_raw":"@return the created project, or null if file was not writable or it already existed.","old_comment_raw":"@return the created project, or null if file was not writable.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":18},{"new_code_raw":"public PhysicalPlan getPlan(SqlNode sqlNode) throws ValidationException, RelConversionException, IOException { SqlDropTable dropTableNode = ((SqlDropTable) sqlNode); SqlIdentifier tableIdentifier = dropTableNode.getTableIdentifier(); SchemaPlus defaultSchema = config.getConverter().getDefaultSchema(); AbstractSchema drillSchema = null; if (tableIdentifier != null) { drillSchema = SchemaUtilites.resolveToMutableDrillSchema(defaultSchema, dropTableNode.getSchema()); } String tableName = dropTableNode.getName(); if (drillSchema == null) { throw UserException.validationError() .message(\"Invalid table_name [%s]\", tableName) .build(logger); } if (dropTableNode.checkTableExistence()) { final Table tableToDrop = SqlHandlerUtil.getTableFromSchema(drillSchema, tableName); if (tableToDrop == null || tableToDrop.getJdbcTableType() != Schema.TableType.TABLE) { return DirectPlan.createDirectPlan(context, true, String.format(\"Table [%s] not found\", tableName)); } } drillSchema.dropTable(tableName); return DirectPlan.createDirectPlan(context, true, String.format(\"Table [%s] %s\", tableName, \"dropped\")); }","old_code_raw":"  public PhysicalPlan getPlan(SqlNode sqlNode) throws ValidationException, RelConversionException, IOException {\n\n    SqlDropTable dropTableNode = ((SqlDropTable) sqlNode);\n    SqlIdentifier tableIdentifier = dropTableNode.getTableIdentifier();\n\n    SchemaPlus defaultSchema = config.getConverter().getDefaultSchema();\n    AbstractSchema drillSchema = null;\n\n    if (tableIdentifier != null) {\n      drillSchema = SchemaUtilites.resolveToMutableDrillSchema(defaultSchema, dropTableNode.getSchema());\n    }\n\n    String tableName = ((SqlDropTable) sqlNode).getName();\n    if (drillSchema == null) {\n      throw UserException.validationError()\n          .message(\"Invalid table_name [%s]\", tableName)\n          .build(logger);\n    }\n\n    drillSchema.dropTable(tableName);\n\n    return DirectPlan.createDirectPlan(context, true,\n        String.format(\"Table [%s] %s\", tableName, \"dropped\"));\n  }\n","new_comment_raw":"@return - Single row indicating drop succeeded or table is not found while IF EXISTS statement is used, raise exception otherwise","old_comment_raw":"@return - Single row indicating drop succeeded, raise exception otherwise","label":1,"pre_label":0,"AST_level":10,"line_counts":33,"new_code_token_num":199},{"new_code_raw":"public CompletableFuture<ExecutionResult> executeAsync(ExecutionInput executionInput) { try { log.debug(\"Executing request. operation name: {}. query: {}. variables {} \", executionInput.getOperationName(), executionInput.getQuery(), executionInput.getVariables()); InstrumentationState instrumentationState = instrumentation.createState(); InstrumentationExecutionParameters instrumentationParameters = new InstrumentationExecutionParameters(executionInput, this.graphQLSchema, instrumentationState); InstrumentationContext<ExecutionResult> executionInstrumentation = instrumentation.beginExecution(instrumentationParameters); CompletableFuture<ExecutionResult> executionResult = parseValidateAndExecute(executionInput, instrumentationState); \/\/ \/\/ finish up instrumentation executionResult = executionResult.whenComplete(executionInstrumentation::onEnd); \/\/ \/\/ allow instrumentation to tweak the result executionResult = executionResult.thenCompose(result -> instrumentation.instrumentExecutionResult(result, instrumentationParameters)); return executionResult; } catch (AbortExecutionException abortException) { ExecutionResultImpl executionResult = new ExecutionResultImpl(abortException); return CompletableFuture.completedFuture(executionResult); } }","old_code_raw":"    public CompletableFuture<ExecutionResult> executeAsync(ExecutionInput executionInput) {\n        log.debug(\"Executing request. operation name: {}. query: {}. variables {} \", executionInput.getOperationName(), executionInput.getQuery(), executionInput.getVariables());\n\n        InstrumentationState instrumentationState = instrumentation.createState();\n\n        InstrumentationExecutionParameters instrumentationParameters = new InstrumentationExecutionParameters(executionInput, instrumentationState);\n        InstrumentationContext<ExecutionResult> executionInstrumentation = instrumentation.beginExecution(instrumentationParameters);\n        CompletableFuture<ExecutionResult> executionResult = parseValidateAndExecute(executionInput, instrumentationState);\n        \/\/\n        \/\/ finish up instrumentation\n        executionResult = executionResult.whenComplete(executionInstrumentation::onEnd);\n        \/\/\n        \/\/ allow instrumentation to tweak the result\n        executionResult = executionResult.thenCompose(result -> instrumentation.instrumentExecutionResult(result, instrumentationParameters));\n        return executionResult;\n    }\n","new_comment_raw":"@return a promise to an  ExecutionResult which can include errors","old_comment_raw":"@return a promise to an ExecutionResult which can include errors","label":0,"pre_label":1,"AST_level":9,"line_counts":22,"new_code_token_num":155},{"new_code_raw":"public Order getOrderById (String orderId) throws ApiException { Object postBody = null; byte[] postBinaryBody = null; \/\/ verify the required parameter 'orderId' is set if (orderId == null) { throw new ApiException(400, \"Missing the required parameter 'orderId' when calling getOrderById\"); } \/\/ create path and map variables String path = \"\/store\/order\/{orderId}\".replaceAll(\"\\\\{format\\\\}\",\"json\") .replaceAll(\"\\\\{\" + \"orderId\" + \"\\\\}\", apiClient.escapeString(orderId.toString())); \/\/ query params List<Pair> queryParams = new ArrayList<Pair>(); Map<String, String> headerParams = new HashMap<String, String>(); Map<String, Object> formParams = new HashMap<String, Object>(); final String[] accepts = { \"application\/json\", \"application\/xml\" }; final String accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final String contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; TypeRef returnType = new TypeRef<Order>() {}; return apiClient.invokeAPI(path, \"GET\", queryParams, postBody, postBinaryBody, headerParams, formParams, accept, contentType, authNames, returnType); }","old_code_raw":"  public Order getOrderById (String orderId) throws ApiException {\n    Object postBody = null;\n    \n    \/\/ verify the required parameter 'orderId' is set\n    if (orderId == null) {\n       throw new ApiException(400, \"Missing the required parameter 'orderId' when calling getOrderById\");\n    }\n    \n\n    \/\/ create path and map variables\n    String path = \"\/store\/order\/{orderId}\".replaceAll(\"\\\\{format\\\\}\",\"json\")\n      .replaceAll(\"\\\\{\" + \"orderId\" + \"\\\\}\", apiClient.escapeString(orderId.toString()));\n\n    \/\/ query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    Map<String, String> headerParams = new HashMap<String, String>();\n    Map<String, Object> formParams = new HashMap<String, Object>();\n\n    \n\n    \n\n    \n\n    final String[] accepts = {\n      \"application\/json\", \"application\/xml\"\n    };\n    final String accept = apiClient.selectHeaderAccept(accepts);\n\n    final String[] contentTypes = {\n      \n    };\n    final String contentType = apiClient.selectHeaderContentType(contentTypes);\n\n    String[] authNames = new String[] {  };\n    \n    TypeRef returnType = new TypeRef<Order>() {};\n    return apiClient.invokeAPI(path, \"GET\", queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    \n  }\n","new_comment_raw":"@return Order","old_comment_raw":"@return Order","label":0,"pre_label":1,"AST_level":9,"line_counts":48,"new_code_token_num":256},{"new_code_raw":"public static HashMap getXmlRpcWorkflowCondition(WorkflowCondition c) { HashMap condition = new HashMap(); condition.put(STR, c.getConditionInstanceClassName()); condition.put(STR, c.getConditionId()); condition.put(STR, c.getConditionName()); condition.put(STR, String.valueOf(c.getOrder())); condition.put(STR, String.valueOf(c.getTimeoutSeconds())); condition.put(STR, String.valueOf(c.isOptional())); condition.put(STR, getXmlRpcWorkflowConditionConfig(c.getCondConfig())); return condition; }","old_code_raw":"public static Hashtable getXmlRpcWorkflowCondition(WorkflowCondition c) {\n    Hashtable condition = new Hashtable();\n    condition.put(STR, c.getConditionInstanceClassName());\n    condition.put(STR, c.getConditionId());\n    condition.put(STR, c.getConditionName());\n    condition.put(STR, String.valueOf(c.getOrder()));\n    condition.put(STR, String.valueOf(c.getTimeoutSeconds()));\n    condition.put(STR, String.valueOf(c.isOptional()));\n    condition.put(STR, getXmlRpcWorkflowConditionConfig(c.getCondConfig()));\n    return condition;\n}","new_comment_raw":"@return an XML-RPC {@link HashMap} representation of the {@link WorkflowCondition} to send over the wire.","old_comment_raw":"@return an XML-RPC {@link Hashtable} representation of the {@link WorkflowCondition} to send over the wire.","label":1,"pre_label":0,"AST_level":6,"line_counts":11,"new_code_token_num":112},{"new_code_raw":"private RexNode convertInToOr(final Blackboard bb, final List<RexNode> leftKeys, SqlNodeList valuesList, boolean isNotIn) { final List<RexNode> comparisons = new ArrayList<>(); for (SqlNode rightVals : valuesList) { RexNode rexComparison; if (leftKeys.size() == 1) { rexComparison = rexBuilder.makeCall(SqlStdOperatorTable.EQUALS, leftKeys.get(0), ensureSqlType(leftKeys.get(0).getType(), bb.convertExpression(rightVals))); } else { assert rightVals instanceof SqlCall; final SqlBasicCall call = (SqlBasicCall) rightVals; assert (call.getOperator() instanceof SqlRowOperator) && call.operandCount() == leftKeys.size(); rexComparison = RexUtil.composeConjunction(rexBuilder, Iterables.transform(Pair.zip(leftKeys, call.getOperandList()), new Function<Pair<RexNode, SqlNode>, RexNode>() { public RexNode apply(Pair<RexNode, SqlNode> pair) { return rexBuilder.makeCall(SqlStdOperatorTable.EQUALS, pair.left, ensureSqlType(pair.left.getType(), bb.convertExpression(pair.right))); } }), false); } comparisons.add(rexComparison); } RexNode result = RexUtil.composeDisjunction(rexBuilder, comparisons, true); assert result != null; if (isNotIn) { result = rexBuilder.makeCall(SqlStdOperatorTable.NOT, result); } return result; }","old_code_raw":"    private RexNode convertInToOr(final Blackboard bb, final List<RexNode> leftKeys, SqlNodeList valuesList, boolean isNotIn) {\n        final List<RexNode> comparisons = new ArrayList<>();\n        for (SqlNode rightVals : valuesList) {\n            RexNode rexComparison;\n            if (leftKeys.size() == 1) {\n                rexComparison = rexBuilder.makeCall(SqlStdOperatorTable.EQUALS, leftKeys.get(0), rexBuilder.ensureType(leftKeys.get(0).getType(), bb.convertExpression(rightVals), true));\n            } else {\n                assert rightVals instanceof SqlCall;\n                final SqlBasicCall call = (SqlBasicCall) rightVals;\n                assert (call.getOperator() instanceof SqlRowOperator) && call.operandCount() == leftKeys.size();\n                rexComparison = RexUtil.composeConjunction(rexBuilder, Iterables.transform(Pair.zip(leftKeys, call.getOperandList()), new Function<Pair<RexNode, SqlNode>, RexNode>() {\n                    public RexNode apply(Pair<RexNode, SqlNode> pair) {\n                        return rexBuilder.makeCall(SqlStdOperatorTable.EQUALS, pair.left, rexBuilder.ensureType(pair.left.getType(), bb.convertExpression(pair.right), true));\n                    }\n                }), false);\n            }\n            comparisons.add(rexComparison);\n        }\n\n        RexNode result = RexUtil.composeDisjunction(rexBuilder, comparisons, true);\n        assert result != null;\n\n        if (isNotIn) {\n            result = rexBuilder.makeCall(SqlStdOperatorTable.NOT, result);\n        }\n\n        return result;\n    }\n","new_comment_raw":"@return converted expression","old_comment_raw":"@return converted expression","label":0,"pre_label":1,"AST_level":17,"line_counts":29,"new_code_token_num":238},{"new_code_raw":"public static String formatObjectKey(String key) { int index = key == null ? -NUM : key.indexOf(STR); if (index >= NUM) { return key.substring(index + NUM); } return formatKey(key, false, true, false, true); }","old_code_raw":"public static String formatObjectKey(String key) {\n    int index = key == null ? -NUM : key.indexOf(STR);\n    if (index >= NUM) {\n        return key.substring(index + NUM);\n    }\n    return formatKey(key, false, false, false, true);\n}","new_comment_raw":"@return {@link #formatKey(String, boolean, boolean, boolean)} formatColon = false, formatAt = true, formatHyphen = false, firstCase = true","old_comment_raw":"@return {@link #formatKey(String, boolean, boolean, boolean)} formatColon = false, formatAt = false, formatHyphen = false, firstCase = true","label":1,"pre_label":0,"AST_level":8,"line_counts":7,"new_code_token_num":54},{"new_code_raw":"public ApiResponse<Void> deletePetWithHttpInfo(Long petId, String apiKey) throws ApiException { okhttp3.Call localVarCall = deletePetValidateBeforeCall(petId, apiKey, null, null); return localVarApiClient.execute(localVarCall); }","old_code_raw":"    public ApiResponse<Void> deletePetWithHttpInfo(Long petId, String apiKey) throws ApiException {\n        okhttp3.Call call = deletePetValidateBeforeCall(petId, apiKey, null, null);\n        return apiClient.execute(call);\n    }\n","new_comment_raw":"@return ApiResponse&lt;Void&gt;","old_comment_raw":"@return ApiResponse&lt;Void&gt;","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":36},{"new_code_raw":"static public String proxy(final String href) { final int hash = href.indexOf(STR); return -NUM == hash ? href : href.substring(NUM, hash); }","old_code_raw":"static public String proxy(final String uri) {\n    final int fragmentStart = uri.indexOf(STR);\n    return -NUM == fragmentStart ? uri : uri.substring(NUM, fragmentStart);\n}","new_comment_raw":"@return <code>href<\/code>, stripped of any <code>fragment<\/code>","old_comment_raw":"@return <code>uri<\/code>, stripped of any <code>fragment<\/code>","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":35},{"new_code_raw":"public SystemUsage getUsageManager() { return this.usageManager; }","old_code_raw":"    public UsageManager getUsageManager() {\n        return this.usageManager;\n    }\n","new_comment_raw":"@return the usageManager","old_comment_raw":"@return the usageManager","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":11},{"new_code_raw":"public static Criterion fromRawSelection(final String selection, final String[] selectionArgs) { if (TextUtils.isEmpty(selection)) { return null; } return new Criterion(null) { @Override protected void populate(SqlBuilder builder, boolean forSqlValidation) { builder.sql.append(selection); if (selectionArgs != null && selectionArgs.length > NUM) { if (builder.args == null) { throw new UnsupportedOperationException(STR + STR); } Collections.addAll(builder.args, selectionArgs); } } }; }","old_code_raw":"public static Criterion fromRawSelection(final String selection, final String[] selectionArgs) {\n    if (TextUtils.isEmpty(selection)) {\n        return Criterion.all;\n    }\n    return new Criterion(null) {\n\n        @Override\n        protected void populate(SqlBuilder builder, boolean forSqlValidation) {\n            builder.sql.append(selection);\n            if (selectionArgs != null && selectionArgs.length > NUM) {\n                if (builder.args == null) {\n                    throw new UnsupportedOperationException(STR + STR);\n                }\n                Collections.addAll(builder.args, selectionArgs);\n            }\n        }\n    };\n}","new_comment_raw":"@return a {@link Criterion} that evaluates the raw selection and selection args. If the selection string is empty, this will return null.","old_comment_raw":"@return a {@link Criterion} that evaluates the raw selection and selection args","label":1,"pre_label":0,"AST_level":13,"line_counts":18,"new_code_token_num":99},{"new_code_raw":"public UserInformationResponse getUserInfo(OIDCConfiguration oidcConfiguration, String acsToken) throws UserInfoException { BearerAccessToken accessToken = new BearerAccessToken(acsToken); URI userInfoEndpoint = oidcConfiguration.getUserInfoEndpoint(); UserInfoRequest userInfoRequest = new UserInfoRequest(userInfoEndpoint, accessToken); HTTPRequest request = userInfoRequest.toHTTPRequest(); return processUserInfoResponse(request); }","old_code_raw":"public UserInfoResponse getUserInfo(OIDCConfiguration oidcConfiguration, String acsToken) throws UserInfoException {\n    BearerAccessToken accessToken = new BearerAccessToken(acsToken);\n    URI userInfoEndpoint = oidcConfiguration.getUserInfoEndpoint();\n    UserInfoRequest userInfoRequest = new UserInfoRequest(userInfoEndpoint, accessToken);\n    HTTPRequest request = userInfoRequest.toHTTPRequest();\n    return processUserInfoResponse(request);\n}","new_comment_raw":"@return {@link UserInformationResponse} Object with received values.","old_comment_raw":"@return UserInfoResponse Object","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":52},{"new_code_raw":"public NumberExpression<T> negate(){ if (negation == null){ negation = multiply(-1); } return negation; }","old_code_raw":"    public NumberExpression<D> negate(){\n        if (negation == null){\n            negation = multiply(-1);\n        }\n        return negation;\n    }\n","new_comment_raw":"@return this -1","old_comment_raw":"@return this -1","label":0,"pre_label":1,"AST_level":8,"line_counts":7,"new_code_token_num":25},{"new_code_raw":"public SubselectFetch getSubselect(EntityKey key) { return subselectsByEntityKey.get( key ); }","old_code_raw":"\tpublic SubselectFetch getSubselect(EntityKey key) {\n\t\treturn (SubselectFetch) subselectsByEntityKey.get(key);\n\t}\n","new_comment_raw":"@return The fetch descriptor; may return null if no subselect fetch queued for this entity key.","old_comment_raw":"@return The fetch descriptor; may return null if no subselect fetch queued for this entity key.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":16},{"new_code_raw":"public int getMonth() { return date.getMonthValue(); }","old_code_raw":"public int getMonth() {\n    return month;\n}","new_comment_raw":"@return the month of the year as defined by {@linkplain LocalDate}","old_comment_raw":"@return the month of the year as defined by {@linkplain Calendar}","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":13},{"new_code_raw":"public FluentWait<T> withMessage(final String message) { this.messageSupplier = new Supplier<String>() { @Override public String get() { return message; } }; return this; }","old_code_raw":"  public FluentWait<T> withMessage(String message) {\n    this.message = message;\n    return this;\n  }\n","new_comment_raw":"@return A self reference.","old_comment_raw":"@return A self reference.","label":0,"pre_label":1,"AST_level":8,"line_counts":10,"new_code_token_num":36},{"new_code_raw":"public Map<String, InternalPortletPreference> getStoredPreferences(PortletWindow portletWindow, PortletRequest request) throws PortletContainerException { String key = getFormattedKey(portletWindow, request); Map<String, InternalPortletPreference> preferences = storage.get(key); if (preferences == null) { if (LOG.isDebugEnabled()) { LOG.debug(STR + key); } return Collections.emptyMap(); } else { if (LOG.isDebugEnabled()) { LOG.debug(STR + preferences.size() + STR); } return clonePreferences(preferences); } }","old_code_raw":"public InternalPortletPreference[] getStoredPreferences(PortletWindow portletWindow, PortletRequest request) throws PortletContainerException {\n    String key = getFormattedKey(portletWindow, request);\n    InternalPortletPreference[] preferences = storage.get(key);\n    if (preferences == null) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(STR + key);\n        }\n        return new InternalPortletPreference[NUM];\n    } else {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(STR + preferences.length + STR);\n        }\n        return clonePreferences(preferences);\n    }\n}","new_comment_raw":"@return a copy of the stored portlet preferences map.","old_comment_raw":"@return a copy of the stored portlet preferences array.","label":1,"pre_label":0,"AST_level":11,"line_counts":15,"new_code_token_num":98},{"new_code_raw":"public static boolean isVisibleInExplain(RelNode rel, SqlExplainLevel explainLevel) { final BuiltInMetadata.ExplainVisibility metadata = rel.metadata(BuiltInMetadata.ExplainVisibility.class); Boolean b = metadata.isVisibleInExplain(explainLevel); return b == null || b; }","old_code_raw":"public static boolean isVisibleInExplain(RelNode rel, SqlExplainLevel explainLevel) {\n    Boolean b = (Boolean) rel.getCluster().getMetadataProvider().getRelMetadata(rel, STR, new Object[] { explainLevel });\n    if (b == null) {\n        return true;\n    } else {\n        return b;\n    }\n}","new_comment_raw":"@return true for visible, false for invisible; if no metadata is available, defaults to true","old_comment_raw":"@return true for visible, false for invisible","label":1,"pre_label":0,"AST_level":7,"line_counts":5,"new_code_token_num":40},{"new_code_raw":"public boolean isSessionToken(String site, String token) { HashSet<String> siteTokens = sessionTokens.get(site); if (siteTokens == null) return false; return siteTokens.contains(token.toLowerCase(Locale.ENGLISH)); }","old_code_raw":"\tpublic boolean isSessionToken(String site, String token) {\n\t\tHashSet<String> siteTokens = sessionTokens.get(site);\n\t\tif (siteTokens == null)\n\t\t\treturn false;\n\t\treturn siteTokens.contains(token.toLowerCase());\n\t}\n","new_comment_raw":"@return true, if it is session token","old_comment_raw":"@return true, if it is session token","label":0,"pre_label":1,"AST_level":6,"line_counts":7,"new_code_token_num":41},{"new_code_raw":"private boolean getPartitionVectors() { if (!saveSamples()) { return false; } CachedVectorContainer finalTable = null; long val = minorFragmentSampleCount.incrementAndGet(); logger.debug(\"Incremented mfsc, got {}\", val); long fragmentsBeforeProceed = (long) Math.ceil(sendingMajorFragmentWidth * completionFactor); String finalTableKey = mapKey + \"final\"; if (val == fragmentsBeforeProceed) { \/\/ we crossed the barrier, build table and get data. buildTable(); finalTable = tableMap.get(finalTableKey); } else { \/\/ Wait until sufficient number of fragments have submitted samples, or proceed after xx ms passed \/\/ TODO: this should be polling. if (val < fragmentsBeforeProceed) { waitUntilTimeOut(10); } for (int i = 0; i < 100 && finalTable == null; i++) { finalTable = tableMap.get(finalTableKey); if (finalTable != null) { break; } waitUntilTimeOut(10); } if (finalTable == null) { buildTable(); } finalTable = tableMap.get(finalTableKey); } Preconditions.checkState(finalTable != null); \/\/ Extract vectors from the wrapper, and add to partition vectors. These vectors will be used for partitioning in \/\/ the rest of this operator for (VectorWrapper<?> w : finalTable.get()) { partitionVectors.add(w.getValueVector()); } return true; }","old_code_raw":"  private boolean getPartitionVectors() {\n    try {\n      if (!saveSamples()) {\n        return false;\n      }\n\n      CachedVectorContainer finalTable = null;\n\n      long val = minorFragmentSampleCount.incrementAndGet();\n      logger.debug(\"Incremented mfsc, got {}\", val);\n\n      long fragmentsBeforeProceed =\n          (long) Math.ceil(sendingMajorFragmentWidth * completionFactor);\n      String finalTableKey = mapKey + \"final\";\n\n      if (val == fragmentsBeforeProceed) { \/\/ we crossed the barrier, build table and get data.\n        buildTable();\n        finalTable = tableMap.get(finalTableKey);\n      } else {\n        \/\/ Wait until sufficient number of fragments have submitted samples, or proceed after xx ms passed\n        \/\/ TODO: this should be polling.\n\n        if (val < fragmentsBeforeProceed) {\n          waitUntilTimeOut(10);\n        }\n        for (int i = 0; i < 100 && finalTable == null; i++) {\n          finalTable = tableMap.get(finalTableKey);\n          if (finalTable != null) {\n            break;\n          }\n          waitUntilTimeOut(10);\n        }\n        if (finalTable == null) {\n          buildTable();\n        }\n        finalTable = tableMap.get(finalTableKey);\n      }\n\n      Preconditions.checkState(finalTable != null);\n\n      \/\/ Extract vectors from the wrapper, and add to partition vectors. These vectors will be used for partitioning in\n      \/\/ the rest of this operator\n      for (VectorWrapper<?> w : finalTable.get()) {\n        partitionVectors.add(w.getValueVector());\n      }\n\n    } catch (ClassTransformationException | IOException | SchemaChangeException ex) {\n      kill(false);\n      context.getExecutorState().fail(ex);\n      return false;\n      \/\/ TODO InterruptedException\n    }\n    return true;\n  }\n","new_comment_raw":"@return True is successful. False if failed.","old_comment_raw":"@return True is successful. False if failed.","label":0,"pre_label":1,"AST_level":10,"line_counts":47,"new_code_token_num":257},{"new_code_raw":"protected Class<T> getConfigurationClass() { return (Class<T>) Generics.getTypeParameter(getClass(), Configuration.class); }","old_code_raw":"    protected Class<T> getConfigurationClass() {\n        return (Class<T>) Generics.getTypeParameter(getClass());\n    }\n","new_comment_raw":"@return the  Class of the configuration type","old_comment_raw":"@return the Class of the configuration type","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":24},{"new_code_raw":"public Report findOneThrowExceptionIfNotFound(final Long id) { return this.reportRepository.findById(id) .orElseThrow(() -> new ReportNotFoundException(id)); }","old_code_raw":"    public Report findOneThrowExceptionIfNotFound(final Long id) {\n        final Report report = this.reportRepository.findOne(id);\n        \n        if (report == null) {\n            throw new ReportNotFoundException(id);\n        }\n        \n        return report;\n    }\n","new_comment_raw":"@return  Report object","old_comment_raw":"@return Report object","label":0,"pre_label":1,"AST_level":8,"line_counts":5,"new_code_token_num":29},{"new_code_raw":"public boolean isEmpty() { return pendingCount <= NUM; }","old_code_raw":"public boolean isEmpty() {\n    return empty;\n}","new_comment_raw":"@return true if there are no pendingCount messages","old_comment_raw":"@return true if there are no pending messages","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":11},{"new_code_raw":"public Object next() throws java.io.IOException { int zzInput; int zzAction; \/\/ cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; \/\/ set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { \/\/ store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); \/\/ get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } \/\/ store back cached position zzMarkedPos = zzMarkedPosL; if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { \/\/ prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); \/\/ System.err.println(\"At end of text making after: |\" + str + \"|\"); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); \/\/ System.err.println(\"prevWord is |\" + prevWord.get(CoreAnnotations.TextAnnotation.class) + \"|, its after is |\" + \/\/ prevWord.get(CoreAnnotations.AfterAnnotation.class) + \"|\"); prevWordAfter.setLength(0); } return null; } } else { switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { String str = yytext(); int first = str.codePointAt(0); String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } logger.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: logger.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 79: break; case 2: { return getNext(\"<\", yytext()); } case 80: break; case 3: { return getNext(); } case 81: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 82: break; case 5: { if (tokenizeNLs) { return getNext(AbstractTokenizer.NEWLINE_TOKEN, yytext()); \/\/ for tokenizing newliens } else if (invertible) { \/\/ System.err.println(\"Appending newline: |\" + yytext() + \"|\"); prevWordAfter.append(yytext()); } } case 83: break; case 6: { final String origTxt = yytext(); String tok = LexerUtils.removeSoftHyphens(origTxt); if (americanize) { tok = Americanize.americanize(tok); } if (DEBUG) { logger.info(\"Used {WORD} (2) to recognize \" + origTxt + \" as \" + tok); } return getNext(tok, origTxt); } case 84: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 85: break; case 8: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {QUOTES} (3) to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 86: break; case 9: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 87: break; case 10: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 88: break; case 11: { return getNext(\">\", yytext()); } case 89: break; case 12: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 90: break; case 13: { handleHyphenatedNumber(yytext()); if (DEBUG) { logger.info(\"Used {NUMBER} to recognize \" + yytext() + \" as \" + removeFromNumber(yytext())); } return getNext(removeFromNumber(yytext()), yytext()); } case 91: break; case 14: { return handleEllipsis(yytext()); } case 92: break; case 15: { \/\/ breakByHyphens(yytext()); \/\/ this is causing fail of attempted to pushback too much! String tok = yytext(); \/* A THING can contain quote like O'Malley *\/ String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {THING} (2) to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 93: break; case 16: { String txt = yytext(); String norm = normalizeFractions(yytext()); if (DEBUG) { logger.info(\"Used {FRAC2} to recognize \" + txt + \" as \" + norm + \"; normalizeFractions=\" + normalizeFractions + \", escapeForwardSlashAsterisk=\" + escapeForwardSlashAsterisk); } return getNext(norm, txt); } case 94: break; case 17: { if (normalizeCurrency) { return getNext(LexerUtils.normalizeCurrency(yytext()), yytext()); } else { return getNext(LexerUtils.minimallyNormalizeCurrency(yytext()), yytext()); } } case 95: break; case 18: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 96: break; case 19: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 97: break; case 20: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 98: break; case 21: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 99: break; case 22: { if (normalizeOtherBrackets) { return getNext(\"-LSB-\", yytext()); } else { return getNext(); } } case 100: break; case 23: { if (normalizeOtherBrackets) { return getNext(\"-RSB-\", yytext()); } else { return getNext(); } } case 101: break; case 24: { String tok = yytext(); String norm = LexerUtils.processCp1252misc(tok); if (DEBUG) { logger.info(\"Used {CP1252_MISC_SYMBOL} to recognize \" + tok + \" as \" + norm); } return getNext(norm, tok); } case 102: break; case 25: { if (invertible) { prevWordAfter.append(yytext()); } } case 103: break; case 26: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 104: break; case 27: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 17; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 18; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 105: break; case 28: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(); } case 106: break; case 29: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {REDAUX} (2) to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 107: break; case 30: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {APOWORD} to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 108: break; case 31: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); String norm = handleQuotes(tok, true); if (DEBUG) { logger.info(\"Used {DBLQUOT} to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + true); } return getNext(norm, tok); } case 109: break; case 32: { String tok = yytext(); if (DEBUG) { logger.info(\"Used {PROG_LANGS} to recognize \" + tok + \" as \" + tok); } return getNext(tok, tok); } case 110: break; case 33: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 111: break; case 34: { breakByHyphens(yytext()); if (DEBUG) { logger.info(\"Used {HTHING} to recognize \" + yytext() + \" as \" + LexerUtils.removeSoftHyphens(yytext())); } return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext()); } case 112: break; case 35: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tok = LexerUtils.removeSoftHyphens(origTxt); if (americanize) { tok = Americanize.americanize(tok); } if (DEBUG) { logger.info(\"Used {WORD} to recognize \" + origTxt + \" as \" + tok); } return getNext(tok, origTxt); } case 113: break; case 36: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 114: break; case 37: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String origTok = yytext(); String norm = LexerUtils.removeSoftHyphens(origTok); if (DEBUG) { logger.info(\"Used {WORD} (3) to recognize \" + origTok + \" as \" + norm); } return getNext(norm, origTok); } case 115: break; case 38: { \/\/ this one should only match if we're basically at the end of file \/\/ since the last one matches two things, even newlines (if not tokenize per line) return processAbbrev1(); } case 116: break; case 39: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 117: break; case 40: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { \/\/ Extra context is to not match on ones like 'd but you do want words like \"a\" \/\/ can't have digit here because of cases like '90s String tok = yytext(); \/* invert single quote - often but not always right *\/ String norm = handleQuotes(tok, true); if (DEBUG) { logger.info(\"Used {QUOTES} to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + true); } return getNext(norm, tok); } case 118: break; case 41: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {REDAUX} to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 119: break; case 42: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { \/\/ Extra context is to not match on ones like 'd but you do want words like \"a\" \/\/ can't have digit here because of cases like '90s String tok = yytext(); \/* invert single quote - often but not always right *\/ String norm = handleQuotes(tok, true); if (DEBUG) { logger.info(\"Used {QUOTES} (2) to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + true); } return getNext(norm, tok); } case 120: break; case 43: { return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext()); } case 121: break; case 44: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {SREDAUX} (2) to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 122: break; case 45: { if (splitAssimilations) { yypushback(2); } String tok = yytext(); if (DEBUG) { logger.info(\"Used {ASSIMILATIONS3} to recognize \" + tok + \" as \" + tok + \"; splitAssimilations=\" + splitAssimilations); } return getNext(tok, tok); } case 123: break; case 46: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String txt = yytext(); if (DEBUG) { logger.info(\"Used {DIGIT}\/{SEP_SUFFIX} to recognize \" + txt); } return getNext(txt, txt); } case 124: break; case 47: { String txt = yytext(); \/\/ if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space... if (strictTreebank3) { int spaceIndex = indexOfSpace(txt); if (spaceIndex >= 0) { yypushback(txt.length() - spaceIndex); return getNext(); } } if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, yytext()); } case 125: break; case 48: { final String origTxt = yytext(); String tok; if (normalizeAmpersandEntity) { tok = LexerUtils.normalizeAmp(origTxt); } else { tok = origTxt; } if (DEBUG) { logger.info(\"Used {THINGA} (2) to recognize \" + origTxt + \" as \" + tok); } return getNext(tok, origTxt); } case 126: break; case 49: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, origTxt); } case 127: break; case 50: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space } return getNext(txt, origTxt); } case 128: break; case 51: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tok = LexerUtils.removeSoftHyphens(origTxt); if (DEBUG) { logger.info(\"Used {SWORD} to recognize \" + origTxt + \" as \" + tok); } return getNext(tok, origTxt); } case 129: break; case 52: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 19; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 18; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 130: break; case 53: { String txt = yytext(); String normTok = txt; if (escapeForwardSlashAsterisk) { normTok = delimit(normTok, '*'); } if (DEBUG) { logger.info(\"Used {SWEARING} to recognize \" + txt + \" as \" + normTok); } return getNext(normTok, txt); } case 131: break; case 54: { final String origTxt = yytext(); String tok; if (normalizeAmpersandEntity) { tok = LexerUtils.normalizeAmp(origTxt); } else { tok = origTxt; } if (DEBUG) { logger.info(\"Used {TBSPEC} to recognize \" + origTxt + \" as \" + tok); } return getNext(tok, origTxt); } case 132: break; case 55: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 133: break; case 56: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 13; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 134: break; case 57: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 22; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 24; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 135: break; case 58: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 21; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 136: break; case 59: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 13; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 137: break; case 60: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 22; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 23; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 138: break; case 61: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); breakByHyphens(tok); tok = yytext(); String norm = LexerUtils.removeSoftHyphens(tok); if (DEBUG) { logger.info(\"Used {HTHING} (2) to recognize \" + tok + \" as \" + norm); } return getNext(norm, tok); } case 139: break; case 62: { if (splitAssimilations) { yypushback(3); } String tok = yytext(); if (DEBUG) { logger.info(\"Used {ASSIMILATIONS3} to recognize \" + tok + \" as \" + tok + \"; splitAssimilations=\" + splitAssimilations); } return getNext(tok, tok); } case 140: break; case 63: { final String origTxt = yytext(); String tok; if (normalizeAmpersandEntity) { tok = LexerUtils.normalizeAmp(origTxt); } else { tok = origTxt; } if (DEBUG) { logger.info(\"Used {SPAMP} to recognize \" + origTxt + \" as \" + tok); } return getNext(tok, origTxt); } case 141: break; case 64: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext()); } case 142: break; case 65: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { final String origTxt = yytext(); String tok; if (normalizeAmpersandEntity) { tok = LexerUtils.normalizeAmp(origTxt); } else { tok = origTxt; } if (DEBUG) { logger.info(\"Used {THINGA} to recognize \" + origTxt + \" as \" + tok); } return getNext(tok, origTxt); } case 143: break; case 66: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 9; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 144: break; case 67: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { return getNext(); } case 145: break; case 68: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 14; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 146: break; case 69: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 9; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 10; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 147: break; case 70: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 14; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 15; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 148: break; case 71: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String txt = yytext(); String norm = txt; if (escapeForwardSlashAsterisk) { norm = delimit(norm, '\/'); norm = delimit(norm, '*'); } if (DEBUG) { logger.info(\"Used {LIKELYURL} to recognize \" + txt + \" as \" + norm); } return getNext(norm, txt); } case 149: break; case 72: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } return getNext(txt, yytext()); } case 150: break; case 73: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4); { return getNext(); } case 151: break; case 74: \/\/ lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { return getNext(); } case 152: break; case 75: { String txt = yytext(); String norm = txt; if (escapeForwardSlashAsterisk) { norm = delimit(norm, '\/'); norm = delimit(norm, '*'); } if (DEBUG) { logger.info(\"Used {FULLURL} to recognize \" + txt + \" as \" + norm); } return getNext(norm, txt); } case 153: break; case 76: { String txt = yytext(); if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } if (DEBUG) { logger.info(\"Used {PHONE} to recognize \" + yytext() + \" as \" + txt); } return getNext(txt, yytext()); } case 154: break; case 77: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 25; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 27; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 155: break; case 78: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 25; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 26; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 156: break; default: zzScanError(ZZ_NO_MATCH); } } } }","old_code_raw":"  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    \/\/ cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      \/\/ set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            \/\/ store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            \/\/ get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      \/\/ store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n        zzAtEOF = true;\n              {\n                if (invertible) {\n            \/\/ prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            \/\/ System.err.println(\"At end of text making after: |\" + str + \"|\");\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n            \/\/ System.err.println(\"prevWord is |\" + prevWord.get(CoreAnnotations.TextAnnotation.class) + \"|, its after is |\" +\n            \/\/         prevWord.get(CoreAnnotations.AfterAnnotation.class) + \"|\");\n            prevWordAfter.setLength(0);\n          }\n          return null;\n              }\n      }\n      else {\n        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n          case 1: \n            { String str = yytext();\n          int first = str.codePointAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\",\n                          yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n            }\n          case 79: break;\n          case 2: \n            { return getNext(\"<\", yytext());\n            }\n          case 80: break;\n          case 3: \n            { return getNext();\n            }\n          case 81: break;\n          case 4: \n            { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n            }\n          case 82: break;\n          case 5: \n            { if (tokenizeNLs) {\n                      return getNext(AbstractTokenizer.NEWLINE_TOKEN, yytext()); \/\/ for tokenizing newliens\n                  } else if (invertible) {\n                    \/\/ System.err.println(\"Appending newline: |\" + yytext() + \"|\");\n                    prevWordAfter.append(yytext());\n                  }\n            }\n          case 83: break;\n          case 6: \n            { final String origTxt = yytext();\n                          String tok = LexerUtils.removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tok = Americanize.americanize(tok);\n                          }\n                          if (DEBUG) { logger.info(\"Used {WORD} (2) to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 84: break;\n          case 7: \n            { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n            }\n          case 85: break;\n          case 8: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} (3) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 86: break;\n          case 9: \n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 87: break;\n          case 10: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '\/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 88: break;\n          case 11: \n            { return getNext(\">\", yytext());\n            }\n          case 89: break;\n          case 12: \n            { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n            }\n          case 90: break;\n          case 13: \n            { handleHyphenatedNumber(yytext());\n                          if (DEBUG) { logger.info(\"Used {NUMBER} to recognize \" + yytext() + \" as \" + removeFromNumber(yytext())); }\n                          return getNext(removeFromNumber(yytext()), yytext());\n            }\n          case 91: break;\n          case 14: \n            { return handleEllipsis(yytext());\n            }\n          case 92: break;\n          case 15: \n            { \/\/ breakByHyphens(yytext()); \/\/ this is causing fail of attempted to pushback too much!\n                  String tok = yytext();\n                  \/* A THING can contain quote like O'Malley *\/\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {THING} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 93: break;\n          case 16: \n            { String txt = yytext();\n                  String norm = normalizeFractions(yytext());\n                  if (DEBUG) { logger.info(\"Used {FRAC2} to recognize \" + txt + \" as \" + norm +\n                                       \"; normalizeFractions=\" + normalizeFractions +\n                                       \", escapeForwardSlashAsterisk=\" + escapeForwardSlashAsterisk); }\n                  return getNext(norm, txt);\n            }\n          case 94: break;\n          case 17: \n            { if (normalizeCurrency) {\n                            return getNext(LexerUtils.normalizeCurrency(yytext()), yytext());\n                        } else {\n                            return getNext(LexerUtils.minimallyNormalizeCurrency(yytext()), yytext());\n                          }\n            }\n          case 95: break;\n          case 18: \n            { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 96: break;\n          case 19: \n            { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 97: break;\n          case 20: \n            { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 98: break;\n          case 21: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 99: break;\n          case 22: \n            { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 100: break;\n          case 23: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-LSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 101: break;\n          case 24: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-RSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 102: break;\n          case 25: \n            { String tok = yytext();\n                        String norm = LexerUtils.processCp1252misc(tok);\n                        if (DEBUG) { logger.info(\"Used {CP1252_MISC_SYMBOL} to recognize \" + tok + \" as \" + norm); }\n                        return getNext(norm, tok);\n            }\n          case 103: break;\n          case 26: \n            { if (invertible) {\n                            prevWordAfter.append(yytext());\n                        }\n            }\n          case 104: break;\n          case 27: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 17;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 18;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 105: break;\n          case 28: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext();\n            }\n          case 106: break;\n          case 29: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {REDAUX} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 107: break;\n          case 30: \n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {APOWORD} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 108: break;\n          case 31: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                                   String norm = handleQuotes(tok, true);\n                                   if (DEBUG) { logger.info(\"Used {DBLQUOT} to recognize \" + tok + \" as \" + norm +\n                                                            \"; probablyLeft=\" + true); }\n                                   return getNext(norm, tok);\n            }\n          case 109: break;\n          case 32: \n            { String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {PROG_LANGS} to recognize \" + tok + \" as \" + tok); }\n                    return getNext(tok, tok);\n            }\n          case 110: break;\n          case 33: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 8;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { String txt = yytext();\n                  if (DEBUG) { logger.info(\"Used {DIGIT}\/{SEP_SUFFIX} to recognize \" + txt); }\n                  return getNext(txt, txt);\n            }\n          case 111: break;\n          case 34: \n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 112: break;\n          case 35: \n            { breakByHyphens(yytext());\n                  if (DEBUG) { logger.info(\"Used {HTHING} to recognize \" + yytext() + \" as \" + LexerUtils.removeSoftHyphens(yytext())); }\n                  return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext());\n            }\n          case 113: break;\n          case 36: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 3;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 4;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String origTxt = yytext();\n                          String tok = LexerUtils.removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tok = Americanize.americanize(tok);\n                          }\n                          if (DEBUG) { logger.info(\"Used {WORD} to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 114: break;\n          case 37: \n            { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '\/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 115: break;\n          case 38: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String origTok = yytext();\n                          String norm = LexerUtils.removeSoftHyphens(origTok);\n                          if (DEBUG) { logger.info(\"Used {WORD} (3) to recognize \" + origTok + \" as \" + norm); }\n                          return getNext(norm, origTok);\n            }\n          case 116: break;\n          case 39: \n            { \/\/ this one should only match if we're basically at the end of file\n                          \/\/ since the last one matches two things, even newlines (if not tokenize per line)\n                          return processAbbrev1();\n            }\n          case 117: break;\n          case 40: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 118: break;\n          case 41: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { \/\/ Extra context is to not match on ones like 'd but you do want words like \"a\"\n                  \/\/ can't have digit here because of cases like '90s\n                  String tok = yytext();\n                  \/* invert single quote - often but not always right *\/\n                  String norm = handleQuotes(tok, true);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + true); }\n                  return getNext(norm, tok);\n            }\n          case 119: break;\n          case 42: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {REDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 120: break;\n          case 43: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { \/\/ Extra context is to not match on ones like 'd but you do want words like \"a\"\n                  \/\/ can't have digit here because of cases like '90s\n                  String tok = yytext();\n                  \/* invert single quote - often but not always right *\/\n                  String norm = handleQuotes(tok, true);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + true); }\n                  return getNext(norm, tok);\n            }\n          case 121: break;\n          case 44: \n            { return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext());\n            }\n          case 122: break;\n          case 45: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {SREDAUX} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 123: break;\n          case 46: \n            { if (splitAssimilations) {\n                      yypushback(2);\n                    }\n                    String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {ASSIMILATIONS3} to recognize \" + tok + \" as \" + tok +\n                            \"; splitAssimilations=\" + splitAssimilations); }\n                    return getNext(tok, tok);\n            }\n          case 124: break;\n          case 47: \n            { String txt = yytext();\n                  \/\/ if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space...\n                  if (strictTreebank3) {\n                    int spaceIndex = indexOfSpace(txt);\n                    if (spaceIndex >= 0) {\n                      yypushback(txt.length() - spaceIndex);\n                      return getNext();\n                    }\n                  }\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '\/');\n                  }\n                  if (normalizeSpace) {\n                    txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                  }\n                  return getNext(txt, yytext());\n            }\n          case 125: break;\n          case 48: \n            { final String origTxt = yytext();\n                          String tok;\n                          if (normalizeAmpersandEntity) {\n                            tok = LexerUtils.normalizeAmp(origTxt);\n                          } else {\n                            tok = origTxt;\n                          }\n                          if (DEBUG) { logger.info(\"Used {THINGA} (2) to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 126: break;\n          case 49: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 127: break;\n          case 50: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 128: break;\n          case 51: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 5;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 6;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String origTxt = yytext();\n                          String tok = LexerUtils.removeSoftHyphens(origTxt);\n                          if (DEBUG) { logger.info(\"Used {SWORD} to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 129: break;\n          case 52: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 19;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 18;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 130: break;\n          case 53: \n            { String txt = yytext();\n                  String normTok = txt;\n                  if (escapeForwardSlashAsterisk) {\n                    normTok = delimit(normTok, '*');\n                  }\n                  if (DEBUG) { logger.info(\"Used {SWEARING} to recognize \" + txt + \" as \" + normTok); }\n                  return getNext(normTok, txt);\n            }\n          case 131: break;\n          case 54: \n            { final String origTxt = yytext();\n                  String tok;\n                  if (normalizeAmpersandEntity) {\n                    tok = LexerUtils.normalizeAmp(origTxt);\n                  } else {\n                    tok = origTxt;\n                  }\n                  if (DEBUG) { logger.info(\"Used {TBSPEC} to recognize \" + origTxt + \" as \" + tok); }\n                  return getNext(tok, origTxt);\n            }\n          case 132: break;\n          case 55: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 133: break;\n          case 56: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 13;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 134: break;\n          case 57: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 22;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 24;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 135: break;\n          case 58: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 21;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 136: break;\n          case 59: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 13;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 137: break;\n          case 60: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 22;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 23;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 138: break;\n          case 61: \n            { String txt = yytext();\n                          String norm = txt;\n                          if (escapeForwardSlashAsterisk) {\n                            norm = delimit(norm, '\/');\n                            norm = delimit(norm, '*');\n                          }\n                          if (DEBUG) { logger.info(\"Used {LIKELYURL} to recognize \" + txt + \" as \" + norm); }\n                          return getNext(norm, txt);\n            }\n          case 139: break;\n          case 62: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                  breakByHyphens(tok);\n                  tok = yytext();\n                  String norm = LexerUtils.removeSoftHyphens(tok);\n                  if (DEBUG) { logger.info(\"Used {HTHING} (2) to recognize \" + tok + \" as \" + norm); }\n                  return getNext(norm, tok);\n            }\n          case 140: break;\n          case 63: \n            { if (splitAssimilations) {\n                      yypushback(3);\n                    }\n                    String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {ASSIMILATIONS3} to recognize \" + tok + \" as \" + tok +\n                            \"; splitAssimilations=\" + splitAssimilations); }\n                    return getNext(tok, tok);\n            }\n          case 141: break;\n          case 64: \n            { final String origTxt = yytext();\n                          String tok;\n                          if (normalizeAmpersandEntity) {\n                            tok = LexerUtils.normalizeAmp(origTxt);\n                          } else {\n                            tok = origTxt;\n                          }\n                          if (DEBUG) { logger.info(\"Used {SPAMP} to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 142: break;\n          case 65: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext());\n            }\n          case 143: break;\n          case 66: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { final String origTxt = yytext();\n                          String tok;\n                          if (normalizeAmpersandEntity) {\n                            tok = LexerUtils.normalizeAmp(origTxt);\n                          } else {\n                            tok = origTxt;\n                          }\n                          if (DEBUG) { logger.info(\"Used {THINGA} to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 144: break;\n          case 67: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 9;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 145: break;\n          case 68: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { return getNext();\n            }\n          case 146: break;\n          case 69: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 14;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 147: break;\n          case 70: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 9;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 10;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 148: break;\n          case 71: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 14;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 15;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 149: break;\n          case 72: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 150: break;\n          case 73: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4);\n            { return getNext();\n            }\n          case 151: break;\n          case 74: \n            \/\/ lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);\n            { return getNext();\n            }\n          case 152: break;\n          case 75: \n            { String txt = yytext();\n                          String norm = txt;\n                          if (escapeForwardSlashAsterisk) {\n                            norm = delimit(norm, '\/');\n                            norm = delimit(norm, '*');\n                          }\n                          if (DEBUG) { logger.info(\"Used {FULLURL} to recognize \" + txt + \" as \" + norm); }\n                          return getNext(norm, txt);\n            }\n          case 153: break;\n          case 76: \n            { String txt = yytext();\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          if (DEBUG) { logger.info(\"Used {PHONE} to recognize \" + yytext() + \" as \" + txt); }\n                          return getNext(txt, yytext());\n            }\n          case 154: break;\n          case 77: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 25;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 27;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 155: break;\n          case 78: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 25;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 26;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 156: break;\n          default:\n            zzScanError(ZZ_NO_MATCH);\n        }\n      }\n    }\n  }\n","new_comment_raw":"@return the next token","old_comment_raw":"@return the next token","label":0,"pre_label":1,"AST_level":21,"line_counts":1167,"new_code_token_num":8327},{"new_code_raw":"private static Class getVMPrimitiveType(final String name) { return VM_PRIMITIVES.get(name); }","old_code_raw":"    private static Class getVMPrimitiveType(final String name) {\n        return (Class) VM_PRIMITIVES.get(name);\n    }\n","new_comment_raw":"@return Primitive type or null.","old_comment_raw":"@return Primitive type or null.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":18},{"new_code_raw":"public static StandardProperty buildStandardProperty(AttributeBinding property, boolean lazyAvailable) { final Type type = property.getHibernateTypeDescriptor().getResolvedTypeMapping(); \/\/ we need to dirty check collections, since they can cause an owner \/\/ version number increment \/\/ we need to dirty check many-to-ones with not-found=\"ignore\" in order \/\/ to update the cache (not the database), since in this case a null \/\/ entity reference can lose information final boolean alwaysDirtyCheck = type.isAssociationType() && ( (AssociationType) type ).isAlwaysDirtyChecked(); if ( property.getAttribute().isSingular() ) { final SingularAttributeBinding singularAttributeBinding = ( SingularAttributeBinding ) property; final CascadeStyle cascadeStyle = singularAttributeBinding.isAssociation() ? ( (AssociationAttributeBinding) singularAttributeBinding ).getCascadeStyle() : CascadeStyles.NONE; final FetchMode fetchMode = singularAttributeBinding.isAssociation() ? ( (AssociationAttributeBinding) singularAttributeBinding ).getFetchMode() : FetchMode.DEFAULT; return new StandardProperty( singularAttributeBinding.getAttribute().getName(), type, lazyAvailable && singularAttributeBinding.isLazy(), true, \/\/ insertable true, \/\/ updatable singularAttributeBinding.getGeneration() == PropertyGeneration.INSERT || singularAttributeBinding.getGeneration() == PropertyGeneration.ALWAYS, singularAttributeBinding.getGeneration() == PropertyGeneration.ALWAYS, singularAttributeBinding.isNullable(), alwaysDirtyCheck || areAllValuesIncludedInUpdate( singularAttributeBinding ), singularAttributeBinding.isIncludedInOptimisticLocking(), cascadeStyle, fetchMode ); } else { final AbstractPluralAttributeBinding pluralAttributeBinding = (AbstractPluralAttributeBinding) property; final CascadeStyle cascadeStyle = pluralAttributeBinding.isAssociation() ? pluralAttributeBinding.getCascadeStyle() : CascadeStyles.NONE; final FetchMode fetchMode = pluralAttributeBinding.isAssociation() ? pluralAttributeBinding.getFetchMode() : FetchMode.DEFAULT; return new StandardProperty( pluralAttributeBinding.getAttribute().getName(), type, lazyAvailable && pluralAttributeBinding.isLazy(), \/\/ TODO: fix this when HHH-6356 is fixed; for now assume AbstractPluralAttributeBinding is updatable and insertable true, \/\/ pluralAttributeBinding.isInsertable(), true, \/\/pluralAttributeBinding.isUpdatable(), false, false, false, \/\/ nullable - not sure what that means for a collection \/\/ TODO: fix this when HHH-6356 is fixed; for now assume AbstractPluralAttributeBinding is updatable and insertable \/\/alwaysDirtyCheck || pluralAttributeBinding.isUpdatable(), true, pluralAttributeBinding.isIncludedInOptimisticLocking(), cascadeStyle, fetchMode ); } }","old_code_raw":"\tpublic static StandardProperty buildStandardProperty(AttributeBinding property, boolean lazyAvailable) {\n\n\t\tfinal Type type = property.getHibernateTypeDescriptor().getResolvedTypeMapping();\n\n\t\t\/\/ we need to dirty check collections, since they can cause an owner\n\t\t\/\/ version number increment\n\n\t\t\/\/ we need to dirty check many-to-ones with not-found=\"ignore\" in order\n\t\t\/\/ to update the cache (not the database), since in this case a null\n\t\t\/\/ entity reference can lose information\n\n\t\tfinal boolean alwaysDirtyCheck = type.isAssociationType() && ( (AssociationType) type ).isAlwaysDirtyChecked();\n\n\t\tif ( property.getAttribute().isSingular() ) {\n\t\t\tfinal SingularAttributeBinding singularAttributeBinding = ( SingularAttributeBinding ) property;\n\t\t\tfinal CascadeStyle cascadeStyle = singularAttributeBinding.isAssociation()\n\t\t\t\t\t? ( (AssociationAttributeBinding) singularAttributeBinding ).getCascadeStyle()\n\t\t\t\t\t: CascadeStyles.NONE;\n\t\t\tfinal FetchMode fetchMode = singularAttributeBinding.isAssociation()\n\t\t\t\t\t? ( (AssociationAttributeBinding) singularAttributeBinding ).getFetchMode()\n\t\t\t\t\t: FetchMode.DEFAULT;\n\n\t\t\treturn new StandardProperty(\n\t\t\t\t\tsingularAttributeBinding.getAttribute().getName(),\n\t\t\t\t\tnull,\n\t\t\t\t\ttype,\n\t\t\t\t\tlazyAvailable && singularAttributeBinding.isLazy(),\n\t\t\t\t\ttrue, \/\/ insertable\n\t\t\t\t\ttrue, \/\/ updatable\n\t\t\t\t\tsingularAttributeBinding.getGeneration() == PropertyGeneration.INSERT\n\t\t\t\t\t\t\t|| singularAttributeBinding.getGeneration() == PropertyGeneration.ALWAYS,\n\t\t\t\t\tsingularAttributeBinding.getGeneration() == PropertyGeneration.ALWAYS,\n\t\t\t\t\tsingularAttributeBinding.isNullable(),\n\t\t\t\t\talwaysDirtyCheck || areAllValuesIncludedInUpdate( singularAttributeBinding ),\n\t\t\t\t\tsingularAttributeBinding.isIncludedInOptimisticLocking(),\n\t\t\t\t\tcascadeStyle,\n\t\t\t\t\tfetchMode\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tfinal AbstractPluralAttributeBinding pluralAttributeBinding = (AbstractPluralAttributeBinding) property;\n\t\t\tfinal CascadeStyle cascadeStyle = pluralAttributeBinding.isAssociation()\n\t\t\t\t\t? pluralAttributeBinding.getCascadeStyle()\n\t\t\t\t\t: CascadeStyles.NONE;\n\t\t\tfinal FetchMode fetchMode = pluralAttributeBinding.isAssociation()\n\t\t\t\t\t? pluralAttributeBinding.getFetchMode()\n\t\t\t\t\t: FetchMode.DEFAULT;\n\n\t\t\treturn new StandardProperty(\n\t\t\t\t\tpluralAttributeBinding.getAttribute().getName(),\n\t\t\t\t\tnull,\n\t\t\t\t\ttype,\n\t\t\t\t\tlazyAvailable && pluralAttributeBinding.isLazy(),\n\t\t\t\t\t\/\/ TODO: fix this when HHH-6356 is fixed; for now assume AbstractPluralAttributeBinding is updatable and insertable\n\t\t\t\t\ttrue, \/\/ pluralAttributeBinding.isInsertable(),\n\t\t\t\t\ttrue, \/\/pluralAttributeBinding.isUpdatable(),\n\t\t\t\t\tfalse,\n\t\t\t\t\tfalse,\n\t\t\t\t\tfalse, \/\/ nullable - not sure what that means for a collection\n\t\t\t\t\t\/\/ TODO: fix this when HHH-6356 is fixed; for now assume AbstractPluralAttributeBinding is updatable and insertable\n\t\t\t\t\t\/\/alwaysDirtyCheck || pluralAttributeBinding.isUpdatable(),\n\t\t\t\t\ttrue,\n\t\t\t\t\tpluralAttributeBinding.isIncludedInOptimisticLocking(),\n\t\t\t\t\tcascadeStyle,\n\t\t\t\t\tfetchMode\n\t\t\t\t);\n\t\t}\n\t}\n","new_comment_raw":"@return The appropriate NonIdentifierProperty definition.","old_comment_raw":"@return The appropriate StandardProperty definition.","label":1,"pre_label":0,"AST_level":9,"line_counts":67,"new_code_token_num":413},{"new_code_raw":"public EigenbaseException newValidationSignatureError() { return validator.newValidationError(call, RESOURCE.canNotApplyOp2Type(getOperator().getName(), call.getCallSignature(validator, scope), getOperator().getAllowedSignatures())); }","old_code_raw":"  public EigenbaseException newValidationSignatureError() {\n    return validator.newValidationError(\n        call,\n        EigenbaseResource.instance().CanNotApplyOp2Type.ex(\n            getOperator().getName(),\n            call.getCallSignature(validator, scope),\n            getOperator().getAllowedSignatures()));\n  }\n","new_comment_raw":"@return signature exception","old_comment_raw":"@return signature exception","label":0,"pre_label":1,"AST_level":7,"line_counts":7,"new_code_token_num":40},{"new_code_raw":"public ActivityOptions getActivityLaunchOptions(Launcher launcher, View v) { if (hasControlRemoteAppTransitionPermission()) { try { RemoteAnimationRunnerCompat runner = new LauncherAnimationRunner(mLauncher) { @Override public void onAnimationStart(RemoteAnimationTargetCompat[] targets, Runnable finishedCallback) { \/\/ Post at front of queue ignoring sync barriers to make sure it gets \/\/ processed before the next frame. postAtFrontOfQueueAsynchronously(v.getHandler(), () -> { final boolean removeTrackingView; LauncherTransitionAnimator animator = composeRecentsLaunchAnimator(v, targets); if (animator != null) { \/\/ We are animating the task view directly, do not remove it after removeTrackingView = false; } else { animator = composeAppLaunchAnimator(v, targets); \/\/ A new floating view is created for the animation, remove it after removeTrackingView = true; } setCurrentAnimator(animator); mAnimator = animator.getAnimatorSet(); mAnimator.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { \/\/ Reset launcher to normal state v.setVisibility(View.VISIBLE); if (removeTrackingView) { ((ViewGroup) mDragLayer.getParent()).removeView( mFloatingView); } mDragLayer.setAlpha(1f); mDragLayer.setTranslationY(0f); View appsView = mLauncher.getAppsView(); appsView.setAlpha(1f); appsView.setTranslationY(0f); finishedCallback.run(); } }); mAnimator.start(); \/\/ Because t=0 has the app icon in its original spot, we can skip the \/\/ first frame and have the same movement one frame earlier. mAnimator.setCurrentPlayTime(REFRESH_RATE_MS); }); } }; return ActivityOptionsCompat.makeRemoteAnimation( new RemoteAnimationAdapterCompat(runner, 500, 380)); } catch (NoClassDefFoundError e) { \/\/ Gracefully fall back to default launch options if the user's platform doesn't \/\/ have the latest changes. } } return getDefaultActivityLaunchOptions(launcher, v); }","old_code_raw":"    public Bundle getActivityLaunchOptions(Launcher launcher, View v) {\n        if (hasControlRemoteAppTransitionPermission()) {\n            try {\n                RemoteAnimationRunnerCompat runner = new LauncherAnimationRunner(mLauncher) {\n                    @Override\n                    public void onAnimationStart(RemoteAnimationTargetCompat[] targets,\n                                                 Runnable finishedCallback) {\n                        \/\/ Post at front of queue ignoring sync barriers to make sure it gets\n                        \/\/ processed before the next frame.\n                        postAtFrontOfQueueAsynchronously(v.getHandler(), () -> {\n                            final boolean removeTrackingView;\n                            LauncherTransitionAnimator animator =\n                                    composeRecentsLaunchAnimator(v, targets);\n                            if (animator != null) {\n                                \/\/ We are animating the task view directly, do not remove it after\n                                removeTrackingView = false;\n                            } else {\n                                animator = composeAppLaunchAnimator(v, targets);\n                                \/\/ A new floating view is created for the animation, remove it after\n                                removeTrackingView = true;\n                            }\n\n                            setCurrentAnimator(animator);\n                            mAnimator = animator.getAnimatorSet();\n                            mAnimator.addListener(new AnimatorListenerAdapter() {\n                                @Override\n                                public void onAnimationEnd(Animator animation) {\n                                    \/\/ Reset launcher to normal state\n                                    v.setVisibility(View.VISIBLE);\n                                    if (removeTrackingView) {\n                                        ((ViewGroup) mDragLayer.getParent()).removeView(\n                                                mFloatingView);\n                                    }\n\n                                    mDragLayer.setAlpha(1f);\n                                    mDragLayer.setTranslationY(0f);\n\n                                    View appsView = mLauncher.getAppsView();\n                                    appsView.setAlpha(1f);\n                                    appsView.setTranslationY(0f);\n\n                                    finishedCallback.run();\n                                }\n                            });\n                            mAnimator.start();\n                            \/\/ Because t=0 has the app icon in its original spot, we can skip the\n                            \/\/ first frame and have the same movement one frame earlier.\n                            mAnimator.setCurrentPlayTime(REFRESH_RATE_MS);\n                        });\n                    }\n                };\n\n                return ActivityOptionsCompat.makeRemoteAnimation(\n                        new RemoteAnimationAdapterCompat(runner, 500, 380)).toBundle();\n            } catch (NoClassDefFoundError e) {\n                \/\/ Gracefully fall back to default launch options if the user's platform doesn't\n                \/\/ have the latest changes.\n            }\n        }\n        return getDefaultActivityLaunchOptions(launcher, v);\n    }\n","new_comment_raw":"@return ActivityOptions with remote animations that controls how the window of the opening targets are displayed.","old_comment_raw":"@return A Bundle with remote animations that controls how the window of the opening targets are displayed.","label":1,"pre_label":0,"AST_level":21,"line_counts":62,"new_code_token_num":351},{"new_code_raw":"public String getResourceManagerId() throws JMSException { if (isRmIdFromConnectionId()) { return info.getConnectionId().getValue(); } waitForBrokerInfo(); if (brokerInfo == null) { throw new JMSException(\"Connection failed before Broker info was received.\"); } return brokerInfo.getBrokerId().getValue(); }","old_code_raw":"    public String getResourceManagerId() throws JMSException {\n        waitForBrokerInfo();\n        if (brokerInfo == null) {\n            throw new JMSException(\"Connection failed before Broker info was received.\");\n        }\n        return brokerInfo.getBrokerId().getValue();\n    }\n","new_comment_raw":"@return Returns the resourceManagerId.","old_comment_raw":"@return Returns the resourceManagerId.","label":0,"pre_label":1,"AST_level":7,"line_counts":11,"new_code_token_num":61},{"new_code_raw":"public ActivityOptions getActivityLaunchOptions(Launcher launcher, View v) { if (hasControlRemoteAppTransitionPermission()) { TaskView taskView = findTaskViewToLaunch(launcher, v); try { RemoteAnimationRunnerCompat runner = new LauncherAnimationRunner(mLauncher) { @Override public void onAnimationStart(RemoteAnimationTargetCompat[] targets, Runnable finishedCallback) { \/\/ Post at front of queue ignoring sync barriers to make sure it gets \/\/ processed before the next frame. postAtFrontOfQueueAsynchronously(v.getHandler(), () -> { final boolean removeTrackingView; LauncherTransitionAnimator animator = composeRecentsLaunchAnimator( taskView == null ? v : taskView, targets); if (animator != null) { \/\/ We are animating the task view directly, do not remove it after removeTrackingView = false; } else { animator = composeAppLaunchAnimator(v, targets); \/\/ A new floating view is created for the animation, remove it after removeTrackingView = true; } setCurrentAnimator(animator); mAnimator = animator.getAnimatorSet(); mAnimator.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { \/\/ Reset launcher to normal state v.setVisibility(View.VISIBLE); if (removeTrackingView) { ((ViewGroup) mDragLayer.getParent()).removeView( mFloatingView); } mDragLayer.setAlpha(1f); mDragLayer.setTranslationY(0f); View appsView = mLauncher.getAppsView(); appsView.setAlpha(1f); appsView.setTranslationY(0f); finishedCallback.run(); } }); mAnimator.start(); \/\/ Because t=0 has the app icon in its original spot, we can skip the \/\/ first frame and have the same movement one frame earlier. mAnimator.setCurrentPlayTime(REFRESH_RATE_MS); }); } }; int duration = taskView != null ? RECENTS_LAUNCH_DURATION : APP_LAUNCH_DURATION; int statusBarTransitionDelay = duration - STATUS_BAR_TRANSITION_DURATION; return ActivityOptionsCompat.makeRemoteAnimation(new RemoteAnimationAdapterCompat( runner, duration, statusBarTransitionDelay)); } catch (NoClassDefFoundError e) { \/\/ Gracefully fall back to default launch options if the user's platform doesn't \/\/ have the latest changes. } } return getDefaultActivityLaunchOptions(launcher, v); }","old_code_raw":"    public ActivityOptions getActivityLaunchOptions(Launcher launcher, View v) {\n        if (hasControlRemoteAppTransitionPermission()) {\n            try {\n                RemoteAnimationRunnerCompat runner = new LauncherAnimationRunner(mLauncher) {\n                    @Override\n                    public void onAnimationStart(RemoteAnimationTargetCompat[] targets,\n                                                 Runnable finishedCallback) {\n                        \/\/ Post at front of queue ignoring sync barriers to make sure it gets\n                        \/\/ processed before the next frame.\n                        postAtFrontOfQueueAsynchronously(v.getHandler(), () -> {\n                            final boolean removeTrackingView;\n                            LauncherTransitionAnimator animator =\n                                    composeRecentsLaunchAnimator(v, targets);\n                            if (animator != null) {\n                                \/\/ We are animating the task view directly, do not remove it after\n                                removeTrackingView = false;\n                            } else {\n                                animator = composeAppLaunchAnimator(v, targets);\n                                \/\/ A new floating view is created for the animation, remove it after\n                                removeTrackingView = true;\n                            }\n\n                            setCurrentAnimator(animator);\n                            mAnimator = animator.getAnimatorSet();\n                            mAnimator.addListener(new AnimatorListenerAdapter() {\n                                @Override\n                                public void onAnimationEnd(Animator animation) {\n                                    \/\/ Reset launcher to normal state\n                                    v.setVisibility(View.VISIBLE);\n                                    if (removeTrackingView) {\n                                        ((ViewGroup) mDragLayer.getParent()).removeView(\n                                                mFloatingView);\n                                    }\n\n                                    mDragLayer.setAlpha(1f);\n                                    mDragLayer.setTranslationY(0f);\n\n                                    View appsView = mLauncher.getAppsView();\n                                    appsView.setAlpha(1f);\n                                    appsView.setTranslationY(0f);\n\n                                    finishedCallback.run();\n                                }\n                            });\n                            mAnimator.start();\n                            \/\/ Because t=0 has the app icon in its original spot, we can skip the\n                            \/\/ first frame and have the same movement one frame earlier.\n                            mAnimator.setCurrentPlayTime(REFRESH_RATE_MS);\n                        });\n                    }\n                };\n\n                return ActivityOptionsCompat.makeRemoteAnimation(\n                        new RemoteAnimationAdapterCompat(runner, 500, 380));\n            } catch (NoClassDefFoundError e) {\n                \/\/ Gracefully fall back to default launch options if the user's platform doesn't\n                \/\/ have the latest changes.\n            }\n        }\n        return getDefaultActivityLaunchOptions(launcher, v);\n    }\n","new_comment_raw":"@return ActivityOptions with remote animations that controls how the window of the opening targets are displayed.","old_comment_raw":"@return ActivityOptions with remote animations that controls how the window of the opening targets are displayed.","label":0,"pre_label":1,"AST_level":21,"line_counts":65,"new_code_token_num":381},{"new_code_raw":"protected String getUrlProtocol() { return STR + (getPort() > NUM ? getPort() : DEFAULT_PORT) + STR; }","old_code_raw":"protected String getUrlProtocol() {\n    return PROTOCOL;\n}","new_comment_raw":"@return Returns protocol","old_comment_raw":"@return Always returns {@link DerbyDatabase#PROTOCOL}.","label":1,"pre_label":0,"AST_level":8,"line_counts":3,"new_code_token_num":25},{"new_code_raw":"@Nullable public synchronized CloseableReference<Bitmap> cloneUnderlyingBitmapReference() { return CloseableReference.cloneOrNull(mBitmapReference); }","old_code_raw":"public synchronized CloseableReference<Bitmap> cloneUnderlyingBitmapReference() {\n    Preconditions.checkNotNull(mBitmapReference, STR);\n    return mBitmapReference.clone();\n}","new_comment_raw":"@return the cloned bitmap reference without altering this instance or null if already closed","old_comment_raw":"@return the cloned bitmap reference without altering this instance","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":18},{"new_code_raw":"public String toDefaultValue(Schema p) { if (p instanceof StringSchema) { StringSchema dp = (StringSchema) p; if (dp.getDefault() != null) { return \"@\\\"\" + dp.getDefault() + \"\\\"\"; } } else if (p instanceof BooleanSchema) { BooleanSchema dp = (BooleanSchema) p; if (dp.getDefault() != null) { if (dp.getDefault().toString().equalsIgnoreCase(\"false\")) return \"@(NO)\"; else return \"@(YES)\"; } } else if (p instanceof DateSchema) { \/\/ TODO } else if (p instanceof DateTimeSchema) { \/\/ TODO } else if (p instanceof NumberSchema) { NumberSchema dp = (NumberSchema) p; if (dp.getDefault() != null) { return \"@\" + dp.getDefault().toString(); } } else if (p instanceof IntegerSchema) { IntegerSchema dp = (IntegerSchema) p; if (dp.getDefault() != null) { return \"@\" + dp.getDefault().toString(); } } return null; }","old_code_raw":"    public String toDefaultValue(Property p) {\n        if (p instanceof StringProperty) {\n            StringProperty dp = (StringProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\\\"\" + dp.getDefault() + \"\\\"\";\n            }\n        } else if (p instanceof BooleanProperty) {\n            BooleanProperty dp = (BooleanProperty) p;\n            if (dp.getDefault() != null) {\n                if (dp.getDefault().toString().equalsIgnoreCase(\"false\"))\n                    return \"@(NO)\";\n                else\n                    return \"@(YES)\";\n            }\n        } else if (p instanceof DateProperty) {\n            \/\/ TODO\n        } else if (p instanceof DateTimeProperty) {\n            \/\/ TODO\n        } else if (p instanceof DoubleProperty) {\n            DoubleProperty dp = (DoubleProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        } else if (p instanceof FloatProperty) {\n            FloatProperty dp = (FloatProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        } else if (p instanceof IntegerProperty) {\n            IntegerProperty dp = (IntegerProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        } else if (p instanceof LongProperty) {\n            LongProperty dp = (LongProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        }\n\n        return null;\n    }\n","new_comment_raw":"@return string presentation of the default value of the schema","old_comment_raw":"@return string presentation of the default value of the property","label":1,"pre_label":0,"AST_level":15,"line_counts":33,"new_code_token_num":219},{"new_code_raw":"public Object next() throws java.io.IOException { int zzInput; int zzAction; \/\/ cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; \/\/ set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { \/\/ store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); \/\/ get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } \/\/ store back cached position zzMarkedPos = zzMarkedPosL; if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { String str = yytext(); int first = str.codePointAt(0); String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } logger.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: logger.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 67: break; case 2: { return getNext(\"<\", yytext()); } case 68: break; case 3: { return getNext(); } case 69: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 70: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 71: break; case 6: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 72: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 73: break; case 8: { return handleQuotes(yytext(), false); } case 74: break; case 9: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 75: break; case 10: { return getNext(\">\", yytext()); } case 76: break; case 11: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 77: break; case 12: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 78: break; case 13: { return handleEllipsis(yytext()); } case 79: break; case 14: { return normalizeFractions(yytext()); } case 80: break; case 15: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(minimallyNormalizeCurrency(yytext()), yytext()); } } case 81: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 82: break; case 17: { if (normalizeOtherBrackets) { return getNext(\"-RSB-\", yytext()); } else { return getNext(); } } case 83: break; case 18: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 84: break; case 19: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 85: break; case 20: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 86: break; case 21: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 87: break; case 22: { if (normalizeOtherBrackets) { return getNext(\"-LSB-\", yytext()); } else { return getNext(); } } case 88: break; case 23: { if (invertible) { prevWordAfter.append(yytext()); } } case 89: break; case 24: { return getNext(\"\\u2022\", yytext()); } case 90: break; case 25: { return getNext(\"\\u2122\", yytext()); } case 91: break; case 26: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 92: break; case 27: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(); } case 93: break; case 28: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return handleQuotes(yytext(), true); } case 94: break; case 29: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 95: break; case 30: { breakByHyphens(yytext()); return getNext(removeSoftHyphens(yytext()), yytext()); } case 96: break; case 31: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 97: break; case 32: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 98: break; case 33: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 99: break; case 34: { \/\/ this one should only match if we're basically at the end of file \/\/ since the last one matches two things, even newlines (if not tokenize per line) String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 100: break; case 35: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 101: break; case 36: \/\/ lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 1); { \/* invert quote - often but not always right *\/ return handleQuotes(yytext(), true); } case 102: break; case 37: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return handleQuotes(yytext(), false); } case 103: break; case 38: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 104: break; case 39: { String txt = yytext(); \/\/ if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space... if (strictTreebank3) { int spaceIndex = indexOfSpace(txt); if (spaceIndex >= 0) { yypushback(txt.length() - spaceIndex); String newText = yytext(); return getNext(newText, newText); } } if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, txt); } case 105: break; case 40: { return getNormalizedAmpNext(); } case 106: break; case 41: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, origTxt); } case 107: break; case 42: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space } return getNext(txt, origTxt); } case 108: break; case 43: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 109: break; case 44: { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 110: break; case 45: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 17; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 111: break; case 46: \/\/ lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 112: break; case 47: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 113: break; case 48: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 22; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 114: break; case 49: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 18; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 19; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 115: break; case 50: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 116: break; case 51: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 21; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 117: break; case 52: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 118: break; case 53: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { breakByHyphens(yytext()); return getNext(removeSoftHyphens(yytext()), yytext()); } case 119: break; case 54: { if (splitAssimilations) { yypushback(3) ; return getNext(); } else { return getNext(); } } case 120: break; case 55: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNormalizedAmpNext(); } case 121: break; case 56: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 9; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 122: break; case 57: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { return getNext(); } case 123: break; case 58: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 124: break; case 59: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 125: break; case 60: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 13; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 126: break; case 61: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } return getNext(txt, yytext()); } case 127: break; case 62: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4); { return getNext(); } case 128: break; case 63: \/\/ lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { return getNext(); } case 129: break; case 64: { String txt = yytext(); if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 130: break; case 65: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 25; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 131: break; case 66: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 24; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 132: break; default: zzScanError(ZZ_NO_MATCH); } } } }","old_code_raw":"  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    \/\/ cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      \/\/ set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            \/\/ store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            \/\/ get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      \/\/ store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n        zzAtEOF = true;\n              {\n                if (invertible) {\n            prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            prevWordAfter.setLength(0);\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n          }\n          return null;\n              }\n      }\n      else {\n        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n          case 1: \n            { String str = yytext();\n          int first = str.codePointAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n            }\n          case 67: break;\n          case 2: \n            { return getNext(\"<\", yytext());\n            }\n          case 68: break;\n          case 3: \n            { return getNext();\n            }\n          case 69: break;\n          case 4: \n            { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n            }\n          case 70: break;\n          case 5: \n            { if (tokenizeNLs) {\n                      return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns\n                  } else if (invertible) {\n                      prevWordAfter.append(yytext());\n                  }\n            }\n          case 71: break;\n          case 6: \n            { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n            }\n          case 72: break;\n          case 7: \n            { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n            }\n          case 73: break;\n          case 8: \n            { return handleQuotes(yytext(), false);\n            }\n          case 74: break;\n          case 9: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '\/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 75: break;\n          case 10: \n            { return getNext(\">\", yytext());\n            }\n          case 76: break;\n          case 11: \n            { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n            }\n          case 77: break;\n          case 12: \n            { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n            }\n          case 78: break;\n          case 13: \n            { return handleEllipsis(yytext());\n            }\n          case 79: break;\n          case 14: \n            { return normalizeFractions(yytext());\n            }\n          case 80: break;\n          case 15: \n            { if (normalizeCurrency) {\n                            return getNext(normalizeCurrency(yytext()), yytext());\n\t\t\t  } else {\n                            return getNext(minimallyNormalizeCurrency(yytext()), yytext());\n                          }\n            }\n          case 81: break;\n          case 16: \n            { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 82: break;\n          case 17: \n            { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 83: break;\n          case 18: \n            { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 84: break;\n          case 19: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 85: break;\n          case 20: \n            { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 86: break;\n          case 21: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-RSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 87: break;\n          case 22: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-LSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 88: break;\n          case 23: \n            { if (invertible) {\n                            prevWordAfter.append(yytext());\n                        }\n            }\n          case 89: break;\n          case 24: \n            { return getNext(\"\\u2022\", yytext());\n            }\n          case 90: break;\n          case 25: \n            { return getNext(\"\\u2122\", yytext());\n            }\n          case 91: break;\n          case 26: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 15;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 92: break;\n          case 27: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext();\n            }\n          case 93: break;\n          case 28: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return handleQuotes(yytext(), true);\n            }\n          case 94: break;\n          case 29: \n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 95: break;\n          case 30: \n            { breakByHyphens(yytext());\n                    return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 96: break;\n          case 31: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 3;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 4;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n            }\n          case 97: break;\n          case 32: \n            { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '\/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 98: break;\n          case 33: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 99: break;\n          case 34: \n            { \/\/ this one should only match if we're basically at the end of file\n                          \/\/ since the last one matches two things, even newlines (if not tokenize per line)\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n                          return getNext(s, yytext());\n            }\n          case 100: break;\n          case 35: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 101: break;\n          case 36: \n            \/\/ lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 1);\n            { \/* invert quote - often but not always right *\/\n                  return handleQuotes(yytext(), true);\n            }\n          case 102: break;\n          case 37: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return handleQuotes(yytext(), false);\n            }\n          case 103: break;\n          case 38: \n            { return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 104: break;\n          case 39: \n            { String txt = yytext();\n                  \/\/ if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space...\n                  if (strictTreebank3) {\n                    int spaceIndex = indexOfSpace(txt);\n                    if (spaceIndex >= 0) {\n                      yypushback(txt.length() - spaceIndex);\n                      String newText = yytext();\n                      return getNext(newText, newText);\n                    }\n                  }\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '\/');\n                  }\n                  if (normalizeSpace) {\n                    txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                  }\n                  return getNext(txt, txt);\n            }\n          case 105: break;\n          case 40: \n            { return getNormalizedAmpNext();\n            }\n          case 106: break;\n          case 41: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 107: break;\n          case 42: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 108: break;\n          case 43: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 5;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 6;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String txt = yytext();\n                          return getNext(removeSoftHyphens(txt),\n                                         txt);\n            }\n          case 109: break;\n          case 44: \n            { if (splitAssimilations) {\n                            yypushback(2) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 110: break;\n          case 45: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 17;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 111: break;\n          case 46: \n            \/\/ lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);\n            { if (splitAssimilations) {\n                            yypushback(2) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 112: break;\n          case 47: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 10;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 113: break;\n          case 48: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 22;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 114: break;\n          case 49: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 18;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 19;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 115: break;\n          case 50: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 10;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 116: break;\n          case 51: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 21;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 117: break;\n          case 52: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 118: break;\n          case 53: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { breakByHyphens(yytext());\n                    return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 119: break;\n          case 54: \n            { if (splitAssimilations) {\n                            yypushback(3) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 120: break;\n          case 55: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNormalizedAmpNext();\n            }\n          case 121: break;\n          case 56: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 9;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 122: break;\n          case 57: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { return getNext();\n            }\n          case 123: break;\n          case 58: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 14;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 124: break;\n          case 59: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 8;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 125: break;\n          case 60: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 13;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 126: break;\n          case 61: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 127: break;\n          case 62: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4);\n            { return getNext();\n            }\n          case 128: break;\n          case 63: \n            \/\/ lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);\n            { return getNext();\n            }\n          case 129: break;\n          case 64: \n            { String txt = yytext();\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 130: break;\n          case 65: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 23;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 25;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 131: break;\n          case 66: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 23;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 24;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 132: break;\n          default:\n            zzScanError(ZZ_NO_MATCH);\n        }\n      }\n    }\n  }\n","new_comment_raw":"@return the next token","old_comment_raw":"@return the next token","label":0,"pre_label":1,"AST_level":19,"line_counts":966,"new_code_token_num":6267},{"new_code_raw":"protected Object convertTimestampToEpochNanos(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0L; \/\/ return epoch } try { return NanoTimestamp.toEpochNanos(data); } catch (IllegalArgumentException e) { return handleUnknownData(column, fieldDefn, data); } }","old_code_raw":"    protected Object convertTimestampToEpochNanos(Column column, Field fieldDefn, Object data) {\n        if ( data == null ) return null;\n        try {\n            return NanoTimestamp.toEpochNanos(data);\n        } catch (IllegalArgumentException e) {\n            return handleUnknownData(column, fieldDefn, data);\n        }\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made","label":1,"pre_label":0,"AST_level":8,"line_counts":15,"new_code_token_num":82},{"new_code_raw":"public ApiResponse<Void> testBodyWithFileSchemaWithHttpInfo(FileSchemaTestClass body) throws ApiException { okhttp3.Call localVarCall = testBodyWithFileSchemaValidateBeforeCall(body, null, null); return localVarApiClient.execute(localVarCall); }","old_code_raw":"    public ApiResponse<Void> testBodyWithFileSchemaWithHttpInfo(FileSchemaTestClass body) throws ApiException {\n        okhttp3.Call call = testBodyWithFileSchemaValidateBeforeCall(body, null, null);\n        return apiClient.execute(call);\n    }\n","new_comment_raw":"@return ApiResponse&lt;Void&gt;","old_comment_raw":"@return ApiResponse&lt;Void&gt;","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":31},{"new_code_raw":"public PeriodPrinter toPrinter() { if (iNotPrinter) { return null; } return toFormatter().getPrinter(); }","old_code_raw":"    public PeriodPrinter toPrinter() {\n        return toFormatter().getPrinter();\n    }\n","new_comment_raw":"@return the newly created printer, null if builder cannot create a printer","old_comment_raw":"@return the newly created printer","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":24},{"new_code_raw":"protected String removeNonNameElementToCamelCase(final String name, final String nonNameElementPattern) { String result = Arrays.stream(name.split(nonNameElementPattern)) .map(StringUtils::capitalize) .collect(Collectors.joining(\"\")); if (result.length() > 0) { result = result.substring(0, 1).toLowerCase() + result.substring(1); } return result; }","old_code_raw":"    protected String removeNonNameElementToCamelCase(final String name, final String nonNameElementPattern) {\n        String result = StringUtils.join(Lists.transform(Lists.newArrayList(name.split(nonNameElementPattern)), new Function<String, String>() {\n            @Nullable\n            @Override\n            public String apply(String input) {\n                return StringUtils.capitalize(input);\n            }\n        }), \"\");\n        if (result.length() > 0) {\n            result = result.substring(0, 1).toLowerCase() + result.substring(1);\n        }\n        return result;\n    }\n","new_comment_raw":"@return camelized string","old_comment_raw":"@return camelized string","label":0,"pre_label":1,"AST_level":9,"line_counts":10,"new_code_token_num":73},{"new_code_raw":"public Connect getConnect() { return virConnect; }","old_code_raw":"public VirConnect getConnect() {\n    return virConnect;\n}","new_comment_raw":"@return the Connect object","old_comment_raw":"@return the VirConnect object","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":10},{"new_code_raw":"public boolean setTaskCompleted(List<FileDownloadTaskAtom> taskAtomList) { FileDownloadLog.w(this, \"If you invoked this method, please remove it directly feel free, \" + \"it doesn't need any longer\"); return true; }","old_code_raw":"    public boolean setTaskCompleted(List<FileDownloadTaskAtom> taskAtomList) {\n        return FileDownloadServiceProxy.getImpl().setTaskCompleted(taskAtomList);\n    }\n","new_comment_raw":"@return Whether is successful to update all tasks' status to the Filedownloader Engine. If one task atom among them is not match the Rules in FileDownloadMgr#obtainCompletedTaskShelfModel(String, String, long) will receive false, and non of them would be updated to DB.","old_comment_raw":"@return Whether is successful to update all tasks' status to the Filedownloader Engine. If one task atom among them is not match the Rules in com.liulishuo.filedownloader.services.FileDownloadMgr#obtainCompletedTaskShelfModel(String, String, long) will receive false, and non of them would be updated to DB.","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":45},{"new_code_raw":"public static MailboxMessage<HBaseId> messageMetaFromResult(Configuration conf, Result result) { HBaseMailboxMessage message = null; Flags flags = new Flags(); List<Property> propList = new ArrayList<Property>(); KeyValue[] keys = result.raw(); String mediaType = null, subType = null; Long modSeq = null, uid, bodyOctets = null, contentOctets = null, textualLineCount = null; Date internalDate = null; int i = NUM; if (Bytes.equals(keys[i].getQualifier(), MESSAGE_BODY_OCTETS)) { bodyOctets = Bytes.toLong(keys[i].getValue()); i++; } if (Bytes.equals(keys[i].getQualifier(), MESSAGE_CONTENT_OCTETS)) { contentOctets = Bytes.toLong(keys[i].getValue()); i++; } if (Bytes.equals(keys[i].getQualifier(), MESSAGE_INTERNALDATE)) { internalDate = new Date(Bytes.toLong(keys[i].getValue())); i++; } if (Bytes.equals(keys[i].getQualifier(), MESSAGE_TEXT_LINE_COUNT)) { textualLineCount = Bytes.toLong(keys[i].getValue()); i++; } if (Bytes.equals(keys[i].getQualifier(), MESSAGE_MODSEQ)) { modSeq = Bytes.toLong(keys[i].getValue()); i++; } if (Bytes.equals(keys[i].getQualifier(), MESSAGE_MEDIA_TYPE)) { mediaType = Bytes.toString(keys[i].getValue()); i++; } if (Bytes.equals(keys[i].getQualifier(), MESSAGE_SUB_TYPE)) { subType = Bytes.toString(keys[i].getValue()); i++; } if (i < NUM) { throw new RuntimeException(STR); } while (i < keys.length) { if (Bytes.startsWith(keys[i].getQualifier(), PREFIX_PROP_B)) { propList.add(getProperty(keys[i].getValue())); } else if (Bytes.startsWith(keys[i].getQualifier(), PREFIX_SFLAGS_B)) { if (Bytes.equals(MARKER_PRESENT, keys[i].getValue())) { flags.add(systemFlagFromBytes(keys[i].getQualifier())); } } else if (Bytes.startsWith(keys[i].getQualifier(), PREFIX_UFLAGS_B)) { flags.add(userFlagFromBytes(keys[i].getQualifier())); } i++; } HBaseId uuid = HBaseIdFromRowKey(result.getRow()); uid = Long.MAX_VALUE - Bytes.toLong(result.getRow(), NUM); PropertyBuilder props = new PropertyBuilder(propList); props.setMediaType(mediaType); props.setSubType(subType); message = new HBaseMailboxMessage(conf, uuid, internalDate, flags, contentOctets, (int) (contentOctets - bodyOctets), props); message.setUid(uid); message.setModSeq(modSeq); message.setTextualLineCount(textualLineCount); return message; }","old_code_raw":"public static Message<HBaseId> messageMetaFromResult(Configuration conf, Result result) {\n    HBaseMessage message = null;\n    Flags flags = new Flags();\n    List<Property> propList = new ArrayList<Property>();\n    KeyValue[] keys = result.raw();\n    String mediaType = null, subType = null;\n    Long modSeq = null, uid, bodyOctets = null, contentOctets = null, textualLineCount = null;\n    Date internalDate = null;\n    int i = NUM;\n    if (Bytes.equals(keys[i].getQualifier(), MESSAGE_BODY_OCTETS)) {\n        bodyOctets = Bytes.toLong(keys[i].getValue());\n        i++;\n    }\n    if (Bytes.equals(keys[i].getQualifier(), MESSAGE_CONTENT_OCTETS)) {\n        contentOctets = Bytes.toLong(keys[i].getValue());\n        i++;\n    }\n    if (Bytes.equals(keys[i].getQualifier(), MESSAGE_INTERNALDATE)) {\n        internalDate = new Date(Bytes.toLong(keys[i].getValue()));\n        i++;\n    }\n    if (Bytes.equals(keys[i].getQualifier(), MESSAGE_TEXT_LINE_COUNT)) {\n        textualLineCount = Bytes.toLong(keys[i].getValue());\n        i++;\n    }\n    if (Bytes.equals(keys[i].getQualifier(), MESSAGE_MODSEQ)) {\n        modSeq = Bytes.toLong(keys[i].getValue());\n        i++;\n    }\n    if (Bytes.equals(keys[i].getQualifier(), MESSAGE_MEDIA_TYPE)) {\n        mediaType = Bytes.toString(keys[i].getValue());\n        i++;\n    }\n    if (Bytes.equals(keys[i].getQualifier(), MESSAGE_SUB_TYPE)) {\n        subType = Bytes.toString(keys[i].getValue());\n        i++;\n    }\n    if (i < NUM) {\n        throw new RuntimeException(STR);\n    }\n    while (i < keys.length) {\n        if (Bytes.startsWith(keys[i].getQualifier(), PREFIX_PROP_B)) {\n            propList.add(getProperty(keys[i].getValue()));\n        } else if (Bytes.startsWith(keys[i].getQualifier(), PREFIX_SFLAGS_B)) {\n            if (Bytes.equals(MARKER_PRESENT, keys[i].getValue())) {\n                flags.add(systemFlagFromBytes(keys[i].getQualifier()));\n            }\n        } else if (Bytes.startsWith(keys[i].getQualifier(), PREFIX_UFLAGS_B)) {\n            flags.add(userFlagFromBytes(keys[i].getQualifier()));\n        }\n        i++;\n    }\n    HBaseId uuid = HBaseIdFromRowKey(result.getRow());\n    uid = Long.MAX_VALUE - Bytes.toLong(result.getRow(), NUM);\n    PropertyBuilder props = new PropertyBuilder(propList);\n    props.setMediaType(mediaType);\n    props.setSubType(subType);\n    message = new HBaseMessage(conf, uuid, internalDate, flags, contentOctets, (int) (contentOctets - bodyOctets), props);\n    message.setUid(uid);\n    message.setModSeq(modSeq);\n    message.setTextualLineCount(textualLineCount);\n    return message;\n}","new_comment_raw":"@return a HBaseMailboxMessage instance with message metadata.","old_comment_raw":"@return a HBaseMessage instance with message metadata.","label":1,"pre_label":0,"AST_level":15,"line_counts":63,"new_code_token_num":559},{"new_code_raw":"public Object getValue(PgProto.DatumMessage datumMessage, PgConnectionSupplier connection, boolean includeUnknownDatatypes) { if (datumMessage.hasDatumMissing()) { return UnchangedToastedReplicationMessageColumn.UNCHANGED_TOAST_VALUE; } int columnType = (int) datumMessage.getColumnType(); switch (columnType) { case PgOid.BOOL: return datumMessage.hasDatumBool() ? datumMessage.getDatumBool() : null; case PgOid.INT2: case PgOid.INT4: return datumMessage.hasDatumInt32() ? datumMessage.getDatumInt32() : null; case PgOid.INT8: case PgOid.OID: case PgOid.MONEY: return datumMessage.hasDatumInt64() ? datumMessage.getDatumInt64() : null; case PgOid.FLOAT4: return datumMessage.hasDatumFloat()? datumMessage.getDatumFloat() : null; case PgOid.FLOAT8: return datumMessage.hasDatumDouble() ? datumMessage.getDatumDouble() : null; case PgOid.NUMERIC: if (datumMessage.hasDatumDouble()) { \/\/ For backwards compatibility only to enable independent upgrade of Postgres plug-in return datumMessage.getDatumDouble(); } else if (datumMessage.hasDatumString()) { final String s = datumMessage.getDatumString(); return PostgresValueConverter.toSpecialValue(s).orElseGet(() -> new SpecialValueDecimal(new BigDecimal(s))); } return null; case PgOid.CHAR: case PgOid.VARCHAR: case PgOid.BPCHAR: case PgOid.TEXT: case PgOid.JSON: case PgOid.JSONB_OID: case PgOid.XML: case PgOid.UUID: case PgOid.BIT: case PgOid.VARBIT: case PgOid.INET_OID: case PgOid.CIDR_OID: case PgOid.MACADDR_OID: case PgOid.MACADDR8_OID: return datumMessage.hasDatumString() ? datumMessage.getDatumString() : null; case PgOid.DATE: return datumMessage.hasDatumInt32() ? (long) datumMessage.getDatumInt32() : null; case PgOid.TIMESTAMP: if (!datumMessage.hasDatumInt64()) { return null; } \/\/ these types are sent by the plugin as LONG - microseconds since Unix Epoch return Conversions.toInstantFromMicros(datumMessage.getDatumInt64()); case PgOid.TIMESTAMPTZ: if (!datumMessage.hasDatumInt64()) { return null; } \/\/ these types are sent by the plugin as LONG - microseconds since Unix Epoch return Conversions.toInstantFromMicros(datumMessage.getDatumInt64()).atOffset(ZoneOffset.UTC); case PgOid.TIME: if (!datumMessage.hasDatumInt64()) { return null; } \/\/ these types are sent by the plugin as LONG - microseconds since Unix Epoch return Duration.of(datumMessage.getDatumInt64(), ChronoUnit.MICROS); case PgOid.TIMETZ: if (!datumMessage.hasDatumDouble()) { return null; } \/\/ the value is sent as a double microseconds return Conversions.toInstantFromMicros((long) datumMessage.getDatumDouble()) .atOffset(ZoneOffset.UTC) .toOffsetTime(); case PgOid.INTERVAL: \/\/ these are sent as doubles by the plugin since their storage is larger than 8 bytes return datumMessage.hasDatumDouble() ? datumMessage.getDatumDouble() : null; \/\/ the plugin will send back a TZ formatted string case PgOid.BYTEA: return datumMessage.hasDatumBytes() ? datumMessage.getDatumBytes().toByteArray() : null; case PgOid.POINT: { PgProto.Point datumPoint = datumMessage.getDatumPoint(); return new PGpoint(datumPoint.getX(), datumPoint.getY()); } case PgOid.TSRANGE_OID: case PgOid.TSTZRANGE_OID: case PgOid.DATERANGE_OID: case PgOid.INT4RANGE_OID: case PgOid.NUM_RANGE_OID: case PgOid.INT8RANGE_OID: return datumMessage.hasDatumBytes() ? new String(datumMessage.getDatumBytes().toByteArray(), Charset.forName(\"UTF-8\")) : null; case PgOid.INT2_ARRAY: case PgOid.INT4_ARRAY: case PgOid.INT8_ARRAY: case PgOid.TEXT_ARRAY: case PgOid.NUMERIC_ARRAY: case PgOid.FLOAT4_ARRAY: case PgOid.FLOAT8_ARRAY: case PgOid.BOOL_ARRAY: case PgOid.DATE_ARRAY: case PgOid.TIME_ARRAY: case PgOid.TIMETZ_ARRAY: case PgOid.TIMESTAMP_ARRAY: case PgOid.TIMESTAMPTZ_ARRAY: case PgOid.BYTEA_ARRAY: case PgOid.VARCHAR_ARRAY: case PgOid.OID_ARRAY: case PgOid.BPCHAR_ARRAY: case PgOid.MONEY_ARRAY: case PgOid.NAME_ARRAY: case PgOid.INTERVAL_ARRAY: case PgOid.CHAR_ARRAY: case PgOid.VARBIT_ARRAY: case PgOid.UUID_ARRAY: case PgOid.XML_ARRAY: case PgOid.POINT_ARRAY: case PgOid.JSONB_ARRAY: case PgOid.JSON_ARRAY: case PgOid.REF_CURSOR_ARRAY: case PgOid.INET_ARRAY: case PgOid.CIDR_ARRAY: case PgOid.MACADDR_ARRAY: case PgOid.MACADDR8_ARRAY: case PgOid.TSRANGE_ARRAY: case PgOid.TSTZRANGE_ARRAY: case PgOid.DATERANGE_ARRAY: case PgOid.INT4RANGE_ARRAY: case PgOid.NUM_RANGE_ARRAY: case PgOid.INT8RANGE_ARRAY: return getArray(datumMessage, connection, columnType); case PgOid.UNSPECIFIED: return null; default: PostgresType type = typeRegistry.get(columnType); if (type.getOid() == typeRegistry.geometryOid() || type.getOid() == typeRegistry.geographyOid() || type.getOid() == typeRegistry.citextOid() ) { return datumMessage.getDatumBytes().toByteArray(); } if(type.getOid() == typeRegistry.hstoreOid()) { return datumMessage.getDatumBytes().toByteArray(); } if (type.getOid() == typeRegistry.geometryArrayOid() || type.getOid() == typeRegistry.geographyArrayOid() || type.getOid() == typeRegistry.citextArrayOid() || type.getOid() == typeRegistry.hstoreArrayOid()) { return getArray(datumMessage, connection, columnType); } \/\/ unknown data type is sent by decoder as binary value if (includeUnknownDatatypes && datumMessage.hasDatumBytes()) { return datumMessage.getDatumBytes().toByteArray(); } return null; } }","old_code_raw":"    public Object getValue(PgProto.DatumMessage datumMessage, PgConnectionSupplier connection, boolean includeUnknownDatatypes) {\n        if (datumMessage.hasDatumMissing()) {\n            return ToastedReplicationMessageColumn.UNCHANGED_TOAST_VALUE;\n        }\n\n        int columnType = (int) datumMessage.getColumnType();\n        switch (columnType) {\n            case PgOid.BOOL:\n                return datumMessage.hasDatumBool() ? datumMessage.getDatumBool() : null;\n            case PgOid.INT2:\n            case PgOid.INT4:\n                return datumMessage.hasDatumInt32() ? datumMessage.getDatumInt32() : null;\n            case PgOid.INT8:\n            case PgOid.OID:\n            case PgOid.MONEY:\n                return datumMessage.hasDatumInt64() ? datumMessage.getDatumInt64() : null;\n            case PgOid.FLOAT4:\n                return datumMessage.hasDatumFloat()? datumMessage.getDatumFloat() : null;\n            case PgOid.FLOAT8:\n                return datumMessage.hasDatumDouble() ? datumMessage.getDatumDouble() : null;\n            case PgOid.NUMERIC:\n                if (datumMessage.hasDatumDouble()) {\n                    \/\/ For backwards compatibility only to enable independent upgrade of Postgres plug-in\n                    return datumMessage.getDatumDouble();\n                }\n                else if (datumMessage.hasDatumString()) {\n                    final String s = datumMessage.getDatumString();\n                    return PostgresValueConverter.toSpecialValue(s).orElseGet(() -> new SpecialValueDecimal(new BigDecimal(s)));\n                }\n                return null;\n            case PgOid.CHAR:\n            case PgOid.VARCHAR:\n            case PgOid.BPCHAR:\n            case PgOid.TEXT:\n            case PgOid.JSON:\n            case PgOid.JSONB_OID:\n            case PgOid.XML:\n            case PgOid.UUID:\n            case PgOid.BIT:\n            case PgOid.VARBIT:\n            case PgOid.INET_OID:\n            case PgOid.CIDR_OID:\n            case PgOid.MACADDR_OID:\n            case PgOid.MACADDR8_OID:\n                return datumMessage.hasDatumString() ? datumMessage.getDatumString() : null;\n            case PgOid.DATE:\n                return datumMessage.hasDatumInt32() ? (long) datumMessage.getDatumInt32() : null;\n            case PgOid.TIMESTAMP:\n                if (!datumMessage.hasDatumInt64()) {\n                    return null;\n                }\n                \/\/ these types are sent by the plugin as LONG - microseconds since Unix Epoch\n                return Conversions.toInstantFromMicros(datumMessage.getDatumInt64());\n            case PgOid.TIMESTAMPTZ:\n                if (!datumMessage.hasDatumInt64()) {\n                    return null;\n                }\n                \/\/ these types are sent by the plugin as LONG - microseconds since Unix Epoch\n                return Conversions.toInstantFromMicros(datumMessage.getDatumInt64()).atOffset(ZoneOffset.UTC);\n            case PgOid.TIME:\n                if (!datumMessage.hasDatumInt64()) {\n                    return null;\n                }\n\n                \/\/ these types are sent by the plugin as LONG - microseconds since Unix Epoch\n                return Duration.of(datumMessage.getDatumInt64(), ChronoUnit.MICROS);\n            case PgOid.TIMETZ:\n                if (!datumMessage.hasDatumDouble()) {\n                    return null;\n                }\n                \/\/ the value is sent as a double microseconds\n                return Conversions.toInstantFromMicros((long) datumMessage.getDatumDouble())\n                        .atOffset(ZoneOffset.UTC)\n                        .toOffsetTime();\n            case PgOid.INTERVAL:\n                \/\/ these are sent as doubles by the plugin since their storage is larger than 8 bytes\n                return datumMessage.hasDatumDouble() ? datumMessage.getDatumDouble() : null;\n            \/\/ the plugin will send back a TZ formatted string\n            case PgOid.BYTEA:\n                return datumMessage.hasDatumBytes() ? datumMessage.getDatumBytes().toByteArray() : null;\n            case PgOid.POINT: {\n                PgProto.Point datumPoint = datumMessage.getDatumPoint();\n                return new PGpoint(datumPoint.getX(), datumPoint.getY());\n            }\n            case PgOid.TSRANGE_OID:\n            case PgOid.TSTZRANGE_OID:\n            case PgOid.DATERANGE_OID:\n            case PgOid.INT4RANGE_OID:\n            case PgOid.NUM_RANGE_OID:\n            case PgOid.INT8RANGE_OID:\n                return datumMessage.hasDatumBytes() ? new String(datumMessage.getDatumBytes().toByteArray(), Charset.forName(\"UTF-8\")) : null;\n            case PgOid.INT2_ARRAY:\n            case PgOid.INT4_ARRAY:\n            case PgOid.INT8_ARRAY:\n            case PgOid.TEXT_ARRAY:\n            case PgOid.NUMERIC_ARRAY:\n            case PgOid.FLOAT4_ARRAY:\n            case PgOid.FLOAT8_ARRAY:\n            case PgOid.BOOL_ARRAY:\n            case PgOid.DATE_ARRAY:\n            case PgOid.TIME_ARRAY:\n            case PgOid.TIMETZ_ARRAY:\n            case PgOid.TIMESTAMP_ARRAY:\n            case PgOid.TIMESTAMPTZ_ARRAY:\n            case PgOid.BYTEA_ARRAY:\n            case PgOid.VARCHAR_ARRAY:\n            case PgOid.OID_ARRAY:\n            case PgOid.BPCHAR_ARRAY:\n            case PgOid.MONEY_ARRAY:\n            case PgOid.NAME_ARRAY:\n            case PgOid.INTERVAL_ARRAY:\n            case PgOid.CHAR_ARRAY:\n            case PgOid.VARBIT_ARRAY:\n            case PgOid.UUID_ARRAY:\n            case PgOid.XML_ARRAY:\n            case PgOid.POINT_ARRAY:\n            case PgOid.JSONB_ARRAY:\n            case PgOid.JSON_ARRAY:\n            case PgOid.REF_CURSOR_ARRAY:\n            case PgOid.INET_ARRAY:\n            case PgOid.CIDR_ARRAY:\n            case PgOid.MACADDR_ARRAY:\n            case PgOid.MACADDR8_ARRAY:\n            case PgOid.TSRANGE_ARRAY:\n            case PgOid.TSTZRANGE_ARRAY:\n            case PgOid.DATERANGE_ARRAY:\n            case PgOid.INT4RANGE_ARRAY:\n            case PgOid.NUM_RANGE_ARRAY:\n            case PgOid.INT8RANGE_ARRAY:\n            return getArray(datumMessage, connection, columnType);\n\n            case PgOid.UNSPECIFIED:\n                return null;\n\n            default:\n                PostgresType type = typeRegistry.get(columnType);\n                if (type.getOid() == typeRegistry.geometryOid() || type.getOid() == typeRegistry.geographyOid() || type.getOid() == typeRegistry.citextOid() ) {\n                    return datumMessage.getDatumBytes().toByteArray();\n                }\n                if(type.getOid() == typeRegistry.hstoreOid()) {\n                    return datumMessage.getDatumBytes().toByteArray();\n                }\n                if (type.getOid() == typeRegistry.geometryArrayOid() ||\n                        type.getOid() == typeRegistry.geographyArrayOid() ||\n                        type.getOid() == typeRegistry.citextArrayOid() ||\n                        type.getOid() == typeRegistry.hstoreArrayOid()) {\n                    return getArray(datumMessage, connection, columnType);\n                }\n                \/\/ unknown data type is sent by decoder as binary value\n                if (includeUnknownDatatypes && datumMessage.hasDatumBytes()) {\n                    return datumMessage.getDatumBytes().toByteArray();\n                }\n\n                return null;\n        }\n    }\n","new_comment_raw":"@return the value; may be null","old_comment_raw":"@return the value; may be null","label":0,"pre_label":1,"AST_level":14,"line_counts":157,"new_code_token_num":974},{"new_code_raw":"public String[] getHistory(String historyId) { Assert.isNotNull(historyId); List<String> entries = history.get(historyId); if (entries == null) { entries = new ArrayList<String>(); } return entries.toArray(new String[entries.size()]); }","old_code_raw":"public String[] getHistory(String historyId) {\n    Assert.isNotNull(historyId);\n    List<String> ids = history.get(historyId);\n    if (ids == null) {\n        ids = new ArrayList<String>();\n    }\n    return ids.toArray(new String[ids.size()]);\n}","new_comment_raw":"@return The list of entries within the history ids list or an empty list.","old_comment_raw":"@return The list of ids within the history ids list or an empty list.","label":1,"pre_label":0,"AST_level":10,"line_counts":8,"new_code_token_num":54},{"new_code_raw":"public int update(Object[] before, Object[] after, long ts, int rowNumber, int numberOfRows) throws InterruptedException { return converter.update(source, before, after, rowNumber, numberOfRows, includedColumns, ts, consumer); }","old_code_raw":"        public int update(Object[] before, Object[] after, long ts, int rowNumber) throws InterruptedException {\n            return converter.update(source, before, after, rowNumber, includedColumns, ts, consumer);\n        }\n","new_comment_raw":"@return the number of records produced; will be 0 or more","old_comment_raw":"@return the number of records produced; will be 0 or more","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":48},{"new_code_raw":"public String ceDataschema() { return dataSchemaUrl; }","old_code_raw":"    public String ceDataschema() {\n        return (dataSchemaUrl == null) ? \"\" : dataSchemaUrl;\n    }\n","new_comment_raw":"@return the data schema url of CloudEvents envelope","old_comment_raw":"@return the data schema url of CloudEvents envelope","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"public Map<Integer, TaskInfo> mkTaskComponentAssignments(Map<Object, Object> conf, String topologyId) throws IOException, InvalidTopologyException, KeyNotFoundException { Map<Object, Object> stormConf = StormConfig.read_nimbus_topology_conf(topologyId, data.getBlobStore()); StormTopology rawTopology = StormConfig.read_nimbus_topology_code(topologyId, data.getBlobStore()); StormTopology topology = Common.system_topology(stormConf, rawTopology); return Common.mkTaskInfo(stormConf, topology, topologyId); }","old_code_raw":"public Map<Integer, TaskInfo> mkTaskComponentAssignments(Map<Object, Object> conf, String topologyid) throws IOException, InvalidTopologyException, KeyNotFoundException {\n    Map<Object, Object> stormConf = StormConfig.read_nimbus_topology_conf(topologyid, data.getBlobStore());\n    StormTopology stopology = StormConfig.read_nimbus_topology_code(topologyid, data.getBlobStore());\n    StormTopology topology = Common.system_topology(stormConf, stopology);\n    return Common.mkTaskInfo(stormConf, topology, topologyid);\n}","new_comment_raw":"@return Map[task id, component id]","old_comment_raw":"@return Map<Integer, String>: from taskid to componentid","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":74},{"new_code_raw":"public boolean isThisMyUrl(String url) { return isInstanceURL(url, applicationInfoManager.getInfo()); }","old_code_raw":"    public boolean isThisMyUrl(String url) {\n        InstanceInfo myInfo = applicationInfoManager.getInfo();\n        String hostName = hostFromUrl(url);\n        return hostName != null && hostName.equals(myInfo.getHostName());\n    }\n","new_comment_raw":"@return true, if the url represents the current node which is trying to replicate, false otherwise.","old_comment_raw":"@return true, if the url represents the current node which is trying to replicate, false otherwise.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"@RequestMapping(value = STR, method = { RequestMethod.POST }) @ResponseBody public CubeRequest saveCubeDesc(@RequestBody CubeRequest cubeRequest) { CubeDesc desc = deserializeCubeDesc(cubeRequest); if (desc == null) { cubeRequest.setMessage(STR); return cubeRequest; } String name = CubeService.getCubeNameFromDesc(desc.getName()); if (StringUtils.isEmpty(name)) { logger.info(STR); throw new BadRequestException(STR); } CubeInstance cubeInstance; try { desc.setUuid(UUID.randomUUID().toString()); String projectName = (null == cubeRequest.getProject()) ? ProjectInstance.DEFAULT_PROJECT_NAME : cubeRequest.getProject(); cubeInstance = cubeService.createCubeAndDesc(name, projectName, desc); } catch (Exception e) { logger.error(STR, e); throw new InternalErrorException(e.getLocalizedMessage(), e); } boolean createStreamingConfigSuccess = false, createKafkaConfigSuccess = false; StreamingConfig streamingConfig = null; KafkaConfig kafkaConfig = null; boolean isStreamingCube = cubeRequest.getStreamingCube() != null && cubeRequest.getStreamingCube().equals(STR); try { if (isStreamingCube) { streamingConfig = deserializeStreamingDesc(cubeRequest); kafkaConfig = deserializeKafkaDesc(cubeRequest); if (kafkaConfig == null) { cubeRequest.setMessage(STR); return cubeRequest; } if (streamingConfig == null) { cubeRequest.setMessage(STR); return cubeRequest; } try { streamingConfig.setUuid(UUID.randomUUID().toString()); streamingService.createStreamingConfig(streamingConfig); createStreamingConfigSuccess = true; } catch (IOException e) { logger.error(STR + e.getLocalizedMessage(), e); throw new InternalErrorException(STR + e.getLocalizedMessage()); } try { kafkaConfig.setUuid(UUID.randomUUID().toString()); kafkaConfigService.createKafkaConfig(kafkaConfig); createKafkaConfigSuccess = true; } catch (IOException e) { logger.error(STR + e.getLocalizedMessage(), e); throw new InternalErrorException(STR + e.getLocalizedMessage()); } } } finally { if (isStreamingCube) { if (createStreamingConfigSuccess == false || createKafkaConfigSuccess == false) { try { cubeService.deleteCube(cubeInstance); } catch (Exception ex) { throw new InternalErrorException(STR + STR + ex.getMessage(), ex); } if (createStreamingConfigSuccess == true) { try { streamingService.dropStreamingConfig(streamingConfig); } catch (IOException e) { throw new InternalErrorException(STR + e.getLocalizedMessage()); } } if (createKafkaConfigSuccess == true) { try { kafkaConfigService.dropKafkaConfig(kafkaConfig); } catch (IOException e) { throw new InternalErrorException(STR + e.getLocalizedMessage()); } } } } } cubeRequest.setUuid(desc.getUuid()); cubeRequest.setSuccessful(true); return cubeRequest; }","old_code_raw":"@RequestMapping(value = STR, method = { RequestMethod.POST })\n@ResponseBody\npublic CubeRequest saveCubeDesc(@RequestBody CubeRequest cubeRequest) {\n    MetadataManager metaManager = MetadataManager.getInstance(cubeService.getConfig());\n    DataModelDesc modelDesc = deserializeDataModelDesc(cubeRequest);\n    if (modelDesc == null) {\n        return errorRequest(cubeRequest, STR);\n    }\n    if (StringUtils.isEmpty(modelDesc.getName())) {\n        return errorRequest(cubeRequest, STR);\n    }\n    try {\n        DataModelDesc existingModel = metaManager.getDataModelDesc(modelDesc.getName());\n        if (existingModel == null) {\n            metaManager.createDataModelDesc(modelDesc);\n        } else {\n            modelDesc.setLastModified(existingModel.getLastModified());\n            metaManager.updateDataModelDesc(modelDesc);\n        }\n    } catch (IOException e) {\n        logger.error(STR + e.getLocalizedMessage(), e);\n        throw new InternalErrorException(STR + e.getLocalizedMessage());\n    }\n    CubeDesc desc = deserializeCubeDesc(cubeRequest);\n    if (desc == null) {\n        return cubeRequest;\n    }\n    if (StringUtils.isEmpty(desc.getName())) {\n        logger.info(STR);\n        return errorRequest(cubeRequest, STR);\n    }\n    try {\n        desc.setUuid(UUID.randomUUID().toString());\n        String projectName = (null == cubeRequest.getProject()) ? ProjectInstance.DEFAULT_PROJECT_NAME : cubeRequest.getProject();\n        CubeInstance createdCube = cubeService.createCubeAndDesc(desc.getName(), projectName, desc);\n        accessService.init(createdCube, AclPermission.ADMINISTRATION);\n        ProjectInstance project = cubeService.getProjectManager().getProject(projectName);\n        accessService.inherit(createdCube, project);\n    } catch (Exception e) {\n        logger.error(STR, e);\n        throw new InternalErrorException(e.getLocalizedMessage(), e);\n    }\n    cubeRequest.setUuid(desc.getUuid());\n    cubeRequest.setSuccessful(true);\n    return cubeRequest;\n}","new_comment_raw":"@return Table metadata array","old_comment_raw":"@return cubeRequest cube change request","label":1,"pre_label":0,"AST_level":15,"line_counts":84,"new_code_token_num":495},{"new_code_raw":"public static int getAnimationResource(int gravity, boolean isInAnimation) { switch (gravity) { case Gravity.BOTTOM: return isInAnimation ? R.anim.pickerview_slide_in_bottom : R.anim.pickerview_slide_out_bottom; } return INVALID; }","old_code_raw":"    public static int getAnimationResource(int gravity, boolean isInAnimation) {\n        switch (gravity) {\n            case Gravity.BOTTOM:\n                return isInAnimation ? R.anim.slide_in_bottom : R.anim.slide_out_bottom;\n        }\n        return INVALID;\n    }\n","new_comment_raw":"@return the id of the animation resource","old_comment_raw":"@return the id of the animation resource","label":0,"pre_label":1,"AST_level":7,"line_counts":8,"new_code_token_num":37},{"new_code_raw":"private ZapTextArea getTxtScope() { if (txtScope == null) { txtScope = new ZapTextArea(); txtScope.setLineWrap(true); txtScope.setRows(3); txtScope.setFont(new java.awt.Font(\"Dialog\", java.awt.Font.PLAIN, 11)); } return txtScope; }","old_code_raw":"\tprivate JTextArea getTxtScope() {\n\t\tif (txtScope == null) {\n\t\t\ttxtScope = new JTextArea();\n\t\t\ttxtScope.setLineWrap(true);\n\t\t\ttxtScope.setRows(3);\n\t\t\ttxtScope.setFont(new java.awt.Font(\"Dialog\", java.awt.Font.PLAIN, 11));\n\t\t}\n\t\treturn txtScope;\n\t}\n","new_comment_raw":"@return javax.swing.ZapTextArea","old_comment_raw":"@return javax.swing.JTextArea","label":1,"pre_label":0,"AST_level":10,"line_counts":10,"new_code_token_num":56},{"new_code_raw":"public boolean isRemove() { return command != null && command.getDataStructureType() == CommandTypes.MESSAGE_ACK && subscriptionName == null; }","old_code_raw":"    public boolean isRemove() {\n        return command != null && command.getDataStructureType() == CommandTypes.MESSAGE_ACK;\n    }\n","new_comment_raw":"@return true if a MessageAck command","old_comment_raw":"@return true if a MessageAck command","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":24}]